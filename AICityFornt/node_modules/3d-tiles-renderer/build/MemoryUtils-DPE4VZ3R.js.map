{"version":3,"file":"MemoryUtils-DPE4VZ3R.js","sources":["../src/three/renderer/math/GeoUtils.js","../src/three/renderer/math/Ellipsoid.js","../src/three/renderer/math/GeoConstants.js","../src/three/renderer/math/OBB.js","../src/three/renderer/math/EllipsoidRegion.js","../src/three/renderer/utils/MemoryUtils.js"],"sourcesContent":["import { Spherical, Vector3, MathUtils } from 'three';\n\nconst _spherical = new Spherical();\nconst _vec = new Vector3();\nconst _geoResults = {};\n\n// Cesium / 3D tiles Spheroid:\n// - Up is Z at 90 degrees latitude\n// - 0, 0 latitude, longitude is X axis\n//      Z\n//      |\n//      |\n//      .----- Y\n//     /\n//   X\n\n\n// Three.js Spherical Coordinates\n// - Up is Y at 90 degrees latitude\n// - 0, 0 latitude, longitude is Z\n//       Y\n//      |\n//      |\n//      .----- X\n//     /\n//   Z\n\nexport function swapToGeoFrame( target ) {\n\n\tconst { x, y, z } = target;\n\ttarget.x = z;\n\ttarget.y = x;\n\ttarget.z = y;\n\n}\n\nexport function swapToThreeFrame( target ) {\n\n\tconst { x, y, z } = target;\n\ttarget.z = x;\n\ttarget.x = y;\n\ttarget.y = z;\n\n}\n\nexport function sphericalPhiToLatitude( phi ) {\n\n\treturn - ( phi - Math.PI / 2 );\n\n}\n\nexport function latitudeToSphericalPhi( latitude ) {\n\n\treturn - latitude + Math.PI / 2;\n\n}\n\nfunction correctGeoCoordWrap( lat, lon, target = {} ) {\n\n\t_spherical.theta = lon;\n\t_spherical.phi = latitudeToSphericalPhi( lat );\n\t_vec.setFromSpherical( _spherical );\n\n\t_spherical.setFromVector3( _vec );\n\ttarget.lat = sphericalPhiToLatitude( _spherical.phi );\n\ttarget.lon = _spherical.theta;\n\treturn target;\n\n}\n\nfunction toHoursMinutesSecondsString( value, pos = 'E', neg = 'W' ) {\n\n\tconst direction = value < 0 ? neg : pos;\n\tvalue = Math.abs( value );\n\n\tconst hours = ~ ~ value;\n\n\tconst minDec = ( value - hours ) * 60;\n\tconst minutes = ~ ~ minDec;\n\n\tconst secDec = ( minDec - minutes ) * 60;\n\tconst seconds = ~ ~ secDec;\n\n\treturn `${ hours }° ${ minutes }' ${ seconds }\" ${ direction }`;\n\n}\n\nexport function toLatLonString( lat, lon, decimalFormat = false ) {\n\n\tconst result = correctGeoCoordWrap( lat, lon, _geoResults );\n\tlet latString, lonString;\n\tif ( decimalFormat ) {\n\n\t\tlatString = `${ ( MathUtils.RAD2DEG * result.lat ).toFixed( 4 ) }°`;\n\t\tlonString = `${ ( MathUtils.RAD2DEG * result.lon ).toFixed( 4 ) }°`;\n\n\t} else {\n\n\t\tlatString = toHoursMinutesSecondsString( MathUtils.RAD2DEG * result.lat, 'N', 'S' );\n\t\tlonString = toHoursMinutesSecondsString( MathUtils.RAD2DEG * result.lon, 'E', 'W' );\n\n\t}\n\n\treturn `${ latString } ${ lonString }`;\n\n}\n","import { Vector3, Spherical, MathUtils, Ray, Matrix4, Sphere, Euler } from 'three';\nimport { swapToGeoFrame, latitudeToSphericalPhi } from './GeoUtils.js';\n\nconst _spherical = new Spherical();\nconst _norm = new Vector3();\nconst _vec = new Vector3();\nconst _vec2 = new Vector3();\nconst _matrix = new Matrix4();\nconst _matrix2 = new Matrix4();\nconst _matrix3 = new Matrix4();\nconst _sphere = new Sphere();\nconst _euler = new Euler();\n\nconst _vecX = new Vector3();\nconst _vecY = new Vector3();\nconst _vecZ = new Vector3();\nconst _pos = new Vector3();\n\nconst _ray = new Ray();\n\nconst EPSILON12 = 1e-12;\nconst CENTER_EPS = 0.1;\n\nexport const ENU_FRAME = 0;\nexport const CAMERA_FRAME = 1;\nexport const OBJECT_FRAME = 2;\n\nexport class Ellipsoid {\n\n\tconstructor( x = 1, y = 1, z = 1 ) {\n\n\t\tthis.name = '';\n\t\tthis.radius = new Vector3( x, y, z );\n\n\t}\n\n\tintersectRay( ray, target ) {\n\n\t\t_matrix.makeScale( ...this.radius ).invert();\n\t\t_sphere.center.set( 0, 0, 0 );\n\t\t_sphere.radius = 1;\n\n\t\t_ray.copy( ray ).applyMatrix4( _matrix );\n\t\tif ( _ray.intersectSphere( _sphere, target ) ) {\n\n\t\t\t_matrix.makeScale( ...this.radius );\n\t\t\ttarget.applyMatrix4( _matrix );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// returns a frame with Z indicating altitude, Y pointing north, X pointing east\n\tgetEastNorthUpFrame( lat, lon, height, target ) {\n\n\t\tif ( height.isMatrix4 ) {\n\n\t\t\ttarget = height;\n\t\t\theight = 0;\n\n\t\t\tconsole.warn( 'Ellipsoid: The signature for \"getEastNorthUpFrame\" has changed.' );\n\n\t\t}\n\n\t\tthis.getEastNorthUpAxes( lat, lon, _vecX, _vecY, _vecZ );\n\t\tthis.getCartographicToPosition( lat, lon, height, _pos );\n\t\treturn target.makeBasis( _vecX, _vecY, _vecZ ).setPosition( _pos );\n\n\t}\n\n\t// returns a frame with z indicating altitude and az, el, roll rotation within that frame\n\t// - azimuth: measured off of true north, increasing towards \"east\" (z-axis)\n\t// - elevation: measured off of the horizon, increasing towards sky (x-axis)\n\t// - roll: rotation around northern axis (y-axis)\n\tgetOrientedEastNorthUpFrame( lat, lon, height, az, el, roll, target ) {\n\n\t\treturn this.getObjectFrame( lat, lon, height, az, el, roll, target, ENU_FRAME );\n\n\t}\n\n\t// returns a frame similar to the ENU frame but rotated to match three.js object and camera conventions\n\t// OBJECT_FRAME: oriented such that \"+Y\" is up and \"+Z\" is forward.\n\t// CAMERA_FRAME: oriented such that \"+Y\" is up and \"-Z\" is forward.\n\tgetObjectFrame( lat, lon, height, az, el, roll, target, frame = OBJECT_FRAME ) {\n\n\t\tthis.getEastNorthUpFrame( lat, lon, height, _matrix );\n\t\t_euler.set( el, roll, - az, 'ZXY' );\n\n\t\ttarget\n\t\t\t.makeRotationFromEuler( _euler )\n\t\t\t.premultiply( _matrix );\n\n\t\t// Add in the orientation adjustment for objects and cameras so \"forward\" and \"up\" are oriented\n\t\t// correctly\n\t\tif ( frame === CAMERA_FRAME ) {\n\n\t\t\t_euler.set( Math.PI / 2, 0, 0, 'XYZ' );\n\t\t\t_matrix2.makeRotationFromEuler( _euler );\n\t\t\ttarget.multiply( _matrix2 );\n\n\t\t} else if ( frame === OBJECT_FRAME ) {\n\n\t\t\t_euler.set( - Math.PI / 2, 0, Math.PI, 'XYZ' );\n\t\t\t_matrix2.makeRotationFromEuler( _euler );\n\t\t\ttarget.multiply( _matrix2 );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetCartographicFromObjectFrame( matrix, target, frame = OBJECT_FRAME ) {\n\n\t\t// if working with a frame that is not the ENU_FRAME then multiply in the\n\t\t// offset for a camera or object so \"forward\" and \"up\" are oriented correct\n\t\tif ( frame === CAMERA_FRAME ) {\n\n\t\t\t_euler.set( - Math.PI / 2, 0, 0, 'XYZ' );\n\t\t\t_matrix2.makeRotationFromEuler( _euler ).premultiply( matrix );\n\n\t\t} else if ( frame === OBJECT_FRAME ) {\n\n\t\t\t_euler.set( - Math.PI / 2, 0, Math.PI, 'XYZ' );\n\t\t\t_matrix2.makeRotationFromEuler( _euler ).premultiply( matrix );\n\n\t\t} else {\n\n\t\t\t_matrix2.copy( matrix );\n\n\t\t}\n\n\t\t// get the cartographic position of the frame\n\t\t_pos.setFromMatrixPosition( _matrix2 );\n\t\tthis.getPositionToCartographic( _pos, target );\n\n\t\t// get the relative rotation\n\t\tthis.getEastNorthUpFrame( target.lat, target.lon, 0, _matrix ).invert();\n\t\t_matrix2.premultiply( _matrix );\n\t\t_euler.setFromRotationMatrix( _matrix2, 'ZXY' );\n\n\t\ttarget.azimuth = - _euler.z;\n\t\ttarget.elevation = _euler.x;\n\t\ttarget.roll = _euler.y;\n\t\treturn target;\n\n\t}\n\n\tgetEastNorthUpAxes( lat, lon, vecEast, vecNorth, vecUp, point = _pos ) {\n\n\t\tthis.getCartographicToPosition( lat, lon, 0, point );\n\t\tthis.getCartographicToNormal( lat, lon, vecUp );\t\t// up\n\t\tvecEast.set( - point.y, point.x, 0 ).normalize();\t\t// east\n\t\tvecNorth.crossVectors( vecUp, vecEast ).normalize();\t// north\n\n\t}\n\n\t// azimuth: measured off of true north, increasing towards \"east\"\n\t// elevation: measured off of the horizon, increasing towards sky\n\t// roll: rotation around northern axis\n\tgetAzElRollFromRotationMatrix( lat, lon, rotationMatrix, target, frame = ENU_FRAME ) {\n\n\t\tconsole.warn( 'Ellipsoid: \"getAzElRollFromRotationMatrix\" is deprecated. Use \"getCartographicFromObjectFrame\", instead.' );\n\t\tthis.getCartographicToPosition( lat, lon, 0, _pos );\n\t\t_matrix3.copy( rotationMatrix ).setPosition( _pos );\n\n\t\tthis.getCartographicFromObjectFrame( _matrix3, target, frame );\n\t\tdelete target.height;\n\t\tdelete target.lat;\n\t\tdelete target.lon;\n\n\t\treturn target;\n\n\n\t}\n\n\tgetRotationMatrixFromAzElRoll( lat, lon, az, el, roll, target, frame = ENU_FRAME ) {\n\n\t\tconsole.warn( 'Ellipsoid: \"getRotationMatrixFromAzElRoll\" function has been deprecated. Use \"getObjectFrame\", instead.' );\n\n\t\tthis.getObjectFrame( lat, lon, 0, az, el, roll, target, frame );\n\t\ttarget.setPosition( 0, 0, 0 );\n\t\treturn target;\n\n\t}\n\n\tgetFrame( lat, lon, az, el, roll, height, target, frame = ENU_FRAME ) {\n\n\t\tconsole.warn( 'Ellipsoid: \"getFrame\" function has been deprecated. Use \"getObjectFrame\", instead.' );\n\t\treturn this.getObjectFrame( lat, lon, height, az, el, roll, target, frame );\n\n\t}\n\n\tgetCartographicToPosition( lat, lon, height, target ) {\n\n\t\t// From Cesium function Ellipsoid.cartographicToCartesian\n\t\t// https://github.com/CesiumGS/cesium/blob/665ec32e813d5d6fe906ec3e87187f6c38ed5e49/packages/engine/Source/core/renderer/Ellipsoid.js#L396\n\t\tthis.getCartographicToNormal( lat, lon, _norm );\n\n\t\tconst radius = this.radius;\n\t\t_vec.copy( _norm );\n\t\t_vec.x *= radius.x ** 2;\n\t\t_vec.y *= radius.y ** 2;\n\t\t_vec.z *= radius.z ** 2;\n\n\t\tconst gamma = Math.sqrt( _norm.dot( _vec ) );\n\t\t_vec.divideScalar( gamma );\n\n\t\treturn target.copy( _vec ).addScaledVector( _norm, height );\n\n\t}\n\n\tgetPositionToCartographic( pos, target ) {\n\n\t\t// From Cesium function Ellipsoid.cartesianToCartographic\n\t\t// https://github.com/CesiumGS/cesium/blob/665ec32e813d5d6fe906ec3e87187f6c38ed5e49/packages/engine/Source/core/renderer/Ellipsoid.js#L463\n\t\tthis.getPositionToSurfacePoint( pos, _vec );\n\t\tthis.getPositionToNormal( pos, _norm );\n\n\t\tconst heightDelta = _vec2.subVectors( pos, _vec );\n\n\t\ttarget.lon = Math.atan2( _norm.y, _norm.x );\n\t\ttarget.lat = Math.asin( _norm.z );\n\t\ttarget.height = Math.sign( heightDelta.dot( pos ) ) * heightDelta.length();\n\t\treturn target;\n\n\t}\n\n\tgetCartographicToNormal( lat, lon, target ) {\n\n\t\t_spherical.set( 1, latitudeToSphericalPhi( lat ), lon );\n\t\ttarget.setFromSpherical( _spherical ).normalize();\n\n\t\t// swap frame from the three.js frame to the geo coord frame\n\t\tswapToGeoFrame( target );\n\t\treturn target;\n\n\t}\n\n\tgetPositionToNormal( pos, target ) {\n\n\t\tconst radius = this.radius;\n\t\ttarget.copy( pos );\n\t\ttarget.x /= radius.x ** 2;\n\t\ttarget.y /= radius.y ** 2;\n\t\ttarget.z /= radius.z ** 2;\n\t\ttarget.normalize();\n\n\t\treturn target;\n\n\t}\n\n\tgetPositionToSurfacePoint( pos, target ) {\n\n\t\t// From Cesium function Ellipsoid.scaleToGeodeticSurface\n\t\t// https://github.com/CesiumGS/cesium/blob/d11b746e5809ac115fcff65b7b0c6bdfe81dcf1c/packages/engine/Source/core/renderer/scaleToGeodeticSurface.js#L25\n\t\tconst radius = this.radius;\n\t\tconst invRadiusSqX = 1 / ( radius.x ** 2 );\n\t\tconst invRadiusSqY = 1 / ( radius.y ** 2 );\n\t\tconst invRadiusSqZ = 1 / ( radius.z ** 2 );\n\n\t\tconst x2 = pos.x * pos.x * invRadiusSqX;\n\t\tconst y2 = pos.y * pos.y * invRadiusSqY;\n\t\tconst z2 = pos.z * pos.z * invRadiusSqZ;\n\n\t\t// Compute the squared ellipsoid norm.\n\t\tconst squaredNorm = x2 + y2 + z2;\n\t\tconst ratio = Math.sqrt( 1.0 / squaredNorm );\n\n\t\t// As an initial approximation, assume that the radial intersection is the projection point.\n\t\tconst intersection = _vec.copy( pos ).multiplyScalar( ratio );\n\t\tif ( squaredNorm < CENTER_EPS ) {\n\n\t\t\treturn ! isFinite( ratio ) ? null : target.copy( intersection );\n\n\t\t}\n\n\t\t// Use the gradient at the intersection point in place of the true unit normal.\n\t\t// The difference in magnitude will be absorbed in the multiplier.\n\t\tconst gradient = _vec2.set(\n\t\t\tintersection.x * invRadiusSqX * 2.0,\n\t\t\tintersection.y * invRadiusSqY * 2.0,\n\t\t\tintersection.z * invRadiusSqZ * 2.0\n\t\t);\n\n\t\t// Compute the initial guess at the normal vector multiplier, lambda.\n\t\tlet lambda = ( 1.0 - ratio ) * pos.length() / ( 0.5 * gradient.length() );\n\t\tlet correction = 0.0;\n\n\t\tlet func, denominator;\n\t\tlet xMultiplier, yMultiplier, zMultiplier;\n\t\tlet xMultiplier2, yMultiplier2, zMultiplier2;\n\t\tlet xMultiplier3, yMultiplier3, zMultiplier3;\n\n\t\tdo {\n\n\t\t\tlambda -= correction;\n\n\t\t\txMultiplier = 1.0 / ( 1.0 + lambda * invRadiusSqX );\n\t\t\tyMultiplier = 1.0 / ( 1.0 + lambda * invRadiusSqY );\n\t\t\tzMultiplier = 1.0 / ( 1.0 + lambda * invRadiusSqZ );\n\n\t\t\txMultiplier2 = xMultiplier * xMultiplier;\n\t\t\tyMultiplier2 = yMultiplier * yMultiplier;\n\t\t\tzMultiplier2 = zMultiplier * zMultiplier;\n\n\t\t\txMultiplier3 = xMultiplier2 * xMultiplier;\n\t\t\tyMultiplier3 = yMultiplier2 * yMultiplier;\n\t\t\tzMultiplier3 = zMultiplier2 * zMultiplier;\n\n\t\t\tfunc = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n\t\t\t// \"denominator\" here refers to the use of this expression in the velocity and acceleration\n\t\t\t// computations in the sections to follow.\n\t\t\tdenominator =\n\t\t\t\tx2 * xMultiplier3 * invRadiusSqX +\n\t\t\t\ty2 * yMultiplier3 * invRadiusSqY +\n\t\t\t\tz2 * zMultiplier3 * invRadiusSqZ;\n\n\t\t\tconst derivative = - 2.0 * denominator;\n\t\t\tcorrection = func / derivative;\n\n\t\t} while ( Math.abs( func ) > EPSILON12 );\n\n\t\treturn target.set(\n\t\t\tpos.x * xMultiplier,\n\t\t\tpos.y * yMultiplier,\n\t\t\tpos.z * zMultiplier\n\t\t);\n\n\t}\n\n\tcalculateHorizonDistance( latitude, elevation ) {\n\n\t\t// from https://aty.sdsu.edu/explain/atmos_refr/horizon.html\n\t\t// OG = sqrt ( 2 R h + h2 ) .\n\t\tconst effectiveRadius = this.calculateEffectiveRadius( latitude );\n\t\treturn Math.sqrt( 2 * effectiveRadius * elevation + elevation ** 2 );\n\n\t}\n\n\tcalculateEffectiveRadius( latitude ) {\n\n\t\t// This radius represents the distance from the center of the ellipsoid to the surface along the normal at the given latitude.\n\t\t// from https://en.wikipedia.org/wiki/Earth_radius#Prime_vertical\n\t\t// N = a / sqrt(1 - e^2 * sin^2(phi))\n\t\tconst semiMajorAxis = this.radius.x;\n\t\tconst semiMinorAxis = this.radius.z;\n\t\tconst eSquared = 1 - ( semiMinorAxis ** 2 / semiMajorAxis ** 2 );\n\t\tconst phi = latitude * MathUtils.DEG2RAD;\n\n\t\tconst sinPhiSquared = Math.sin( phi ) ** 2;\n\t\tconst N = semiMajorAxis / Math.sqrt( 1 - eSquared * sinPhiSquared );\n\t\treturn N;\n\n\t}\n\n\tgetPositionElevation( pos ) {\n\n\t\t// logic from \"getPositionToCartographic\"\n\t\tthis.getPositionToSurfacePoint( pos, _vec );\n\n\t\tconst heightDelta = _vec2.subVectors( pos, _vec );\n\t\treturn Math.sign( heightDelta.dot( pos ) ) * heightDelta.length();\n\n\t}\n\n\t// Returns an estimate of the closest point on the ellipsoid to the ray. Returns\n\t// the surface intersection if they collide.\n\tclosestPointToRayEstimate( ray, target ) {\n\n\t\tif ( this.intersectRay( ray, target ) ) {\n\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\t_matrix.makeScale( ...this.radius ).invert();\n\t\t\t_ray.copy( ray ).applyMatrix4( _matrix );\n\n\t\t\t_vec.set( 0, 0, 0 );\n\t\t\t_ray.closestPointToPoint( _vec, target ).normalize();\n\n\t\t\t_matrix.makeScale( ...this.radius );\n\t\t\treturn target.applyMatrix4( _matrix );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.radius.copy( source.radius );\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n","import { WGS84_RADIUS, WGS84_HEIGHT } from '3d-tiles-renderer/core';\nimport { Ellipsoid } from './Ellipsoid.js';\n\nexport const WGS84_ELLIPSOID = new Ellipsoid( WGS84_RADIUS, WGS84_RADIUS, WGS84_HEIGHT );\nWGS84_ELLIPSOID.name = 'WGS84 Earth';\n","import { Matrix4, Box3, Vector3, Plane, Ray } from 'three';\n\nconst _worldMin = new Vector3();\nconst _worldMax = new Vector3();\nconst _norm = new Vector3();\nconst _ray = new Ray();\n\nexport class OBB {\n\n\tconstructor( box = new Box3(), transform = new Matrix4() ) {\n\n\t\tthis.box = box.clone();\n\t\tthis.transform = transform.clone();\n\t\tthis.inverseTransform = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.planes = new Array( 6 ).fill().map( () => new Plane() );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.box.copy( source.box );\n\t\tthis.transform.copy( source.transform );\n\t\tthis.update();\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\t/**\n\t * Clamps the given point within the bounds of this OBB\n\t * @param {Vector3} point\n\t * @param {Vector3} result\n\t * @returns {Vector3}\n\t */\n\tclampPoint( point, result ) {\n\n\t\treturn result.copy( point )\n\t\t\t.applyMatrix4( this.inverseTransform )\n\t\t\t.clamp( this.box.min, this.box.max )\n\t\t\t.applyMatrix4( this.transform );\n\n\t}\n\n\t/**\n\t * Returns the distance from any edge of this OBB to the specified point.\n\t * If the point lies inside of this box, the distance will be 0.\n\t * @param {Vector3} point\n\t * @returns {number}\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _norm ).distanceTo( point );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\t_norm.copy( point ).applyMatrix4( this.inverseTransform );\n\t\treturn this.box.containsPoint( _norm );\n\n\t}\n\n\t// returns boolean indicating whether the ray has intersected the obb\n\tintersectsRay( ray ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\treturn _ray.intersectsBox( this.box );\n\n\t}\n\n\t// Sets \"target\" equal to the intersection point.\n\t// Returns \"null\" if no intersection found.\n\tintersectRay( ray, target ) {\n\n\t\t_ray.copy( ray ).applyMatrix4( this.inverseTransform );\n\t\tif ( _ray.intersectBox( this.box, target ) ) {\n\n\t\t\ttarget.applyMatrix4( this.transform );\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst { points, inverseTransform, transform, box } = this;\n\t\tinverseTransform.copy( transform ).invert();\n\n\t\tconst { min, max } = box;\n\t\tlet index = 0;\n\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\tpoints[ index ].set(\n\t\t\t\t\t\tx < 0 ? min.x : max.x,\n\t\t\t\t\t\ty < 0 ? min.y : max.y,\n\t\t\t\t\t\tz < 0 ? min.z : max.z,\n\t\t\t\t\t).applyMatrix4( transform );\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updatePlanes();\n\n\t}\n\n\tupdatePlanes() {\n\n\t\t_worldMin.copy( this.box.min ).applyMatrix4( this.transform );\n\t\t_worldMax.copy( this.box.max ).applyMatrix4( this.transform );\n\n\t\t_norm.set( 0, 0, 1 ).transformDirection( this.transform );\n\t\tthis.planes[ 0 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 1 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 0, 1, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 2 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 3 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t\t_norm.set( 1, 0, 0 ).transformDirection( this.transform );\n\t\tthis.planes[ 4 ].setFromNormalAndCoplanarPoint( _norm, _worldMin );\n\t\tthis.planes[ 5 ].setFromNormalAndCoplanarPoint( _norm, _worldMax ).negate();\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tthis.clampPoint( sphere.center, _norm );\n\t\treturn _norm.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsFrustum( frustum ) {\n\n\t\treturn this._intersectsPlaneShape( frustum.planes, frustum.points );\n\n\t}\n\n\tintersectsOBB( obb ) {\n\n\t\treturn this._intersectsPlaneShape( obb.planes, obb.points );\n\n\t}\n\n\t// takes a series of 6 planes that define and enclosed shape and the 8 points that lie at the corners\n\t// of that shape to determine whether the OBB is intersected with.\n\t_intersectsPlaneShape( otherPlanes, otherPoints ) {\n\n\t\tconst thisPoints = this.points;\n\t\tconst thisPlanes = this.planes;\n\n\t\t// based on three.js' Box3 \"intersects frustum\" function\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = otherPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = thisPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do the opposite check using the obb planes to avoid false positives\n\t\t// this check is not performed by three.js' AABB logic but helps prevent a lot incorrect intersection reports\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = thisPlanes[ i ];\n\t\t\tlet maxDistance = - Infinity;\n\t\t\tfor ( let j = 0; j < 8; j ++ ) {\n\n\t\t\t\tconst v = otherPoints[ j ];\n\t\t\t\tconst dist = plane.distanceToPoint( v );\n\t\t\t\tmaxDistance = maxDistance < dist ? dist : maxDistance;\n\n\t\t\t}\n\n\t\t\tif ( maxDistance < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n}\n","import { MathUtils, Matrix4 } from 'three';\nimport { Vector3 } from 'three';\nimport { Ellipsoid } from './Ellipsoid.js';\n\nconst PI = Math.PI;\nconst HALF_PI = PI / 2;\n\nconst _orthoX = new Vector3();\nconst _orthoY = new Vector3();\nconst _orthoZ = new Vector3();\nconst _invMatrix = new Matrix4();\n\nlet _poolIndex = 0;\nconst _pointsPool = [];\nfunction getVector( usePool = false ) {\n\n\tif ( ! usePool ) {\n\n\t\treturn new Vector3();\n\n\t}\n\n\tif ( ! _pointsPool[ _poolIndex ] ) {\n\n\t\t_pointsPool[ _poolIndex ] = new Vector3();\n\n\t}\n\n\t_poolIndex ++;\n\treturn _pointsPool[ _poolIndex - 1 ];\n\n}\n\nfunction resetPool() {\n\n\t_poolIndex = 0;\n\n}\n\nexport class EllipsoidRegion extends Ellipsoid {\n\n\tconstructor(\n\t\tx, y, z,\n\t\tlatStart = - HALF_PI, latEnd = HALF_PI,\n\t\tlonStart = 0, lonEnd = 2 * PI,\n\t\theightStart = 0, heightEnd = 0\n\t) {\n\n\t\tsuper( x, y, z );\n\t\tthis.latStart = latStart;\n\t\tthis.latEnd = latEnd;\n\t\tthis.lonStart = lonStart;\n\t\tthis.lonEnd = lonEnd;\n\t\tthis.heightStart = heightStart;\n\t\tthis.heightEnd = heightEnd;\n\n\t}\n\n\t_getPoints( usePool = false ) {\n\n\t\tconst {\n\t\t\tlatStart, latEnd,\n\t\t\tlonStart, lonEnd,\n\t\t\theightStart, heightEnd,\n\t\t} = this;\n\n\t\tconst midLat = MathUtils.mapLinear( 0.5, 0, 1, latStart, latEnd );\n\t\tconst midLon = MathUtils.mapLinear( 0.5, 0, 1, lonStart, lonEnd );\n\n\t\tconst lonOffset = Math.floor( lonStart / HALF_PI ) * HALF_PI;\n\t\tconst latlon = [\n\t\t\t[ - PI / 2, 0 ],\n\t\t\t[ PI / 2, 0 ],\n\t\t\t[ 0, lonOffset ],\n\t\t\t[ 0, lonOffset + PI / 2 ],\n\t\t\t[ 0, lonOffset + PI ],\n\t\t\t[ 0, lonOffset + 3 * PI / 2 ],\n\n\t\t\t[ latStart, lonEnd ],\n\t\t\t[ latEnd, lonEnd ],\n\t\t\t[ latStart, lonStart ],\n\t\t\t[ latEnd, lonStart ],\n\n\t\t\t[ 0, lonStart ],\n\t\t\t[ 0, lonEnd ],\n\n\t\t\t[ midLat, midLon ],\n\t\t\t[ latStart, midLon ],\n\t\t\t[ latEnd, midLon ],\n\t\t\t[ midLat, lonStart ],\n\t\t\t[ midLat, lonEnd ],\n\n\t\t];\n\n\t\tconst target = [];\n\t\tconst total = latlon.length;\n\n\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\tconst height = MathUtils.mapLinear( z, 0, 1, heightStart, heightEnd );\n\t\t\tfor ( let i = 0, l = total; i < l; i ++ ) {\n\n\t\t\t\tconst [ lat, lon ] = latlon[ i ];\n\t\t\t\tif ( lat >= latStart && lat <= latEnd && lon >= lonStart && lon <= lonEnd ) {\n\n\t\t\t\t\tconst v = getVector( usePool );\n\t\t\t\t\ttarget.push( v );\n\t\t\t\t\tthis.getCartographicToPosition( lat, lon, height, v );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( box, matrix ) {\n\n\t\tresetPool();\n\n\t\tconst {\n\t\t\tlatStart, latEnd,\n\t\t\tlonStart, lonEnd,\n\t\t} = this;\n\n\t\tconst latRange = latEnd - latStart;\n\t\tif ( latRange < PI / 2 ) {\n\n\t\t\t// get the midway point for the region\n\t\t\tconst midLat = MathUtils.mapLinear( 0.5, 0, 1, latStart, latEnd );\n\t\t\tconst midLon = MathUtils.mapLinear( 0.5, 0, 1, lonStart, lonEnd );\n\n\t\t\t// get the frame matrix for the box - works well for smaller regions\n\t\t\tthis.getCartographicToNormal( midLat, midLon, _orthoZ );\n\t\t\t_orthoY.set( 0, 0, 1 );\n\t\t\t_orthoX.crossVectors( _orthoY, _orthoZ );\n\t\t\t_orthoY.crossVectors( _orthoX, _orthoZ );\n\t\t\tmatrix.makeBasis( _orthoX, _orthoY, _orthoZ );\n\n\t\t} else {\n\n\t\t\t_orthoX.set( 1, 0, 0 );\n\t\t\t_orthoY.set( 0, 1, 0 );\n\t\t\t_orthoZ.set( 0, 0, 1 );\n\t\t\tmatrix.makeBasis( _orthoX, _orthoY, _orthoZ );\n\n\t\t}\n\n\t\t// transform the points into the local frame\n\t\t_invMatrix.copy( matrix ).invert();\n\n\t\tconst points = this._getPoints( true );\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tpoints[ i ].applyMatrix4( _invMatrix );\n\n\t\t}\n\n\t\t// init the box\n\t\tbox.makeEmpty();\n\t\tbox.setFromPoints( points );\n\n\t}\n\n\tgetBoundingSphere( sphere, center ) {\n\n\t\tresetPool();\n\n\t\tconst points = this._getPoints( true );\n\t\tsphere.makeEmpty();\n\t\tsphere.setFromPoints( points, center );\n\n\t}\n\n}\n","import { estimateBytesUsed as _estimateBytesUsed } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { TextureUtils } from 'three';\n\nexport function getTextureByteLength( tex ) {\n\n\tif ( ! tex ) {\n\n\t\treturn 0;\n\n\t}\n\n\tconst { format, type, image } = tex;\n\tconst { width, height } = image;\n\n\tlet bytes = TextureUtils.getByteLength( width, height, format, type );\n\tbytes *= tex.generateMipmaps ? 4 / 3 : 1;\n\n\treturn bytes;\n\n}\n\n// Returns the estimated number of bytes used by the object\nexport function estimateBytesUsed( object ) {\n\n\tconst dedupeSet = new Set();\n\n\tlet totalBytes = 0;\n\tobject.traverse( c => {\n\n\t\t// get geometry bytes\n\t\tif ( c.geometry && ! dedupeSet.has( c.geometry ) ) {\n\n\t\t\ttotalBytes += _estimateBytesUsed( c.geometry );\n\t\t\tdedupeSet.add( c.geometry );\n\n\t\t}\n\n\t\t// get material bytes\n\t\tif ( c.material ) {\n\n\t\t\tconst material = c.material;\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tconst value = material[ key ];\n\t\t\t\tif ( value && value.isTexture && ! dedupeSet.has( value ) ) {\n\n\t\t\t\t\ttotalBytes += getTextureByteLength( value );\n\t\t\t\t\tdedupeSet.add( value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn totalBytes;\n\n}\n"],"names":["_spherical","Spherical","_vec","Vector3","_geoResults","swapToGeoFrame","target","x","y","z","swapToThreeFrame","sphericalPhiToLatitude","phi","latitudeToSphericalPhi","latitude","correctGeoCoordWrap","lat","lon","toHoursMinutesSecondsString","value","pos","neg","direction","hours","minDec","minutes","seconds","toLatLonString","decimalFormat","result","latString","lonString","MathUtils","_norm","_vec2","_matrix","Matrix4","_matrix2","_matrix3","_sphere","Sphere","_euler","Euler","_vecX","_vecY","_vecZ","_pos","_ray","Ray","EPSILON12","CENTER_EPS","ENU_FRAME","CAMERA_FRAME","OBJECT_FRAME","Ellipsoid","ray","height","az","el","roll","frame","matrix","vecEast","vecNorth","vecUp","point","rotationMatrix","radius","gamma","heightDelta","invRadiusSqX","invRadiusSqY","invRadiusSqZ","x2","y2","z2","squaredNorm","ratio","intersection","gradient","lambda","correction","func","denominator","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","xMultiplier3","yMultiplier3","zMultiplier3","derivative","elevation","effectiveRadius","semiMajorAxis","eSquared","sinPhiSquared","source","WGS84_ELLIPSOID","WGS84_RADIUS","WGS84_HEIGHT","_worldMin","_worldMax","OBB","box","Box3","transform","Plane","points","inverseTransform","min","max","index","sphere","frustum","obb","otherPlanes","otherPoints","thisPoints","thisPlanes","i","plane","maxDistance","j","v","dist","PI","HALF_PI","_orthoX","_orthoY","_orthoZ","_invMatrix","_poolIndex","_pointsPool","getVector","usePool","resetPool","EllipsoidRegion","latStart","latEnd","lonStart","lonEnd","heightStart","heightEnd","midLat","midLon","lonOffset","latlon","total","l","center","getTextureByteLength","tex","format","type","image","width","bytes","TextureUtils","estimateBytesUsed","object","dedupeSet","totalBytes","c","_estimateBytesUsed","material","key"],"mappings":"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"}