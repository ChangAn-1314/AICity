import { jsx as g, jsxs as R, Fragment as Z } from "react/jsx-runtime";
import { useRef as F, useLayoutEffect as N, useEffect as y, createContext as H, forwardRef as _, useContext as q, useState as j, useCallback as K, useReducer as Ce, useMemo as L, StrictMode as xe, cloneElement as Ee } from "react";
import { useThree as M, useFrame as T, createPortal as be } from "@react-three/fiber";
import { Object3D as Me, Scene as Le, Vector3 as P, Matrix4 as A, Ray as ee, OrthographicCamera as qe, BackSide as we, EventDispatcher as me, Line3 as he, Vector2 as _e, Raycaster as Se } from "three";
import { T as Re, E as Pe, G as Fe, a as Te } from "./CameraTransitionManager-CMaqw78S.js";
import { W as We, a as je, O as fe } from "./MemoryUtils-DPE4VZ3R.js";
import { createRoot as Oe } from "react-dom/client";
function ke(o, e) {
  if (o === e)
    return !0;
  if (!o || !e)
    return o === e;
  for (const t in o)
    if (o[t] !== e[t])
      return !1;
  for (const t in e)
    if (o[t] !== e[t])
      return !1;
  return !0;
}
function te(o) {
  const e = F();
  return ke(e.current, o) || (e.current = o), e.current;
}
function Ae(o) {
  return /^on/g.test(o);
}
function ze(o) {
  return o.replace(/^on/, "").replace(/[a-z][A-Z]/g, (e) => `${e[0]}-${e[1]}`).toLowerCase();
}
function le(o) {
  return o.split("-");
}
function ve(o, e) {
  let t = o;
  const i = [...e];
  for (; i.length !== 0; ) {
    const n = i.shift();
    t = t[n];
  }
  return t;
}
function ce(o, e, t) {
  const i = [...e], n = i.pop();
  ve(o, i)[n] = t;
}
function z(o, e, t = !1) {
  N(() => {
    if (o === null)
      return;
    const i = {}, n = {};
    for (const r in e)
      if (Ae(r) && o.addEventListener && !(r in o)) {
        const m = ze(r);
        n[m] = e[r], o.addEventListener(m, e[r]);
      } else {
        const m = t ? [r] : le(r);
        i[r] = ve(o, m), ce(o, m, e[r]);
      }
    return () => {
      for (const r in n)
        o.removeEventListener(r, n[r]);
      for (const r in i) {
        const m = t ? [r] : le(r);
        ce(o, m, i[r]);
      }
    };
  }, [o, te(e)]);
}
function De(o, e) {
  z(o, e, !0);
}
function D(o, ...e) {
  y(() => {
    e.forEach((t) => {
      t && (t instanceof Function ? t(o) : t.current = o);
    });
  }, [o, ...e]);
}
const S = H(null), Qe = H(null);
function Ue({ children: o }) {
  const e = q(S), t = F();
  return y(() => {
    e && (t.current.matrixWorld = e.group.matrixWorld);
  }, [e]), /* @__PURE__ */ g("group", { ref: t, matrixWorldAutoUpdate: !1, matrixAutoUpdate: !1, children: o });
}
function it(o) {
  const {
    lat: e = 0,
    lon: t = 0,
    height: i = 0,
    az: n = 0,
    el: r = 0,
    roll: m = 0,
    ellipsoid: c = We.clone(),
    children: l
  } = o, u = q(S), p = M((s) => s.invalidate), [a, f] = j(null), h = K(() => {
    if (a === null)
      return;
    const s = u && u.ellipsoid || c || null;
    a.matrix.identity(), a.visible = !!(u && u.root || c), s !== null && (s.getOrientedEastNorthUpFrame(e, t, i, n, r, m, a.matrix), a.matrix.decompose(a.position, a.quaternion, a.scale), a.updateMatrixWorld(), p());
  }, [p, u, e, t, i, n, r, m, c, a, te(c.radius)]);
  return y(() => {
    if (u !== null && a !== null)
      return a.updateMatrixWorld = function(s) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || s) && (this.matrixWorld.multiplyMatrices(u.group.matrixWorld, this.matrix), s = !0);
        const d = this.children;
        for (let v = 0, E = d.length; v < E; v++)
          d[v].updateMatrixWorld(s);
      }, () => {
        a.updateMatrixWorld = Me.prototype.updateMatrixWorld;
      };
  }, [u, a]), y(() => {
    h();
  }, [h]), y(() => {
    if (u !== null)
      return u.addEventListener("load-tile-set", h), () => {
        u.removeEventListener("load-tile-set", h);
      };
  }, [u, h]), /* @__PURE__ */ g("group", { ref: f, children: l });
}
const ot = _(function(e, t) {
  const { plugin: i, args: n, children: r, ...m } = e, c = q(S), [l, u] = j(null), [, p] = Ce((a) => a + 1, 0);
  if (N(() => {
    if (c === null)
      return;
    let a;
    return Array.isArray(n) ? a = new i(...n) : a = new i(n), u(a), () => {
      u(null);
    };
  }, [i, c, te(n)]), z(l, m), N(() => {
    if (l !== null)
      return c.registerPlugin(l), p(), () => {
        c.unregisterPlugin(l);
      };
  }, [l]), D(l, t), !(!l || !c.plugins.includes(l)))
    return /* @__PURE__ */ g(Qe.Provider, { value: l, children: r });
}), st = _(function(e, t) {
  const { url: i, group: n = {}, enabled: r = !0, children: m, ...c } = e, [l, u, p] = M((h) => [h.camera, h.gl, h.invalidate]), [a, f] = j(null);
  return y(() => {
    const h = () => p(), s = new Re(i);
    return s.addEventListener("needs-render", h), s.addEventListener("needs-update", h), f(s), () => {
      s.removeEventListener("needs-render", h), s.removeEventListener("needs-update", h), s.dispose(), f(null);
    };
  }, [i, p]), T(() => {
    a === null || !r || (l.updateMatrixWorld(), a.setResolutionFromRenderer(l, u), a.update());
  }), N(() => {
    if (a !== null)
      return a.setCamera(l), () => {
        a.deleteCamera(l);
      };
  }, [a, l]), D(a, t), z(a, c), a ? /* @__PURE__ */ R(Z, { children: [
    /* @__PURE__ */ g("primitive", { object: a.group, ...n }),
    /* @__PURE__ */ g(S.Provider, { value: a, children: /* @__PURE__ */ g(Ue, { children: m }) })
  ] }) : null;
}), Ie = _(function({ children: e, ...t }, i) {
  const [n] = M((l) => [l.gl]), [r, m] = j(null), c = L(() => document.createElement("div"), []);
  y(() => (c.style.pointerEvents = "none", c.style.position = "absolute", c.style.width = "100%", c.style.height = "100%", c.style.left = 0, c.style.top = 0, n.domElement.parentNode.appendChild(c), () => {
    c.remove();
  }), [c, n.domElement.parentNode]), y(() => {
    const l = Oe(c);
    return m(l), () => {
      l.unmount();
    };
  }, [c]), r !== null && r.render(
    /* @__PURE__ */ g(xe, { children: /* @__PURE__ */ g("div", { ...t, ref: i, children: e }) })
  );
});
function Ne() {
  return crypto.getRandomValues(new Uint32Array(1))[0].toString(16);
}
function at({ children: o, style: e, generateAttributions: t, ...i }) {
  const n = q(S), [r, m] = j([]);
  y(() => {
    if (!n)
      return;
    let p = !1;
    const a = () => {
      p || (p = !0, queueMicrotask(() => {
        m(n.getAttributions()), p = !1;
      }));
    };
    return n.addEventListener("tile-visibility-change", a), n.addEventListener("load-tile-set", a), () => {
      n.removeEventListener("tile-visibility-change", a), n.removeEventListener("load-tile-set", a);
    };
  }, [n]);
  const c = L(() => "class_" + Ne(), []), l = L(() => `
		#${c} a {
			color: white;
		}

		#${c} img {
			max-width: 125px;
			display: block;
			margin: 5px 0;
		}
	`, [c]);
  let u;
  if (t)
    u = t(r, c);
  else {
    const p = [];
    r.forEach((a, f) => {
      let h = null;
      a.type === "string" ? h = /* @__PURE__ */ g("div", { children: a.value }, f) : a.type === "html" ? h = /* @__PURE__ */ g("div", { dangerouslySetInnerHTML: { __html: a.value }, style: { pointerEvents: "all" } }, f) : a.type === "image" && (h = /* @__PURE__ */ g("div", { children: /* @__PURE__ */ g("img", { src: a.value }) }, f)), h && p.push(h);
    }), u = /* @__PURE__ */ R(Z, { children: [
      /* @__PURE__ */ g("style", { children: l }),
      p
    ] });
  }
  return /* @__PURE__ */ R(
    Ie,
    {
      id: c,
      style: {
        position: "absolute",
        bottom: 0,
        left: 0,
        padding: "10px",
        color: "rgba( 255, 255, 255, 0.75 )",
        fontSize: "10px",
        ...e
      },
      ...i,
      children: [
        o,
        u
      ]
    }
  );
}
const ge = _(function(e, t) {
  const { controlsConstructor: i, domElement: n, scene: r, camera: m, ellipsoid: c, ellipsoidFrame: l, tilesRenderer: u, ...p } = e, [a] = M((x) => [x.camera]), [f] = M((x) => [x.gl]), [h] = M((x) => [x.scene]), [s] = M((x) => [x.invalidate]), [d] = M((x) => [x.get]), [v] = M((x) => [x.set]), E = q(S), b = u || E, re = m || a || null, ie = r || h || null, oe = n || f.domElement || null, se = c || (b == null ? void 0 : b.ellipsoid) || null, ae = l || (b == null ? void 0 : b.group) || null, C = L(() => new i(), [i]);
  D(C, t), y(() => {
    const x = () => s();
    return C.addEventListener("change", x), C.addEventListener("start", x), C.addEventListener("end", x), () => {
      C.removeEventListener("change", x), C.removeEventListener("start", x), C.removeEventListener("end", x);
    };
  }, [C, s]), y(() => {
    C.setCamera(re);
  }, [C, re]), y(() => {
    C.setScene(ie);
  }, [C, ie]), y(() => {
    C.isGlobeControls && C.setEllipsoid(se, ae);
  }, [C, se, ae]), y(() => (C.attach(oe), () => {
    C.detach();
  }), [C, oe]), y(() => {
    const x = d().controls;
    return v({ controls: C }), () => v({ controls: x });
  }, [C, d, v]), T(() => {
    C.update();
  }, -1), De(C, p);
}), lt = _(function(e, t) {
  return /* @__PURE__ */ g(ge, { ...e, ref: t, controlsConstructor: Pe });
}), ct = _(function(e, t) {
  return /* @__PURE__ */ g(ge, { ...e, ref: t, controlsConstructor: Fe });
}), w = /* @__PURE__ */ new P(), W = /* @__PURE__ */ new P(), k = /* @__PURE__ */ new P(), V = /* @__PURE__ */ new A(), $ = /* @__PURE__ */ new A(), Q = /* @__PURE__ */ new ee(), B = {};
function Ge(o, e, t, i) {
  Q.origin.copy(o.position), Q.direction.set(0, 0, -1).transformDirection(o.matrixWorld), Q.applyMatrix4(t.matrixWorldInverse), e.closestPointToRayEstimate(Q, k), k.applyMatrix4(t.matrixWorld), W.set(0, 0, -1).transformDirection(o.matrixWorld);
  const n = k.sub(o.position).dot(W);
  return i.copy(o.position).addScaledVector(W, n), i;
}
function Ve(o) {
  const { defaultScene: e, defaultCamera: t, overrideRenderLoop: i = !0, renderPriority: n = 1 } = o, r = L(() => new qe(), []), [m, c, l, u] = M((p) => [p.set, p.size, p.gl, p.scene]);
  y(() => {
    m({ camera: r });
  }, [m, r]), y(() => {
    r.left = -c.width / 2, r.right = c.width / 2, r.top = c.height / 2, r.bottom = -c.height / 2, r.near = 0, r.far = 2e3, r.position.z = r.far / 2, r.updateProjectionMatrix();
  }, [r, c]), T(() => {
    i && l.render(e, t);
    const p = l.autoClear;
    l.autoClear = !1, l.clearDepth(), l.render(u, r), l.autoClear = p;
  }, n);
}
function ue() {
  const o = F();
  return y(() => {
    const t = o.current.attributes.position;
    for (let i = 0, n = t.count; i < n; i++)
      w.fromBufferAttribute(t, i), w.y > 0 && (w.x = 0, t.setXYZ(i, ...w));
  }), /* @__PURE__ */ g("boxGeometry", { ref: o });
}
function $e({ northColor: o = 15684432, southColor: e = 16777215 }) {
  const [t, i] = j(), n = F();
  return y(() => {
    i(n.current);
  }, []), /* @__PURE__ */ R("group", { scale: 0.5, ref: n, children: [
    /* @__PURE__ */ g("ambientLight", { intensity: 1 }),
    /* @__PURE__ */ g("directionalLight", { position: [0, 2, 3], intensity: 3, target: t }),
    /* @__PURE__ */ g("directionalLight", { position: [0, -2, -3], intensity: 3, target: t }),
    /* @__PURE__ */ R("mesh", { children: [
      /* @__PURE__ */ g("sphereGeometry", {}),
      /* @__PURE__ */ g("meshBasicMaterial", { color: 0, opacity: 0.3, transparent: !0, side: we })
    ] }),
    /* @__PURE__ */ R("group", { scale: [0.5, 1, 0.15], children: [
      /* @__PURE__ */ R("mesh", { "position-y": 0.5, children: [
        /* @__PURE__ */ g(ue, {}),
        /* @__PURE__ */ g("meshStandardMaterial", { color: o })
      ] }),
      /* @__PURE__ */ R("mesh", { "position-y": -0.5, "rotation-x": Math.PI, children: [
        /* @__PURE__ */ g(ue, {}),
        /* @__PURE__ */ g("meshStandardMaterial", { color: e })
      ] })
    ] })
  ] });
}
function ut({ children: o, overrideRenderLoop: e, mode: t = "3d", margin: i = 10, scale: n = 35, visible: r = !0, ...m }) {
  const [c, l, u] = M((d) => [d.camera, d.scene, d.size]), p = q(S), a = F(null), f = L(() => new Le(), []);
  let h, s;
  return Array.isArray(i) ? (h = i[0], s = i[1]) : (h = i, s = i), T(() => {
    if (p === null || a.current === null)
      return null;
    const { ellipsoid: d } = p, v = a.current;
    if (Ge(c, d, p.group, k).applyMatrix4(p.group.matrixWorldInverse), d.getPositionToCartographic(k, B), d.getEastNorthUpFrame(B.lat, B.lon, 0, $).premultiply(p.group.matrixWorld), $.invert(), V.copy(c.matrixWorld).premultiply($), t.toLowerCase() === "3d")
      v.quaternion.setFromRotationMatrix(V).invert();
    else if (w.set(0, 1, 0).transformDirection(V).normalize(), w.z = 0, w.normalize(), w.length() === 0)
      v.quaternion.identity();
    else {
      const E = W.set(0, 1, 0).angleTo(w);
      W.cross(w).normalize(), v.quaternion.setFromAxisAngle(W, -E);
    }
  }), o || (o = /* @__PURE__ */ g($e, {})), r ? be(
    /* @__PURE__ */ R(Z, { children: [
      /* @__PURE__ */ g(
        "group",
        {
          ref: a,
          scale: n,
          position: [
            u.width / 2 - h - n / 2,
            -u.height / 2 + s + n / 2,
            0
          ],
          ...m,
          children: o
        }
      ),
      /* @__PURE__ */ g(
        Ve,
        {
          defaultCamera: c,
          defaultScene: l,
          overrideRenderLoop: e,
          renderPriority: 10
        }
      )
    ] }),
    f,
    { events: { priority: 10 } }
  ) : null;
}
const dt = _(function(e, t) {
  const {
    mode: i = "perspective",
    onBeforeToggle: n,
    perspectiveCamera: r,
    orthographicCamera: m,
    ...c
  } = e, [l, u, p, a, f, h] = M((d) => [d.set, d.get, d.invalidate, d.controls, d.camera, d.size]), s = L(() => {
    const d = new Te();
    return d.autoSync = !1, f.isOrthographicCamera ? (d.orthographicCamera.copy(f), d.mode = "orthographic") : d.perspectiveCamera.copy(f), d.syncCameras(), d.mode = i, d;
  }, []);
  y(() => {
    const { perspectiveCamera: d, orthographicCamera: v } = s, E = h.width / h.height;
    d.aspect = E, d.updateProjectionMatrix(), v.left = -v.top * E, v.right = -v.left, d.updateProjectionMatrix();
  }, [s, h]), D(s, t), y(() => {
    const d = ({ camera: v }) => {
      l(() => ({ camera: v }));
    };
    return l(() => ({ camera: s.camera })), s.addEventListener("camera-change", d), () => {
      s.removeEventListener("camera-change", d);
    };
  }, [s, l]), y(() => {
    const d = s.perspectiveCamera, v = s.orthographicCamera;
    return s.perspectiveCamera = r || d, s.orthographicCamera = m || v, l(() => ({ camera: s.camera })), () => {
      s.perspectiveCamera = d, s.orthographicCamera = v;
    };
  }, [r, m, s, l]), y(() => {
    if (i !== s.mode) {
      const d = i === "orthographic" ? s.orthographicCamera : s.perspectiveCamera;
      n ? n(s, d) : a && a.isEnvironmentControls ? (a.getPivotPoint(s.fixedPoint), s.syncCameras(), a.adjustCamera(s.perspectiveCamera), a.adjustCamera(s.orthographicCamera)) : (s.fixedPoint.set(0, 0, -1).transformDirection(s.camera.matrixWorld).multiplyScalar(50).add(s.camera.position), s.syncCameras()), s.toggle(), p();
    }
  }, [i, s, p, a, n]), y(() => {
    const d = () => p();
    return s.addEventListener("transition-start", d), s.addEventListener("change", d), s.addEventListener("transition-end", d), () => {
      s.removeEventListener("transition-start", d), s.removeEventListener("change", d), s.removeEventListener("transition-end", d);
    };
  }, [s, p]), z(s, c), T(() => {
    s.update(), a && (a.enabled = !s.animating);
    const { camera: d, size: v } = u();
    if (!m && d === s.orthographicCamera) {
      const E = v.width / v.height, b = s.orthographicCamera;
      E !== b.right && (b.bottom = -1, b.top = 1, b.left = -E, b.right = E, b.updateProjectionMatrix());
    }
    s.animating && p();
  }, -1);
});
function ye(...o) {
  return K((e) => {
    o.forEach((t) => {
      t && (typeof t == "function" ? t(e) : t.current = e);
    });
  }, o);
}
function Y(o, e) {
  e(o) || o.children.forEach((t) => {
    Y(t, e);
  });
}
class Be extends me {
  constructor() {
    super(), this.objects = /* @__PURE__ */ new Set(), this.observed = /* @__PURE__ */ new Set(), this._addedCallback = ({ child: e }) => {
      Y(e, (t) => this.observed.has(t) ? !0 : (this.objects.add(t), t.addEventListener("childadded", this._addedCallback), t.addEventListener("childremoved", this._removedCallback), this.dispatchEvent({ type: "childadded", child: e }), !1));
    }, this._removedCallback = ({ child: e }) => {
      Y(e, (t) => this.observed.has(t) ? !0 : (this.objects.delete(t), t.removeEventListener("childadded", this._addedCallback), t.removeEventListener("childremoved", this._removedCallback), this.dispatchEvent({ type: "childremoved", child: e }), !1));
    };
  }
  observe(e) {
    const { observed: t } = this;
    this._addedCallback({ child: e }), t.add(e);
  }
  unobserve(e) {
    const { observed: t } = this;
    t.delete(e), this._removedCallback({ child: e });
  }
  dispose() {
    this.observed.forEach((e) => {
      this.unobserve(e);
    });
  }
}
const J = /* @__PURE__ */ new Se(), O = /* @__PURE__ */ new he(), U = /* @__PURE__ */ new he(), de = /* @__PURE__ */ new _e(), I = /* @__PURE__ */ new P(), pe = /* @__PURE__ */ new A();
class Je extends me {
  constructor() {
    super(), this.autoRun = !0, this.queryMap = /* @__PURE__ */ new Map(), this.index = 0, this.queued = [], this.scheduled = !1, this.duration = 1, this.objects = [], this.observer = new Be(), this.ellipsoid = new je(), this.frame = new A(), this.cameras = /* @__PURE__ */ new Set();
    const e = /* @__PURE__ */ (() => {
      let t = !1;
      return () => {
        t || (t = !0, queueMicrotask(() => {
          this.queryMap.forEach((i) => this._enqueue(i)), t = !1;
        }));
      };
    })();
    this.observer.addEventListener("childadded", e), this.observer.addEventListener("childremoved", e);
  }
  // job runner
  _enqueue(e) {
    e.queued || (this.queued.push(e), e.queued = !0, this._scheduleRun());
  }
  _runJobs() {
    const { queued: e, cameras: t, duration: i } = this, n = performance.now();
    for (t.forEach((r, m) => {
      pe.copy(r.matrixWorldInverse).premultiply(r.projectionMatrix), I.set(0, 0, -1).transformDirection(r.matrixWorld), O.start.setFromMatrixPosition(r.matrixWorld), O.end.addVectors(I, O.start);
      for (let c = 0, l = e.length; c < l; c++) {
        const u = e[c], { ray: p } = u;
        let a, f;
        if (u.point === null)
          U.start.copy(p.origin), p.at(1, U.end), Xe(O, U, de), u.distance = de.x * (1 - Math.abs(I.dot(p.direction))), u.inFrustum = !0;
        else {
          const h = U.start;
          h.copy(u.point).applyMatrix4(pe), h.x > -1 && h.x < 1 && h.y > -1 && h.y < 1 && h.z > -1 && h.z < 1 ? (u.distance = h.subVectors(u.point, O.start).dot(I), u.inFrustum = !0) : (u.distance = 0, u.inFrustum = !1);
        }
        m === 0 ? (u.distance = a, u.inFrustum = f) : (u.inFrustum = u.inFrustum || f, u.distance = Math.min(u.distance, a));
      }
    }), t.length !== 0 && e.sort((r, m) => r.point === null != (m.point === null) ? r.point === null ? 1 : -1 : r.inFrustum !== m.inFrustum ? r.inFrustum ? 1 : -1 : r.distance < 0 != m.distance < 0 ? r.distance < 0 ? -1 : 1 : m.distance - r.distance); e.length !== 0 && performance.now() - n < i; ) {
      const r = e.pop();
      r.queued = !1, this._updateQuery(r);
    }
    e.length !== 0 && this._scheduleRun();
  }
  _scheduleRun() {
    this.autoRun && !this.scheduled && (this.scheduled = !0, requestAnimationFrame(() => {
      this.scheduled = !1, this._runJobs();
    }));
  }
  _updateQuery(e) {
    J.ray.copy(e.ray), J.far = "lat" in e ? 1e4 + Math.max(...this.ellipsoid.radius) : 1 / 0;
    const t = J.intersectObjects(this.objects)[0] || null;
    t !== null && (e.point === null ? e.point = t.point.clone() : e.point.copy(t.point)), e.callback(t);
  }
  // add and remove cameras used for sorting
  addCamera(e) {
    const { queryMap: t, cameras: i } = this;
    i.add(e), t.forEach((n) => this._enqueue(n));
  }
  deleteCamera(e) {
    const { cameras: t } = this;
    t.delete(e);
  }
  // run the given item index if possible
  runIfNeeded(e) {
    const { queryMap: t, queued: i } = this, n = t.get(e);
    n.queued && (this._updateQuery(n), n.queued = !1, i.splice(i.indexOf(n), 1));
  }
  // set the scene used for query
  setScene(...e) {
    const { observer: t } = this;
    t.dispose(), e.forEach((i) => t.observe(i)), this.objects = e, this._scheduleRun();
  }
  // update the ellipsoid and frame based on a tiles renderer, updating the item rays only if necessary
  setEllipsoidFromTilesRenderer(e) {
    const { queryMap: t, ellipsoid: i, frame: n } = this;
    (!i.radius.equals(e.ellipsoid.radius) || !n.equals(e.group.matrixWorld)) && (i.copy(e.ellipsoid), n.copy(e.group.matrixWorld), t.forEach((r) => {
      if ("lat" in r) {
        const { lat: m, lon: c, ray: l } = r;
        i.getCartographicToPosition(m, c, 1e4, l.origin).applyMatrix4(n), i.getCartographicToNormal(m, c, l.direction).transformDirection(n).multiplyScalar(-1);
      }
      this._enqueue(r);
    }));
  }
  // register query callbacks
  registerRayQuery(e, t) {
    const i = this.index++, n = {
      ray: e.clone(),
      callback: t,
      queued: !1,
      distance: -1,
      point: null
    };
    return this.queryMap.set(i, n), this._enqueue(n), i;
  }
  registerLatLonQuery(e, t, i) {
    const { ellipsoid: n, frame: r } = this, m = this.index++, c = new ee();
    n.getCartographicToPosition(e, t, 1e4, c.origin).applyMatrix4(r), n.getCartographicToNormal(e, t, c.direction).transformDirection(r).multiplyScalar(-1);
    const l = {
      ray: c.clone(),
      lat: e,
      lon: t,
      callback: i,
      queued: !1,
      distance: -1,
      point: null
    };
    return this.queryMap.set(m, l), this._enqueue(l), m;
  }
  unregisterQuery(e) {
    const { queued: t, queryMap: i } = this, n = i.get(e);
    i.delete(e), n && n.queued && (n.queued = !1, t.splice(t.indexOf(n), 1));
  }
  // dispose of everything
  dispose() {
    this.queryMap.clear(), this.queued.length = 0, this.objects.length = 0, this.observer.dispose();
  }
}
const Xe = (function() {
  const o = new P(), e = new P(), t = new P();
  return function(n, r, m) {
    const c = n.start, l = o, u = r.start, p = e;
    t.subVectors(c, u), o.subVectors(n.end, n.start), e.subVectors(r.end, r.start);
    const a = t.dot(p), f = p.dot(l), h = p.dot(p), s = t.dot(l), v = l.dot(l) * h - f * f;
    let E, b;
    v !== 0 ? E = (a * f - s * h) / v : E = 0, b = (a + E * f) / h, m.x = E, m.y = b;
  };
})(), ne = H(null), G = /* @__PURE__ */ new A(), X = /* @__PURE__ */ new ee(), pt = _(function(e, t) {
  const {
    interpolationFactor: i = 0.025,
    onQueryUpdate: n = null,
    ...r
  } = e, m = q(S), c = q(ne), l = M(({ invalidate: s }) => s), u = L(() => new P(), []), p = L(() => ({ value: !1 }), []), a = L(() => ({ value: !1 }), []), f = F(null), h = K((s) => {
    if (m === null || s === null || f.current === null)
      return;
    const { lat: d, lon: v, rayorigin: E, raydirection: b } = r;
    d !== null && v !== null ? (u.copy(s.point), a.value = !0, c.ellipsoid.getObjectFrame(d, v, 0, 0, 0, 0, G, fe).premultiply(m.group.matrixWorld), f.current.quaternion.setFromRotationMatrix(G), l()) : E !== null && b !== null && (u.copy(s.point), a.value = !0, f.current.quaternion.identity(), l()), n && n(s);
  }, [l, a, c.ellipsoid, r, u, m, n]);
  return T((s, d) => {
    if (f.current && (f.current.visible = p.value), f.current && a.value)
      if (p.value === !1)
        p.value = !0, f.current.position.copy(u);
      else {
        const v = 1 - 2 ** (-d / i);
        f.current.position.distanceToSquared(u) > 1e-6 ? (f.current.position.lerp(
          u,
          i === 0 ? 1 : v
        ), l()) : f.current.position.copy(u);
      }
  }), /* @__PURE__ */ g(
    Ye,
    {
      ref: ye(f, t),
      onQueryUpdate: h,
      ...r
    }
  );
}), Ye = _(function(e, t) {
  const {
    component: i = /* @__PURE__ */ g("group", {}),
    lat: n = null,
    lon: r = null,
    rayorigin: m = null,
    raydirection: c = null,
    onQueryUpdate: l = null,
    ...u
  } = e, p = F(null), a = q(S), f = q(ne), h = M(({ invalidate: d }) => d), s = L(() => new P(), []);
  return y(() => {
    const d = (v) => {
      l ? l(v) : a && v !== null && p.current !== null && (n !== null && r !== null ? (p.current.position.copy(v.point), f.ellipsoid.getObjectFrame(n, r, 0, 0, 0, 0, G, fe).premultiply(a.group.matrixWorld), p.current.quaternion.setFromRotationMatrix(G), h()) : m !== null && c !== null && (p.current.position.copy(v.point), p.current.quaternion.identity(), h()));
    };
    if (n !== null && r !== null) {
      const v = f.registerLatLonQuery(n, r, d);
      return () => f.unregisterQuery(v);
    } else if (m !== null && c !== null) {
      X.origin.copy(m), X.direction.copy(c);
      const v = f.registerRayQuery(X, d);
      return () => f.unregisterQuery(v);
    }
  }, [n, r, m, c, f, a, h, s, l]), Ee(i, { ...u, ref: ye(p, t), raycast: () => !1 });
}), mt = _(function(e, t) {
  const i = M(({ scene: p }) => p), {
    scene: n = i,
    children: r,
    ...m
  } = e, c = q(S), l = L(() => new Je(), []), u = M(({ camera: p }) => p);
  return z(l, m), y(() => () => l.dispose(), [l]), y(() => {
    l.setScene(...Array.isArray(n) ? n : [n]);
  }, [l, n]), y(() => {
    l.addCamera(u);
  }, [l, u]), T(() => {
    c && l.setEllipsoidFromTilesRenderer(c);
  }), D(l, t), /* @__PURE__ */ g(ne.Provider, { value: l, children: /* @__PURE__ */ g("group", { matrixAutoUpdate: !1, matrixWorldAutoUpdate: !1, children: r }) });
});
export {
  pt as AnimatedSettledObject,
  dt as CameraTransition,
  Ie as CanvasDOMOverlay,
  ut as CompassGizmo,
  it as EastNorthUpFrame,
  lt as EnvironmentControls,
  ct as GlobeControls,
  Ye as SettledObject,
  mt as SettledObjects,
  at as TilesAttributionOverlay,
  ot as TilesPlugin,
  Qe as TilesPluginContext,
  st as TilesRenderer,
  S as TilesRendererContext
};
//# sourceMappingURL=index.r3f.js.map
