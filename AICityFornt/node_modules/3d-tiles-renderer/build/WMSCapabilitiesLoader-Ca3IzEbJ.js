import { G as Qs, Q as Un, C as Zs } from "./QuantizedMeshLoaderBase-018lzCXI.js";
import { PlaneGeometry as Gt, Mesh as Be, MeshBasicMaterial as De, Vector2 as W, MathUtils as _, Vector3 as E, Sphere as ce, Texture as On, SRGBColorSpace as Js, TextureUtils as Vn, DefaultLoadingManager as Fn, BufferGeometry as jt, MeshStandardMaterial as Ks, BufferAttribute as K, DataTexture as zt, RGFormat as en, UnsignedByteType as tn, LinearMipMapLinearFilter as Nn, LinearFilter as sn, Triangle as Ht, Vector4 as Ue, Matrix4 as Q, Matrix3 as kn, Matrix2 as Gn, WebGLRenderer as jn, WebGLRenderTarget as Dt, ShaderMaterial as nn, OneFactor as zn, ZeroFactor as Hn, CustomBlending as qn, Box2 as Wn, FileLoader as Xn, Quaternion as rn, BatchedMesh as Yn, Source as $n, Box3 as it, REVISION as Qn, WebGLArrayRenderTarget as es, Raycaster as Zn, DoubleSide as on, OrthographicCamera as Jn, Color as qt, CanvasTexture as an, Ray as Kn, LineSegments as ln, LineBasicMaterial as ei, EdgesGeometry as ti, BoxGeometry as si, Group as Fe, Box3Helper as ni, PointsMaterial as ii } from "three";
import { a as cn, O as ri, W as oi, g as ai, c as li, b as ci } from "./MemoryUtils-DPE4VZ3R.js";
import { GLTFLoader as ui } from "three/examples/jsm/loaders/GLTFLoader.js";
import { FullScreenQuad as un } from "three/examples/jsm/postprocessing/Pass.js";
import { L as hi, P as di, W as hn } from "./constants-BPcXltxX.js";
import { b as pi, L as dn } from "./LoaderBase-CfTLVHyZ.js";
class fi {
  constructor() {
    this.creditsCount = {};
  }
  _adjustAttributions(e, t) {
    const s = this.creditsCount, n = e.split(/;/g);
    for (let i = 0, r = n.length; i < r; i++) {
      const o = n[i];
      o in s || (s[o] = 0), s[o] += t ? 1 : -1, s[o] <= 0 && delete s[o];
    }
  }
  addAttributions(e) {
    this._adjustAttributions(e, !0);
  }
  removeAttributions(e) {
    this._adjustAttributions(e, !1);
  }
  toString() {
    return Object.entries(this.creditsCount).sort((t, s) => {
      const n = t[1];
      return s[1] - n;
    }).map((t) => t[0]).join("; ");
  }
}
const mi = "https://tile.googleapis.com/v1/3dtiles/root.json";
class gi {
  constructor({
    apiToken: e,
    sessionOptions: t = null,
    autoRefreshToken: s = !1,
    logoUrl: n = null,
    useRecommendedSettings: i = !0
  }) {
    this.name = "GOOGLE_CLOUD_AUTH_PLUGIN", this.apiToken = e, this.useRecommendedSettings = i, this.logoUrl = n, this.auth = new Qs({ apiToken: e, autoRefreshToken: s, sessionOptions: t }), this.tiles = null, this._visibilityChangeCallback = null, this._attributionsManager = new fi(), this._logoAttribution = {
      value: "",
      type: "image",
      collapsible: !1
    }, this._attribution = {
      value: "",
      type: "string",
      collapsible: !0
    };
  }
  init(e) {
    const { useRecommendedSettings: t, auth: s } = this;
    e.resetFailedTiles(), e.rootURL == null && (e.rootURL = mi), s.sessionOptions || (s.authURL = e.rootURL), t && !s.isMapTilesSession && (e.errorTarget = 20), this.tiles = e, this._visibilityChangeCallback = ({ tile: n, visible: i }) => {
      var o, l;
      const r = ((l = (o = n.cached.metadata) == null ? void 0 : o.asset) == null ? void 0 : l.copyright) || "";
      i ? this._attributionsManager.addAttributions(r) : this._attributionsManager.removeAttributions(r);
    }, e.addEventListener("tile-visibility-change", this._visibilityChangeCallback);
  }
  getAttributions(e) {
    this.tiles.visibleTiles.size > 0 && (this.logoUrl && (this._logoAttribution.value = this.logoUrl, e.push(this._logoAttribution)), this._attribution.value = this._attributionsManager.toString(), e.push(this._attribution));
  }
  dispose() {
    this.tiles.removeEventListener("tile-visibility-change", this._visibilityChangeCallback);
  }
  async fetchData(e, t) {
    return this.auth.fetch(e, t);
  }
}
const de = /* @__PURE__ */ new W(), me = Symbol("TILE_X"), ge = Symbol("TILE_Y"), ie = Symbol("TILE_LEVEL");
class pn {
  get tiling() {
    return this.imageSource.tiling;
  }
  constructor(e = {}) {
    const {
      pixelSize: t = null,
      center: s = !1,
      useRecommendedSettings: n = !0,
      imageSource: i = null
    } = e;
    this.priority = -10, this.tiles = null, this.imageSource = i, this.pixelSize = t, this.center = s, this.useRecommendedSettings = n, t !== null && console.warn('ImageFormatPlugin: "pixelSize" has been deprecated in favor of scaling the tiles root.');
  }
  // Plugin functions
  init(e) {
    this.useRecommendedSettings && (e.errorTarget = 1), this.tiles = e, this.imageSource.fetchOptions = e.fetchOptions, this.imageSource.fetchData = (t, s) => (e.invokeAllPlugins((n) => t = n.preprocessURL ? n.preprocessURL(t, null) : t), e.invokeOnePlugin((n) => n !== this && n.fetchData && n.fetchData(t, s)));
  }
  async loadRootTileSet() {
    const { tiles: e, imageSource: t } = this;
    return t.url = t.url || e.rootURL, e.invokeAllPlugins((s) => t.url = s.preprocessURL ? s.preprocessURL(t.url, null) : t.url), await t.init(), e.rootURL = t.url, this.getTileset(t.url);
  }
  async parseToMesh(e, t, s, n, i) {
    if (i.aborted)
      return null;
    const { imageSource: r } = this, o = t[me], l = t[ge], c = t[ie], u = await r.processBufferToTexture(e);
    if (i.aborted)
      return u.dispose(), u.image.close(), null;
    r.setData(o, l, c, u);
    let h = 1, p = 1, m = 0, d = 0, f = 0;
    const y = t.boundingVolume.box;
    y && ([m, d, f] = y, h = y[3], p = y[7]);
    const g = new Gt(2 * h, 2 * p), x = new Be(g, new De({ map: u, transparent: !0 }));
    x.position.set(m, d, f);
    const T = r.tiling.getTileContentUVBounds(o, l, c), { uv: b } = g.attributes;
    for (let M = 0; M < b.count; M++)
      de.fromBufferAttribute(b, M), de.x = _.mapLinear(de.x, 0, 1, T[0], T[2]), de.y = _.mapLinear(de.y, 0, 1, T[1], T[3]), b.setXY(M, de.x, de.y);
    return x;
  }
  preprocessNode(e) {
    const { tiling: t } = this, s = t.maxLevel;
    e[ie] < s && e.parent !== null && this.expandChildren(e);
  }
  disposeTile(e) {
    const t = e[me], s = e[ge], n = e[ie], { imageSource: i } = this;
    i.has(t, s, n) && i.release(t, s, n);
  }
  // Local functions
  getTileset(e) {
    const { tiling: t, tiles: s } = this, n = t.minLevel, { tileCountX: i, tileCountY: r } = t.getLevel(n), o = [];
    for (let c = 0; c < i; c++)
      for (let u = 0; u < r; u++) {
        const h = this.createChild(c, u, n);
        h !== null && o.push(h);
      }
    const l = {
      asset: {
        version: "1.1"
      },
      geometricError: 1e5,
      root: {
        refine: "REPLACE",
        geometricError: 1e5,
        boundingVolume: this.createBoundingVolume(0, 0, -1),
        children: o,
        [ie]: -1,
        [me]: 0,
        [ge]: 0
      }
    };
    return s.preprocessTileSet(l, e), l;
  }
  getUrl(e, t, s) {
    return this.imageSource.getUrl(e, t, s);
  }
  createBoundingVolume(e, t, s) {
    const { center: n, pixelSize: i, tiling: r } = this, { pixelWidth: o, pixelHeight: l } = r.getLevel(r.maxLevel), [c, u, h, p] = s === -1 ? r.getContentBounds(!0) : r.getTileBounds(e, t, s, !0);
    let m = (h - c) / 2, d = (p - u) / 2, f = c + m, y = u + d;
    return n && (f -= 0.5, y -= 0.5), i ? (f *= o * i, m *= o * i, y *= l * i, d *= l * i) : (f *= r.aspectRatio, m *= r.aspectRatio), {
      box: [
        // center
        f,
        y,
        0,
        // x, y, z half vectors
        m,
        0,
        0,
        0,
        d,
        0,
        0,
        0,
        0
      ]
    };
  }
  createChild(e, t, s) {
    const { pixelSize: n, tiling: i } = this;
    if (!i.getTileExists(e, t, s))
      return null;
    const { pixelWidth: r, pixelHeight: o } = i.getLevel(i.maxLevel), { pixelWidth: l, pixelHeight: c } = i.getLevel(s);
    let u = Math.max(1 / l, 1 / c);
    return n && (u *= n * Math.max(r, o)), {
      refine: "REPLACE",
      geometricError: u,
      boundingVolume: this.createBoundingVolume(e, t, s),
      content: {
        uri: this.getUrl(e, t, s)
      },
      children: [],
      // save the tile params so we can expand later
      [me]: e,
      [ge]: t,
      [ie]: s
    };
  }
  expandChildren(e) {
    const t = e[ie], s = e[me], n = e[ge];
    for (let i = 0; i < 2; i++)
      for (let r = 0; r < 2; r++) {
        const o = this.createChild(2 * s + i, 2 * n + r, t + 1);
        o && e.children.push(o);
      }
  }
}
const ct = /* @__PURE__ */ new E(), Ne = /* @__PURE__ */ new E();
function yi(a, e, t) {
  const n = t + 1e-5;
  let i = e + 1e-5;
  Math.abs(i) > Math.PI / 2 && (i = i - 1e-5), a.getCartographicToPosition(e, t, 0, ct), a.getCartographicToPosition(i, t, 0, Ne);
  const r = ct.distanceTo(Ne) / 1e-5;
  return a.getCartographicToPosition(e, n, 0, Ne), [ct.distanceTo(Ne) / 1e-5, r];
}
const xi = 30, Ti = 15, ut = /* @__PURE__ */ new E(), ts = /* @__PURE__ */ new E(), se = /* @__PURE__ */ new W(), ht = /* @__PURE__ */ new ce();
class rt extends pn {
  get projection() {
    return this.tiling.projection;
  }
  constructor(e = {}) {
    const {
      shape: t = "planar",
      endCaps: s = !0,
      ...n
    } = e;
    super(n), this.shape = t, this.endCaps = s;
  }
  // override the parse to mesh logic to support a region mesh
  async parseToMesh(e, t, ...s) {
    const n = await super.parseToMesh(e, t, ...s), { shape: i, projection: r, tiles: o, tiling: l } = this;
    if (i === "ellipsoid") {
      const c = o.ellipsoid, u = t[ie], h = t[me], p = t[ge], [m, d, f, y] = t.boundingVolume.region, g = Math.ceil((y - d) * _.RAD2DEG * 0.25), x = Math.ceil((f - m) * _.RAD2DEG * 0.25), S = Math.max(Ti, g), T = Math.max(xi, x), b = new Gt(1, 1, T, S), [M, C, v, w] = l.getTileBounds(h, p, u, !0, !0), I = l.getTileContentUVBounds(h, p, u), { position: V, normal: D, uv: N } = b.attributes, L = V.count;
      t.cached.boundingVolume.getSphere(ht);
      for (let A = 0; A < L; A++) {
        ut.fromBufferAttribute(V, A), se.fromBufferAttribute(N, A);
        const U = r.convertProjectionToLongitude(_.mapLinear(se.x, 0, 1, M, v));
        let R = r.convertProjectionToLatitude(_.mapLinear(se.y, 0, 1, C, w));
        if (r.isMercator && this.endCaps && (w === 1 && se.y === 1 && (R = Math.PI / 2), C === 0 && se.y === 0 && (R = -Math.PI / 2)), r.isMercator && se.y !== 0 && se.y !== 1) {
          const k = r.convertProjectionToLatitude(1), F = 1 / S, j = _.mapLinear(se.y - F, 0, 1, d, y), B = _.mapLinear(se.y + F, 0, 1, d, y);
          R > k && j < k && (R = k), R < -k && B > -k && (R = -k);
        }
        c.getCartographicToPosition(R, U, 0, ut).sub(ht.center), c.getCartographicToNormal(R, U, ts);
        const O = _.mapLinear(r.convertLongitudeToProjection(U), M, v, I[0], I[2]), z = _.mapLinear(r.convertLatitudeToProjection(R), C, w, I[1], I[3]);
        N.setXY(A, O, z), V.setXYZ(A, ...ut), D.setXYZ(A, ...ts);
      }
      n.geometry = b, n.position.copy(ht.center);
    }
    return n;
  }
  createBoundingVolume(e, t, s) {
    if (this.shape === "ellipsoid") {
      const { tiling: n, endCaps: i } = this, r = s === -1, o = r ? n.getContentBounds(!0) : n.getTileBounds(e, t, s, !0, !0), l = r ? n.getContentBounds() : n.getTileBounds(e, t, s, !1, !0);
      return i && (o[3] === 1 && (l[3] = Math.PI / 2), o[1] === 0 && (l[1] = -Math.PI / 2)), {
        region: [...l, -1, 1]
      };
    } else
      return super.createBoundingVolume(e, t, s);
  }
  createChild(...e) {
    const t = super.createChild(...e), { shape: s, projection: n, tiling: i } = this;
    if (t && s === "ellipsoid") {
      const r = t[ie], o = t[me], l = t[ge];
      if (r === -1)
        return t.geometricError = 1e50, parent;
      const [c, u, h, p] = i.getTileBounds(o, l, r, !0), { tilePixelWidth: m, tilePixelHeight: d } = i.getLevel(r), f = (h - c) / m, y = (p - u) / d, [
        /* west */
        ,
        g,
        x,
        S
      ] = i.getTileBounds(o, l, r), T = g > 0 != S > 0 ? 0 : Math.min(Math.abs(g), Math.abs(S)), b = n.convertLatitudeToProjection(T), M = n.getLongitudeDerivativeAtProjection(c), C = n.getLatitudeDerivativeAtProjection(b), [v, w] = yi(this.tiles.ellipsoid, T, x), I = Math.max(f * M * v, y * C * w);
      t.geometricError = I;
    }
    return t;
  }
}
class ue {
  get isMercator() {
    return this.scheme === "EPSG:3857";
  }
  constructor(e = "EPSG:4326") {
    this.scheme = e, this.tileCountX = 1, this.tileCountY = 1, this.setScheme(e);
  }
  setScheme(e) {
    switch (this.scheme = e, e) {
      // equirect
      case "CRS:84":
      case "EPSG:4326":
        this.tileCountX = 2, this.tileCountY = 1;
        break;
      // mercator
      case "EPSG:3857":
        this.tileCountX = 1, this.tileCountY = 1;
        break;
      default:
        throw new Error(`ProjectionScheme: Unknown projection scheme "${e}"`);
    }
  }
  convertProjectionToLatitude(e) {
    if (this.isMercator) {
      const t = _.mapLinear(e, 0, 1, -1, 1);
      return 2 * Math.atan(Math.exp(t * Math.PI)) - Math.PI / 2;
    } else
      return _.mapLinear(e, 0, 1, -Math.PI / 2, Math.PI / 2);
  }
  convertProjectionToLongitude(e) {
    return _.mapLinear(e, 0, 1, -Math.PI, Math.PI);
  }
  convertLatitudeToProjection(e) {
    if (this.isMercator) {
      const t = Math.log(Math.tan(Math.PI / 4 + e / 2));
      return 1 / 2 + 1 * t / (2 * Math.PI);
    } else
      return _.mapLinear(e, -Math.PI / 2, Math.PI / 2, 0, 1);
  }
  convertLongitudeToProjection(e) {
    return (e + Math.PI) / (2 * Math.PI);
  }
  getLongitudeDerivativeAtProjection(e) {
    return 2 * Math.PI;
  }
  getLatitudeDerivativeAtProjection(e) {
    let s = e - 1e-5;
    return s < 0 && (s = e + 1e-5), this.isMercator ? Math.abs(this.convertProjectionToLatitude(e) - this.convertProjectionToLatitude(s)) / 1e-5 : Math.PI;
  }
  getBounds() {
    return [
      this.convertProjectionToLongitude(0),
      this.convertProjectionToLatitude(0),
      this.convertProjectionToLongitude(1),
      this.convertProjectionToLatitude(1)
    ];
  }
}
function Me(...a) {
  return a.join("_");
}
class bi {
  constructor() {
    this.cache = {}, this.count = 0, this.cachedBytes = 0, this.active = 0;
  }
  // overridable
  fetchItem() {
  }
  disposeItem() {
  }
  getMemoryUsage(e) {
    return 0;
  }
  // sets the data in the cache explicitly without need to load
  setData(...e) {
    const { cache: t } = this, s = e.pop(), n = Me(...e);
    if (n in t)
      throw new Error(`DataCache: "${n}" is already present.`);
    return this.cache[n] = {
      abortController: new AbortController(),
      result: s,
      count: 1,
      bytes: this.getMemoryUsage(s)
    }, this.count++, this.cachedBytes += this.cache[n].bytes, s;
  }
  // fetches the associated data if it doesn't exist and increments the lock counter
  lock(...e) {
    const { cache: t } = this, s = Me(...e);
    if (s in t)
      t[s].count++;
    else {
      const n = new AbortController(), i = {
        abortController: n,
        result: null,
        count: 1,
        bytes: 0
      };
      this.active++, i.result = this.fetchItem(e, n.signal), i.result instanceof Promise ? i.result.then((r) => (i.result = r, i.bytes = this.getMemoryUsage(r), this.cachedBytes += i.bytes, r)).finally(() => {
        this.active--;
      }).catch((r) => {
      }) : (this.active--, i.bytes = this.getMemoryUsage(i.result), this.cachedBytes += i.bytes), this.cache[s] = i, this.count++;
    }
    return t[s].result;
  }
  // decrements the lock counter for the item and deletes the item if it has reached zero
  release(...e) {
    const t = Me(...e);
    this.releaseViaFullKey(t);
  }
  // get the loaded item
  get(...e) {
    const { cache: t } = this, s = Me(...e);
    return s in t && t[s].count > 0 ? t[s].result : null;
  }
  has(...e) {
    const { cache: t } = this;
    return Me(...e) in t;
  }
  // dispose all items
  dispose() {
    const { cache: e } = this;
    for (const t in e) {
      const { abortController: s } = e[t];
      s.abort(), this.releaseViaFullKey(t, !0);
    }
    this.cache = {};
  }
  // releases an item with an optional force flag
  releaseViaFullKey(e, t = !1) {
    const { cache: s } = this;
    if (e in s && s[e].count > 0) {
      const n = s[e];
      if (n.count--, n.count === 0 || t) {
        const i = () => {
          if (s[e] !== n)
            return;
          const { result: r, abortController: o } = n;
          o.abort(), r instanceof Promise ? r.then((l) => {
            this.disposeItem(l), this.count--, this.cachedBytes -= n.bytes;
          }).catch(() => {
          }) : (this.disposeItem(r), this.count--, this.cachedBytes -= n.bytes), delete s[e];
        };
        t ? i() : queueMicrotask(() => {
          n.count === 0 && i();
        });
      }
      return !0;
    }
    throw new Error("DataCache: Attempting to release key that does not exist");
  }
}
function ss(a, e) {
  const [t, s, n, i] = a, [r, o, l, c] = e;
  return !(t >= l || n <= r || s >= c || i <= o);
}
class fn {
  get levelCount() {
    return this._levels.length;
  }
  get maxLevel() {
    return this.levelCount - 1;
  }
  get minLevel() {
    const e = this._levels;
    for (let t = 0; t < e.length; t++)
      if (e[t] !== null)
        return t;
    return -1;
  }
  // prioritize user-set bounds over projection bounds if present
  get contentBounds() {
    var e;
    return this._contentBounds ?? ((e = this.projection) == null ? void 0 : e.getBounds()) ?? [0, 0, 1, 1];
  }
  get aspectRatio() {
    const { pixelWidth: e, pixelHeight: t } = this.getLevel(this.maxLevel);
    return e / t;
  }
  constructor() {
    this.flipY = !1, this.pixelOverlap = 0, this._contentBounds = null, this.projection = null, this._levels = [];
  }
  // build the zoom levels
  setLevel(e, t = {}) {
    const s = this._levels;
    for (; s.length < e; )
      s.push(null);
    const {
      tilePixelWidth: n = 256,
      tilePixelHeight: i = 256,
      tileCountX: r = 2 ** e,
      tileCountY: o = 2 ** e,
      tileBounds: l = null
    } = t, {
      pixelWidth: c = n * r,
      pixelHeight: u = i * o
    } = t;
    s[e] = {
      // The pixel resolution of each tile.
      tilePixelWidth: n,
      tilePixelHeight: i,
      // The total pixel resolution of the final image at this level. These numbers
      // may not be a round multiple of the tile width.
      pixelWidth: c,
      pixelHeight: u,
      // Or the total number of tiles that can be loaded at this level.
      tileCountX: r,
      tileCountY: o,
      // The bounds covered by the extent of the tiles at this loaded. The actual content covered by the overall tile set
      // may be a subset of this range (eg there may be unused space).
      tileBounds: l
    };
  }
  generateLevels(e, t, s, n = {}) {
    const {
      minLevel: i = 0,
      tilePixelWidth: r = 256,
      tilePixelHeight: o = 256
    } = n, l = e - 1, {
      pixelWidth: c = r * t * 2 ** l,
      pixelHeight: u = o * s * 2 ** l
    } = n;
    for (let h = i; h < e; h++) {
      const p = e - h - 1, m = Math.ceil(c * 2 ** -p), d = Math.ceil(u * 2 ** -p), f = Math.ceil(m / r), y = Math.ceil(d / o);
      this.setLevel(h, {
        tilePixelWidth: r,
        tilePixelHeight: o,
        pixelWidth: m,
        pixelHeight: d,
        tileCountX: f,
        tileCountY: y
      });
    }
  }
  getLevel(e) {
    return this._levels[e];
  }
  // bounds representing the contentful region of the image
  setContentBounds(e, t, s, n) {
    this._contentBounds = [e, t, s, n];
  }
  setProjection(e) {
    this.projection = e;
  }
  // query functions
  getTileAtPoint(e, t, s, n = !1) {
    const { flipY: i } = this, { tileCountX: r, tileCountY: o, tileBounds: l } = this.getLevel(s), c = 1 / r, u = 1 / o;
    if (n || ([e, t] = this.toNormalizedPoint(e, t)), l) {
      const m = this.toNormalizedRange(l);
      e = _.mapLinear(e, m[0], m[2], 0, 1), t = _.mapLinear(t, m[1], m[3], 0, 1);
    }
    const h = Math.floor(e / c);
    let p = Math.floor(t / u);
    return i && (p = o - 1 - p), [h, p];
  }
  getTilesInRange(e, t, s, n, i, r = !1) {
    const o = [e, t, s, n], l = this.getContentBounds(r);
    let c = this.getLevel(i).tileBounds;
    if (!ss(o, l))
      return [0, 0, -1, -1];
    if (c && (r && (c = this.toNormalizedRange(c)), !ss(o, l)))
      return [0, 0, -1, -1];
    const [u, h, p, m] = this.clampToContentBounds(o, r), d = this.getTileAtPoint(u, h, i, r), f = this.getTileAtPoint(p, m, i, r);
    this.flipY && ([d[1], f[1]] = [f[1], d[1]]);
    const { tileCountX: y, tileCountY: g } = this.getLevel(i), [x, S] = d, [T, b] = f;
    return T < 0 || b < 0 || x >= y || S >= g ? [0, 0, -1, -1] : [
      _.clamp(x, 0, y - 1),
      _.clamp(S, 0, g - 1),
      _.clamp(T, 0, y - 1),
      _.clamp(b, 0, g - 1)
    ];
  }
  getTileExists(e, t, s) {
    const [n, i, r, o] = this.contentBounds, [l, c, u, h] = this.getTileBounds(e, t, s);
    return !(l >= u || c >= h) && l <= r && c <= o && u >= n && h >= i;
  }
  getContentBounds(e = !1) {
    const { projection: t } = this, s = [...this.contentBounds];
    return t && e && (s[0] = t.convertLongitudeToProjection(s[0]), s[1] = t.convertLatitudeToProjection(s[1]), s[2] = t.convertLongitudeToProjection(s[2]), s[3] = t.convertLatitudeToProjection(s[3])), s;
  }
  // returns the UV range associated with the content in the given tile
  getTileContentUVBounds(e, t, s) {
    const [n, i, r, o] = this.getTileBounds(e, t, s, !0, !0), [l, c, u, h] = this.getTileBounds(e, t, s, !0, !1);
    return [
      _.mapLinear(n, l, u, 0, 1),
      _.mapLinear(i, c, h, 0, 1),
      _.mapLinear(r, l, u, 0, 1),
      _.mapLinear(o, c, h, 0, 1)
    ];
  }
  getTileBounds(e, t, s, n = !1, i = !0) {
    const { flipY: r, pixelOverlap: o, projection: l } = this, { tilePixelWidth: c, tilePixelHeight: u, pixelWidth: h, pixelHeight: p, tileBounds: m } = this.getLevel(s);
    let d = c * e - o, f = u * t - o, y = d + c + o * 2, g = f + u + o * 2;
    if (d = Math.max(d, 0), f = Math.max(f, 0), y = Math.min(y, h), g = Math.min(g, p), d = d / h, y = y / h, f = f / p, g = g / p, r) {
      const S = (g - f) / 2, b = 1 - (f + g) / 2;
      f = b - S, g = b + S;
    }
    let x = [d, f, y, g];
    if (m) {
      const S = this.toNormalizedRange(m);
      x[0] = _.mapLinear(x[0], 0, 1, S[0], S[2]), x[2] = _.mapLinear(x[2], 0, 1, S[0], S[2]), x[1] = _.mapLinear(x[1], 0, 1, S[1], S[3]), x[3] = _.mapLinear(x[3], 0, 1, S[1], S[3]);
    }
    return i && (x = this.clampToProjectionBounds(x, !0)), l && !n && (x[0] = l.convertProjectionToLongitude(x[0]), x[1] = l.convertProjectionToLatitude(x[1]), x[2] = l.convertProjectionToLongitude(x[2]), x[3] = l.convertProjectionToLatitude(x[3])), x;
  }
  toNormalizedPoint(e, t) {
    const { projection: s } = this, n = [e, t];
    return this.projection && (n[0] = s.convertLongitudeToProjection(n[0]), n[1] = s.convertLatitudeToProjection(n[1])), n;
  }
  toNormalizedRange(e) {
    return [
      ...this.toNormalizedPoint(e[0], e[1]),
      ...this.toNormalizedPoint(e[2], e[3])
    ];
  }
  toCartographicPoint(e, t) {
    const { projection: s } = this, n = [e, t];
    if (this.projection)
      n[0] = s.convertProjectionToLongitude(n[0]), n[1] = s.convertProjectionToLatitude(n[1]);
    else
      throw new Error("TilingScheme: Projection not available.");
    return n;
  }
  toCartographicRange(e) {
    return [
      ...this.toCartographicPoint(e[0], e[1]),
      ...this.toCartographicPoint(e[2], e[3])
    ];
  }
  clampToContentBounds(e, t = !1) {
    const s = [...e], [n, i, r, o] = this.getContentBounds(t);
    return s[0] = _.clamp(s[0], n, r), s[1] = _.clamp(s[1], i, o), s[2] = _.clamp(s[2], n, r), s[3] = _.clamp(s[3], i, o), s;
  }
  clampToProjectionBounds(e, t = !1) {
    const s = [...e], { projection: n } = this;
    let i;
    t || !n ? i = [0, 0, 1, 1] : i = n.getBounds();
    const [r, o, l, c] = i;
    return s[0] = _.clamp(s[0], r, l), s[1] = _.clamp(s[1], o, c), s[2] = _.clamp(s[2], r, l), s[3] = _.clamp(s[3], o, c), s;
  }
}
class Se extends bi {
  constructor(e = {}) {
    super();
    const {
      fetchOptions: t = {}
    } = e;
    this.tiling = new fn(), this.fetchOptions = t, this.fetchData = (...s) => fetch(...s);
  }
  // async function for initializing the tiled image set
  init() {
  }
  // helper for processing the buffer into a texture
  async processBufferToTexture(e) {
    const t = new Blob([e]), s = await createImageBitmap(t, {
      premultiplyAlpha: "none",
      colorSpaceConversion: "none",
      imageOrientation: "flipY"
    }), n = new On(s);
    return n.generateMipmaps = !1, n.colorSpace = Js, n.needsUpdate = !0, n;
  }
  getMemoryUsage(e) {
    const { format: t, type: s, image: n, generateMipmaps: i } = e, { width: r, height: o } = n, l = Vn.getByteLength(r, o, t, s);
    return i ? l * 4 / 3 : l;
  }
  // fetch the item with the given key fields
  fetchItem(e, t) {
    const s = {
      ...this.fetchOptions,
      signal: t
    }, n = this.getUrl(...e);
    return this.fetchData(n, s).then((i) => i.arrayBuffer()).then((i) => this.processBufferToTexture(i));
  }
  // dispose of the item that was fetched
  disposeItem(e) {
    e.dispose(), e.image instanceof ImageBitmap && e.image.close();
  }
  getUrl(...e) {
  }
}
class Wt extends Se {
  constructor(e = {}) {
    const {
      levels: t = 20,
      tileDimension: s = 256,
      url: n = null,
      ...i
    } = e;
    super(i), this.tileDimension = s, this.levels = t, this.url = n;
  }
  getUrl(e, t, s) {
    return this.url.replace(/{\s*z\s*}/gi, s).replace(/{\s*x\s*}/gi, e).replace(/{\s*(y|reverseY|-\s*y)\s*}/gi, t);
  }
  init() {
    const { tiling: e, tileDimension: t, levels: s, url: n } = this;
    return e.flipY = !/{\s*reverseY|-\s*y\s*}/g.test(n), e.setProjection(new ue("EPSG:3857")), e.setContentBounds(...e.projection.getBounds()), e.generateLevels(s, e.projection.tileCountX, e.projection.tileCountY, {
      tilePixelWidth: t,
      tilePixelHeight: t
    }), this.url = n, Promise.resolve();
  }
}
class Xt extends Se {
  constructor(e = {}) {
    const {
      url: t = null,
      ...s
    } = e;
    super(s), this.tileSets = null, this.extension = null, this.url = t;
  }
  getUrl(e, t, s) {
    const { url: n, extension: i, tileSets: r, tiling: o } = this;
    return new URL(`${parseInt(r[s - o.minLevel].href)}/${e}/${t}.${i}`, n).toString();
  }
  init() {
    const { url: e } = this;
    return this.fetchData(new URL("tilemapresource.xml", e), this.fetchOptions).then((t) => t.text()).then((t) => {
      const { tiling: s } = this, n = new DOMParser().parseFromString(t, "text/xml"), i = n.querySelector("BoundingBox"), r = n.querySelector("TileFormat"), l = [...n.querySelector("TileSets").querySelectorAll("TileSet")].map((g) => ({
        href: parseInt(g.getAttribute("href")),
        unitsPerPixel: parseFloat(g.getAttribute("units-per-pixel")),
        order: parseInt(g.getAttribute("order"))
      })).sort((g, x) => g.order - x.order), c = parseFloat(i.getAttribute("minx")) * _.DEG2RAD, u = parseFloat(i.getAttribute("maxx")) * _.DEG2RAD, h = parseFloat(i.getAttribute("miny")) * _.DEG2RAD, p = parseFloat(i.getAttribute("maxy")) * _.DEG2RAD, m = parseInt(r.getAttribute("width")), d = parseInt(r.getAttribute("height")), f = r.getAttribute("extension"), y = n.querySelector("SRS").textContent;
      this.extension = f, this.url = e, this.tileSets = l, s.setProjection(new ue(y)), s.setContentBounds(c, h, u, p), l.forEach(({ order: g }) => {
        s.setLevel(g, {
          tileCountX: s.projection.tileCountX * 2 ** g,
          tilePixelWidth: m,
          tilePixelHeight: d
        });
      });
    });
  }
}
function _i(a) {
  return /(:84|:crs84)$/i.test(a);
}
class mn extends Se {
  constructor(e = {}) {
    const {
      capabilities: t = null,
      layer: s = null,
      tileMatrixSet: n = null,
      style: i = null,
      url: r = null,
      dimensions: o = {},
      ...l
    } = e;
    super(l), this.capabilities = t, this.layer = s, this.tileMatrixSet = n, this.style = i, this.dimensions = o, this.url = r;
  }
  getUrl(e, t, s) {
    return this.url.replace(/{\s*TileMatrix\s*}/gi, s).replace(/{\s*TileCol\s*}/gi, e).replace(/{\s*TileRow\s*}/gi, t);
  }
  init() {
    const { tiling: e, dimensions: t, capabilities: s } = this;
    let { layer: n, tileMatrixSet: i, style: r, url: o } = this;
    n ? typeof n == "string" && (n = s.layers.find((u) => u.identifier === n)) : n = s.layers[0], i ? typeof i == "string" && (i = n.tileMatrixSets.find((u) => u.identifier === i)) : i = n.tileMatrixSets[0], r || (r = n.styles.find((u) => u.isDefault).identifier), o || (o = n.resourceUrls[0].template);
    const l = i.supportedCRS, c = l.includes("4326") || _i(l) ? "EPSG:4326" : "EPSG:3857";
    e.flipY = !0, e.setProjection(new ue(c)), n.boundingBox !== null ? e.setContentBounds(...n.boundingBox.bounds) : e.setContentBounds(...e.projection.getBounds()), i.tileMatrices.forEach((u, h) => {
      const { tileWidth: p, tileHeight: m, matrixWidth: d, matrixHeight: f } = u;
      e.setLevel(h, {
        tilePixelWidth: p,
        tilePixelHeight: m,
        tileCountX: d || e.projection.tileCountX * 2 ** h,
        tileCountY: f || e.projection.tileCountY * 2 ** h,
        tileBounds: u.bounds
      });
    }), o = o.replace(/{\s*TileMatrixSet\s*}/g, i.identifier).replace(/{\s*Style\s*}/g, r);
    for (const u in t)
      o = o.replace(new RegExp(`{\\s*${u}\\s*}`), t[u]);
    return n.dimensions.forEach((u) => {
      o = o.replace(new RegExp(`{\\s*${u.identifier}\\s*}`), u.defaultValue);
    }), this.url = o, Promise.resolve();
  }
}
class gn extends Se {
  // TODO: layer and styles can be arrays, comma separated lists
  constructor(e = {}) {
    const {
      url: t = null,
      layer: s = null,
      styles: n = null,
      contentBoundingBox: i = null,
      version: r = "1.3.0",
      crs: o = "EPSG:4326",
      format: l = "image/png",
      transparent: c = !1,
      levels: u = 18,
      tileDimension: h = 256,
      ...p
    } = e;
    super(p), this.url = t, this.layer = s, this.crs = o, this.format = l, this.tileDimension = h, this.styles = n, this.version = r, this.levels = u, this.transparent = c, this.contentBoundingBox = i;
  }
  init() {
    const { tiling: e, levels: t, tileDimension: s, contentBoundingBox: n } = this;
    return e.setProjection(new ue(this.crs)), e.flipY = !0, e.generateLevels(t, e.projection.tileCountX, e.projection.tileCountY, {
      tilePixelWidth: s,
      tilePixelHeight: s
    }), n !== null ? e.setContentBounds(...n) : e.setContentBounds(...e.projection.getBounds()), Promise.resolve();
  }
  // TODO: handle this in ProjectionScheme or TilingScheme? Or Loader?
  normalizedToMercatorX(e) {
    return _.mapLinear(e, 0, 1, -20037508342789244e-9, 20037508342789244e-9);
  }
  normalizedToMercatorY(e) {
    return _.mapLinear(e, 0, 1, -20037508342789244e-9, 20037508342789244e-9);
  }
  getUrl(e, t, s) {
    const {
      tiling: n,
      layer: i,
      crs: r,
      format: o,
      tileDimension: l,
      styles: c,
      version: u,
      transparent: h
    } = this, p = u === "1.1.1" ? "SRS" : "CRS";
    let m;
    if (r === "EPSG:3857") {
      const f = n.getTileBounds(e, t, s, !0, !1), y = this.normalizedToMercatorX(f[0]), g = this.normalizedToMercatorY(f[1]), x = this.normalizedToMercatorX(f[2]), S = this.normalizedToMercatorY(f[3]);
      m = [y, g, x, S];
    } else {
      const [f, y, g, x] = n.getTileBounds(e, t, s, !1, !1).map((S) => S * _.RAD2DEG);
      r === "EPSG:4326" ? u === "1.1.1" ? m = [f, y, g, x] : m = [y, f, x, g] : m = [f, y, g, x];
    }
    const d = new URLSearchParams({
      SERVICE: "WMS",
      REQUEST: "GetMap",
      VERSION: u,
      LAYERS: i,
      [p]: r,
      BBOX: m.join(","),
      WIDTH: l,
      HEIGHT: l,
      FORMAT: o,
      TRANSPARENT: h ? "TRUE" : "FALSE"
    });
    return c != null && d.set("STYLES", c), new URL("?" + d.toString(), this.url).toString();
  }
}
class to extends rt {
  constructor(e = {}) {
    const {
      levels: t,
      tileDimension: s,
      url: n,
      ...i
    } = e;
    super(i), this.name = "XYZ_TILES_PLUGIN", this.imageSource = new Wt({ url: n, levels: t, tileDimension: s });
  }
}
class Si extends rt {
  constructor(e = {}) {
    const { url: t, ...s } = e;
    super(s), this.name = "TMS_TILES_PLUGIN", this.imageSource = new Xt({ url: t });
  }
}
class so extends rt {
  constructor(e = {}) {
    const {
      capabilities: t,
      layer: s,
      tileMatrixSet: n,
      style: i,
      dimensions: r,
      ...o
    } = e;
    super(o), this.name = "WTMS_TILES_PLUGIN", this.imageSource = new mn({
      capabilities: t,
      layer: s,
      tileMatrixSet: n,
      style: i,
      dimensions: r
    });
  }
}
class no extends rt {
  constructor(e = {}) {
    const {
      url: t,
      layer: s,
      crs: n,
      format: i,
      tileDimension: r,
      styles: o,
      version: l,
      ...c
    } = e;
    super(c), this.name = "WMS_TILES_PLUGIN", this.imageSource = new gn({
      url: t,
      layer: s,
      crs: n,
      format: i,
      tileDimension: r,
      styles: o,
      version: l
    });
  }
}
const ns = /* @__PURE__ */ new E(), ke = /* @__PURE__ */ new Ht(), G = /* @__PURE__ */ new E(), ne = /* @__PURE__ */ new E();
class Mi extends Un {
  constructor(e = Fn) {
    super(), this.manager = e, this.ellipsoid = new cn(), this.skirtLength = 1e3, this.smoothSkirtNormals = !0, this.solid = !1, this.minLat = -Math.PI / 2, this.maxLat = Math.PI / 2, this.minLon = -Math.PI, this.maxLon = Math.PI;
  }
  parse(e) {
    const {
      ellipsoid: t,
      solid: s,
      skirtLength: n,
      smoothSkirtNormals: i,
      minLat: r,
      maxLat: o,
      minLon: l,
      maxLon: c
    } = this, {
      header: u,
      indices: h,
      vertexData: p,
      edgeIndices: m,
      extensions: d
    } = super.parse(e), f = new jt(), y = new Ks(), g = new Be(f, y);
    g.position.set(...u.center);
    const x = "octvertexnormals" in d, S = p.u.length, T = [], b = [], M = [], C = [];
    let v = 0, w = 0;
    for (let L = 0; L < S; L++)
      V(L, G), D(G.x, G.y, G.z, ne), b.push(G.x, G.y), T.push(...ne);
    for (let L = 0, A = h.length; L < A; L++)
      M.push(h[L]);
    if (x) {
      const L = d.octvertexnormals.normals;
      for (let A = 0, U = L.length; A < U; A++)
        C.push(L[A]);
    }
    if (f.addGroup(v, h.length, w), v += h.length, w++, s) {
      const L = T.length / 3;
      for (let A = 0; A < S; A++)
        V(A, G), D(G.x, G.y, G.z, ne, -n), b.push(G.x, G.y), T.push(...ne);
      for (let A = h.length - 1; A >= 0; A--)
        M.push(h[A] + L);
      if (x) {
        const A = d.octvertexnormals.normals;
        for (let U = 0, R = A.length; U < R; U++)
          C.push(-A[U]);
      }
      f.addGroup(v, h.length, w), v += h.length, w++;
    }
    if (n > 0) {
      const {
        westIndices: L,
        eastIndices: A,
        southIndices: U,
        northIndices: R
      } = m;
      let O;
      const z = N(L);
      O = T.length / 3, b.push(...z.uv), T.push(...z.positions);
      for (let B = 0, $ = z.indices.length; B < $; B++)
        M.push(z.indices[B] + O);
      const k = N(A);
      O = T.length / 3, b.push(...k.uv), T.push(...k.positions);
      for (let B = 0, $ = k.indices.length; B < $; B++)
        M.push(k.indices[B] + O);
      const F = N(U);
      O = T.length / 3, b.push(...F.uv), T.push(...F.positions);
      for (let B = 0, $ = F.indices.length; B < $; B++)
        M.push(F.indices[B] + O);
      const j = N(R);
      O = T.length / 3, b.push(...j.uv), T.push(...j.positions);
      for (let B = 0, $ = j.indices.length; B < $; B++)
        M.push(j.indices[B] + O);
      x && (C.push(...z.normals), C.push(...k.normals), C.push(...F.normals), C.push(...j.normals)), f.addGroup(v, h.length, w), v += h.length, w++;
    }
    for (let L = 0, A = T.length; L < A; L += 3)
      T[L + 0] -= u.center[0], T[L + 1] -= u.center[1], T[L + 2] -= u.center[2];
    const I = T.length / 3 > 65535 ? new Uint32Array(M) : new Uint16Array(M);
    if (f.setIndex(new K(I, 1, !1)), f.setAttribute("position", new K(new Float32Array(T), 3, !1)), f.setAttribute("uv", new K(new Float32Array(b), 2, !1)), x && f.setAttribute("normal", new K(new Float32Array(C), 3, !1)), "watermask" in d) {
      const { mask: L, size: A } = d.watermask, U = new Uint8Array(2 * A * A);
      for (let O = 0, z = L.length; O < z; O++) {
        const k = L[O] === 255 ? 0 : 255;
        U[2 * O + 0] = k, U[2 * O + 1] = k;
      }
      const R = new zt(U, A, A, en, tn);
      R.flipY = !0, R.minFilter = Nn, R.magFilter = sn, R.needsUpdate = !0, y.roughnessMap = R;
    }
    return g.userData.minHeight = u.minHeight, g.userData.maxHeight = u.maxHeight, "metadata" in d && (g.userData.metadata = d.metadata.json), g;
    function V(L, A) {
      return A.x = p.u[L], A.y = p.v[L], A.z = p.height[L], A;
    }
    function D(L, A, U, R, O = 0) {
      const z = _.lerp(u.minHeight, u.maxHeight, U), k = _.lerp(l, c, L), F = _.lerp(r, o, A);
      return t.getCartographicToPosition(F, k, z + O, R), R;
    }
    function N(L) {
      const A = [], U = [], R = [], O = [], z = [];
      for (let j = 0, B = L.length; j < B; j++)
        V(L[j], G), A.push(G.x, G.y), R.push(G.x, G.y), D(G.x, G.y, G.z, ne), U.push(...ne), D(G.x, G.y, G.z, ne, -n), O.push(...ne);
      const k = L.length - 1;
      for (let j = 0; j < k; j++) {
        const B = j, $ = j + 1, he = j + L.length, at = j + L.length + 1;
        z.push(B, he, $), z.push($, he, at);
      }
      let F = null;
      if (x) {
        const j = (U.length + O.length) / 3;
        if (i) {
          F = new Array(j * 3);
          const B = d.octvertexnormals.normals, $ = F.length / 2;
          for (let he = 0, at = j / 2; he < at; he++) {
            const lt = L[he], xe = 3 * he, Zt = B[3 * lt + 0], Jt = B[3 * lt + 1], Kt = B[3 * lt + 2];
            F[xe + 0] = Zt, F[xe + 1] = Jt, F[xe + 2] = Kt, F[$ + xe + 0] = Zt, F[$ + xe + 1] = Jt, F[$ + xe + 2] = Kt;
          }
        } else {
          F = [], ke.a.fromArray(U, 0), ke.b.fromArray(O, 0), ke.c.fromArray(U, 3), ke.getNormal(ns);
          for (let B = 0; B < j; B++)
            F.push(...ns);
        }
      }
      return {
        uv: [...A, ...R],
        positions: [...U, ...O],
        indices: z,
        normals: F
      };
    }
  }
}
const H = 0, oe = ["a", "b", "c"], P = /* @__PURE__ */ new Ue(), is = /* @__PURE__ */ new Ue(), rs = /* @__PURE__ */ new Ue(), os = /* @__PURE__ */ new Ue();
class yn {
  constructor() {
    this.attributeList = null, this.splitOperations = [], this.trianglePool = new Ci();
  }
  forEachSplitPermutation(e) {
    const { splitOperations: t } = this, s = (n = 0) => {
      if (n >= t.length) {
        e();
        return;
      }
      t[n].keepPositive = !0, s(n + 1), t[n].keepPositive = !1, s(n + 1);
    };
    s();
  }
  // Takes an operation that returns a value for the given vertex passed to the callback. Triangles
  // are clipped along edges where the interpolated value is equal to 0. The polygons on the positive
  // side of the operation are kept if "keepPositive" is true.
  // callback( geometry, i0, i1, i2, barycoord );
  addSplitOperation(e, t = !0) {
    this.splitOperations.push({
      callback: e,
      keepPositive: t
    });
  }
  // Removes all split operations
  clearSplitOperations() {
    this.splitOperations.length = 0;
  }
  // clips an object hierarchy
  clipObject(e) {
    const t = e.clone(), s = [];
    return t.traverse((n) => {
      n.isMesh && (n.geometry = this.clip(n).geometry, (n.geometry.index ? n.geometry.index.count / 3 : n.attributes.position.count / 3) === 0 && s.push(n));
    }), s.forEach((n) => {
      n.removeFromParent();
    }), t;
  }
  // Returns a new mesh that has been clipped by the split operations. Range indicates the range of
  // elements to include when clipping.
  clip(e, t = null) {
    const s = this.getClippedData(e, t);
    return this.constructMesh(s.attributes, s.index, e);
  }
  // Appends the clip operation data to the given "target" object so multiple ranges can be appended.
  // The "target" object is returned with an "index" field, "vertexIsClipped" field, and series of arrays
  // in "attributes".
  // attributes - set of attribute arrays
  // index - triangle indices referencing vertices in attributes
  // vertexIsClipped - array indicating whether a vertex is on a clipped edge
  getClippedData(e, t = null, s = {}) {
    const { trianglePool: n, splitOperations: i, attributeList: r } = this, o = e.geometry, l = o.attributes.position, c = o.index;
    let u = 0;
    const h = {};
    s.index = s.index || [], s.vertexIsClipped = s.vertexIsClipped || [], s.attributes = s.attributes || {};
    for (const f in o.attributes) {
      if (r !== null) {
        if (r instanceof Function && !r(f))
          continue;
        if (Array.isArray(r) && !r.includes(f))
          continue;
      }
      s.attributes[f] = [];
    }
    let p = 0, m = c ? c.count : l.count;
    t !== null && (p = t.start, m = t.count);
    for (let f = p, y = p + m; f < y; f += 3) {
      let g = f + 0, x = f + 1, S = f + 2;
      c && (g = c.getX(g), x = c.getX(x), S = c.getX(S));
      const T = n.get();
      T.initFromIndices(g, x, S);
      let b = [T];
      for (let M = 0; M < i.length; M++) {
        const { keepPositive: C, callback: v } = i[M], w = [];
        for (let I = 0; I < b.length; I++) {
          const V = b[I], { indices: D, barycoord: N } = V;
          V.clipValues.a = v(o, D.a, D.b, D.c, N.a, e.matrixWorld), V.clipValues.b = v(o, D.a, D.b, D.c, N.b, e.matrixWorld), V.clipValues.c = v(o, D.a, D.b, D.c, N.c, e.matrixWorld), this.splitTriangle(V, !C, w);
        }
        b = w;
      }
      for (let M = 0, C = b.length; M < C; M++) {
        const v = b[M];
        d(v, o);
      }
      n.reset();
    }
    return s;
    function d(f, y) {
      for (let g = 0; g < 3; g++) {
        const x = f.getVertexHash(g, y);
        x in h || (h[x] = u, u++, f.getVertexData(g, y, s.attributes), s.vertexIsClipped.push(f.clipValues[oe[g]] === H));
        const S = h[x];
        s.index.push(S);
      }
    }
  }
  // Takes the set of resultant data and constructs a mesh
  constructMesh(e, t, s) {
    const n = s.geometry, i = new jt(), r = e.position.length / 3 > 65535 ? new Uint32Array(t) : new Uint16Array(t);
    i.setIndex(new K(r, 1, !1));
    for (const l in e) {
      const c = n.getAttribute(l), u = new c.array.constructor(e[l]), h = new K(u, c.itemSize, c.normalized);
      h.gpuType = c.gpuType, i.setAttribute(l, h);
    }
    const o = new Be(i, s.material.clone());
    return o.position.copy(s.position), o.quaternion.copy(s.quaternion), o.scale.copy(s.scale), o;
  }
  // Splits the given triangle
  splitTriangle(e, t, s) {
    const { trianglePool: n } = this, i = [], r = [], o = [];
    for (let l = 0; l < 3; l++) {
      const c = oe[l], u = oe[(l + 1) % 3], h = e.clipValues[c], p = e.clipValues[u];
      (h < H != p < H || h === H) && (i.push(l), r.push([c, u]), h === p ? o.push(0) : o.push(_.mapLinear(H, h, p, 0, 1)));
    }
    if (i.length !== 2)
      Math.min(
        e.clipValues.a,
        e.clipValues.b,
        e.clipValues.c
      ) < H === t && s.push(e);
    else if (i.length === 2) {
      const l = n.get().initFromTriangle(e), c = n.get().initFromTriangle(e), u = n.get().initFromTriangle(e);
      (i[0] + 1) % 3 === i[1] ? (l.lerpVertexFromEdge(e, r[0][0], r[0][1], o[0], "a"), l.copyVertex(e, r[0][1], "b"), l.lerpVertexFromEdge(e, r[1][0], r[1][1], o[1], "c"), l.clipValues.a = H, l.clipValues.c = H, c.lerpVertexFromEdge(e, r[0][0], r[0][1], o[0], "a"), c.copyVertex(e, r[1][1], "b"), c.copyVertex(e, r[0][0], "c"), c.clipValues.a = H, u.lerpVertexFromEdge(e, r[0][0], r[0][1], o[0], "a"), u.lerpVertexFromEdge(e, r[1][0], r[1][1], o[1], "b"), u.copyVertex(e, r[1][1], "c"), u.clipValues.a = H, u.clipValues.b = H) : (l.lerpVertexFromEdge(e, r[0][0], r[0][1], o[0], "a"), l.lerpVertexFromEdge(e, r[1][0], r[1][1], o[1], "b"), l.copyVertex(e, r[0][0], "c"), l.clipValues.a = H, l.clipValues.b = H, c.lerpVertexFromEdge(e, r[0][0], r[0][1], o[0], "a"), c.copyVertex(e, r[0][1], "b"), c.lerpVertexFromEdge(e, r[1][0], r[1][1], o[1], "c"), c.clipValues.a = H, c.clipValues.c = H, u.copyVertex(e, r[0][1], "a"), u.copyVertex(e, r[1][0], "b"), u.lerpVertexFromEdge(e, r[1][0], r[1][1], o[1], "c"), u.clipValues.c = H);
      let p, m;
      p = Math.min(l.clipValues.a, l.clipValues.b, l.clipValues.c), m = p < H, m === t && s.push(l), p = Math.min(c.clipValues.a, c.clipValues.b, c.clipValues.c), m = p < H, m === t && s.push(c), p = Math.min(u.clipValues.a, u.clipValues.b, u.clipValues.c), m = p < H, m === t && s.push(u);
    }
  }
}
class Ci {
  constructor() {
    this.pool = [], this.index = 0;
  }
  get() {
    if (this.index >= this.pool.length) {
      const t = new vi();
      this.pool.push(t);
    }
    const e = this.pool[this.index];
    return this.index++, e;
  }
  reset() {
    this.index = 0;
  }
}
class vi {
  constructor() {
    this.indices = {
      a: -1,
      b: -1,
      c: -1
    }, this.clipValues = {
      a: -1,
      b: -1,
      c: -1
    }, this.barycoord = new Ht();
  }
  // returns a hash for the given [0, 2] index based on attributes of the referenced geometry
  getVertexHash(e, t) {
    const { barycoord: s, indices: n } = this, i = oe[e], r = s[i];
    if (r.x === 1)
      return n[oe[0]];
    if (r.y === 1)
      return n[oe[1]];
    if (r.z === 1)
      return n[oe[2]];
    {
      const { attributes: o } = t;
      let l = "";
      for (const c in o) {
        const u = o[c];
        switch (as(u, n.a, n.b, n.c, r, P), (c === "normal" || c === "tangent" || c === "bitangent") && P.normalize(), u.itemSize) {
          case 4:
            l += Ee(P.x, P.y, P.z, P.w);
            break;
          case 3:
            l += Ee(P.x, P.y, P.z);
            break;
          case 2:
            l += Ee(P.x, P.y);
            break;
          case 1:
            l += Ee(P.x);
            break;
        }
        l += "|";
      }
      return l;
    }
  }
  // Accumulate the vertex data in the given attribute arrays
  getVertexData(e, t, s) {
    const { barycoord: n, indices: i } = this, r = oe[e], o = n[r], { attributes: l } = t;
    for (const c in l) {
      if (!s[c])
        continue;
      const u = l[c], h = s[c];
      switch (as(u, i.a, i.b, i.c, o, P), (c === "normal" || c === "tangent" || c === "bitangent") && P.normalize(), u.itemSize) {
        case 4:
          h.push(P.x, P.y, P.z, P.w);
          break;
        case 3:
          h.push(P.x, P.y, P.z);
          break;
        case 2:
          h.push(P.x, P.y);
          break;
        case 1:
          h.push(P.x);
          break;
      }
    }
  }
  // Copy the indices from a target triangle
  initFromTriangle(e) {
    return this.initFromIndices(
      e.indices.a,
      e.indices.b,
      e.indices.c
    );
  }
  // Set the indices for the given
  initFromIndices(e, t, s) {
    return this.indices.a = e, this.indices.b = t, this.indices.c = s, this.clipValues.a = -1, this.clipValues.b = -1, this.clipValues.c = -1, this.barycoord.a.set(1, 0, 0), this.barycoord.b.set(0, 1, 0), this.barycoord.c.set(0, 0, 1), this;
  }
  // Lerp the given vertex along to the provided edge of the provided triangle
  lerpVertexFromEdge(e, t, s, n, i) {
    this.clipValues[i] = _.lerp(e.clipValues[t], e.clipValues[s], n), this.barycoord[i].lerpVectors(e.barycoord[t], e.barycoord[s], n);
  }
  // Copy a vertex from the provided triangle
  copyVertex(e, t, s) {
    this.clipValues[s] = e.clipValues[t], this.barycoord[s].copy(e.barycoord[t]);
  }
}
function as(a, e, t, s, n, i) {
  switch (is.fromBufferAttribute(a, e), rs.fromBufferAttribute(a, t), os.fromBufferAttribute(a, s), i.set(0, 0, 0, 0).addScaledVector(is, n.x).addScaledVector(rs, n.y).addScaledVector(os, n.z), a.itemSize) {
    case 3:
      P.w = 0;
      break;
    case 2:
      P.w = 0, P.z = 0;
      break;
    case 1:
      P.w = 0, P.z = 0, P.y = 0;
      break;
  }
  return i;
}
function Ee(...a) {
  let s = "";
  for (let n = 0, i = a.length; n < i; n++)
    s += ~~(a[n] * 1e5 + 0.5), n !== i - 1 && (s += "_");
  return s;
}
const ls = {}, Ai = /* @__PURE__ */ new E(), dt = /* @__PURE__ */ new E(), pt = /* @__PURE__ */ new E(), Li = /* @__PURE__ */ new E(), Ei = /* @__PURE__ */ new E(), Y = /* @__PURE__ */ new E(), Te = /* @__PURE__ */ new E(), X = /* @__PURE__ */ new W(), re = /* @__PURE__ */ new W(), cs = /* @__PURE__ */ new W();
class wi extends yn {
  constructor() {
    super(), this.ellipsoid = new cn(), this.skirtLength = 1e3, this.smoothSkirtNormals = !0, this.solid = !1, this.minLat = -Math.PI / 2, this.maxLat = Math.PI / 2, this.minLon = -Math.PI, this.maxLon = Math.PI, this.attributeList = ["position", "normal", "uv"];
  }
  clipToQuadrant(e, t, s) {
    const { solid: n, skirtLength: i, ellipsoid: r, smoothSkirtNormals: o } = this;
    this.clearSplitOperations(), this.addSplitOperation(us("x"), !t), this.addSplitOperation(us("y"), !s);
    let l, c;
    const u = e.geometry.groups[0], h = this.getClippedData(e, u);
    if (this.adjustVertices(h, e.position, 0), n) {
      l = {
        index: h.index.slice().reverse(),
        attributes: {}
      };
      for (const b in h.attributes)
        l.attributes[b] = h.attributes[b].slice();
      const T = l.attributes.normal;
      if (T)
        for (let b = 0; b < T.length; b += 3)
          T[b + 0] *= -1, T[b + 1] *= -1, T[b + 2] *= -1;
      this.adjustVertices(l, e.position, -i);
    }
    if (i > 0) {
      c = {
        index: [],
        attributes: {
          position: [],
          normal: [],
          uv: []
        }
      };
      let T = 0;
      const b = {}, M = (D, N, L) => {
        const A = Ee(...D, ...L, ...N);
        A in b || (b[A] = T, T++, c.attributes.position.push(...D), c.attributes.normal.push(...L), c.attributes.uv.push(...N)), c.index.push(b[A]);
      }, C = h.index, v = h.attributes.uv, w = h.attributes.position, I = h.attributes.normal, V = h.index.length / 3;
      for (let D = 0; D < V; D++) {
        const N = 3 * D;
        for (let L = 0; L < 3; L++) {
          const A = (L + 1) % 3, U = C[N + L], R = C[N + A];
          if (X.fromArray(v, U * 2), re.fromArray(v, R * 2), X.x === re.x && (X.x === 0 || X.x === 0.5 || X.x === 1) || X.y === re.y && (X.y === 0 || X.y === 0.5 || X.y === 1)) {
            dt.fromArray(w, U * 3), pt.fromArray(w, R * 3);
            const O = dt, z = pt, k = Li.copy(dt), F = Ei.copy(pt);
            Y.copy(k).add(e.position), r.getPositionToNormal(Y, Y), k.addScaledVector(Y, -i), Y.copy(F).add(e.position), r.getPositionToNormal(Y, Y), F.addScaledVector(Y, -i), o && I ? (Y.fromArray(I, U * 3), Te.fromArray(I, R * 3)) : (Y.subVectors(O, z), Te.subVectors(O, k).cross(Y).normalize(), Y.copy(Te)), M(z, re, Te), M(O, X, Y), M(k, X, Y), M(z, re, Te), M(k, X, Y), M(F, re, Te);
          }
        }
      }
    }
    const p = h.index.length, m = h;
    if (l) {
      const { index: T, attributes: b } = l, M = m.attributes.position.length / 3;
      for (let C = 0, v = T.length; C < v; C++)
        m.index.push(T[C] + M);
      for (const C in h.attributes)
        m.attributes[C].push(...b[C]);
    }
    if (c) {
      const { index: T, attributes: b } = c, M = m.attributes.position.length / 3;
      for (let C = 0, v = T.length; C < v; C++)
        m.index.push(T[C] + M);
      for (const C in h.attributes)
        m.attributes[C].push(...b[C]);
    }
    const d = t ? 0 : -0.5, f = s ? 0 : -0.5, y = m.attributes.uv;
    for (let T = 0, b = y.length; T < b; T += 2)
      y[T] = (y[T] + d) * 2, y[T + 1] = (y[T + 1] + f) * 2;
    const g = this.constructMesh(m.attributes, m.index, e);
    g.userData.minHeight = e.userData.minHeight, g.userData.maxHeight = e.userData.maxHeight;
    let x = 0, S = 0;
    return g.geometry.addGroup(S, p, x), S += p, x++, l && (g.geometry.addGroup(S, l.index.length, x), S += l.index.length, x++), c && (g.geometry.addGroup(S, c.index.length, x), S += c.index.length, x++), g;
  }
  adjustVertices(e, t, s) {
    const { ellipsoid: n, minLat: i, maxLat: r, minLon: o, maxLon: l } = this, { attributes: c, vertexIsClipped: u } = e, h = c.position, p = c.uv, m = h.length / 3;
    for (let d = 0; d < m; d++) {
      const f = X.fromArray(p, d * 2);
      u && u[d] && (Math.abs(f.x - 0.5) < 1e-10 && (f.x = 0.5), Math.abs(f.y - 0.5) < 1e-10 && (f.y = 0.5), X.toArray(p, d * 2));
      const y = _.lerp(i, r, f.y), g = _.lerp(o, l, f.x), x = Ai.fromArray(h, d * 3).add(t);
      n.getPositionToCartographic(x, ls), n.getCartographicToPosition(y, g, ls.height + s, x), x.sub(t), x.toArray(h, d * 3);
    }
  }
}
function us(a) {
  return (e, t, s, n, i) => {
    const r = e.attributes.uv;
    return X.fromBufferAttribute(r, t), re.fromBufferAttribute(r, s), cs.fromBufferAttribute(r, n), X[a] * i.x + re[a] * i.y + cs[a] * i.z - 0.5;
  };
}
const hs = Symbol("TILE_X"), ds = Symbol("TILE_Y"), we = Symbol("TILE_LEVEL"), pe = Symbol("TILE_AVAILABLE"), Ge = 1e4, ps = /* @__PURE__ */ new E();
function Ii(a, e, t, s) {
  if (a && e < a.length) {
    const n = a[e];
    for (let i = 0, r = n.length; i < r; i++) {
      const { startX: o, startY: l, endX: c, endY: u } = n[i];
      if (t >= o && t <= c && s >= l && s <= u)
        return !0;
    }
  }
  return !1;
}
function xn(a) {
  const { available: e = null, maxzoom: t = null } = a;
  return t === null ? e.length - 1 : t;
}
function Pi(a) {
  const { metadataAvailability: e = -1 } = a;
  return e;
}
function ft(a, e) {
  const t = a[we], s = Pi(e), n = xn(e);
  return t < n && s !== -1 && t % s === 0;
}
function Ri(a, e, t, s, n) {
  return n.tiles[0].replace(/{\s*z\s*}/g, t).replace(/{\s*x\s*}/g, a).replace(/{\s*y\s*}/g, e).replace(/{\s*version\s*}/g, s);
}
class Bi {
  constructor(e = {}) {
    const {
      useRecommendedSettings: t = !0,
      skirtLength: s = null,
      smoothSkirtNormals: n = !0,
      solid: i = !1
    } = e;
    this.name = "QUANTIZED_MESH_PLUGIN", this.priority = -1e3, this.tiles = null, this.layer = null, this.useRecommendedSettings = t, this.skirtLength = s, this.smoothSkirtNormals = n, this.solid = i, this.attribution = null, this.tiling = new fn(), this.projection = new ue();
  }
  // Plugin function
  init(e) {
    e.fetchOptions.headers = e.fetchOptions.headers || {}, e.fetchOptions.headers.Accept = "application/vnd.quantized-mesh,application/octet-stream;q=0.9", this.useRecommendedSettings && (e.errorTarget = 2), this.tiles = e;
  }
  loadRootTileSet() {
    const { tiles: e } = this;
    let t = new URL("layer.json", new URL(e.rootURL, location.href));
    return e.invokeAllPlugins((s) => t = s.preprocessURL ? s.preprocessURL(t, null) : t), e.invokeOnePlugin((s) => s.fetchData && s.fetchData(t, this.tiles.fetchOptions)).then((s) => s.json()).then((s) => {
      this.layer = s;
      const {
        projection: n = "EPSG:4326",
        extensions: i = [],
        attribution: r = "",
        available: o = null
      } = s, {
        tiling: l,
        tiles: c,
        projection: u
      } = this;
      r && (this.attribution = {
        value: r,
        type: "string",
        collapsible: !0
      }), i.length > 0 && (c.fetchOptions.headers.Accept += `;extensions=${i.join("-")}`), u.setScheme(n);
      const { tileCountX: h, tileCountY: p } = u;
      l.setProjection(u), l.generateLevels(xn(s) + 1, h, p);
      const m = [];
      for (let y = 0; y < h; y++) {
        const g = this.createChild(0, y, 0, o);
        g && m.push(g);
      }
      const d = {
        asset: {
          version: "1.1"
        },
        geometricError: 1 / 0,
        root: {
          refine: "REPLACE",
          geometricError: 1 / 0,
          boundingVolume: {
            region: [...this.tiling.getContentBounds(), -Ge, Ge]
          },
          children: m,
          [pe]: o,
          [we]: -1
        }
      };
      let f = c.rootURL;
      return c.invokeAllPlugins((y) => f = y.preprocessURL ? y.preprocessURL(f, null) : f), c.preprocessTileSet(d, f), d;
    });
  }
  parseToMesh(e, t, s, n) {
    const {
      skirtLength: i,
      solid: r,
      smoothSkirtNormals: o,
      tiles: l
    } = this, c = l.ellipsoid;
    let u;
    if (s === "quantized_tile_split") {
      const d = new URL(n).searchParams, f = d.get("left") === "true", y = d.get("bottom") === "true", g = new wi();
      g.ellipsoid.copy(c), g.solid = r, g.smoothSkirtNormals = o, g.skirtLength = i === null ? t.geometricError : i;
      const [x, S, T, b] = t.parent.boundingVolume.region;
      g.minLat = S, g.maxLat = b, g.minLon = x, g.maxLon = T, u = g.clipToQuadrant(t.parent.cached.scene, f, y);
    } else if (s === "terrain") {
      const d = new Mi(l.manager);
      d.ellipsoid.copy(c), d.solid = r, d.smoothSkirtNormals = o, d.skirtLength = i === null ? t.geometricError : i;
      const [f, y, g, x] = t.boundingVolume.region;
      d.minLat = y, d.maxLat = x, d.minLon = f, d.maxLon = g, u = d.parse(e);
    } else
      return;
    const { minHeight: h, maxHeight: p, metadata: m } = u.userData;
    return t.boundingVolume.region[4] = h, t.boundingVolume.region[5] = p, t.cached.boundingVolume.setRegionData(c, ...t.boundingVolume.region), m && ("geometricerror" in m && (t.geometricError = m.geometricerror), ft(t, this.layer) && "available" in m && t.children.length === 0 && (t[pe] = [
      ...new Array(t[we] + 1).fill(null),
      ...m.available
    ])), this.expandChildren(t), u;
  }
  getAttributions(e) {
    this.attribution && e.push(this.attribution);
  }
  // Local functions
  createChild(e, t, s, n) {
    const { tiles: i, layer: r, tiling: o, projection: l } = this, c = i.ellipsoid, u = n === null && e === 0 || Ii(n, e, t, s), h = Ri(t, s, e, 1, r), p = [...o.getTileBounds(t, s, e), -Ge, Ge], [
      /* west */
      ,
      m,
      /* east */
      ,
      d,
      /* minHeight */
      ,
      f
    ] = p, y = m > 0 != d > 0 ? 0 : Math.min(Math.abs(m), Math.abs(d));
    c.getCartographicToPosition(y, 0, f, ps), ps.z = 0;
    const g = l.tileCountX, T = Math.max(...c.radius) * 2 * Math.PI * 0.25 / (65 * g) / 2 ** e, b = {
      [pe]: null,
      [we]: e,
      [hs]: t,
      [ds]: s,
      refine: "REPLACE",
      geometricError: T,
      boundingVolume: { region: p },
      content: u ? { uri: h } : null,
      children: []
    };
    return ft(b, r) || (b[pe] = n), b;
  }
  expandChildren(e) {
    const t = e[we], s = e[hs], n = e[ds], i = e[pe];
    if (t >= this.tiling.maxLevel)
      return;
    let r = !1;
    for (let o = 0; o < 2; o++)
      for (let l = 0; l < 2; l++) {
        const c = this.createChild(t + 1, 2 * s + o, 2 * n + l, i);
        c.content !== null ? (e.children.push(c), r = !0) : (e.children.push(c), c.content = { uri: `tile.quantized_tile_split?bottom=${l === 0}&left=${o === 0}` });
      }
    r || (e.children.length = 0);
  }
  fetchData(e, t) {
    if (/quantized_tile_split/.test(e))
      return new ArrayBuffer();
  }
  disposeTile(e) {
    ft(e, this.layer) && (e[pe] = null), pe in e && (e.children.forEach((t) => {
      this.tiles.processNodeQueue.remove(t);
    }), e.children.length = 0, e.__childrenProcessed = 0);
  }
}
class io {
  get apiToken() {
    return this.auth.apiToken;
  }
  set apiToken(e) {
    this.auth.apiToken = e;
  }
  get autoRefreshToken() {
    return this.auth.autoRefreshToken;
  }
  set autoRefreshToken(e) {
    this.auth.autoRefreshToken = e;
  }
  constructor({ apiToken: e, assetId: t = null, autoRefreshToken: s = !1, useRecommendedSettings: n = !0 }) {
    this.name = "CESIUM_ION_AUTH_PLUGIN", this.auth = new Zs({ apiToken: e, autoRefreshToken: s }), this.assetId = t, this.autoRefreshToken = s, this.useRecommendedSettings = n, this.tiles = null, this._tileSetVersion = -1, this._attributions = [];
  }
  init(e) {
    this.assetId !== null && (e.rootURL = `https://api.cesium.com/v1/assets/${this.assetId}/endpoint`), this.tiles = e, this.auth.authURL = e.rootURL, e.resetFailedTiles();
  }
  loadRootTileSet() {
    return this.auth.refreshToken().then((e) => (this._initializeFromAsset(e), this.tiles.invokeOnePlugin((t) => t !== this && t.loadRootTileSet && t.loadRootTileSet()))).catch((e) => {
      this.tiles.dispatchEvent({
        type: "load-error",
        tile: null,
        error: e,
        url: this.auth.authURL
      });
    });
  }
  preprocessURL(e) {
    return e = new URL(e), /^http/.test(e.protocol) && this._tileSetVersion != -1 && e.searchParams.set("v", this._tileSetVersion), e.toString();
  }
  fetchData(e, t) {
    return this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN") !== null ? null : this.auth.fetch(e, t);
  }
  getAttributions(e) {
    this.tiles.visibleTiles.size > 0 && e.push(...this._attributions);
  }
  _initializeFromAsset(e) {
    const t = this.tiles;
    if ("externalType" in e) {
      const s = new URL(e.options.url);
      t.rootURL = e.options.url, t.registerPlugin(new gi({
        apiToken: s.searchParams.get("key"),
        autoRefreshToken: this.autoRefreshToken,
        useRecommendedSettings: this.useRecommendedSettings
      }));
    } else {
      e.type === "TERRAIN" && t.getPluginByName("QUANTIZED_MESH_PLUGIN") === null ? t.registerPlugin(new Bi({
        useRecommendedSettings: this.useRecommendedSettings
      })) : e.type === "IMAGERY" && t.getPluginByName("TMS_TILES_PLUGIN") === null && t.registerPlugin(new Si({
        useRecommendedSettings: this.useRecommendedSettings,
        shape: "ellipsoid"
      })), t.rootURL = e.url;
      const s = new URL(e.url);
      s.searchParams.has("v") && this._tileSetVersion === -1 && (this._tileSetVersion = s.searchParams.get("v")), e.attributions && (this._attributions = e.attributions.map((n) => ({
        value: n.html,
        type: "html",
        collapsible: n.collapsible
      })));
    }
  }
}
const mt = /* @__PURE__ */ new Q();
class ro {
  constructor() {
    this.name = "UPDATE_ON_CHANGE_PLUGIN", this.tiles = null, this.needsUpdate = !1, this.cameraMatrices = /* @__PURE__ */ new Map();
  }
  init(e) {
    this.tiles = e, this._needsUpdateCallback = () => {
      this.needsUpdate = !0;
    }, this._onCameraAdd = ({ camera: t }) => {
      this.needsUpdate = !0, this.cameraMatrices.set(t, new Q());
    }, this._onCameraDelete = ({ camera: t }) => {
      this.needsUpdate = !0, this.cameraMatrices.delete(t);
    }, e.addEventListener("needs-update", this._needsUpdateCallback), e.addEventListener("add-camera", this._onCameraAdd), e.addEventListener("delete-camera", this._onCameraDelete), e.addEventListener("camera-resolution-change", this._needsUpdateCallback), e.cameras.forEach((t) => {
      this._onCameraAdd({ camera: t });
    });
  }
  doTilesNeedUpdate() {
    const e = this.tiles;
    let t = !1;
    this.cameraMatrices.forEach((n, i) => {
      mt.copy(e.group.matrixWorld).premultiply(i.matrixWorldInverse).premultiply(i.projectionMatrixInverse), t = t || !mt.equals(n), n.copy(mt);
    });
    const s = this.needsUpdate;
    return this.needsUpdate = !1, s || t;
  }
  preprocessNode() {
    this.needsUpdate = !0;
  }
  dispose() {
    const e = this.tiles;
    e.removeEventListener("camera-resolution-change", this._needsUpdateCallback), e.removeEventListener("needs-update", this._needsUpdateCallback), e.removeEventListener("add-camera", this._onCameraAdd), e.removeEventListener("delete-camera", this._onCameraDelete);
  }
}
const fs = new E();
function Ce(a, e) {
  if (a.isInterleavedBufferAttribute || a.array instanceof e)
    return a;
  const s = e === Int8Array || e === Int16Array || e === Int32Array ? -1 : 0, n = new e(a.count * a.itemSize), i = new K(n, a.itemSize, !0), r = a.itemSize, o = a.count;
  for (let l = 0; l < o; l++)
    for (let c = 0; c < r; c++) {
      const u = _.clamp(a.getComponent(l, c), s, 1);
      i.setComponent(l, c, u);
    }
  return i;
}
function Di(a, e = Int16Array) {
  const t = a.geometry, s = t.attributes, n = s.position;
  if (n.isInterleavedBufferAttribute || n.array instanceof e)
    return n;
  const i = new e(n.count * n.itemSize), r = new K(i, n.itemSize, !1), o = n.itemSize, l = n.count;
  t.computeBoundingBox();
  const c = t.boundingBox, { min: u, max: h } = c, p = 2 ** (8 * e.BYTES_PER_ELEMENT - 1) - 1, m = -p;
  for (let d = 0; d < l; d++)
    for (let f = 0; f < o; f++) {
      const y = f === 0 ? "x" : f === 1 ? "y" : "z", g = u[y], x = h[y], S = _.mapLinear(
        n.getComponent(d, f),
        g,
        x,
        m,
        p
      );
      r.setComponent(d, f, S);
    }
  c.getCenter(fs).multiply(a.scale).applyQuaternion(a.quaternion), a.position.add(fs), a.scale.x *= 0.5 * (h.x - u.x) / p, a.scale.y *= 0.5 * (h.y - u.y) / p, a.scale.z *= 0.5 * (h.z - u.z) / p, s.position = r, a.geometry.boundingBox = null, a.geometry.boundingSphere = null, a.updateMatrixWorld();
}
class oo {
  constructor(e) {
    this._options = {
      // whether to generate normals if they don't already exist.
      generateNormals: !1,
      // whether to disable use of mipmaps since they are typically not necessary
      // with something like 3d tiles.
      disableMipmaps: !0,
      // whether to compress certain attributes
      compressIndex: !0,
      compressNormals: !1,
      compressUvs: !1,
      compressPosition: !1,
      // the TypedArray type to use when compressing the attributes
      uvType: Int8Array,
      normalType: Int8Array,
      positionType: Int16Array,
      ...e
    }, this.name = "TILES_COMPRESSION_PLUGIN", this.priority = -100;
  }
  processTileModel(e, t) {
    const {
      generateNormals: s,
      disableMipmaps: n,
      compressIndex: i,
      compressUvs: r,
      compressNormals: o,
      compressPosition: l,
      uvType: c,
      normalType: u,
      positionType: h
    } = this._options;
    e.traverse((p) => {
      if (p.material && n) {
        const m = p.material;
        for (const d in m) {
          const f = m[d];
          f && f.isTexture && f.generateMipmaps && (f.generateMipmaps = !1, f.minFilter = sn);
        }
      }
      if (p.geometry) {
        const m = p.geometry, d = m.attributes;
        if (r) {
          const { uv: f, uv1: y, uv2: g, uv3: x } = d;
          f && (d.uv = Ce(f, c)), y && (d.uv1 = Ce(y, c)), g && (d.uv2 = Ce(g, c)), x && (d.uv3 = Ce(x, c));
        }
        if (s && !d.normals && m.computeVertexNormals(), o && d.normals && (d.normals = Ce(d.normals, u)), l && Di(p, h), i && m.index) {
          const f = d.position.count, y = m.index, g = f > 65535 ? Uint32Array : f > 255 ? Uint16Array : Uint8Array;
          if (!(y.array instanceof g)) {
            const x = new g(m.index.count);
            x.set(y.array);
            const S = new K(x, 1);
            m.setIndex(S);
          }
        }
      }
    });
  }
}
function q(a, e, t) {
  return a && e in a ? a[e] : t;
}
function Tn(a) {
  return a !== "BOOLEAN" && a !== "STRING" && a !== "ENUM";
}
function Ui(a) {
  return /^FLOAT/.test(a);
}
function Oe(a) {
  return /^VEC/.test(a);
}
function Ve(a) {
  return /^MAT/.test(a);
}
function bn(a, e, t, s = null) {
  return Ve(t) || Oe(t) ? s.fromArray(a, e) : a[e];
}
function Ut(a) {
  const { type: e, componentType: t } = a;
  switch (e) {
    case "SCALAR":
      return t === "INT64" ? 0n : 0;
    case "VEC2":
      return new W();
    case "VEC3":
      return new E();
    case "VEC4":
      return new Ue();
    case "MAT2":
      return new Gn();
    case "MAT3":
      return new kn();
    case "MAT4":
      return new Q();
    case "BOOLEAN":
      return !1;
    case "STRING":
      return "";
    // the final value for enums is a string but are represented as integers
    // during intermediate steps
    case "ENUM":
      return 0;
  }
}
function ms(a, e) {
  if (e == null)
    return !1;
  switch (a) {
    case "SCALAR":
      return typeof e == "number" || typeof e == "bigint";
    case "VEC2":
      return e.isVector2;
    case "VEC3":
      return e.isVector3;
    case "VEC4":
      return e.isVector4;
    case "MAT2":
      return e.isMatrix2;
    case "MAT3":
      return e.isMatrix3;
    case "MAT4":
      return e.isMatrix4;
    case "BOOLEAN":
      return typeof e == "boolean";
    case "STRING":
      return typeof e == "string";
    case "ENUM":
      return typeof e == "number" || typeof e == "bigint";
  }
  throw new Error("ClassProperty: invalid type.");
}
function Re(a, e = null) {
  switch (a) {
    case "INT8":
      return Int8Array;
    case "INT16":
      return Int16Array;
    case "INT32":
      return Int32Array;
    case "INT64":
      return BigInt64Array;
    case "UINT8":
      return Uint8Array;
    case "UINT16":
      return Uint16Array;
    case "UINT32":
      return Uint32Array;
    case "UINT64":
      return BigUint64Array;
    case "FLOAT32":
      return Float32Array;
    case "FLOAT64":
      return Float64Array;
  }
  switch (e) {
    case "BOOLEAN":
      return Uint8Array;
    case "STRING":
      return Uint8Array;
  }
  throw new Error("ClassProperty: invalid type.");
}
function Oi(a, e = null) {
  if (a.array) {
    e = e && Array.isArray(e) ? e : [], e.length = a.count;
    for (let s = 0, n = e.length; s < n; s++)
      e[s] = Ze(a, e[s]);
  } else
    e = Ze(a, e);
  return e;
}
function Ze(a, e = null) {
  const t = a.default, s = a.type;
  if (e = e || Ut(a), t === null) {
    switch (s) {
      case "SCALAR":
        return 0;
      case "VEC2":
        return e.set(0, 0);
      case "VEC3":
        return e.set(0, 0, 0);
      case "VEC4":
        return e.set(0, 0, 0, 0);
      case "MAT2":
        return e.identity();
      case "MAT3":
        return e.identity();
      case "MAT4":
        return e.identity();
      case "BOOLEAN":
        return !1;
      case "STRING":
        return "";
      case "ENUM":
        return "";
    }
    throw new Error("ClassProperty: invalid type.");
  } else if (Ve(s))
    e.fromArray(t);
  else if (Oe(s))
    e.fromArray(t);
  else
    return t;
}
function Vi(a, e) {
  if (a.noData === null)
    return e;
  const t = a.noData, s = a.type;
  if (Array.isArray(e))
    for (let r = 0, o = e.length; r < o; r++)
      e[r] = n(e[r]);
  else
    e = n(e);
  return e;
  function n(r) {
    return i(r) && (r = Ze(a, r)), r;
  }
  function i(r) {
    if (Ve(s)) {
      const o = r.elements;
      for (let l = 0, c = t.length; l < c; l++)
        if (t[l] !== o[l])
          return !1;
      return !0;
    } else if (Oe(s)) {
      for (let o = 0, l = t.length; o < l; o++)
        if (t[o] !== r.getComponent(o))
          return !1;
      return !0;
    } else
      return t === r;
  }
}
function Fi(a, e) {
  switch (a) {
    case "INT8":
      return Math.max(e / 127, -1);
    case "INT16":
      return Math.max(e, 32767, -1);
    case "INT32":
      return Math.max(e / 2147483647, -1);
    case "INT64":
      return Math.max(Number(e) / 9223372036854776e3, -1);
    // eslint-disable-line no-loss-of-precision
    case "UINT8":
      return e / 255;
    case "UINT16":
      return e / 65535;
    case "UINT32":
      return e / 4294967295;
    case "UINT64":
      return Number(e) / 18446744073709552e3;
  }
}
function Ni(a, e) {
  const {
    type: t,
    componentType: s,
    scale: n,
    offset: i,
    normalized: r
  } = a;
  if (Array.isArray(e))
    for (let h = 0, p = e.length; h < p; h++)
      e[h] = o(e[h]);
  else
    e = o(e);
  return e;
  function o(h) {
    return Ve(t) ? h = c(h) : Oe(t) ? h = l(h) : h = u(h), h;
  }
  function l(h) {
    return h.x = u(h.x), h.y = u(h.y), "z" in h && (h.z = u(h.z)), "w" in h && (h.w = u(h.w)), h;
  }
  function c(h) {
    const p = h.elements;
    for (let m = 0, d = p.length; m < d; m++)
      p[m] = u(p[m]);
    return h;
  }
  function u(h) {
    return r && (h = Fi(s, h)), (r || Ui(s)) && (h = h * n + i), h;
  }
}
function Yt(a, e, t = null) {
  if (a.array) {
    Array.isArray(e) || (e = new Array(a.count || 0)), e.length = t !== null ? t : a.count;
    for (let s = 0, n = e.length; s < n; s++)
      ms(a.type, e[s]) || (e[s] = Ut(a));
  } else
    ms(a.type, e) || (e = Ut(a));
  return e;
}
function Je(a, e) {
  for (const t in e)
    t in a || delete e[t];
  for (const t in a) {
    const s = a[t];
    e[t] = Yt(s, e[t]);
  }
}
function ki(a) {
  switch (a) {
    case "ENUM":
      return 1;
    case "SCALAR":
      return 1;
    case "VEC2":
      return 2;
    case "VEC3":
      return 3;
    case "VEC4":
      return 4;
    case "MAT2":
      return 4;
    case "MAT3":
      return 9;
    case "MAT4":
      return 16;
    // unused
    case "BOOLEAN":
      return -1;
    case "STRING":
      return -1;
    default:
      return -1;
  }
}
class ot {
  constructor(e, t, s = null) {
    this.name = t.name || null, this.description = t.description || null, this.type = t.type, this.componentType = t.componentType || null, this.enumType = t.enumType || null, this.array = t.array || !1, this.count = t.count || 0, this.normalized = t.normalized || !1, this.offset = t.offset || 0, this.scale = q(t, "scale", 1), this.max = q(t, "max", 1 / 0), this.min = q(t, "min", -1 / 0), this.required = t.required || !1, this.noData = q(t, "noData", null), this.default = q(t, "default", null), this.semantic = q(t, "semantic", null), this.enumSet = null, this.accessorProperty = s, s && (this.offset = q(s, "offset", this.offset), this.scale = q(s, "scale", this.scale), this.max = q(s, "max", this.max), this.min = q(s, "min", this.min)), t.type === "ENUM" && (this.enumSet = e[this.enumType], this.componentType === null && (this.componentType = q(this.enumSet, "valueType", "UINT16")));
  }
  // shape the given target to match the data type of the property
  // enums are set to their integer value
  shapeToProperty(e, t = null) {
    return Yt(this, e, t);
  }
  // resolve the given object to the default value for the property for a single element
  // enums are set to a default string
  resolveDefaultElement(e) {
    return Ze(this, e);
  }
  // resolve the target to the default value for the property for every element if it's an array
  // enums are set to a default string
  resolveDefault(e) {
    return Oi(this, e);
  }
  // converts any instances of no data to the default value
  resolveNoData(e) {
    return Vi(this, e);
  }
  // converts enums integers in the given target to strings
  resolveEnumsToStrings(e) {
    const t = this.enumSet;
    if (this.type === "ENUM")
      if (Array.isArray(e))
        for (let n = 0, i = e.length; n < i; n++)
          e[n] = s(e[n]);
      else
        e = s(e);
    return e;
    function s(n) {
      const i = t.values.find((r) => r.value === n);
      return i === null ? "" : i.name;
    }
  }
  // apply scales
  adjustValueScaleOffset(e) {
    return Tn(this.type) ? Ni(this, e) : e;
  }
}
class $t {
  constructor(e, t = {}, s = {}, n = null) {
    this.definition = e, this.class = t[e.class], this.className = e.class, this.enums = s, this.data = n, this.name = "name" in e ? e.name : null, this.properties = null;
  }
  getPropertyNames() {
    return Object.keys(this.class.properties);
  }
  includesData(e) {
    return !!this.definition.properties[e];
  }
  dispose() {
  }
  _initProperties(e = ot) {
    const t = {};
    for (const s in this.class.properties)
      t[s] = new e(this.enums, this.class.properties[s], this.definition.properties[s]);
    this.properties = t;
  }
}
class Gi extends ot {
  constructor(e, t, s = null) {
    super(e, t, s), this.attribute = (s == null ? void 0 : s.attribute) ?? null;
  }
}
class ji extends $t {
  constructor(...e) {
    super(...e), this.isPropertyAttributeAccessor = !0, this._initProperties(Gi);
  }
  getData(e, t, s = {}) {
    const n = this.properties;
    Je(n, s);
    for (const i in n)
      s[i] = this.getPropertyValue(i, e, t, s[i]);
    return s;
  }
  getPropertyValue(e, t, s, n = null) {
    if (t >= this.count)
      throw new Error("PropertyAttributeAccessor: Requested index is outside the range of the buffer.");
    const i = this.properties[e], r = i.type;
    if (i) {
      if (!this.definition.properties[e])
        return i.resolveDefault(n);
    } else throw new Error("PropertyAttributeAccessor: Requested class property does not exist.");
    n = i.shapeToProperty(n);
    const o = s.getAttribute(i.attribute.toLowerCase());
    if (Ve(r)) {
      const l = n.elements;
      for (let c = 0, u = l.length; c < u; c < u)
        l[c] = o.getComponent(t, c);
    } else if (Oe(r))
      n.fromBufferAttribute(o, t);
    else if (r === "SCALAR" || r === "ENUM")
      n = o.getX(t);
    else
      throw new Error("StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.");
    return n = i.adjustValueScaleOffset(n), n = i.resolveEnumsToStrings(n), n = i.resolveNoData(n), n;
  }
}
class zi extends ot {
  constructor(e, t, s = null) {
    super(e, t, s), this.values = (s == null ? void 0 : s.values) ?? null, this.valueLength = ki(this.type), this.arrayOffsets = q(s, "arrayOffsets", null), this.stringOffsets = q(s, "stringOffsets", null), this.arrayOffsetType = q(s, "arrayOffsetType", "UINT32"), this.stringOffsetType = q(s, "stringOffsetType", "UINT32");
  }
  // returns the necessary array length based on the array offsets if present
  getArrayLengthFromId(e, t) {
    let s = this.count;
    if (this.arrayOffsets !== null) {
      const { arrayOffsets: n, arrayOffsetType: i } = this, r = Re(i), o = new r(e[n]);
      s = o[t + 1] - o[t];
    }
    return s;
  }
  // returns the index offset into the data buffer for the given id based on the
  // the array offsets if present
  getIndexOffsetFromId(e, t) {
    let s = t;
    if (this.arrayOffsets) {
      const { arrayOffsets: n, arrayOffsetType: i } = this, r = Re(i);
      s = new r(e[n])[s];
    } else this.array && (s *= this.count);
    return s;
  }
}
class Hi extends $t {
  constructor(...e) {
    super(...e), this.isPropertyTableAccessor = !0, this.count = this.definition.count, this._initProperties(zi);
  }
  getData(e, t = {}) {
    const s = this.properties;
    Je(s, t);
    for (const n in s)
      t[n] = this.getPropertyValue(n, e, t[n]);
    return t;
  }
  // reads an individual element
  _readValueAtIndex(e, t, s, n = null) {
    const i = this.properties[e], { componentType: r, type: o } = i, l = this.data, c = l[i.values], u = Re(r, o), h = new u(c), p = i.getIndexOffsetFromId(l, t);
    if (Tn(o) || o === "ENUM")
      return bn(h, (p + s) * i.valueLength, o, n);
    if (o === "STRING") {
      let m = p + s, d = 0;
      if (i.stringOffsets !== null) {
        const { stringOffsets: y, stringOffsetType: g } = i, x = Re(g), S = new x(l[y]);
        d = S[m + 1] - S[m], m = S[m];
      }
      const f = new Uint8Array(h.buffer, m, d);
      n = new TextDecoder().decode(f);
    } else if (o === "BOOLEAN") {
      const m = p + s, d = Math.floor(m / 8), f = m % 8;
      n = (h[d] >> f & 1) === 1;
    }
    return n;
  }
  // Reads the data for the given table index
  getPropertyValue(e, t, s = null) {
    if (t >= this.count)
      throw new Error("PropertyTableAccessor: Requested index is outside the range of the table.");
    const n = this.properties[e];
    if (n) {
      if (!this.definition.properties[e])
        return n.resolveDefault(s);
    } else throw new Error("PropertyTableAccessor: Requested property does not exist.");
    const i = n.array, r = this.data, o = n.getArrayLengthFromId(r, t);
    if (s = n.shapeToProperty(s, o), i)
      for (let l = 0, c = s.length; l < c; l++)
        s[l] = this._readValueAtIndex(e, t, l, s[l]);
    else
      s = this._readValueAtIndex(e, t, 0, s);
    return s = n.adjustValueScaleOffset(s), s = n.resolveEnumsToStrings(s), s = n.resolveNoData(s), s;
  }
}
const ve = /* @__PURE__ */ new Wn();
class gs {
  constructor() {
    this._renderer = new jn(), this._target = new Dt(1, 1), this._texTarget = new Dt(), this._quad = new un(new nn({
      blending: qn,
      blendDst: Hn,
      blendSrc: zn,
      uniforms: {
        map: { value: null },
        pixel: { value: new W() }
      },
      vertexShader: (
        /* glsl */
        `
				void main() {

					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `
				uniform sampler2D map;
				uniform ivec2 pixel;

				void main() {

					gl_FragColor = texelFetch( map, pixel, 0 );

				}
			`
      )
    }));
  }
  // increases the width of the target render target to support more data
  increaseSizeTo(e) {
    this._target.setSize(Math.max(this._target.width, e), 1);
  }
  // read data from the rendered texture asynchronously
  readDataAsync(e) {
    const { _renderer: t, _target: s } = this;
    return t.readRenderTargetPixelsAsync(s, 0, 0, e.length / 4, 1, e);
  }
  // read data from the rendered texture
  readData(e) {
    const { _renderer: t, _target: s } = this;
    t.readRenderTargetPixels(s, 0, 0, e.length / 4, 1, e);
  }
  // render a single pixel from the source at the destination point on the render target
  // takes the texture, pixel to read from, and pixel to render in to
  renderPixelToTarget(e, t, s) {
    const { _renderer: n, _target: i } = this;
    ve.min.copy(t), ve.max.copy(t), ve.max.x += 1, ve.max.y += 1, n.initRenderTarget(i), n.copyTextureToTexture(e, i.texture, ve, s, 0);
  }
}
const le = /* @__PURE__ */ new class {
  constructor() {
    let a = null;
    Object.getOwnPropertyNames(gs.prototype).forEach((e) => {
      e !== "constructor" && (this[e] = (...t) => (a = a || new gs(), a[e](...t)));
    });
  }
}(), ys = /* @__PURE__ */ new W(), xs = /* @__PURE__ */ new W(), Ts = /* @__PURE__ */ new W();
function qi(a, e) {
  return e === 0 ? a.getAttribute("uv") : a.getAttribute(`uv${e}`);
}
function _n(a, e, t = new Array(3)) {
  let s = 3 * e, n = 3 * e + 1, i = 3 * e + 2;
  return a.index && (s = a.index.getX(s), n = a.index.getX(n), i = a.index.getX(i)), t[0] = s, t[1] = n, t[2] = i, t;
}
function Sn(a, e, t, s, n) {
  const [i, r, o] = s, l = qi(a, e);
  ys.fromBufferAttribute(l, i), xs.fromBufferAttribute(l, r), Ts.fromBufferAttribute(l, o), n.set(0, 0, 0).addScaledVector(ys, t.x).addScaledVector(xs, t.y).addScaledVector(Ts, t.z);
}
function Mn(a, e, t, s) {
  const n = a.x - Math.floor(a.x), i = a.y - Math.floor(a.y), r = Math.floor(n * e % e), o = Math.floor(i * t % t);
  return s.set(r, o), s;
}
const bs = /* @__PURE__ */ new W(), _s = /* @__PURE__ */ new W(), Ss = /* @__PURE__ */ new W();
class Wi extends ot {
  constructor(e, t, s = null) {
    super(e, t, s), this.channels = q(s, "channels", [0]), this.index = q(s, "index", null), this.texCoord = q(s, "texCoord", null), this.valueLength = parseInt(this.type.replace(/[^0-9]/g, "")) || 1;
  }
  // takes the buffer to read from and the value index to read
  readDataFromBuffer(e, t, s = null) {
    const n = this.type;
    if (n === "BOOLEAN" || n === "STRING")
      throw new Error("PropertyTextureAccessor: BOOLEAN and STRING types not supported.");
    return bn(e, t * this.valueLength, n, s);
  }
}
class Xi extends $t {
  constructor(...e) {
    super(...e), this.isPropertyTextureAccessor = !0, this._asyncRead = !1, this._initProperties(Wi);
  }
  // Reads the full set of property data
  getData(e, t, s, n = {}) {
    const i = this.properties;
    Je(i, n);
    const r = Object.keys(i), o = r.map((l) => n[l]);
    return this.getPropertyValuesAtTexel(r, e, t, s, o), r.forEach((l, c) => n[l] = o[c]), n;
  }
  // Reads the full set of property data asynchronously
  async getDataAsync(e, t, s, n = {}) {
    const i = this.properties;
    Je(i, n);
    const r = Object.keys(i), o = r.map((l) => n[l]);
    return await this.getPropertyValuesAtTexelAsync(r, e, t, s, o), r.forEach((l, c) => n[l] = o[c]), n;
  }
  // Reads values asynchronously
  getPropertyValuesAtTexelAsync(...e) {
    this._asyncRead = !0;
    const t = this.getPropertyValuesAtTexel(...e);
    return this._asyncRead = !1, t;
  }
  // Reads values from the textures synchronously
  getPropertyValuesAtTexel(e, t, s, n, i = []) {
    for (; i.length < e.length; ) i.push(null);
    i.length = e.length, le.increaseSizeTo(i.length);
    const r = this.data, o = this.definition.properties, l = this.properties, c = _n(n, t);
    for (let p = 0, m = e.length; p < m; p++) {
      const d = e[p];
      if (!o[d])
        continue;
      const f = l[d], y = r[f.index];
      Sn(n, f.texCoord, s, c, bs), Mn(bs, y.image.width, y.image.height, _s), Ss.set(p, 0), le.renderPixelToTarget(y, _s, Ss);
    }
    const u = new Uint8Array(e.length * 4);
    if (this._asyncRead)
      return le.readDataAsync(u).then(() => (h.call(this), i));
    return le.readData(u), h.call(this), i;
    function h() {
      for (let p = 0, m = e.length; p < m; p++) {
        const d = e[p], f = l[d], y = f.type;
        if (i[p] = Yt(f, i[p]), f) {
          if (!o[d]) {
            i[p] = f.resolveDefault(i);
            continue;
          }
        } else throw new Error("PropertyTextureAccessor: Requested property does not exist.");
        const g = f.valueLength * (f.count || 1), x = f.channels.map((M) => u[4 * p + M]), S = f.componentType, T = Re(S, y), b = new T(g);
        if (new Uint8Array(b.buffer).set(x), f.array) {
          const M = i[p];
          for (let C = 0, v = M.length; C < v; C++)
            M[C] = f.readDataFromBuffer(b, C, M[C]);
        } else
          i[p] = f.readDataFromBuffer(b, 0, i[p]);
        i[p] = f.adjustValueScaleOffset(i[p]), i[p] = f.resolveEnumsToStrings(i[p]), i[p] = f.resolveNoData(i[p]);
      }
    }
  }
  // dispose all of the texture data used
  dispose() {
    this.data.forEach((e) => {
      e && (e.dispose(), e.image instanceof ImageBitmap && e.image.close());
    });
  }
}
class Ms {
  constructor(e, t, s, n = null, i = null) {
    const {
      schema: r,
      propertyTables: o = [],
      propertyTextures: l = [],
      propertyAttributes: c = []
    } = e, { enums: u, classes: h } = r, p = o.map((f) => new Hi(f, h, u, s));
    let m = [], d = [];
    n && (n.propertyTextures && (m = n.propertyTextures.map((f) => new Xi(l[f], h, u, t))), n.propertyAttributes && (d = n.propertyAttributes.map((f) => new ji(c[f], h, u)))), this.schema = r, this.tableAccessors = p, this.textureAccessors = m, this.attributeAccessors = d, this.object = i, this.textures = t, this.nodeMetadata = n;
  }
  // Property Tables
  getPropertyTableData(e, t, s = null) {
    if (!Array.isArray(e) || !Array.isArray(t))
      s = s || {}, s = this.tableAccessors[e].getData(t, s);
    else {
      s = s || [];
      const n = Math.min(e.length, t.length);
      s.length = n;
      for (let i = 0; i < n; i++) {
        const r = this.tableAccessors[e[i]];
        s[i] = r.getData(t[i], s[i]);
      }
    }
    return s;
  }
  getPropertyTableInfo(e = null) {
    if (e === null && (e = this.tableAccessors.map((t, s) => s)), Array.isArray(e))
      return e.map((t) => {
        const s = this.tableAccessors[t];
        return {
          name: s.name,
          className: s.definition.class
        };
      });
    {
      const t = this.tableAccessors[e];
      return {
        name: t.name,
        className: t.definition.class
      };
    }
  }
  // Property Textures
  getPropertyTextureData(e, t, s = []) {
    const n = this.textureAccessors;
    s.length = n.length;
    for (let i = 0; i < n.length; i++) {
      const r = n[i];
      s[i] = r.getData(e, t, this.object.geometry, s[i]);
    }
    return s;
  }
  async getPropertyTextureDataAsync(e, t, s = []) {
    const n = this.textureAccessors;
    s.length = n.length;
    const i = [];
    for (let r = 0; r < n.length; r++) {
      const l = n[r].getDataAsync(e, t, this.object.geometry, s[r]).then((c) => {
        s[r] = c;
      });
      i.push(l);
    }
    return await Promise.all(i), s;
  }
  getPropertyTextureInfo() {
    return this.textureAccessors;
  }
  // Property Attributes
  getPropertyAttributeData(e, t = []) {
    const s = this.attributeAccessors;
    t.length = s.length;
    for (let n = 0; n < s.length; n++) {
      const i = s[n];
      t[n] = i.getData(e, this.object.geometry, t[n]);
    }
    return t;
  }
  getPropertyAttributeInfo() {
    return this.attributeAccessors.map((e) => ({
      name: e.name,
      className: e.definition.class
    }));
  }
  dispose() {
    this.textureAccessors.forEach((e) => e.dispose()), this.tableAccessors.forEach((e) => e.dispose()), this.attributeAccessors.forEach((e) => e.dispose());
  }
}
const Ae = "EXT_structural_metadata";
function Yi(a, e = []) {
  var n;
  const t = ((n = a.json.textures) == null ? void 0 : n.length) || 0, s = new Array(t).fill(null);
  return e.forEach(({ properties: i }) => {
    for (const r in i) {
      const { index: o } = i[r];
      s[o] === null && (s[o] = a.loadTexture(o));
    }
  }), Promise.all(s);
}
function $i(a, e = []) {
  var n;
  const t = ((n = a.json.bufferViews) == null ? void 0 : n.length) || 0, s = new Array(t).fill(null);
  return e.forEach(({ properties: i }) => {
    for (const r in i) {
      const { values: o, arrayOffsets: l, stringOffsets: c } = i[r];
      s[o] === null && (s[o] = a.loadBufferView(o)), s[l] === null && (s[l] = a.loadBufferView(l)), s[c] === null && (s[c] = a.loadBufferView(c));
    }
  }), Promise.all(s);
}
class Qi {
  constructor(e) {
    this.parser = e, this.name = Ae;
  }
  async afterRoot({ scene: e, parser: t }) {
    const s = t.json.extensionsUsed;
    if (!s || !s.includes(Ae))
      return;
    let n = null, i = t.json.extensions[Ae];
    if (i.schemaUri) {
      const { manager: c, path: u, requestHeader: h, crossOrigin: p } = t.options, m = new URL(i.schemaUri, u).toString(), d = new Xn(c);
      d.setCrossOrigin(p), d.setResponseType("json"), d.setRequestHeader(h), n = d.loadAsync(m).then((f) => {
        i = { ...i, schema: f };
      });
    }
    const [r, o] = await Promise.all([
      Yi(t, i.propertyTextures),
      $i(t, i.propertyTables),
      n
    ]), l = new Ms(i, r, o);
    e.userData.structuralMetadata = l, e.traverse((c) => {
      var u;
      if (t.associations.has(c)) {
        const { meshes: h, primitives: p } = t.associations.get(c), m = (u = t.json.meshes[h]) == null ? void 0 : u.primitives[p];
        if (m && m.extensions && m.extensions[Ae]) {
          const d = m.extensions[Ae];
          c.userData.structuralMetadata = new Ms(i, r, o, d, c);
        } else
          c.userData.structuralMetadata = l;
      }
    });
  }
}
const Cs = /* @__PURE__ */ new W(), vs = /* @__PURE__ */ new W(), As = /* @__PURE__ */ new W();
function Zi(a) {
  return a.x > a.y && a.x > a.z ? 0 : a.y > a.z ? 1 : 2;
}
class Ji {
  constructor(e, t, s) {
    this.geometry = e, this.textures = t, this.data = s, this._asyncRead = !1, this.featureIds = s.featureIds.map((n) => {
      const { texture: i, ...r } = n, o = {
        label: null,
        propertyTable: null,
        nullFeatureId: null,
        ...r
      };
      return i && (o.texture = {
        texCoord: 0,
        channels: [0],
        ...i
      }), o;
    });
  }
  // returns list of textures
  getTextures() {
    return this.textures;
  }
  // returns a set of info for each feature
  getFeatureInfo() {
    return this.featureIds;
  }
  // performs texture data read back asynchronously
  getFeaturesAsync(...e) {
    this._asyncRead = !0;
    const t = this.getFeatures(...e);
    return this._asyncRead = !1, t;
  }
  // returns all features for the given point on the given triangle
  getFeatures(e, t) {
    const { geometry: s, textures: n, featureIds: i } = this, r = new Array(i.length).fill(null), o = i.length;
    le.increaseSizeTo(o);
    const l = _n(s, e), c = l[Zi(t)];
    for (let p = 0, m = i.length; p < m; p++) {
      const d = i[p], f = "nullFeatureId" in d ? d.nullFeatureId : null;
      if ("texture" in d) {
        const y = n[d.texture.index];
        Sn(s, d.texture.texCoord, t, l, Cs), Mn(Cs, y.image.width, y.image.height, vs), As.set(p, 0), le.renderPixelToTarget(n[d.texture.index], vs, As);
      } else if ("attribute" in d) {
        const g = s.getAttribute(`_feature_id_${d.attribute}`).getX(c);
        g !== f && (r[p] = g);
      } else {
        const y = c;
        y !== f && (r[p] = y);
      }
    }
    const u = new Uint8Array(o * 4);
    if (this._asyncRead)
      return le.readDataAsync(u).then(() => (h(), r));
    return le.readData(u), h(), r;
    function h() {
      const p = new Uint32Array(1);
      for (let m = 0, d = i.length; m < d; m++) {
        const f = i[m], y = "nullFeatureId" in f ? f.nullFeatureId : null;
        if ("texture" in f) {
          const { channels: g } = f.texture, x = g.map((T) => u[4 * m + T]);
          new Uint8Array(p.buffer).set(x);
          const S = p[0];
          S !== y && (r[m] = S);
        }
      }
    }
  }
  // dispose all of the texture data used
  dispose() {
    this.textures.forEach((e) => {
      e && (e.dispose(), e.image instanceof ImageBitmap && e.image.close());
    });
  }
}
const Ke = "EXT_mesh_features";
function Ls(a, e, t) {
  a.traverse((s) => {
    var n;
    if (e.associations.has(s)) {
      const { meshes: i, primitives: r } = e.associations.get(s), o = (n = e.json.meshes[i]) == null ? void 0 : n.primitives[r];
      o && o.extensions && o.extensions[Ke] && t(s, o.extensions[Ke]);
    }
  });
}
class Ki {
  constructor(e) {
    this.parser = e, this.name = Ke;
  }
  async afterRoot({ scene: e, parser: t }) {
    var o;
    const s = t.json.extensionsUsed;
    if (!s || !s.includes(Ke))
      return;
    const n = ((o = t.json.textures) == null ? void 0 : o.length) || 0, i = new Array(n).fill(null);
    Ls(e, t, (l, { featureIds: c }) => {
      c.forEach((u) => {
        if (u.texture && i[u.texture.index] === null) {
          const h = u.texture.index;
          i[h] = t.loadTexture(h);
        }
      });
    });
    const r = await Promise.all(i);
    Ls(e, t, (l, c) => {
      l.userData.meshFeatures = new Ji(l.geometry, r, c);
    });
  }
}
class er {
  constructor() {
    this.name = "CESIUM_RTC";
  }
  afterRoot(e) {
    if (e.parser.json.extensions && e.parser.json.extensions.CESIUM_RTC) {
      const { center: t } = e.parser.json.extensions.CESIUM_RTC;
      t && (e.scene.position.x += t[0], e.scene.position.y += t[1], e.scene.position.z += t[2]);
    }
  }
}
class ao {
  constructor(e) {
    e = {
      metadata: !0,
      rtc: !0,
      plugins: [],
      dracoLoader: null,
      ktxLoader: null,
      meshoptDecoder: null,
      autoDispose: !0,
      ...e
    }, this.tiles = null, this.metadata = e.metadata, this.rtc = e.rtc, this.plugins = e.plugins, this.dracoLoader = e.dracoLoader, this.ktxLoader = e.ktxLoader, this.meshoptDecoder = e.meshoptDecoder, this._gltfRegex = /\.(gltf|glb)$/g, this._dracoRegex = /\.drc$/g, this._loader = null;
  }
  init(e) {
    const t = new ui(e.manager);
    this.dracoLoader && (t.setDRACOLoader(this.dracoLoader), e.manager.addHandler(this._dracoRegex, this.dracoLoader)), this.ktxLoader && t.setKTX2Loader(this.ktxLoader), this.meshoptDecoder && t.setMeshoptDecoder(this.meshoptDecoder), this.rtc && t.register(() => new er()), this.metadata && (t.register(() => new Qi()), t.register(() => new Ki())), this.plugins.forEach((s) => t.register(s)), e.manager.addHandler(this._gltfRegex, t), this.tiles = e, this._loader = t;
  }
  dispose() {
    this.tiles.manager.removeHandler(this._gltfRegex), this.tiles.manager.removeHandler(this._dracoRegex), this.autoDispose && (this.ktxLoader.dispose(), this.dracoLoader.dispose());
  }
}
const je = /* @__PURE__ */ new ce();
class lo {
  constructor(e) {
    e = {
      up: "+z",
      recenter: !0,
      lat: null,
      lon: null,
      height: 0,
      azimuth: 0,
      elevation: 0,
      roll: 0,
      ...e
    }, this.tiles = null, this.up = e.up.toLowerCase().replace(/\s+/, ""), this.lat = e.lat, this.lon = e.lon, this.height = e.height, this.azimuth = e.azimuth, this.elevation = e.elevation, this.roll = e.roll, this.recenter = e.recenter, this._callback = null;
  }
  init(e) {
    this.tiles = e, this._callback = () => {
      const { up: t, lat: s, lon: n, height: i, azimuth: r, elevation: o, roll: l, recenter: c } = this;
      if (s !== null && n !== null)
        this.transformLatLonHeightToOrigin(s, n, i, r, o, l);
      else {
        const { ellipsoid: u } = e, h = Math.min(...u.radius);
        if (e.getBoundingSphere(je), je.center.length() > h * 0.5) {
          const p = {};
          u.getPositionToCartographic(je.center, p), this.transformLatLonHeightToOrigin(p.lat, p.lon, p.height);
        } else {
          const p = e.group;
          switch (p.rotation.set(0, 0, 0), t) {
            case "x":
            case "+x":
              p.rotation.z = Math.PI / 2;
              break;
            case "-x":
              p.rotation.z = -Math.PI / 2;
              break;
            case "y":
            case "+y":
              break;
            case "-y":
              p.rotation.z = Math.PI;
              break;
            case "z":
            case "+z":
              p.rotation.x = -Math.PI / 2;
              break;
            case "-z":
              p.rotation.x = Math.PI / 2;
              break;
          }
          e.group.position.copy(je.center).applyEuler(p.rotation).multiplyScalar(-1);
        }
      }
      c || e.group.position.setScalar(0), e.removeEventListener("load-tile-set", this._callback);
    }, e.addEventListener("load-tile-set", this._callback), e.root && this._callback();
  }
  transformLatLonHeightToOrigin(e, t, s = 0, n = 0, i = 0, r = 0) {
    const { group: o, ellipsoid: l } = this.tiles;
    l.getObjectFrame(e, t, s, n, i, r, o.matrix, ri), o.matrix.invert().decompose(o.position, o.quaternion, o.scale), o.updateMatrixWorld();
  }
  dispose() {
    const { group: e } = this.tiles;
    e.position.setScalar(0), e.quaternion.identity(), e.scale.set(1, 1, 1), this.tiles.removeEventListener("load-tile-set", this._callback);
  }
}
class co {
  set delay(e) {
    this.deferCallbacks.delay = e;
  }
  get delay() {
    return this.deferCallbacks.delay;
  }
  set bytesTarget(e) {
    this.lruCache.minBytesSize = e;
  }
  get bytesTarget() {
    return this.lruCache.minBytesSize;
  }
  get estimatedGpuBytes() {
    return this.lruCache.cachedBytes;
  }
  constructor(e = {}) {
    const {
      delay: t = 0,
      bytesTarget: s = 0
    } = e;
    this.name = "UNLOAD_TILES_PLUGIN", this.tiles = null, this.lruCache = new hi(), this.deferCallbacks = new tr(), this.delay = t, this.bytesTarget = s;
  }
  init(e) {
    this.tiles = e;
    const { lruCache: t, deferCallbacks: s } = this;
    s.callback = (i) => {
      t.markUnused(i), t.scheduleUnload(!1);
    };
    const n = (i) => {
      const r = i.cached.scene;
      e.visibleTiles.has(i) || e.invokeOnePlugin((l) => l.unloadTileFromGPU && l.unloadTileFromGPU(r, i));
    };
    this._onUpdateBefore = () => {
      t.unloadPriorityCallback = e.lruCache.unloadPriorityCallback, t.computeMemoryUsageCallback = e.lruCache.computeMemoryUsageCallback, t.minSize = 1 / 0, t.maxSize = 1 / 0, t.maxBytesSize = 1 / 0, t.unloadPercent = 1, t.autoMarkUnused = !1;
    }, this._onVisibilityChangeCallback = ({ tile: i, visible: r }) => {
      r ? (t.add(i, n), e.markTileUsed(i), s.cancel(i)) : s.run(i);
    }, e.forEachLoadedModel((i, r) => {
      const o = e.visibleTiles.has(r);
      this._onVisibilityChangeCallback({ scene: i, visible: o });
    }), e.addEventListener("tile-visibility-change", this._onVisibilityChangeCallback), e.addEventListener("update-before", this._onUpdateBefore);
  }
  unloadTileFromGPU(e, t) {
    e && e.traverse((s) => {
      if (s.material) {
        const n = s.material;
        n.dispose();
        for (const i in n) {
          const r = n[i];
          r && r.isTexture && r.dispose();
        }
      }
      s.geometry && s.geometry.dispose();
    });
  }
  dispose() {
    this.tiles.removeEventListener("tile-visibility-change", this._onVisibilityChangeCallback), this.tiles.removeEventListener("update-before", this._onUpdateBefore), this.deferCallbacks.cancelAll();
  }
}
class tr {
  constructor(e = () => {
  }) {
    this.map = /* @__PURE__ */ new Map(), this.callback = e, this.delay = 0;
  }
  run(e) {
    const { map: t, delay: s } = this;
    if (t.has(e))
      throw new Error("DeferCallbackManager: Callback already initialized.");
    s === 0 ? this.callback(e) : t.set(e, setTimeout(() => this.callback(e), s));
  }
  cancel(e) {
    const { map: t } = this;
    t.has(e) && (clearTimeout(t.get(e)), t.delete(e));
  }
  cancelAll() {
    this.map.forEach((e, t) => {
      this.cancel(t);
    });
  }
}
const { clamp: gt } = _;
class sr {
  constructor() {
    this.duration = 250, this.fadeCount = 0, this._lastTick = -1, this._fadeState = /* @__PURE__ */ new Map(), this.onFadeComplete = null, this.onFadeStart = null, this.onFadeSetComplete = null, this.onFadeSetStart = null;
  }
  // delete the object from the fade, reset the material data
  deleteObject(e) {
    e && this.completeFade(e);
  }
  // Ensure we're storing a fade timer for the provided object
  // Returns whether a new state had to be added
  guaranteeState(e) {
    const t = this._fadeState;
    if (t.has(e))
      return !1;
    const s = {
      fadeInTarget: 0,
      fadeOutTarget: 0,
      fadeIn: 0,
      fadeOut: 0
    };
    return t.set(e, s), !0;
  }
  // Force the fade to complete in the direction it is already trending
  completeFade(e) {
    const t = this._fadeState;
    if (!t.has(e))
      return;
    const s = t.get(e).fadeOutTarget === 0;
    t.delete(e), this.fadeCount--, this.onFadeComplete && this.onFadeComplete(e, s), this.fadeCount === 0 && this.onFadeSetComplete && this.onFadeSetComplete();
  }
  completeAllFades() {
    this._fadeState.forEach((e, t) => {
      this.completeFade(t);
    });
  }
  forEachObject(e) {
    this._fadeState.forEach((t, s) => {
      e(s, t);
    });
  }
  // Fade the object in
  fadeIn(e) {
    const t = this.guaranteeState(e), s = this._fadeState.get(e);
    s.fadeInTarget = 1, s.fadeOutTarget = 0, s.fadeOut = 0, t && (this.fadeCount++, this.fadeCount === 1 && this.onFadeSetStart && this.onFadeSetStart(), this.onFadeStart && this.onFadeStart(e));
  }
  // Fade the object out
  fadeOut(e) {
    const t = this.guaranteeState(e), s = this._fadeState.get(e);
    s.fadeOutTarget = 1, t && (s.fadeInTarget = 1, s.fadeIn = 1, this.fadeCount++, this.fadeCount === 1 && this.onFadeSetStart && this.onFadeSetStart(), this.onFadeStart && this.onFadeStart(e));
  }
  isFading(e) {
    return this._fadeState.has(e);
  }
  isFadingOut(e) {
    const t = this._fadeState.get(e);
    return t && t.fadeOutTarget === 1;
  }
  // Tick the fade timer for each actively fading object
  update() {
    const e = window.performance.now();
    this._lastTick === -1 && (this._lastTick = e);
    const t = gt((e - this._lastTick) / this.duration, 0, 1);
    this._lastTick = e, this._fadeState.forEach((n, i) => {
      const {
        fadeOutTarget: r,
        fadeInTarget: o
      } = n;
      let {
        fadeOut: l,
        fadeIn: c
      } = n;
      const u = Math.sign(o - c);
      c = gt(c + u * t, 0, 1);
      const h = Math.sign(r - l);
      l = gt(l + h * t, 0, 1), n.fadeIn = c, n.fadeOut = l, ((l === 1 || l === 0) && (c === 1 || c === 0) || l >= c) && this.completeFade(i);
    });
  }
}
const yt = Symbol("FADE_PARAMS");
function Cn(a, e) {
  if (a[yt])
    return a[yt];
  const t = {
    fadeIn: { value: 0 },
    fadeOut: { value: 0 },
    fadeTexture: { value: null }
  };
  return a[yt] = t, a.defines = {
    ...a.defines || {},
    FEATURE_FADE: 0
  }, a.onBeforeCompile = (s) => {
    e && e(s), s.uniforms = {
      ...s.uniforms,
      ...t
    }, s.vertexShader = s.vertexShader.replace(
      /void\s+main\(\)\s+{/,
      (n) => (
        /* glsl */
        `
					#ifdef USE_BATCHING_FRAG

					varying float vBatchId;

					#endif

					${n}

						#ifdef USE_BATCHING_FRAG

						// add 0.5 to the value to avoid floating error that may cause flickering
						vBatchId = getIndirectIndex( gl_DrawID ) + 0.5;

						#endif
				`
      )
    ), s.fragmentShader = s.fragmentShader.replace(/void main\(/, (n) => (
      /* glsl */
      `
				#if FEATURE_FADE

				// adapted from https://www.shadertoy.com/view/Mlt3z8
				float bayerDither2x2( vec2 v ) {

					return mod( 3.0 * v.y + 2.0 * v.x, 4.0 );

				}

				float bayerDither4x4( vec2 v ) {

					vec2 P1 = mod( v, 2.0 );
					vec2 P2 = floor( 0.5 * mod( v, 4.0 ) );
					return 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );

				}

				// the USE_BATCHING define is not available in fragment shaders
				#ifdef USE_BATCHING_FRAG

				// functions for reading the fade state of a given batch id
				uniform sampler2D fadeTexture;
				varying float vBatchId;
				vec2 getFadeValues( const in float i ) {

					int size = textureSize( fadeTexture, 0 ).x;
					int j = int( i );
					int x = j % size;
					int y = j / size;
					return texelFetch( fadeTexture, ivec2( x, y ), 0 ).rg;

				}

				#else

				uniform float fadeIn;
				uniform float fadeOut;

				#endif

				#endif

				${n}
			`
    )).replace(/#include <dithering_fragment>/, (n) => (
      /* glsl */
      `

				${n}

				#if FEATURE_FADE

				#ifdef USE_BATCHING_FRAG

				vec2 fadeValues = getFadeValues( vBatchId );
				float fadeIn = fadeValues.r;
				float fadeOut = fadeValues.g;

				#endif

				float bayerValue = bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) );
				float bayerBins = 16.0;
				float dither = ( 0.5 + bayerValue ) / bayerBins;
				if ( dither >= fadeIn ) {

					discard;

				}

				if ( dither < fadeOut ) {

					discard;

				}

				#endif

			`
    ));
  }, t;
}
class nr {
  constructor() {
    this._fadeParams = /* @__PURE__ */ new WeakMap(), this.fading = 0;
  }
  // Set the fade parameters for the given scene
  setFade(e, t, s) {
    if (!e)
      return;
    const n = this._fadeParams;
    e.traverse((i) => {
      const r = i.material;
      if (r && n.has(r)) {
        const o = n.get(r);
        o.fadeIn.value = t, o.fadeOut.value = s;
        const u = +(!(t === 0 || t === 1) || !(s === 0 || s === 1));
        r.defines.FEATURE_FADE !== u && (this.fading += u === 1 ? 1 : -1, r.defines.FEATURE_FADE = u, r.needsUpdate = !0);
      }
    });
  }
  // initialize materials in the object
  prepareScene(e) {
    e.traverse((t) => {
      t.material && this.prepareMaterial(t.material);
    });
  }
  // delete the object from the fade, reset the material data
  deleteScene(e) {
    if (!e)
      return;
    this.setFade(e, 1, 0);
    const t = this._fadeParams;
    e.traverse((s) => {
      const n = s.material;
      n && t.delete(n);
    });
  }
  // initialize the material
  prepareMaterial(e) {
    const t = this._fadeParams;
    t.has(e) || t.set(e, Cn(e, e.onBeforeCompile));
  }
}
class ir {
  constructor(e, t = new De()) {
    this.other = e, this.material = t, this.visible = !0, this.parent = null, this._instanceInfo = [], this._visibilityChanged = !0;
    const s = new Proxy(this, {
      get(n, i) {
        if (i in n)
          return n[i];
        {
          const r = e[i];
          return r instanceof Function ? (...o) => (n.syncInstances(), r.call(s, ...o)) : e[i];
        }
      },
      set(n, i, r) {
        return i in n ? n[i] = r : e[i] = r, !0;
      },
      deleteProperty(n, i) {
        return i in n ? delete n[i] : delete e[i];
      }
      // ownKeys() {},
      // has(target, key) {},
      // defineProperty(target, key, descriptor) {},
      // getOwnPropertyDescriptor(target, key) {},
    });
    return s;
  }
  syncInstances() {
    const e = this._instanceInfo, t = this.other._instanceInfo;
    for (; t.length > e.length; ) {
      const s = e.length;
      e.push(new Proxy({ visible: !1 }, {
        get(n, i) {
          return i in n ? n[i] : t[s][i];
        },
        set(n, i, r) {
          return i in n ? n[i] = r : t[s][i] = r, !0;
        }
      }));
    }
  }
}
class rr extends ir {
  constructor(...e) {
    super(...e);
    const t = this.material, s = Cn(t, t.onBeforeCompile);
    t.defines.FEATURE_FADE = 1, t.defines.USE_BATCHING_FRAG = 1, t.needsUpdate = !0, this.fadeTexture = null, this._fadeParams = s;
  }
  // Set the fade state
  setFadeAt(e, t, s) {
    this._initFadeTexture(), this.fadeTexture.setValueAt(e, t * 255, s * 255);
  }
  // initialize the texture and resize it if needed
  _initFadeTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = e * e * 2, s = this.fadeTexture;
    if (!s || s.image.data.length !== t) {
      const n = new Uint8Array(t), i = new or(n, e, e, en, tn);
      if (s) {
        s.dispose();
        const r = s.image.data, o = this.fadeTexture.image.data, l = Math.min(r.length, o.length);
        o.set(new r.constructor(r.buffer, 0, l));
      }
      this.fadeTexture = i, this._fadeParams.fadeTexture.value = i, i.needsUpdate = !0;
    }
  }
  // dispose the fade texture. Super cannot be used here due to proxy
  dispose() {
    this.fadeTexture && this.fadeTexture.dispose();
  }
}
class or extends zt {
  setValueAt(e, ...t) {
    const { data: s, width: n, height: i } = this.image, r = Math.floor(s.length / (n * i));
    let o = !1;
    for (let l = 0; l < r; l++) {
      const c = e * r + l, u = s[c], h = t[l] || 0;
      u !== h && (s[c] = h, o = !0);
    }
    o && (this.needsUpdate = !0);
  }
}
const Es = Symbol("HAS_POPPED_IN"), ws = new E(), Is = new E(), Ps = new rn(), Rs = new rn(), Bs = new E();
function ar() {
  const a = this._fadeManager, e = this.tiles;
  this._fadingBefore = a.fadeCount, this._displayActiveTiles = e.displayActiveTiles, e.displayActiveTiles = !0;
}
function lr() {
  const a = this._fadeManager, e = this._fadeMaterialManager, t = this._displayActiveTiles, s = this._fadingBefore, n = this._prevCameraTransforms, { tiles: i, maximumFadeOutTiles: r, batchedMesh: o } = this, { cameras: l } = i;
  i.displayActiveTiles = t, a.update();
  const c = a.fadeCount;
  if (s !== 0 && c !== 0 && (i.dispatchEvent({ type: "fade-change" }), i.dispatchEvent({ type: "needs-render" })), t || i.visibleTiles.forEach((u) => {
    const h = u.cached.scene;
    h && (h.visible = u.__inFrustum), this.forEachBatchIds(u, (p, m, d) => {
      m.setVisibleAt(p, u.__inFrustum), d.batchedMesh.setVisibleAt(p, u.__inFrustum);
    });
  }), r < this._fadingOutCount) {
    let u = !0;
    l.forEach((h) => {
      if (!n.has(h))
        return;
      const p = h.matrixWorld, m = n.get(h);
      p.decompose(Is, Rs, Bs), m.decompose(ws, Ps, Bs);
      const d = Rs.angleTo(Ps), f = Is.distanceTo(ws);
      u = u && (d > 0.25 || f > 0.1);
    }), u && a.completeAllFades();
  }
  if (l.forEach((u) => {
    n.get(u).copy(u.matrixWorld);
  }), a.forEachObject((u, { fadeIn: h, fadeOut: p }) => {
    const m = u.cached.scene, d = a.isFadingOut(u);
    i.markTileUsed(u), m && (e.setFade(m, h, p), d && (m.visible = !0)), this.forEachBatchIds(u, (f, y, g) => {
      y.setFadeAt(f, h, p), y.setVisibleAt(f, !0), g.batchedMesh.setVisibleAt(f, !1);
    });
  }), o) {
    const u = i.getPluginByName("BATCHED_TILES_PLUGIN").batchedMesh.material;
    o.material.map = u.map;
  }
}
class uo {
  get fadeDuration() {
    return this._fadeManager.duration;
  }
  set fadeDuration(e) {
    this._fadeManager.duration = Number(e);
  }
  get fadingTiles() {
    return this._fadeManager.fadeCount;
  }
  constructor(e) {
    e = {
      maximumFadeOutTiles: 50,
      fadeRootTiles: !1,
      fadeDuration: 250,
      ...e
    }, this.name = "FADE_TILES_PLUGIN", this.priority = -2, this.tiles = null, this.batchedMesh = null, this._quickFadeTiles = /* @__PURE__ */ new Set(), this._fadeManager = new sr(), this._fadeMaterialManager = new nr(), this._prevCameraTransforms = null, this._fadingOutCount = 0, this.maximumFadeOutTiles = e.maximumFadeOutTiles, this.fadeRootTiles = e.fadeRootTiles, this.fadeDuration = e.fadeDuration;
  }
  init(e) {
    this._onLoadModel = ({ scene: n }) => {
      this._fadeMaterialManager.prepareScene(n);
    }, this._onDisposeModel = ({ tile: n, scene: i }) => {
      this.tiles.visibleTiles.has(n) && this._quickFadeTiles.add(n.parent), this._fadeManager.deleteObject(n), this._fadeMaterialManager.deleteScene(i);
    }, this._onAddCamera = ({ camera: n }) => {
      this._prevCameraTransforms.set(n, new Q());
    }, this._onDeleteCamera = ({ camera: n }) => {
      this._prevCameraTransforms.delete(n);
    }, this._onTileVisibilityChange = ({ tile: n, visible: i }) => {
      const r = n.cached.scene;
      r && (r.visible = !0), this.forEachBatchIds(n, (o, l, c) => {
        l.setFadeAt(o, 0, 0), l.setVisibleAt(o, !1), c.batchedMesh.setVisibleAt(o, !1);
      });
    }, this._onUpdateBefore = () => {
      ar.call(this);
    }, this._onUpdateAfter = () => {
      lr.call(this);
    }, e.addEventListener("load-model", this._onLoadModel), e.addEventListener("dispose-model", this._onDisposeModel), e.addEventListener("add-camera", this._onAddCamera), e.addEventListener("delete-camera", this._onDeleteCamera), e.addEventListener("update-before", this._onUpdateBefore), e.addEventListener("update-after", this._onUpdateAfter), e.addEventListener("tile-visibility-change", this._onTileVisibilityChange);
    const t = this._fadeManager;
    t.onFadeSetStart = () => {
      e.dispatchEvent({ type: "fade-start" }), e.dispatchEvent({ type: "needs-render" });
    }, t.onFadeSetComplete = () => {
      e.dispatchEvent({ type: "fade-end" }), e.dispatchEvent({ type: "needs-render" });
    }, t.onFadeComplete = (n, i) => {
      this._fadeMaterialManager.setFade(n.cached.scene, 0, 0), this.forEachBatchIds(n, (r, o, l) => {
        o.setFadeAt(r, 0, 0), o.setVisibleAt(r, !1), l.batchedMesh.setVisibleAt(r, i);
      }), i || (e.invokeOnePlugin((r) => r !== this && r.setTileVisible && r.setTileVisible(n, !1)), this._fadingOutCount--);
    };
    const s = /* @__PURE__ */ new Map();
    e.cameras.forEach((n) => {
      s.set(n, new Q());
    }), e.forEachLoadedModel((n, i) => {
      this._onLoadModel({ scene: n });
    }), this.tiles = e, this._fadeManager = t, this._prevCameraTransforms = s;
  }
  // initializes the batched mesh if it needs to be, dispose if it it's no longer needed
  initBatchedMesh() {
    var t;
    const e = (t = this.tiles.getPluginByName("BATCHED_TILES_PLUGIN")) == null ? void 0 : t.batchedMesh;
    if (e) {
      if (this.batchedMesh === null) {
        this._onBatchedMeshDispose = () => {
          this.batchedMesh.dispose(), this.batchedMesh.removeFromParent(), this.batchedMesh = null, e.removeEventListener("dispose", this._onBatchedMeshDispose);
        };
        const s = e.material.clone();
        s.onBeforeCompile = e.material.onBeforeCompile, this.batchedMesh = new rr(e, s), this.tiles.group.add(this.batchedMesh);
      }
    } else
      this.batchedMesh !== null && (this._onBatchedMeshDispose(), this._onBatchedMeshDispose = null);
  }
  // callback for fading to prevent tiles from being removed until the fade effect has completed
  setTileVisible(e, t) {
    const s = this._fadeManager, n = s.isFading(e);
    if (s.isFadingOut(e) && this._fadingOutCount--, t ? e.__depthFromRenderedParent === 1 ? ((e[Es] || this.fadeRootTiles) && this._fadeManager.fadeIn(e), e[Es] = !0) : this._fadeManager.fadeIn(e) : (this._fadingOutCount++, s.fadeOut(e)), this._quickFadeTiles.has(e) && (this._fadeManager.completeFade(e), this._quickFadeTiles.delete(e)), n)
      return !0;
    const i = this._fadeManager.isFading(e);
    return !!(!t && i);
  }
  dispose() {
    const e = this.tiles;
    this._fadeManager.completeAllFades(), this.batchedMesh !== null && this._onBatchedMeshDispose(), e.removeEventListener("load-model", this._onLoadModel), e.removeEventListener("dispose-model", this._onDisposeModel), e.removeEventListener("add-camera", this._onAddCamera), e.removeEventListener("delete-camera", this._onDeleteCamera), e.removeEventListener("update-before", this._onUpdateBefore), e.removeEventListener("update-after", this._onUpdateAfter), e.removeEventListener("tile-visibility-change", this._onTileVisibilityChange), e.forEachLoadedModel((t, s) => {
      this._fadeManager.deleteObject(s), t && (t.visible = !0);
    });
  }
  // helper for iterating over the batch ids for a given tile
  forEachBatchIds(e, t) {
    if (this.initBatchedMesh(), this.batchedMesh) {
      const s = this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"), n = s.getTileBatchIds(e);
      n && n.forEach((i) => {
        t(i, this.batchedMesh, s);
      });
    }
  }
}
const xt = new Q(), Ds = new E(), Us = new E();
class cr extends Yn {
  constructor(...e) {
    super(...e), this.resetDistance = 1e4, this._matricesTextureHandle = null, this._lastCameraPos = new Q(), this._forceUpdate = !0, this._matrices = [];
  }
  setMatrixAt(e, t) {
    super.setMatrixAt(e, t), this._forceUpdate = !0;
    const s = this._matrices;
    for (; s.length <= e; )
      s.push(new Q());
    s[e].copy(t);
  }
  setInstanceCount(...e) {
    super.setInstanceCount(...e);
    const t = this._matrices;
    for (; t.length > this.instanceCount; )
      t.pop();
  }
  onBeforeRender(e, t, s, n, i, r) {
    super.onBeforeRender(e, t, s, n, i, r), Ds.setFromMatrixPosition(s.matrixWorld), Us.setFromMatrixPosition(this._lastCameraPos);
    const o = this._matricesTexture;
    let l = this._modelViewMatricesTexture;
    if ((!l || l.image.width !== o.image.width || l.image.height !== o.image.height) && (l && l.dispose(), l = o.clone(), l.source = new $n({
      ...l.image,
      data: l.image.data.slice()
    }), this._modelViewMatricesTexture = l), this._forceUpdate || Ds.distanceTo(Us) > this.resetDistance) {
      const c = this._matrices, u = l.image.data;
      for (let h = 0; h < this.maxInstanceCount; h++) {
        const p = c[h];
        p ? xt.copy(p) : xt.identity(), xt.premultiply(this.matrixWorld).premultiply(s.matrixWorldInverse).toArray(u, h * 16);
      }
      l.needsUpdate = !0, this._lastCameraPos.copy(s.matrixWorld), this._forceUpdate = !1;
    }
    this._matricesTextureHandle = this._matricesTexture, this._matricesTexture = this._modelViewMatricesTexture, this.matrixWorld.copy(this._lastCameraPos);
  }
  onAfterRender() {
    this.updateMatrixWorld(), this._matricesTexture = this._matricesTextureHandle, this._matricesTextureHandle = null;
  }
  onAfterShadow(e, t, s, n, i, r) {
    this.onAfterRender(e, null, n, i, r);
  }
  dispose() {
    super.dispose(), this._modelViewMatricesTexture && this._modelViewMatricesTexture.dispose();
  }
}
const Z = new Be(), ze = [];
class ur extends cr {
  constructor(...e) {
    super(...e), this.expandPercent = 0.25, this.maxInstanceExpansionSize = 1 / 0, this._freeGeometryIds = [];
  }
  // Finds a free id that can fit the geometry with the requested ranges. Returns -1 if it could not be found.
  findFreeId(e, t, s) {
    const n = !!this.geometry.index, i = Math.max(n ? e.index.count : -1, s), r = Math.max(e.attributes.position.count, t);
    let o = -1, l = 1 / 0;
    const c = this._freeGeometryIds;
    if (c.forEach((u, h) => {
      const p = this.getGeometryRangeAt(u), { reservedIndexCount: m, reservedVertexCount: d } = p;
      if (m >= i && d >= r) {
        const f = i - m + (r - d);
        f < l && (o = h, l = f);
      }
    }), o !== -1) {
      const u = c[o];
      return c.splice(o, 1), u;
    } else
      return -1;
  }
  // Overrides addGeometry to find an option geometry slot, expand, or optimized if needed
  addGeometry(e, t, s) {
    const n = !!this.geometry.index;
    s = Math.max(n ? e.index.count : -1, s), t = Math.max(e.attributes.position.count, t);
    const { expandPercent: i, _freeGeometryIds: r } = this;
    let o = this.findFreeId(e, t, s);
    if (o !== -1)
      this.setGeometryAt(o, e);
    else {
      const l = () => {
        const h = this.unusedVertexCount < t, p = this.unusedIndexCount < s;
        return h || p;
      }, c = e.index, u = e.attributes.position;
      if (t = Math.max(t, u.count), s = Math.max(s, c ? c.count : 0), l() && (r.forEach((h) => this.deleteGeometry(h)), r.length = 0, this.optimize(), l())) {
        const h = this.geometry.index, p = this.geometry.attributes.position;
        let m, d;
        if (h) {
          const f = Math.ceil(i * h.count);
          m = Math.max(f, s, c.count) + h.count;
        } else
          m = Math.max(this.unusedIndexCount, s);
        if (p) {
          const f = Math.ceil(i * p.count);
          d = Math.max(f, t, u.count) + p.count;
        } else
          d = Math.max(this.unusedVertexCount, t);
        this.setGeometrySize(d, m);
      }
      o = super.addGeometry(e, t, s);
    }
    return o;
  }
  // add an instance and automatically expand the number of instances if necessary
  addInstance(e) {
    if (this.maxInstanceCount === this.instanceCount) {
      const t = Math.ceil(this.maxInstanceCount * (1 + this.expandPercent));
      this.setInstanceCount(Math.min(t, this.maxInstanceExpansionSize));
    }
    return super.addInstance(e);
  }
  // delete an instance, keeping note that the geometry id is now unused
  deleteInstance(e) {
    const t = this.getGeometryIdAt(e);
    return t !== -1 && this._freeGeometryIds.push(t), super.deleteInstance(e);
  }
  // add a function for raycasting per tile
  raycastInstance(e, t, s) {
    const n = this.geometry, i = this.getGeometryIdAt(e);
    Z.material = this.material, Z.geometry.index = n.index, Z.geometry.attributes = n.attributes;
    const r = this.getGeometryRangeAt(i);
    Z.geometry.setDrawRange(r.start, r.count), Z.geometry.boundingBox === null && (Z.geometry.boundingBox = new it()), Z.geometry.boundingSphere === null && (Z.geometry.boundingSphere = new ce()), this.getMatrixAt(e, Z.matrixWorld).premultiply(this.matrixWorld), this.getBoundingBoxAt(i, Z.geometry.boundingBox), this.getBoundingSphereAt(i, Z.geometry.boundingSphere), Z.raycast(t, ze);
    for (let o = 0, l = ze.length; o < l; o++) {
      const c = ze[o];
      c.object = this, c.batchId = e, s.push(c);
    }
    ze.length = 0;
  }
}
function hr(a) {
  return a.r === 1 && a.g === 1 && a.b === 1;
}
function dr(a) {
  a.needsUpdate = !0, a.onBeforeCompile = (e) => {
    e.vertexShader = e.vertexShader.replace(
      "#include <common>",
      /* glsl */
      `
				#include <common>
				varying float texture_index;
				`
    ).replace(
      "#include <uv_vertex>",
      /* glsl */
      `
				#include <uv_vertex>
				texture_index = getIndirectIndex( gl_DrawID );
				`
    ), e.fragmentShader = e.fragmentShader.replace(
      "#include <map_pars_fragment>",
      /* glsl */
      `
				#ifdef USE_MAP
				precision highp sampler2DArray;
				uniform sampler2DArray map;
				varying float texture_index;
				#endif
				`
    ).replace(
      "#include <map_fragment>",
      /* glsl */
      `
				#ifdef USE_MAP
					diffuseColor *= texture( map, vec3( vMapUv, texture_index ) );
				#endif
				`
    );
  };
}
const Tt = new un(new De()), Ot = new zt(new Uint8Array([255, 255, 255, 255]), 1, 1);
Ot.needsUpdate = !0;
class ho {
  constructor(e = {}) {
    if (parseInt(Qn) < 170)
      throw new Error("BatchedTilesPlugin: Three.js revision 170 or higher required.");
    e = {
      instanceCount: 500,
      vertexCount: 750,
      indexCount: 2e3,
      expandPercent: 0.25,
      maxInstanceCount: 1 / 0,
      discardOriginalContent: !0,
      textureSize: null,
      material: null,
      renderer: null,
      ...e
    }, this.name = "BATCHED_TILES_PLUGIN", this.priority = -1;
    const t = e.renderer.getContext();
    this.instanceCount = e.instanceCount, this.vertexCount = e.vertexCount, this.indexCount = e.indexCount, this.material = e.material ? e.material.clone() : null, this.expandPercent = e.expandPercent, this.maxInstanceCount = Math.min(e.maxInstanceCount, t.getParameter(t.MAX_3D_TEXTURE_SIZE)), this.renderer = e.renderer, this.discardOriginalContent = e.discardOriginalContent, this.textureSize = e.textureSize, this.batchedMesh = null, this.arrayTarget = null, this.tiles = null, this._onLoadModel = null, this._onDisposeModel = null, this._onVisibilityChange = null, this._tileToInstanceId = /* @__PURE__ */ new Map();
  }
  init(e) {
    this._onDisposeModel = ({ scene: t, tile: s }) => {
      this.removeSceneFromBatchedMesh(t, s);
    }, e.addEventListener("dispose-model", this._onDisposeModel), this.tiles = e;
  }
  initTextureArray(e) {
    if (this.arrayTarget !== null || e.material.map === null)
      return;
    const { instanceCount: t, renderer: s, textureSize: n, batchedMesh: i } = this, r = e.material.map, o = {
      colorSpace: r.colorSpace,
      wrapS: r.wrapS,
      wrapT: r.wrapT,
      wrapR: r.wrapS,
      // TODO: Generating mipmaps for the volume every time a new texture is added is extremely slow
      // generateMipmaps: map.generateMipmaps,
      // minFilter: map.minFilter,
      magFilter: r.magFilter
    }, l = new es(n || r.image.width, n || r.image.height, t);
    Object.assign(l.texture, o), s.initRenderTarget(l), i.material.map = l.texture, this.arrayTarget = l, this._tileToInstanceId.forEach((c) => {
      c.forEach((u) => {
        this.assignTextureToLayer(Ot, u);
      });
    });
  }
  // init the batched mesh if it's not ready
  initBatchedMesh(e) {
    if (this.batchedMesh !== null)
      return;
    const { instanceCount: t, vertexCount: s, indexCount: n, tiles: i } = this, r = this.material ? this.material : new e.material.constructor(), o = new ur(t, t * s, t * n, r);
    o.name = "BatchTilesPlugin", o.frustumCulled = !1, i.group.add(o), o.updateMatrixWorld(), dr(o.material), this.batchedMesh = o;
  }
  setTileVisible(e, t) {
    const s = e.cached.scene;
    if (t && this.addSceneToBatchedMesh(s, e), this._tileToInstanceId.has(e)) {
      this._tileToInstanceId.get(e).forEach((r) => {
        this.batchedMesh.setVisibleAt(r, t);
      });
      const i = this.tiles;
      return t ? i.visibleTiles.add(e) : i.visibleTiles.delete(e), i.dispatchEvent({
        type: "tile-visibility-change",
        scene: s,
        tile: e,
        visible: t
      }), !0;
    }
    return !1;
  }
  unloadTileFromGPU(e, t) {
    return !this.discardOriginalContent && this._tileToInstanceId.has(t) ? (this.removeSceneFromBatchedMesh(e, t), !0) : !1;
  }
  // render the given into the given layer
  assignTextureToLayer(e, t) {
    if (!this.arrayTarget)
      return;
    this.expandArrayTargetIfNeeded();
    const { renderer: s } = this, n = s.getRenderTarget();
    s.setRenderTarget(this.arrayTarget, t), Tt.material.map = e, Tt.render(s), s.setRenderTarget(n), Tt.material.map = null, e.dispose();
  }
  // check if the array texture target needs to be expanded
  expandArrayTargetIfNeeded() {
    const { batchedMesh: e, arrayTarget: t, renderer: s } = this, n = Math.min(e.maxInstanceCount, this.maxInstanceCount);
    if (n > t.depth) {
      const i = {
        colorSpace: t.texture.colorSpace,
        wrapS: t.texture.wrapS,
        wrapT: t.texture.wrapT,
        generateMipmaps: t.texture.generateMipmaps,
        minFilter: t.texture.minFilter,
        magFilter: t.texture.magFilter
      }, r = new es(t.width, t.height, n);
      Object.assign(r.texture, i), s.initRenderTarget(r), s.copyTextureToTexture(t.texture, r.texture), t.dispose(), e.material.map = r.texture, this.arrayTarget = r;
    }
  }
  removeSceneFromBatchedMesh(e, t) {
    if (this._tileToInstanceId.has(t)) {
      const s = this._tileToInstanceId.get(t);
      this._tileToInstanceId.delete(t), s.forEach((n) => {
        this.batchedMesh.deleteInstance(n);
      });
    }
  }
  addSceneToBatchedMesh(e, t) {
    if (this._tileToInstanceId.has(t))
      return;
    const s = [];
    e.traverse((r) => {
      r.isMesh && s.push(r);
    });
    let n = !0;
    s.forEach((r) => {
      if (this.batchedMesh && n) {
        const o = r.geometry.attributes, l = this.batchedMesh.geometry.attributes;
        for (const c in l)
          if (!(c in o)) {
            n = !1;
            return;
          }
      }
    });
    const i = !this.batchedMesh || this.batchedMesh.instanceCount + s.length <= this.maxInstanceCount;
    if (n && i) {
      e.updateMatrixWorld();
      const r = [];
      this._tileToInstanceId.set(t, r), s.forEach((o) => {
        this.initBatchedMesh(o), this.initTextureArray(o);
        const { geometry: l, material: c } = o, { batchedMesh: u, expandPercent: h } = this;
        u.expandPercent = h;
        const p = u.addGeometry(l, this.vertexCount, this.indexCount), m = u.addInstance(p);
        r.push(m), u.setMatrixAt(m, o.matrixWorld), u.setVisibleAt(m, !1), hr(c.color) || (c.color.setHSL(Math.random(), 0.5, 0.5), u.setColorAt(m, c.color));
        const d = c.map;
        d ? this.assignTextureToLayer(d, m) : this.assignTextureToLayer(Ot, m);
      }), this.discardOriginalContent && (t.cached.textures.forEach((o) => {
        o.image instanceof ImageBitmap && o.image.close();
      }), t.cached.scene = null, t.cached.materials = [], t.cached.geometries = [], t.cached.textures = []);
    }
  }
  // Override raycasting per tile to defer to the batched mesh
  raycastTile(e, t, s, n) {
    return this._tileToInstanceId.has(e) ? (this._tileToInstanceId.get(e).forEach((r) => {
      this.batchedMesh.raycastInstance(r, s, n);
    }), !0) : !1;
  }
  dispose() {
    const { arrayTarget: e, tiles: t, batchedMesh: s } = this;
    e && e.dispose(), s && (s.material.dispose(), s.geometry.dispose(), s.dispose(), s.removeFromParent()), t.removeEventListener("dispose-model", this._onDisposeModel);
  }
  getTileBatchIds(e) {
    return this._tileToInstanceId.get(e);
  }
}
const bt = /* @__PURE__ */ new ce(), He = /* @__PURE__ */ new E(), Le = /* @__PURE__ */ new Q(), Os = /* @__PURE__ */ new Q(), _t = /* @__PURE__ */ new Zn(), pr = /* @__PURE__ */ new De({ side: on }), Vs = /* @__PURE__ */ new it(), St = 1e5;
function Fs(a, e) {
  return a.isBufferGeometry ? (a.boundingSphere === null && a.computeBoundingSphere(), e.copy(a.boundingSphere)) : (Vs.setFromObject(a), Vs.getBoundingSphere(e), e);
}
class po {
  constructor() {
    this.name = "TILE_FLATTENING_PLUGIN", this.priority = -100, this.tiles = null, this.shapes = /* @__PURE__ */ new Map(), this.positionsMap = /* @__PURE__ */ new Map(), this.positionsUpdated = /* @__PURE__ */ new Set(), this.needsUpdate = !1;
  }
  init(e) {
    this.tiles = e, this.needsUpdate = !0, this._updateBeforeCallback = () => {
      this.needsUpdate && (this._updateTiles(), this.needsUpdate = !1);
    }, this._disposeModelCallback = ({ tile: t }) => {
      this.positionsMap.delete(t), this.positionsUpdated.delete(t);
    }, e.addEventListener("update-before", this._updateBeforeCallback), e.addEventListener("dispose-model", this._disposeModelCallback);
  }
  // update tile flattening state if it has not been made visible, yet
  setTileActive(e, t) {
    t && !this.positionsUpdated.has(e) && this._updateTile(e);
  }
  _updateTile(e) {
    const { positionsUpdated: t, positionsMap: s, shapes: n, tiles: i } = this;
    t.add(e);
    const r = e.cached.scene;
    if (s.has(e)) {
      const o = s.get(e);
      r.traverse((l) => {
        if (l.geometry) {
          const c = o.get(l.geometry);
          c && (l.geometry.attributes.position.array.set(c), l.geometry.attributes.position.needsUpdate = !0);
        }
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      s.set(e, o), r.traverse((l) => {
        l.geometry && o.set(l.geometry, l.geometry.attributes.position.array.slice());
      });
    }
    r.updateMatrixWorld(!0), r.traverse((o) => {
      const { geometry: l } = o;
      l && (Le.copy(o.matrixWorld), r.parent !== null && Le.premultiply(i.group.matrixWorldInverse), Os.copy(Le).invert(), Fs(l, bt).applyMatrix4(Le), n.forEach(({
        shape: c,
        direction: u,
        sphere: h,
        thresholdMode: p,
        threshold: m,
        flattenRange: d
      }) => {
        He.subVectors(bt.center, h.center), He.addScaledVector(u, -u.dot(He));
        const f = (bt.radius + h.radius) ** 2;
        if (He.lengthSq() > f)
          return;
        const { position: y } = l.attributes, { ray: g } = _t;
        g.direction.copy(u).multiplyScalar(-1);
        for (let x = 0, S = y.count; x < S; x++) {
          g.origin.fromBufferAttribute(y, x).applyMatrix4(Le).addScaledVector(u, St), _t.far = St;
          const T = _t.intersectObject(c)[0];
          if (T) {
            let b = (St - T.distance) / m;
            const M = b >= 1;
            (!M || M && p === "flatten") && (b = Math.min(b, 1), T.point.addScaledVector(g.direction, _.mapLinear(b, 0, 1, -d, 0)), T.point.applyMatrix4(Os), y.setXYZ(x, ...T.point));
          }
        }
      }));
    }), this.tiles.dispatchEvent({ type: "needs-render" });
  }
  _updateTiles() {
    this.positionsUpdated.clear(), this.tiles.activeTiles.forEach((e) => this._updateTile(e));
  }
  // API for updating and shapes to flatten the vertices
  hasShape(e) {
    return this.shapes.has(e);
  }
  addShape(e, t = new E(0, 0, -1), s = {}) {
    if (this.hasShape(e))
      throw new Error("TileFlatteningPlugin: Shape is already used.");
    typeof s == "number" && (console.warn('TileFlatteningPlugin: "addShape" function signature has changed. Please use an options object, instead.'), s = {
      threshold: s
    }), this.needsUpdate = !0;
    const n = e.clone();
    n.updateMatrixWorld(!0), n.traverse((r) => {
      r.material && (r.material = pr);
    });
    const i = Fs(n, new ce());
    this.shapes.set(e, {
      shape: n,
      direction: t.clone(),
      sphere: i,
      // "flatten": Flattens the vertices above the shape
      // "none": leaves the vertices above the shape as they are
      thresholdMode: "none",
      // only flatten within this range above the object
      threshold: 1 / 0,
      // the range to flatten vertices in to. 0 is completely flat
      // while 0.1 means a 10cm range.
      flattenRange: 0,
      ...s
    });
  }
  updateShape(e) {
    if (!this.hasShape(e))
      throw new Error("TileFlatteningPlugin: Shape is not present.");
    const { direction: t, threshold: s, thresholdMode: n, flattenRange: i } = this.shapes.get(e);
    this.deleteShape(e), this.addShape(e, t, {
      threshold: s,
      thresholdMode: n,
      flattenRange: i
    });
  }
  deleteShape(e) {
    return this.needsUpdate = !0, this.shapes.delete(e);
  }
  clearShapes() {
    this.shapes.size !== 0 && (this.needsUpdate = !0, this.shapes.clear());
  }
  // reset the vertex positions and remove the update callback
  dispose() {
    this.tiles.removeEventListener("before-update", this._updateBeforeCallback), this.tiles.removeEventListener("dispose-model", this._disposeModelCallback), this.positionsMap.forEach((e) => {
      e.forEach((t, s) => {
        const { position: n } = s.attributes;
        n.array.set(t), n.needsUpdate = !0;
      });
    });
  }
}
const fr = /* @__PURE__ */ new Jn(), mr = /* @__PURE__ */ new qt();
class gr {
  constructor(e) {
    this.renderer = e, this.renderTarget = null, this.range = [0, 0, 1, 1], this.quad = new Be(new Gt(), new yr());
  }
  // set the target render texture and the range that represents the full span
  setRenderTarget(e, t) {
    this.renderTarget = e, this.range = [...t];
  }
  // draw the given texture at the given span with the provided projection
  draw(e, t) {
    const { range: s, renderer: n, quad: i, renderTarget: r } = this, o = i.material;
    o.map = e, o.minRange.x = _.mapLinear(t[0], s[0], s[2], -1, 1), o.minRange.y = _.mapLinear(t[1], s[1], s[3], -1, 1), o.maxRange.x = _.mapLinear(t[2], s[0], s[2], -1, 1), o.maxRange.y = _.mapLinear(t[3], s[1], s[3], -1, 1);
    const l = n.getRenderTarget(), c = n.autoClear;
    n.autoClear = !1, n.setRenderTarget(r), n.render(i, fr), n.setRenderTarget(l), n.autoClear = c, o.map = null;
  }
  // clear the set target
  clear(e, t = 1) {
    const { renderer: s, renderTarget: n } = this, i = s.getRenderTarget(), r = s.getClearColor(mr), o = s.getClearAlpha();
    s.setClearColor(e, t), s.setRenderTarget(n), s.clear(), s.setRenderTarget(i), s.setClearColor(r, o);
  }
  dispose() {
    this.quad.material.dispose(), this.quad.geometry.dispose();
  }
}
class yr extends nn {
  // the [ - 1, 1 ] NDC ranges to draw the texture at
  get minRange() {
    return this.uniforms.minRange.value;
  }
  get maxRange() {
    return this.uniforms.maxRange.value;
  }
  // access the map being drawn
  get map() {
    return this.uniforms.map.value;
  }
  set map(e) {
    this.uniforms.map.value = e;
  }
  constructor() {
    super({
      depthWrite: !1,
      depthTest: !1,
      transparent: !1,
      side: on,
      premultipliedAlpha: !0,
      uniforms: {
        map: { value: null },
        // the normalized [0, 1] range of the target to draw to
        minRange: { value: new W() },
        maxRange: { value: new W() }
      },
      vertexShader: (
        /* glsl */
        `

				uniform vec2 minRange;
				uniform vec2 maxRange;
				varying vec2 vUv;

				void main() {

					vUv = uv;
					gl_Position = vec4( mix( minRange, maxRange, uv ), 0, 1 );

				}

			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D map;
				uniform vec2 minRange;
				uniform vec2 maxRange;
				varying vec2 vUv;

				void main() {

					// sample the texture
					gl_FragColor = texture( map, vUv );
					#include <premultiplied_alpha_fragment>

				}

			`
      )
    });
  }
}
function et(a, e, t, s, n) {
  let [i, r, o, l] = a;
  r += 1e-8, i += 1e-8, l -= 1e-8, o -= 1e-8;
  const c = Math.max(Math.min(e, t.maxLevel), t.minLevel), [u, h, p, m] = t.getTilesInRange(i, r, o, l, c, s);
  for (let d = u; d <= p; d++)
    for (let f = h; f <= m; f++)
      n(d, f, c);
}
function xr(a, e, t) {
  const s = new E(), n = {}, i = [], r = a.getAttribute("position");
  a.computeBoundingBox(), a.boundingBox.getCenter(s).applyMatrix4(e), t.getPositionToCartographic(s, n);
  const o = n.lat, l = n.lon;
  let c = 1 / 0, u = 1 / 0, h = 1 / 0, p = -1 / 0, m = -1 / 0, d = -1 / 0;
  for (let g = 0; g < r.count; g++)
    s.fromBufferAttribute(r, g).applyMatrix4(e), t.getPositionToCartographic(s, n), Math.abs(Math.abs(n.lat) - Math.PI / 2) < 1e-5 && (n.lon = l), Math.abs(l - n.lon) > Math.PI && (n.lon += Math.sign(l - n.lon) * Math.PI * 2), Math.abs(o - n.lat) > Math.PI && (n.lat += Math.sign(o - n.lat) * Math.PI * 2), i.push(n.lon, n.lat, n.height), c = Math.min(c, n.lat), p = Math.max(p, n.lat), u = Math.min(u, n.lon), m = Math.max(m, n.lon), h = Math.min(h, n.height), d = Math.max(d, n.height);
  const f = [u, c, m, p], y = [...f, h, d];
  return {
    uv: i,
    range: f,
    region: y
  };
}
function Ns(a, e, t = null, s = null) {
  let n = 1 / 0, i = 1 / 0, r = 1 / 0, o = -1 / 0, l = -1 / 0, c = -1 / 0;
  const u = [], h = new Q();
  a.forEach((m) => {
    h.copy(m.matrixWorld), t && h.premultiply(t);
    const { uv: d, region: f } = xr(m.geometry, h, e);
    u.push(d), n = Math.min(n, f[1]), o = Math.max(o, f[3]), i = Math.min(i, f[0]), l = Math.max(l, f[2]), r = Math.min(r, f[4]), c = Math.max(c, f[5]);
  });
  let p = [i, n, l, o];
  if (s !== null) {
    p = s.clampToProjectionBounds([i, n, l, o]);
    const [m, d, f, y] = s.toNormalizedRange(p);
    u.forEach((g) => {
      for (let x = 0, S = g.length; x < S; x += 3) {
        const T = g[x + 0], b = g[x + 1], M = g[x + 2], [C, v] = s.toNormalizedPoint(T, b);
        g[x + 0] = _.mapLinear(C, m, f, 0, 1), g[x + 1] = _.mapLinear(v, d, y, 0, 1), g[x + 2] = _.mapLinear(M, r, c, 0, 1);
      }
    });
  }
  return {
    uvs: u,
    range: p,
    region: [i, n, l, o, r, c]
  };
}
function Tr(a, e, t) {
  const s = new E(), n = [], i = a.getAttribute("position");
  let r = 1 / 0, o = 1 / 0, l = 1 / 0, c = -1 / 0, u = -1 / 0, h = -1 / 0;
  for (let m = 0; m < i.count; m++)
    s.fromBufferAttribute(i, m).applyMatrix4(e), s.x /= t, n.push(s.x, s.y, s.z), r = Math.min(r, s.x), c = Math.max(c, s.x), o = Math.min(o, s.y), u = Math.max(u, s.y), l = Math.min(l, s.z), h = Math.max(h, s.z);
  return {
    uv: n,
    range: [r, o, c, u],
    heightRange: [l, h]
  };
}
function br(a, e, t) {
  let s = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, l = -1 / 0;
  const c = [], u = new Q();
  return a.forEach((h) => {
    u.copy(h.matrixWorld), e && u.premultiply(e);
    const { uv: p, range: m, heightRange: d } = Tr(h.geometry, u, t.aspectRatio);
    c.push(p), s = Math.min(s, m[0]), r = Math.max(r, m[2]), n = Math.min(n, m[1]), o = Math.max(o, m[3]), i = Math.min(i, d[0]), l = Math.max(l, d[1]);
  }), c.forEach((h) => {
    for (let p = 0, m = h.length; p < m; p += 3) {
      const d = h[p + 0], f = h[p + 1];
      h[p + 0] = _.mapLinear(d, s, r, 0, 1), h[p + 1] = _.mapLinear(f, n, o, 0, 1);
    }
  }), {
    uvs: c,
    range: [s, n, r, o],
    heightRange: [i, l]
  };
}
const Mt = Symbol("OVERLAY_PARAMS");
function _r(a, e) {
  if (a[Mt])
    return a[Mt];
  const t = {
    layerMaps: { value: [] },
    layerColor: { value: [] }
  };
  return a[Mt] = t, a.defines = {
    ...a.defines || {},
    LAYER_COUNT: 0
  }, a.onBeforeCompile = (s) => {
    e && e(s), s.uniforms = {
      ...s.uniforms,
      ...t
    }, s.vertexShader = s.vertexShader.replace(/void main\(\s*\)\s*{/, (n) => (
      /* glsl */
      `

				#pragma unroll_loop_start
					for ( int i = 0; i < 10; i ++ ) {

						#if UNROLLED_LOOP_INDEX < LAYER_COUNT

							attribute vec3 layer_uv_UNROLLED_LOOP_INDEX;
							varying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;

						#endif


					}
				#pragma unroll_loop_end

				${n}

				#pragma unroll_loop_start
					for ( int i = 0; i < 10; i ++ ) {

						#if UNROLLED_LOOP_INDEX < LAYER_COUNT

							v_layer_uv_UNROLLED_LOOP_INDEX = layer_uv_UNROLLED_LOOP_INDEX;

						#endif

					}
				#pragma unroll_loop_end

			`
    )), s.fragmentShader = s.fragmentShader.replace(/void main\(/, (n) => (
      /* glsl */
      `

				#if LAYER_COUNT != 0
					struct LayerTint {
						vec3 color;
						float opacity;
					};

					uniform sampler2D layerMaps[ LAYER_COUNT ];
					uniform LayerTint layerColor[ LAYER_COUNT ];
				#endif

				#pragma unroll_loop_start
					for ( int i = 0; i < 10; i ++ ) {

						#if UNROLLED_LOOP_INDEX < LAYER_COUNT

							varying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;

						#endif

					}
				#pragma unroll_loop_end

				${n}

			`
    )).replace(/#include <color_fragment>/, (n) => (
      /* glsl */
      `

				${n}

				#if LAYER_COUNT != 0
				{
					vec4 tint;
					vec3 layerUV;
					float layerOpacity;
					float wOpacity;
					float wDelta;
					#pragma unroll_loop_start
						for ( int i = 0; i < 10; i ++ ) {

							#if UNROLLED_LOOP_INDEX < LAYER_COUNT

								layerUV = v_layer_uv_UNROLLED_LOOP_INDEX;
								tint = texture( layerMaps[ i ], layerUV.xy );

								// discard texture outside 0, 1 on w - offset the stepped value by an epsilon to avoid cases
								// where wDelta is near 0 (eg a flat surface) at the w boundary, resulting in artifacts on some
								// hardware.
								wDelta = max( fwidth( layerUV.z ), 1e-7 );
								wOpacity =
									smoothstep( - wDelta, 0.0, layerUV.z ) *
									smoothstep( 1.0 + wDelta, 1.0, layerUV.z );

								// apply tint & opacity
								tint.rgb *= layerColor[ i ].color;
								tint.rgba *= layerColor[ i ].opacity * wOpacity;

								// premultiplied alpha equation
								diffuseColor = tint + diffuseColor * ( 1.0 - tint.a );

							#endif

						}
					#pragma unroll_loop_end
				}
				#endif
			`
    ));
  }, t;
}
const Ct = /* @__PURE__ */ new E(), qe = /* @__PURE__ */ new E();
function Sr(a, e, t) {
  a.getCartographicToPosition(e, t, 0, Ct), a.getCartographicToPosition(e + 0.01, t, 0, qe);
  const n = Ct.distanceTo(qe);
  return a.getCartographicToPosition(e, t + 0.01, 0, qe), Ct.distanceTo(qe) / n;
}
class Mr extends Se {
  constructor({
    geojson: e = null,
    url: t = null,
    // URL or GeoJson object can be provided
    tileDimension: s = 256,
    levels: n = 20,
    pointRadius: i = 6,
    strokeStyle: r = "white",
    strokeWidth: o = 2,
    fillStyle: l = "rgba( 255, 255, 255, 0.5 )",
    ...c
  } = {}) {
    super(c), this.geojson = e, this.url = t, this.tileDimension = s, this.levels = n, this.pointRadius = i, this.strokeStyle = r, this.strokeWidth = o, this.fillStyle = l;
  }
  async init() {
    const { tiling: e, levels: t, tileDimension: s, geojson: n, url: i } = this, r = new ue();
    if (e.setProjection(r), e.setContentBounds(...r.getBounds()), e.generateLevels(
      t,
      r.tileCountX,
      r.tileCountY,
      {
        tilePixelWidth: s,
        tilePixelHeight: s
      }
    ), !n && i) {
      const l = await this.fetchData(i);
      this.geojson = await l.json();
    }
    const o = this._geoJSONBounds(50).map((l) => l * _.DEG2RAD);
    this.tiling.setContentBounds(...o);
  }
  // main fetch per tile - > returns .Texture
  async fetchItem(e, t) {
    return this.drawCanvasImage(e);
  }
  drawCanvasImage(e) {
    const { tiling: t, tileDimension: s, geojson: n } = this, [i, r, o] = e, l = t.getTileBounds(i, r, o, !1, !1).map((m) => _.RAD2DEG * m), c = document.createElement("canvas");
    c.width = s, c.height = s;
    const u = c.getContext("2d"), h = this._featuresFromGeoJSON(n);
    for (let m = 0; m < h.length; m++) {
      const d = h[m];
      this._featureIntersectsTile(d, l) && this._drawFeatureOnCanvas(u, d, l, c.width, c.height);
    }
    const p = new an(c);
    return p.needsUpdate = !0, p;
  }
  // bbox quick test in projected units
  _featureIntersectsTile(e, t) {
    const s = this._getFeatureBounds(e);
    if (!s)
      return !1;
    const [n, i, r, o] = s, [l, c, u, h] = t;
    return !(r < l || n > u || o < c || i > h);
  }
  _getFeatureBounds(e) {
    const { geometry: t } = e;
    if (!t)
      return null;
    const { type: s, coordinates: n } = t;
    let i = 1 / 0, r = 1 / 0, o = -1 / 0, l = -1 / 0;
    const c = (u, h) => {
      i = Math.min(i, u), o = Math.max(o, u), r = Math.min(r, h), l = Math.max(l, h);
    };
    return s === "Point" ? c(n[0], n[1]) : s === "MultiPoint" || s === "LineString" ? n.forEach((u) => c(u[0], u[1])) : s === "MultiLineString" || s === "Polygon" ? n.forEach((u) => u.forEach((h) => c(h[0], h[1]))) : s === "MultiPolygon" && n.forEach(
      (u) => u.forEach((h) => h.forEach((p) => c(p[0], p[1])))
    ), [i, r, o, l];
  }
  // Normalize top-level geojson into an array of Feature objects
  _featuresFromGeoJSON(e) {
    const t = e.type, s = /* @__PURE__ */ new Set(["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"]);
    return t === "FeatureCollection" ? e.features : t === "Feature" ? [e] : t === "GeometryCollection" ? e.geometries.map((n) => ({ type: "Feature", geometry: n, properties: {} })) : s.has(t) ? [{ type: "Feature", geometry: e, properties: {} }] : [];
  }
  // draw feature on canvas ( assumes intersects already )
  _drawFeatureOnCanvas(e, t, s, n, i) {
    const { geometry: r = null, properties: o = {} } = t;
    if (!r)
      return;
    const [l, c, u, h] = s, p = o.strokeStyle || this.strokeStyle, m = o.fillStyle || this.fillStyle, d = o.pointRadius || this.pointRadius, f = o.strokeWidth || this.strokeWidth;
    e.save(), e.strokeStyle = p, e.fillStyle = m, e.lineWidth = f;
    const y = new Array(2), g = (T, b, M = y) => {
      const C = _.mapLinear(T, l, u, 0, n), v = i - _.mapLinear(b, c, h, 0, i);
      return M[0] = Math.round(C), M[1] = Math.round(v), M;
    }, x = (T, b) => {
      const M = b * _.DEG2RAD, C = T * _.DEG2RAD, v = (h - c) / i;
      return (u - l) / n / v * Sr(oi, M, C);
    }, S = r.type;
    if (S === "Point") {
      const [T, b] = r.coordinates, [M, C] = g(T, b), v = x(T, b);
      e.beginPath(), e.ellipse(M, C, d / v, d, 0, 0, Math.PI * 2), e.fill(), e.stroke();
    } else S === "MultiPoint" ? r.coordinates.forEach(([T, b]) => {
      const [M, C] = g(T, b), v = x(T, b);
      e.beginPath(), e.ellipse(M, C, d / v, d, 0, 0, Math.PI * 2), e.fill(), e.stroke();
    }) : S === "LineString" ? (e.beginPath(), r.coordinates.forEach(([T, b], M) => {
      const [C, v] = g(T, b);
      M === 0 ? e.moveTo(C, v) : e.lineTo(C, v);
    }), e.stroke()) : S === "MultiLineString" ? (e.beginPath(), r.coordinates.forEach((T) => {
      T.forEach(([b, M], C) => {
        const [v, w] = g(b, M);
        C === 0 ? e.moveTo(v, w) : e.lineTo(v, w);
      });
    }), e.stroke()) : S === "Polygon" ? (e.beginPath(), r.coordinates.forEach((T, b) => {
      T.forEach(([M, C], v) => {
        const [w, I] = g(M, C);
        v === 0 ? e.moveTo(w, I) : e.lineTo(w, I);
      }), e.closePath();
    }), e.fill("evenodd"), e.stroke()) : S === "MultiPolygon" && r.coordinates.forEach((T) => {
      e.beginPath(), T.forEach((b, M) => {
        b.forEach(([C, v], w) => {
          const [I, V] = g(C, v);
          w === 0 ? e.moveTo(I, V) : e.lineTo(I, V);
        }), e.closePath();
      }), e.fill("evenodd"), e.stroke();
    });
    e.restore();
  }
  // Compute geographic bounds in degrees from current geojson.
  _geoJSONBounds() {
    const e = this._featuresFromGeoJSON(this.geojson);
    let t = 1 / 0, s = 1 / 0, n = -1 / 0, i = -1 / 0;
    return e.forEach((r) => {
      const [o, l, c, u] = this._getFeatureBounds(r);
      t = Math.min(t, o), s = Math.min(s, l), n = Math.max(n, c), i = Math.max(i, u);
    }), [t, s, n, i];
  }
}
const be = /* @__PURE__ */ new Q(), We = /* @__PURE__ */ new E(), vt = /* @__PURE__ */ new E(), At = /* @__PURE__ */ new E(), ee = /* @__PURE__ */ new E(), Cr = /* @__PURE__ */ new it(), ks = Symbol("SPLIT_TILE_DATA"), Xe = Symbol("SPLIT_HASH");
function Ie(a, e, t, s) {
  if (Array.isArray(t)) {
    const i = t.map((r) => Ie(a, e, r, s)).filter((r) => r !== null);
    return i.length === 0 ? null : Promise.all(i);
  }
  if (t.isReady)
    return n();
  return t.whenReady().then(n);
  function n() {
    const i = [], { imageSource: r, tiling: o } = t;
    et(a, e, o, t.isPlanarProjection, (c, u, h) => {
      s ? r.release(c, u, h) : i.push(r.lock(c, u, h));
    });
    const l = i.filter((c) => c instanceof Promise);
    return l.length !== 0 ? Promise.all(l) : null;
  }
}
function vr(a, e, t) {
  let s = 0;
  return et(a, e, t.tiling, t.isPlanarProjection, (n, i, r) => {
    s++;
  }), s;
}
class fo {
  get enableTileSplitting() {
    return this._enableTileSplitting;
  }
  set enableTileSplitting(e) {
    this._enableTileSplitting !== e && (this._enableTileSplitting = e, this._markNeedsUpdate());
  }
  constructor(e = {}) {
    const {
      overlays: t = [],
      resolution: s = 256,
      renderer: n = null,
      enableTileSplitting: i = !0
    } = e;
    this.name = "IMAGE_OVERLAY_PLUGIN", this.priority = -15, this.renderer = n, this.resolution = s, this._enableTileSplitting = i, this.overlays = [], this.needsUpdate = !1, this.tiles = null, this.tileComposer = null, this.tileControllers = /* @__PURE__ */ new Map(), this.overlayInfo = /* @__PURE__ */ new Map(), this.usedTextures = /* @__PURE__ */ new Set(), this.meshParams = /* @__PURE__ */ new WeakMap(), this.pendingTiles = /* @__PURE__ */ new Map(), this.processQueue = null, this._onUpdateAfter = null, this._onTileDownloadStart = null, this._cleanupScheduled = !1, this._virtualChildResetId = 0, this._bytesUsed = /* @__PURE__ */ new WeakMap(), t.forEach((r) => {
      this.addOverlay(r);
    });
  }
  // plugin functions
  init(e) {
    const t = new gr(this.renderer), s = new di();
    s.maxJobs = 10, s.priorityCallback = (n, i) => {
      const r = n.tile, o = i.tile, l = e.visibleTiles.has(r), c = e.visibleTiles.has(o);
      return l !== c ? l ? 1 : -1 : e.downloadQueue.priorityCallback(r, o);
    }, this.tiles = e, this.tileComposer = t, this.processQueue = s, e.forEachLoadedModel((n, i) => {
      this._processTileModel(n, i, !0);
    }), this._onUpdateAfter = async () => {
      let n = !1;
      if (this.overlayInfo.forEach((i, r) => {
        if (!!r.frame != !!i.frame || r.frame && i.frame && !i.frame.equals(r.frame)) {
          const o = i.order;
          this.deleteOverlay(r, !1), this.addOverlay(r, o), n = !0;
        }
      }), n) {
        const i = s.maxJobs;
        let r = 0;
        s.items.forEach((o) => {
          e.visibleTiles.has(o.tile) && r++;
        }), s.maxJobs = r + s.currJobs, s.tryRunJobs(), s.maxJobs = i, this.needsUpdate = !0;
      }
      if (this.needsUpdate) {
        this.needsUpdate = !1;
        const { overlays: i, overlayInfo: r } = this;
        i.sort((o, l) => r.get(o).order - r.get(l).order), e.forEachLoadedModel((o, l) => {
          this._updateLayers(l);
        }), this.resetVirtualChildren(!this.enableTileSplitting), e.recalculateBytesUsed(), e.dispatchEvent({ type: "needs-rerender" });
      }
    }, this._onTileDownloadStart = ({ tile: n }) => {
      this._initTileOverlayInfo(n);
    }, e.addEventListener("update-after", this._onUpdateAfter), e.addEventListener("tile-download-start", this._onTileDownloadStart), this.overlays.forEach((n) => {
      this._initOverlay(n);
    });
  }
  disposeTile(e) {
    const { overlayInfo: t, tileControllers: s, processQueue: n, pendingTiles: i } = this;
    s.has(e) && (s.get(e).abort(), s.delete(e), i.delete(e)), t.forEach((({ tileInfo: r }, o) => {
      if (r.has(e)) {
        const { meshInfo: l, range: c, meshRange: u, level: h, target: p, meshRangeMarked: m, rangeMarked: d } = r.get(e);
        u !== null && m && Ie(u, h, o, !0), c !== null && d && Ie(c, h, o, !0), p !== null && p.dispose(), r.delete(e), l.clear();
      }
    })), n.removeByFilter((r) => r.tile === e);
  }
  calculateBytesUsed(e) {
    const { overlayInfo: t } = this, s = this._bytesUsed;
    let n = null;
    return t.forEach(({ tileInfo: i }, r) => {
      if (i.has(e)) {
        const { target: o } = i.get(e);
        n = n || 0, n += ai(o == null ? void 0 : o.texture);
      }
    }), n !== null ? (s.set(e, n), n) : s.has(e) ? s.get(e) : 0;
  }
  processTileModel(e, t) {
    return this._processTileModel(e, t);
  }
  async _processTileModel(e, t, s = !1) {
    this.tileControllers.set(t, new AbortController()), s || this.pendingTiles.set(t, e), this._wrapMaterials(e), this._initTileOverlayInfo(t), await this._initTileSceneOverlayInfo(e, t), this.expandVirtualChildren(e, t), this._updateLayers(t), this.pendingTiles.delete(t);
  }
  dispose() {
    const { tileComposer: e, tiles: t } = this;
    e.dispose(), [...this.overlays].forEach((n) => {
      this.deleteOverlay(n);
    }), t.forEachLoadedModel((n, i) => {
      this._updateLayers(i), this.disposeTile(i), delete i[Xe];
    }), t.removeEventListener("update-after", this._onUpdateAfter), this.resetVirtualChildren(!0);
  }
  getAttributions(e) {
    this.overlays.forEach((t) => {
      t.opacity > 0 && t.getAttributions(e);
    });
  }
  parseToMesh(e, t, s, n) {
    if (s === "image_overlay_tile_split")
      return t[ks];
  }
  async resetVirtualChildren(e = !1) {
    this._virtualChildResetId++;
    const t = this._virtualChildResetId;
    if (await Promise.all(this.overlays.map((r) => r.whenReady())), t !== this._virtualChildResetId)
      return;
    const { tiles: s } = this, n = /* @__PURE__ */ new Set();
    s.forEachLoadedModel((r, o) => {
      Xe in o && n.add(o);
    }), n.forEach((r) => {
      if (r.parent === null)
        return;
      const o = r.cached.scene.clone();
      o.updateMatrixWorld();
      const { hash: l } = this._getSplitVectors(o, r);
      if (r[Xe] !== l || e) {
        const c = i(r);
        c.sort((u, h) => (h.__depth || 0) - (u.__depth || 0)), c.forEach((u) => {
          s.processNodeQueue.remove(u), s.lruCache.remove(u), u.parent = null;
        }), r.children.length = 0, r.__childrenProcessed = 0;
      }
    }), e || s.forEachLoadedModel((r, o) => {
      this.expandVirtualChildren(r, o);
    });
    function i(r, o = []) {
      return r.children.forEach((l) => {
        o.push(l), i(l, o);
      }), o;
    }
  }
  _getSplitVectors(e, t, s = vt) {
    const { tiles: n, overlayInfo: i } = this, r = new it();
    r.setFromObject(e), r.getCenter(s);
    const o = [], l = [];
    i.forEach(({ tileInfo: u }, h) => {
      const p = u.get(t);
      if (p && p.target && h.tiling.maxLevel > p.level) {
        h.frame ? ee.set(0, 0, 1).transformDirection(h.frame) : (n.ellipsoid.getPositionToNormal(s, ee), ee.length() < 1e-6 && ee.set(1, 0, 0));
        const m = `${ee.x.toFixed(3)},${ee.y.toFixed(3)},${ee.z.toFixed(3)}_`;
        l.includes(m) || l.push(m);
        const d = We.set(0, 0, 1);
        Math.abs(ee.dot(d)) > 1 - 1e-4 && d.set(1, 0, 0);
        const f = new E().crossVectors(ee, d).normalize(), y = new E().crossVectors(ee, f).normalize();
        o.push(f, y);
      }
    });
    const c = [];
    for (; o.length !== 0; ) {
      const u = o.pop().clone(), h = u.clone();
      for (let p = 0; p < o.length; p++) {
        const m = o[p], d = u.dot(m);
        Math.abs(d) > Math.cos(Math.PI / 8) && (h.addScaledVector(m, Math.sign(d)), u.copy(h).normalize(), o.splice(p, 1), p--);
      }
      c.push(h.normalize());
    }
    return { directions: c, hash: l.join("") };
  }
  async expandVirtualChildren(e, t) {
    if (t.children.length !== 0 || this.enableTileSplitting === !1)
      return;
    const s = e.clone();
    s.updateMatrixWorld();
    const { directions: n, hash: i } = this._getSplitVectors(s, t, vt);
    if (t[Xe] = i, n.length === 0)
      return;
    const r = new yn();
    r.attributeList = (l) => !/^layer_uv_\d+/.test(l), n.map((l) => {
      r.addSplitOperation((c, u, h, p, m, d) => (Ht.getInterpolatedAttribute(c.attributes.position, u, h, p, m, We), We.applyMatrix4(d).sub(vt).dot(l)));
    });
    const o = [];
    r.forEachSplitPermutation(() => {
      const l = r.clipObject(s);
      l.matrix.premultiply(t.cached.transformInverse).decompose(l.position, l.quaternion, l.scale);
      const c = [];
      if (l.traverse((h) => {
        if (h.isMesh) {
          const p = h.material.clone();
          h.material = p;
          for (const m in p) {
            const d = p[m];
            if (d && d.isTexture && d.source.data instanceof ImageBitmap) {
              const f = document.createElement("canvas");
              f.width = d.image.width, f.height = d.image.height;
              const y = f.getContext("2d");
              y.scale(1, -1), y.drawImage(d.source.data, 0, 0, f.width, -f.height);
              const g = new an(f);
              g.mapping = d.mapping, g.wrapS = d.wrapS, g.wrapT = d.wrapT, g.minFilter = d.minFilter, g.magFilter = d.magFilter, g.format = d.format, g.type = d.type, g.anisotropy = d.anisotropy, g.colorSpace = d.colorSpace, g.generateMipmaps = d.generateMipmaps, p[m] = g;
            }
          }
          c.push(h);
        }
      }), c.length === 0)
        return;
      const u = {};
      if (t.boundingVolume.region && (u.region = Ns(c, this.tiles.ellipsoid).region), t.boundingVolume.box || t.boundingVolume.sphere) {
        Cr.setFromObject(l, !0).getCenter(At);
        let h = 0;
        l.traverse((p) => {
          const m = p.geometry;
          if (m) {
            const d = m.attributes.position;
            for (let f = 0, y = d.count; f < y; f++) {
              const g = We.fromBufferAttribute(d, f).applyMatrix4(p.matrixWorld).distanceToSquared(At);
              h = Math.max(h, g);
            }
          }
        }), u.sphere = [...At, Math.sqrt(h)];
      }
      o.push({
        refine: "REPLACE",
        geometricError: t.geometricError * 0.5,
        boundingVolume: u,
        content: { uri: "./child.image_overlay_tile_split" },
        children: [],
        [ks]: l
      });
    }), t.children.push(...o);
  }
  fetchData(e, t) {
    if (/image_overlay_tile_split/.test(e))
      return new ArrayBuffer();
  }
  // public
  addOverlay(e, t = null) {
    const { tiles: s, overlays: n, overlayInfo: i } = this;
    t === null && (t = n.reduce((o, l) => Math.max(o, l.order + 1), 0));
    const r = new AbortController();
    n.push(e), i.set(e, {
      order: t,
      uniforms: {},
      tileInfo: /* @__PURE__ */ new Map(),
      controller: r,
      frame: e.frame ? e.frame.clone() : null
    }), s !== null && this._initOverlay(e);
  }
  setOverlayOrder(e, t) {
    this.overlays.indexOf(e) !== -1 && (this.overlayInfo.get(e).order = t, this._markNeedsUpdate());
  }
  deleteOverlay(e, t = !0) {
    const { overlays: s, overlayInfo: n, processQueue: i } = this, r = s.indexOf(e);
    if (r !== -1) {
      const { tileInfo: o, controller: l } = n.get(e);
      o.forEach(({ meshInfo: c, target: u }) => {
        u !== null && u.dispose(), c.clear();
      }), o.clear(), n.delete(e), l.abort(), i.removeByFilter((c) => c.overlay === e), s.splice(r, 1), t && e.dispose(), this._markNeedsUpdate();
    }
  }
  // internal
  _calculateLevelFromOverlay(e, t, s, n = !1) {
    if (e.isPlanarProjection) {
      const { resolution: i } = this, { tiling: r } = e, o = n ? t : r.toNormalizedRange(t), [l, c, u, h] = o, p = u - l, m = h - c;
      let d = 0;
      const { maxLevel: f } = r;
      for (; d < f; d++) {
        const y = i / p, g = i / m, { pixelWidth: x, pixelHeight: S } = r.getLevel(d);
        if (x >= y || S >= g)
          break;
      }
      return d;
    } else
      return s.__depthFromRenderedParent - 1;
  }
  // initialize the overlay to use the right fetch options, load all data for existing tiles
  _initOverlay(e) {
    const { tiles: t } = this;
    e.isInitialized || (e.imageSource.fetchData = (...i) => t.downloadQueue.add({ priority: -performance.now() }, () => e.fetch(...i)), e.init());
    const s = [], n = async (i, r) => {
      this._initTileOverlayInfo(r, e);
      const o = this._initTileSceneOverlayInfo(i, r, e);
      s.push(o), await o, this._updateLayers(r);
    };
    t.forEachLoadedModel(n), this.pendingTiles.forEach((i, r) => {
      n(i, r);
    }), Promise.all(s).then(() => {
      this._markNeedsUpdate();
    });
  }
  // wrap all materials in the given scene wit the overlay material shader
  _wrapMaterials(e) {
    e.traverse((t) => {
      if (t.material) {
        const s = _r(t.material, t.material.onBeforeCompile);
        this.meshParams.set(t, s);
      }
    });
  }
  // Initialize per-tile overlay information. This function triggers an async function but
  // does not need to be awaited for use since it's just locking textures which are awaited later.
  _initTileOverlayInfo(e, t = this.overlays) {
    if (Array.isArray(t)) {
      t.forEach((o) => this._initTileOverlayInfo(e, o));
      return;
    }
    const { overlayInfo: s, processQueue: n } = this;
    if (s.get(t).tileInfo.has(e))
      return;
    const i = e.__depthFromRenderedParent - 1, r = {
      range: null,
      meshRange: null,
      level: null,
      target: null,
      meshInfo: /* @__PURE__ */ new Map(),
      rangeMarked: !1,
      meshRangeMarked: !1
    };
    if (s.get(t).tileInfo.set(e, r), !t.isPlanarProjection) {
      if (e.boundingVolume.region) {
        const [o, l, c, u] = e.boundingVolume.region, h = [o, l, c, u];
        r.range = h, r.level = this._calculateLevelFromOverlay(t, h, e), n.add({ tile: e, overlay: t }, () => (r.rangeMarked = !0, Ie(h, i, t, !1))).catch(() => {
        });
      }
    }
  }
  // initialize the scene meshes
  async _initTileSceneOverlayInfo(e, t, s = this.overlays) {
    if (Array.isArray(s))
      return Promise.all(s.map((v) => this._initTileSceneOverlayInfo(e, t, v)));
    const { tiles: n, overlayInfo: i, resolution: r, tileComposer: o, tileControllers: l, usedTextures: c, processQueue: u } = this, { ellipsoid: h } = n, { controller: p, tileInfo: m } = i.get(s), d = l.get(t);
    if (s.isReady || await s.whenReady(), p.signal.aborted || d.signal.aborted)
      return;
    const f = [];
    e.updateMatrixWorld(), e.traverse((v) => {
      v.isMesh && f.push(v);
    });
    const { tiling: y, imageSource: g } = s, x = m.get(t);
    let S, T, b;
    if (s.isPlanarProjection) {
      be.copy(s.frame), e.parent !== null && be.multiply(n.group.matrixWorldInverse);
      let v;
      ({ range: S, uvs: T, heightRange: v } = br(f, be, y)), b = !(v[0] > 1 || v[1] < 0);
    } else
      be.identity(), e.parent !== null && be.copy(n.group.matrixWorldInverse), { range: S, uvs: T } = Ns(f, h, be, y), b = !0;
    let M;
    s.isPlanarProjection ? M = S : M = y.toNormalizedRange(S), x.level === null && (x.level = this._calculateLevelFromOverlay(s, M, t, !0));
    let C = null;
    b && vr(S, x.level, s) !== 0 && (C = new Dt(r, r, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      colorSpace: Js
    })), x.meshRange = S, x.target = C, f.forEach((v, w) => {
      const I = new Float32Array(T[w]), V = new K(I, 3);
      x.meshInfo.set(v, { attribute: V });
    }), C !== null && await u.add({ tile: t, overlay: s }, async () => {
      x.meshRangeMarked = !0;
      const v = Ie(S, x.level, s, !1);
      if (v) {
        o.setRenderTarget(C, M), o.clear(16777215, 0), et(S, x.level - 1, y, s.isPlanarProjection, (w, I, V) => {
          const D = y.getTileBounds(w, I, V, !0, !1), N = g.get(w, I, V);
          N && !(N instanceof Promise) && (o.draw(N, D), c.add(N), this._scheduleCleanup());
        });
        try {
          await v;
        } catch {
          return;
        }
      }
      p.signal.aborted || d.signal.aborted || (o.setRenderTarget(C, M), o.clear(16777215, 0), et(S, x.level, y, s.isPlanarProjection, (w, I, V) => {
        const D = y.getTileBounds(w, I, V, !0, !1), N = g.get(w, I, V);
        o.draw(N, D), c.add(N), this._scheduleCleanup();
      }));
    }).catch(() => {
    });
  }
  _updateLayers(e) {
    const { overlayInfo: t, overlays: s, tileControllers: n } = this, i = n.get(e);
    this.tiles.recalculateBytesUsed(e), !(!i || i.signal.aborted) && s.forEach((r, o) => {
      const { tileInfo: l } = t.get(r), { meshInfo: c, target: u } = l.get(e);
      c.forEach(({ attribute: h }, p) => {
        const { geometry: m, material: d } = p, f = this.meshParams.get(p), y = `layer_uv_${o}`;
        m.getAttribute(y) !== h && (m.setAttribute(y, h), m.dispose()), f.layerMaps.length = s.length, f.layerColor.length = s.length, f.layerMaps.value[o] = u !== null ? u.texture : null, f.layerColor.value[o] = r, d.defines.LAYER_COUNT = s.length, d.needsUpdate = !0;
      });
    });
  }
  _scheduleCleanup() {
    this._cleanupScheduled || (this._cleanupScheduled = !0, requestAnimationFrame(() => {
      const { usedTextures: e } = this;
      e.forEach((t) => {
        t.dispose();
      }), e.clear(), this._cleanupScheduled = !1;
    }));
  }
  _markNeedsUpdate() {
    this.needsUpdate === !1 && (this.needsUpdate = !0, this.tiles !== null && this.tiles.dispatchEvent({ type: "needs-update" }));
  }
}
class ye {
  get tiling() {
    return this.imageSource.tiling;
  }
  get projection() {
    return this.tiling.projection;
  }
  get isPlanarProjection() {
    return !!this.frame;
  }
  get aspectRatio() {
    return this.tiling && this.isReady ? this.tiling.aspectRatio : 1;
  }
  get fetchOptions() {
    return this.imageSource.fetchOptions;
  }
  set fetchOptions(e) {
    this.imageSource.fetchOptions = e;
  }
  constructor(e = {}) {
    const {
      opacity: t = 1,
      color: s = 16777215,
      frame: n = null,
      preprocessURL: i = null
    } = e;
    this.imageSource = null, this.preprocessURL = i, this.opacity = t, this.color = new qt(s), this.frame = n !== null ? n.clone() : null, this.isReady = !1, this.isInitialized = !1;
  }
  init() {
    this.isInitialized = !0, this.whenReady().then(() => {
      this.isReady = !0;
    });
  }
  fetch(e, t = {}) {
    return this.preprocessURL && (e = this.preprocessURL(e)), fetch(e, t);
  }
  whenReady() {
  }
  getAttributions(e) {
  }
  dispose() {
    this.imageSource.dispose();
  }
}
class mo extends ye {
  constructor(e = {}) {
    super(e), this.imageSource = new Wt(e), this.imageSource.fetchData = (...t) => this.fetch(...t);
  }
  init() {
    this._whenReady = this.imageSource.init(), super.init();
  }
  whenReady() {
    return this._whenReady;
  }
}
class go extends ye {
  constructor(e = {}) {
    super(e), this.imageSource = new Mr(e), this.imageSource.fetchData = (...t) => this.fetch(...t);
  }
  init() {
    this._whenReady = this.imageSource.init(), super.init();
  }
  whenReady() {
    return this._whenReady;
  }
}
class yo extends ye {
  constructor(e = {}) {
    super(e), this.imageSource = new gn(e), this.imageSource.fetchData = (...t) => this.fetch(...t);
  }
  init() {
    this._whenReady = this.imageSource.init(), super.init();
  }
  whenReady() {
    return this._whenReady;
  }
}
class xo extends ye {
  constructor(e = {}) {
    super(e), this.imageSource = new mn(e), this.imageSource.fetchData = (...t) => this.fetch(...t);
  }
  init() {
    this._whenReady = this.imageSource.init(), super.init();
  }
  whenReady() {
    return this._whenReady;
  }
}
class To extends ye {
  constructor(e = {}) {
    super(e), this.imageSource = new Xt(e), this.imageSource.fetchData = (...t) => this.fetch(...t), this.url = e.url;
  }
  init() {
    this._whenReady = this.imageSource.init(), super.init();
  }
  whenReady() {
    return this._whenReady;
  }
}
class bo extends ye {
  constructor(e = {}) {
    super(e);
    const { apiToken: t, autoRefreshToken: s, assetId: n } = e;
    this.assetId = n, this.auth = new Zs({ apiToken: t, autoRefreshToken: s }), this.imageSource = new Xt(e), this.auth.authURL = `https://api.cesium.com/v1/assets/${n}/endpoint`, this.imageSource.fetchData = (...i) => this.fetch(...i), this._attributions = [];
  }
  init() {
    this._whenReady = this.auth.refreshToken().then((e) => (this._attributions = e.attributions.map((t) => ({
      value: t.html,
      type: "html",
      collapsible: t.collapsible
    })), this.imageSource.url = e.url, this.imageSource.init())), super.init();
  }
  fetch(...e) {
    return this.auth.fetch(...e);
  }
  whenReady() {
    return this._whenReady;
  }
  getAttributions(e) {
    e.push(...this._attributions);
  }
}
class _o extends ye {
  constructor(e = {}) {
    super(e);
    const { apiToken: t, sessionOptions: s, autoRefreshToken: n, logoUrl: i } = e;
    this.logoUrl = i, this.auth = new Qs({ apiToken: t, sessionOptions: s, autoRefreshToken: n }), this.imageSource = new Wt(), this.imageSource.fetchData = (...r) => this.fetch(...r), this._logoAttribution = {
      value: "",
      type: "image",
      collapsible: !1
    };
  }
  init() {
    this._whenReady = this.auth.refreshToken().then((e) => (this.imageSource.tileDimension = e.tileWidth, this.imageSource.url = "https://tile.googleapis.com/v1/2dtiles/{z}/{x}/{y}", this.imageSource.init())), super.init();
  }
  fetch(...e) {
    return this.auth.fetch(...e);
  }
  whenReady() {
    return this._whenReady;
  }
  getAttributions(e) {
    this.logoUrl && (this._logoAttribution.value = this.logoUrl, e.push(this._logoAttribution));
  }
}
class So {
  constructor() {
    this.name = "LOAD_REGION_PLUGIN", this.regions = [], this.tiles = null;
  }
  init(e) {
    this.tiles = e;
  }
  addRegion(e) {
    this.regions.indexOf(e) === -1 && this.regions.push(e);
  }
  removeRegion(e) {
    const t = this.regions.indexOf(e);
    t !== -1 && this.regions.splice(t, 1);
  }
  hasRegion(e) {
    return this.regions.indexOf(e) !== -1;
  }
  clearRegions() {
    this.regions = [];
  }
  // Calculates shape intersections and associated error values to use. If "mask" shapes are present then
  // tiles are only loaded if they are within those shapes.
  calculateTileViewError(e, t) {
    const s = e.cached.boundingVolume, { regions: n, tiles: i } = this;
    let r = !1, o = null, l = -1 / 0;
    for (const c of n) {
      const u = c.intersectsTile(s, e, i);
      r = r || u, l = Math.max(c.calculateError(e, i), l), c.mask && (o = o || u);
    }
    return t.inView = r && o !== !1, t.error = l, t.inView || o !== null;
  }
  dispose() {
    this.regions = [];
  }
}
class Qt {
  constructor(e = {}) {
    typeof e == "number" && (console.warn("LoadRegionPlugin: Region constructor has been changed to take options as an object."), e = { errorTarget: e });
    const {
      errorTarget: t = 10,
      mask: s = !1
    } = e;
    this.errorTarget = t, this.mask = s;
  }
  intersectsTile() {
  }
  calculateError(e, t) {
    return e.geometricError - this.errorTarget + t.errorTarget;
  }
}
class Mo extends Qt {
  constructor(e = {}) {
    typeof e == "number" && (console.warn("SphereRegion: Region constructor has been changed to take options as an object."), e = {
      errorTarget: arguments[0],
      sphere: arguments[1]
    });
    const { sphere: t = new ce() } = e;
    super(e), this.sphere = t.clone();
  }
  intersectsTile(e) {
    return e.intersectsSphere(this.sphere);
  }
}
class Co extends Qt {
  constructor(e = {}) {
    typeof e == "number" && (console.warn("RayRegion: Region constructor has been changed to take options as an object."), e = {
      errorTarget: arguments[0],
      ray: arguments[1]
    });
    const { ray: t = new Kn() } = e;
    super(e), this.ray = t.clone();
  }
  intersectsTile(e) {
    return e.intersectsRay(this.ray);
  }
}
class vo extends Qt {
  constructor(e = {}) {
    typeof e == "number" && (console.warn("RayRegion: Region constructor has been changed to take options as an object."), e = {
      errorTarget: arguments[0],
      obb: arguments[1]
    });
    const { obb: t = new li() } = e;
    super(e), this.obb = t.clone(), this.obb.update();
  }
  intersectsTile(e) {
    return e.intersectsOBB(this.obb);
  }
}
const J = new E(), Gs = ["x", "y", "z"];
class Ar extends ln {
  constructor(e, t = 16776960, s = 40) {
    const n = new jt(), i = [];
    for (let r = 0; r < 3; r++) {
      const o = Gs[r], l = Gs[(r + 1) % 3];
      J.set(0, 0, 0);
      for (let c = 0; c < s; c++) {
        let u;
        u = 2 * Math.PI * c / (s - 1), J[o] = Math.sin(u), J[l] = Math.cos(u), i.push(J.x, J.y, J.z), u = 2 * Math.PI * (c + 1) / (s - 1), J[o] = Math.sin(u), J[l] = Math.cos(u), i.push(J.x, J.y, J.z);
      }
    }
    n.setAttribute("position", new K(new Float32Array(i), 3)), n.computeBoundingSphere(), super(n, new ei({ color: t, toneMapped: !1 })), this.sphere = e, this.type = "SphereHelper";
  }
  updateMatrixWorld(e) {
    const t = this.sphere;
    this.position.copy(t.center), this.scale.setScalar(t.radius), super.updateMatrixWorld(e);
  }
}
const Lt = /* @__PURE__ */ new E(), Ye = /* @__PURE__ */ new E(), te = /* @__PURE__ */ new E();
function Lr(a, { computeNormals: e = !1 } = {}) {
  const {
    latStart: t = -Math.PI / 2,
    latEnd: s = Math.PI / 2,
    lonStart: n = 0,
    lonEnd: i = 2 * Math.PI,
    heightStart: r = 0,
    heightEnd: o = 0
  } = a, l = new si(1, 1, 1, 32, 32), { normal: c, position: u } = l.attributes, h = u.clone();
  for (let p = 0, m = u.count; p < m; p++) {
    te.fromBufferAttribute(u, p);
    const d = _.mapLinear(te.x, -0.5, 0.5, t, s), f = _.mapLinear(te.y, -0.5, 0.5, n, i);
    let y = r;
    a.getCartographicToNormal(d, f, Lt), te.z < 0 && (y = o), a.getCartographicToPosition(d, f, y, te), u.setXYZ(p, ...te);
  }
  e && l.computeVertexNormals();
  for (let p = 0, m = h.count; p < m; p++) {
    te.fromBufferAttribute(h, p);
    const d = _.mapLinear(te.x, -0.5, 0.5, t, s), f = _.mapLinear(te.y, -0.5, 0.5, n, i);
    Lt.fromBufferAttribute(c, p), a.getCartographicToNormal(d, f, Ye), Math.abs(Lt.dot(Ye)) > 0.1 && (te.z > 0 && Ye.multiplyScalar(-1), c.setXYZ(p, ...Ye));
  }
  return l;
}
class Er extends ln {
  constructor(e = new ci(), t = 16776960) {
    super(), this.ellipsoidRegion = e, this.material.color.set(t), this.update();
  }
  update() {
    const e = Lr(this.ellipsoidRegion);
    this.geometry.dispose(), this.geometry = new ti(e, 80);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const js = Symbol("ORIGINAL_MATERIAL"), Et = Symbol("HAS_RANDOM_COLOR"), wt = Symbol("HAS_RANDOM_NODE_COLOR"), It = Symbol("LOAD_TIME"), fe = Symbol("PARENT_BOUND_REF_COUNT"), zs = /* @__PURE__ */ new ce(), Pt = () => {
}, Rt = {};
function Bt(a) {
  if (!Rt[a]) {
    const e = Math.random(), t = 0.5 + Math.random() * 0.5, s = 0.375 + Math.random() * 0.25;
    Rt[a] = new qt().setHSL(e, t, s);
  }
  return Rt[a];
}
const Pe = 0, vn = 1, An = 2, Ln = 3, En = 4, wn = 5, In = 6, $e = 7, Qe = 8, Pn = 9, Vt = 10, wr = Object.freeze({
  NONE: Pe,
  SCREEN_ERROR: vn,
  GEOMETRIC_ERROR: An,
  DISTANCE: Ln,
  DEPTH: En,
  RELATIVE_DEPTH: wn,
  IS_LEAF: In,
  RANDOM_COLOR: $e,
  RANDOM_NODE_COLOR: Qe,
  CUSTOM_COLOR: Pn,
  LOAD_ORDER: Vt
});
class Ao {
  static get ColorModes() {
    return wr;
  }
  get unlit() {
    return this._unlit;
  }
  set unlit(e) {
    e !== this._unlit && (this._unlit = e, this.materialsNeedUpdate = !0);
  }
  get colorMode() {
    return this._colorMode;
  }
  set colorMode(e) {
    e !== this._colorMode && (this._colorMode = e, this.materialsNeedUpdate = !0);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    e !== this._enabled && this.tiles !== null && (e ? this.init(this.tiles) : this.dispose()), this._enabled = e;
  }
  get displayParentBounds() {
    return this._displayParentBounds;
  }
  set displayParentBounds(e) {
    this._displayParentBounds !== e && (this._displayParentBounds = e, e ? this.tiles.traverse((t) => {
      t.__visible && this._onTileVisibilityChange(t, !0);
    }) : this.tiles.traverse((t) => {
      t[fe] = null, this._onTileVisibilityChange(t, t.__visible);
    }));
  }
  constructor(e) {
    e = {
      displayParentBounds: !1,
      displayBoxBounds: !1,
      displaySphereBounds: !1,
      displayRegionBounds: !1,
      colorMode: Pe,
      maxDebugDepth: -1,
      maxDebugDistance: -1,
      maxDebugError: -1,
      customColorCallback: null,
      unlit: !1,
      enabled: !0,
      ...e
    }, this.name = "DEBUG_TILES_PLUGIN", this.tiles = null, this._colorMode = null, this._unlit = null, this.materialsNeedUpdate = !1, this.extremeDebugDepth = -1, this.extremeDebugError = -1, this.boxGroup = null, this.sphereGroup = null, this.regionGroup = null, this._enabled = e.enabled, this._displayParentBounds = e.displayParentBounds, this.displayBoxBounds = e.displayBoxBounds, this.displaySphereBounds = e.displaySphereBounds, this.displayRegionBounds = e.displayRegionBounds, this.colorMode = e.colorMode, this.maxDebugDepth = e.maxDebugDepth, this.maxDebugDistance = e.maxDebugDistance, this.maxDebugError = e.maxDebugError, this.customColorCallback = e.customColorCallback, this.unlit = e.unlit, this.getDebugColor = (t, s) => {
      s.setRGB(t, t, t);
    };
  }
  // initialize the groups for displaying helpers, register events, and initialize existing tiles
  init(e) {
    this.tiles = e;
    const t = e.group;
    this.boxGroup = new Fe(), this.boxGroup.name = "DebugTilesRenderer.boxGroup", t.add(this.boxGroup), this.boxGroup.updateMatrixWorld(), this.sphereGroup = new Fe(), this.sphereGroup.name = "DebugTilesRenderer.sphereGroup", t.add(this.sphereGroup), this.sphereGroup.updateMatrixWorld(), this.regionGroup = new Fe(), this.regionGroup.name = "DebugTilesRenderer.regionGroup", t.add(this.regionGroup), this.regionGroup.updateMatrixWorld(), this._onLoadTileSetCB = () => {
      this._initExtremes();
    }, this._onLoadModelCB = ({ scene: s, tile: n }) => {
      this._onLoadModel(s, n);
    }, this._onDisposeModelCB = ({ tile: s }) => {
      this._onDisposeModel(s);
    }, this._onUpdateAfterCB = () => {
      this._onUpdateAfter();
    }, this._onTileVisibilityChangeCB = ({ scene: s, tile: n, visible: i }) => {
      this._onTileVisibilityChange(n, i);
    }, e.addEventListener("load-tile-set", this._onLoadTileSetCB), e.addEventListener("load-model", this._onLoadModelCB), e.addEventListener("dispose-model", this._onDisposeModelCB), e.addEventListener("update-after", this._onUpdateAfterCB), e.addEventListener("tile-visibility-change", this._onTileVisibilityChangeCB), this._initExtremes(), e.traverse((s) => {
      s.cached.scene && this._onLoadModel(s.cached.scene, s);
    }), e.visibleTiles.forEach((s) => {
      this._onTileVisibilityChange(s, !0);
    });
  }
  getTileInformationFromActiveObject(e) {
    let t = null;
    return this.tiles.activeTiles.forEach((n) => {
      if (t)
        return !0;
      const i = n.cached.scene;
      i && i.traverse((r) => {
        r === e && (t = n);
      });
    }), t ? {
      distanceToCamera: t.__distanceFromCamera,
      geometricError: t.geometricError,
      screenSpaceError: t.__error,
      depth: t.__depth,
      isLeaf: t.__isLeaf
    } : null;
  }
  _initExtremes() {
    if (!(this.tiles && this.tiles.root))
      return;
    let e = -1, t = -1;
    this.tiles.traverse(null, (s, n, i) => {
      e = Math.max(e, i), t = Math.max(t, s.geometricError);
    }, !1), this.extremeDebugDepth = e, this.extremeDebugError = t;
  }
  _onUpdateAfter() {
    const { tiles: e, colorMode: t } = this;
    if (!e.root)
      return;
    this.materialsNeedUpdate && (e.forEachLoadedModel((c) => {
      this._updateMaterial(c);
    }), this.materialsNeedUpdate = !1), this.boxGroup.visible = this.displayBoxBounds, this.sphereGroup.visible = this.displaySphereBounds, this.regionGroup.visible = this.displayRegionBounds;
    let s = -1;
    this.maxDebugDepth === -1 ? s = this.extremeDebugDepth : s = this.maxDebugDepth;
    let n = -1;
    this.maxDebugError === -1 ? n = this.extremeDebugError : n = this.maxDebugError;
    let i = -1;
    this.maxDebugDistance === -1 ? (e.getBoundingSphere(zs), i = zs.radius) : i = this.maxDebugDistance;
    const { errorTarget: r, visibleTiles: o } = e;
    let l;
    t === Vt && (l = Array.from(o).sort((c, u) => c[It] - u[It])), o.forEach((c) => {
      const u = c.cached.scene;
      let h, p, m;
      t === $e && (h = Math.random(), p = 0.5 + Math.random() * 0.5, m = 0.375 + Math.random() * 0.25), u.traverse((d) => {
        if (t === Qe && (h = Math.random(), p = 0.5 + Math.random() * 0.5, m = 0.375 + Math.random() * 0.25), d.material)
          switch (t !== $e && delete d.material[Et], t !== Qe && delete d.material[wt], t) {
            case En: {
              const f = c.__depth / s;
              this.getDebugColor(f, d.material.color);
              break;
            }
            case wn: {
              const f = c.__depthFromRenderedParent / s;
              this.getDebugColor(f, d.material.color);
              break;
            }
            case vn: {
              const f = c.__error / r;
              f > 1 ? d.material.color.setRGB(1, 0, 0) : this.getDebugColor(f, d.material.color);
              break;
            }
            case An: {
              const f = Math.min(c.geometricError / n, 1);
              this.getDebugColor(f, d.material.color);
              break;
            }
            case Ln: {
              const f = Math.min(c.__distanceFromCamera / i, 1);
              this.getDebugColor(f, d.material.color);
              break;
            }
            case In: {
              !c.children || c.children.length === 0 ? this.getDebugColor(1, d.material.color) : this.getDebugColor(0, d.material.color);
              break;
            }
            case Qe: {
              d.material[wt] || (d.material.color.setHSL(h, p, m), d.material[wt] = !0);
              break;
            }
            case $e: {
              d.material[Et] || (d.material.color.setHSL(h, p, m), d.material[Et] = !0);
              break;
            }
            case Pn: {
              this.customColorCallback ? this.customColorCallback(c, d) : console.warn("DebugTilesRenderer: customColorCallback not defined");
              break;
            }
            case Vt: {
              const f = l.indexOf(c);
              this.getDebugColor(f / (l.length - 1), d.material.color);
              break;
            }
          }
      });
    });
  }
  _onTileVisibilityChange(e, t) {
    this.displayParentBounds ? pi(e, (s) => {
      s[fe] == null && (s[fe] = 0), t ? s[fe]++ : s[fe] > 0 && s[fe]--;
      const n = s === e && t || this.displayParentBounds && s[fe] > 0;
      this._updateBoundHelper(s, n);
    }) : this._updateBoundHelper(e, t);
  }
  _createBoundHelper(e) {
    const t = this.tiles, s = e.cached, { sphere: n, obb: i, region: r } = s.boundingVolume;
    if (i) {
      const o = new Fe();
      o.name = "DebugTilesRenderer.boxHelperGroup", o.matrix.copy(i.transform), o.matrixAutoUpdate = !1;
      const l = new ni(i.box, Bt(e.__depth));
      l.raycast = Pt, o.add(l), s.boxHelperGroup = o, t.visibleTiles.has(e) && this.displayBoxBounds && (this.boxGroup.add(o), o.updateMatrixWorld(!0));
    }
    if (n) {
      const o = new Ar(n, Bt(e.__depth));
      o.raycast = Pt, s.sphereHelper = o, t.visibleTiles.has(e) && this.displaySphereBounds && (this.sphereGroup.add(o), o.updateMatrixWorld(!0));
    }
    if (r) {
      const o = new Er(r, Bt(e.__depth));
      o.raycast = Pt;
      const l = new ce();
      r.getBoundingSphere(l), o.position.copy(l.center), l.center.multiplyScalar(-1), o.geometry.translate(...l.center), s.regionHelper = o, t.visibleTiles.has(e) && this.displayRegionBounds && (this.regionGroup.add(o), o.updateMatrixWorld(!0));
    }
  }
  _updateHelperMaterial(e, t) {
    e.__visible || !this.displayParentBounds ? t.opacity = 1 : t.opacity = 0.2;
    const s = t.transparent;
    t.transparent = t.opacity < 1, t.transparent !== s && (t.needsUpdate = !0);
  }
  _updateBoundHelper(e, t) {
    const s = e.cached;
    if (!s)
      return;
    const n = this.sphereGroup, i = this.boxGroup, r = this.regionGroup;
    t && s.boxHelperGroup == null && s.sphereHelper == null && s.regionHelper == null && this._createBoundHelper(e);
    const o = s.boxHelperGroup, l = s.sphereHelper, c = s.regionHelper;
    t ? (o && (i.add(o), o.updateMatrixWorld(!0), this._updateHelperMaterial(e, o.children[0].material)), l && (n.add(l), l.updateMatrixWorld(!0), this._updateHelperMaterial(e, l.material)), c && (r.add(c), c.updateMatrixWorld(!0), this._updateHelperMaterial(e, c.material))) : (o && i.remove(o), l && n.remove(l), c && r.remove(c));
  }
  _updateMaterial(e) {
    const { colorMode: t, unlit: s } = this;
    e.traverse((n) => {
      if (!n.material)
        return;
      const i = n.material, r = n[js];
      if (i !== r && i.dispose(), t !== Pe || s) {
        if (n.isPoints) {
          const o = new ii();
          o.size = r.size, o.sizeAttenuation = r.sizeAttenuation, n.material = o;
        } else s ? n.material = new De() : (n.material = new Ks(), n.material.flatShading = !0);
        t === Pe && (n.material.map = r.map, n.material.color.set(r.color));
      } else
        n.material = r;
    });
  }
  _onLoadModel(e, t) {
    t[It] = performance.now(), e.traverse((s) => {
      const n = s.material;
      n && (s[js] = n);
    }), this._updateMaterial(e);
  }
  _onDisposeModel(e) {
    const t = e.cached;
    t.boxHelperGroup && (t.boxHelperGroup.children[0].geometry.dispose(), delete t.boxHelperGroup), t.sphereHelper && (t.sphereHelper.geometry.dispose(), delete t.sphereHelper), t.regionHelper && (t.regionHelper.geometry.dispose(), delete t.regionHelper);
  }
  dispose() {
    var t, s, n;
    const e = this.tiles;
    e.removeEventListener("load-tile-set", this._onLoadTileSetCB), e.removeEventListener("load-model", this._onLoadModelCB), e.removeEventListener("dispose-model", this._onDisposeModelCB), e.removeEventListener("update-after", this._onUpdateAfterCB), e.removeEventListener("tile-visibility-change", this._onTileVisibilityChangeCB), this.colorMode = Pe, this.unlit = !1, e.forEachLoadedModel((i) => {
      this._updateMaterial(i);
    }), e.traverse((i) => {
      this._onDisposeModel(i);
    }), (t = this.boxGroup) == null || t.removeFromParent(), (s = this.sphereGroup) == null || s.removeFromParent(), (n = this.regionGroup) == null || n.removeFromParent();
  }
}
class Ir extends Se {
  constructor(e = {}) {
    const { url: t = null, ...s } = e;
    super(s), this.url = t, this.format = null, this.stem = null;
  }
  getUrl(e, t, s) {
    return `${this.stem}_files/${s}/${e}_${t}.${this.format}`;
  }
  init() {
    const { url: e } = this;
    return this.fetchData(e, this.fetchOptions).then((t) => t.text()).then((t) => {
      const s = new DOMParser().parseFromString(t, "text/xml");
      if (s.querySelector("DisplayRects") || s.querySelector("Collection"))
        throw new Error("DeepZoomImagesPlugin: DisplayRect and Collection DZI files not supported.");
      const n = s.querySelector("Image"), i = n.querySelector("Size"), r = parseInt(i.getAttribute("Width")), o = parseInt(i.getAttribute("Height")), l = parseInt(n.getAttribute("TileSize")), c = parseInt(n.getAttribute("Overlap")), u = n.getAttribute("Format");
      this.format = u, this.stem = e.split(/\.[^.]+$/g)[0];
      const { tiling: h } = this, p = Math.ceil(Math.log2(Math.max(r, o))) + 1;
      h.flipY = !0, h.pixelOverlap = c, h.generateLevels(p, 1, 1, {
        tilePixelWidth: l,
        tilePixelHeight: l,
        pixelWidth: r,
        pixelHeight: o
      });
    });
  }
}
class Lo extends pn {
  constructor(e = {}) {
    const { url: t, ...s } = e;
    super(s), this.name = "DZI_TILES_PLUGIN", this.imageSource = new Ir({ url: t });
  }
}
const tt = hn * Math.PI * 2, Hs = /* @__PURE__ */ new ue("EPSG:3857");
function Pr(a) {
  return /:4326$/i.test(a);
}
function Rn(a) {
  return /:3857$/i.test(a);
}
function Ft(a) {
  return a.trim().split(/\s+/).map((e) => parseFloat(e));
}
function Nt(a, e) {
  Pr(e) && ([a[1], a[0]] = [a[0], a[1]]);
}
function st(a, e) {
  if (Rn(e))
    return a[0] = Hs.convertProjectionToLongitude(0.5 + a[0] / tt), a[1] = Hs.convertProjectionToLatitude(0.5 + a[1] / tt), a[0] *= _.RAD2DEG, a[1] *= _.RAD2DEG, a;
}
function nt(a) {
  a[0] *= _.DEG2RAD, a[1] *= _.DEG2RAD;
}
class Eo extends dn {
  parse(e) {
    const t = new TextDecoder("utf-8").decode(new Uint8Array(e)), s = new DOMParser().parseFromString(t, "text/xml"), n = s.querySelector("Contents"), i = ae(n, "TileMatrixSet").map((l) => Vr(l)), r = ae(n, "Layer").map((l) => Br(l)), o = Rr(s.querySelector("ServiceIdentification"));
    return r.forEach((l) => {
      l.tileMatrixSets = l.tileMatrixSetLinks.map((c) => i.find((u) => u.identifier === c));
    }), {
      serviceIdentification: o,
      tileMatrixSets: i,
      layers: r
    };
  }
}
function Rr(a) {
  var i;
  const e = a.querySelector("Title").textContent, t = ((i = a.querySelector("Abstract")) == null ? void 0 : i.textContent) || "", s = a.querySelector("ServiceType").textContent, n = a.querySelector("ServiceTypeVersion").textContent;
  return {
    title: e,
    abstract: t,
    serviceType: s,
    serviceTypeVersion: n
  };
}
function Br(a) {
  const e = a.querySelector("Title").textContent, t = a.querySelector("Identifier").textContent, s = a.querySelector("Format").textContent, n = ae(a, "ResourceURL").map((c) => Dr(c)), i = ae(a, "TileMatrixSetLink").map((c) => ae(c, "TileMatrixSet")[0].textContent), r = ae(a, "Style").map((c) => Or(c)), o = ae(a, "Dimension").map((c) => Ur(c));
  let l = qs(a.querySelector("WGS84BoundingBox"));
  return l || (l = qs(a.querySelector("BoundingBox"))), {
    title: e,
    identifier: t,
    format: s,
    dimensions: o,
    tileMatrixSetLinks: i,
    styles: r,
    boundingBox: l,
    resourceUrls: n
  };
}
function Dr(a) {
  const e = a.getAttribute("template"), t = a.getAttribute("format"), s = a.getAttribute("resourceType");
  return {
    template: e,
    format: t,
    resourceType: s
  };
}
function Ur(a) {
  var r, o;
  const e = a.querySelector("Identifier").textContent, t = ((r = a.querySelector("UOM")) == null ? void 0 : r.textContent) || "", s = a.querySelector("Default").textContent, n = ((o = a.querySelector("Current")) == null ? void 0 : o.textContent) === "true", i = ae(a, "Value").map((l) => l.textContent);
  return {
    identifier: e,
    uom: t,
    defaultValue: s,
    current: n,
    values: i
  };
}
function qs(a) {
  if (!a)
    return null;
  const e = a.nodeName.endsWith("WGS84BoundingBox") ? "urn:ogc:def:crs:CRS::84" : a.getAttribute("crs"), t = Ft(a.querySelector("LowerCorner").textContent), s = Ft(a.querySelector("UpperCorner").textContent);
  return Nt(t, e), Nt(s, e), st(t, e), st(s, e), nt(t), nt(s), {
    crs: e,
    lowerCorner: t,
    upperCorner: s,
    bounds: [...t, ...s]
  };
}
function Or(a) {
  var n;
  const e = ((n = a.querySelector("Title")) == null ? void 0 : n.textContent) || null, t = a.querySelector("Identifier").textContent, s = a.getAttribute("isDefault") === "true";
  return {
    title: e,
    identifier: t,
    isDefault: s
  };
}
function Vr(a) {
  var r, o;
  const e = a.querySelector("SupportedCRS").textContent, t = ((r = a.querySelector("Title")) == null ? void 0 : r.textContent) || "", s = a.querySelector("Identifier").textContent, n = ((o = a.querySelector("Abstract")) == null ? void 0 : o.textContent) || "", i = [];
  return a.querySelectorAll("TileMatrix").forEach((l, c) => {
    const u = Fr(l), h = 28e-5 * u.scaleDenominator, p = u.tileWidth * u.matrixWidth * h, m = u.tileHeight * u.matrixHeight * h;
    let d;
    Nt(u.topLeftCorner, e), Rn(e) ? d = [
      u.topLeftCorner[0] + p,
      u.topLeftCorner[1] - m
    ] : d = [
      u.topLeftCorner[0] + 360 * p / tt,
      u.topLeftCorner[1] - 360 * m / tt
    ], st(d, e), st(u.topLeftCorner, e), nt(d), nt(u.topLeftCorner), u.bounds = [...u.topLeftCorner, ...d], [u.bounds[1], u.bounds[3]] = [u.bounds[3], u.bounds[1]], i.push(u);
  }), {
    title: t,
    identifier: s,
    abstract: n,
    supportedCRS: e,
    tileMatrices: i
  };
}
function Fr(a) {
  const e = a.querySelector("Identifier").textContent, t = parseFloat(a.querySelector("TileWidth").textContent), s = parseFloat(a.querySelector("TileHeight").textContent), n = parseFloat(a.querySelector("MatrixWidth").textContent), i = parseFloat(a.querySelector("MatrixHeight").textContent), r = parseFloat(a.querySelector("ScaleDenominator").textContent), o = Ft(a.querySelector("TopLeftCorner").textContent);
  return {
    identifier: e,
    tileWidth: t,
    tileHeight: s,
    matrixWidth: n,
    matrixHeight: i,
    scaleDenominator: r,
    topLeftCorner: o,
    bounds: null
  };
}
function ae(a, e) {
  return [...a.children].filter((t) => t.tagName === e);
}
const Ws = hn * Math.PI * 2, Xs = /* @__PURE__ */ new ue("EPSG:3857");
function Nr(a) {
  return /:4326$/i.test(a);
}
function kr(a) {
  return /:3857$/i.test(a);
}
function Ys(a, e) {
  return kr(e) && (a[0] = Xs.convertProjectionToLongitude(0.5 + a[0] / (Math.PI * 2 * Ws)), a[1] = Xs.convertProjectionToLatitude(0.5 + a[1] / (Math.PI * 2 * Ws)), a[0] *= _.RAD2DEG, a[1] *= _.RAD2DEG), a;
}
function $s(a, e, t) {
  const [s, n] = t.split(".").map((r) => parseInt(r)), i = s === 1 && n < 3 || s < 1;
  Nr(e) && i && ([a[0], a[1]] = [a[1], a[0]]);
}
function _e(a) {
  a[0] *= _.DEG2RAD, a[1] *= _.DEG2RAD;
}
function Gr(a, e) {
  if (!a)
    return null;
  const t = a.getAttribute("CRS") || a.getAttribute("crs") || a.getAttribute("SRS") || "", s = parseFloat(a.getAttribute("minx")), n = parseFloat(a.getAttribute("miny")), i = parseFloat(a.getAttribute("maxx")), r = parseFloat(a.getAttribute("maxy")), o = [s, n], l = [i, r];
  return $s(o, t, e), $s(l, t, e), Ys(o, t), Ys(l, t), _e(o), _e(l), { crs: t, bounds: [...o, ...l] };
}
function jr(a) {
  const e = parseFloat(a.querySelector("westBoundLongitude").textContent), t = parseFloat(a.querySelector("eastBoundLongitude").textContent), s = parseFloat(a.querySelector("southBoundLatitude").textContent), n = parseFloat(a.querySelector("northBoundLatitude").textContent), i = [e, s], r = [t, n];
  return _e(i), _e(r), [...i, ...r];
}
function zr(a) {
  const e = parseFloat(a.getAttribute("minx").textContent), t = parseFloat(a.getAttribute("maxx").textContent), s = parseFloat(a.getAttribute("miny").textContent), n = parseFloat(a.getAttribute("maxy").textContent), i = [e, s], r = [t, n];
  return _e(i), _e(r), [...i, ...r];
}
function Hr(a) {
  const e = a.querySelector("Name").textContent, t = a.querySelector("Title").textContent, s = [...a.querySelectorAll("LegendURL")].map((n) => {
    const i = parseInt(n.getAttribute("width")), r = parseInt(n.getAttribute("height")), o = n.querySelector("Format").textContent, l = n.querySelector("OnlineResource"), c = kt(l);
    return {
      width: i,
      height: r,
      format: o,
      url: c
    };
  });
  return {
    name: e,
    title: t,
    legends: s
  };
}
function Bn(a, e, t = {}) {
  var f, y, g;
  let {
    styles: s = [],
    crs: n = [],
    contentBoundingBox: i = null,
    queryable: r = !1,
    opaque: o = !1
  } = t;
  const l = ((f = a.querySelector(":scope > Name")) == null ? void 0 : f.textContent) || null, c = ((y = a.querySelector(":scope > Title")) == null ? void 0 : y.textContent) || "", u = ((g = a.querySelector(":scope > Abstract")) == null ? void 0 : g.textContent) || "", h = [...a.querySelectorAll(":scope > Keyword")].map((x) => x.textContent), m = [...a.querySelectorAll(":scope > BoundingBox")].map((x) => Gr(x, e));
  n = [
    ...n,
    ...Array.from(a.querySelectorAll("CRS")).map((x) => x.textContent)
  ], s = [
    ...s,
    ...Array.from(a.querySelectorAll(":scope > Style")).map((x) => Hr(x))
  ], a.hasAttribute("queryable") && (r = a.getAttribute("queryable") === "1"), a.hasAttribute("opaque") && (o = a.getAttribute("opaque") === "1"), a.querySelector("EX_GeographicBoundingBox") ? i = jr(a.querySelector("EX_GeographicBoundingBox")) : a.querySelector("LatLonBoundingBox") && (i = zr(a.querySelector("LatLonBoundingBox")));
  const d = Array.from(a.querySelectorAll(":scope > Layer")).map((x) => Bn(x, e, {
    // add
    styles: s,
    crs: n,
    // replace
    contentBoundingBox: i,
    queryable: r,
    opaque: o
  }));
  return {
    name: l,
    title: c,
    abstract: u,
    queryable: r,
    opaque: o,
    keywords: h,
    crs: n,
    boundingBoxes: m,
    contentBoundingBox: i,
    styles: s,
    subLayers: d
  };
}
function qr(a) {
  var e, t, s;
  return {
    name: ((e = a.querySelector("Name")) == null ? void 0 : e.textContent) || "",
    title: ((t = a.querySelector("Title")) == null ? void 0 : t.textContent) || "",
    abstract: ((s = a.querySelector("Abstract")) == null ? void 0 : s.textContent) || "",
    keywords: Array.from(a.querySelectorAll("Keyword")).map((n) => n.textContent),
    maxWidth: parseFloat(a.querySelector("MaxWidth")) || null,
    maxHeight: parseFloat(a.querySelector("MaxHeight")) || null,
    layerLimit: parseFloat(a.querySelector("LayerLimit")) || null
  };
}
function kt(a) {
  return a ? (a.getAttribute("xlink:href") || a.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "").trim() : "";
}
function Wr(a) {
  const e = Array.from(a.querySelectorAll("Format")).map((s) => s.textContent.trim()), t = Array.from(a.querySelectorAll("DCPType")).map((s) => {
    const n = s.querySelector("HTTP"), i = n.querySelector("Get OnlineResource") || n.querySelector("Get > OnlineResource") || n.querySelector("Get"), r = n.querySelector("Post OnlineResource") || n.querySelector("Post > OnlineResource") || n.querySelector("Post"), o = kt(i), l = kt(r);
    return { type: "HTTP", get: o, post: l };
  });
  return { formats: e, dcp: t, href: t[0].get };
}
function Xr(a) {
  const e = {};
  return Array.from(a.querySelectorAll(":scope > *")).forEach((t) => {
    const s = t.localName;
    e[s] = Wr(t);
  }), e;
}
function Dn(a, e = []) {
  return a.forEach((t) => {
    t.name !== null && e.push(t), Dn(t.subLayers, e);
  }), e;
}
class wo extends dn {
  parse(e) {
    const t = new TextDecoder("utf-8").decode(new Uint8Array(e)), s = new DOMParser().parseFromString(t, "text/xml"), i = (s.querySelector("WMS_Capabilities") || s.querySelector("WMT_MS_Capabilities")).getAttribute("version"), r = s.querySelector("Capability"), o = qr(s.querySelector(":scope > Service")), l = Xr(r.querySelector(":scope > Request")), c = Array.from(r.querySelectorAll(":scope > Layer")).map((h) => Bn(h, i)), u = Dn(c);
    return { version: i, service: o, layers: u, request: l };
  }
}
export {
  ho as B,
  io as C,
  Ao as D,
  gi as G,
  fo as I,
  So as L,
  vo as O,
  Bi as Q,
  lo as R,
  Mo as S,
  oo as T,
  ro as U,
  yo as W,
  mo as X,
  ao as a,
  co as b,
  uo as c,
  po as d,
  er as e,
  Qi as f,
  Ki as g,
  go as h,
  xo as i,
  To as j,
  bo as k,
  _o as l,
  Qt as m,
  Co as n,
  Lo as o,
  to as p,
  Si as q,
  so as r,
  no as s,
  Eo as t,
  wo as u
};
//# sourceMappingURL=WMSCapabilitiesLoader-Ca3IzEbJ.js.map
