{"version":3,"file":"WMSCapabilitiesLoader-Ca3IzEbJ.js","sources":["../src/three/plugins/GoogleAttributionsManager.js","../src/three/plugins/GoogleCloudAuthPlugin.js","../src/three/plugins/images/ImageFormatPlugin.js","../src/three/plugins/images/utils/getCartographicToMeterDerivative.js","../src/three/plugins/images/EllipsoidProjectionTilesPlugin.js","../src/three/plugins/images/utils/ProjectionScheme.js","../src/three/plugins/images/utils/DataCache.js","../src/three/plugins/images/utils/TilingScheme.js","../src/three/plugins/images/sources/TiledImageSource.js","../src/three/plugins/images/sources/XYZImageSource.js","../src/three/plugins/images/sources/TMSImageSource.js","../src/three/plugins/images/sources/WMTSImageSource.js","../src/three/plugins/images/sources/WMSImageSource.js","../src/three/plugins/images/EPSGTilesPlugin.js","../src/three/plugins/loaders/QuantizedMeshLoader.js","../src/three/plugins/utilities/GeometryClipper.js","../src/three/plugins/utilities/QuantizedMeshClipper.js","../src/three/plugins/QuantizedMeshPlugin.js","../src/three/plugins/CesiumIonAuthPlugin.js","../src/three/plugins/UpdateOnChangePlugin.js","../src/three/plugins/TileCompressionPlugin.js","../src/three/plugins/gltf/metadata/utilities/ClassPropertyHelpers.js","../src/three/plugins/gltf/metadata/classes/ClassProperty.js","../src/three/plugins/gltf/metadata/classes/PropertySetAccessor.js","../src/three/plugins/gltf/metadata/classes/PropertyAttributeAccessor.js","../src/three/plugins/gltf/metadata/classes/PropertyTableAccessor.js","../src/three/plugins/gltf/metadata/utilities/TextureReadUtility.js","../src/three/plugins/gltf/metadata/utilities/TexCoordUtilities.js","../src/three/plugins/gltf/metadata/classes/PropertyTextureAccessor.js","../src/three/plugins/gltf/metadata/classes/StructuralMetadata.js","../src/three/plugins/gltf/GLTFStructuralMetadataExtension.js","../src/three/plugins/gltf/metadata/classes/MeshFeatures.js","../src/three/plugins/gltf/GLTFMeshFeaturesExtension.js","../src/three/plugins/gltf/GLTFCesiumRTCExtension.js","../src/three/plugins/GLTFExtensionsPlugin.js","../src/three/plugins/ReorientationPlugin.js","../src/three/plugins/UnloadTilesPlugin.js","../src/three/plugins/fade/FadeManager.js","../src/three/plugins/fade/wrapFadeMaterial.js","../src/three/plugins/fade/FadeMaterialManager.js","../src/three/plugins/fade/PassThroughBatchedMesh.js","../src/three/plugins/fade/FadeBatchedMesh.js","../src/three/plugins/fade/TilesFadePlugin.js","../src/three/plugins/batched/ModelViewBatchedMesh.js","../src/three/plugins/batched/ExpandingBatchedMesh.js","../src/three/plugins/batched/utilities.js","../src/three/plugins/batched/BatchedTilesPlugin.js","../src/three/plugins/TileFlatteningPlugin.js","../src/three/plugins/images/overlays/TiledTextureComposer.js","../src/three/plugins/images/overlays/utils.js","../src/three/plugins/images/overlays/wrapOverlaysMaterial.js","../src/three/plugins/images/sources/GeoJSONImageSource.js","../src/three/plugins/images/ImageOverlayPlugin.js","../src/three/plugins/LoadRegionPlugin.js","../src/three/plugins/objects/SphereHelper.js","../src/three/plugins/objects/EllipsoidRegionHelper.js","../src/three/plugins/DebugTilesPlugin.js","../src/three/plugins/images/sources/DeepZoomImageSource.js","../src/three/plugins/images/DeepZoomImagePlugin.js","../src/three/plugins/loaders/WMTSCapabilitiesLoader.js","../src/three/plugins/loaders/WMSCapabilitiesLoader.js"],"sourcesContent":["export class GoogleAttributionsManager {\n\n\tconstructor() {\n\n\t\tthis.creditsCount = {};\n\n\t}\n\n\t_adjustAttributions( line, add ) {\n\n\t\tconst creditsCount = this.creditsCount;\n\t\tconst tokens = line.split( /;/g );\n\t\tfor ( let i = 0, l = tokens.length; i < l; i ++ ) {\n\n\t\t\tconst t = tokens[ i ];\n\t\t\tif ( ! ( t in creditsCount ) ) {\n\n\t\t\t\tcreditsCount[ t ] = 0;\n\n\t\t\t}\n\n\t\t\tcreditsCount[ t ] += add ? 1 : - 1;\n\n\t\t\tif ( creditsCount[ t ] <= 0 ) {\n\n\t\t\t\tdelete creditsCount[ t ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taddAttributions( line ) {\n\n\t\tthis._adjustAttributions( line, true );\n\n\t}\n\n\tremoveAttributions( line ) {\n\n\t\tthis._adjustAttributions( line, false );\n\n\t}\n\n\ttoString() {\n\n\t\t// attribution guidelines: https://developers.google.com/maps/documentation/tile/create-renderer#display-attributions\n\n\t\tconst sortedByCount = Object.entries( this.creditsCount ).sort( ( a, b ) => {\n\n\t\t\tconst countA = a[ 1 ];\n\t\t\tconst countB = b[ 1 ];\n\t\t\treturn countB - countA; // Descending order\n\n\t\t} );\n\n\t\treturn sortedByCount.map( pair => pair[ 0 ] ).join( '; ' );\n\n\t}\n\n}\n","import { GoogleCloudAuth } from '3d-tiles-renderer/core/plugins';\nimport { GoogleAttributionsManager } from './GoogleAttributionsManager.js';\n\nconst TILES_3D_API = 'https://tile.googleapis.com/v1/3dtiles/root.json';\n\nexport class GoogleCloudAuthPlugin {\n\n\tconstructor( {\n\t\tapiToken,\n\t\tsessionOptions = null,\n\t\tautoRefreshToken = false,\n\t\tlogoUrl = null,\n\t\tuseRecommendedSettings = true,\n\t} ) {\n\n\t\tthis.name = 'GOOGLE_CLOUD_AUTH_PLUGIN';\n\n\t\tthis.apiToken = apiToken;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\t\tthis.logoUrl = logoUrl;\n\n\t\tthis.auth = new GoogleCloudAuth( { apiToken, autoRefreshToken, sessionOptions } );\n\t\tthis.tiles = null;\n\n\t\tthis._visibilityChangeCallback = null;\n\t\tthis._attributionsManager = new GoogleAttributionsManager();\n\t\tthis._logoAttribution = {\n\t\t\tvalue: '',\n\t\t\ttype: 'image',\n\t\t\tcollapsible: false,\n\t\t};\n\t\tthis._attribution = {\n\t\t\tvalue: '',\n\t\t\ttype: 'string',\n\t\t\tcollapsible: true,\n\t\t};\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tconst { useRecommendedSettings, auth } = this;\n\n\t\t// reset the tiles in case this plugin was removed and re-added\n\t\ttiles.resetFailedTiles();\n\n\t\tif ( tiles.rootURL == null ) {\n\n\t\t\ttiles.rootURL = TILES_3D_API;\n\n\t\t}\n\n\t\tif ( ! auth.sessionOptions ) {\n\n\t\t\tauth.authURL = tiles.rootURL;\n\n\t\t}\n\n\t\tif ( useRecommendedSettings && ! auth.isMapTilesSession ) {\n\n\t\t\t// This plugin changes below values to be more efficient for the photorealistic tiles\n\t\t\ttiles.errorTarget = 20;\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\n\t\tthis._visibilityChangeCallback = ( { tile, visible } ) => {\n\n\t\t\tconst copyright = tile.cached.metadata?.asset?.copyright || '';\n\t\t\tif ( visible ) {\n\n\t\t\t\tthis._attributionsManager.addAttributions( copyright );\n\n\t\t\t} else {\n\n\t\t\t\tthis._attributionsManager.removeAttributions( copyright );\n\n\t\t\t}\n\n\t\t};\n\n\t\ttiles.addEventListener( 'tile-visibility-change', this._visibilityChangeCallback );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.tiles.visibleTiles.size > 0 ) {\n\n\t\t\tif ( this.logoUrl ) {\n\n\t\t\t\tthis._logoAttribution.value = this.logoUrl;\n\t\t\t\ttarget.push( this._logoAttribution );\n\n\t\t\t}\n\n\t\t\tthis._attribution.value = this._attributionsManager.toString();\n\t\t\ttarget.push( this._attribution );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.tiles.removeEventListener( 'tile-visibility-change', this._visibilityChangeCallback );\n\n\t}\n\n\tasync fetchData( uri, options ) {\n\n\t\treturn this.auth.fetch( uri, options );\n\n\t}\n\n}\n","import { Mesh, MeshBasicMaterial, PlaneGeometry, MathUtils, Vector2 } from 'three';\n\nconst _uv = /* @__PURE__ */ new Vector2();\n\nexport const TILE_X = Symbol( 'TILE_X' );\nexport const TILE_Y = Symbol( 'TILE_Y' );\nexport const TILE_LEVEL = Symbol( 'TILE_LEVEL' );\n\n// Base class for supporting tiled images with a consistent size / resolution per tile\nexport class ImageFormatPlugin {\n\n\tget tiling() {\n\n\t\treturn this.imageSource.tiling;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tpixelSize = null,\n\t\t\tcenter = false,\n\t\t\tuseRecommendedSettings = true,\n\t\t\timageSource = null,\n\t\t} = options;\n\n\t\tthis.priority = - 10;\n\t\tthis.tiles = null;\n\n\t\t// tiling scheme\n\t\tthis.imageSource = imageSource;\n\n\t\t// options\n\t\tthis.pixelSize = pixelSize;\n\t\tthis.center = center;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\n\t\tif ( pixelSize !== null ) {\n\n\t\t\tconsole.warn( 'ImageFormatPlugin: \"pixelSize\" has been deprecated in favor of scaling the tiles root.' );\n\n\t\t}\n\n\t}\n\n\t// Plugin functions\n\tinit( tiles ) {\n\n\t\tif ( this.useRecommendedSettings ) {\n\n\t\t\ttiles.errorTarget = 1;\n\t\t\t// TODO: apply skip traversal settings here once supported, as well, for faster loading\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\n\t\tthis.imageSource.fetchOptions = tiles.fetchOptions;\n\t\tthis.imageSource.fetchData = ( url, options ) => {\n\n\t\t\ttiles.invokeAllPlugins( plugin => url = plugin.preprocessURL ? plugin.preprocessURL( url, null ) : url );\n\t\t\treturn tiles.invokeOnePlugin( plugin => plugin !== this && plugin.fetchData && plugin.fetchData( url, options ) );\n\n\t\t};\n\n\t}\n\n\tasync loadRootTileSet() {\n\n\t\tconst { tiles, imageSource } = this;\n\t\timageSource.url = imageSource.url || tiles.rootURL;\n\t\ttiles.invokeAllPlugins( plugin => imageSource.url = plugin.preprocessURL ? plugin.preprocessURL( imageSource.url, null ) : imageSource.url );\n\t\tawait imageSource.init();\n\n\t\ttiles.rootURL = imageSource.url;\n\t\treturn this.getTileset( imageSource.url );\n\n\t}\n\n\tasync parseToMesh( buffer, tile, extension, uri, abortSignal ) {\n\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Construct texture\n\t\tconst { imageSource } = this;\n\t\tconst tx = tile[ TILE_X ];\n\t\tconst ty = tile[ TILE_Y ];\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst texture = await imageSource.processBufferToTexture( buffer );\n\n\t\t// clean up the texture if it's not going to be used.\n\t\tif ( abortSignal.aborted ) {\n\n\t\t\ttexture.dispose();\n\t\t\ttexture.image.close();\n\t\t\treturn null;\n\n\t\t}\n\n\t\timageSource.setData( tx, ty, level, texture );\n\n\t\t// Construct mesh\n\t\tlet sx = 1, sy = 1;\n\t\tlet x = 0, y = 0, z = 0;\n\n\t\tconst boundingBox = tile.boundingVolume.box;\n\t\tif ( boundingBox ) {\n\n\t\t\t[ x, y, z ] = boundingBox;\n\t\t\tsx = boundingBox[ 3 ];\n\t\t\tsy = boundingBox[ 7 ];\n\n\t\t}\n\n\t\t// adjust the geometry transform itself rather than the mesh because it reduces the artifact errors\n\t\t// when using batched mesh rendering.\n\t\tconst geometry = new PlaneGeometry( 2 * sx, 2 * sy );\n\t\tconst mesh = new Mesh( geometry, new MeshBasicMaterial( { map: texture, transparent: true } ) );\n\t\tmesh.position.set( x, y, z );\n\n\t\tconst tiling = imageSource.tiling;\n\t\tconst uvRange = tiling.getTileContentUVBounds( tx, ty, level );\n\t\tconst { uv } = geometry.attributes;\n\t\tfor ( let i = 0; i < uv.count; i ++ ) {\n\n\t\t\t_uv.fromBufferAttribute( uv, i );\n\t\t\t_uv.x = MathUtils.mapLinear( _uv.x, 0, 1, uvRange[ 0 ], uvRange[ 2 ] );\n\t\t\t_uv.y = MathUtils.mapLinear( _uv.y, 0, 1, uvRange[ 1 ], uvRange[ 3 ] );\n\t\t\tuv.setXY( i, _uv.x, _uv.y );\n\n\t\t}\n\n\t\treturn mesh;\n\n\t}\n\n\tpreprocessNode( tile ) {\n\n\t\t// generate children\n\t\tconst { tiling } = this;\n\t\tconst maxLevel = tiling.maxLevel;\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tif ( level < maxLevel && tile.parent !== null ) {\n\n\t\t\tthis.expandChildren( tile );\n\n\t\t}\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tconst tx = tile[ TILE_X ];\n\t\tconst ty = tile[ TILE_Y ];\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst { imageSource } = this;\n\t\tif ( imageSource.has( tx, ty, level ) ) {\n\n\t\t\t// only dispose of the image data if it hasn't been aborted\n\t\t\timageSource.release( tx, ty, level );\n\n\t\t}\n\n\t}\n\n\t// Local functions\n\tgetTileset( baseUrl ) {\n\n\t\tconst { tiling, tiles } = this;\n\t\tconst minLevel = tiling.minLevel;\n\t\tconst { tileCountX, tileCountY } = tiling.getLevel( minLevel );\n\n\t\t// generate all children for the root\n\t\tconst children = [];\n\t\tfor ( let x = 0; x < tileCountX; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < tileCountY; y ++ ) {\n\n\t\t\t\tconst child = this.createChild( x, y, minLevel );\n\t\t\t\tif ( child !== null ) {\n\n\t\t\t\t\tchildren.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate tile set\n\t\tconst tileset = {\n\t\t\tasset: {\n\t\t\t\tversion: '1.1'\n\t\t\t},\n\t\t\tgeometricError: 1e5,\n\t\t\troot: {\n\t\t\t\trefine: 'REPLACE',\n\t\t\t\tgeometricError: 1e5,\n\t\t\t\tboundingVolume: this.createBoundingVolume( 0, 0, - 1 ),\n\t\t\t\tchildren,\n\n\t\t\t\t[ TILE_LEVEL ]: - 1,\n\t\t\t\t[ TILE_X ]: 0,\n\t\t\t\t[ TILE_Y ]: 0,\n\t\t\t}\n\t\t};\n\n\t\ttiles.preprocessTileSet( tileset, baseUrl );\n\n\t\treturn tileset;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.imageSource.getUrl( x, y, level );\n\n\t}\n\n\tcreateBoundingVolume( x, y, level ) {\n\n\t\tconst { center, pixelSize, tiling } = this;\n\t\tconst { pixelWidth, pixelHeight } = tiling.getLevel( tiling.maxLevel );\n\n\t\t// calculate the world space bounds position from the range\n\t\tconst [ minX, minY, maxX, maxY ] = level === - 1 ? tiling.getContentBounds( true ) : tiling.getTileBounds( x, y, level, true );\n\t\tlet extentsX = ( maxX - minX ) / 2;\n\t\tlet extentsY = ( maxY - minY ) / 2;\n\t\tlet centerX = minX + extentsX;\n\t\tlet centerY = minY + extentsY;\n\t\tif ( center ) {\n\n\t\t\tcenterX -= 0.5;\n\t\t\tcenterY -= 0.5;\n\n\t\t}\n\n\t\t// scale the fields\n\t\tif ( pixelSize ) {\n\n\t\t\tcenterX *= pixelWidth * pixelSize;\n\t\t\textentsX *= pixelWidth * pixelSize;\n\n\t\t\tcenterY *= pixelHeight * pixelSize;\n\t\t\textentsY *= pixelHeight * pixelSize;\n\n\t\t} else {\n\n\t\t\tcenterX *= tiling.aspectRatio;\n\t\t\textentsX *= tiling.aspectRatio;\n\n\t\t}\n\n\n\t\t// return bounding box\n\t\treturn {\n\t\t\tbox: [\n\t\t\t\t// center\n\t\t\t\tcenterX, centerY, 0,\n\n\t\t\t\t// x, y, z half vectors\n\t\t\t\textentsX, 0.0, 0.0,\n\t\t\t\t0.0, extentsY, 0.0,\n\t\t\t\t0.0, 0.0, 0.0,\n\t\t\t],\n\t\t};\n\n\t}\n\n\tcreateChild( x, y, level ) {\n\n\t\tconst { pixelSize, tiling } = this;\n\t\tif ( ! tiling.getTileExists( x, y, level ) ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// the scale ration of the image at this level\n\t\tconst { pixelWidth, pixelHeight } = tiling.getLevel( tiling.maxLevel );\n\t\tconst { pixelWidth: levelWidth, pixelHeight: levelHeight } = tiling.getLevel( level );\n\t\tlet geometricError = Math.max( 1 / levelWidth, 1 / levelHeight );\n\t\tif ( pixelSize ) {\n\n\t\t\tgeometricError *= pixelSize * Math.max( pixelWidth, pixelHeight );\n\n\t\t}\n\n\t\t// Generate the node\n\t\treturn {\n\t\t\trefine: 'REPLACE',\n\t\t\tgeometricError: geometricError,\n\t\t\tboundingVolume: this.createBoundingVolume( x, y, level ),\n\t\t\tcontent: {\n\t\t\t\turi: this.getUrl( x, y, level ),\n\t\t\t},\n\t\t\tchildren: [],\n\n\t\t\t// save the tile params so we can expand later\n\t\t\t[ TILE_X ]: x,\n\t\t\t[ TILE_Y ]: y,\n\t\t\t[ TILE_LEVEL ]: level,\n\t\t};\n\n\t}\n\n\texpandChildren( tile ) {\n\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst x = tile[ TILE_X ];\n\t\tconst y = tile[ TILE_Y ];\n\n\t\tfor ( let cx = 0; cx < 2; cx ++ ) {\n\n\t\t\tfor ( let cy = 0; cy < 2; cy ++ ) {\n\n\t\t\t\tconst child = this.createChild( 2 * x + cx, 2 * y + cy, level + 1 );\n\t\t\t\tif ( child ) {\n\n\t\t\t\t\ttile.children.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\n\nexport function getCartographicToMeterDerivative( ellipsoid, lat, lon ) {\n\n\tconst EPS = 1e-5;\n\tconst lonp = lon + EPS;\n\tlet latp = lat + EPS;\n\tif ( Math.abs( latp ) > Math.PI / 2 ) {\n\n\t\tlatp = latp - EPS;\n\n\t}\n\n\tellipsoid.getCartographicToPosition( lat, lon, 0, _v0 );\n\n\tellipsoid.getCartographicToPosition( latp, lon, 0, _v1 );\n\tconst dy = _v0.distanceTo( _v1 ) / EPS;\n\n\tellipsoid.getCartographicToPosition( lat, lonp, 0, _v1 );\n\tconst dx = _v0.distanceTo( _v1 ) / EPS;\n\n\treturn [ dx, dy ];\n\n}\n","import { ImageFormatPlugin, TILE_LEVEL, TILE_X, TILE_Y } from './ImageFormatPlugin.js';\nimport { MathUtils, PlaneGeometry, Sphere, Vector2, Vector3 } from 'three';\nimport { getCartographicToMeterDerivative } from './utils/getCartographicToMeterDerivative.js';\n\nconst MIN_LON_VERTS = 30;\nconst MIN_LAT_VERTS = 15;\n\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _uv = /* @__PURE__ */ new Vector2();\nconst _sphere = /* @__PURE__ */ new Sphere();\n\nexport class EllipsoidProjectionTilesPlugin extends ImageFormatPlugin {\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tshape = 'planar',\n\t\t\tendCaps = true,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\t// options\n\t\tthis.shape = shape;\n\t\tthis.endCaps = endCaps;\n\n\t}\n\n\t// override the parse to mesh logic to support a region mesh\n\tasync parseToMesh( buffer, tile, ...args ) {\n\n\t\tconst mesh = await super.parseToMesh( buffer, tile, ...args );\n\n\t\t// if displaying the tiles as an ellipsoid\n\t\tconst { shape, projection, tiles, tiling } = this;\n\t\tif ( shape === 'ellipsoid' ) {\n\n\t\t\tconst ellipsoid = tiles.ellipsoid;\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\t// new geometry\n\t\t\t// default to a minimum number of vertices per degree on each axis\n\t\t\tconst [ west, south, east, north ] = tile.boundingVolume.region;\n\t\t\tconst latVerts = Math.ceil( ( north - south ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst lonVerts = Math.ceil( ( east - west ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst yVerts = Math.max( MIN_LAT_VERTS, latVerts );\n\t\t\tconst xVerts = Math.max( MIN_LON_VERTS, lonVerts );\n\t\t\tconst geometry = new PlaneGeometry( 1, 1, xVerts, yVerts );\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true, true );\n\t\t\tconst uvRange = tiling.getTileContentUVBounds( x, y, level );\n\n\t\t\t// adjust the geometry to position it at the region\n\t\t\tconst { position, normal, uv } = geometry.attributes;\n\t\t\tconst vertCount = position.count;\n\t\t\ttile.cached.boundingVolume.getSphere( _sphere );\n\t\t\tfor ( let i = 0; i < vertCount; i ++ ) {\n\n\t\t\t\t// retrieve attributes\n\t\t\t\t_pos.fromBufferAttribute( position, i );\n\t\t\t\t_uv.fromBufferAttribute( uv, i );\n\n\t\t\t\t// convert the plane position to lat / lon\n\t\t\t\tconst lon = projection.convertProjectionToLongitude( MathUtils.mapLinear( _uv.x, 0, 1, minU, maxU ) );\n\t\t\t\tlet lat = projection.convertProjectionToLatitude( MathUtils.mapLinear( _uv.y, 0, 1, minV, maxV ) );\n\n\t\t\t\t// snap the edges to the poles if using mercator projection and end caps are enabled\n\t\t\t\tif ( projection.isMercator && this.endCaps ) {\n\n\t\t\t\t\tif ( maxV === 1 && _uv.y === 1 ) {\n\n\t\t\t\t\t\tlat = Math.PI / 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( minV === 0 && _uv.y === 0 ) {\n\n\t\t\t\t\t\tlat = - Math.PI / 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// ensure we have an edge loop positioned at the mercator limit to avoid UV distortion\n\t\t\t\t// as much as possible at low LoDs.\n\t\t\t\tif ( projection.isMercator && _uv.y !== 0 && _uv.y !== 1 ) {\n\n\t\t\t\t\tconst latLimit = projection.convertProjectionToLatitude( 1 );\n\t\t\t\t\tconst vStep = 1 / yVerts;\n\n\t\t\t\t\tconst prevLat = MathUtils.mapLinear( _uv.y - vStep, 0, 1, south, north );\n\t\t\t\t\tconst nextLat = MathUtils.mapLinear( _uv.y + vStep, 0, 1, south, north );\n\t\t\t\t\tif ( lat > latLimit && prevLat < latLimit ) {\n\n\t\t\t\t\t\tlat = latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( lat < - latLimit && nextLat > - latLimit ) {\n\n\t\t\t\t\t\tlat = - latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// get the position and normal\n\t\t\t\tellipsoid.getCartographicToPosition( lat, lon, 0, _pos ).sub( _sphere.center );\n\t\t\t\tellipsoid.getCartographicToNormal( lat, lon, _norm );\n\n\t\t\t\t// map from the uvs for the tile into the uv range\n\t\t\t\tconst u = MathUtils.mapLinear( projection.convertLongitudeToProjection( lon ), minU, maxU, uvRange[ 0 ], uvRange[ 2 ] );\n\t\t\t\tconst v = MathUtils.mapLinear( projection.convertLatitudeToProjection( lat ), minV, maxV, uvRange[ 1 ], uvRange[ 3 ] );\n\n\t\t\t\t// update the geometry\n\t\t\t\tuv.setXY( i, u, v );\n\t\t\t\tposition.setXYZ( i, ..._pos );\n\t\t\t\tnormal.setXYZ( i, ..._norm );\n\n\t\t\t}\n\n\t\t\tmesh.geometry = geometry;\n\t\t\tmesh.position.copy( _sphere.center );\n\n\t\t}\n\n\t\treturn mesh;\n\n\t}\n\n\tcreateBoundingVolume( x, y, level ) {\n\n\t\tif ( this.shape === 'ellipsoid' ) {\n\n\t\t\tconst { tiling, endCaps } = this;\n\t\t\tconst isRoot = level === - 1;\n\t\t\tconst normalizedBounds = isRoot ? tiling.getContentBounds( true ) : tiling.getTileBounds( x, y, level, true, true );\n\t\t\tconst cartBounds = isRoot ? tiling.getContentBounds() : tiling.getTileBounds( x, y, level, false, true );\n\n\t\t\tif ( endCaps ) {\n\n\t\t\t\t// if the north side is at the edge\n\t\t\t\tif ( normalizedBounds[ 3 ] === 1 ) {\n\n\t\t\t\t\tcartBounds[ 3 ] = Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t\t// if the south side is at the edge\n\t\t\t\tif ( normalizedBounds[ 1 ] === 0 ) {\n\n\t\t\t\t\tcartBounds[ 1 ] = - Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tregion: [ ...cartBounds, - 1, 1 ],\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn super.createBoundingVolume( x, y, level );\n\n\t\t}\n\n\t}\n\n\tcreateChild( ...args ) {\n\n\t\tconst tile = super.createChild( ...args );\n\n\t\tconst { shape, projection, tiling } = this;\n\t\tif ( tile && shape === 'ellipsoid' ) {\n\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\t// if this is the root node then skip calculating the geometric error\n\t\t\tif ( level === - 1 ) {\n\n\t\t\t\ttile.geometricError = 1e50;\n\t\t\t\treturn parent;\n\n\t\t\t}\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true );\n\t\t\tconst { tilePixelWidth, tilePixelHeight } = tiling.getLevel( level );\n\n\t\t\t// one pixel width in uv space\n\t\t\tconst tileUWidth = ( maxU - minU ) / tilePixelWidth;\n\t\t\tconst tileVWidth = ( maxV - minV ) / tilePixelHeight;\n\n\t\t\t// calculate the region ranges\n\t\t\tconst [ /* west */, south, east, north ] = tiling.getTileBounds( x, y, level );\n\n\t\t\t// calculate the changes in lat / lon at the given point\n\t\t\t// find the most bowed point of the latitude range since the amount that latitude changes is\n\t\t\t// dependent on the Y value of the image\n\t\t\tconst midLat = ( south > 0 ) !== ( north > 0 ) ? 0 : Math.min( Math.abs( south ), Math.abs( north ) );\n\t\t\tconst midV = projection.convertLatitudeToProjection( midLat );\n\t\t\tconst lonFactor = projection.getLongitudeDerivativeAtProjection( minU );\n\t\t\tconst latFactor = projection.getLatitudeDerivativeAtProjection( midV );\n\n\t\t\t// calculate the size of a pixel on the surface\n\t\t\tconst [ xDeriv, yDeriv ] = getCartographicToMeterDerivative( this.tiles.ellipsoid, midLat, east );\n\t\t\tconst projectedPixelWidth = Math.max( tileUWidth * lonFactor * xDeriv, tileVWidth * latFactor * yDeriv );\n\t\t\ttile.geometricError = projectedPixelWidth;\n\n\t\t}\n\n\t\treturn tile;\n\n\t}\n\n}\n\n","import { MathUtils } from 'three';\n\n// Class for storing and querying a certain projection scheme for an image and converting\n// between the [0, 1] image range to cartographic longitude / latitude values.\nexport class ProjectionScheme {\n\n\tget isMercator() {\n\n\t\treturn this.scheme === 'EPSG:3857';\n\n\t}\n\n\tconstructor( scheme = 'EPSG:4326' ) {\n\n\t\tthis.scheme = scheme;\n\t\tthis.tileCountX = 1;\n\t\tthis.tileCountY = 1;\n\n\t\tthis.setScheme( scheme );\n\n\t}\n\n\tsetScheme( scheme ) {\n\n\t\tthis.scheme = scheme;\n\t\tswitch ( scheme ) {\n\n\t\t\t// equirect\n\t\t\tcase 'CRS:84':\n\t\t\tcase 'EPSG:4326':\n\t\t\t\tthis.tileCountX = 2;\n\t\t\t\tthis.tileCountY = 1;\n\t\t\t\tbreak;\n\n\t\t\t// mercator\n\t\t\tcase 'EPSG:3857':\n\t\t\t\tthis.tileCountX = 1;\n\t\t\t\tthis.tileCountY = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( `ProjectionScheme: Unknown projection scheme \"${ scheme }\"` );\n\n\t\t}\n\n\t}\n\n\tconvertProjectionToLatitude( v ) {\n\n\t\tif ( this.isMercator ) {\n\n\t\t\t// https://gis.stackexchange.com/questions/447421/convert-a-point-on-a-flat-2d-web-mercator-map-image-to-a-coordinate\n\t\t\tconst ratio = MathUtils.mapLinear( v, 0, 1, - 1, 1 );\n\t\t\treturn 2 * Math.atan( Math.exp( ratio * Math.PI ) ) - Math.PI / 2;\n\n\t\t} else {\n\n\t\t\treturn MathUtils.mapLinear( v, 0, 1, - Math.PI / 2, Math.PI / 2 );\n\n\t\t}\n\n\t}\n\n\tconvertProjectionToLongitude( v ) {\n\n\t\treturn MathUtils.mapLinear( v, 0, 1, - Math.PI, Math.PI );\n\n\t}\n\n\tconvertLatitudeToProjection( lat ) {\n\n\t\tif ( this.isMercator ) {\n\n\t\t\t// https://stackoverflow.com/questions/14329691/convert-latitude-longitude-point-to-a-pixels-x-y-on-mercator-projection\n\t\t\tconst mercatorN = Math.log( Math.tan( ( Math.PI / 4 ) + ( lat / 2 ) ) );\n\t\t\treturn ( 1 / 2 ) + ( 1 * mercatorN / ( 2 * Math.PI ) );\n\n\t\t} else {\n\n\t\t\treturn MathUtils.mapLinear( lat, - Math.PI / 2, Math.PI / 2, 0, 1 );\n\n\t\t}\n\n\t}\n\n\tconvertLongitudeToProjection( lon ) {\n\n\t\treturn ( lon + Math.PI ) / ( 2 * Math.PI );\n\n\t}\n\n\tgetLongitudeDerivativeAtProjection( value ) {\n\n\t\treturn 2 * Math.PI;\n\n\t}\n\n\tgetLatitudeDerivativeAtProjection( value ) {\n\n\t\tconst EPS = 1e-5;\n\t\tlet yp = value - EPS;\n\t\tif ( yp < 0 ) {\n\n\t\t\typ = value + EPS;\n\n\t\t}\n\n\t\tif ( this.isMercator ) {\n\n\t\t\t// TODO: why is this 2 * Math.PI rather than Math.PI?\n\t\t\treturn Math.abs( this.convertProjectionToLatitude( value ) - this.convertProjectionToLatitude( yp ) ) / EPS;\n\n\t\t} else {\n\n\t\t\treturn Math.PI;\n\n\t\t}\n\n\t}\n\n\tgetBounds() {\n\n\t\treturn [\n\t\t\tthis.convertProjectionToLongitude( 0 ), this.convertProjectionToLatitude( 0 ),\n\t\t\tthis.convertProjectionToLongitude( 1 ), this.convertProjectionToLatitude( 1 ),\n\t\t];\n\n\t}\n\n}\n","function hash( ...args ) {\n\n\treturn args.join( '_' );\n\n}\n\n// class for retrieving and locking data being requested\n// \"fetchItem\" and \"disposeItem\" should be implemented\nexport class DataCache {\n\n\tconstructor() {\n\n\t\tthis.cache = {};\n\t\tthis.count = 0;\n\t\tthis.cachedBytes = 0;\n\t\tthis.active = 0;\n\n\t}\n\n\t// overridable\n\tfetchItem() {}\n\tdisposeItem() {}\n\tgetMemoryUsage( item ) {\n\n\t\treturn 0;\n\n\t}\n\n\t// sets the data in the cache explicitly without need to load\n\tsetData( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst data = args.pop();\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tthrow new Error( `DataCache: \"${ key }\" is already present.` );\n\n\t\t} else {\n\n\t\t\tthis.cache[ key ] = {\n\t\t\t\tabortController: new AbortController(),\n\t\t\t\tresult: data,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: this.getMemoryUsage( data ),\n\t\t\t};\n\t\t\tthis.count ++;\n\t\t\tthis.cachedBytes += this.cache[ key ].bytes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t// fetches the associated data if it doesn't exist and increments the lock counter\n\tlock( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tcache[ key ].count ++;\n\n\t\t} else {\n\n\t\t\tconst abortController = new AbortController();\n\t\t\tconst info = {\n\t\t\t\tabortController,\n\t\t\t\tresult: null,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: 0,\n\t\t\t};\n\n\t\t\tthis.active ++;\n\t\t\tinfo.result = this.fetchItem( args, abortController.signal );\n\t\t\tif ( info.result instanceof Promise ) {\n\n\t\t\t\tinfo.result.then( res => {\n\n\t\t\t\t\tinfo.result = res;\n\t\t\t\t\tinfo.bytes = this.getMemoryUsage( res );\n\t\t\t\t\tthis.cachedBytes += info.bytes;\n\t\t\t\t\treturn res;\n\n\t\t\t\t} ).finally( () => {\n\n\t\t\t\t\tthis.active --;\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\t// error logging and handling can be handled elsewhere\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tthis.active --;\n\t\t\t\tinfo.bytes = this.getMemoryUsage( info.result );\n\t\t\t\tthis.cachedBytes += info.bytes;\n\n\t\t\t}\n\n\t\t\tthis.cache[ key ] = info;\n\t\t\tthis.count ++;\n\n\t\t}\n\n\t\treturn cache[ key ].result;\n\n\t}\n\n\t// decrements the lock counter for the item and deletes the item if it has reached zero\n\trelease( ...args ) {\n\n\t\tconst key = hash( ...args );\n\t\tthis.releaseViaFullKey( key );\n\n\t}\n\n\t// get the loaded item\n\tget( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\treturn cache[ key ].result;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\thas( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\treturn key in cache;\n\n\t}\n\n\t// dispose all items\n\tdispose() {\n\n\t\tconst { cache } = this;\n\t\tfor ( const key in cache ) {\n\n\t\t\tconst { abortController } = cache[ key ];\n\t\t\tabortController.abort();\n\n\t\t\tthis.releaseViaFullKey( key, true );\n\n\t\t}\n\n\t\tthis.cache = {};\n\n\t}\n\n\t// releases an item with an optional force flag\n\treleaseViaFullKey( key, force = false ) {\n\n\t\tconst { cache } = this;\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\t// decrement the lock\n\t\t\tconst info = cache[ key ];\n\t\t\tinfo.count --;\n\n\t\t\t// if the item is no longer being used\n\t\t\tif ( info.count === 0 || force ) {\n\n\t\t\t\tconst disposeCallback = () => {\n\n\t\t\t\t\t// if the object isn't in the cache anymore then exit early because it's been disposed elsewhere\n\t\t\t\t\tif ( cache[ key ] !== info ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// abort any loads\n\t\t\t\t\tconst { result, abortController } = info;\n\t\t\t\t\tabortController.abort();\n\n\t\t\t\t\t// dispose of the object even if it still is in progress\n\t\t\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\t\t\t// \"disposeItem\" will throw potentially if fetch, etc are cancelled using the abort signal\n\t\t\t\t\t\tresult.then( item => {\n\n\t\t\t\t\t\t\tthis.disposeItem( item );\n\t\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t\t} ).catch( () => {} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disposeItem( result );\n\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t};\n\n\t\t\t\tif ( force ) {\n\n\t\t\t\t\t// if we're forcing disposal then dispose immediately\n\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// queue for disposal in a frame here - we need to make sure we're not disposing of something twice\n\t\t\t\t\t// this can get called multiple times in a row to increment then decrement again.\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\tif ( info.count === 0 ) {\n\n\t\t\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tthrow new Error( 'DataCache: Attempting to release key that does not exist' );\n\n\t}\n\n}\n","import { MathUtils } from 'three';\n\nfunction doBoundsIntersect( a, b ) {\n\n\tconst [ aMinX, aMinY, aMaxX, aMaxY ] = a;\n\tconst [ bMinX, bMinY, bMaxX, bMaxY ] = b;\n\n\treturn ! ( aMinX >= bMaxX || aMaxX <= bMinX || aMinY >= bMaxY || aMaxY <= bMinY );\n\n}\n\n// Class for storing and querying a tiling scheme including a bounds, origin, and negative tile indices.\n// Assumes that tiles are split into four child tiles at each level.\n\n// Projection Bounds: The full extent of content representable by the projection.\n// Content Bounds: The range within the content bounds contains relevant, loadable, and renderable data.\n// Tile Bounds: The per-layer extent covered by the tiles to be loaded. This range may be larger than\n// both the projection and content bounds.\nexport class TilingScheme {\n\n\tget levelCount() {\n\n\t\treturn this._levels.length;\n\n\t}\n\n\tget maxLevel() {\n\n\t\treturn this.levelCount - 1;\n\n\t}\n\n\tget minLevel() {\n\n\t\tconst levels = this._levels;\n\t\tfor ( let i = 0; i < levels.length; i ++ ) {\n\n\t\t\tif ( levels[ i ] !== null ) {\n\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t// prioritize user-set bounds over projection bounds if present\n\tget contentBounds() {\n\n\t\treturn this._contentBounds ?? this.projection?.getBounds() ?? [ 0, 0, 1, 1 ];\n\n\t}\n\n\tget aspectRatio() {\n\n\t\tconst { pixelWidth, pixelHeight } = this.getLevel( this.maxLevel );\n\t\treturn pixelWidth / pixelHeight;\n\n\t}\n\n\tconstructor() {\n\n\t\tthis.flipY = false;\n\t\tthis.pixelOverlap = 0;\n\n\t\t// The origin and bounds\n\t\tthis._contentBounds = null;\n\t\tthis.projection = null;\n\n\t\tthis._levels = [];\n\n\t}\n\n\t// build the zoom levels\n\tsetLevel( level, options = {} ) {\n\n\t\tconst levels = this._levels;\n\t\twhile ( levels.length < level ) {\n\n\t\t\tlevels.push( null );\n\n\t\t}\n\n\t\tconst {\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t\ttileCountX = 2 ** level,\n\t\t\ttileCountY = 2 ** level,\n\t\t\ttileBounds = null,\n\t\t} = options;\n\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * tileCountX,\n\t\t\tpixelHeight = tilePixelHeight * tileCountY,\n\t\t} = options;\n\n\t\tlevels[ level ] = {\n\t\t\t// The pixel resolution of each tile.\n\t\t\ttilePixelWidth,\n\t\t\ttilePixelHeight,\n\n\t\t\t// The total pixel resolution of the final image at this level. These numbers\n\t\t\t// may not be a round multiple of the tile width.\n\t\t\tpixelWidth,\n\t\t\tpixelHeight,\n\n\t\t\t// Or the total number of tiles that can be loaded at this level.\n\t\t\ttileCountX,\n\t\t\ttileCountY,\n\n\t\t\t// The bounds covered by the extent of the tiles at this loaded. The actual content covered by the overall tile set\n\t\t\t// may be a subset of this range (eg there may be unused space).\n\t\t\ttileBounds,\n\t\t};\n\n\t}\n\n\tgenerateLevels( levels, rootTileX, rootTileY, options = {} ) {\n\n\t\tconst {\n\t\t\tminLevel = 0,\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t} = options;\n\n\t\tconst maxLevel = levels - 1;\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * rootTileX * ( 2 ** maxLevel ),\n\t\t\tpixelHeight = tilePixelHeight * rootTileY * ( 2 ** maxLevel ),\n\t\t} = options;\n\t\tfor ( let level = minLevel; level < levels; level ++ ) {\n\n\t\t\tconst invLevel = levels - level - 1;\n\t\t\tconst levelPixelWidth = Math.ceil( pixelWidth * ( 2 ** - invLevel ) );\n\t\t\tconst levelPixelHeight = Math.ceil( pixelHeight * ( 2 ** - invLevel ) );\n\t\t\tconst tileCountX = Math.ceil( levelPixelWidth / tilePixelWidth );\n\t\t\tconst tileCountY = Math.ceil( levelPixelHeight / tilePixelHeight );\n\n\t\t\tthis.setLevel( level, {\n\t\t\t\ttilePixelWidth,\n\t\t\t\ttilePixelHeight,\n\t\t\t\tpixelWidth: levelPixelWidth,\n\t\t\t\tpixelHeight: levelPixelHeight,\n\t\t\t\ttileCountX,\n\t\t\t\ttileCountY,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tgetLevel( level ) {\n\n\t\treturn this._levels[ level ];\n\n\t}\n\n\t// bounds representing the contentful region of the image\n\tsetContentBounds( minX, minY, maxX, maxY ) {\n\n\t\tthis._contentBounds = [ minX, minY, maxX, maxY ];\n\n\t}\n\n\tsetProjection( projection ) {\n\n\t\tthis.projection = projection;\n\n\t}\n\n\t// query functions\n\tgetTileAtPoint( bx, by, level, normalized = false ) {\n\n\t\tconst { flipY } = this;\n\t\tconst { tileCountX, tileCountY, tileBounds } = this.getLevel( level );\n\t\tconst xStride = 1 / tileCountX;\n\t\tconst yStride = 1 / tileCountY;\n\n\t\tif ( ! normalized ) {\n\n\t\t\t[ bx, by ] = this.toNormalizedPoint( bx, by );\n\n\t\t}\n\n\t\tif ( tileBounds ) {\n\n\t\t\tconst normalizedBounds = this.toNormalizedRange( tileBounds );\n\t\t\tbx = MathUtils.mapLinear( bx, normalizedBounds[ 0 ], normalizedBounds[ 2 ], 0, 1 );\n\t\t\tby = MathUtils.mapLinear( by, normalizedBounds[ 1 ], normalizedBounds[ 3 ], 0, 1 );\n\n\t\t}\n\n\t\tconst tx = Math.floor( bx / xStride );\n\t\tlet ty = Math.floor( by / yStride );\n\n\t\tif ( flipY ) {\n\n\t\t\tty = tileCountY - 1 - ty;\n\n\t\t}\n\n\t\treturn [ tx, ty ];\n\n\t}\n\n\tgetTilesInRange( minX, minY, maxX, maxY, level, normalized = false ) {\n\n\t\t// check if the range is outside the content bounds\n\t\tconst range = [ minX, minY, maxX, maxY ];\n\t\tconst contentBounds = this.getContentBounds( normalized );\n\t\tlet tileBounds = this.getLevel( level ).tileBounds;\n\t\tif ( ! doBoundsIntersect( range, contentBounds ) ) {\n\n\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t}\n\n\t\t// check if the range is outside the tile bounds\n\t\tif ( tileBounds ) {\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ttileBounds = this.toNormalizedRange( tileBounds );\n\n\t\t\t}\n\n\t\t\tif ( ! doBoundsIntersect( range, contentBounds ) ) {\n\n\t\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst [ clampedMinX, clampedMinY, clampedMaxX, clampedMaxY ] = this.clampToContentBounds( range, normalized );\n\t\tconst minTile = this.getTileAtPoint( clampedMinX, clampedMinY, level, normalized );\n\t\tconst maxTile = this.getTileAtPoint( clampedMaxX, clampedMaxY, level, normalized );\n\n\t\tif ( this.flipY ) {\n\n\t\t\t[ minTile[ 1 ], maxTile[ 1 ] ] = [ maxTile[ 1 ], minTile[ 1 ] ];\n\n\t\t}\n\n\t\tconst { tileCountX, tileCountY } = this.getLevel( level );\n\t\tconst [ minTileX, minTileY ] = minTile;\n\t\tconst [ maxTileX, maxTileY ] = maxTile;\n\n\t\tif ( maxTileX < 0 || maxTileY < 0 || minTileX >= tileCountX || minTileY >= tileCountY ) {\n\n\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t}\n\n\t\treturn [\n\t\t\tMathUtils.clamp( minTileX, 0, tileCountX - 1 ),\n\t\t\tMathUtils.clamp( minTileY, 0, tileCountY - 1 ),\n\t\t\tMathUtils.clamp( maxTileX, 0, tileCountX - 1 ),\n\t\t\tMathUtils.clamp( maxTileY, 0, tileCountY - 1 ),\n\t\t];\n\n\t}\n\n\tgetTileExists( x, y, level ) {\n\n\t\tconst [ rminx, rminy, rmaxx, rmaxy ] = this.contentBounds;\n\t\tconst [ tminx, tminy, tmaxx, tmaxy ] = this.getTileBounds( x, y, level );\n\t\tconst isDegenerate = tminx >= tmaxx || tminy >= tmaxy;\n\n\t\t// TODO: is supporting \"just touch\" correct?\n\t\treturn ! isDegenerate && tminx <= rmaxx && tminy <= rmaxy && tmaxx >= rminx && tmaxy >= rminy;\n\n\t}\n\n\tgetContentBounds( normalized = false ) {\n\n\t\tconst { projection } = this;\n\t\tconst bounds = [ ...this.contentBounds ];\n\t\tif ( projection && normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertLongitudeToProjection( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertLatitudeToProjection( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertLongitudeToProjection( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertLatitudeToProjection( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\t// returns the UV range associated with the content in the given tile\n\tgetTileContentUVBounds( x, y, level ) {\n\n\t\tconst [ minU, minV, maxU, maxV ] = this.getTileBounds( x, y, level, true, true );\n\t\tconst [ fullMinU, fullMinV, fullMaxU, fullMaxV ] = this.getTileBounds( x, y, level, true, false );\n\t\treturn [\n\t\t\tMathUtils.mapLinear( minU, fullMinU, fullMaxU, 0, 1 ),\n\t\t\tMathUtils.mapLinear( minV, fullMinV, fullMaxV, 0, 1 ),\n\t\t\tMathUtils.mapLinear( maxU, fullMinU, fullMaxU, 0, 1 ),\n\t\t\tMathUtils.mapLinear( maxV, fullMinV, fullMaxV, 0, 1 ),\n\t\t];\n\n\t}\n\n\tgetTileBounds( x, y, level, normalized = false, clampToProjection = true ) {\n\n\t\tconst { flipY, pixelOverlap, projection } = this;\n\t\tconst { tilePixelWidth, tilePixelHeight, pixelWidth, pixelHeight, tileBounds } = this.getLevel( level );\n\n\t\tlet tileLeft = tilePixelWidth * x - pixelOverlap;\n\t\tlet tileTop = tilePixelHeight * y - pixelOverlap;\n\t\tlet tileRight = tileLeft + tilePixelWidth + pixelOverlap * 2;\n\t\tlet tileBottom = tileTop + tilePixelHeight + pixelOverlap * 2;\n\n\t\t// clamp\n\t\ttileLeft = Math.max( tileLeft, 0 );\n\t\ttileTop = Math.max( tileTop, 0 );\n\t\ttileRight = Math.min( tileRight, pixelWidth );\n\t\ttileBottom = Math.min( tileBottom, pixelHeight );\n\n\t\t// normalized\n\t\ttileLeft = tileLeft / pixelWidth;\n\t\ttileRight = tileRight / pixelWidth;\n\t\ttileTop = tileTop / pixelHeight;\n\t\ttileBottom = tileBottom / pixelHeight;\n\n\t\t// invert y\n\t\tif ( flipY ) {\n\n\t\t\tconst extents = ( tileBottom - tileTop ) / 2;\n\t\t\tconst centerY = ( tileTop + tileBottom ) / 2;\n\t\t\tconst invCenterY = 1.0 - centerY;\n\n\t\t\ttileTop = invCenterY - extents;\n\t\t\ttileBottom = invCenterY + extents;\n\n\t\t}\n\n\t\tlet bounds = [ tileLeft, tileTop, tileRight, tileBottom ];\n\t\tif ( tileBounds ) {\n\n\t\t\tconst normBounds = this.toNormalizedRange( tileBounds );\n\t\t\tbounds[ 0 ] = MathUtils.mapLinear( bounds[ 0 ], 0, 1, normBounds[ 0 ], normBounds[ 2 ] );\n\t\t\tbounds[ 2 ] = MathUtils.mapLinear( bounds[ 2 ], 0, 1, normBounds[ 0 ], normBounds[ 2 ] );\n\t\t\tbounds[ 1 ] = MathUtils.mapLinear( bounds[ 1 ], 0, 1, normBounds[ 1 ], normBounds[ 3 ] );\n\t\t\tbounds[ 3 ] = MathUtils.mapLinear( bounds[ 3 ], 0, 1, normBounds[ 1 ], normBounds[ 3 ] );\n\n\t\t}\n\n\t\tif ( clampToProjection ) {\n\n\t\t\tbounds = this.clampToProjectionBounds( bounds, true );\n\n\t\t}\n\n\t\tif ( projection && ! normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertProjectionToLongitude( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertProjectionToLatitude( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertProjectionToLongitude( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertProjectionToLatitude( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\ttoNormalizedPoint( x, y ) {\n\n\t\tconst { projection } = this;\n\t\tconst result = [ x, y ];\n\t\tif ( this.projection ) {\n\n\t\t\tresult[ 0 ] = projection.convertLongitudeToProjection( result[ 0 ] );\n\t\t\tresult[ 1 ] = projection.convertLatitudeToProjection( result[ 1 ] );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\ttoNormalizedRange( range ) {\n\n\t\treturn [\n\t\t\t...this.toNormalizedPoint( range[ 0 ], range[ 1 ] ),\n\t\t\t...this.toNormalizedPoint( range[ 2 ], range[ 3 ] ),\n\t\t];\n\n\t}\n\n\ttoCartographicPoint( x, y ) {\n\n\t\tconst { projection } = this;\n\t\tconst result = [ x, y ];\n\t\tif ( this.projection ) {\n\n\t\t\tresult[ 0 ] = projection.convertProjectionToLongitude( result[ 0 ] );\n\t\t\tresult[ 1 ] = projection.convertProjectionToLatitude( result[ 1 ] );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'TilingScheme: Projection not available.' );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\ttoCartographicRange( range ) {\n\n\t\treturn [\n\t\t\t...this.toCartographicPoint( range[ 0 ], range[ 1 ] ),\n\t\t\t...this.toCartographicPoint( range[ 2 ], range[ 3 ] ),\n\t\t];\n\n\t}\n\n\tclampToContentBounds( range, normalized = false ) {\n\n\t\tconst result = [ ...range ];\n\t\tconst [ minX, minY, maxX, maxY ] = this.getContentBounds( normalized );\n\t\tresult[ 0 ] = MathUtils.clamp( result[ 0 ], minX, maxX );\n\t\tresult[ 1 ] = MathUtils.clamp( result[ 1 ], minY, maxY );\n\t\tresult[ 2 ] = MathUtils.clamp( result[ 2 ], minX, maxX );\n\t\tresult[ 3 ] = MathUtils.clamp( result[ 3 ], minY, maxY );\n\n\t\treturn result;\n\n\t}\n\n\tclampToProjectionBounds( range, normalized = false ) {\n\n\t\tconst result = [ ...range ];\n\t\tconst { projection } = this;\n\t\tlet clampBounds;\n\n\t\tif ( normalized || ! projection ) {\n\n\t\t\tclampBounds = [ 0, 0, 1, 1 ];\n\n\t\t} else {\n\n\t\t\tclampBounds = projection.getBounds();\n\n\t\t}\n\n\t\tconst [ minX, minY, maxX, maxY ] = clampBounds;\n\t\tresult[ 0 ] = MathUtils.clamp( result[ 0 ], minX, maxX );\n\t\tresult[ 1 ] = MathUtils.clamp( result[ 1 ], minY, maxY );\n\t\tresult[ 2 ] = MathUtils.clamp( result[ 2 ], minX, maxX );\n\t\tresult[ 3 ] = MathUtils.clamp( result[ 3 ], minY, maxY );\n\n\t\treturn result;\n\n\t}\n\n}\n\n","import { DataCache } from '../utils/DataCache.js';\nimport { TilingScheme } from '../utils/TilingScheme.js';\nimport { SRGBColorSpace, Texture, TextureUtils } from 'three';\n\n// TODO: support queries for detail at level - ie projected pixel size for geometric error mapping\n// Goes here or in \"TilingScheme\"?\nexport class TiledImageSource extends DataCache {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\tfetchOptions = {}\n\t\t} = options;\n\n\t\tthis.tiling = new TilingScheme();\n\t\tthis.fetchOptions = fetchOptions;\n\t\tthis.fetchData = ( ...args ) => fetch( ...args );\n\n\t}\n\n\t// async function for initializing the tiled image set\n\tinit() {}\n\n\t// helper for processing the buffer into a texture\n\tasync processBufferToTexture( buffer ) {\n\n\t\tconst blob = new Blob( [ buffer ] );\n\t\tconst imageBitmap = await createImageBitmap( blob, {\n\t\t\tpremultiplyAlpha: 'none',\n\t\t\tcolorSpaceConversion: 'none',\n\t\t\timageOrientation: 'flipY',\n\t\t} );\n\t\tconst texture = new Texture( imageBitmap );\n\t\ttexture.generateMipmaps = false;\n\t\ttexture.colorSpace = SRGBColorSpace;\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n\tgetMemoryUsage( tex ) {\n\n\t\tconst { format, type, image, generateMipmaps } = tex;\n\t\tconst { width, height } = image;\n\t\tconst bytes = TextureUtils.getByteLength( width, height, format, type );\n\t\treturn generateMipmaps ? bytes * 4 / 3 : bytes;\n\n\t}\n\n\t// fetch the item with the given key fields\n\tfetchItem( tokens, signal ) {\n\n\t\tconst fetchOptions = {\n\t\t\t...this.fetchOptions,\n\t\t\tsignal,\n\t\t};\n\t\tconst url = this.getUrl( ...tokens );\n\t\treturn this\n\t\t\t.fetchData( url, fetchOptions )\n\t\t\t.then( res => res.arrayBuffer() )\n\t\t\t.then( buffer => this.processBufferToTexture( buffer ) );\n\n\t}\n\n\t// dispose of the item that was fetched\n\tdisposeItem( texture ) {\n\n\t\ttexture.dispose();\n\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\ttexture.image.close();\n\n\t\t}\n\n\t}\n\n\tgetUrl( ...args ) {\n\n\t}\n\n}\n","import { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { TiledImageSource } from './TiledImageSource.js';\n\nexport class XYZImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tlevels = 20,\n\t\t\ttileDimension = 256,\n\t\t\turl = null,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.tileDimension = tileDimension;\n\t\tthis.levels = levels;\n\t\tthis.url = url;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.url\n\t\t\t.replace( /{\\s*z\\s*}/gi, level )\n\t\t\t.replace( /{\\s*x\\s*}/gi, x )\n\t\t\t.replace( /{\\s*(y|reverseY|-\\s*y)\\s*}/gi, y );\n\n\t}\n\n\tinit() {\n\n\t\t// transform the url\n\t\tconst { tiling, tileDimension, levels, url } = this;\n\n\t\ttiling.flipY = ! /{\\s*reverseY|-\\s*y\\s*}/g.test( url );\n\t\ttiling.setProjection( new ProjectionScheme( 'EPSG:3857' ) );\n\t\ttiling.setContentBounds( ...tiling.projection.getBounds() );\n\t\ttiling.generateLevels( levels, tiling.projection.tileCountX, tiling.projection.tileCountY, {\n\t\t\ttilePixelWidth: tileDimension,\n\t\t\ttilePixelHeight: tileDimension,\n\t\t} );\n\n\t\tthis.url = url;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n","import { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { TiledImageSource } from './TiledImageSource.js';\nimport { MathUtils } from 'three';\n\nexport class TMSImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\turl = null,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.tileSets = null;\n\t\tthis.extension = null;\n\t\tthis.url = url;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\tconst { url, extension, tileSets, tiling } = this;\n\t\treturn new URL( `${ parseInt( tileSets[ level - tiling.minLevel ].href ) }/${ x }/${ y }.${ extension }`, url ).toString();\n\n\t}\n\n\tinit() {\n\n\t\tconst { url } = this;\n\n\t\treturn this\n\t\t\t.fetchData( new URL( 'tilemapresource.xml', url ), this.fetchOptions )\n\t\t\t.then( res => res.text() )\n\t\t\t.then( text => {\n\n\t\t\t\tconst { tiling } = this;\n\n\t\t\t\t// elements\n\t\t\t\tconst xml = new DOMParser().parseFromString( text, 'text/xml' );\n\t\t\t\tconst boundingBox = xml.querySelector( 'BoundingBox' );\n\t\t\t\tconst tileFormat = xml.querySelector( 'TileFormat' );\n\t\t\t\tconst tileSets = xml.querySelector( 'TileSets' ).querySelectorAll( 'TileSet' );\n\n\t\t\t\t// tile set definitions\n\t\t\t\tconst tileSetList = [ ...tileSets ]\n\t\t\t\t\t.map( ts => ( {\n\t\t\t\t\t\thref: parseInt( ts.getAttribute( 'href' ) ),\n\t\t\t\t\t\tunitsPerPixel: parseFloat( ts.getAttribute( 'units-per-pixel' ) ),\n\t\t\t\t\t\torder: parseInt( ts.getAttribute( 'order' ) ),\n\t\t\t\t\t} ) )\n\t\t\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\t\t\treturn a.order - b.order;\n\n\t\t\t\t\t} );\n\n\t\t\t\t// bounding box\n\t\t\t\tconst minX = parseFloat( boundingBox.getAttribute( 'minx' ) ) * MathUtils.DEG2RAD;\n\t\t\t\tconst maxX = parseFloat( boundingBox.getAttribute( 'maxx' ) ) * MathUtils.DEG2RAD;\n\t\t\t\tconst minY = parseFloat( boundingBox.getAttribute( 'miny' ) ) * MathUtils.DEG2RAD;\n\t\t\t\tconst maxY = parseFloat( boundingBox.getAttribute( 'maxy' ) ) * MathUtils.DEG2RAD;\n\n\t\t\t\t// origin in lat / lon\n\t\t\t\t// Note: The \"origin\" value in TMS is documented but otherwise not used in any data set as\n\t\t\t\t// defined by the spec so ignore it here.\n\t\t\t\t// const origin = xml.querySelector( 'Origin' );\n\t\t\t\t// const originX = parseFloat( origin.getAttribute( 'x' ) ) * MathUtils.DEG2RAD;\n\t\t\t\t// const originY = parseFloat( origin.getAttribute( 'y' ) ) * MathUtils.DEG2RAD;\n\n\t\t\t\t// image dimensions in pixels\n\t\t\t\tconst tileWidth = parseInt( tileFormat.getAttribute( 'width' ) );\n\t\t\t\tconst tileHeight = parseInt( tileFormat.getAttribute( 'height' ) );\n\t\t\t\tconst extension = tileFormat.getAttribute( 'extension' );\n\t\t\t\tconst srs = xml.querySelector( 'SRS' ).textContent;\n\n\t\t\t\t// assign settings\n\t\t\t\tthis.extension = extension;\n\t\t\t\tthis.url = url;\n\t\t\t\tthis.tileSets = tileSetList;\n\n\t\t\t\t// initialize tiling and projection schemes\n\t\t\t\ttiling.setProjection( new ProjectionScheme( srs ) );\n\t\t\t\ttiling.setContentBounds( minX, minY, maxX, maxY );\n\n\t\t\t\ttileSetList.forEach( ( { order } ) => {\n\n\t\t\t\t\ttiling.setLevel( order, {\n\t\t\t\t\t\ttileCountX: tiling.projection.tileCountX * 2 ** order,\n\t\t\t\t\t\ttilePixelWidth: tileWidth,\n\t\t\t\t\t\ttilePixelHeight: tileHeight,\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t}\n\n}\n","import { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\n\nfunction isCRS84( crs ) {\n\n\treturn /(:84|:crs84)$/i.test( crs );\n\n}\n\nexport class WMTSImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tcapabilities = null,\n\t\t\tlayer = null,\n\t\t\ttileMatrixSet = null,\n\t\t\tstyle = null,\n\t\t\turl = null,\n\t\t\tdimensions = {},\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.capabilities = capabilities;\n\t\tthis.layer = layer;\n\t\tthis.tileMatrixSet = tileMatrixSet;\n\t\tthis.style = style;\n\t\tthis.dimensions = dimensions;\n\t\tthis.url = url;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn this.url\n\t\t\t.replace( /{\\s*TileMatrix\\s*}/gi, level )\n\t\t\t.replace( /{\\s*TileCol\\s*}/gi, x )\n\t\t\t.replace( /{\\s*TileRow\\s*}/gi, y );\n\n\t}\n\n\tinit() {\n\n\t\tconst { tiling, dimensions, capabilities } = this;\n\t\tlet { layer, tileMatrixSet, style, url } = this;\n\n\t\t// extract the layer to use\n\t\tif ( ! layer ) {\n\n\t\t\tlayer = capabilities.layers[ 0 ];\n\n\t\t} else if ( typeof layer === 'string' ) {\n\n\t\t\tlayer = capabilities.layers.find( l => l.identifier === layer );\n\n\t\t}\n\n\t\t// extract the tile matrix set\n\t\tif ( ! tileMatrixSet ) {\n\n\t\t\ttileMatrixSet = layer.tileMatrixSets[ 0 ];\n\n\t\t} else if ( typeof tileMatrixSet === 'string' ) {\n\n\t\t\ttileMatrixSet = layer.tileMatrixSets.find( tms => tms.identifier === tileMatrixSet );\n\n\t\t}\n\n\t\t// extract the style\n\t\tif ( ! style ) {\n\n\t\t\tstyle = layer.styles.find( style => style.isDefault ).identifier;\n\n\t\t}\n\n\t\t// extract the url template\n\t\tif ( ! url ) {\n\n\t\t\turl = layer.resourceUrls[ 0 ].template;\n\n\t\t}\n\n\t\t// determine the projection\n\t\tconst supportedCRS = tileMatrixSet.supportedCRS;\n\t\tconst projection = ( supportedCRS.includes( '4326' ) || isCRS84( supportedCRS ) ) ? 'EPSG:4326' : 'EPSG:3857';\n\n\t\t// generate the tiling scheme\n\t\ttiling.flipY = true;\n\t\ttiling.setProjection( new ProjectionScheme( projection ) );\n\n\t\tif ( layer.boundingBox !== null ) {\n\n\t\t\ttiling.setContentBounds( ...layer.boundingBox.bounds );\n\n\t\t} else {\n\n\t\t\ttiling.setContentBounds( ...tiling.projection.getBounds() );\n\n\t\t}\n\n\t\ttileMatrixSet.tileMatrices.forEach( ( tm, i ) => {\n\n\t\t\t// TODO: needs to set tileCountX from matrix width?\n\t\t\t// TODO: How does bounds and tile count work together here?\n\t\t\t// Can one typically be generated from the other?\n\n\t\t\tconst { tileWidth, tileHeight, matrixWidth, matrixHeight } = tm;\n\t\t\ttiling.setLevel( i, {\n\t\t\t\ttilePixelWidth: tileWidth,\n\t\t\t\ttilePixelHeight: tileHeight,\n\t\t\t\ttileCountX: matrixWidth || tiling.projection.tileCountX * 2 ** i,\n\t\t\t\ttileCountY: matrixHeight || tiling.projection.tileCountY * 2 ** i,\n\t\t\t\ttileBounds: tm.bounds,\n\t\t\t} );\n\n\t\t} );\n\n\t\t// construct the url\n\t\turl = url\n\t\t\t.replace( /{\\s*TileMatrixSet\\s*}/g, tileMatrixSet.identifier )\n\t\t\t.replace( /{\\s*Style\\s*}/g, style );\n\n\t\t// fill in the dimension values\n\t\tfor ( const key in dimensions ) {\n\n\t\t\turl = url.replace( new RegExp( `{\\\\s*${ key }\\\\s*}` ), dimensions[ key ] );\n\n\t\t}\n\n\t\tlayer.dimensions.forEach( dim => {\n\n\t\t\turl = url.replace( new RegExp( `{\\\\s*${ dim.identifier }\\\\s*}` ), dim.defaultValue );\n\n\t\t} );\n\n\t\tthis.url = url;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n","import { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { MathUtils } from 'three';\n\nexport class WMSImageSource extends TiledImageSource {\n\n\t// TODO: layer and styles can be arrays, comma separated lists\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\turl = null,\n\t\t\tlayer = null,\n\t\t\tstyles = null,\n\t\t\tcontentBoundingBox = null,\n\t\t\tversion = '1.3.0',\n\t\t\tcrs = 'EPSG:4326',\n\t\t\tformat = 'image/png',\n\t\t\ttransparent = false,\n\t\t\tlevels = 18,\n\t\t\ttileDimension = 256,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\t\tthis.url = url;\n\t\tthis.layer = layer;\n\t\tthis.crs = crs;\n\t\tthis.format = format;\n\t\tthis.tileDimension = tileDimension;\n\t\tthis.styles = styles;\n\t\tthis.version = version;\n\t\tthis.levels = levels;\n\t\tthis.transparent = transparent;\n\t\tthis.contentBoundingBox = contentBoundingBox;\n\n\t}\n\n\tinit() {\n\n\t\tconst { tiling, levels, tileDimension, contentBoundingBox } = this;\n\t\ttiling.setProjection( new ProjectionScheme( this.crs ) );\n\t\ttiling.flipY = true;\n\t\ttiling.generateLevels( levels, tiling.projection.tileCountX, tiling.projection.tileCountY, {\n\t\t\ttilePixelWidth: tileDimension,\n\t\t\ttilePixelHeight: tileDimension,\n\t\t} );\n\n\t\tif ( contentBoundingBox !== null ) {\n\n\t\t\ttiling.setContentBounds( ...contentBoundingBox );\n\n\t\t} else {\n\n\t\t\ttiling.setContentBounds( ...tiling.projection.getBounds() );\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n\t// TODO: handle this in ProjectionScheme or TilingScheme? Or Loader?\n\tnormalizedToMercatorX( v ) {\n\n\t\tconst MERCATOR_MIN = - 20037508.342789244;\n\t\tconst MERCATOR_MAX = 20037508.342789244;\n\t\treturn MathUtils.mapLinear( v, 0, 1, MERCATOR_MIN, MERCATOR_MAX );\n\n\t}\n\n\tnormalizedToMercatorY( v ) {\n\n\t\tconst MERCATOR_MIN = - 20037508.342789244;\n\t\tconst MERCATOR_MAX = 20037508.342789244;\n\t\treturn MathUtils.mapLinear( v, 0, 1, MERCATOR_MIN, MERCATOR_MAX );\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\tconst {\n\t\t\ttiling,\n\t\t\tlayer,\n\t\t\tcrs,\n\t\t\tformat,\n\t\t\ttileDimension,\n\t\t\tstyles,\n\t\t\tversion,\n\t\t\ttransparent,\n\t\t} = this;\n\n\t\t// Axis order and CRS param name depend on WMS version and CRS\n\t\t// crsParam: 'SRS' for WMS 1.1.1, 'CRS' for WMS 1.3.0\n\t\tconst crsParam = version === '1.1.1' ? 'SRS' : 'CRS';\n\t\tlet bboxParam;\n\n\t\tif ( crs === 'EPSG:3857' ) {\n\n\t\t\t// Always lon / lat order for both versions\n\t\t\tconst range = tiling.getTileBounds( x, y, level, true, false );\n\t\t\tconst minx = this.normalizedToMercatorX( range[ 0 ] );\n\t\t\tconst miny = this.normalizedToMercatorY( range[ 1 ] );\n\t\t\tconst maxx = this.normalizedToMercatorX( range[ 2 ] );\n\t\t\tconst maxy = this.normalizedToMercatorY( range[ 3 ] );\n\t\t\tbboxParam = [ minx, miny, maxx, maxy ];\n\n\t\t} else {\n\n\t\t\t// Get the tile bounds as degrees\n\t\t\tconst [ minx, miny, maxx, maxy ] = tiling\n\t\t\t\t.getTileBounds( x, y, level, false, false )\n\t\t\t\t.map( v => v * MathUtils.RAD2DEG );\n\n\t\t\tif ( crs === 'EPSG:4326' ) {\n\n\t\t\t\t// Note: In WMS 1.1.1 EPSG:4326 is wrongly defined as having long/lat coordinate axes. See v1.3.0 documentation for details.\n\t\t\t\t// Docs:  https://docs.foursquare.com/analytics-products/docs/data-formats-wms\n\t\t\t\t// Topic: https://gis.stackexchange.com/questions/23347/getmap-wms-1-1-1-vs-1-3-0\n\t\t\t\tif ( version === '1.1.1' ) {\n\n\t\t\t\t\t// WMS 1.1.1: lon / lat order\n\t\t\t\t\tbboxParam = [ minx, miny, maxx, maxy ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// WMS 1.3.0: lat / lon order\n\t\t\t\t\tbboxParam = [ miny, minx, maxy, maxx ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbboxParam = [ minx, miny, maxx, maxy ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst params = new URLSearchParams( {\n\t\t\tSERVICE: 'WMS',\n\t\t\tREQUEST: 'GetMap',\n\t\t\tVERSION: version,\n\t\t\tLAYERS: layer,\n\t\t\t[ crsParam ]: crs,\n\t\t\tBBOX: bboxParam.join( ',' ),\n\t\t\tWIDTH: tileDimension,\n\t\t\tHEIGHT: tileDimension,\n\t\t\tFORMAT: format,\n\t\t\tTRANSPARENT: transparent ? 'TRUE' : 'FALSE',\n\t\t} );\n\n\t\t// Only add STYLES if it's defined (not null or undefined)\n\t\t// This is a WMS-specific parameter, and giving it an unexpected value can lead to errors\n\t\tif ( styles !== null && styles !== undefined ) {\n\n\t\t\tparams.set( 'STYLES', styles );\n\n\t\t}\n\n\t\treturn new URL( '?' + params.toString(), this.url ).toString();\n\n\t}\n\n}\n","\n// Support for XYZ / Slippy tile systems\n\nimport { EllipsoidProjectionTilesPlugin } from './EllipsoidProjectionTilesPlugin.js';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\nimport { WMSImageSource } from './sources/WMSImageSource.js';\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames\nexport class XYZTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tlevels,\n\t\t\ttileDimension,\n\t\t\turl,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'XYZ_TILES_PLUGIN';\n\t\tthis.imageSource = new XYZImageSource( { url, levels, tileDimension } );\n\n\t}\n\n}\n\n// Support for TMS tiles\n// https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification\n// NOTE: Most, if not all, TMS generation implementations do not correctly support the Origin tag\n// and tile index offsets, including CesiumJS and Ion.\nexport class TMSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst { url, ...rest } = options;\n\t\tsuper( rest );\n\n\t\tthis.name = 'TMS_TILES_PLUGIN';\n\t\tthis.imageSource = new TMSImageSource( { url } );\n\n\t}\n\n}\n\n// Support for WMTS tiles via a url template\nexport class WMTSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tcapabilities,\n\t\t\tlayer,\n\t\t\ttileMatrixSet,\n\t\t\tstyle,\n\t\t\tdimensions,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'WTMS_TILES_PLUGIN';\n\t\tthis.imageSource = new WMTSImageSource( {\n\t\t\tcapabilities,\n\t\t\tlayer,\n\t\t\ttileMatrixSet,\n\t\t\tstyle,\n\t\t\tdimensions\n\t\t} );\n\n\t}\n\n}\n\nexport class WMSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\turl,\n\t\t\tlayer,\n\t\t\tcrs,\n\t\t\tformat,\n\t\t\ttileDimension,\n\t\t\tstyles,\n\t\t\tversion,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\tthis.name = 'WMS_TILES_PLUGIN';\n\t\tthis.imageSource = new WMSImageSource( {\n\t\t\turl,\n\t\t\tlayer,\n\t\t\tcrs,\n\t\t\tformat,\n\t\t\ttileDimension,\n\t\t\tstyles,\n\t\t\tversion\n\t\t} );\n\n\t}\n\n}\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tDataTexture,\n\tDefaultLoadingManager,\n\tLinearFilter,\n\tLinearMipMapLinearFilter,\n\tMathUtils,\n\tMesh,\n\tMeshStandardMaterial,\n\tRGFormat,\n\tTriangle,\n\tUnsignedByteType,\n\tVector3,\n} from 'three';\nimport { QuantizedMeshLoaderBase } from '3d-tiles-renderer/core/plugins';\nimport { Ellipsoid } from '3d-tiles-renderer/three';\n\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _tri = /* @__PURE__ */ new Triangle();\nconst _uvh = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nexport class QuantizedMeshLoader extends QuantizedMeshLoaderBase {\n\n\tconstructor( manager = DefaultLoadingManager ) {\n\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis.ellipsoid = new Ellipsoid();\n\t\tthis.skirtLength = 1000;\n\t\tthis.smoothSkirtNormals = true;\n\t\tthis.solid = false;\n\n\t\t// set the range of the tile\n\t\tthis.minLat = - Math.PI / 2;\n\t\tthis.maxLat = Math.PI / 2;\n\t\tthis.minLon = - Math.PI;\n\t\tthis.maxLon = Math.PI;\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst {\n\t\t\tellipsoid,\n\t\t\tsolid,\n\t\t\tskirtLength,\n\t\t\tsmoothSkirtNormals,\n\n\t\t\tminLat,\n\t\t\tmaxLat,\n\t\t\tminLon,\n\t\t\tmaxLon,\n\t\t} = this;\n\n\t\tconst {\n\t\t\theader,\n\t\t\tindices,\n\t\t\tvertexData,\n\t\t\tedgeIndices,\n\t\t\textensions,\n\t\t} = super.parse( buffer );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new MeshStandardMaterial();\n\t\tconst mesh = new Mesh( geometry, material );\n\t\tmesh.position.set( ...header.center );\n\n\t\tconst includeNormals = 'octvertexnormals' in extensions;\n\t\tconst vertexCount = vertexData.u.length;\n\t\tconst positions = [];\n\t\tconst uvs = [];\n\t\tconst indexArr = [];\n\t\tconst normals = [];\n\t\tlet groupOffset = 0;\n\t\tlet materialIndex = 0;\n\n\t\t// construct terrain\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\treadUVHeight( i, _uvh );\n\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos );\n\n\t\t\tuvs.push( _uvh.x, _uvh.y );\n\t\t\tpositions.push( ..._pos );\n\n\t\t}\n\n\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tindexArr.push( indices[ i ] );\n\n\t\t}\n\n\t\tif ( includeNormals ) {\n\n\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\tfor ( let i = 0, l = extNormals.length; i < l; i ++ ) {\n\n\t\t\t\tnormals.push( extNormals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add material group\n\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\tgroupOffset += indices.length;\n\t\tmaterialIndex ++;\n\n\t\t// create a lower cap\n\t\tif ( solid ) {\n\n\t\t\tconst indexOffset = positions.length / 3;\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\treadUVHeight( i, _uvh );\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos, - skirtLength );\n\n\t\t\t\tuvs.push( _uvh.x, _uvh.y );\n\t\t\t\tpositions.push( ..._pos );\n\n\t\t\t}\n\n\t\t\tfor ( let i = indices.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tindexArr.push( indices[ i ] + indexOffset );\n\n\t\t\t}\n\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\tfor ( let i = 0, l = extNormals.length; i < l; i ++ ) {\n\n\t\t\t\t\tnormals.push( - extNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// add material group\n\t\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\t\tgroupOffset += indices.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\t// construct skirts\n\t\tif ( skirtLength > 0 ) {\n\n\t\t\tconst {\n\t\t\t\twestIndices,\n\t\t\t\teastIndices,\n\t\t\t\tsouthIndices,\n\t\t\t\tnorthIndices,\n\t\t\t} = edgeIndices;\n\n\t\t\t// construct the indices\n\t\t\tlet offset;\n\n\t\t\t// west\n\t\t\tconst westStrip = constructEdgeStrip( westIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...westStrip.uv );\n\t\t\tpositions.push( ...westStrip.positions );\n\t\t\tfor ( let i = 0, l = westStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( westStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// east\n\t\t\tconst eastStrip = constructEdgeStrip( eastIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...eastStrip.uv );\n\t\t\tpositions.push( ...eastStrip.positions );\n\t\t\tfor ( let i = 0, l = eastStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( eastStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// south\n\t\t\tconst southStrip = constructEdgeStrip( southIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...southStrip.uv );\n\t\t\tpositions.push( ...southStrip.positions );\n\t\t\tfor ( let i = 0, l = southStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( southStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// north\n\t\t\tconst northStrip = constructEdgeStrip( northIndices );\n\t\t\toffset = positions.length / 3;\n\t\t\tuvs.push( ...northStrip.uv );\n\t\t\tpositions.push( ...northStrip.positions );\n\t\t\tfor ( let i = 0, l = northStrip.indices.length; i < l; i ++ ) {\n\n\t\t\t\tindexArr.push( northStrip.indices[ i ] + offset );\n\n\t\t\t}\n\n\t\t\t// add the normals\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tnormals.push( ...westStrip.normals );\n\t\t\t\tnormals.push( ...eastStrip.normals );\n\t\t\t\tnormals.push( ...southStrip.normals );\n\t\t\t\tnormals.push( ...northStrip.normals );\n\n\t\t\t}\n\n\t\t\t// add material group\n\t\t\tgeometry.addGroup( groupOffset, indices.length, materialIndex );\n\t\t\tgroupOffset += indices.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\t// shift the positions by the center of the tile\n\t\tfor ( let i = 0, l = positions.length; i < l; i += 3 ) {\n\n\t\t\tpositions[ i + 0 ] -= header.center[ 0 ];\n\t\t\tpositions[ i + 1 ] -= header.center[ 1 ];\n\t\t\tpositions[ i + 2 ] -= header.center[ 2 ];\n\n\t\t}\n\n\t\t// generate geometry and mesh\n\t\tconst indexBuffer = positions.length / 3 > 65535 ? new Uint32Array( indexArr ) : new Uint16Array( indexArr );\n\t\tgeometry.setIndex( new BufferAttribute( indexBuffer, 1, false ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( positions ), 3, false ) );\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( uvs ), 2, false ) );\n\t\tif ( includeNormals ) {\n\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( normals ), 3, false ) );\n\n\t\t}\n\n\t\t// generate the water texture\n\t\tif ( 'watermask' in extensions ) {\n\n\t\t\t// invert the mask data\n\t\t\t// TODO: this inversion step can be a bit slow\n\t\t\tconst { mask, size } = extensions[ 'watermask' ];\n\t\t\tconst maskBuffer = new Uint8Array( 2 * size * size );\n\t\t\tfor ( let i = 0, l = mask.length; i < l; i ++ ) {\n\n\t\t\t\tconst v = mask[ i ] === 255 ? 0 : 255;\n\t\t\t\tmaskBuffer[ 2 * i + 0 ] = v;\n\t\t\t\tmaskBuffer[ 2 * i + 1 ] = v;\n\n\t\t\t}\n\n\t\t\t// TODO: Luminance format is not supported - eventually node materials will\n\t\t\t// make it possible to map the texture to the appropriate buffer input.\n\t\t\tconst map = new DataTexture( maskBuffer, size, size, RGFormat, UnsignedByteType );\n\t\t\tmap.flipY = true;\n\t\t\tmap.minFilter = LinearMipMapLinearFilter;\n\t\t\tmap.magFilter = LinearFilter;\n\t\t\tmap.needsUpdate = true;\n\n\t\t\tmaterial.roughnessMap = map;\n\n\t\t}\n\n\t\t// set metadata\n\t\tmesh.userData.minHeight = header.minHeight;\n\t\tmesh.userData.maxHeight = header.maxHeight;\n\n\t\tif ( 'metadata' in extensions ) {\n\n\t\t\tmesh.userData.metadata = extensions[ 'metadata' ].json;\n\n\t\t}\n\n\t\treturn mesh;\n\n\t\tfunction readUVHeight( index, target ) {\n\n\t\t\ttarget.x = vertexData.u[ index ];\n\t\t\ttarget.y = vertexData.v[ index ];\n\t\t\ttarget.z = vertexData.height[ index ];\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction readPosition( u, v, h, target, heightOffset = 0 ) {\n\n\t\t\tconst height = MathUtils.lerp( header.minHeight, header.maxHeight, h );\n\t\t\tconst lon = MathUtils.lerp( minLon, maxLon, u );\n\t\t\tconst lat = MathUtils.lerp( minLat, maxLat, v );\n\n\t\t\tellipsoid.getCartographicToPosition( lat, lon, height + heightOffset, target );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction constructEdgeStrip( indices ) {\n\n\t\t\tconst topUvs = [];\n\t\t\tconst topPos = [];\n\t\t\tconst botUvs = [];\n\t\t\tconst botPos = [];\n\t\t\tconst sideIndices = [];\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\treadUVHeight( indices[ i ], _uvh );\n\t\t\t\ttopUvs.push( _uvh.x, _uvh.y );\n\t\t\t\tbotUvs.push( _uvh.x, _uvh.y );\n\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos );\n\t\t\t\ttopPos.push( ..._pos );\n\n\t\t\t\treadPosition( _uvh.x, _uvh.y, _uvh.z, _pos, - skirtLength );\n\t\t\t\tbotPos.push( ..._pos );\n\n\t\t\t}\n\n\t\t\tconst triCount = ( indices.length - 1 );\n\t\t\tfor ( let i = 0; i < triCount; i ++ ) {\n\n\t\t\t\tconst t0 = i;\n\t\t\t\tconst t1 = i + 1;\n\t\t\t\tconst b0 = i + indices.length;\n\t\t\t\tconst b1 = i + indices.length + 1;\n\n\t\t\t\tsideIndices.push( t0, b0, t1 );\n\t\t\t\tsideIndices.push( t1, b0, b1 );\n\n\t\t\t}\n\n\t\t\tlet normals = null;\n\t\t\tif ( includeNormals ) {\n\n\t\t\t\tconst total = ( topPos.length + botPos.length ) / 3;\n\n\t\t\t\tif ( smoothSkirtNormals ) {\n\n\t\t\t\t\tnormals = new Array( total * 3 );\n\n\t\t\t\t\tconst extNormals = extensions[ 'octvertexnormals' ].normals;\n\t\t\t\t\tconst botOffset = normals.length / 2;\n\t\t\t\t\tfor ( let i = 0, l = total / 2; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst index = indices[ i ];\n\t\t\t\t\t\tconst i3 = 3 * i;\n\t\t\t\t\t\tconst nx = extNormals[ 3 * index + 0 ];\n\t\t\t\t\t\tconst ny = extNormals[ 3 * index + 1 ];\n\t\t\t\t\t\tconst nz = extNormals[ 3 * index + 2 ];\n\n\t\t\t\t\t\tnormals[ i3 + 0 ] = nx;\n\t\t\t\t\t\tnormals[ i3 + 1 ] = ny;\n\t\t\t\t\t\tnormals[ i3 + 2 ] = nz;\n\n\t\t\t\t\t\tnormals[ botOffset + i3 + 0 ] = nx;\n\t\t\t\t\t\tnormals[ botOffset + i3 + 1 ] = ny;\n\t\t\t\t\t\tnormals[ botOffset + i3 + 2 ] = nz;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormals = [];\n\t\t\t\t\t_tri.a.fromArray( topPos, 0 );\n\t\t\t\t\t_tri.b.fromArray( botPos, 0 );\n\t\t\t\t\t_tri.c.fromArray( topPos, 3 );\n\t\t\t\t\t_tri.getNormal( _norm );\n\n\t\t\t\t\tfor ( let i = 0; i < total; i ++ ) {\n\n\t\t\t\t\t\tnormals.push( ..._norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tuv: [ ...topUvs, ...botUvs ],\n\t\t\t\tpositions: [ ...topPos, ...botPos ],\n\t\t\t\tindices: sideIndices,\n\t\t\t\tnormals,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n","import { MathUtils, Triangle, BufferGeometry, BufferAttribute, Mesh, Vector4 } from 'three';\n\nconst SPLIT_VALUE = 0;\nconst vertNames = [ 'a', 'b', 'c' ];\nconst _vec = /* @__PURE__ */ new Vector4();\nconst _v0 = /* @__PURE__ */ new Vector4();\nconst _v1 = /* @__PURE__ */ new Vector4();\nconst _v2 = /* @__PURE__ */ new Vector4();\n\n// Class for clipping geometry using the results from a \"split operation\"\nexport class GeometryClipper {\n\n\tconstructor() {\n\n\t\t// the list of attributes to use in the geometry being clipped, such as\n\t\t// [ 'position', 'normal', 'uv' ]\n\t\tthis.attributeList = null;\n\n\t\t// internal\n\t\tthis.splitOperations = [];\n\t\tthis.trianglePool = new ClipTrianglePool();\n\n\t}\n\n\tforEachSplitPermutation( callback ) {\n\n\t\tconst { splitOperations } = this;\n\t\tconst runPermutations = ( index = 0 ) => {\n\n\t\t\tif ( index >= splitOperations.length ) {\n\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tsplitOperations[ index ].keepPositive = true;\n\t\t\trunPermutations( index + 1 );\n\n\t\t\tsplitOperations[ index ].keepPositive = false;\n\t\t\trunPermutations( index + 1 );\n\n\t\t};\n\n\t\trunPermutations();\n\n\t}\n\n\t// Takes an operation that returns a value for the given vertex passed to the callback. Triangles\n\t// are clipped along edges where the interpolated value is equal to 0. The polygons on the positive\n\t// side of the operation are kept if \"keepPositive\" is true.\n\t// callback( geometry, i0, i1, i2, barycoord );\n\taddSplitOperation( callback, keepPositive = true ) {\n\n\t\tthis.splitOperations.push( {\n\t\t\tcallback,\n\t\t\tkeepPositive,\n\t\t} );\n\n\t}\n\n\t// Removes all split operations\n\tclearSplitOperations() {\n\n\t\tthis.splitOperations.length = 0;\n\n\t}\n\n\t// clips an object hierarchy\n\tclipObject( object ) {\n\n\t\tconst result = object.clone();\n\t\tconst toRemove = [];\n\t\tresult.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tc.geometry = this.clip( c ).geometry;\n\n\t\t\t\tconst triCount = c.geometry.index ? c.geometry.index.count / 3 : c.attributes.position.count / 3;\n\t\t\t\tif ( triCount === 0 ) {\n\n\t\t\t\t\ttoRemove.push( c );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttoRemove.forEach( m => {\n\n\t\t\tm.removeFromParent();\n\n\t\t} );\n\n\t\treturn result;\n\n\t}\n\n\t// Returns a new mesh that has been clipped by the split operations. Range indicates the range of\n\t// elements to include when clipping.\n\tclip( mesh, range = null ) {\n\n\t\t// TODO: support multimaterial\n\t\tconst result = this.getClippedData( mesh, range );\n\t\treturn this.constructMesh( result.attributes, result.index, mesh );\n\n\t}\n\n\t// Appends the clip operation data to the given \"target\" object so multiple ranges can be appended.\n\t// The \"target\" object is returned with an \"index\" field, \"vertexIsClipped\" field, and series of arrays\n\t// in \"attributes\".\n\t// attributes - set of attribute arrays\n\t// index - triangle indices referencing vertices in attributes\n\t// vertexIsClipped - array indicating whether a vertex is on a clipped edge\n\tgetClippedData( mesh, range = null, target = {} ) {\n\n\t\tconst { trianglePool, splitOperations, attributeList } = this;\n\n\t\t// source geometry\n\t\tconst sourceGeometry = mesh.geometry;\n\t\tconst position = sourceGeometry.attributes.position;\n\t\tconst index = sourceGeometry.index;\n\n\t\t// vertex hash data\n\t\tlet nextIndex = 0;\n\t\tconst vertToNewIndexMap = {};\n\n\t\t// initialize the result\n\t\ttarget.index = target.index || [];\n\t\ttarget.vertexIsClipped = target.vertexIsClipped || [];\n\t\ttarget.attributes = target.attributes || {};\n\n\t\t// initialize the attributes to the set in the attribute list or all if set to null\n\t\tfor ( const key in sourceGeometry.attributes ) {\n\n\t\t\tif ( attributeList !== null ) {\n\n\t\t\t\tif ( attributeList instanceof Function && ! attributeList( key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t} else if ( Array.isArray( attributeList ) && ! attributeList.includes( key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.attributes[ key ] = [];\n\n\t\t}\n\n\t\t// iterate over each group separately to retain the group information\n\t\tlet start = 0;\n\t\tlet count = index ? index.count : position.count;\n\t\tif ( range !== null ) {\n\n\t\t\tstart = range.start;\n\t\t\tcount = range.count;\n\n\t\t}\n\n\t\t// run the clip operations\n\t\tfor ( let i = start, l = start + count; i < l; i += 3 ) {\n\n\t\t\t// get the indices\n\t\t\tlet i0 = i + 0;\n\t\t\tlet i1 = i + 1;\n\t\t\tlet i2 = i + 2;\n\t\t\tif ( index ) {\n\n\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t}\n\n\t\t\t// get the original triangle\n\t\t\tconst tri = trianglePool.get();\n\t\t\ttri.initFromIndices( i0, i1, i2 );\n\n\t\t\t// iterate over each triangle and clip it\n\t\t\tlet triangles = [ tri ];\n\t\t\tfor ( let s = 0; s < splitOperations.length; s ++ ) {\n\n\t\t\t\tconst { keepPositive, callback } = splitOperations[ s ];\n\t\t\t\tconst result = [];\n\t\t\t\tfor ( let t = 0; t < triangles.length; t ++ ) {\n\n\t\t\t\t\tconst tri = triangles[ t ];\n\t\t\t\t\tconst { indices, barycoord } = tri;\n\t\t\t\t\ttri.clipValues.a = callback( sourceGeometry, indices.a, indices.b, indices.c, barycoord.a, mesh.matrixWorld );\n\t\t\t\t\ttri.clipValues.b = callback( sourceGeometry, indices.a, indices.b, indices.c, barycoord.b, mesh.matrixWorld );\n\t\t\t\t\ttri.clipValues.c = callback( sourceGeometry, indices.a, indices.b, indices.c, barycoord.c, mesh.matrixWorld );\n\n\t\t\t\t\tthis.splitTriangle( tri, ! keepPositive, result );\n\n\t\t\t\t}\n\n\t\t\t\ttriangles = result;\n\n\t\t\t}\n\n\t\t\t// append the triangles to the result\n\t\t\tfor ( let t = 0, l = triangles.length; t < l; t ++ ) {\n\n\t\t\t\tconst tri = triangles[ t ];\n\t\t\t\tpushTriangle( tri, sourceGeometry );\n\n\t\t\t}\n\n\t\t\ttrianglePool.reset();\n\n\t\t}\n\n\t\treturn target;\n\n\t\tfunction pushTriangle( tri, geometry ) {\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst hash = tri.getVertexHash( i, geometry );\n\n\t\t\t\tif ( ! ( hash in vertToNewIndexMap ) ) {\n\n\t\t\t\t\tvertToNewIndexMap[ hash ] = nextIndex;\n\t\t\t\t\tnextIndex ++;\n\n\t\t\t\t\ttri.getVertexData( i, geometry, target.attributes );\n\t\t\t\t\ttarget.vertexIsClipped.push( tri.clipValues[ vertNames[ i ] ] === SPLIT_VALUE );\n\n\t\t\t\t}\n\n\t\t\t\tconst index = vertToNewIndexMap[ hash ];\n\t\t\t\ttarget.index.push( index );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Takes the set of resultant data and constructs a mesh\n\tconstructMesh( attributes, index, sourceMesh ) {\n\n\t\tconst sourceGeometry = sourceMesh.geometry;\n\n\t\t// new geometry\n\t\tconst geometry = new BufferGeometry();\n\t\tconst indexBuffer = attributes.position.length / 3 > 65535 ? new Uint32Array( index ) : new Uint16Array( index );\n\t\tgeometry.setIndex( new BufferAttribute( indexBuffer, 1, false ) );\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = sourceGeometry.getAttribute( key );\n\t\t\tconst cons = new attr.array.constructor( attributes[ key ] );\n\t\t\tconst newAttr = new BufferAttribute( cons, attr.itemSize, attr.normalized );\n\t\t\tnewAttr.gpuType = attr.gpuType;\n\n\t\t\tgeometry.setAttribute( key, newAttr );\n\n\t\t}\n\n\t\t// new mesh\n\t\tconst result = new Mesh( geometry, sourceMesh.material.clone() );\n\t\tresult.position.copy( sourceMesh.position );\n\t\tresult.quaternion.copy( sourceMesh.quaternion );\n\t\tresult.scale.copy( sourceMesh.scale );\n\n\t\treturn result;\n\n\n\t}\n\n\t// Splits the given triangle\n\tsplitTriangle( tri, keepNegative, target ) {\n\n\t\tconst { trianglePool } = this;\n\n\t\t// TODO: clean up, add scratch variables, optimize\n\t\tconst edgeIndices = [];\n\t\tconst edges = [];\n\t\tconst lerpValues = [];\n\n\t\t// Find all points to clip\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst v = vertNames[ i ];\n\t\t\tconst nv = vertNames[ ( i + 1 ) % 3 ];\n\n\t\t\tconst pValue = tri.clipValues[ v ];\n\t\t\tconst npValue = tri.clipValues[ nv ];\n\n\t\t\t// if the uv values span across the halfway divide\n\t\t\tif ( ( pValue < SPLIT_VALUE ) !== ( npValue < SPLIT_VALUE ) || pValue === SPLIT_VALUE ) {\n\n\t\t\t\tedgeIndices.push( i );\n\t\t\t\tedges.push( [ v, nv ] );\n\n\t\t\t\tif ( pValue === npValue ) {\n\n\t\t\t\t\t// avoid NaN here which can occur with mapLinear when pValue and npValue are the same value\n\t\t\t\t\tlerpValues.push( 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlerpValues.push( MathUtils.mapLinear( SPLIT_VALUE, pValue, npValue, 0, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( edgeIndices.length !== 2 ) {\n\n\t\t\t// if we don't have two intersection points then this triangle must fall on\n\t\t\t// one side of the bounds.\n\t\t\tconst minBound = Math.min(\n\t\t\t\ttri.clipValues.a,\n\t\t\t\ttri.clipValues.b,\n\t\t\t\ttri.clipValues.c,\n\t\t\t);\n\n\t\t\tif ( ( minBound < SPLIT_VALUE ) === keepNegative ) {\n\n\t\t\t\ttarget.push( tri );\n\n\t\t\t}\n\n\t\t} else if ( edgeIndices.length === 2 ) {\n\n\t\t\t// TODO: how can we determine which triangles actually need to be added here ahead of time\n\t\t\tconst tri0 = trianglePool.get().initFromTriangle( tri );\n\t\t\tconst tri1 = trianglePool.get().initFromTriangle( tri );\n\t\t\tconst tri2 = trianglePool.get().initFromTriangle( tri );\n\n\t\t\t// If the points lie on edges that are immediately after one another then we have to split the\n\t\t\t// triangle differently.\n\t\t\tconst sequential = ( ( edgeIndices[ 0 ] + 1 ) % 3 ) === edgeIndices[ 1 ];\n\t\t\tif ( sequential ) {\n\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri0.copyVertex( tri, edges[ 0 ][ 1 ], 'b' );\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'c' );\n\t\t\t\ttri0.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri0.clipValues.c = SPLIT_VALUE;\n\n\t\t\t\ttri1.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri1.copyVertex( tri, edges[ 1 ][ 1 ], 'b' );\n\t\t\t\ttri1.copyVertex( tri, edges[ 0 ][ 0 ], 'c' );\n\t\t\t\ttri1.clipValues.a = SPLIT_VALUE;\n\n\t\t\t\ttri2.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri2.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'b' );\n\t\t\t\ttri2.copyVertex( tri, edges[ 1 ][ 1 ], 'c' );\n\t\t\t\ttri2.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri2.clipValues.b = SPLIT_VALUE;\n\n\t\t\t} else {\n\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri0.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'b' );\n\t\t\t\ttri0.copyVertex( tri, edges[ 0 ][ 0 ], 'c' );\n\t\t\t\ttri0.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri0.clipValues.b = SPLIT_VALUE;\n\n\t\t\t\ttri1.lerpVertexFromEdge( tri, edges[ 0 ][ 0 ], edges[ 0 ][ 1 ], lerpValues[ 0 ], 'a' );\n\t\t\t\ttri1.copyVertex( tri, edges[ 0 ][ 1 ], 'b' );\n\t\t\t\ttri1.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'c' );\n\t\t\t\ttri1.clipValues.a = SPLIT_VALUE;\n\t\t\t\ttri1.clipValues.c = SPLIT_VALUE;\n\n\t\t\t\ttri2.copyVertex( tri, edges[ 0 ][ 1 ], 'a' );\n\t\t\t\ttri2.copyVertex( tri, edges[ 1 ][ 0 ], 'b' );\n\t\t\t\ttri2.lerpVertexFromEdge( tri, edges[ 1 ][ 0 ], edges[ 1 ][ 1 ], lerpValues[ 1 ], 'c' );\n\t\t\t\ttri2.clipValues.c = SPLIT_VALUE;\n\n\t\t\t}\n\n\t\t\t// Save the triangles that sit on the right side of the split\n\t\t\tlet minBound, negativeSide;\n\t\t\tminBound = Math.min( tri0.clipValues.a, tri0.clipValues.b, tri0.clipValues.c );\n\t\t\tnegativeSide = minBound < SPLIT_VALUE;\n\t\t\tif ( negativeSide === keepNegative ) {\n\n\t\t\t\ttarget.push( tri0 );\n\n\t\t\t}\n\n\t\t\tminBound = Math.min( tri1.clipValues.a, tri1.clipValues.b, tri1.clipValues.c );\n\t\t\tnegativeSide = minBound < SPLIT_VALUE;\n\t\t\tif ( negativeSide === keepNegative ) {\n\n\t\t\t\ttarget.push( tri1 );\n\n\t\t\t}\n\n\t\t\tminBound = Math.min( tri2.clipValues.a, tri2.clipValues.b, tri2.clipValues.c );\n\t\t\tnegativeSide = minBound < SPLIT_VALUE;\n\t\t\tif ( negativeSide === keepNegative ) {\n\n\t\t\t\ttarget.push( tri2 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Pool of reusable triangles\nclass ClipTrianglePool {\n\n\tconstructor() {\n\n\t\tthis.pool = [];\n\t\tthis.index = 0;\n\n\t}\n\n\tget() {\n\n\t\tif ( this.index >= this.pool.length ) {\n\n\t\t\tconst tri = new ClipTriangle();\n\t\t\tthis.pool.push( tri );\n\n\t\t}\n\n\t\tconst res = this.pool[ this.index ];\n\t\tthis.index ++;\n\t\treturn res;\n\n\t}\n\n\treset() {\n\n\t\tthis.index = 0;\n\n\t}\n\n}\n\n// Triangle class that stores the values to clip along, barycoord values for clipping, and the\n// original indices that the barycoord are interpolated between.\nclass ClipTriangle {\n\n\tconstructor() {\n\n\t\tthis.indices = {\n\t\t\ta: - 1,\n\t\t\tb: - 1,\n\t\t\tc: - 1,\n\t\t};\n\n\t\tthis.clipValues = {\n\t\t\ta: - 1,\n\t\t\tb: - 1,\n\t\t\tc: - 1,\n\t\t};\n\n\t\tthis.barycoord = new Triangle();\n\n\t}\n\n\t// returns a hash for the given [0, 2] index based on attributes of the referenced geometry\n\tgetVertexHash( index, geometry ) {\n\n\t\tconst { barycoord, indices } = this;\n\t\tconst vn = vertNames[ index ];\n\t\tconst bc = barycoord[ vn ];\n\n\t\t// If the barycoord value is specifying a single vertex then return a quick hash\n\t\tif ( bc.x === 1 ) {\n\n\t\t\treturn indices[ vertNames[ 0 ] ];\n\n\t\t} else if ( bc.y === 1 ) {\n\n\t\t\treturn indices[ vertNames[ 1 ] ];\n\n\t\t} else if ( bc.z === 1 ) {\n\n\t\t\treturn indices[ vertNames[ 2 ] ];\n\n\t\t} else {\n\n\t\t\t// Construct a hash based on all the interpolated attributes\n\t\t\tconst { attributes } = geometry;\n\t\t\tlet result = '';\n\t\t\tfor ( const name in attributes ) {\n\n\t\t\t\tconst attr = attributes[ name ];\n\t\t\t\treadInterpolatedAttribute( attr, indices.a, indices.b, indices.c, bc, _vec );\n\n\t\t\t\t// normalize values if needed\n\t\t\t\tif ( name === 'normal' || name === 'tangent' || name === 'bitangent' ) {\n\n\t\t\t\t\t_vec.normalize();\n\n\t\t\t\t}\n\n\t\t\t\t// construct the hash\n\t\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tresult += hashVertex( _vec.x, _vec.y, _vec.z, _vec.w );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tresult += hashVertex( _vec.x, _vec.y, _vec.z );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tresult += hashVertex( _vec.x, _vec.y );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tresult += hashVertex( _vec.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tresult += '|';\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// Accumulate the vertex data in the given attribute arrays\n\tgetVertexData( index, geometry, target ) {\n\n\t\tconst { barycoord, indices } = this;\n\t\tconst vn = vertNames[ index ];\n\t\tconst bc = barycoord[ vn ];\n\n\t\tconst { attributes } = geometry;\n\t\tfor ( const name in attributes ) {\n\n\t\t\t// skip saving the data if we have no fields for it\n\t\t\tif ( ! target[ name ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst attr = attributes[ name ];\n\t\t\tconst arr = target[ name ];\n\n\t\t\treadInterpolatedAttribute( attr, indices.a, indices.b, indices.c, bc, _vec );\n\n\t\t\t// normalize values if needed\n\t\t\tif ( name === 'normal' || name === 'tangent' || name === 'bitangent' ) {\n\n\t\t\t\t_vec.normalize();\n\n\t\t\t}\n\n\t\t\t// append the data\n\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\tcase 4:\n\t\t\t\t\tarr.push( _vec.x, _vec.y, _vec.z, _vec.w );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tarr.push( _vec.x, _vec.y, _vec.z );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tarr.push( _vec.x, _vec.y );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tarr.push( _vec.x );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Copy the indices from a target triangle\n\tinitFromTriangle( other ) {\n\n\t\treturn this.initFromIndices(\n\t\t\tother.indices.a,\n\t\t\tother.indices.b,\n\t\t\tother.indices.c,\n\t\t);\n\n\t}\n\n\t// Set the indices for the given\n\tinitFromIndices( i0, i1, i2 ) {\n\n\t\tthis.indices.a = i0;\n\t\tthis.indices.b = i1;\n\t\tthis.indices.c = i2;\n\n\t\tthis.clipValues.a = - 1;\n\t\tthis.clipValues.b = - 1;\n\t\tthis.clipValues.c = - 1;\n\n\t\tthis.barycoord.a.set( 1, 0, 0 );\n\t\tthis.barycoord.b.set( 0, 1, 0 );\n\t\tthis.barycoord.c.set( 0, 0, 1 );\n\n\t\treturn this;\n\n\t}\n\n\t// Lerp the given vertex along to the provided edge of the provided triangle\n\tlerpVertexFromEdge( other, e0, e1, alpha, targetVertex ) {\n\n\t\tthis.clipValues[ targetVertex ] = MathUtils.lerp( other.clipValues[ e0 ], other.clipValues[ e1 ], alpha );\n\t\tthis.barycoord[ targetVertex ].lerpVectors( other.barycoord[ e0 ], other.barycoord[ e1 ], alpha );\n\n\t}\n\n\t// Copy a vertex from the provided triangle\n\tcopyVertex( other, fromVertex, targetVertex ) {\n\n\t\tthis.clipValues[ targetVertex ] = other.clipValues[ fromVertex ];\n\t\tthis.barycoord[ targetVertex ].copy( other.barycoord[ fromVertex ] );\n\n\t}\n\n}\n\n// Read a vertex from the given attribute interpolated between the indices\nfunction readInterpolatedAttribute( attribute, i0, i1, i2, barycoord, target ) {\n\n\t_v0.fromBufferAttribute( attribute, i0 );\n\t_v1.fromBufferAttribute( attribute, i1 );\n\t_v2.fromBufferAttribute( attribute, i2 );\n\n\ttarget\n\t\t.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( _v0, barycoord.x )\n\t\t.addScaledVector( _v1, barycoord.y )\n\t\t.addScaledVector( _v2, barycoord.z );\n\n\tswitch ( attribute.itemSize ) {\n\n\t\tcase 3:\n\t\t\t_vec.w = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t_vec.w = 0;\n\t\t\t_vec.z = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t_vec.w = 0;\n\t\t\t_vec.z = 0;\n\t\t\t_vec.y = 0;\n\t\t\tbreak;\n\n\t}\n\n\treturn target;\n\n}\n\n// Hash the provided numbers\nexport function hashVertex( ...args ) {\n\n\tconst scalar = 1e5;\n\tconst additive = 0.5;\n\tlet result = '';\n\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\n\n\t\tresult += ~ ~ ( args[ i ] * scalar + additive );\n\t\tif ( i !== l - 1 ) {\n\n\t\t\tresult += '_';\n\n\t\t}\n\n\t}\n\treturn result;\n\n}\n","import { MathUtils, Vector2, Vector3 } from 'three';\nimport { Ellipsoid } from '3d-tiles-renderer/three';\nimport { GeometryClipper, hashVertex } from './GeometryClipper.js';\n\nconst _cart = {};\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _pos0 = /* @__PURE__ */ new Vector3();\nconst _pos1 = /* @__PURE__ */ new Vector3();\nconst _pos2 = /* @__PURE__ */ new Vector3();\nconst _pos3 = /* @__PURE__ */ new Vector3();\nconst _temp = /* @__PURE__ */ new Vector3();\nconst _temp2 = /* @__PURE__ */ new Vector3();\n\nconst _uv0 = /* @__PURE__ */ new Vector2();\nconst _uv1 = /* @__PURE__ */ new Vector2();\nconst _uv2 = /* @__PURE__ */ new Vector2();\n\nexport class QuantizedMeshClipper extends GeometryClipper {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.ellipsoid = new Ellipsoid();\n\t\tthis.skirtLength = 1000;\n\t\tthis.smoothSkirtNormals = true;\n\t\tthis.solid = false;\n\n\t\tthis.minLat = - Math.PI / 2;\n\t\tthis.maxLat = Math.PI / 2;\n\t\tthis.minLon = - Math.PI;\n\t\tthis.maxLon = Math.PI;\n\n\t\tthis.attributeList = [ 'position', 'normal', 'uv' ];\n\n\t}\n\n\tclipToQuadrant( sourceMesh, left, bottom ) {\n\n\t\tconst { solid, skirtLength, ellipsoid, smoothSkirtNormals } = this;\n\n\t\tthis.clearSplitOperations();\n\t\tthis.addSplitOperation( getUvSplitOperation( 'x' ), ! left );\n\t\tthis.addSplitOperation( getUvSplitOperation( 'y' ), ! bottom );\n\n\t\tlet botResult, skirtResult;\n\t\tconst capGroup = sourceMesh.geometry.groups[ 0 ];\n\t\tconst capResult = this.getClippedData( sourceMesh, capGroup );\n\t\tthis.adjustVertices( capResult, sourceMesh.position, 0 );\n\n\t\tif ( solid ) {\n\n\t\t\tbotResult = {\n\t\t\t\tindex: capResult.index.slice().reverse(),\n\t\t\t\tattributes: {},\n\t\t\t};\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tbotResult.attributes[ key ] = capResult.attributes[ key ].slice();\n\n\t\t\t}\n\n\t\t\tconst normal = botResult.attributes.normal;\n\t\t\tif ( normal ) {\n\n\t\t\t\tfor ( let i = 0; i < normal.length; i += 3 ) {\n\n\t\t\t\t\tnormal[ i + 0 ] *= - 1;\n\t\t\t\t\tnormal[ i + 1 ] *= - 1;\n\t\t\t\t\tnormal[ i + 2 ] *= - 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.adjustVertices( botResult, sourceMesh.position, - skirtLength );\n\n\t\t}\n\n\t\tif ( skirtLength > 0 ) {\n\n\t\t\tskirtResult = {\n\t\t\t\tindex: [],\n\t\t\t\tattributes: {\n\t\t\t\t\tposition: [],\n\t\t\t\t\tnormal: [],\n\t\t\t\t\tuv: [],\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// push data onto the\n\t\t\tlet nextIndex = 0;\n\t\t\tconst vertToNewIndexMap = {};\n\t\t\tconst pushVertex = ( pos, uv, norm ) => {\n\n\t\t\t\tconst hash = hashVertex( ...pos, ...norm, ...uv );\n\t\t\t\tif ( ! ( hash in vertToNewIndexMap ) ) {\n\n\t\t\t\t\tvertToNewIndexMap[ hash ] = nextIndex;\n\t\t\t\t\tnextIndex ++;\n\n\t\t\t\t\tskirtResult.attributes.position.push( ...pos );\n\t\t\t\t\tskirtResult.attributes.normal.push( ...norm );\n\t\t\t\t\tskirtResult.attributes.uv.push( ...uv );\n\n\t\t\t\t}\n\n\t\t\t\tskirtResult.index.push( vertToNewIndexMap[ hash ] );\n\n\t\t\t};\n\n\t\t\t// TODO: this seems to have some problematic cases at the root tiles near the poles\n\t\t\tconst capIndex = capResult.index;\n\t\t\tconst capUv = capResult.attributes.uv;\n\t\t\tconst capPosition = capResult.attributes.position;\n\t\t\tconst capNormal = capResult.attributes.normal;\n\t\t\tconst capTriangles = capResult.index.length / 3;\n\t\t\tfor ( let i = 0; i < capTriangles; i ++ ) {\n\n\t\t\t\tconst triOffset = 3 * i;\n\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\t\tconst ne = ( e + 1 ) % 3;\n\t\t\t\t\tconst i0 = capIndex[ triOffset + e ];\n\t\t\t\t\tconst i1 = capIndex[ triOffset + ne ];\n\n\t\t\t\t\t_uv0.fromArray( capUv, i0 * 2 );\n\t\t\t\t\t_uv1.fromArray( capUv, i1 * 2 );\n\n\t\t\t\t\t// find the vertices that lie on the edge\n\t\t\t\t\tif (\n\t\t\t\t\t\t_uv0.x === _uv1.x && ( _uv0.x === 0 || _uv0.x === 0.5 || _uv0.x === 1.0 ) ||\n\t\t\t\t\t\t_uv0.y === _uv1.y && ( _uv0.y === 0 || _uv0.y === 0.5 || _uv0.y === 1.0 )\n\t\t\t\t\t) {\n\n\t\t\t\t\t\t_pos0.fromArray( capPosition, i0 * 3 );\n\t\t\t\t\t\t_pos1.fromArray( capPosition, i1 * 3 );\n\n\t\t\t\t\t\tconst u0 = _pos0;\n\t\t\t\t\t\tconst u1 = _pos1;\n\n\t\t\t\t\t\tconst b0 = _pos2.copy( _pos0 );\n\t\t\t\t\t\tconst b1 = _pos3.copy( _pos1 );\n\n\t\t\t\t\t\t_temp.copy( b0 ).add( sourceMesh.position );\n\t\t\t\t\t\tellipsoid.getPositionToNormal( _temp, _temp );\n\t\t\t\t\t\tb0.addScaledVector( _temp, - skirtLength );\n\n\t\t\t\t\t\t_temp.copy( b1 ).add( sourceMesh.position );\n\t\t\t\t\t\tellipsoid.getPositionToNormal( _temp, _temp );\n\t\t\t\t\t\tb1.addScaledVector( _temp, - skirtLength );\n\n\t\t\t\t\t\tif ( smoothSkirtNormals && capNormal ) {\n\n\t\t\t\t\t\t\t_temp.fromArray( capNormal, i0 * 3 );\n\t\t\t\t\t\t\t_temp2.fromArray( capNormal, i1 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_temp.subVectors( u0, u1 );\n\t\t\t\t\t\t\t_temp2.subVectors( u0, b0 ).cross( _temp ).normalize();\n\t\t\t\t\t\t\t_temp.copy( _temp2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpushVertex( u1, _uv1, _temp2 );\n\t\t\t\t\t\tpushVertex( u0, _uv0, _temp );\n\t\t\t\t\t\tpushVertex( b0, _uv0, _temp );\n\n\t\t\t\t\t\tpushVertex( u1, _uv1, _temp2 );\n\t\t\t\t\t\tpushVertex( b0, _uv0, _temp );\n\t\t\t\t\t\tpushVertex( b1, _uv1, _temp2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst capLength = capResult.index.length;\n\t\tconst result = capResult;\n\t\tif ( botResult ) {\n\n\t\t\tconst { index, attributes } = botResult;\n\t\t\tconst offset = result.attributes.position.length / 3;\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tresult.index.push( index[ i ] + offset );\n\n\t\t\t}\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tresult.attributes[ key ].push( ...attributes[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( skirtResult ) {\n\n\t\t\tconst { index, attributes } = skirtResult;\n\t\t\tconst offset = result.attributes.position.length / 3;\n\t\t\tfor ( let i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\tresult.index.push( index[ i ] + offset );\n\n\t\t\t}\n\n\t\t\tfor ( const key in capResult.attributes ) {\n\n\t\t\t\tresult.attributes[ key ].push( ...attributes[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// offset the uvs\n\t\tconst xUvOffset = left ? 0 : - 0.5;\n\t\tconst yUvOffset = bottom ? 0 : - 0.5;\n\t\tconst uv = result.attributes.uv;\n\t\tfor ( let i = 0, l = uv.length; i < l; i += 2 ) {\n\n\t\t\tuv[ i ] = ( uv[ i ] + xUvOffset ) * 2.0;\n\t\t\tuv[ i + 1 ] = ( uv[ i + 1 ] + yUvOffset ) * 2.0;\n\n\t\t}\n\n\t\t// construct the result\n\t\tconst resultMesh = this.constructMesh( result.attributes, result.index, sourceMesh );\n\t\tresultMesh.userData.minHeight = sourceMesh.userData.minHeight;\n\t\tresultMesh.userData.maxHeight = sourceMesh.userData.maxHeight;\n\n\t\tlet materialIndex = 0;\n\t\tlet start = 0;\n\t\tresultMesh.geometry.addGroup( start, capLength, materialIndex );\n\t\tstart += capLength;\n\t\tmaterialIndex ++;\n\n\t\tif ( botResult ) {\n\n\t\t\tresultMesh.geometry.addGroup( start, botResult.index.length, materialIndex );\n\t\t\tstart += botResult.index.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\tif ( skirtResult ) {\n\n\t\t\tresultMesh.geometry.addGroup( start, skirtResult.index.length, materialIndex );\n\t\t\tstart += skirtResult.index.length;\n\t\t\tmaterialIndex ++;\n\n\t\t}\n\n\t\treturn resultMesh;\n\n\t}\n\n\tadjustVertices( info, position, offset ) {\n\n\t\tconst { ellipsoid, minLat, maxLat, minLon, maxLon } = this;\n\t\tconst { attributes, vertexIsClipped } = info;\n\t\tconst posArr = attributes.position;\n\t\tconst uvArr = attributes.uv;\n\n\t\tconst vertexCount = posArr.length / 3;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tconst uv = _uv0.fromArray( uvArr, i * 2 );\n\t\t\tif ( vertexIsClipped && vertexIsClipped[ i ] ) {\n\n\t\t\t\tif ( Math.abs( uv.x - 0.5 ) < 1e-10 ) {\n\n\t\t\t\t\tuv.x = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\tif ( Math.abs( uv.y - 0.5 ) < 1e-10 ) {\n\n\t\t\t\t\tuv.y = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\t_uv0.toArray( uvArr, i * 2 );\n\n\t\t\t}\n\n\t\t\tconst lat = MathUtils.lerp( minLat, maxLat, uv.y );\n\t\t\tconst lon = MathUtils.lerp( minLon, maxLon, uv.x );\n\t\t\tconst point = _vec.fromArray( posArr, i * 3 ).add( position );\n\t\t\tellipsoid.getPositionToCartographic( point, _cart );\n\t\t\tellipsoid.getCartographicToPosition( lat, lon, _cart.height + offset, point );\n\t\t\tpoint.sub( position );\n\t\t\tpoint.toArray( posArr, i * 3 );\n\n\t\t}\n\n\t}\n\n}\n\nfunction getUvSplitOperation( axis ) {\n\n\treturn ( geometry, i0, i1, i2, barycoord ) => {\n\n\t\tconst uv = geometry.attributes.uv;\n\t\t_uv0.fromBufferAttribute( uv, i0 );\n\t\t_uv1.fromBufferAttribute( uv, i1 );\n\t\t_uv2.fromBufferAttribute( uv, i2 );\n\n\t\treturn _uv0[ axis ] * barycoord.x + _uv1[ axis ] * barycoord.y + _uv2[ axis ] * barycoord.z - 0.5;\n\n\t};\n\n}\n","import { Vector3 } from 'three';\nimport { QuantizedMeshLoader } from './loaders/QuantizedMeshLoader.js';\nimport { TilingScheme } from './images/utils/TilingScheme.js';\nimport { ProjectionScheme } from './images/utils/ProjectionScheme.js';\nimport { QuantizedMeshClipper } from './utilities/QuantizedMeshClipper.js';\n\nconst TILE_X = Symbol( 'TILE_X' );\nconst TILE_Y = Symbol( 'TILE_Y' );\nconst TILE_LEVEL = Symbol( 'TILE_LEVEL' );\nconst TILE_AVAILABLE = Symbol( 'TILE_AVAILABLE' );\n\n// We don't know the height ranges for the tile set on load so assume a large range and\n// adjust it once the tiles have actually loaded based on the min and max height\nconst INITIAL_HEIGHT_RANGE = 1e4;\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// Checks if the given tile is available\nfunction isTileAvailable( available, level, x, y ) {\n\n\tif ( available && level < available.length ) {\n\n\t\t// TODO: consider a binary search\n\t\tconst availableSet = available[ level ];\n\t\tfor ( let i = 0, l = availableSet.length; i < l; i ++ ) {\n\n\t\t\tconst { startX, startY, endX, endY } = availableSet[ i ];\n\t\t\tif ( x >= startX && x <= endX && y >= startY && y <= endY ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n// Calculates the max level that can be loaded.\nfunction getMaxLevel( layer ) {\n\n\tconst { available = null, maxzoom = null } = layer;\n\treturn maxzoom === null ? available.length - 1 : maxzoom;\n\n}\n\n// Calculates whether metadata availability is present - returns -1 if not.\nfunction getMetadataAvailability( layer ) {\n\n\tconst { metadataAvailability = - 1 } = layer;\n\treturn metadataAvailability;\n\n}\n\n// Calculates whether the given tile should have metadata availability\nfunction getTileHasMetadata( tile, layer ) {\n\n\tconst level = tile[ TILE_LEVEL ];\n\tconst metadataAvailability = getMetadataAvailability( layer );\n\tconst maxLevel = getMaxLevel( layer );\n\n\treturn level < maxLevel && metadataAvailability !== - 1 && ( level % metadataAvailability ) === 0;\n\n}\n\n// Constructs the url for the given tile content\nfunction getContentUrl( x, y, level, version, layer ) {\n\n\treturn layer.tiles[ 0 ]\n\t\t.replace( /{\\s*z\\s*}/g, level )\n\t\t.replace( /{\\s*x\\s*}/g, x )\n\t\t.replace( /{\\s*y\\s*}/g, y )\n\t\t.replace( /{\\s*version\\s*}/g, version );\n\n}\n\nexport class QuantizedMeshPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tuseRecommendedSettings = true,\n\t\t\tskirtLength = null,\n\t\t\tsmoothSkirtNormals = true,\n\t\t\tsolid = false,\n\t\t} = options;\n\n\t\t// plugin needs to run before other plugins that fetch data since content\n\t\t// is handled and loaded in a custom way\n\t\tthis.name = 'QUANTIZED_MESH_PLUGIN';\n\t\tthis.priority = - 1000;\n\n\t\tthis.tiles = null;\n\t\tthis.layer = null;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\t\tthis.skirtLength = skirtLength;\n\t\tthis.smoothSkirtNormals = smoothSkirtNormals;\n\t\tthis.solid = solid;\n\t\tthis.attribution = null;\n\n\t\tthis.tiling = new TilingScheme();\n\t\tthis.projection = new ProjectionScheme();\n\n\t}\n\n\t// Plugin function\n\tinit( tiles ) {\n\n\t\t// TODO: should we avoid setting this globally?\n\t\ttiles.fetchOptions.headers = tiles.fetchOptions.headers || {};\n\t\ttiles.fetchOptions.headers.Accept = 'application/vnd.quantized-mesh,application/octet-stream;q=0.9';\n\n\t\tif ( this.useRecommendedSettings ) {\n\n\t\t\ttiles.errorTarget = 2;\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\n\t}\n\n\tloadRootTileSet() {\n\n\t\tconst { tiles } = this;\n\n\t\t// initialize href to resolve the root in case it's specified as a relative url\n\t\tlet url = new URL( 'layer.json', new URL( tiles.rootURL, location.href ) );\n\t\ttiles.invokeAllPlugins( plugin => url = plugin.preprocessURL ? plugin.preprocessURL( url, null ) : url );\n\n\t\treturn tiles\n\t\t\t.invokeOnePlugin( plugin => plugin.fetchData && plugin.fetchData( url, this.tiles.fetchOptions ) )\n\t\t\t.then( res => res.json() )\n\t\t\t.then( json => {\n\n\t\t\t\tthis.layer = json;\n\t\t\t\tconst {\n\t\t\t\t\tprojection: layerProjection = 'EPSG:4326',\n\t\t\t\t\textensions = [],\n\t\t\t\t\tattribution = '',\n\t\t\t\t\tavailable = null,\n\t\t\t\t} = json;\n\n\t\t\t\tconst {\n\t\t\t\t\ttiling,\n\t\t\t\t\ttiles,\n\t\t\t\t\tprojection,\n\t\t\t\t} = this;\n\n\t\t\t\t// attribution\n\t\t\t\tif ( attribution ) {\n\n\t\t\t\t\tthis.attribution = {\n\t\t\t\t\t\tvalue: attribution,\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tcollapsible: true,\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\t// extensions\n\t\t\t\tif ( extensions.length > 0 ) {\n\n\t\t\t\t\ttiles.fetchOptions.headers[ 'Accept' ] += `;extensions=${ extensions.join( '-' ) }`;\n\n\t\t\t\t}\n\n\t\t\t\t// initialize tiling, projection\n\t\t\t\tprojection.setScheme( layerProjection );\n\n\t\t\t\tconst { tileCountX, tileCountY } = projection;\n\t\t\t\ttiling.setProjection( projection );\n\t\t\t\ttiling.generateLevels( getMaxLevel( json ) + 1, tileCountX, tileCountY );\n\n\t\t\t\t// initialize children\n\t\t\t\tconst children = [];\n\t\t\t\tfor ( let x = 0; x < tileCountX; x ++ ) {\n\n\t\t\t\t\tconst child = this.createChild( 0, x, 0, available );\n\t\t\t\t\tif ( child ) {\n\n\t\t\t\t\t\tchildren.push( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// produce the tile set root\n\t\t\t\tconst tileset = {\n\t\t\t\t\tasset: {\n\t\t\t\t\t\tversion: '1.1'\n\t\t\t\t\t},\n\t\t\t\t\tgeometricError: Infinity,\n\t\t\t\t\troot: {\n\t\t\t\t\t\trefine: 'REPLACE',\n\t\t\t\t\t\tgeometricError: Infinity,\n\t\t\t\t\t\tboundingVolume: {\n\t\t\t\t\t\t\tregion: [ ...this.tiling.getContentBounds(), - INITIAL_HEIGHT_RANGE, INITIAL_HEIGHT_RANGE ],\n\t\t\t\t\t\t},\n\t\t\t\t\t\tchildren: children,\n\n\t\t\t\t\t\t[ TILE_AVAILABLE ]: available,\n\t\t\t\t\t\t[ TILE_LEVEL ]: - 1,\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tlet baseUrl = tiles.rootURL;\n\t\t\t\ttiles.invokeAllPlugins( plugin => baseUrl = plugin.preprocessURL ? plugin.preprocessURL( baseUrl, null ) : baseUrl );\n\t\t\t\ttiles.preprocessTileSet( tileset, baseUrl );\n\n\t\t\t\treturn tileset;\n\n\t\t\t} );\n\n\t}\n\n\tparseToMesh( buffer, tile, extension, uri ) {\n\n\t\tconst {\n\t\t\tskirtLength,\n\t\t\tsolid,\n\t\t\tsmoothSkirtNormals,\n\t\t\ttiles,\n\t\t} = this;\n\n\t\t// set up loader\n\t\tconst ellipsoid = tiles.ellipsoid;\n\n\t\t// split the parent tile if needed\n\t\tlet result;\n\t\tif ( extension === 'quantized_tile_split' ) {\n\n\t\t\t// split the parent tile\n\t\t\tconst searchParams = new URL( uri ).searchParams;\n\t\t\tconst left = searchParams.get( 'left' ) === 'true';\n\t\t\tconst bottom = searchParams.get( 'bottom' ) === 'true';\n\n\t\t\t// parse the tile data\n\t\t\tconst clipper = new QuantizedMeshClipper();\n\t\t\tclipper.ellipsoid.copy( ellipsoid );\n\t\t\tclipper.solid = solid;\n\t\t\tclipper.smoothSkirtNormals = smoothSkirtNormals;\n\t\t\tclipper.skirtLength = skirtLength === null ? tile.geometricError : skirtLength;\n\n\t\t\tconst [ west, south, east, north ] = tile.parent.boundingVolume.region;\n\t\t\tclipper.minLat = south;\n\t\t\tclipper.maxLat = north;\n\t\t\tclipper.minLon = west;\n\t\t\tclipper.maxLon = east;\n\n\t\t\tresult = clipper.clipToQuadrant( tile.parent.cached.scene, left, bottom );\n\n\t\t} else if ( extension === 'terrain' ) {\n\n\t\t\tconst loader = new QuantizedMeshLoader( tiles.manager );\n\t\t\tloader.ellipsoid.copy( ellipsoid );\n\t\t\tloader.solid = solid;\n\t\t\tloader.smoothSkirtNormals = smoothSkirtNormals;\n\t\t\tloader.skirtLength = skirtLength === null ? tile.geometricError : skirtLength;\n\n\t\t\tconst [ west, south, east, north ] = tile.boundingVolume.region;\n\t\t\tloader.minLat = south;\n\t\t\tloader.maxLat = north;\n\t\t\tloader.minLon = west;\n\t\t\tloader.maxLon = east;\n\n\t\t\tresult = loader.parse( buffer );\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// adjust the bounding region to be more accurate based on the contents of the terrain file\n\t\t// NOTE: The debug region bounds are only created after the tile is first shown so the debug\n\t\t// region bounding volume will have the correct dimensions.\n\t\tconst { minHeight, maxHeight, metadata } = result.userData;\n\t\ttile.boundingVolume.region[ 4 ] = minHeight;\n\t\ttile.boundingVolume.region[ 5 ] = maxHeight;\n\t\ttile.cached.boundingVolume.setRegionData( ellipsoid, ...tile.boundingVolume.region );\n\n\t\t// use the geometric error value if it's present\n\t\tif ( metadata ) {\n\n\t\t\tif ( 'geometricerror' in metadata ) {\n\n\t\t\t\ttile.geometricError = metadata.geometricerror;\n\n\t\t\t}\n\n\t\t\t// if the tile hasn't been expanded yet and isn't in the queue to do so then\n\t\t\t// mark it for expansion again\n\t\t\tconst hasMetadata = getTileHasMetadata( tile, this.layer );\n\t\t\tif ( hasMetadata && 'available' in metadata && tile.children.length === 0 ) {\n\n\t\t\t\t// add an offset to account for the current and previous layers\n\t\t\t\ttile[ TILE_AVAILABLE ] = [\n\t\t\t\t\t...new Array( tile[ TILE_LEVEL ] + 1 ).fill( null ),\n\t\t\t\t\t...metadata.available,\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// NOTE: we expand children only once the parent mesh data is loaded to ensure the mesh\n\t\t// data is ready for clipping. It's possible that this child data gets to the parse stage\n\t\t// first, otherwise, while the parent is still downloading.\n\t\t// Ideally we would be able to guarantee parents are loaded first but this is an odd case.\n\t\tthis.expandChildren( tile );\n\n\t\treturn result;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.attribution ) {\n\n\t\t\ttarget.push( this.attribution );\n\n\t\t}\n\n\t}\n\n\t// Local functions\n\tcreateChild( level, x, y, available ) {\n\n\t\tconst { tiles, layer, tiling, projection } = this;\n\t\tconst ellipsoid = tiles.ellipsoid;\n\n\t\t// metadata availability will return \"null\" if there are no more children but we\n\t\t// have to always load the root tile data.\n\t\tconst isAvailable = available === null && level === 0 || isTileAvailable( available, level, x, y );\n\t\tconst url = getContentUrl( x, y, level, 1, layer );\n\t\tconst region = [ ...tiling.getTileBounds( x, y, level ), - INITIAL_HEIGHT_RANGE, INITIAL_HEIGHT_RANGE ];\n\t\tconst [ /* west */, south, /* east */, north, /* minHeight */, maxHeight ] = region;\n\t\tconst midLat = ( south > 0 ) !== ( north > 0 ) ? 0 : Math.min( Math.abs( south ), Math.abs( north ) );\n\n\t\t// get the projected perimeter\n\t\tellipsoid.getCartographicToPosition( midLat, 0, maxHeight, _vec );\n\t\t_vec.z = 0;\n\n\t\t// https://github.com/CesiumGS/cesium/blob/53889cbed2a91d38e0fae4b6f2dcf6783632fc92/packages/engine/Source/Scene/QuadtreeTileProvider.js#L24-L31\n\t\t// Implicit quantized mesh tile error halves with every layer\n\t\tconst tileCountX = projection.tileCountX;\n\t\tconst maxRadius = Math.max( ...ellipsoid.radius );\n\t\tconst rootGeometricError = maxRadius * 2 * Math.PI * 0.25 / ( 65 * tileCountX );\n\t\tconst geometricError = rootGeometricError / ( 2 ** level );\n\n\t\t// Create the child\n\t\tconst tile = {\n\t\t\t[ TILE_AVAILABLE ]: null,\n\t\t\t[ TILE_LEVEL ]: level,\n\t\t\t[ TILE_X ]: x,\n\t\t\t[ TILE_Y ]: y,\n\t\t\trefine: 'REPLACE',\n\t\t\tgeometricError: geometricError,\n\t\t\tboundingVolume: { region },\n\t\t\tcontent: isAvailable ? { uri: url } : null,\n\t\t\tchildren: []\n\t\t};\n\n\t\t// if we're relying on tile metadata availability then skip storing the tile metadata\n\t\tif ( ! getTileHasMetadata( tile, layer ) ) {\n\n\t\t\ttile[ TILE_AVAILABLE ] = available;\n\n\t\t}\n\n\t\treturn tile;\n\n\t}\n\n\texpandChildren( tile ) {\n\n\t\tconst level = tile[ TILE_LEVEL ];\n\t\tconst x = tile[ TILE_X ];\n\t\tconst y = tile[ TILE_Y ];\n\t\tconst available = tile[ TILE_AVAILABLE ];\n\n\t\t// only expand down to the highest level\n\t\tif ( level >= this.tiling.maxLevel ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet hasChildren = false;\n\t\tfor ( let cx = 0; cx < 2; cx ++ ) {\n\n\t\t\tfor ( let cy = 0; cy < 2; cy ++ ) {\n\n\t\t\t\tconst child = this.createChild( level + 1, 2 * x + cx, 2 * y + cy, available );\n\t\t\t\tif ( child.content !== null ) {\n\n\t\t\t\t\ttile.children.push( child );\n\t\t\t\t\thasChildren = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttile.children.push( child );\n\t\t\t\t\tchild.content = { uri: `tile.quantized_tile_split?bottom=${ cy === 0 }&left=${ cx === 0 }` };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! hasChildren ) {\n\n\t\t\ttile.children.length = 0;\n\n\t\t}\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\t// if this is our custom url indicating a tile split then return fake response\n\t\tif ( /quantized_tile_split/.test( uri ) ) {\n\n\t\t\treturn new ArrayBuffer();\n\n\t\t}\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\t// dispose of the available array since we will get it again if this tile is loaded\n\t\tif ( getTileHasMetadata( tile, this.layer ) ) {\n\n\t\t\ttile[ TILE_AVAILABLE ] = null;\n\n\t\t}\n\n\t\t// Note: we remove all children always because child tiles can rely on splitting parent tiles\n\t\t// and we can find ourselves in a situation where a child tile is ready first but the parent tile\n\t\t// hasn't loaded, causing a stall / race condition in the parsing queue. To avoid this dependency\n\t\t// we just remove all children and generate them again one the parent is loaded.\n\t\t// Only get rid of the children if this plugin was responsible for them.\n\t\tif ( TILE_AVAILABLE in tile ) {\n\n\t\t\ttile.children.forEach( child => {\n\n\t\t\t\t// TODO: there should be a reliable way for removing children like this.\n\t\t\t\tthis.tiles.processNodeQueue.remove( child );\n\n\t\t\t} );\n\t\t\ttile.children.length = 0;\n\t\t\ttile.__childrenProcessed = 0;\n\n\t\t}\n\n\t}\n\n}\n","import { CesiumIonAuth } from '3d-tiles-renderer/core/plugins';\nimport { GoogleCloudAuthPlugin } from './GoogleCloudAuthPlugin.js';\nimport { TMSTilesPlugin } from './images/EPSGTilesPlugin.js';\nimport { QuantizedMeshPlugin } from './QuantizedMeshPlugin.js';\n\nexport class CesiumIonAuthPlugin {\n\n\tget apiToken() {\n\n\t\treturn this.auth.apiToken;\n\n\t}\n\n\tset apiToken( v ) {\n\n\t\tthis.auth.apiToken = v;\n\n\t}\n\n\tget autoRefreshToken() {\n\n\t\treturn this.auth.autoRefreshToken;\n\n\t}\n\n\tset autoRefreshToken( v ) {\n\n\t\tthis.auth.autoRefreshToken = v;\n\n\t}\n\n\tconstructor( { apiToken, assetId = null, autoRefreshToken = false, useRecommendedSettings = true } ) {\n\n\t\tthis.name = 'CESIUM_ION_AUTH_PLUGIN';\n\t\tthis.auth = new CesiumIonAuth( { apiToken, autoRefreshToken } );\n\n\t\tthis.assetId = assetId;\n\t\tthis.autoRefreshToken = autoRefreshToken;\n\t\tthis.useRecommendedSettings = useRecommendedSettings;\n\t\tthis.tiles = null;\n\n\t\tthis._tileSetVersion = - 1;\n\t\tthis._attributions = [];\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tif ( this.assetId !== null ) {\n\n\t\t\ttiles.rootURL = `https://api.cesium.com/v1/assets/${ this.assetId }/endpoint`;\n\n\t\t}\n\n\t\tthis.tiles = tiles;\n\t\tthis.auth.authURL = tiles.rootURL;\n\n\t\t// reset the tiles in case this plugin was removed and re-added\n\t\ttiles.resetFailedTiles();\n\n\t}\n\n\tloadRootTileSet() {\n\n\t\t// ensure we have an up-to-date token and root url, then trigger the internal\n\t\t// root tile set load function\n\t\treturn this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis._initializeFromAsset( json );\n\t\t\t\treturn this.tiles.invokeOnePlugin( plugin => plugin !== this && plugin.loadRootTileSet && plugin.loadRootTileSet() );\n\n\t\t\t} )\n\t\t\t.catch( error => {\n\n\t\t\t\tthis.tiles.dispatchEvent( {\n\t\t\t\t\ttype: 'load-error',\n\t\t\t\t\ttile: null,\n\t\t\t\t\terror,\n\t\t\t\t\turl: this.auth.authURL,\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t}\n\n\tpreprocessURL( uri ) {\n\n\t\turi = new URL( uri );\n\t\tif ( /^http/.test( uri.protocol ) && this._tileSetVersion != - 1 ) {\n\n\t\t\turi.searchParams.set( 'v', this._tileSetVersion );\n\n\t\t}\n\t\treturn uri.toString();\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\tconst tiles = this.tiles;\n\t\tif ( tiles.getPluginByName( 'GOOGLE_CLOUD_AUTH_PLUGIN' ) !== null ) {\n\n\t\t\treturn null;\n\n\t\t} else {\n\n\t\t\treturn this.auth.fetch( uri, options );\n\n\t\t}\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.tiles.visibleTiles.size > 0 ) {\n\n\t\t\ttarget.push( ...this._attributions );\n\n\t\t}\n\n\t}\n\n\t_initializeFromAsset( json ) {\n\n\t\tconst tiles = this.tiles;\n\t\tif ( 'externalType' in json ) {\n\n\t\t\tconst url = new URL( json.options.url );\n\t\t\ttiles.rootURL = json.options.url;\n\n\t\t\t// if the tile set is \"external\" then assume it's a google API tile set\n\t\t\ttiles.registerPlugin( new GoogleCloudAuthPlugin( {\n\t\t\t\tapiToken: url.searchParams.get( 'key' ),\n\t\t\t\tautoRefreshToken: this.autoRefreshToken,\n\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t} ) );\n\n\t\t} else {\n\n\t\t\t// GLTF\n\t\t\t// CZML\n\t\t\t// KML\n\t\t\t// GEOJSON\n\t\t\tif ( json.type === 'TERRAIN' && tiles.getPluginByName( 'QUANTIZED_MESH_PLUGIN' ) === null ) {\n\n\t\t\t\ttiles.registerPlugin( new QuantizedMeshPlugin( {\n\t\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t\t} ) );\n\n\t\t\t} else if ( json.type === 'IMAGERY' && tiles.getPluginByName( 'TMS_TILES_PLUGIN' ) === null ) {\n\n\t\t\t\ttiles.registerPlugin( new TMSTilesPlugin( {\n\t\t\t\t\tuseRecommendedSettings: this.useRecommendedSettings,\n\t\t\t\t\tshape: 'ellipsoid',\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\ttiles.rootURL = json.url;\n\n\t\t\t// save the version key if present\n\t\t\tconst url = new URL( json.url );\n\t\t\tif ( url.searchParams.has( 'v' ) && this._tileSetVersion === - 1 ) {\n\n\t\t\t\tthis._tileSetVersion = url.searchParams.get( 'v' );\n\n\t\t\t}\n\n\t\t\tif ( json.attributions ) {\n\n\t\t\t\tthis._attributions = json.attributions.map( att => ( {\n\t\t\t\t\tvalue: att.html,\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\tcollapsible: att.collapsible,\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4 } from 'three';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nexport class UpdateOnChangePlugin {\n\n\tconstructor() {\n\n\t\tthis.name = 'UPDATE_ON_CHANGE_PLUGIN';\n\t\tthis.tiles = null;\n\t\tthis.needsUpdate = false;\n\t\tthis.cameraMatrices = new Map();\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\t// register callbacks to add cameras and force a new update\n\t\tthis._needsUpdateCallback = () => {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t};\n\t\tthis._onCameraAdd = ( { camera } ) => {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cameraMatrices.set( camera, new Matrix4() );\n\n\t\t};\n\t\tthis._onCameraDelete = ( { camera } ) => {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cameraMatrices.delete( camera );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'needs-update', this._needsUpdateCallback );\n\t\ttiles.addEventListener( 'add-camera', this._onCameraAdd );\n\t\ttiles.addEventListener( 'delete-camera', this._onCameraDelete );\n\t\ttiles.addEventListener( 'camera-resolution-change', this._needsUpdateCallback );\n\n\t\t// register any already-present cameras\n\t\ttiles.cameras.forEach( camera => {\n\n\t\t\tthis._onCameraAdd( { camera } );\n\n\t\t} );\n\n\t}\n\n\tdoTilesNeedUpdate() {\n\n\t\tconst tiles = this.tiles;\n\t\tlet didCamerasChange = false;\n\t\tthis.cameraMatrices.forEach( ( matrix, camera ) => {\n\n\t\t\t// check if the camera position or frustum changed by comparing the MVP\n\t\t\t// matrix between frames\n\t\t\t_matrix\n\t\t\t\t.copy( tiles.group.matrixWorld )\n\t\t\t\t.premultiply( camera.matrixWorldInverse )\n\t\t\t\t.premultiply( camera.projectionMatrixInverse );\n\n\t\t\tdidCamerasChange = didCamerasChange || ! _matrix.equals( matrix );\n\t\t\tmatrix.copy( _matrix );\n\n\t\t} );\n\n\t\tconst needsUpdate = this.needsUpdate;\n\t\tthis.needsUpdate = false;\n\n\t\treturn needsUpdate || didCamerasChange;\n\n\t}\n\n\tpreprocessNode() {\n\n\t\t// trigger a new update when nodes are processed because hte process happens asynchronously\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tconst tiles = this.tiles;\n\t\ttiles.removeEventListener( 'camera-resolution-change', this._needsUpdateCallback );\n\t\ttiles.removeEventListener( 'needs-update', this._needsUpdateCallback );\n\t\ttiles.removeEventListener( 'add-camera', this._onCameraAdd );\n\t\ttiles.removeEventListener( 'delete-camera', this._onCameraDelete );\n\n\t}\n\n}\n","import { Vector3, LinearFilter, BufferAttribute, MathUtils } from 'three';\n\nconst _vec = new Vector3();\nfunction compressAttribute( attribute, arrayType ) {\n\n\tif ( attribute.isInterleavedBufferAttribute || attribute.array instanceof arrayType ) {\n\n\t\treturn attribute;\n\n\t}\n\n\tconst signed = arrayType === Int8Array || arrayType === Int16Array || arrayType === Int32Array;\n\tconst minValue = signed ? - 1 : 0;\n\n\tconst array = new arrayType( attribute.count * attribute.itemSize );\n\tconst newAttribute = new BufferAttribute( array, attribute.itemSize, true );\n\tconst itemSize = attribute.itemSize;\n\tconst count = attribute.count;\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\tconst v = MathUtils.clamp( attribute.getComponent( i, j ), minValue, 1 );\n\t\t\tnewAttribute.setComponent( i, j, v );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\nfunction compressPositionAttribute( mesh, arrayType = Int16Array ) {\n\n\tconst geometry = mesh.geometry;\n\tconst attributes = geometry.attributes;\n\tconst attribute = attributes.position;\n\n\t// skip if it's already compressed to the provided level\n\tif ( attribute.isInterleavedBufferAttribute || attribute.array instanceof arrayType ) {\n\n\t\treturn attribute;\n\n\t}\n\n\t// new attribute data\n\tconst array = new arrayType( attribute.count * attribute.itemSize );\n\tconst newAttribute = new BufferAttribute( array, attribute.itemSize, false );\n\tconst itemSize = attribute.itemSize;\n\tconst count = attribute.count;\n\n\t// bounding box stride\n\t// TODO: the bounding box is computed every time even if it already exists because\n\t// it's possible that the encoded value is incorrect causing artifacts\n\tgeometry.computeBoundingBox();\n\n\tconst boundingBox = geometry.boundingBox;\n\tconst { min, max } = boundingBox;\n\n\t// array range\n\tconst maxValue = 2 ** ( 8 * arrayType.BYTES_PER_ELEMENT - 1 ) - 1;\n\tconst minValue = - maxValue;\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\tconst key = j === 0 ? 'x' : j === 1 ? 'y' : 'z';\n\t\t\tconst bbMinValue = min[ key ];\n\t\t\tconst bbMaxValue = max[ key ];\n\n\t\t\t// scale the geometry values to the integer range\n\t\t\tconst v = MathUtils.mapLinear(\n\t\t\t\tattribute.getComponent( i, j ),\n\t\t\t\tbbMinValue, bbMaxValue,\n\t\t\t\tminValue, maxValue,\n\t\t\t);\n\n\t\t\tnewAttribute.setComponent( i, j, v );\n\n\t\t}\n\n\t}\n\n\t// shift the mesh to the center of the bounds\n\tboundingBox\n\t\t.getCenter( _vec )\n\t\t.multiply( mesh.scale )\n\t\t.applyQuaternion( mesh.quaternion );\n\tmesh.position.add( _vec );\n\n\t// adjust the scale to accommodate the new geometry data range\n\tmesh.scale.x *= 0.5 * ( max.x - min.x ) / maxValue;\n\tmesh.scale.y *= 0.5 * ( max.y - min.y ) / maxValue;\n\tmesh.scale.z *= 0.5 * ( max.z - min.z ) / maxValue;\n\n\tattributes.position = newAttribute;\n\tmesh.geometry.boundingBox = null;\n\tmesh.geometry.boundingSphere = null;\n\n\tmesh.updateMatrixWorld();\n\n}\n\nexport class TileCompressionPlugin {\n\n\tconstructor( options ) {\n\n\t\tthis._options = {\n\t\t\t// whether to generate normals if they don't already exist.\n\t\t\tgenerateNormals: false,\n\n\t\t\t// whether to disable use of mipmaps since they are typically not necessary\n\t\t\t// with something like 3d tiles.\n\t\t\tdisableMipmaps: true,\n\n\t\t\t// whether to compress certain attributes\n\t\t\tcompressIndex: true,\n\t\t\tcompressNormals: false,\n\t\t\tcompressUvs: false,\n\t\t\tcompressPosition: false,\n\n\t\t\t// the TypedArray type to use when compressing the attributes\n\t\t\tuvType: Int8Array,\n\t\t\tnormalType: Int8Array,\n\t\t\tpositionType: Int16Array,\n\n\t\t\t...options,\n\t\t};\n\n\t\tthis.name = 'TILES_COMPRESSION_PLUGIN';\n\t\tthis.priority = - 100;\n\n\t}\n\n\tprocessTileModel( scene, tile ) {\n\n\t\tconst {\n\t\t\tgenerateNormals,\n\n\t\t\tdisableMipmaps,\n\t\t\tcompressIndex,\n\t\t\tcompressUvs,\n\t\t\tcompressNormals,\n\t\t\tcompressPosition,\n\n\t\t\tuvType,\n\t\t\tnormalType,\n\t\t\tpositionType,\n\t\t} = this._options;\n\n\t\tscene.traverse( c => {\n\n\t\t\t// handle materials\n\t\t\tif ( c.material && disableMipmaps ) {\n\n\t\t\t\tconst material = c.material;\n\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\tif ( value && value.isTexture && value.generateMipmaps ) {\n\n\t\t\t\t\t\tvalue.generateMipmaps = false;\n\t\t\t\t\t\tvalue.minFilter = LinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// handle geometry attribute compression\n\t\t\tif ( c.geometry ) {\n\n\t\t\t\tconst geometry = c.geometry;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tif ( compressUvs ) {\n\n\t\t\t\t\tconst { uv, uv1, uv2, uv3 } = attributes;\n\t\t\t\t\tif ( uv ) attributes.uv = compressAttribute( uv, uvType );\n\t\t\t\t\tif ( uv1 ) attributes.uv1 = compressAttribute( uv1, uvType );\n\t\t\t\t\tif ( uv2 ) attributes.uv2 = compressAttribute( uv2, uvType );\n\t\t\t\t\tif ( uv3 ) attributes.uv3 = compressAttribute( uv3, uvType );\n\n\t\t\t\t}\n\n\t\t\t\tif ( generateNormals && ! attributes.normals ) {\n\n\t\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t\t}\n\n\t\t\t\tif ( compressNormals && attributes.normals ) {\n\n\t\t\t\t\tattributes.normals = compressAttribute( attributes.normals, normalType );\n\n\t\t\t\t}\n\n\t\t\t\tif ( compressPosition ) {\n\n\t\t\t\t\tcompressPositionAttribute( c, positionType );\n\n\t\t\t\t}\n\n\t\t\t\tif ( compressIndex && geometry.index ) {\n\n\t\t\t\t\tconst vertCount = attributes.position.count;\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tconst type = vertCount > 65535 ? Uint32Array : vertCount > 255 ? Uint16Array : Uint8Array;\n\t\t\t\t\tif ( ! ( index.array instanceof type ) ) {\n\n\t\t\t\t\t\tconst array = new type( geometry.index.count );\n\t\t\t\t\t\tarray.set( index.array );\n\n\t\t\t\t\t\tconst attribute = new BufferAttribute( array, 1 );\n\t\t\t\t\t\tgeometry.setIndex( attribute );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import {\n\tVector2,\n\tVector3,\n\tVector4,\n\tMatrix2,\n\tMatrix3,\n\tMatrix4,\n} from 'three';\n\n// returns the field in the object with a resolved default\nexport function getField( object, key, def ) {\n\n\treturn object && key in object ? object[ key ] : def;\n\n}\n\n// checks the structural metadata type\nexport function isNumericType( type ) {\n\n\treturn type !== 'BOOLEAN' && type !== 'STRING' && type !== 'ENUM';\n\n}\n\n// check if the class property type is a float component type value\nexport function isFloatComponentType( type ) {\n\n\treturn /^FLOAT/.test( type );\n\n}\n\n// check if the class property type is a vector type\nexport function isVectorType( type ) {\n\n\treturn /^VEC/.test( type );\n\n}\n\n// check if the class property type is a matrix type\nexport function isMatrixType( type ) {\n\n\treturn /^MAT/.test( type );\n\n}\n\n// returns a value from the given buffer of the given type\nexport function readDataFromBufferToType( buffer, offset, type, target = null ) {\n\n\tif ( isMatrixType( type ) ) {\n\n\t\treturn target.fromArray( buffer, offset );\n\n\t} else if ( isVectorType( type ) ) {\n\n\t\treturn target.fromArray( buffer, offset );\n\n\t} else {\n\n\t\treturn buffer[ offset ];\n\n\t}\n\n}\n\n// gets a new instance of the given structural metadata type\nexport function getTypeInstance( property ) {\n\n\tconst { type, componentType } = property;\n\tswitch ( type ) {\n\n\t\tcase 'SCALAR': return componentType === 'INT64' ? 0n : 0;\n\t\tcase 'VEC2': return new Vector2();\n\t\tcase 'VEC3': return new Vector3();\n\t\tcase 'VEC4': return new Vector4();\n\t\tcase 'MAT2': return new Matrix2();\n\t\tcase 'MAT3': return new Matrix3();\n\t\tcase 'MAT4': return new Matrix4();\n\t\tcase 'BOOLEAN': return false;\n\t\tcase 'STRING': return '';\n\n\t\t// the final value for enums is a string but are represented as integers\n\t\t// during intermediate steps\n\t\tcase 'ENUM': return 0;\n\n\t}\n\n}\n\n// returns false if the given value is not of \"type\"\nexport function isTypeInstance( type, value ) {\n\n\tif ( value === null || value === undefined ) {\n\n\t\treturn false;\n\n\t}\n\n\tswitch ( type ) {\n\n\t\tcase 'SCALAR': return typeof value === 'number' || typeof value === 'bigint';\n\t\tcase 'VEC2': return value.isVector2;\n\t\tcase 'VEC3': return value.isVector3;\n\t\tcase 'VEC4': return value.isVector4;\n\t\tcase 'MAT2': return value.isMatrix2;\n\t\tcase 'MAT3': return value.isMatrix3;\n\t\tcase 'MAT4': return value.isMatrix4;\n\t\tcase 'BOOLEAN': return typeof value === 'boolean';\n\t\tcase 'STRING': return typeof value === 'string';\n\t\tcase 'ENUM': return typeof value === 'number' || typeof value === 'bigint';\n\n\t}\n\n\tthrow new Error( 'ClassProperty: invalid type.' );\n\n}\n\n// gets a new numeric array constructor from the given structural metadata type\nexport function getArrayConstructorFromComponentType( componentType, type = null ) {\n\n\tswitch ( componentType ) {\n\n\t\tcase 'INT8': return Int8Array;\n\t\tcase 'INT16': return Int16Array;\n\t\tcase 'INT32': return Int32Array;\n\t\tcase 'INT64': return BigInt64Array;\n\n\t\tcase 'UINT8': return Uint8Array;\n\t\tcase 'UINT16': return Uint16Array;\n\t\tcase 'UINT32': return Uint32Array;\n\t\tcase 'UINT64': return BigUint64Array;\n\n\t\tcase 'FLOAT32': return Float32Array;\n\t\tcase 'FLOAT64': return Float64Array;\n\n\t}\n\n\tswitch ( type ) {\n\n\t\tcase 'BOOLEAN': return Uint8Array;\n\t\tcase 'STRING': return Uint8Array;\n\n\t}\n\n\tthrow new Error( 'ClassProperty: invalid type.' );\n\n}\n\n// resolve a full default value for the given property including arrays\nexport function resolveDefault( property, target = null ) {\n\n\tconst array = property.array;\n\tif ( array ) {\n\n\t\ttarget = target && Array.isArray( target ) ? target : [];\n\t\ttarget.length = property.count;\n\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\ttarget[ i ] = resolveDefaultElement( property, target[ i ] );\n\n\t\t}\n\n\t} else {\n\n\t\ttarget = resolveDefaultElement( property, target );\n\n\t}\n\n\treturn target;\n\n}\n\n// gets the default value of the given type\nexport function resolveDefaultElement( property, target = null ) {\n\n\tconst defaultValue = property.default;\n\tconst type = property.type;\n\n\ttarget = target || getTypeInstance( property );\n\n\tif ( defaultValue === null ) {\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 'SCALAR': return 0;\n\t\t\tcase 'VEC2': return target.set( 0, 0 );\n\t\t\tcase 'VEC3': return target.set( 0, 0, 0 );\n\t\t\tcase 'VEC4': return target.set( 0, 0, 0, 0 );\n\t\t\tcase 'MAT2': return target.identity();\n\t\t\tcase 'MAT3': return target.identity();\n\t\t\tcase 'MAT4': return target.identity();\n\t\t\tcase 'BOOLEAN': return false;\n\t\t\tcase 'STRING': return '';\n\t\t\tcase 'ENUM': return '';\n\n\t\t}\n\n\t\tthrow new Error( 'ClassProperty: invalid type.' );\n\n\t} else {\n\n\t\tif ( isMatrixType( type ) ) {\n\n\t\t\ttarget.fromArray( defaultValue );\n\n\t\t} else if ( isVectorType( type ) ) {\n\n\t\t\ttarget.fromArray( defaultValue );\n\n\t\t} else {\n\n\t\t\treturn defaultValue;\n\n\t\t}\n\n\t}\n\n}\n\n// check for of instances of \"no data\" in the given target value and adjust them to the\n// default value.\nexport function resolveNoData( property, target ) {\n\n\tif ( property.noData === null ) {\n\n\t\treturn target;\n\n\t}\n\n\tconst noData = property.noData;\n\tconst type = property.type;\n\tif ( Array.isArray( target ) ) {\n\n\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\ttarget[ i ] = performResolution( target[ i ] );\n\n\t\t}\n\n\t} else {\n\n\t\ttarget = performResolution( target );\n\n\t}\n\n\treturn target;\n\n\t// replace the value with a default if no data is encountered\n\tfunction performResolution( target ) {\n\n\t\tif ( isNoDataEqual( target ) ) {\n\n\t\t\ttarget = resolveDefaultElement( property, target );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// checks if the given value is equal to the no data value\n\tfunction isNoDataEqual( value ) {\n\n\t\tif ( isMatrixType( type ) ) {\n\n\t\t\tconst elements = value.elements;\n\t\t\tfor ( let i = 0, l = noData.length; i < l; i ++ ) {\n\n\t\t\t\tif ( noData[ i ] !== elements[ i ] ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else if ( isVectorType( type ) ) {\n\n\t\t\tfor ( let i = 0, l = noData.length; i < l; i ++ ) {\n\n\t\t\t\tif ( noData[ i ] !== value.getComponent( i ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn noData === value;\n\n\t\t}\n\n\t}\n\n}\n\nexport function normalizeValue( componentType, v ) {\n\n\t// formulas defined here but normalizing 64 bit ints will result in precision loss:\n\t// https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata/#normalized-values\n\tswitch ( componentType ) {\n\n\t\tcase 'INT8': return Math.max( v / 127.0, - 1.0 );\n\t\tcase 'INT16': return Math.max( v, 32767.0, - 1.0 );\n\t\tcase 'INT32': return Math.max( v / 2147483647.0, - 1.0 );\n\t\tcase 'INT64': return Math.max( Number( v ) / 9223372036854775807.0, - 1.0 ); // eslint-disable-line no-loss-of-precision\n\n\t\tcase 'UINT8': return v / 255.0;\n\t\tcase 'UINT16': return v / 65535.0;\n\t\tcase 'UINT32': return v / 4294967295.0;\n\t\tcase 'UINT64': return Number( v ) / 18446744073709551615.0; // eslint-disable-line no-loss-of-precision\n\n\t}\n\n}\n\n// scales the value based on property settings\n// the provided target value is normalized, scaled, and then offset if numeric\nexport function adjustValueScaleOffset( property, target ) {\n\n\tconst {\n\t\ttype,\n\t\tcomponentType,\n\t\tscale,\n\t\toffset,\n\t\tnormalized,\n\t} = property;\n\n\tif ( Array.isArray( target ) ) {\n\n\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\ttarget[ i ] = adjustFromType( target[ i ] );\n\n\t\t}\n\n\t} else {\n\n\t\ttarget = adjustFromType( target );\n\n\t}\n\n\treturn target;\n\n\tfunction adjustFromType( value ) {\n\n\t\tif ( isMatrixType( type ) ) {\n\n\t\t\tvalue = adjustMatrix( value );\n\n\t\t} else if ( isVectorType( type ) ) {\n\n\t\t\tvalue = adjustVector( value );\n\n\t\t} else {\n\n\t\t\tvalue = adjustScalar( value );\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\tfunction adjustVector( value ) {\n\n\t\tvalue.x = adjustScalar( value.x );\n\t\tvalue.y = adjustScalar( value.y );\n\t\tif ( 'z' in value ) value.z = adjustScalar( value.z );\n\t\tif ( 'w' in value ) value.w = adjustScalar( value.w );\n\t\treturn value;\n\n\t}\n\n\tfunction adjustMatrix( value ) {\n\n\t\tconst elements = value.elements;\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\telements[ i ] = adjustScalar( elements[ i ] );\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\tfunction adjustScalar( value ) {\n\n\t\tif ( normalized ) {\n\n\t\t\tvalue = normalizeValue( componentType, value );\n\n\t\t}\n\n\t\tif ( normalized || isFloatComponentType( componentType ) ) {\n\n\t\t\tvalue = value * scale + offset;\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n}\n\n// Shape the given target object based on the provided property. If overrideCount is\n// provided then it will be used to specify the array length.\nexport function initializeFromProperty( property, target, overrideCount = null ) {\n\n\tif ( property.array ) {\n\n\t\tif ( ! Array.isArray( target ) ) {\n\n\t\t\ttarget = new Array( property.count || 0 );\n\n\t\t}\n\n\t\ttarget.length = overrideCount !== null ? overrideCount : property.count;\n\n\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\tif ( ! isTypeInstance( property.type, target[ i ] ) ) {\n\n\t\t\t\ttarget[ i ] = getTypeInstance( property );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tif ( ! isTypeInstance( property.type, target ) ) {\n\n\t\t\ttarget = getTypeInstance( property );\n\n\t\t}\n\n\t}\n\n\treturn target;\n\n}\n\n// Shape the \"target\" object based on the provided set of properties\nexport function initializeFromClass( properties, target ) {\n\n\t// remove unused fields\n\tfor ( const key in target ) {\n\n\t\tif ( ! ( key in properties ) ) {\n\n\t\t\tdelete target[ key ];\n\n\t\t}\n\n\t}\n\n\t// add and adjust any fields required by the set of properties\n\tfor ( const key in properties ) {\n\n\t\tconst prop = properties[ key ];\n\t\ttarget[ key ] = initializeFromProperty( prop, target[ key ] );\n\n\t}\n\n}\n\n// Returns the number of components required for the given type\nexport function typeToComponentCount( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 'ENUM': return 1;\n\t\tcase 'SCALAR': return 1;\n\t\tcase 'VEC2': return 2;\n\t\tcase 'VEC3': return 3;\n\t\tcase 'VEC4': return 4;\n\t\tcase 'MAT2': return 4;\n\t\tcase 'MAT3': return 9;\n\t\tcase 'MAT4': return 16;\n\n\t\t// unused\n\t\tcase 'BOOLEAN': return - 1;\n\t\tcase 'STRING': return - 1;\n\t\tdefault: return - 1;\n\n\t}\n\n}\n","import {\n\tinitializeFromProperty,\n\tadjustValueScaleOffset,\n\tgetField,\n\tisNumericType,\n\tresolveDefaultElement,\n\tresolveNoData,\n\tresolveDefault,\n} from '../utilities/ClassPropertyHelpers.js';\n\nexport class ClassProperty {\n\n\tconstructor( enums, property, accessorProperty = null ) {\n\n\t\t// initialize defaults for class property info\n\t\tthis.name = property.name || null;\n\t\tthis.description = property.description || null;\n\t\tthis.type = property.type;\n\t\tthis.componentType = property.componentType || null;\n\t\tthis.enumType = property.enumType || null;\n\t\tthis.array = property.array || false;\n\t\tthis.count = property.count || 0;\n\t\tthis.normalized = property.normalized || false;\n\t\tthis.offset = property.offset || 0;\n\t\tthis.scale = getField( property, 'scale', 1 );\n\t\tthis.max = getField( property, 'max', Infinity );\n\t\tthis.min = getField( property, 'min', - Infinity );\n\t\tthis.required = property.required || false;\n\t\tthis.noData = getField( property, 'noData', null );\n\t\tthis.default = getField( property, 'default', null );\n\t\tthis.semantic = getField( property, 'semantic', null );\n\t\tthis.enumSet = null;\n\t\tthis.accessorProperty = accessorProperty;\n\n\t\t// accessor properties can override min, max, offset, and scale values\n\t\tif ( accessorProperty ) {\n\n\t\t\tthis.offset = getField( accessorProperty, 'offset', this.offset );\n\t\t\tthis.scale = getField( accessorProperty, 'scale', this.scale );\n\t\t\tthis.max = getField( accessorProperty, 'max', this.max );\n\t\t\tthis.min = getField( accessorProperty, 'min', this.min );\n\n\t\t}\n\n\t\t// get the component type for the provided enum\n\t\tif ( property.type === 'ENUM' ) {\n\n\t\t\tthis.enumSet = enums[ this.enumType ];\n\t\t\tif ( this.componentType === null ) {\n\n\t\t\t\tthis.componentType = getField( this.enumSet, 'valueType', 'UINT16' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// shape the given target to match the data type of the property\n\t// enums are set to their integer value\n\tshapeToProperty( target, countOverride = null ) {\n\n\t\treturn initializeFromProperty( this, target, countOverride );\n\n\t}\n\n\t// resolve the given object to the default value for the property for a single element\n\t// enums are set to a default string\n\tresolveDefaultElement( target ) {\n\n\t\treturn resolveDefaultElement( this, target );\n\n\t}\n\n\t// resolve the target to the default value for the property for every element if it's an array\n\t// enums are set to a default string\n\tresolveDefault( target ) {\n\n\t\treturn resolveDefault( this, target );\n\n\t}\n\n\t// converts any instances of no data to the default value\n\tresolveNoData( target ) {\n\n\t\treturn resolveNoData( this, target );\n\n\t}\n\n\t// converts enums integers in the given target to strings\n\tresolveEnumsToStrings( target ) {\n\n\t\tconst enumSet = this.enumSet;\n\t\tif ( this.type === 'ENUM' ) {\n\n\t\t\tif ( Array.isArray( target ) ) {\n\n\t\t\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\t\t\ttarget[ i ] = getEnumName( target[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttarget = getEnumName( target );\n\n\t\t\t}\n\n\n\t\t}\n\n\t\treturn target;\n\n\t\tfunction getEnumName( index ) {\n\n\t\t\tconst match = enumSet.values.find( e => e.value === index );\n\t\t\tif ( match === null ) {\n\n\t\t\t\t// the default \"default enum\" value is an empty string when we can't find a match\n\t\t\t\t// in a case where enums are defined correctly we should never get here.\n\t\t\t\treturn '';\n\n\t\t\t} else {\n\n\t\t\t\treturn match.name;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// apply scales\n\tadjustValueScaleOffset( target ) {\n\n\t\tif ( isNumericType( this.type ) ) {\n\n\t\t\treturn adjustValueScaleOffset( this, target );\n\n\t\t} else {\n\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n}\n","import { ClassProperty } from './ClassProperty.js';\n\nexport class PropertySetAccessor {\n\n\tconstructor( definition, classes = {}, enums = {}, data = null ) {\n\n\t\tthis.definition = definition;\n\t\tthis.class = classes[ definition.class ];\n\t\tthis.className = definition.class;\n\t\tthis.enums = enums;\n\t\tthis.data = data;\n\t\tthis.name = 'name' in definition ? definition.name : null;\n\n\t\tthis.properties = null;\n\n\t}\n\n\tgetPropertyNames() {\n\n\t\treturn Object.keys( this.class.properties );\n\n\t}\n\n\tincludesData( name ) {\n\n\t\treturn Boolean( this.definition.properties[ name ] );\n\n\t}\n\n\tdispose() {}\n\n\t_initProperties( propertyClass = ClassProperty ) {\n\n\t\tconst properties = {};\n\t\tfor ( const key in this.class.properties ) {\n\n\t\t\tproperties[ key ] = new propertyClass( this.enums, this.class.properties[ key ], this.definition.properties[ key ] );\n\n\t\t}\n\n\t\tthis.properties = properties;\n\n\t}\n\n}\n","import { initializeFromClass, isMatrixType, isVectorType } from '../utilities/ClassPropertyHelpers.js';\nimport { ClassProperty } from './ClassProperty.js';\nimport { PropertySetAccessor } from './PropertySetAccessor.js';\n\nclass PropertyAttributeClassProperty extends ClassProperty {\n\n\tconstructor( enums, classProperty, attributeProperty = null ) {\n\n\t\tsuper( enums, classProperty, attributeProperty );\n\n\t\tthis.attribute = attributeProperty?.attribute ?? null;\n\n\t}\n\n}\n\nexport class PropertyAttributeAccessor extends PropertySetAccessor {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isPropertyAttributeAccessor = true;\n\t\tthis._initProperties( PropertyAttributeClassProperty );\n\n\t}\n\n\tgetData( id, geometry, target = {} ) {\n\n\t\tconst properties = this.properties;\n\t\tinitializeFromClass( properties, target );\n\n\t\tfor ( const name in properties ) {\n\n\t\t\ttarget[ name ] = this.getPropertyValue( name, id, geometry, target[ name ] );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetPropertyValue( name, id, geometry, target = null ) {\n\n\t\t// NOTE: arrays are not supported via attribute accessors\n\t\tif ( id >= this.count ) {\n\n\t\t\tthrow new Error( 'PropertyAttributeAccessor: Requested index is outside the range of the buffer.' );\n\n\t\t}\n\n\t\t// use a default of the texture accessor definition does not include the value\n\t\tconst property = this.properties[ name ];\n\t\tconst type = property.type;\n\t\tif ( ! property ) {\n\n\t\t\tthrow new Error( 'PropertyAttributeAccessor: Requested class property does not exist.' );\n\n\t\t} else if ( ! this.definition.properties[ name ] ) {\n\n\t\t\treturn property.resolveDefault( target );\n\n\t\t}\n\n\t\t// initialize the array\n\t\ttarget = property.shapeToProperty( target );\n\n\t\t// Read the data values from the attribute\n\t\tconst attribute = geometry.getAttribute( property.attribute.toLowerCase() );\n\t\tif ( isMatrixType( type ) ) {\n\n\t\t\tconst elements = target.elements;\n\t\t\tfor ( let i = 0, l = elements.length; i < l; i < l ) {\n\n\t\t\t\telements[ i ] = attribute.getComponent( id, i );\n\n\t\t\t}\n\n\t\t} else if ( isVectorType( type ) ) {\n\n\t\t\ttarget.fromBufferAttribute( attribute, id );\n\n\t\t} else if ( type === 'SCALAR' || type === 'ENUM' ) {\n\n\t\t\ttarget = attribute.getX( id );\n\n\t\t} else {\n\n\t\t\t// BOOLEAN, STRING not supported\n\t\t\tthrow new Error( 'StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.' );\n\n\t\t}\n\n\t\t// scale the numeric values\n\t\ttarget = property.adjustValueScaleOffset( target );\n\n\t\t// convert to enum strings - no data enum values are stored as strings\n\t\ttarget = property.resolveEnumsToStrings( target );\n\n\t\t// resolve to default values\n\t\ttarget = property.resolveNoData( target );\n\n\t\treturn target;\n\n\t}\n\n}\n","import { ClassProperty } from './ClassProperty.js';\nimport { PropertySetAccessor } from './PropertySetAccessor.js';\nimport {\n\tinitializeFromClass,\n\tgetArrayConstructorFromComponentType,\n\treadDataFromBufferToType,\n\tgetField,\n\tisNumericType,\n\ttypeToComponentCount,\n} from '../utilities/ClassPropertyHelpers.js';\n\nclass PropertyTableClassProperty extends ClassProperty {\n\n\tconstructor( enums, classProperty, tableProperty = null ) {\n\n\t\tsuper( enums, classProperty, tableProperty );\n\n\t\tthis.values = tableProperty?.values ?? null;\n\t\tthis.valueLength = typeToComponentCount( this.type );\n\t\tthis.arrayOffsets = getField( tableProperty, 'arrayOffsets', null );\n\t\tthis.stringOffsets = getField( tableProperty, 'stringOffsets', null );\n\t\tthis.arrayOffsetType = getField( tableProperty, 'arrayOffsetType', 'UINT32' );\n\t\tthis.stringOffsetType = getField( tableProperty, 'stringOffsetType', 'UINT32' );\n\n\t}\n\n\t// returns the necessary array length based on the array offsets if present\n\tgetArrayLengthFromId( buffers, id ) {\n\n\t\tlet count = this.count;\n\t\tif ( this.arrayOffsets !== null ) {\n\n\t\t\tconst { arrayOffsets, arrayOffsetType } = this;\n\t\t\tconst bufferCons = getArrayConstructorFromComponentType( arrayOffsetType );\n\t\t\tconst arr = new bufferCons( buffers[ arrayOffsets ] );\n\t\t\tcount = arr[ id + 1 ] - arr[ id ];\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// returns the index offset into the data buffer for the given id based on the\n\t// the array offsets if present\n\tgetIndexOffsetFromId( buffers, id ) {\n\n\t\tlet indexOffset = id;\n\t\tif ( this.arrayOffsets ) {\n\n\t\t\tconst { arrayOffsets, arrayOffsetType } = this;\n\t\t\tconst bufferCons = getArrayConstructorFromComponentType( arrayOffsetType );\n\t\t\tconst arr = new bufferCons( buffers[ arrayOffsets ] );\n\t\t\tindexOffset = arr[ indexOffset ];\n\n\t\t} else if ( this.array ) {\n\n\t\t\t// TODO: why do this? Revisit\n\t\t\tindexOffset *= this.count;\n\n\t\t}\n\n\t\treturn indexOffset;\n\n\t}\n\n}\n\nexport class PropertyTableAccessor extends PropertySetAccessor {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isPropertyTableAccessor = true;\n\t\tthis.count = this.definition.count;\n\n\t\tthis._initProperties( PropertyTableClassProperty );\n\n\t}\n\n\tgetData( id, target = {} ) {\n\n\t\tconst properties = this.properties;\n\t\tinitializeFromClass( properties, target );\n\n\t\tfor ( const name in properties ) {\n\n\t\t\ttarget[ name ] = this.getPropertyValue( name, id, target[ name ] );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// reads an individual element\n\t_readValueAtIndex( name, id, index, target = null ) {\n\n\t\tconst property = this.properties[ name ];\n\t\tconst { componentType, type } = property;\n\n\t\tconst buffers = this.data;\n\t\tconst bufferView = buffers[ property.values ];\n\t\tconst bufferCons = getArrayConstructorFromComponentType( componentType, type );\n\t\tconst dataArray = new bufferCons( bufferView );\n\n\t\t// array offsets contain element offsets, not byte offsets\n\t\tconst indexOffset = property.getIndexOffsetFromId( buffers, id );\n\n\t\tif ( isNumericType( type ) || type === 'ENUM' ) {\n\n\t\t\t// \"readDataFromBufferToType\" takes the start offset to read from so we multiply the\n\t\t\t// index by the final value length\n\t\t\treturn readDataFromBufferToType( dataArray, ( indexOffset + index ) * property.valueLength, type, target );\n\n\t\t} else if ( type === 'STRING' ) {\n\n\t\t\t// https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata/#variable-length-arrays\n\n\t\t\tlet stringIndex = indexOffset + index;\n\t\t\tlet stringLength = 0;\n\t\t\tif ( property.stringOffsets !== null ) {\n\n\t\t\t\t// get the string lengths and beginning offsets if variable\n\t\t\t\tconst { stringOffsets, stringOffsetType } = property;\n\t\t\t\tconst bufferCons = getArrayConstructorFromComponentType( stringOffsetType );\n\t\t\t\tconst stringOffsetBuffer = new bufferCons( buffers[ stringOffsets ] );\n\t\t\t\tstringLength = stringOffsetBuffer[ stringIndex + 1 ] - stringOffsetBuffer[ stringIndex ];\n\t\t\t\tstringIndex = stringOffsetBuffer[ stringIndex ];\n\n\t\t\t}\n\n\t\t\tconst byteArray = new Uint8Array( dataArray.buffer, stringIndex, stringLength );\n\t\t\ttarget = new TextDecoder().decode( byteArray );\n\n\t\t} else if ( type === 'BOOLEAN' ) {\n\n\t\t\tconst offset = indexOffset + index;\n\t\t\tconst byteIndex = Math.floor( offset / 8 );\n\t\t\tconst bitIndex = offset % 8;\n\t\t\tconst bitValue = ( dataArray[ byteIndex ] >> bitIndex ) & 1;\n\t\t\ttarget = bitValue === 1;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t// Reads the data for the given table index\n\tgetPropertyValue( name, id, target = null ) {\n\n\t\t// check if the requested id is outside of the size of the table\n\t\tif ( id >= this.count ) {\n\n\t\t\tthrow new Error( 'PropertyTableAccessor: Requested index is outside the range of the table.' );\n\n\t\t}\n\n\t\t// check to see if we skip this field since its not in the table\n\t\tconst property = this.properties[ name ];\n\t\tif ( ! property ) {\n\n\t\t\tthrow new Error( 'PropertyTableAccessor: Requested property does not exist.' );\n\n\t\t} else if ( ! this.definition.properties[ name ] ) {\n\n\t\t\treturn property.resolveDefault( target );\n\n\t\t}\n\n\t\t// get the dynamic array count from the property buffer\n\t\tconst array = property.array;\n\t\tconst buffers = this.data;\n\t\tconst count = property.getArrayLengthFromId( buffers, id );\n\n\t\t// initialize the array\n\t\ttarget = property.shapeToProperty( target, count );\n\n\t\t// read all data\n\t\tif ( array ) {\n\n\t\t\tfor ( let i = 0, l = target.length; i < l; i ++ ) {\n\n\t\t\t\ttarget[ i ] = this._readValueAtIndex( name, id, i, target[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttarget = this._readValueAtIndex( name, id, 0, target );\n\n\t\t}\n\n\t\t// scale the numeric values\n\t\ttarget = property.adjustValueScaleOffset( target );\n\n\t\t// convert to enum strings - no data enum values are stored as strings\n\t\ttarget = property.resolveEnumsToStrings( target );\n\n\t\t// resolve to default values\n\t\ttarget = property.resolveNoData( target );\n\n\t\treturn target;\n\n\t}\n\n}\n","import { WebGLRenderTarget, WebGLRenderer, Box2, Vector2, ShaderMaterial, CustomBlending, ZeroFactor, OneFactor } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\n\nconst _box = /* @__PURE__ */ new Box2();\n\n// Utility for reading sets of individual pixel values from textures\nclass _TextureReadUtility {\n\n\tconstructor() {\n\n\t\tthis._renderer = new WebGLRenderer();\n\t\tthis._target = new WebGLRenderTarget( 1, 1 );\n\t\tthis._texTarget = new WebGLRenderTarget();\n\n\t\t// quad to render just a single pixel from the provided texture\n\t\tthis._quad = new FullScreenQuad( new ShaderMaterial( {\n\n\t\t\tblending: CustomBlending,\n\t\t\tblendDst: ZeroFactor,\n\t\t\tblendSrc: OneFactor,\n\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: null },\n\t\t\t\tpixel: { value: new Vector2() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform ivec2 pixel;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texelFetch( map, pixel, 0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} ) );\n\n\t}\n\n\t// increases the width of the target render target to support more data\n\tincreaseSizeTo( width ) {\n\n\t\tthis._target.setSize( Math.max( this._target.width, width ), 1 );\n\n\t}\n\n\t// read data from the rendered texture asynchronously\n\treadDataAsync( buffer ) {\n\n\t\tconst { _renderer, _target } = this;\n\t\treturn _renderer.readRenderTargetPixelsAsync( _target, 0, 0, buffer.length / 4, 1, buffer );\n\n\t}\n\n\t// read data from the rendered texture\n\treadData( buffer ) {\n\n\t\tconst { _renderer, _target } = this;\n\t\t_renderer.readRenderTargetPixels( _target, 0, 0, buffer.length / 4, 1, buffer );\n\n\t}\n\n\t// render a single pixel from the source at the destination point on the render target\n\t// takes the texture, pixel to read from, and pixel to render in to\n\trenderPixelToTarget( texture, pixel, dstPixel ) {\n\n\t\tconst { _renderer, _target } = this;\n\n\t\t// copies the pixel directly to the target buffer\n\t\t_box.min.copy( pixel );\n\t\t_box.max.copy( pixel );\n\t\t_box.max.x += 1;\n\t\t_box.max.y += 1;\n\t\t_renderer.initRenderTarget( _target );\n\t\t_renderer.copyTextureToTexture( texture, _target.texture, _box, dstPixel, 0 );\n\n\t}\n\n}\n\n// Create a wrapper class to defer instantiation of the WebGLRenderer until it's needed\n// See NASA-AMMOS/3DTilesRendererJS#905\nexport const TextureReadUtility = /* @__PURE__ */ new ( class {\n\n\tconstructor() {\n\n\t\tlet reader = null;\n\t\tObject\n\t\t\t.getOwnPropertyNames( _TextureReadUtility.prototype )\n\t\t\t.forEach( key => {\n\n\t\t\t\tif ( key !== 'constructor' ) {\n\n\t\t\t\t\tthis[ key ] = ( ...args ) => {\n\n\t\t\t\t\t\treader = reader || new _TextureReadUtility();\n\t\t\t\t\t\treturn reader[ key ]( ...args );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t}\n\n} )();\n","import { Vector2 } from 'three';\n\nconst _uv0 = /* @__PURE__ */ new Vector2();\nconst _uv1 = /* @__PURE__ */ new Vector2();\nconst _uv2 = /* @__PURE__ */ new Vector2();\n\n// returns the uv attribute of the given index\nexport function getTextureCoordAttribute( geometry, index ) {\n\n\tif ( index === 0 ) {\n\n\t\treturn geometry.getAttribute( 'uv' );\n\n\t} else {\n\n\t\treturn geometry.getAttribute( `uv${ index }` );\n\n\t}\n\n}\n\n// returns the vertex indices associated with the triangle index\nexport function getTriangleVertexIndices( geometry, faceIndex, target = new Array( 3 ) ) {\n\n\t// get the attribute indices\n\tlet i0 = 3 * faceIndex;\n\tlet i1 = 3 * faceIndex + 1;\n\tlet i2 = 3 * faceIndex + 2;\n\tif ( geometry.index ) {\n\n\t\ti0 = geometry.index.getX( i0 );\n\t\ti1 = geometry.index.getX( i1 );\n\t\ti2 = geometry.index.getX( i2 );\n\n\t}\n\n\ttarget[ 0 ] = i0;\n\ttarget[ 1 ] = i1;\n\ttarget[ 2 ] = i2;\n\treturn target;\n\n}\n\n// takes a tex coord index, barycoord, vertex indices, and target to set\n// sets target to the interpolated uv value\nexport function getTexCoord( geometry, texCoord, barycoord, indices, target ) {\n\n\tconst [ i0, i1, i2 ] = indices;\n\tconst attr = getTextureCoordAttribute( geometry, texCoord );\n\t_uv0.fromBufferAttribute( attr, i0 );\n\t_uv1.fromBufferAttribute( attr, i1 );\n\t_uv2.fromBufferAttribute( attr, i2 );\n\n\ttarget\n\t\t.set( 0, 0, 0 )\n\t\t.addScaledVector( _uv0, barycoord.x )\n\t\t.addScaledVector( _uv1, barycoord.y )\n\t\t.addScaledVector( _uv2, barycoord.z );\n\n}\n\n// gets the x, y index of the pixel at the given uv coordinate\nexport function getTexelIndices( uv, width, height, target ) {\n\n\tconst fx = uv.x - Math.floor( uv.x );\n\tconst fy = uv.y - Math.floor( uv.y );\n\tconst px = Math.floor( ( fx * width ) % width );\n\tconst py = Math.floor( ( fy * height ) % height );\n\ttarget.set( px, py );\n\treturn target;\n\n}\n","import { Vector2 } from 'three';\nimport { PropertySetAccessor } from './PropertySetAccessor.js';\nimport { ClassProperty } from './ClassProperty.js';\nimport { TextureReadUtility } from '../utilities/TextureReadUtility.js';\nimport { getTexCoord, getTexelIndices, getTriangleVertexIndices } from '../utilities/TexCoordUtilities.js';\nimport {\n\tinitializeFromClass,\n\tinitializeFromProperty,\n\tgetArrayConstructorFromComponentType,\n\treadDataFromBufferToType,\n\tgetField\n} from '../utilities/ClassPropertyHelpers.js';\n\nconst _uv = /* @__PURE__ */ new Vector2();\nconst _srcPixel = /* @__PURE__ */ new Vector2();\nconst _dstPixel = /* @__PURE__ */ new Vector2();\n\nclass PropertyTextureClassProperty extends ClassProperty {\n\n\tconstructor( enums, classProperty, textureProperty = null ) {\n\n\t\tsuper( enums, classProperty, textureProperty );\n\n\t\tthis.channels = getField( textureProperty, 'channels', [ 0 ] );\n\t\tthis.index = getField( textureProperty, 'index', null );\n\t\tthis.texCoord = getField( textureProperty, 'texCoord', null );\n\t\tthis.valueLength = parseInt( this.type.replace( /[^0-9]/g, '' ) ) || 1;\n\n\t}\n\n\t// takes the buffer to read from and the value index to read\n\treadDataFromBuffer( buffer, index, target = null ) {\n\n\t\tconst type = this.type;\n\t\tif ( type === 'BOOLEAN' || type === 'STRING' ) {\n\n\t\t\tthrow new Error( 'PropertyTextureAccessor: BOOLEAN and STRING types not supported.' );\n\n\t\t}\n\n\t\t// \"readDataFromBufferToType\" takes the start offset to read from so we multiply the index by the\n\t\t// final value length\n\t\treturn readDataFromBufferToType( buffer, index * this.valueLength, type, target );\n\n\t}\n\n}\n\n// Reads and accesses data encoded to textures\nexport class PropertyTextureAccessor extends PropertySetAccessor {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isPropertyTextureAccessor = true;\n\t\tthis._asyncRead = false;\n\n\t\tthis._initProperties( PropertyTextureClassProperty );\n\n\t}\n\n\t// Reads the full set of property data\n\tgetData( faceIndex, barycoord, geometry, target = {} ) {\n\n\t\tconst properties = this.properties;\n\t\tinitializeFromClass( properties, target );\n\n\t\tconst names = Object.keys( properties );\n\t\tconst results = names.map( n => target[ n ] );\n\t\tthis.getPropertyValuesAtTexel( names, faceIndex, barycoord, geometry, results );\n\n\t\tnames.forEach( ( n, i ) => target[ n ] = results[ i ] );\n\t\treturn target;\n\n\t}\n\n\t// Reads the full set of property data asynchronously\n\tasync getDataAsync( faceIndex, barycoord, geometry, target = {} ) {\n\n\t\tconst properties = this.properties;\n\t\tinitializeFromClass( properties, target );\n\n\t\tconst names = Object.keys( properties );\n\t\tconst results = names.map( n => target[ n ] );\n\t\tawait this.getPropertyValuesAtTexelAsync( names, faceIndex, barycoord, geometry, results );\n\n\t\tnames.forEach( ( n, i ) => target[ n ] = results[ i ] );\n\t\treturn target;\n\n\t}\n\n\t// Reads values asynchronously\n\tgetPropertyValuesAtTexelAsync( ...args ) {\n\n\t\tthis._asyncRead = true;\n\t\tconst result = this.getPropertyValuesAtTexel( ...args );\n\t\tthis._asyncRead = false;\n\t\treturn result;\n\n\t}\n\n\t// Reads values from the textures synchronously\n\tgetPropertyValuesAtTexel( names, faceIndex, barycoord, geometry, target = [] ) {\n\n\t\t// resize our targets appropriately\n\t\twhile ( target.length < names.length ) target.push( null );\n\t\ttarget.length = names.length;\n\t\tTextureReadUtility.increaseSizeTo( target.length );\n\n\t\t// get the attribute indices\n\t\tconst textures = this.data;\n\t\tconst accessorProperties = this.definition.properties;\n\t\tconst properties = this.properties;\n\t\tconst indices = getTriangleVertexIndices( geometry, faceIndex );\n\t\tfor ( let i = 0, l = names.length; i < l; i ++ ) {\n\n\t\t\t// skip any requested class schema properties that are not provided via the accessor\n\t\t\tconst name = names[ i ];\n\t\t\tif ( ! accessorProperties[ name ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// get the attribute of the target tex coord\n\t\t\tconst property = properties[ name ];\n\t\t\tconst texture = textures[ property.index ];\n\t\t\tgetTexCoord( geometry, property.texCoord, barycoord, indices, _uv );\n\t\t\tgetTexelIndices( _uv, texture.image.width, texture.image.height, _srcPixel );\n\t\t\t_dstPixel.set( i, 0 );\n\n\t\t\tTextureReadUtility.renderPixelToTarget( texture, _srcPixel, _dstPixel );\n\n\t\t}\n\n\t\t// read the data\n\t\tconst buffer = new Uint8Array( names.length * 4 );\n\t\tif ( this._asyncRead ) {\n\n\t\t\treturn TextureReadUtility\n\t\t\t\t.readDataAsync( buffer )\n\t\t\t\t.then( () => {\n\n\t\t\t\t\treadTextureSampleResults.call( this );\n\t\t\t\t\treturn target;\n\n\t\t\t\t} );\n\n\t\t} else {\n\n\t\t\tTextureReadUtility.readData( buffer );\n\t\t\treadTextureSampleResults.call( this );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\tfunction readTextureSampleResults() {\n\n\t\t\tfor ( let i = 0, l = names.length; i < l; i ++ ) {\n\n\t\t\t\tconst name = names[ i ];\n\t\t\t\tconst property = properties[ name ];\n\t\t\t\tconst type = property.type;\n\n\t\t\t\t// initialize the output value\n\t\t\t\ttarget[ i ] = initializeFromProperty( property, target[ i ] );\n\n\t\t\t\t// use a default of the texture accessor definition does not include the value\n\t\t\t\tif ( ! property ) {\n\n\t\t\t\t\tthrow new Error( 'PropertyTextureAccessor: Requested property does not exist.' );\n\n\t\t\t\t} else if ( ! accessorProperties[ name ] ) {\n\n\t\t\t\t\ttarget[ i ] = property.resolveDefault( target );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// get the final array length to read all data based on used buffer data\n\t\t\t\tconst length = property.valueLength * ( property.count || 1 );\n\n\t\t\t\t// set the data read back from the texture to the target type\n\t\t\t\tconst data = property.channels.map( c => buffer[ 4 * i + c ] );\n\t\t\t\tconst componentType = property.componentType;\n\t\t\t\tconst BufferCons = getArrayConstructorFromComponentType( componentType, type );\n\t\t\t\tconst readBuffer = new BufferCons( length );\n\t\t\t\tnew Uint8Array( readBuffer.buffer ).set( data );\n\n\t\t\t\t// read all the data\n\t\t\t\tif ( property.array ) {\n\n\t\t\t\t\tconst arr = target[ i ];\n\t\t\t\t\tfor ( let j = 0, lj = arr.length; j < lj; j ++ ) {\n\n\t\t\t\t\t\tarr[ j ] = property.readDataFromBuffer( readBuffer, j, arr[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget[ i ] = property.readDataFromBuffer( readBuffer, 0, target[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t// scale the numeric values\n\t\t\t\ttarget[ i ] = property.adjustValueScaleOffset( target[ i ] );\n\n\t\t\t\t// convert to enum strings - no data enum values are stored as strings\n\t\t\t\ttarget[ i ] = property.resolveEnumsToStrings( target[ i ] );\n\n\t\t\t\t// resolve to default values\n\t\t\t\ttarget[ i ] = property.resolveNoData( target[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// dispose all of the texture data used\n\tdispose() {\n\n\t\tthis.data.forEach( texture => {\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import { PropertyAttributeAccessor } from './PropertyAttributeAccessor.js';\nimport { PropertyTableAccessor } from './PropertyTableAccessor.js';\nimport { PropertyTextureAccessor } from './PropertyTextureAccessor.js';\n\nexport class StructuralMetadata {\n\n\tconstructor( definition, textures, buffers, nodeMetadata = null, object = null ) {\n\n\t\tconst {\n\t\t\tschema,\n\t\t\tpropertyTables = [],\n\t\t\tpropertyTextures = [],\n\t\t\tpropertyAttributes = [],\n\t\t} = definition;\n\n\t\tconst { enums, classes } = schema;\n\t\tconst tableAccessors = propertyTables.map( t => new PropertyTableAccessor( t, classes, enums, buffers ) );\n\t\tlet textureAccessors = [];\n\t\tlet attributeAccessors = [];\n\n\t\tif ( nodeMetadata ) {\n\n\t\t\tif ( nodeMetadata.propertyTextures ) {\n\n\t\t\t\ttextureAccessors = nodeMetadata.propertyTextures.map( i => new PropertyTextureAccessor( propertyTextures[ i ], classes, enums, textures ) );\n\n\t\t\t}\n\n\t\t\tif ( nodeMetadata.propertyAttributes ) {\n\n\t\t\t\tattributeAccessors = nodeMetadata.propertyAttributes.map( i => new PropertyAttributeAccessor( propertyAttributes[ i ], classes, enums ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.schema = schema;\n\t\tthis.tableAccessors = tableAccessors;\n\t\tthis.textureAccessors = textureAccessors;\n\t\tthis.attributeAccessors = attributeAccessors;\n\t\tthis.object = object;\n\t\tthis.textures = textures;\n\t\tthis.nodeMetadata = nodeMetadata;\n\n\t}\n\n\t// Property Tables\n\tgetPropertyTableData( tableIndices, ids, target = null ) {\n\n\t\tif ( ! Array.isArray( tableIndices ) || ! Array.isArray( ids ) ) {\n\n\t\t\t// only return a single tables data\n\t\t\ttarget = target || {};\n\n\t\t\tconst table = this.tableAccessors[ tableIndices ];\n\t\t\ttarget = table.getData( ids, target );\n\n\t\t} else {\n\n\t\t\t// return data from an array of tables and ids\n\t\t\ttarget = target || [];\n\n\t\t\tconst length = Math.min( tableIndices.length, ids.length );\n\t\t\ttarget.length = length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst table = this.tableAccessors[ tableIndices[ i ] ];\n\t\t\t\ttarget[ i ] = table.getData( ids[ i ], target[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetPropertyTableInfo( tableIndices = null ) {\n\n\t\t// default to all table information\n\t\tif ( tableIndices === null ) {\n\n\t\t\ttableIndices = this.tableAccessors.map( ( t, i ) => i );\n\n\t\t}\n\n\t\tif ( Array.isArray( tableIndices ) ) {\n\n\t\t\t// return all table information from the requested list\n\t\t\treturn tableIndices.map( i => {\n\n\t\t\t\tconst table = this.tableAccessors[ i ];\n\t\t\t\treturn {\n\t\t\t\t\tname: table.name,\n\t\t\t\t\tclassName: table.definition.class,\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\t// return the one piece of table information\n\t\t\tconst table = this.tableAccessors[ tableIndices ];\n\t\t\treturn {\n\t\t\t\tname: table.name,\n\t\t\t\tclassName: table.definition.class,\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t// Property Textures\n\tgetPropertyTextureData( triangle, barycoord, target = [] ) {\n\n\t\tconst textureAccessors = this.textureAccessors;\n\t\ttarget.length = textureAccessors.length;\n\n\t\tfor ( let i = 0; i < textureAccessors.length; i ++ ) {\n\n\t\t\tconst accessor = textureAccessors[ i ];\n\t\t\ttarget[ i ] = accessor.getData( triangle, barycoord, this.object.geometry, target[ i ] );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tasync getPropertyTextureDataAsync( triangle, barycoord, target = [] ) {\n\n\t\tconst textureAccessors = this.textureAccessors;\n\t\ttarget.length = textureAccessors.length;\n\n\t\tconst promises = [];\n\t\tfor ( let i = 0; i < textureAccessors.length; i ++ ) {\n\n\t\t\tconst accessor = textureAccessors[ i ];\n\t\t\tconst promise = accessor\n\t\t\t\t.getDataAsync( triangle, barycoord, this.object.geometry, target[ i ] )\n\t\t\t\t.then( result => {\n\n\t\t\t\t\ttarget[ i ] = result;\n\n\t\t\t\t} );\n\n\t\t\tpromises.push( promise );\n\n\t\t}\n\n\t\tawait Promise.all( promises );\n\n\t\treturn target;\n\n\t}\n\n\tgetPropertyTextureInfo() {\n\n\t\treturn this.textureAccessors;\n\n\t}\n\n\t// Property Attributes\n\tgetPropertyAttributeData( attributeIndex, target = [] ) {\n\n\t\tconst attributeAccessors = this.attributeAccessors;\n\t\ttarget.length = attributeAccessors.length;\n\n\t\tfor ( let i = 0; i < attributeAccessors.length; i ++ ) {\n\n\t\t\tconst accessor = attributeAccessors[ i ];\n\t\t\ttarget[ i ] = accessor.getData( attributeIndex, this.object.geometry, target[ i ] );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetPropertyAttributeInfo() {\n\n\t\treturn this.attributeAccessors.map( acc => {\n\n\t\t\treturn {\n\t\t\t\tname: acc.name,\n\t\t\t\tclassName: acc.definition.class,\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.textureAccessors.forEach( acc => acc.dispose() );\n\t\tthis.tableAccessors.forEach( acc => acc.dispose() );\n\t\tthis.attributeAccessors.forEach( acc => acc.dispose() );\n\n\t}\n\n}\n","// https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata\n\nimport { FileLoader } from 'three';\nimport { StructuralMetadata } from './metadata/classes/StructuralMetadata.js';\n\nconst EXT_NAME = 'EXT_structural_metadata';\n\n// returns the set of textures required by the property texture definitions\nfunction getRelevantTextures( parser, propertyTextures = [] ) {\n\n\tconst textureCount = parser.json.textures?.length || 0;\n\tconst result = new Array( textureCount ).fill( null );\n\n\tpropertyTextures.forEach( ( { properties } ) => {\n\n\t\tfor ( const key in properties ) {\n\n\t\t\tconst { index } = properties[ key ];\n\t\t\tif ( result[ index ] === null ) {\n\n\t\t\t\tresult[ index ] = parser.loadTexture( index );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn Promise.all( result );\n\n}\n\n// returns the set of buffers required by the property table definitions\nfunction getRelevantBuffers( parser, propertyTables = [] ) {\n\n\tconst textureCount = parser.json.bufferViews?.length || 0;\n\tconst result = new Array( textureCount ).fill( null );\n\n\tpropertyTables.forEach( ( { properties } ) => {\n\n\t\tfor ( const key in properties ) {\n\n\t\t\tconst { values, arrayOffsets, stringOffsets } = properties[ key ];\n\t\t\tif ( result[ values ] === null ) {\n\n\t\t\t\tresult[ values ] = parser.loadBufferView( values );\n\n\t\t\t}\n\n\t\t\tif ( result[ arrayOffsets ] === null ) {\n\n\t\t\t\tresult[ arrayOffsets ] = parser.loadBufferView( arrayOffsets );\n\n\t\t\t}\n\n\t\t\tif ( result[ stringOffsets ] === null ) {\n\n\t\t\t\tresult[ stringOffsets ] = parser.loadBufferView( stringOffsets );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn Promise.all( result );\n\n}\n\nexport class GLTFStructuralMetadataExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXT_NAME;\n\n\t}\n\n\tasync afterRoot( { scene, parser } ) {\n\n\t\t// skip if the extension is not present\n\t\tconst extensionsUsed = parser.json.extensionsUsed;\n\t\tif ( ! extensionsUsed || ! extensionsUsed.includes( EXT_NAME ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// load the remote schema definition if present\n\t\tlet schemaPromise = null;\n\t\tlet rootExtension = parser.json.extensions[ EXT_NAME ];\n\t\tif ( rootExtension.schemaUri ) {\n\n\t\t\t// TODO: cache the loaded schema so we can share it and dispose of it when the\n\t\t\t// extension is no longer available\n\t\t\tconst { manager, path, requestHeader, crossOrigin } = parser.options;\n\t\t\tconst finalUri = new URL( rootExtension.schemaUri, path ).toString();\n\t\t\tconst fileLoader = new FileLoader( manager );\n\t\t\tfileLoader.setCrossOrigin( crossOrigin );\n\t\t\tfileLoader.setResponseType( 'json' );\n\t\t\tfileLoader.setRequestHeader( requestHeader );\n\n\t\t\tschemaPromise = fileLoader.loadAsync( finalUri )\n\t\t\t\t.then( schema => {\n\n\t\t\t\t\trootExtension = { ...rootExtension, schema };\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\t// prep the textures and buffers\n\t\tconst [ textures, buffers ] = await Promise.all( [\n\t\t\tgetRelevantTextures( parser, rootExtension.propertyTextures ),\n\t\t\tgetRelevantBuffers( parser, rootExtension.propertyTables ),\n\t\t\tschemaPromise,\n\t\t] );\n\n\t\t// initialize the extension\n\t\tconst rootMetadata = new StructuralMetadata( rootExtension, textures, buffers );\n\t\tscene.userData.structuralMetadata = rootMetadata;\n\n\t\tscene.traverse( child => {\n\n\t\t\tif ( parser.associations.has( child ) ) {\n\n\t\t\t\t// check if this object has extension references and use a child-specific version of the extension\n\t\t\t\tconst { meshes, primitives } = parser.associations.get( child );\n\t\t\t\tconst primitive = parser.json.meshes[ meshes ]?.primitives[ primitives ];\n\t\t\t\tif ( primitive && primitive.extensions && primitive.extensions[ EXT_NAME ] ) {\n\n\t\t\t\t\tconst extension = primitive.extensions[ EXT_NAME ];\n\t\t\t\t\tchild.userData.structuralMetadata = new StructuralMetadata( rootExtension, textures, buffers, extension, child );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.userData.structuralMetadata = rootMetadata;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import { Vector2 } from 'three';\nimport { TextureReadUtility } from '../utilities/TextureReadUtility.js';\nimport { getTexCoord, getTexelIndices, getTriangleVertexIndices } from '../utilities/TexCoordUtilities.js';\n\nconst _uv = /* @__PURE__ */ new Vector2();\nconst _pixel = /* @__PURE__ */ new Vector2();\nconst _dstPixel = /* @__PURE__ */ new Vector2();\n\n// retrieve the appropriate UV attribute based on the tex coord index\nfunction getMaxBarycoordIndex( barycoord ) {\n\n\tif ( barycoord.x > barycoord.y && barycoord.x > barycoord.z ) {\n\n\t\treturn 0;\n\n\t} else if ( barycoord.y > barycoord.z ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 2;\n\n\t}\n\n}\n\nexport class MeshFeatures {\n\n\tconstructor( geometry, textures, data ) {\n\n\t\tthis.geometry = geometry;\n\t\tthis.textures = textures;\n\t\tthis.data = data;\n\t\tthis._asyncRead = false;\n\n\t\t// fill out feature id default values\n\t\tthis.featureIds = data.featureIds.map( info => {\n\n\t\t\tconst { texture, ...rest } = info;\n\t\t\tconst result = {\n\t\t\t\tlabel: null,\n\t\t\t\tpropertyTable: null,\n\t\t\t\tnullFeatureId: null,\n\t\t\t\t...rest,\n\t\t\t};\n\n\t\t\tif ( texture ) {\n\n\t\t\t\tresult.texture = {\n\t\t\t\t\ttexCoord: 0,\n\t\t\t\t\tchannels: [ 0 ],\n\t\t\t\t\t...texture,\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t} );\n\n\t}\n\n\t// returns list of textures\n\tgetTextures() {\n\n\t\treturn this.textures;\n\n\t}\n\n\t// returns a set of info for each feature\n\tgetFeatureInfo() {\n\n\t\treturn this.featureIds;\n\n\t}\n\n\t// performs texture data read back asynchronously\n\tgetFeaturesAsync( ...args ) {\n\n\t\tthis._asyncRead = true;\n\t\tconst result = this.getFeatures( ...args );\n\t\tthis._asyncRead = false;\n\t\treturn result;\n\n\t}\n\n\t// returns all features for the given point on the given triangle\n\tgetFeatures( triangle, barycoord ) {\n\n\t\tconst { geometry, textures, featureIds } = this;\n\t\tconst result = new Array( featureIds.length ).fill( null );\n\n\t\t// prep the canvas width\n\t\tconst width = featureIds.length;\n\t\tTextureReadUtility.increaseSizeTo( width );\n\n\t\t// get the attribute indices\n\t\tconst indices = getTriangleVertexIndices( geometry, triangle );\n\t\tconst closestIndex = indices[ getMaxBarycoordIndex( barycoord ) ];\n\t\tfor ( let i = 0, l = featureIds.length; i < l; i ++ ) {\n\n\t\t\t// the feature id from the closest point is returned\n\t\t\tconst featureId = featureIds[ i ];\n\t\t\tconst nullFeatureId = 'nullFeatureId' in featureId ? featureId.nullFeatureId : null;\n\t\t\tif ( 'texture' in featureId ) {\n\n\t\t\t\tconst texture = textures[ featureId.texture.index ];\n\n\t\t\t\t// get the attribute of the target tex coord and pixel\n\t\t\t\tgetTexCoord( geometry, featureId.texture.texCoord, barycoord, indices, _uv );\n\t\t\t\tgetTexelIndices( _uv, texture.image.width, texture.image.height, _pixel );\n\t\t\t\t_dstPixel.set( i, 0 );\n\n\t\t\t\t// draw the image\n\t\t\t\tTextureReadUtility.renderPixelToTarget( textures[ featureId.texture.index ], _pixel, _dstPixel );\n\n\t\t\t} else if ( 'attribute' in featureId ) {\n\n\t\t\t\tconst attr = geometry.getAttribute( `_feature_id_${ featureId.attribute }` );\n\t\t\t\tconst value = attr.getX( closestIndex );\n\t\t\t\tif ( value !== nullFeatureId ) {\n\n\t\t\t\t\tresult[ i ] = value;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// implicit id is based on vertex attributes, see 3d-tiles#763\n\t\t\t\tconst value = closestIndex;\n\t\t\t\tif ( value !== nullFeatureId ) {\n\n\t\t\t\t\tresult[ i ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// read the buffer data\n\t\tconst buffer = new Uint8Array( width * 4 );\n\t\tif ( this._asyncRead ) {\n\n\t\t\treturn TextureReadUtility\n\t\t\t\t.readDataAsync( buffer )\n\t\t\t\t.then( () => {\n\n\t\t\t\t\treadTextureSampleResults();\n\t\t\t\t\treturn result;\n\n\t\t\t\t} );\n\n\t\t} else {\n\n\t\t\tTextureReadUtility.readData( buffer );\n\t\t\treadTextureSampleResults();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfunction readTextureSampleResults() {\n\n\t\t\t// get data based on the texture information\n\t\t\tconst readBuffer = new Uint32Array( 1 );\n\t\t\tfor ( let i = 0, l = featureIds.length; i < l; i ++ ) {\n\n\t\t\t\tconst featureId = featureIds[ i ];\n\t\t\t\tconst nullFeatureId = 'nullFeatureId' in featureId ? featureId.nullFeatureId : null;\n\t\t\t\tif ( 'texture' in featureId ) {\n\n\t\t\t\t\t// TODO: do we need to handle big-endian here?\n\t\t\t\t\tconst { channels } = featureId.texture;\n\t\t\t\t\tconst data = channels.map( c => buffer[ 4 * i + c ] );\n\t\t\t\t\tnew Uint8Array( readBuffer.buffer ).set( data );\n\n\t\t\t\t\tconst value = readBuffer[ 0 ];\n\t\t\t\t\tif ( value !== nullFeatureId ) {\n\n\t\t\t\t\t\tresult[ i ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// dispose all of the texture data used\n\tdispose() {\n\n\t\tthis.textures.forEach( texture => {\n\n\t\t\tif ( texture ) {\n\n\t\t\t\ttexture.dispose();\n\n\t\t\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\t\t\ttexture.image.close();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","import { MeshFeatures } from './metadata/classes/MeshFeatures.js';\n\n// https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_mesh_features\n\nconst EXT_NAME = 'EXT_mesh_features';\n\nfunction forEachPrimitiveExtension( scene, parser, callback ) {\n\n\tscene.traverse( c => {\n\n\t\tif ( parser.associations.has( c ) ) {\n\n\t\t\t// check if this object has extension references\n\t\t\tconst { meshes, primitives } = parser.associations.get( c );\n\n\t\t\tconst primitive = parser.json.meshes[ meshes ]?.primitives[ primitives ];\n\n\t\t\tif ( primitive && primitive.extensions && primitive.extensions[ EXT_NAME ] ) {\n\n\t\t\t\tcallback( c, primitive.extensions[ EXT_NAME ] );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n}\n\nexport class GLTFMeshFeaturesExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXT_NAME;\n\n\t}\n\n\tasync afterRoot( { scene, parser } ) {\n\n\t\t// skip if the extension is not present\n\t\tconst extensionsUsed = parser.json.extensionsUsed;\n\t\tif ( ! extensionsUsed || ! extensionsUsed.includes( EXT_NAME ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// get fetch the relevant textures are loaded\n\t\tconst textureCount = parser.json.textures?.length || 0;\n\t\tconst promises = new Array( textureCount ).fill( null );\n\t\tforEachPrimitiveExtension( scene, parser, ( child, { featureIds } ) => {\n\n\t\t\tfeatureIds.forEach( info => {\n\n\t\t\t\tif ( info.texture && promises[ info.texture.index ] === null ) {\n\n\t\t\t\t\tconst index = info.texture.index;\n\t\t\t\t\tpromises[ index ] = parser.loadTexture( index );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// initialize mesh features on each primitive\n\t\tconst textures = await Promise.all( promises );\n\t\tforEachPrimitiveExtension( scene, parser, ( child, extension ) => {\n\n\t\t\tchild.userData.meshFeatures = new MeshFeatures( child.geometry, textures, extension );\n\n\t\t} );\n\n\t}\n\n}\n","export class GLTFCesiumRTCExtension {\n\n\tconstructor() {\n\n\t\tthis.name = 'CESIUM_RTC';\n\n\t}\n\n\tafterRoot( res ) {\n\n\t\tif ( res.parser.json.extensions && res.parser.json.extensions.CESIUM_RTC ) {\n\n\t\t\tconst { center } = res.parser.json.extensions.CESIUM_RTC;\n\n\t\t\tif ( center ) {\n\n\t\t\t\tres.scene.position.x += center[ 0 ];\n\t\t\t\tres.scene.position.y += center[ 1 ];\n\t\t\t\tres.scene.position.z += center[ 2 ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { GLTFStructuralMetadataExtension } from './gltf/GLTFStructuralMetadataExtension.js';\nimport { GLTFMeshFeaturesExtension } from './gltf/GLTFMeshFeaturesExtension.js';\nimport { GLTFCesiumRTCExtension } from './gltf/GLTFCesiumRTCExtension.js';\n\nexport class GLTFExtensionsPlugin {\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\t\t\tmetadata: true,\n\t\t\trtc: true,\n\n\t\t\tplugins: [],\n\n\t\t\tdracoLoader: null,\n\t\t\tktxLoader: null,\n\t\t\tmeshoptDecoder: null,\n\t\t\tautoDispose: true,\n\t\t\t...options,\n\t\t};\n\n\t\tthis.tiles = null;\n\n\t\tthis.metadata = options.metadata;\n\t\tthis.rtc = options.rtc;\n\t\tthis.plugins = options.plugins;\n\n\t\tthis.dracoLoader = options.dracoLoader;\n\t\tthis.ktxLoader = options.ktxLoader;\n\t\tthis.meshoptDecoder = options.meshoptDecoder;\n\t\tthis._gltfRegex = /\\.(gltf|glb)$/g;\n\t\tthis._dracoRegex = /\\.drc$/g;\n\t\tthis._loader = null;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tconst loader = new GLTFLoader( tiles.manager );\n\t\tif ( this.dracoLoader ) {\n\n\t\t\tloader.setDRACOLoader( this.dracoLoader );\n\t\t\ttiles.manager.addHandler( this._dracoRegex, this.dracoLoader );\n\n\t\t}\n\n\t\tif ( this.ktxLoader ) {\n\n\t\t\tloader.setKTX2Loader( this.ktxLoader );\n\n\t\t}\n\n\t\tif ( this.meshoptDecoder ) {\n\n\t\t\tloader.setMeshoptDecoder( this.meshoptDecoder );\n\n\t\t}\n\n\t\tif ( this.rtc ) {\n\n\t\t\tloader.register( () => new GLTFCesiumRTCExtension() );\n\n\t\t}\n\n\t\tif ( this.metadata ) {\n\n\t\t\tloader.register( () => new GLTFStructuralMetadataExtension() );\n\t\t\tloader.register( () => new GLTFMeshFeaturesExtension() );\n\n\t\t}\n\n\t\tthis.plugins.forEach( plugin => loader.register( plugin ) );\n\n\t\ttiles.manager.addHandler( this._gltfRegex, loader );\n\t\tthis.tiles = tiles;\n\t\tthis._loader = loader;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.tiles.manager.removeHandler( this._gltfRegex );\n\t\tthis.tiles.manager.removeHandler( this._dracoRegex );\n\t\tif ( this.autoDispose ) {\n\n\t\t\tthis.ktxLoader.dispose();\n\t\t\tthis.dracoLoader.dispose();\n\n\t\t}\n\n\t}\n\n}\n","import { Sphere } from 'three';\nimport { OBJECT_FRAME } from '3d-tiles-renderer/three';\n\nconst sphere = /* @__PURE__ */ new Sphere();\nexport class ReorientationPlugin {\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\t\t\tup: '+z',\n\t\t\trecenter: true,\n\n\t\t\tlat: null,\n\t\t\tlon: null,\n\t\t\theight: 0,\n\n\t\t\tazimuth: 0,\n\t\t\televation: 0,\n\t\t\troll: 0,\n\n\t\t\t...options,\n\t\t};\n\n\t\tthis.tiles = null;\n\n\t\tthis.up = options.up.toLowerCase().replace( /\\s+/, '' );\n\t\tthis.lat = options.lat;\n\t\tthis.lon = options.lon;\n\t\tthis.height = options.height;\n\t\tthis.azimuth = options.azimuth;\n\t\tthis.elevation = options.elevation;\n\t\tthis.roll = options.roll;\n\t\tthis.recenter = options.recenter;\n\t\tthis._callback = null;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\tthis._callback = () => {\n\n\t\t\tconst { up, lat, lon, height, azimuth, elevation, roll, recenter } = this;\n\n\t\t\tif ( lat !== null && lon !== null ) {\n\n\t\t\t\t// if the latitude and longitude are provided then remove the position offset\n\t\t\t\tthis.transformLatLonHeightToOrigin( lat, lon, height, azimuth, elevation, roll );\n\n\t\t\t} else {\n\n\t\t\t\tconst { ellipsoid } = tiles;\n\t\t\t\tconst minRadii = Math.min( ...ellipsoid.radius );\n\t\t\t\ttiles.getBoundingSphere( sphere );\n\t\t\t\tif ( sphere.center.length() > minRadii * 0.5 ) {\n\n\t\t\t\t\t// otherwise see if this is possibly a tile set on the surface of the globe based on the positioning\n\t\t\t\t\tconst cart = {};\n\t\t\t\t\tellipsoid.getPositionToCartographic( sphere.center, cart );\n\t\t\t\t\tthis.transformLatLonHeightToOrigin( cart.lat, cart.lon, cart.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// lastly fall back to orienting the up direction to +Y\n\t\t\t\t\tconst group = tiles.group;\n\t\t\t\t\tgroup.rotation.set( 0, 0, 0 );\n\t\t\t\t\tswitch ( up ) {\n\n\t\t\t\t\t\tcase 'x': case '+x':\n\t\t\t\t\t\t\tgroup.rotation.z = Math.PI / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-x':\n\t\t\t\t\t\t\tgroup.rotation.z = - Math.PI / 2;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'y': case '+y':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-y':\n\t\t\t\t\t\t\tgroup.rotation.z = Math.PI;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'z': case '+z':\n\t\t\t\t\t\t\tgroup.rotation.x = - Math.PI / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '-z':\n\t\t\t\t\t\t\tgroup.rotation.x = Math.PI / 2;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttiles.group.position\n\t\t\t\t\t\t.copy( sphere.center )\n\t\t\t\t\t\t.applyEuler( group.rotation )\n\t\t\t\t\t\t.multiplyScalar( - 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! recenter ) {\n\n\t\t\t\ttiles.group.position.setScalar( 0 );\n\n\t\t\t}\n\n\t\t\ttiles.removeEventListener( 'load-tile-set', this._callback );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'load-tile-set', this._callback );\n\n\t\tif ( tiles.root ) {\n\n\t\t\tthis._callback();\n\n\t\t}\n\n\t}\n\n\ttransformLatLonHeightToOrigin( lat, lon, height = 0, azimuth = 0, elevation = 0, roll = 0 ) {\n\n\t\tconst { group, ellipsoid } = this.tiles;\n\n\t\t// get ENU orientation (Z facing north and X facing west) and position\n\t\tellipsoid.getObjectFrame( lat, lon, height, azimuth, elevation, roll, group.matrix, OBJECT_FRAME );\n\n\t\t// adjust the group matrix\n\t\tgroup.matrix.invert().decompose( group.position, group.quaternion, group.scale );\n\t\tgroup.updateMatrixWorld();\n\n\t}\n\n\tdispose() {\n\n\t\tconst { group } = this.tiles;\n\t\tgroup.position.setScalar( 0 );\n\t\tgroup.quaternion.identity();\n\t\tgroup.scale.set( 1, 1, 1 );\n\n\t\tthis.tiles.removeEventListener( 'load-tile-set', this._callback );\n\n\t}\n\n}\n","import { LRUCache } from '3d-tiles-renderer/core';\n\n// Plugin that disposes tiles on unload to remove them from the GPU, saving memory\n\n// TODO:\n// - abstract the \"tile visible\" callback so fade tiles can call it when tiles are _actually_ marked as non-visible\nexport class UnloadTilesPlugin {\n\n\tset delay( v ) {\n\n\t\tthis.deferCallbacks.delay = v;\n\n\t}\n\n\tget delay() {\n\n\t\treturn this.deferCallbacks.delay;\n\n\t}\n\n\tset bytesTarget( v ) {\n\n\t\tthis.lruCache.minBytesSize = v;\n\n\t}\n\n\tget bytesTarget() {\n\n\t\treturn this.lruCache.minBytesSize;\n\n\t}\n\n\tget estimatedGpuBytes() {\n\n\t\treturn this.lruCache.cachedBytes;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tbytesTarget = 0,\n\t\t} = options;\n\n\t\tthis.name = 'UNLOAD_TILES_PLUGIN';\n\n\t\tthis.tiles = null;\n\t\tthis.lruCache = new LRUCache();\n\t\tthis.deferCallbacks = new DeferCallbackManager();\n\n\t\tthis.delay = delay;\n\t\tthis.bytesTarget = bytesTarget;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\tconst { lruCache, deferCallbacks } = this;\n\t\tdeferCallbacks.callback = tile => {\n\n\t\t\tlruCache.markUnused( tile );\n\t\t\tlruCache.scheduleUnload( false );\n\n\t\t};\n\n\t\tconst unloadCallback = tile => {\n\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tconst visible = tiles.visibleTiles.has( tile );\n\n\t\t\tif ( ! visible ) {\n\n\t\t\t\ttiles.invokeOnePlugin( plugin => plugin.unloadTileFromGPU && plugin.unloadTileFromGPU( scene, tile ) );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._onUpdateBefore = () => {\n\n\t\t\t// update lruCache in \"update\" in case the callback values change\n\t\t\tlruCache.unloadPriorityCallback = tiles.lruCache.unloadPriorityCallback;\n\t\t\tlruCache.computeMemoryUsageCallback = tiles.lruCache.computeMemoryUsageCallback;\n\t\t\tlruCache.minSize = Infinity;\n\t\t\tlruCache.maxSize = Infinity;\n\t\t\tlruCache.maxBytesSize = Infinity;\n\t\t\tlruCache.unloadPercent = 1;\n\t\t\tlruCache.autoMarkUnused = false;\n\n\t\t};\n\n\t\tthis._onVisibilityChangeCallback = ( { tile, visible } ) => {\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tlruCache.add( tile, unloadCallback );\n\t\t\t\ttiles.markTileUsed( tile );\n\t\t\t\tdeferCallbacks.cancel( tile );\n\n\t\t\t} else {\n\n\t\t\t\tdeferCallbacks.run( tile );\n\n\t\t\t}\n\n\t\t};\n\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tconst visible = tiles.visibleTiles.has( tile );\n\t\t\tthis._onVisibilityChangeCallback( { scene, visible } );\n\n\t\t} );\n\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onVisibilityChangeCallback );\n\t\ttiles.addEventListener( 'update-before', this._onUpdateBefore );\n\n\t}\n\n\tunloadTileFromGPU( scene, tile ) {\n\n\t\tif ( scene ) {\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tconst material = c.material;\n\t\t\t\t\tmaterial.dispose();\n\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\t\tvalue.dispose();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c.geometry ) {\n\n\t\t\t\t\tc.geometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.tiles.removeEventListener( 'tile-visibility-change', this._onVisibilityChangeCallback );\n\t\tthis.tiles.removeEventListener( 'update-before', this._onUpdateBefore );\n\t\tthis.deferCallbacks.cancelAll();\n\n\t}\n\n}\n\n// Manager for running callbacks after a certain amount of time\nclass DeferCallbackManager {\n\n\tconstructor( callback = () => {} ) {\n\n\t\tthis.map = new Map();\n\t\tthis.callback = callback;\n\t\tthis.delay = 0;\n\n\t}\n\n\trun( tile ) {\n\n\t\tconst { map, delay } = this;\n\t\tif ( map.has( tile ) ) {\n\n\t\t\tthrow new Error( 'DeferCallbackManager: Callback already initialized.' );\n\n\t\t}\n\n\t\tif ( delay === 0 ) {\n\n\t\t\tthis.callback( tile );\n\n\t\t} else {\n\n\t\t\tmap.set( tile, setTimeout( () => this.callback( tile ), delay ) );\n\n\t\t}\n\n\t}\n\n\tcancel( tile ) {\n\n\t\tconst { map } = this;\n\t\tif ( map.has( tile ) ) {\n\n\t\t\tclearTimeout( map.get( tile ) );\n\t\t\tmap.delete( tile );\n\n\t\t}\n\n\t}\n\n\tcancelAll() {\n\n\t\tthis.map.forEach( ( value, tile ) => {\n\n\t\t\tthis.cancel( tile );\n\n\t\t} );\n\n\t}\n\n}\n","import { MathUtils } from 'three';\n\nconst { clamp } = MathUtils;\nexport class FadeManager {\n\n\tconstructor() {\n\n\t\tthis.duration = 250;\n\t\tthis.fadeCount = 0;\n\t\tthis._lastTick = - 1;\n\t\tthis._fadeState = new Map();\n\t\tthis.onFadeComplete = null;\n\t\tthis.onFadeStart = null;\n\t\tthis.onFadeSetComplete = null;\n\t\tthis.onFadeSetStart = null;\n\n\t}\n\n\t// delete the object from the fade, reset the material data\n\tdeleteObject( object ) {\n\n\t\tif ( ! object ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.completeFade( object );\n\n\t}\n\n\t// Ensure we're storing a fade timer for the provided object\n\t// Returns whether a new state had to be added\n\tguaranteeState( object ) {\n\n\t\tconst fadeState = this._fadeState;\n\t\tif ( fadeState.has( object ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst state = {\n\t\t\tfadeInTarget: 0,\n\t\t\tfadeOutTarget: 0,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t};\n\n\t\tfadeState.set( object, state );\n\n\t\treturn true;\n\n\t}\n\n\t// Force the fade to complete in the direction it is already trending\n\tcompleteFade( object ) {\n\n\t\tconst fadeState = this._fadeState;\n\t\tif ( ! fadeState.has( object ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst visible = fadeState.get( object ).fadeOutTarget === 0;\n\n\t\tfadeState.delete( object );\n\n\t\t// fire events\n\t\tthis.fadeCount --;\n\n\t\tif ( this.onFadeComplete ) {\n\n\t\t\tthis.onFadeComplete( object, visible );\n\n\t\t}\n\n\t\tif ( this.fadeCount === 0 && this.onFadeSetComplete ) {\n\n\t\t\tthis.onFadeSetComplete();\n\n\t\t}\n\n\t}\n\n\tcompleteAllFades() {\n\n\t\tthis._fadeState.forEach( ( value, key ) => {\n\n\t\t\tthis.completeFade( key );\n\n\t\t} );\n\n\t}\n\n\tforEachObject( cb ) {\n\n\t\tthis._fadeState.forEach( ( info, object ) => {\n\n\t\t\tcb( object, info );\n\n\t\t} );\n\n\t}\n\n\t// Fade the object in\n\tfadeIn( object ) {\n\n\t\tconst noState = this.guaranteeState( object );\n\t\tconst state = this._fadeState.get( object );\n\t\tstate.fadeInTarget = 1;\n\t\tstate.fadeOutTarget = 0;\n\t\tstate.fadeOut = 0;\n\n\t\t// Fire events\n\t\tif ( noState ) {\n\n\t\t\tthis.fadeCount ++;\n\t\t\tif ( this.fadeCount === 1 && this.onFadeSetStart ) {\n\n\t\t\t\tthis.onFadeSetStart();\n\n\t\t\t}\n\n\t\t\tif ( this.onFadeStart ) {\n\n\t\t\t\tthis.onFadeStart( object );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Fade the object out\n\tfadeOut( object ) {\n\n\t\tconst noState = this.guaranteeState( object );\n\t\tconst state = this._fadeState.get( object );\n\t\tstate.fadeOutTarget = 1;\n\n\t\t// Fire events and initialize state\n\t\tif ( noState ) {\n\n\t\t\tstate.fadeInTarget = 1;\n\t\t\tstate.fadeIn = 1;\n\n\t\t\tthis.fadeCount ++;\n\t\t\tif ( this.fadeCount === 1 && this.onFadeSetStart ) {\n\n\t\t\t\tthis.onFadeSetStart();\n\n\t\t\t}\n\n\t\t\tif ( this.onFadeStart ) {\n\n\t\t\t\tthis.onFadeStart( object );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tisFading( object ) {\n\n\t\treturn this._fadeState.has( object );\n\n\t}\n\n\tisFadingOut( object ) {\n\n\t\tconst state = this._fadeState.get( object );\n\t\treturn state && state.fadeOutTarget === 1;\n\n\t}\n\n\t// Tick the fade timer for each actively fading object\n\tupdate() {\n\n\t\t// clamp delta in case duration is really small or 0\n\t\tconst time = window.performance.now();\n\t\tif ( this._lastTick === - 1 ) {\n\n\t\t\tthis._lastTick = time;\n\n\t\t}\n\n\t\tconst delta = clamp( ( time - this._lastTick ) / this.duration, 0, 1 );\n\t\tthis._lastTick = time;\n\n\t\tconst fadeState = this._fadeState;\n\t\tfadeState.forEach( ( state, object ) => {\n\n\t\t\t// tick the fade values\n\t\t\tconst {\n\t\t\t\tfadeOutTarget,\n\t\t\t\tfadeInTarget,\n\t\t\t} = state;\n\n\t\t\tlet {\n\t\t\t\tfadeOut,\n\t\t\t\tfadeIn,\n\t\t\t} = state;\n\n\t\t\tconst fadeInSign = Math.sign( fadeInTarget - fadeIn );\n\t\t\tfadeIn = clamp( fadeIn + fadeInSign * delta, 0, 1 );\n\n\t\t\tconst fadeOutSign = Math.sign( fadeOutTarget - fadeOut );\n\t\t\tfadeOut = clamp( fadeOut + fadeOutSign * delta, 0, 1 );\n\n\t\t\tstate.fadeIn = fadeIn;\n\t\t\tstate.fadeOut = fadeOut;\n\n\t\t\t// Check if the fade in and fade out animations are complete\n\t\t\tconst fadeOutComplete = fadeOut === 1 || fadeOut === 0;\n\t\t\tconst fadeInComplete = fadeIn === 1 || fadeIn === 0;\n\n\t\t\t// If they are or the fade out animation is further along than the\n\t\t\t// fade in animation then mark the fade as completed for this tile\n\t\t\tif ( ( fadeOutComplete && fadeInComplete ) || fadeOut >= fadeIn ) {\n\n\t\t\t\tthis.completeFade( object );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n","// Adjusts the provided material to support fading in and out using a bayer pattern. Providing a \"previous\"\n// before compile can be used to chain shader adjustments. Returns the added uniforms used for fading.\nconst FADE_PARAMS = Symbol( 'FADE_PARAMS' );\nexport function wrapFadeMaterial( material, previousOnBeforeCompile ) {\n\n\t// if the material has already been wrapped then return the params\n\tif ( material[ FADE_PARAMS ] ) {\n\n\t\treturn material[ FADE_PARAMS ];\n\n\t}\n\n\tconst params = {\n\t\tfadeIn: { value: 0 },\n\t\tfadeOut: { value: 0 },\n\t\tfadeTexture: { value: null },\n\t};\n\n\tmaterial[ FADE_PARAMS ] = params;\n\n\tmaterial.defines = {\n\t\t...( material.defines || {} ),\n\t\tFEATURE_FADE: 0,\n\t};\n\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tif ( previousOnBeforeCompile ) {\n\n\t\t\tpreviousOnBeforeCompile( shader );\n\n\t\t}\n\n\t\tshader.uniforms = {\n\t\t\t...shader.uniforms,\n\t\t\t...params,\n\t\t};\n\n\t\tshader.vertexShader = shader.vertexShader\n\t\t\t.replace(\n\t\t\t\t/void\\s+main\\(\\)\\s+{/,\n\t\t\t\tvalue => /* glsl */`\n\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\tvarying float vBatchId;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t${ value }\n\n\t\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\t\t// add 0.5 to the value to avoid floating error that may cause flickering\n\t\t\t\t\t\tvBatchId = getIndirectIndex( gl_DrawID ) + 0.5;\n\n\t\t\t\t\t\t#endif\n\t\t\t\t`\n\t\t\t);\n\n\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t// adapted from https://www.shadertoy.com/view/Mlt3z8\n\t\t\t\tfloat bayerDither2x2( vec2 v ) {\n\n\t\t\t\t\treturn mod( 3.0 * v.y + 2.0 * v.x, 4.0 );\n\n\t\t\t\t}\n\n\t\t\t\tfloat bayerDither4x4( vec2 v ) {\n\n\t\t\t\t\tvec2 P1 = mod( v, 2.0 );\n\t\t\t\t\tvec2 P2 = floor( 0.5 * mod( v, 4.0 ) );\n\t\t\t\t\treturn 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );\n\n\t\t\t\t}\n\n\t\t\t\t// the USE_BATCHING define is not available in fragment shaders\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t// functions for reading the fade state of a given batch id\n\t\t\t\tuniform sampler2D fadeTexture;\n\t\t\t\tvarying float vBatchId;\n\t\t\t\tvec2 getFadeValues( const in float i ) {\n\n\t\t\t\t\tint size = textureSize( fadeTexture, 0 ).x;\n\t\t\t\t\tint j = int( i );\n\t\t\t\t\tint x = j % size;\n\t\t\t\t\tint y = j / size;\n\t\t\t\t\treturn texelFetch( fadeTexture, ivec2( x, y ), 0 ).rg;\n\n\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\tuniform float fadeIn;\n\t\t\t\tuniform float fadeOut;\n\n\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t${ value }\n\t\t\t` )\n\t\t\t.replace( /#include <dithering_fragment>/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\tvec2 fadeValues = getFadeValues( vBatchId );\n\t\t\t\tfloat fadeIn = fadeValues.r;\n\t\t\t\tfloat fadeOut = fadeValues.g;\n\n\t\t\t\t#endif\n\n\t\t\t\tfloat bayerValue = bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) );\n\t\t\t\tfloat bayerBins = 16.0;\n\t\t\t\tfloat dither = ( 0.5 + bayerValue ) / bayerBins;\n\t\t\t\tif ( dither >= fadeIn ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\tif ( dither < fadeOut ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t` );\n\n\t};\n\n\treturn params;\n\n}\n","import { wrapFadeMaterial } from './wrapFadeMaterial.js';\n\n// Class for managing and updating extended fade parameters\nexport class FadeMaterialManager {\n\n\tconstructor() {\n\n\t\tthis._fadeParams = new WeakMap();\n\t\tthis.fading = 0;\n\n\t}\n\n\t// Set the fade parameters for the given scene\n\tsetFade( scene, fadeIn, fadeOut ) {\n\n\t\tif ( ! scene ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// traverse the scene and update the fade parameters of all materials\n\t\tconst fadeParams = this._fadeParams;\n\t\tscene.traverse( child => {\n\n\t\t\tconst material = child.material;\n\t\t\tif ( material && fadeParams.has( material ) ) {\n\n\t\t\t\tconst params = fadeParams.get( material );\n\t\t\t\tparams.fadeIn.value = fadeIn;\n\t\t\t\tparams.fadeOut.value = fadeOut;\n\n\t\t\t\tconst fadeInComplete = fadeIn === 0 || fadeIn === 1;\n\t\t\t\tconst fadeOutComplete = fadeOut === 0 || fadeOut === 1;\n\t\t\t\tconst value = Number( ! fadeInComplete || ! fadeOutComplete );\n\t\t\t\tif ( material.defines.FEATURE_FADE !== value ) {\n\n\t\t\t\t\tthis.fading += value === 1 ? 1 : - 1;\n\t\t\t\t\tmaterial.defines.FEATURE_FADE = value;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// initialize materials in the object\n\tprepareScene( scene ) {\n\n\t\tscene.traverse( child => {\n\n\t\t\tif ( child.material ) {\n\n\t\t\t\tthis.prepareMaterial( child.material );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// delete the object from the fade, reset the material data\n\tdeleteScene( scene ) {\n\n\t\tif ( ! scene ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// mark the materials such that they are displayed at full value\n\t\tthis.setFade( scene, 1, 0 );\n\n\t\t// revert the materials\n\t\tconst fadeParams = this._fadeParams;\n\t\tscene.traverse( child => {\n\n\t\t\tconst material = child.material;\n\t\t\tif ( material ) {\n\n\t\t\t\tfadeParams.delete( material );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// initialize the material\n\tprepareMaterial( material ) {\n\n\t\tconst fadeParams = this._fadeParams;\n\t\tif ( fadeParams.has( material ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tfadeParams.set( material, wrapFadeMaterial( material, material.onBeforeCompile ) );\n\n\t}\n\n}\n","import { MeshBasicMaterial } from 'three';\n\n// A hacky version of BatchedMesh that passes through functions and geometry and other fields from the underlying\n// BatchedMesh. Calls to \"this\" or \"super\" will not work in subfunctions.\nexport class PassThroughBatchedMesh {\n\n\tconstructor( other, material = new MeshBasicMaterial() ) {\n\n\t\t// the other batched mesh\n\t\tthis.other = other;\n\n\t\t// guarded fields\n\t\tthis.material = material;\n\t\tthis.visible = true;\n\t\tthis.parent = null;\n\t\tthis._instanceInfo = [];\n\t\tthis._visibilityChanged = true;\n\n\t\t// the proxy instance tht pass through arguments to the underlying mesh\n\t\tconst proxyTarget = new Proxy( this, {\n\n\t\t\tget( target, key ) {\n\n\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\treturn target[ key ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// sync instances on function call and call functions on \"this\" instance\n\t\t\t\t\tconst value = other[ key ];\n\t\t\t\t\tif ( value instanceof Function ) {\n\n\t\t\t\t\t\treturn ( ...args ) => {\n\n\t\t\t\t\t\t\ttarget.syncInstances();\n\t\t\t\t\t\t\treturn value.call( proxyTarget, ...args );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn other[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tset( target, key, value ) {\n\n\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\ttarget[ key ] = value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tother[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t},\n\n\t\t\tdeleteProperty( target, key ) {\n\n\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\treturn delete target[ key ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn delete other[ key ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// ownKeys() {},\n\t\t\t// has(target, key) {},\n\t\t\t// defineProperty(target, key, descriptor) {},\n\t\t\t// getOwnPropertyDescriptor(target, key) {},\n\n\t\t} );\n\n\t\treturn proxyTarget;\n\n\t}\n\n\tsyncInstances() {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst otherInstanceInfo = this.other._instanceInfo;\n\t\twhile ( otherInstanceInfo.length > instanceInfo.length ) {\n\n\t\t\tconst index = instanceInfo.length;\n\t\t\tinstanceInfo.push( new Proxy( { visible: false }, {\n\n\t\t\t\tget( target, key ) {\n\n\t\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\t\treturn target[ key ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn otherInstanceInfo[ index ][ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tset( target, key, value ) {\n\n\t\t\t\t\tif ( key in target ) {\n\n\t\t\t\t\t\ttarget[ key ] = value;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\totherInstanceInfo[ index ][ key ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} ) );\n\n\t\t}\n\n\t}\n\n}\n","import { PassThroughBatchedMesh } from './PassThroughBatchedMesh.js';\nimport { RGFormat, UnsignedByteType, DataTexture } from 'three';\nimport { wrapFadeMaterial } from './wrapFadeMaterial.js';\n\n// BatchedMesh instance that can fade materials\nexport class FadeBatchedMesh extends PassThroughBatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\t// construct a version of the material that supports fading\n\t\tconst material = this.material;\n\t\tconst params = wrapFadeMaterial( material, material.onBeforeCompile );\n\t\tmaterial.defines.FEATURE_FADE = 1;\n\t\tmaterial.defines.USE_BATCHING_FRAG = 1;\n\t\tmaterial.needsUpdate = true;\n\n\t\t// fade parameters\n\t\tthis.fadeTexture = null;\n\t\tthis._fadeParams = params;\n\n\t}\n\n\t// Set the fade state\n\tsetFadeAt( index, fadeIn, fadeOut ) {\n\n\t\tthis._initFadeTexture();\n\t\tthis.fadeTexture.setValueAt( index, fadeIn * 255, fadeOut * 255 );\n\n\t}\n\n\t// initialize the texture and resize it if needed\n\t_initFadeTexture() {\n\n\t\t// calculate the new size\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\tconst length = size * size * 2;\n\t\tconst oldFadeTexture = this.fadeTexture;\n\t\tif ( ! oldFadeTexture || oldFadeTexture.image.data.length !== length ) {\n\n\t\t\t// 2 bytes per RG pixel\n\t\t\tconst fadeArray = new Uint8Array( length );\n\t\t\tconst fadeTexture = new InstanceDataTexture( fadeArray, size, size, RGFormat, UnsignedByteType );\n\n\t\t\t// copy the data from the old fade texture if it exists\n\t\t\tif ( oldFadeTexture ) {\n\n\t\t\t\toldFadeTexture.dispose();\n\n\t\t\t\tconst src = oldFadeTexture.image.data;\n\t\t\t\tconst dst = this.fadeTexture.image.data;\n\t\t\t\tconst len = Math.min( src.length, dst.length );\n\t\t\t\tdst.set( new src.constructor( src.buffer, 0, len ) );\n\n\t\t\t}\n\n\t\t\t// assign the new fade texture to the uniform, member variable\n\t\t\tthis.fadeTexture = fadeTexture;\n\t\t\tthis._fadeParams.fadeTexture.value = fadeTexture;\n\t\t\tfadeTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t// dispose the fade texture. Super cannot be used here due to proxy\n\tdispose() {\n\n\t\tif ( this.fadeTexture ) {\n\n\t\t\tthis.fadeTexture.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n// Version of data texture that can assign pixel values\nclass InstanceDataTexture extends DataTexture {\n\n\tsetValueAt( instance, ...values ) {\n\n\t\tconst { data, width, height } = this.image;\n\t\tconst itemSize = Math.floor( data.length / ( width * height ) );\n\t\tlet needsUpdate = false;\n\t\tfor ( let i = 0; i < itemSize; i ++ ) {\n\n\t\t\tconst index = instance * itemSize + i;\n\t\t\tconst prevValue = data[ index ];\n\t\t\tconst newValue = values[ i ] || 0;\n\t\t\tif ( prevValue !== newValue ) {\n\n\t\t\t\tdata[ index ] = newValue;\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4, Vector3, Quaternion } from 'three';\nimport { FadeManager } from './FadeManager.js';\nimport { FadeMaterialManager } from './FadeMaterialManager.js';\nimport { FadeBatchedMesh } from './FadeBatchedMesh.js';\n\nconst HAS_POPPED_IN = Symbol( 'HAS_POPPED_IN' );\nconst _fromPos = new Vector3();\nconst _toPos = new Vector3();\nconst _fromQuat = new Quaternion();\nconst _toQuat = new Quaternion();\nconst _scale = new Vector3();\n\nfunction onUpdateBefore() {\n\n\tconst fadeManager = this._fadeManager;\n\tconst tiles = this.tiles;\n\n\t// store the tiles renderer state before the tiles update so we can check\n\t// whether fading started or stopped completely\n\tthis._fadingBefore = fadeManager.fadeCount;\n\tthis._displayActiveTiles = tiles.displayActiveTiles;\n\n\t// we need to display all active tiles in this case so we don't fade tiles in\n\t// when moving from off screen\n\ttiles.displayActiveTiles = true;\n\n}\n\nfunction onUpdateAfter() {\n\n\tconst fadeManager = this._fadeManager;\n\tconst fadeMaterialManager = this._fadeMaterialManager;\n\tconst displayActiveTiles = this._displayActiveTiles;\n\tconst fadingBefore = this._fadingBefore;\n\tconst prevCameraTransforms = this._prevCameraTransforms;\n\tconst { tiles, maximumFadeOutTiles, batchedMesh } = this;\n\tconst { cameras } = tiles;\n\n\t// reset the active tiles flag\n\ttiles.displayActiveTiles = displayActiveTiles;\n\n\t// update fade step\n\tfadeManager.update();\n\n\t// fire an event\n\tconst fadingAfter = fadeManager.fadeCount;\n\tif ( fadingBefore !== 0 && fadingAfter !== 0 ) {\n\n\t\ttiles.dispatchEvent( { type: 'fade-change' } );\n\t\ttiles.dispatchEvent( { type: 'needs-render' } );\n\n\t}\n\n\t// update the visibility of tiles based on visibility since we must use\n\t// the active tiles for rendering fade\n\tif ( ! displayActiveTiles ) {\n\n\t\ttiles.visibleTiles.forEach( t => {\n\n\t\t\t// if a tile is fading out then it may not be traversed and thus will not have\n\t\t\t// the frustum flag set correctly.\n\t\t\tconst scene = t.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.visible = t.__inFrustum;\n\n\t\t\t}\n\n\t\t\tthis.forEachBatchIds( t, ( id, batchedMesh, plugin ) => {\n\n\t\t\t\tbatchedMesh.setVisibleAt( id, t.__inFrustum );\n\t\t\t\tplugin.batchedMesh.setVisibleAt( id, t.__inFrustum );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\tif ( maximumFadeOutTiles < this._fadingOutCount ) {\n\n\t\t// determine whether all the rendering cameras are moving\n\t\t// quickly so we can adjust how tiles fade accordingly\n\t\tlet isMovingFast = true;\n\t\tcameras.forEach( camera => {\n\n\t\t\tif ( ! prevCameraTransforms.has( camera ) ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currMatrix = camera.matrixWorld;\n\t\t\tconst prevMatrix = prevCameraTransforms.get( camera );\n\n\t\t\tcurrMatrix.decompose( _toPos, _toQuat, _scale );\n\t\t\tprevMatrix.decompose( _fromPos, _fromQuat, _scale );\n\n\t\t\tconst angleTo = _toQuat.angleTo( _fromQuat );\n\t\t\tconst positionTo = _toPos.distanceTo( _fromPos );\n\n\t\t\t// if rotation is moving > 0.25 radians per frame or position is moving > 0.1 units\n\t\t\t// then we are considering the camera to be moving too fast to notice a faster / abrupt fade\n\t\t\tisMovingFast = isMovingFast && ( angleTo > 0.25 || positionTo > 0.1 );\n\n\t\t} );\n\n\t\tif ( isMovingFast ) {\n\n\t\t\tfadeManager.completeAllFades();\n\n\t\t}\n\n\t}\n\n\t// track the camera movement so we can use it for next frame\n\tcameras.forEach( camera => {\n\n\t\tprevCameraTransforms.get( camera ).copy( camera.matrixWorld );\n\n\t} );\n\n\t// update the fade state for each tile\n\tfadeManager.forEachObject( ( tile, { fadeIn, fadeOut } ) => {\n\n\t\t// prevent faded tiles from being unloaded\n\t\tconst scene = tile.cached.scene;\n\t\tconst isFadingOut = fadeManager.isFadingOut( tile );\n\t\ttiles.markTileUsed( tile );\n\t\tif ( scene ) {\n\n\t\t\tfadeMaterialManager.setFade( scene, fadeIn, fadeOut );\n\t\t\tif ( isFadingOut ) {\n\n\t\t\t\tscene.visible = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// fade the tiles and toggle the visibility appropriately\n\t\tthis.forEachBatchIds( tile, ( id, batchedMesh, plugin ) => {\n\n\t\t\tbatchedMesh.setFadeAt( id, fadeIn, fadeOut );\n\t\t\tbatchedMesh.setVisibleAt( id, true );\n\t\t\tplugin.batchedMesh.setVisibleAt( id, false );\n\n\t\t} );\n\n\t} );\n\n\t// update the batched mesh fields\n\tif ( batchedMesh ) {\n\n\t\tconst material = tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' ).batchedMesh.material;\n\t\tbatchedMesh.material.map = material.map;\n\n\t}\n\n}\n\nexport class TilesFadePlugin {\n\n\tget fadeDuration() {\n\n\t\treturn this._fadeManager.duration;\n\n\t}\n\n\tset fadeDuration( value ) {\n\n\t\tthis._fadeManager.duration = Number( value );\n\n\t}\n\n\tget fadingTiles() {\n\n\t\treturn this._fadeManager.fadeCount;\n\n\t}\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\n\t\t\tmaximumFadeOutTiles: 50,\n\t\t\tfadeRootTiles: false,\n\t\t\tfadeDuration: 250,\n\t\t\t...options,\n\n\t\t};\n\n\t\tthis.name = 'FADE_TILES_PLUGIN';\n\t\tthis.priority = - 2;\n\n\t\tthis.tiles = null;\n\t\tthis.batchedMesh = null;\n\t\tthis._quickFadeTiles = new Set();\n\t\tthis._fadeManager = new FadeManager();\n\t\tthis._fadeMaterialManager = new FadeMaterialManager();\n\t\tthis._prevCameraTransforms = null;\n\t\tthis._fadingOutCount = 0;\n\n\t\tthis.maximumFadeOutTiles = options.maximumFadeOutTiles;\n\t\tthis.fadeRootTiles = options.fadeRootTiles;\n\t\tthis.fadeDuration = options.fadeDuration;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\t// event callback initialization\n\t\tthis._onLoadModel = ( { scene } )=> {\n\n\t\t\t// initialize all the scene materials to fade\n\t\t\tthis._fadeMaterialManager.prepareScene( scene );\n\n\t\t};\n\t\tthis._onDisposeModel = ( { tile, scene } ) => {\n\n\t\t\tif ( this.tiles.visibleTiles.has( tile ) ) {\n\n\t\t\t\t// mark the parent as needing to fade in quickly to accommodate the children disappearing.\n\t\t\t\t// this can happen when a tile is forcefully disposed or removed from the lru cache while visible.\n\t\t\t\tthis._quickFadeTiles.add( tile.parent );\n\n\t\t\t}\n\n\t\t\t// delete the fade info from the managers on disposal of model\n\t\t\tthis._fadeManager.deleteObject( tile );\n\t\t\tthis._fadeMaterialManager.deleteScene( scene );\n\n\t\t};\n\t\tthis._onAddCamera = ( { camera } ) => {\n\n\t\t\t// track the camera transform\n\t\t\tthis._prevCameraTransforms.set( camera, new Matrix4() );\n\n\t\t};\n\t\tthis._onDeleteCamera = ( { camera } )=> {\n\n\t\t\t// remove the camera transform\n\t\t\tthis._prevCameraTransforms.delete( camera );\n\n\t\t};\n\t\tthis._onTileVisibilityChange = ( { tile, visible } ) => {\n\n\t\t\t// this function gets fired _after_ all set visible callbacks including the batched meshes\n\n\t\t\t// revert the scene and fade to the initial state when toggling\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.visible = true;\n\n\t\t\t}\n\n\t\t\tthis.forEachBatchIds( tile, ( id, batchedMesh, plugin ) => {\n\n\t\t\t\tbatchedMesh.setFadeAt( id, 0, 0 );\n\t\t\t\tbatchedMesh.setVisibleAt( id, false );\n\t\t\t\tplugin.batchedMesh.setVisibleAt( id, false );\n\n\t\t\t} );\n\n\t\t};\n\t\tthis._onUpdateBefore = () => {\n\n\t\t\tonUpdateBefore.call( this );\n\n\t\t};\n\t\tthis._onUpdateAfter = () => {\n\n\t\t\tonUpdateAfter.call( this );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'load-model', this._onLoadModel );\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModel );\n\t\ttiles.addEventListener( 'add-camera', this._onAddCamera );\n\t\ttiles.addEventListener( 'delete-camera', this._onDeleteCamera );\n\t\ttiles.addEventListener( 'update-before', this._onUpdateBefore );\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onTileVisibilityChange );\n\n\t\t// initialize fade manager\n\t\tconst fadeManager = this._fadeManager;\n\t\tfadeManager.onFadeSetStart = () => {\n\n\t\t\ttiles.dispatchEvent( { type: 'fade-start' } );\n\t\t\ttiles.dispatchEvent( { type: 'needs-render' } );\n\n\t\t};\n\n\t\tfadeManager.onFadeSetComplete = () => {\n\n\t\t\ttiles.dispatchEvent( { type: 'fade-end' } );\n\t\t\ttiles.dispatchEvent( { type: 'needs-render' } );\n\n\t\t};\n\n\t\tfadeManager.onFadeComplete = ( tile, visible ) => {\n\n\t\t\t// mark the fade as finished and reset the fade parameters\n\t\t\tthis._fadeMaterialManager.setFade( tile.cached.scene, 0, 0 );\n\n\t\t\tthis.forEachBatchIds( tile, ( id, batchedMesh, plugin ) => {\n\n\t\t\t\tbatchedMesh.setFadeAt( id, 0, 0 );\n\t\t\t\tbatchedMesh.setVisibleAt( id, false );\n\t\t\t\tplugin.batchedMesh.setVisibleAt( id, visible );\n\n\t\t\t} );\n\n\t\t\tif ( ! visible ) {\n\n\t\t\t\t// now that the tile is hidden we can run the built-in setTileVisible function for the tile\n\t\t\t\ttiles.invokeOnePlugin( plugin => plugin !== this && plugin.setTileVisible && plugin.setTileVisible( tile, false ) );\n\t\t\t\tthis._fadingOutCount --;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// initialize the state based on what's already present\n\t\tconst prevCameraTransforms = new Map();\n\t\ttiles.cameras.forEach( camera => {\n\n\t\t\tprevCameraTransforms.set( camera, new Matrix4() );\n\n\t\t} );\n\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._onLoadModel( { scene } );\n\n\t\t} );\n\n\t\tthis.tiles = tiles;\n\t\tthis._fadeManager = fadeManager;\n\t\tthis._prevCameraTransforms = prevCameraTransforms;\n\n\t}\n\n\t// initializes the batched mesh if it needs to be, dispose if it it's no longer needed\n\tinitBatchedMesh() {\n\n\t\tconst otherBatchedMesh = this.tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' )?.batchedMesh;\n\t\tif ( otherBatchedMesh ) {\n\n\t\t\tif ( this.batchedMesh === null ) {\n\n\t\t\t\tthis._onBatchedMeshDispose = () => {\n\n\t\t\t\t\tthis.batchedMesh.dispose();\n\t\t\t\t\tthis.batchedMesh.removeFromParent();\n\t\t\t\t\tthis.batchedMesh = null;\n\t\t\t\t\totherBatchedMesh.removeEventListener( 'dispose', this._onBatchedMeshDispose );\n\n\t\t\t\t};\n\n\t\t\t\tconst material = otherBatchedMesh.material.clone();\n\t\t\t\tmaterial.onBeforeCompile = otherBatchedMesh.material.onBeforeCompile;\n\n\t\t\t\tthis.batchedMesh = new FadeBatchedMesh( otherBatchedMesh, material );\n\t\t\t\tthis.tiles.group.add( this.batchedMesh );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\t\tthis._onBatchedMeshDispose();\n\t\t\t\tthis._onBatchedMeshDispose = null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// callback for fading to prevent tiles from being removed until the fade effect has completed\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst fadeManager = this._fadeManager;\n\n\t\t// track the fade state\n\t\tconst wasFading = fadeManager.isFading( tile );\n\t\tif ( fadeManager.isFadingOut( tile ) ) {\n\n\t\t\tthis._fadingOutCount --;\n\n\t\t}\n\n\t\t// trigger any necessary fades\n\t\tif ( ! visible ) {\n\n\t\t\tthis._fadingOutCount ++;\n\t\t\tfadeManager.fadeOut( tile );\n\n\t\t} else {\n\n\t\t\t// if this is a root renderable tile and this is the first time rendering in\n\t\t\t// then pop it in\n\t\t\tconst isRootRenderableTile = tile.__depthFromRenderedParent === 1;\n\t\t\tif ( isRootRenderableTile ) {\n\n\t\t\t\tif ( tile[ HAS_POPPED_IN ] || this.fadeRootTiles ) {\n\n\t\t\t\t\tthis._fadeManager.fadeIn( tile );\n\n\t\t\t\t}\n\n\t\t\t\ttile[ HAS_POPPED_IN ] = true;\n\n\t\t\t} else {\n\n\t\t\t\tthis._fadeManager.fadeIn( tile );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if a tile needs to be jumped in then complete the fade here\n\t\tif ( this._quickFadeTiles.has( tile ) ) {\n\n\t\t\tthis._fadeManager.completeFade( tile );\n\t\t\tthis._quickFadeTiles.delete( tile );\n\n\t\t}\n\n\t\t// if a tile was already fading then it's already marked as visible and in the scene\n\t\tif ( wasFading ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// cancel the visibility change trigger because we're fading and will call this after\n\t\t// fade completes.\n\t\tconst isFading = this._fadeManager.isFading( tile );\n\t\tif ( ! visible && isFading ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tdispose() {\n\n\t\tconst tiles = this.tiles;\n\n\t\tthis._fadeManager.completeAllFades();\n\n\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\tthis._onBatchedMeshDispose();\n\n\t\t}\n\n\t\ttiles.removeEventListener( 'load-model', this._onLoadModel );\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModel );\n\t\ttiles.removeEventListener( 'add-camera', this._onAddCamera );\n\t\ttiles.removeEventListener( 'delete-camera', this._onDeleteCamera );\n\t\ttiles.removeEventListener( 'update-before', this._onUpdateBefore );\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.removeEventListener( 'tile-visibility-change', this._onTileVisibilityChange );\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._fadeManager.deleteObject( tile );\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.visible = true; // TODO\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// helper for iterating over the batch ids for a given tile\n\tforEachBatchIds( tile, cb ) {\n\n\t\tthis.initBatchedMesh();\n\n\t\tif ( this.batchedMesh ) {\n\n\t\t\tconst batchedPlugin = this.tiles.getPluginByName( 'BATCHED_TILES_PLUGIN' );\n\t\t\tconst instanceIds = batchedPlugin.getTileBatchIds( tile );\n\t\t\tif ( instanceIds ) {\n\n\t\t\t\tinstanceIds.forEach( id => {\n\n\t\t\t\t\tcb( id, this.batchedMesh, batchedPlugin );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","import { BatchedMesh, Matrix4, Vector3, Source } from 'three';\n\nconst matrix = new Matrix4();\nconst vec1 = new Vector3();\nconst vec2 = new Vector3();\nexport class ModelViewBatchedMesh extends BatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.resetDistance = 1e4;\n\t\tthis._matricesTextureHandle = null;\n\t\tthis._lastCameraPos = new Matrix4();\n\t\tthis._forceUpdate = true;\n\n\t\tthis._matrices = [];\n\n\t}\n\n\tsetMatrixAt( instanceId, matrix ) {\n\n\t\tsuper.setMatrixAt( instanceId, matrix );\n\t\tthis._forceUpdate = true;\n\n\t\t// save the matrices in their original float64 format to avoid\n\t\t// precision errors when multiplying later\n\t\tconst matrices = this._matrices;\n\t\twhile ( matrices.length <= instanceId ) {\n\n\t\t\tmatrices.push( new Matrix4() );\n\n\t\t}\n\n\t\tmatrices[ instanceId ].copy( matrix );\n\n\t}\n\n\tsetInstanceCount( ...args ) {\n\n\t\tsuper.setInstanceCount( ...args );\n\n\t\tconst matrices = this._matrices;\n\t\twhile ( matrices.length > this.instanceCount ) {\n\n\t\t\tmatrices.pop();\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material, group ) {\n\n\t\t// ensure matrices are complete and up to date\n\t\tsuper.onBeforeRender( renderer, scene, camera, geometry, material, group );\n\n\t\t// retrieve camera before and after camera positions\n\t\tvec1.setFromMatrixPosition( camera.matrixWorld );\n\t\tvec2.setFromMatrixPosition( this._lastCameraPos );\n\n\t\t// initialize the model-view matrix texture if needed\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tlet modelViewMatricesTexture = this._modelViewMatricesTexture;\n\t\tif (\n\t\t\t! modelViewMatricesTexture ||\n\t\t\tmodelViewMatricesTexture.image.width !== matricesTexture.image.width ||\n\t\t\tmodelViewMatricesTexture.image.height !== matricesTexture.image.height\n\t\t) {\n\n\t\t\tif ( modelViewMatricesTexture ) {\n\n\t\t\t\tmodelViewMatricesTexture.dispose();\n\n\t\t\t}\n\n\t\t\tmodelViewMatricesTexture = matricesTexture.clone();\n\t\t\tmodelViewMatricesTexture.source = new Source( {\n\t\t\t\t...modelViewMatricesTexture.image,\n\t\t\t\tdata: modelViewMatricesTexture.image.data.slice(),\n\t\t\t} );\n\n\t\t\tthis._modelViewMatricesTexture = modelViewMatricesTexture;\n\n\t\t}\n\n\t\t// check if we need to update the model view matrices\n\t\tif ( this._forceUpdate || vec1.distanceTo( vec2 ) > this.resetDistance ) {\n\n\t\t\t// transform each objects matrix into local camera frame to avoid precision issues\n\t\t\tconst matrices = this._matrices;\n\t\t\tconst modelViewArray = modelViewMatricesTexture.image.data;\n\t\t\tfor ( let i = 0; i < this.maxInstanceCount; i ++ ) {\n\n\t\t\t\tconst instanceMatrix = matrices[ i ];\n\t\t\t\tif ( instanceMatrix ) {\n\n\t\t\t\t\tmatrix.copy( instanceMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t}\n\n\t\t\t\tmatrix\n\t\t\t\t\t.premultiply( this.matrixWorld )\n\t\t\t\t\t.premultiply( camera.matrixWorldInverse )\n\t\t\t\t\t.toArray( modelViewArray, i * 16 );\n\n\t\t\t}\n\n\t\t\tmodelViewMatricesTexture.needsUpdate = true;\n\t\t\tthis._lastCameraPos.copy( camera.matrixWorld );\n\t\t\tthis._forceUpdate = false;\n\n\t\t}\n\n\t\t// save handles, and transform the matrix world into the camera frame used to position the mesh instances\n\t\t// to offset the position shift.\n\t\tthis._matricesTextureHandle = this._matricesTexture;\n\t\tthis._matricesTexture = this._modelViewMatricesTexture;\n\t\tthis.matrixWorld.copy( this._lastCameraPos );\n\n\t}\n\n\tonAfterRender() {\n\n\t\tthis.updateMatrixWorld();\n\t\tthis._matricesTexture = this._matricesTextureHandle;\n\t\tthis._matricesTextureHandle = null;\n\n\t}\n\n\tonAfterShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onAfterRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tif ( this._modelViewMatricesTexture ) {\n\n\t\t\tthis._modelViewMatricesTexture.dispose();\n\n\t\t}\n\n\t}\n\n}\n","import { Mesh, Box3, Sphere } from 'three';\nimport { ModelViewBatchedMesh } from './ModelViewBatchedMesh.js';\n\nconst _raycastMesh = new Mesh();\nconst _batchIntersects = [];\n\n// Implementation of BatchedMesh that automatically expands\nexport class ExpandingBatchedMesh extends ModelViewBatchedMesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.expandPercent = 0.25;\n\t\tthis.maxInstanceExpansionSize = Infinity;\n\n\t\t// set of available geometry ids that are no longer being used\n\t\tthis._freeGeometryIds = [];\n\n\t}\n\n\t// Finds a free id that can fit the geometry with the requested ranges. Returns -1 if it could not be found.\n\tfindFreeId( geometry, reservedVertexRange, reservedIndexRange ) {\n\n\t\tconst needsIndex = Boolean( this.geometry.index );\n\t\tconst neededIndexCount = Math.max( needsIndex ? geometry.index.count : - 1, reservedIndexRange );\n\t\tconst neededVertexCount = Math.max( geometry.attributes.position.count, reservedVertexRange );\n\n\t\tlet bestIndex = - 1;\n\t\tlet bestScore = Infinity;\n\t\tconst freeGeometryIds = this._freeGeometryIds;\n\t\tfreeGeometryIds.forEach( ( id, i ) => {\n\n\t\t\t// if indices are not needed then they default to - 1\n\t\t\tconst geometryInfo = this.getGeometryRangeAt( id );\n\t\t\tconst { reservedIndexCount, reservedVertexCount } = geometryInfo;\n\t\t\tif ( reservedIndexCount >= neededIndexCount && reservedVertexCount >= neededVertexCount ) {\n\n\t\t\t\t// generate score that is a combination of how much unused space a geometry would have if used and pick the\n\t\t\t\t// one with the least amount of unused space.\n\t\t\t\tconst score = ( neededIndexCount - reservedIndexCount ) + ( neededVertexCount - reservedVertexCount );\n\t\t\t\tif ( score < bestScore ) {\n\n\t\t\t\t\tbestIndex = i;\n\t\t\t\t\tbestScore = score;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( bestIndex !== - 1 ) {\n\n\t\t\t// remove the id from the array\n\t\t\tconst id = freeGeometryIds[ bestIndex ];\n\t\t\tfreeGeometryIds.splice( bestIndex, 1 );\n\n\t\t\treturn id;\n\n\t\t} else {\n\n\t\t\treturn - 1;\n\n\t\t}\n\n\t}\n\n\t// Overrides addGeometry to find an option geometry slot, expand, or optimized if needed\n\taddGeometry( geometry, reservedVertexRange, reservedIndexRange ) {\n\n\t\t// expand the reserved range to what geometry needs since add geometry will throw an error otherwise\n\t\tconst needsIndex = Boolean( this.geometry.index );\n\t\treservedIndexRange = Math.max( needsIndex ? geometry.index.count : - 1, reservedIndexRange );\n\t\treservedVertexRange = Math.max( geometry.attributes.position.count, reservedVertexRange );\n\n\t\tconst { expandPercent, _freeGeometryIds } = this;\n\t\tlet resultId = this.findFreeId( geometry, reservedVertexRange, reservedIndexRange );\n\t\tif ( resultId !== - 1 ) {\n\n\t\t\t// insert the geometry in the found empty space\n\t\t\tthis.setGeometryAt( resultId, geometry );\n\n\t\t} else {\n\n\t\t\tconst needsMoreSpace = () => {\n\n\t\t\t\tconst vertexNeedsSpace = this.unusedVertexCount < reservedVertexRange;\n\t\t\t\tconst indexNeedsSpace = this.unusedIndexCount < reservedIndexRange;\n\t\t\t\treturn vertexNeedsSpace || indexNeedsSpace;\n\n\t\t\t};\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\treservedVertexRange = Math.max( reservedVertexRange, position.count );\n\t\t\treservedIndexRange = Math.max( reservedIndexRange, index ? index.count : 0 );\n\n\t\t\tif ( needsMoreSpace() ) {\n\n\t\t\t\t// shift all the unused geometries to try to make space\n\t\t\t\t_freeGeometryIds.forEach( id => this.deleteGeometry( id ) );\n\t\t\t\t_freeGeometryIds.length = 0;\n\n\t\t\t\tthis.optimize();\n\n\t\t\t\tif ( needsMoreSpace() ) {\n\n\t\t\t\t\t// lastly try to expand the batched mesh size so the new geometry fits\n\n\t\t\t\t\tconst batchedIndex = this.geometry.index;\n\t\t\t\t\tconst batchedPosition = this.geometry.attributes.position;\n\n\t\t\t\t\t// compute the new geometry size to expand to accounting for the case where the geometry is not initialized\n\t\t\t\t\tlet newIndexCount, newVertexCount;\n\t\t\t\t\tif ( batchedIndex ) {\n\n\t\t\t\t\t\tconst addIndexCount = Math.ceil( expandPercent * batchedIndex.count );\n\t\t\t\t\t\tnewIndexCount = Math.max( addIndexCount, reservedIndexRange, index.count ) + batchedIndex.count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndexCount = Math.max( this.unusedIndexCount, reservedIndexRange );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( batchedPosition ) {\n\n\t\t\t\t\t\tconst addVertexCount = Math.ceil( expandPercent * batchedPosition.count );\n\t\t\t\t\t\tnewVertexCount = Math.max( addVertexCount, reservedVertexRange, position.count ) + batchedPosition.count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewVertexCount = Math.max( this.unusedVertexCount, reservedVertexRange );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setGeometrySize( newVertexCount, newIndexCount );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresultId = super.addGeometry( geometry, reservedVertexRange, reservedIndexRange );\n\n\t\t}\n\n\t\treturn resultId;\n\n\t}\n\n\t// add an instance and automatically expand the number of instances if necessary\n\taddInstance( geometryId ) {\n\n\t\tif ( this.maxInstanceCount === this.instanceCount ) {\n\n\t\t\tconst newCount = Math.ceil( this.maxInstanceCount * ( 1 + this.expandPercent ) );\n\t\t\tthis.setInstanceCount( Math.min( newCount, this.maxInstanceExpansionSize ) );\n\n\t\t}\n\n\t\treturn super.addInstance( geometryId );\n\n\t}\n\n\t// delete an instance, keeping note that the geometry id is now unused\n\tdeleteInstance( instanceId ) {\n\n\t\tconst geometryId = this.getGeometryIdAt( instanceId );\n\t\tif ( geometryId !== - 1 ) {\n\n\t\t\tthis._freeGeometryIds.push( geometryId );\n\n\t\t}\n\n\t\treturn super.deleteInstance( instanceId );\n\n\t}\n\n\t// add a function for raycasting per tile\n\traycastInstance( instanceId, raycaster, intersects ) {\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst geometryId = this.getGeometryIdAt( instanceId );\n\n\t\t// initialize the mesh\n\t\t_raycastMesh.material = this.material;\n\t\t_raycastMesh.geometry.index = batchGeometry.index;\n\t\t_raycastMesh.geometry.attributes = batchGeometry.attributes;\n\n\t\t// initialize the geometry\n\t\tconst drawRange = this.getGeometryRangeAt( geometryId );\n\t\t_raycastMesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\t\tif ( _raycastMesh.geometry.boundingBox === null ) {\n\n\t\t\t_raycastMesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _raycastMesh.geometry.boundingSphere === null ) {\n\n\t\t\t_raycastMesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\t// get the intersects\n\t\tthis.getMatrixAt( instanceId, _raycastMesh.matrixWorld ).premultiply( this.matrixWorld );\n\t\tthis.getBoundingBoxAt( geometryId, _raycastMesh.geometry.boundingBox );\n\t\tthis.getBoundingSphereAt( geometryId, _raycastMesh.geometry.boundingSphere );\n\t\t_raycastMesh.raycast( raycaster, _batchIntersects );\n\n\t\t// add batch id to the intersects\n\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\tintersect.object = this;\n\t\t\tintersect.batchId = instanceId;\n\t\t\tintersects.push( intersect );\n\n\t\t}\n\n\t\t_batchIntersects.length = 0;\n\n\t}\n\n}\n","// Returns whether the passed color is white or not\nexport function isColorWhite( color ) {\n\n\treturn color.r === 1 && color.g === 1 && color.b === 1;\n\n}\n\n// Adjusts the given material to take an ArrayTexture for a map\nexport function convertMapToArrayTexture( material ) {\n\n\tmaterial.needsUpdate = true;\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tshader.vertexShader = shader.vertexShader\n\t\t\t.replace(\n\t\t\t\t'#include <common>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#include <common>\n\t\t\t\tvarying float texture_index;\n\t\t\t\t`,\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\t'#include <uv_vertex>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#include <uv_vertex>\n\t\t\t\ttexture_index = getIndirectIndex( gl_DrawID );\n\t\t\t\t`,\n\t\t\t);\n\n\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t.replace(\n\t\t\t\t'#include <map_pars_fragment>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#ifdef USE_MAP\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tuniform sampler2DArray map;\n\t\t\t\tvarying float texture_index;\n\t\t\t\t#endif\n\t\t\t\t`,\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\t'#include <map_fragment>',\n\t\t\t\t/* glsl */`\n\t\t\t\t#ifdef USE_MAP\n\t\t\t\t\tdiffuseColor *= texture( map, vec3( vMapUv, texture_index ) );\n\t\t\t\t#endif\n\t\t\t\t`\n\t\t\t);\n\n\t};\n\n}\n","import { WebGLArrayRenderTarget, MeshBasicMaterial, DataTexture, REVISION } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { ExpandingBatchedMesh } from './ExpandingBatchedMesh.js';\nimport { convertMapToArrayTexture, isColorWhite } from './utilities.js';\n\nconst _textureRenderQuad = new FullScreenQuad( new MeshBasicMaterial() );\nconst _whiteTex = new DataTexture( new Uint8Array( [ 255, 255, 255, 255 ] ), 1, 1 );\n_whiteTex.needsUpdate = true;\n\nexport class BatchedTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( parseInt( REVISION ) < 170 ) {\n\n\t\t\tthrow new Error( 'BatchedTilesPlugin: Three.js revision 170 or higher required.' );\n\n\t\t}\n\n\t\toptions = {\n\t\t\tinstanceCount: 500,\n\t\t\tvertexCount: 750,\n\t\t\tindexCount: 2000,\n\t\t\texpandPercent: 0.25,\n\t\t\tmaxInstanceCount: Infinity,\n\t\t\tdiscardOriginalContent: true,\n\t\t\ttextureSize: null,\n\n\t\t\tmaterial: null,\n\t\t\trenderer: null,\n\t\t\t...options\n\t\t};\n\n\t\tthis.name = 'BATCHED_TILES_PLUGIN';\n\t\tthis.priority = - 1;\n\n\t\t// limit the amount of instances to the size of a 3d texture to avoid over flowing the\n\t\tconst gl = options.renderer.getContext();\n\n\t\t// save options\n\t\tthis.instanceCount = options.instanceCount;\n\t\tthis.vertexCount = options.vertexCount;\n\t\tthis.indexCount = options.indexCount;\n\t\tthis.material = options.material ? options.material.clone() : null;\n\t\tthis.expandPercent = options.expandPercent;\n\t\tthis.maxInstanceCount = Math.min( options.maxInstanceCount, gl.getParameter( gl.MAX_3D_TEXTURE_SIZE ) );\n\t\tthis.renderer = options.renderer;\n\t\tthis.discardOriginalContent = options.discardOriginalContent;\n\t\tthis.textureSize = options.textureSize;\n\n\t\t// local variables\n\t\tthis.batchedMesh = null;\n\t\tthis.arrayTarget = null;\n\t\tthis.tiles = null;\n\t\tthis._onLoadModel = null;\n\t\tthis._onDisposeModel = null;\n\t\tthis._onVisibilityChange = null;\n\t\tthis._tileToInstanceId = new Map();\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis._onDisposeModel = ( { scene, tile } ) => {\n\n\t\t\tthis.removeSceneFromBatchedMesh( scene, tile );\n\n\t\t};\n\n\t\t// register events\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModel );\n\t\tthis.tiles = tiles;\n\n\t}\n\n\tinitTextureArray( target ) {\n\n\t\tif ( this.arrayTarget !== null || target.material.map === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst { instanceCount, renderer, textureSize, batchedMesh } = this;\n\n\t\t// init the array texture render target\n\t\tconst map = target.material.map;\n\t\tconst textureOptions = {\n\t\t\tcolorSpace: map.colorSpace,\n\t\t\twrapS: map.wrapS,\n\t\t\twrapT: map.wrapT,\n\t\t\twrapR: map.wrapS,\n\t\t\t// TODO: Generating mipmaps for the volume every time a new texture is added is extremely slow\n\t\t\t// generateMipmaps: map.generateMipmaps,\n\t\t\t// minFilter: map.minFilter,\n\t\t\tmagFilter: map.magFilter,\n\t\t};\n\n\t\tconst arrayTarget = new WebGLArrayRenderTarget( textureSize || map.image.width, textureSize || map.image.height, instanceCount );\n\t\tObject.assign( arrayTarget.texture, textureOptions );\n\t\trenderer.initRenderTarget( arrayTarget );\n\n\t\t// assign the material\n\t\tbatchedMesh.material.map = arrayTarget.texture;\n\n\t\tthis.arrayTarget = arrayTarget;\n\n\t\t// once the texture array is initialized we fill in textures for all previously-initialized instances\n\t\t// since they may have been skipped due to not having textures\n\t\tthis._tileToInstanceId.forEach( value => {\n\n\t\t\tvalue.forEach( id => {\n\n\t\t\t\tthis.assignTextureToLayer( _whiteTex, id );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t// init the batched mesh if it's not ready\n\tinitBatchedMesh( target ) {\n\n\t\tif ( this.batchedMesh !== null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// init the batched mesh\n\t\tconst { instanceCount, vertexCount, indexCount, tiles } = this;\n\t\tconst material = this.material ? this.material : new target.material.constructor();\n\t\tconst batchedMesh = new ExpandingBatchedMesh( instanceCount, instanceCount * vertexCount, instanceCount * indexCount, material );\n\t\tbatchedMesh.name = 'BatchTilesPlugin';\n\t\tbatchedMesh.frustumCulled = false;\n\t\ttiles.group.add( batchedMesh );\n\t\tbatchedMesh.updateMatrixWorld();\n\n\t\tconvertMapToArrayTexture( batchedMesh.material );\n\n\t\tthis.batchedMesh = batchedMesh;\n\n\t}\n\n\tsetTileVisible( tile, visible ) {\n\n\t\tconst scene = tile.cached.scene;\n\t\tif ( visible ) {\n\n\t\t\t// Add tile set to the batched mesh if it hasn't been added already\n\t\t\tthis.addSceneToBatchedMesh( scene, tile );\n\n\t\t}\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\t\tthis.batchedMesh.setVisibleAt( instanceId, visible );\n\n\t\t\t} );\n\n\t\t\t// TODO: this should be handled by the base tiles renderer\n\t\t\tconst tiles = this.tiles;\n\t\t\tif ( visible ) {\n\n\t\t\t\ttiles.visibleTiles.add( tile );\n\n\t\t\t} else {\n\n\t\t\t\ttiles.visibleTiles.delete( tile );\n\n\t\t\t}\n\n\t\t\t// dispatch the event that is blocked otherwise\n\t\t\ttiles.dispatchEvent( {\n\t\t\t\ttype: 'tile-visibility-change',\n\t\t\t\tscene,\n\t\t\t\ttile,\n\t\t\t\tvisible,\n\t\t\t} );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tunloadTileFromGPU( scene, tile ) {\n\n\t\tif ( ! this.discardOriginalContent && this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tthis.removeSceneFromBatchedMesh( scene, tile );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// render the given into the given layer\n\tassignTextureToLayer( texture, layer ) {\n\n\t\t// if the array target has not been created yet then skip the assignment and expansion\n\t\tif ( ! this.arrayTarget ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.expandArrayTargetIfNeeded();\n\n\t\tconst { renderer } = this;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t// render the layer\n\t\trenderer.setRenderTarget( this.arrayTarget, layer );\n\t\t_textureRenderQuad.material.map = texture;\n\t\t_textureRenderQuad.render( renderer );\n\n\t\t// TODO: perform a copy if the texture is already the appropriate size\n\n\t\t// reset state\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\t_textureRenderQuad.material.map = null;\n\t\ttexture.dispose();\n\n\t}\n\n\t// check if the array texture target needs to be expanded\n\texpandArrayTargetIfNeeded() {\n\n\t\tconst { batchedMesh, arrayTarget, renderer } = this;\n\t\tconst targetDepth = Math.min( batchedMesh.maxInstanceCount, this.maxInstanceCount );\n\t\tif ( targetDepth > arrayTarget.depth ) {\n\n\t\t\t// create a new array texture target\n\t\t\tconst textureOptions = {\n\t\t\t\tcolorSpace: arrayTarget.texture.colorSpace,\n\t\t\t\twrapS: arrayTarget.texture.wrapS,\n\t\t\t\twrapT: arrayTarget.texture.wrapT,\n\t\t\t\tgenerateMipmaps: arrayTarget.texture.generateMipmaps,\n\t\t\t\tminFilter: arrayTarget.texture.minFilter,\n\t\t\t\tmagFilter: arrayTarget.texture.magFilter,\n\t\t\t};\n\n\t\t\tconst newArrayTarget = new WebGLArrayRenderTarget( arrayTarget.width, arrayTarget.height, targetDepth );\n\t\t\tObject.assign( newArrayTarget.texture, textureOptions );\n\n\t\t\t// copy the contents\n\t\t\trenderer.initRenderTarget( newArrayTarget );\n\t\t\trenderer.copyTextureToTexture( arrayTarget.texture, newArrayTarget.texture );\n\n\t\t\t// replace the old array target\n\t\t\tarrayTarget.dispose();\n\t\t\tbatchedMesh.material.map = newArrayTarget.texture;\n\t\t\tthis.arrayTarget = newArrayTarget;\n\n\t\t}\n\n\t}\n\n\tremoveSceneFromBatchedMesh( scene, tile ) {\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\t\tthis._tileToInstanceId.delete( tile );\n\t\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\t\tthis.batchedMesh.deleteInstance( instanceId );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\taddSceneToBatchedMesh( scene, tile ) {\n\n\t\tif ( this._tileToInstanceId.has( tile ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// find the meshes in the scene\n\t\tconst meshes = [];\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// don't add the geometry if it doesn't have the right attributes\n\t\tlet hasCorrectAttributes = true;\n\t\tmeshes.forEach( mesh => {\n\n\t\t\tif ( this.batchedMesh && hasCorrectAttributes ) {\n\n\t\t\t\tconst attrs = mesh.geometry.attributes;\n\t\t\t\tconst batchedAttrs = this.batchedMesh.geometry.attributes;\n\t\t\t\tfor ( const key in batchedAttrs ) {\n\n\t\t\t\t\tif ( ! ( key in attrs ) ) {\n\n\t\t\t\t\t\thasCorrectAttributes = false;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst canAddMeshes = ! this.batchedMesh || this.batchedMesh.instanceCount + meshes.length <= this.maxInstanceCount;\n\t\tif ( hasCorrectAttributes && canAddMeshes ) {\n\n\t\t\tscene.updateMatrixWorld();\n\n\t\t\tconst instanceIds = [];\n\t\t\tthis._tileToInstanceId.set( tile, instanceIds );\n\n\t\t\tmeshes.forEach( mesh => {\n\n\t\t\t\tthis.initBatchedMesh( mesh );\n\t\t\t\tthis.initTextureArray( mesh );\n\n\t\t\t\tconst { geometry, material } = mesh;\n\t\t\t\tconst { batchedMesh, expandPercent } = this;\n\n\t\t\t\t// assign expandPercent in case it has changed\n\t\t\t\tbatchedMesh.expandPercent = expandPercent;\n\n\t\t\t\tconst geometryId = batchedMesh.addGeometry( geometry, this.vertexCount, this.indexCount );\n\t\t\t\tconst instanceId = batchedMesh.addInstance( geometryId );\n\t\t\t\tinstanceIds.push( instanceId );\n\t\t\t\tbatchedMesh.setMatrixAt( instanceId, mesh.matrixWorld );\n\t\t\t\tbatchedMesh.setVisibleAt( instanceId, false );\n\t\t\t\tif ( ! isColorWhite( material.color ) ) {\n\n\t\t\t\t\tmaterial.color.setHSL( Math.random(), 0.5, 0.5 );\n\t\t\t\t\tbatchedMesh.setColorAt( instanceId, material.color );\n\n\t\t\t\t}\n\n\t\t\t\t// render the material\n\t\t\t\tconst texture = material.map;\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\tthis.assignTextureToLayer( texture, instanceId );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.assignTextureToLayer( _whiteTex, instanceId );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\n\t\t\t// discard all data if the option is set\n\t\t\t// TODO: this would be best done in a more general way\n\t\t\tif ( this.discardOriginalContent ) {\n\n\t\t\t\ttile.cached.textures.forEach( tex => {\n\n\t\t\t\t\tif ( tex.image instanceof ImageBitmap ) {\n\n\t\t\t\t\t\ttex.image.close();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\ttile.cached.scene = null;\n\t\t\t\ttile.cached.materials = [];\n\t\t\t\ttile.cached.geometries = [];\n\t\t\t\ttile.cached.textures = [];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Override raycasting per tile to defer to the batched mesh\n\traycastTile( tile, scene, raycaster, intersects ) {\n\n\t\tif ( ! this._tileToInstanceId.has( tile ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst instanceIds = this._tileToInstanceId.get( tile );\n\t\tinstanceIds.forEach( instanceId => {\n\n\t\t\tthis.batchedMesh.raycastInstance( instanceId, raycaster, intersects );\n\n\t\t} );\n\n\t\treturn true;\n\n\t}\n\n\tdispose() {\n\n\t\tconst { arrayTarget, tiles, batchedMesh } = this;\n\t\tif ( arrayTarget ) {\n\n\t\t\tarrayTarget.dispose();\n\n\t\t}\n\n\t\tif ( batchedMesh ) {\n\n\t\t\tbatchedMesh.material.dispose();\n\t\t\tbatchedMesh.geometry.dispose();\n\t\t\tbatchedMesh.dispose();\n\t\t\tbatchedMesh.removeFromParent();\n\n\t\t}\n\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModel );\n\n\t}\n\n\tgetTileBatchIds( tile ) {\n\n\t\treturn this._tileToInstanceId.get( tile );\n\n\t}\n\n}\n","import { Box3, DoubleSide, MathUtils, Matrix4, MeshBasicMaterial, Raycaster, Sphere, Vector3 } from 'three';\n\n// Limitations:\n// - No support for BatchedTilesPlugin when resetting or modifying geometry\n// - Sharing geometry between models may result in incorrect flattening\n\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _invMatrix = /* @__PURE__ */ new Matrix4();\nconst _raycaster = /* @__PURE__ */ new Raycaster();\nconst _doubleSidedMaterial = /* @__PURE__ */ new MeshBasicMaterial( { side: DoubleSide } );\nconst _box = /* @__PURE__ */ new Box3();\nconst RAYCAST_DISTANCE = 1e5;\n\nfunction calculateSphere( object, target ) {\n\n\tif ( object.isBufferGeometry ) {\n\n\t\tif ( object.boundingSphere === null ) {\n\n\t\t\tobject.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn target.copy( object.boundingSphere );\n\n\t} else {\n\n\t\t_box.setFromObject( object );\n\t\t_box.getBoundingSphere( target );\n\t\treturn target;\n\n\t}\n\n}\n\nexport class TileFlatteningPlugin {\n\n\tconstructor() {\n\n\t\tthis.name = 'TILE_FLATTENING_PLUGIN';\n\t\tthis.priority = - 100;\n\n\t\tthis.tiles = null;\n\t\tthis.shapes = new Map();\n\t\tthis.positionsMap = new Map();\n\t\tthis.positionsUpdated = new Set();\n\t\tthis.needsUpdate = false;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\t\tthis.needsUpdate = true;\n\n\t\tthis._updateBeforeCallback = () => {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis._updateTiles();\n\t\t\t\tthis.needsUpdate = false;\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._disposeModelCallback = ( { tile } ) => {\n\n\t\t\tthis.positionsMap.delete( tile );\n\t\t\tthis.positionsUpdated.delete( tile );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'update-before', this._updateBeforeCallback );\n\t\ttiles.addEventListener( 'dispose-model', this._disposeModelCallback );\n\n\t}\n\n\t// update tile flattening state if it has not been made visible, yet\n\tsetTileActive( tile, active ) {\n\n\t\tif ( active && ! this.positionsUpdated.has( tile ) ) {\n\n\t\t\tthis._updateTile( tile );\n\n\t\t}\n\n\t}\n\n\t_updateTile( tile ) {\n\n\t\tconst { positionsUpdated, positionsMap, shapes, tiles } = this;\n\t\tpositionsUpdated.add( tile );\n\n\t\tconst scene = tile.cached.scene;\n\t\tif ( ! positionsMap.has( tile ) ) {\n\n\t\t\t// save the geometry positions for resetting after\n\t\t\tconst geomMap = new Map();\n\t\t\tpositionsMap.set( tile, geomMap );\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.geometry ) {\n\n\t\t\t\t\tgeomMap.set( c.geometry, c.geometry.attributes.position.array.slice() );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\t// reset the geometry state before re-flattening tiles\n\t\t\tconst geomMap = positionsMap.get( tile );\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( c.geometry ) {\n\n\t\t\t\t\tconst buffer = geomMap.get( c.geometry );\n\t\t\t\t\tif ( buffer ) {\n\n\t\t\t\t\t\tc.geometry.attributes.position.array.set( buffer );\n\t\t\t\t\t\tc.geometry.attributes.position.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// TODO: if we save the sphere of the original mesh we can check the height to limit the tiles checked\n\t\t// TODO: we should use the tile bounding volume sphere if present\n\t\tscene.updateMatrixWorld( true );\n\n\t\t// iterate over every geometry\n\t\tscene.traverse( c => {\n\n\t\t\tconst { geometry } = c;\n\n\t\t\tif ( ! geometry ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// calculate matrices\n\t\t\t_matrix.copy( c.matrixWorld );\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.premultiply( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t_invMatrix.copy( _matrix ).invert();\n\n\t\t\t// calculate sphere for mesh\n\t\t\tcalculateSphere( geometry, _sphere ).applyMatrix4( _matrix );\n\n\t\t\t// iterate over each shape\n\t\t\tshapes.forEach( ( {\n\t\t\t\tshape,\n\t\t\t\tdirection,\n\t\t\t\tsphere,\n\n\t\t\t\tthresholdMode,\n\t\t\t\tthreshold,\n\t\t\t\tflattenRange,\n\t\t\t} ) => {\n\n\t\t\t\t// check if the spheres overlap so there may actually be potential of geometry overlap\n\t\t\t\t_vec.subVectors( _sphere.center, sphere.center );\n\t\t\t\t_vec.addScaledVector( direction, - direction.dot( _vec ) );\n\n\t\t\t\tconst r2 = ( _sphere.radius + sphere.radius ) ** 2;\n\t\t\t\tif ( _vec.lengthSq() > r2 ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every vertex position\n\t\t\t\tconst { position } = geometry.attributes;\n\t\t\t\tconst { ray } = _raycaster;\n\t\t\t\tray.direction.copy( direction ).multiplyScalar( - 1 );\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\tray.origin\n\t\t\t\t\t\t.fromBufferAttribute( position, i )\n\t\t\t\t\t\t.applyMatrix4( _matrix )\n\t\t\t\t\t\t.addScaledVector( direction, RAYCAST_DISTANCE );\n\t\t\t\t\t_raycaster.far = RAYCAST_DISTANCE;\n\n\t\t\t\t\tconst hit = _raycaster.intersectObject( shape )[ 0 ];\n\t\t\t\t\tif ( hit ) {\n\n\t\t\t\t\t\tlet rangeAlpha = ( RAYCAST_DISTANCE - hit.distance ) / threshold;\n\t\t\t\t\t\tconst aboveThreshold = rangeAlpha >= 1;\n\t\t\t\t\t\tif ( ! aboveThreshold || aboveThreshold && thresholdMode === 'flatten' ) {\n\n\t\t\t\t\t\t\trangeAlpha = Math.min( rangeAlpha, 1.0 );\n\n\t\t\t\t\t\t\thit.point.addScaledVector( ray.direction, MathUtils.mapLinear( rangeAlpha, 0, 1, - flattenRange, 0 ) );\n\t\t\t\t\t\t\thit.point.applyMatrix4( _invMatrix );\n\t\t\t\t\t\t\tposition.setXYZ( i, ...hit.point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\n\t\tthis.tiles.dispatchEvent( { type: 'needs-render' } );\n\n\t}\n\n\t_updateTiles() {\n\n\t\tthis.positionsUpdated.clear();\n\t\tthis.tiles.activeTiles.forEach( tile => this._updateTile( tile ) );\n\n\t}\n\n\t// API for updating and shapes to flatten the vertices\n\thasShape( mesh ) {\n\n\t\treturn this.shapes.has( mesh );\n\n\t}\n\n\taddShape( mesh, direction = new Vector3( 0, 0, - 1 ), options = {} ) {\n\n\t\tif ( this.hasShape( mesh ) ) {\n\n\t\t\tthrow new Error( 'TileFlatteningPlugin: Shape is already used.' );\n\n\t\t}\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'TileFlatteningPlugin: \"addShape\" function signature has changed. Please use an options object, instead.' );\n\t\t\toptions = {\n\t\t\t\tthreshold: options,\n\t\t\t};\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t\tconst shape = mesh.clone();\n\t\tshape.updateMatrixWorld( true );\n\t\tshape.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tc.material = _doubleSidedMaterial;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst sphere = calculateSphere( shape, new Sphere() );\n\t\tthis.shapes.set( mesh, {\n\t\t\tshape: shape,\n\t\t\tdirection: direction.clone(),\n\t\t\tsphere: sphere,\n\n\t\t\t// \"flatten\": Flattens the vertices above the shape\n\t\t\t// \"none\": leaves the vertices above the shape as they are\n\t\t\tthresholdMode: 'none',\n\n\t\t\t// only flatten within this range above the object\n\t\t\tthreshold: Infinity,\n\n\t\t\t// the range to flatten vertices in to. 0 is completely flat\n\t\t\t// while 0.1 means a 10cm range.\n\t\t\tflattenRange: 0,\n\n\t\t\t...options,\n\t\t} );\n\n\t}\n\n\tupdateShape( mesh ) {\n\n\t\tif ( ! this.hasShape( mesh ) ) {\n\n\t\t\tthrow new Error( 'TileFlatteningPlugin: Shape is not present.' );\n\n\t\t}\n\n\t\tconst { direction, threshold, thresholdMode, flattenRange } = this.shapes.get( mesh );\n\t\tthis.deleteShape( mesh );\n\t\tthis.addShape( mesh, direction, {\n\t\t\tthreshold,\n\t\t\tthresholdMode,\n\t\t\tflattenRange,\n\t\t} );\n\n\t}\n\n\tdeleteShape( mesh ) {\n\n\t\tthis.needsUpdate = true;\n\t\treturn this.shapes.delete( mesh );\n\n\t}\n\n\tclearShapes() {\n\n\t\tif ( this.shapes.size === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\t\tthis.shapes.clear();\n\n\t}\n\n\t// reset the vertex positions and remove the update callback\n\tdispose() {\n\n\t\tthis.tiles.removeEventListener( 'before-update', this._updateBeforeCallback );\n\t\tthis.tiles.removeEventListener( 'dispose-model', this._disposeModelCallback );\n\n\t\tthis.positionsMap.forEach( geomMap => {\n\n\t\t\tgeomMap.forEach( ( buffer, geometry ) => {\n\n\t\t\t\tconst { position } = geometry.attributes;\n\t\t\t\tposition.array.set( buffer );\n\t\t\t\tposition.needsUpdate = true;\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n","import { ShaderMaterial, MathUtils, Vector2, PlaneGeometry, OrthographicCamera, Mesh, Color, DoubleSide } from 'three';\n\nconst _camera = /* @__PURE__ */ new OrthographicCamera();\nconst _color = /* @__PURE__ */ new Color();\n\n// Utility for composing a series of tiled textures together onto a target texture in a given range\nexport class TiledTextureComposer {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.renderTarget = null;\n\t\tthis.range = [ 0, 0, 1, 1 ];\n\t\tthis.quad = new Mesh( new PlaneGeometry(), new ComposeTextureMaterial() );\n\n\t}\n\n\t// set the target render texture and the range that represents the full span\n\tsetRenderTarget( renderTarget, range ) {\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.range = [ ...range ];\n\n\t}\n\n\t// draw the given texture at the given span with the provided projection\n\tdraw( texture, span ) {\n\n\t\t// draw the texture at the given sub range\n\t\tconst { range, renderer, quad, renderTarget } = this;\n\t\tconst material = quad.material;\n\t\tmaterial.map = texture;\n\n\t\t// map the range to draw the texture to\n\t\tmaterial.minRange.x = MathUtils.mapLinear( span[ 0 ], range[ 0 ], range[ 2 ], - 1, 1 );\n\t\tmaterial.minRange.y = MathUtils.mapLinear( span[ 1 ], range[ 1 ], range[ 3 ], - 1, 1 );\n\n\t\tmaterial.maxRange.x = MathUtils.mapLinear( span[ 2 ], range[ 0 ], range[ 2 ], - 1, 1 );\n\t\tmaterial.maxRange.y = MathUtils.mapLinear( span[ 3 ], range[ 1 ], range[ 3 ], - 1, 1 );\n\n\t\t// draw the texture\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.render( quad, _camera );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\tmaterial.map = null;\n\n\t}\n\n\t// clear the set target\n\tclear( color, alpha = 1 ) {\n\n\t\t// clear the texture\n\t\tconst { renderer, renderTarget } = this;\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentClearColor = renderer.getClearColor( _color );\n\t\tconst currentClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.setClearColor( color, alpha );\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.clear();\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setClearColor( currentClearColor, currentClearAlpha );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.quad.material.dispose();\n\t\tthis.quad.geometry.dispose();\n\n\t}\n\n}\n\n// Draws the given texture with no depth testing at the given bounds defined by \"minRange\" and \"maxRange\"\nclass ComposeTextureMaterial extends ShaderMaterial {\n\n\t// the [ - 1, 1 ] NDC ranges to draw the texture at\n\tget minRange() {\n\n\t\treturn this.uniforms.minRange.value;\n\n\t}\n\n\tget maxRange() {\n\n\t\treturn this.uniforms.maxRange.value;\n\n\t}\n\n\t// access the map being drawn\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( {\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: false,\n\t\t\tside: DoubleSide,\n\t\t\tpremultipliedAlpha: true,\n\t\t\tuniforms: {\n\t\t\t\tmap: { value: null },\n\n\t\t\t\t// the normalized [0, 1] range of the target to draw to\n\t\t\t\tminRange: { value: new Vector2() },\n\t\t\t\tmaxRange: { value: new Vector2() },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tuniform vec2 minRange;\n\t\t\t\tuniform vec2 maxRange;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = vec4( mix( minRange, maxRange, uv ), 0, 1 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform vec2 minRange;\n\t\t\t\tuniform vec2 maxRange;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// sample the texture\n\t\t\t\t\tgl_FragColor = texture( map, vUv );\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\n\t\t\t`,\n\t\t} );\n\n\n\t}\n\n}\n","import { Vector3, Matrix4, MathUtils } from 'three';\n\n// iterates over all present tiles in the given tile set at the given level in the given range\nexport function forEachTileInBounds( range, level, tiling, normalized, callback ) {\n\n\t// pull the bounds in a bit to avoid loading unnecessary tiles. 1e-8 was chosen since smaller values\n\t// are not larger enough and cause extra tiles to load in cases where 1-to-1 tile-to-image should occur\n\tlet [ minLon, minLat, maxLon, maxLat ] = range;\n\tminLat += 1e-8;\n\tminLon += 1e-8;\n\tmaxLat -= 1e-8;\n\tmaxLon -= 1e-8;\n\n\tconst clampedLevel = Math.max( Math.min( level, tiling.maxLevel ), tiling.minLevel );\n\tconst [ minX, minY, maxX, maxY ] = tiling.getTilesInRange( minLon, minLat, maxLon, maxLat, clampedLevel, normalized );\n\tfor ( let x = minX; x <= maxX; x ++ ) {\n\n\t\tfor ( let y = minY; y <= maxY; y ++ ) {\n\n\t\t\tcallback( x, y, clampedLevel );\n\n\t\t}\n\n\t}\n\n}\n\n// functions for generating UVs for cartographic-projected UVs\nfunction getGeometryCartographicChannel( geometry, geomToEllipsoidMatrix, ellipsoid ) {\n\n\tconst _vec = new Vector3();\n\tconst _cart = {};\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tgeometry.computeBoundingBox();\n\tgeometry.boundingBox.getCenter( _vec ).applyMatrix4( geomToEllipsoidMatrix );\n\n\t// find a rough mid lat / lon point\n\tellipsoid.getPositionToCartographic( _vec, _cart );\n\tconst centerLat = _cart.lat;\n\tconst centerLon = _cart.lon;\n\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t// get the lat / lon values per vertex\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( geomToEllipsoidMatrix );\n\t\tellipsoid.getPositionToCartographic( _vec, _cart );\n\n\t\t// The latitude calculations are not so stable at the poles so force the lat value to\n\t\t// the mid point to ensure we don't load an unnecessarily large of tiles\n\t\t// NOTE: this can distort the texture a bit at the poles\n\t\tif ( Math.abs( Math.abs( _cart.lat ) - Math.PI / 2 ) < 1e-5 ) {\n\n\t\t\t_cart.lon = centerLon;\n\n\t\t}\n\n\t\t// ensure we're not wrapping on the same geometry\n\t\tif ( Math.abs( centerLon - _cart.lon ) > Math.PI ) {\n\n\t\t\t_cart.lon += Math.sign( centerLon - _cart.lon ) * Math.PI * 2;\n\n\t\t}\n\n\t\tif ( Math.abs( centerLat - _cart.lat ) > Math.PI ) {\n\n\t\t\t_cart.lat += Math.sign( centerLat - _cart.lat ) * Math.PI * 2;\n\n\t\t}\n\n\t\tuv.push( _cart.lon, _cart.lat, _cart.height );\n\n\t\tminLat = Math.min( minLat, _cart.lat );\n\t\tmaxLat = Math.max( maxLat, _cart.lat );\n\n\t\tminLon = Math.min( minLon, _cart.lon );\n\t\tmaxLon = Math.max( maxLon, _cart.lon );\n\n\t\tminHeight = Math.min( minHeight, _cart.height );\n\t\tmaxHeight = Math.max( maxHeight, _cart.height );\n\n\t}\n\n\tconst range = [ minLon, minLat, maxLon, maxLat ];\n\tconst region = [ ...range, minHeight, maxHeight ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\tregion,\n\t};\n\n}\n\nexport function getMeshesCartographicRange( meshes, ellipsoid, meshToEllipsoidMatrix = null, tiling = null ) {\n\n\t// find the lat / lon ranges\n\tlet minLat = Infinity;\n\tlet minLon = Infinity;\n\tlet minHeight = Infinity;\n\tlet maxLat = - Infinity;\n\tlet maxLon = - Infinity;\n\tlet maxHeight = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( meshToEllipsoidMatrix ) {\n\n\t\t\t_matrix.premultiply( meshToEllipsoidMatrix );\n\n\t\t}\n\n\t\tconst { uv, region } = getGeometryCartographicChannel( mesh.geometry, _matrix, ellipsoid );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminLat = Math.min( minLat, region[ 1 ] );\n\t\tmaxLat = Math.max( maxLat, region[ 3 ] );\n\n\t\tminLon = Math.min( minLon, region[ 0 ] );\n\t\tmaxLon = Math.max( maxLon, region[ 2 ] );\n\n\t\tminHeight = Math.min( minHeight, region[ 4 ] );\n\t\tmaxHeight = Math.max( maxHeight, region[ 5 ] );\n\n\t} );\n\n\tlet clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\tif ( tiling !== null ) {\n\n\t\t// Clamp the lat lon range to the bounds of the projection scheme. Note that clamping the data\n\t\t// allows for \"stretching\" the texture look at the edges of the projection which leads to a nicer\n\t\t// looking overlay. Eg at the poles of a web-mercator projection - otherwise there will be gaps\n\t\t// that show the underlying tile data. It's arguable which one is better but in all supported\n\t\t// ellipsoid projections (Web mercator, equirect) the projection ranges always span the entire\n\t\t// globe range.\n\t\t// const clampedRange = [ minLon, minLat, maxLon, maxLat ];\n\t\tclampedRange = tiling.clampToProjectionBounds( [ minLon, minLat, maxLon, maxLat ] );\n\t\tconst [ minU, minV, maxU, maxV ] = tiling.toNormalizedRange( clampedRange );\n\t\tuvs.forEach( uv => {\n\n\t\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\t\tconst lon = uv[ i + 0 ];\n\t\t\t\tconst lat = uv[ i + 1 ];\n\t\t\t\tconst h = uv[ i + 2 ];\n\n\t\t\t\tconst [ u, v ] = tiling.toNormalizedPoint( lon, lat );\n\t\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\t\t\t\tuv[ i + 2 ] = MathUtils.mapLinear( h, minHeight, maxHeight, 0, 1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\treturn {\n\t\tuvs,\n\t\trange: clampedRange,\n\t\tregion: [ minLon, minLat, maxLon, maxLat, minHeight, maxHeight ],\n\t};\n\n}\n\n// functions for generating UVs for planar-projected UVs\nfunction getGeometryPlanarChannel( geometry, meshToFrame, aspectRatio ) {\n\n\tconst _vec = new Vector3();\n\tconst uv = [];\n\tconst posAttr = geometry.getAttribute( 'position' );\n\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tfor ( let i = 0; i < posAttr.count; i ++ ) {\n\n\t\t// divide U by the aspect to stretch the U dimension to the aspect of the image\n\t\t_vec.fromBufferAttribute( posAttr, i ).applyMatrix4( meshToFrame );\n\t\t_vec.x /= aspectRatio;\n\n\t\tuv.push( _vec.x, _vec.y, _vec.z );\n\n\t\tminU = Math.min( minU, _vec.x );\n\t\tmaxU = Math.max( maxU, _vec.x );\n\n\t\tminV = Math.min( minV, _vec.y );\n\t\tmaxV = Math.max( maxV, _vec.y );\n\n\t\tminW = Math.min( minW, _vec.z );\n\t\tmaxW = Math.max( maxW, _vec.z );\n\n\t}\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\tconst range = [ minU, minV, maxU, maxV ];\n\treturn {\n\t\tuv,\n\t\trange,\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n\nexport function getMeshesPlanarRange( meshes, worldToFrame, tiling ) {\n\n\t// find the U / V ranges\n\tlet minU = Infinity;\n\tlet minV = Infinity;\n\tlet minW = Infinity;\n\tlet maxU = - Infinity;\n\tlet maxV = - Infinity;\n\tlet maxW = - Infinity;\n\tconst uvs = [];\n\n\tconst _matrix = new Matrix4();\n\tmeshes.forEach( mesh => {\n\n\t\t// multiply in the ellipsoid matrix if necessary\n\t\t_matrix.copy( mesh.matrixWorld );\n\t\tif ( worldToFrame ) {\n\n\t\t\t_matrix.premultiply( worldToFrame );\n\n\t\t}\n\n\t\tconst { uv, range, heightRange } = getGeometryPlanarChannel( mesh.geometry, _matrix, tiling.aspectRatio );\n\t\tuvs.push( uv );\n\n\t\t// save the min and max values\n\t\tminU = Math.min( minU, range[ 0 ] );\n\t\tmaxU = Math.max( maxU, range[ 2 ] );\n\n\t\tminV = Math.min( minV, range[ 1 ] );\n\t\tmaxV = Math.max( maxV, range[ 3 ] );\n\n\t\tminW = Math.min( minW, heightRange[ 0 ] );\n\t\tmaxW = Math.max( maxW, heightRange[ 1 ] );\n\n\t} );\n\n\tuvs.forEach( uv => {\n\n\t\tfor ( let i = 0, l = uv.length; i < l; i += 3 ) {\n\n\t\t\tconst u = uv[ i + 0 ];\n\t\t\tconst v = uv[ i + 1 ];\n\n\t\t\tuv[ i + 0 ] = MathUtils.mapLinear( u, minU, maxU, 0, 1 );\n\t\t\tuv[ i + 1 ] = MathUtils.mapLinear( v, minV, maxV, 0, 1 );\n\n\t\t}\n\n\t} );\n\n\t// TODO: output a more complete bounds definition relative to the frame\n\treturn {\n\t\tuvs,\n\t\trange: [ minU, minV, maxU, maxV ],\n\t\theightRange: [ minW, maxW ],\n\t};\n\n}\n","const OVERLAY_PARAMS = Symbol( 'OVERLAY_PARAMS' );\n\n// before compile can be used to chain shader adjustments. Returns the added uniforms used for fading.\nexport function wrapOverlaysMaterial( material, previousOnBeforeCompile ) {\n\n\t// if the material has already been wrapped then return the params\n\tif ( material[ OVERLAY_PARAMS ] ) {\n\n\t\treturn material[ OVERLAY_PARAMS ];\n\n\t}\n\n\tconst params = {\n\t\tlayerMaps: { value: [] },\n\t\tlayerColor: { value: [] },\n\t};\n\n\tmaterial[ OVERLAY_PARAMS ] = params;\n\n\tmaterial.defines = {\n\t\t...( material.defines || {} ),\n\t\tLAYER_COUNT: 0,\n\t};\n\n\tmaterial.onBeforeCompile = shader => {\n\n\t\tif ( previousOnBeforeCompile ) {\n\n\t\t\tpreviousOnBeforeCompile( shader );\n\n\t\t}\n\n\t\tshader.uniforms = {\n\t\t\t...shader.uniforms,\n\t\t\t...params,\n\t\t};\n\n\t\tshader.vertexShader = shader\n\t\t\t.vertexShader\n\t\t\t.replace( /void main\\(\\s*\\)\\s*{/, value => /* glsl */`\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tattribute vec3 layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tv_layer_uv_UNROLLED_LOOP_INDEX = layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t` );\n\n\t\tshader.fragmentShader = shader\n\t\t\t.fragmentShader\n\t\t\t.replace( /void main\\(/, value => /* glsl */`\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t\tstruct LayerTint {\n\t\t\t\t\t\tvec3 color;\n\t\t\t\t\t\tfloat opacity;\n\t\t\t\t\t};\n\n\t\t\t\t\tuniform sampler2D layerMaps[ LAYER_COUNT ];\n\t\t\t\t\tuniform LayerTint layerColor[ LAYER_COUNT ];\n\t\t\t\t#endif\n\n\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\tvarying vec3 v_layer_uv_UNROLLED_LOOP_INDEX;\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t}\n\t\t\t\t#pragma unroll_loop_end\n\n\t\t\t\t${ value }\n\n\t\t\t` )\n\t\t\t.replace( /#include <color_fragment>/, value => /* glsl */`\n\n\t\t\t\t${ value }\n\n\t\t\t\t#if LAYER_COUNT != 0\n\t\t\t\t{\n\t\t\t\t\tvec4 tint;\n\t\t\t\t\tvec3 layerUV;\n\t\t\t\t\tfloat layerOpacity;\n\t\t\t\t\tfloat wOpacity;\n\t\t\t\t\tfloat wDelta;\n\t\t\t\t\t#pragma unroll_loop_start\n\t\t\t\t\t\tfor ( int i = 0; i < 10; i ++ ) {\n\n\t\t\t\t\t\t\t#if UNROLLED_LOOP_INDEX < LAYER_COUNT\n\n\t\t\t\t\t\t\t\tlayerUV = v_layer_uv_UNROLLED_LOOP_INDEX;\n\t\t\t\t\t\t\t\ttint = texture( layerMaps[ i ], layerUV.xy );\n\n\t\t\t\t\t\t\t\t// discard texture outside 0, 1 on w - offset the stepped value by an epsilon to avoid cases\n\t\t\t\t\t\t\t\t// where wDelta is near 0 (eg a flat surface) at the w boundary, resulting in artifacts on some\n\t\t\t\t\t\t\t\t// hardware.\n\t\t\t\t\t\t\t\twDelta = max( fwidth( layerUV.z ), 1e-7 );\n\t\t\t\t\t\t\t\twOpacity =\n\t\t\t\t\t\t\t\t\tsmoothstep( - wDelta, 0.0, layerUV.z ) *\n\t\t\t\t\t\t\t\t\tsmoothstep( 1.0 + wDelta, 1.0, layerUV.z );\n\n\t\t\t\t\t\t\t\t// apply tint & opacity\n\t\t\t\t\t\t\t\ttint.rgb *= layerColor[ i ].color;\n\t\t\t\t\t\t\t\ttint.rgba *= layerColor[ i ].opacity * wOpacity;\n\n\t\t\t\t\t\t\t\t// premultiplied alpha equation\n\t\t\t\t\t\t\t\tdiffuseColor = tint + diffuseColor * ( 1.0 - tint.a );\n\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t}\n\t\t\t\t\t#pragma unroll_loop_end\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t` );\n\n\t};\n\n\treturn params;\n\n}\n","import { CanvasTexture, MathUtils, Vector3 } from 'three';\nimport { TiledImageSource } from './TiledImageSource.js';\nimport { ProjectionScheme } from '../utils/ProjectionScheme.js';\nimport { WGS84_ELLIPSOID } from '3d-tiles-renderer/three';\n\n// TODO: Add support for limited bounds\n// TODO: Add support for padding of tiles to avoid clipping \"wide\" elements\n// TODO: Need to clip / fix geojson shapes across the 180 degree boundary\n// TODO: Add support for easy regeneration when colors / styles / geojson change\n// TODO: Consider option to support world-space thickness definitions. Eg world-space point size or line thickness in meters.\n\n// function for calculating the the change in arc length at a given cartographic point\n// in order to preserve a circular look when drawing points\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\nfunction calculateArcRatioAtPoint( ellipsoid, lat, lon ) {\n\n\tconst DELTA = 0.01;\n\tellipsoid.getCartographicToPosition( lat, lon, 0, _v0 );\n\tellipsoid.getCartographicToPosition( lat + DELTA, lon, 0, _v1 );\n\n\tconst latDelta = _v0.distanceTo( _v1 );\n\tellipsoid.getCartographicToPosition( lat, lon + DELTA, 0, _v1 );\n\n\tconst lonDelta = _v0.distanceTo( _v1 );\n\treturn lonDelta / latDelta;\n\n}\n\nexport class GeoJSONImageSource extends TiledImageSource {\n\n\tconstructor( {\n\t\tgeojson = null,\n\t\turl = null, // URL or GeoJson object can be provided\n\t\ttileDimension = 256,\n\t\tlevels = 20,\n\t\tpointRadius = 6,\n\t\tstrokeStyle = 'white',\n\t\tstrokeWidth = 2,\n\t\tfillStyle = 'rgba( 255, 255, 255, 0.5 )',\n\t\t...rest\n\t} = {} ) {\n\n\t\tsuper( rest );\n\t\tthis.geojson = geojson;\n\t\tthis.url = url;\n\t\tthis.tileDimension = tileDimension;\n\t\tthis.levels = levels;\n\n\t\tthis.pointRadius = pointRadius;\n\t\tthis.strokeStyle = strokeStyle;\n\t\tthis.strokeWidth = strokeWidth;\n\t\tthis.fillStyle = fillStyle;\n\n\t}\n\n\tasync init() {\n\n\t\t// configure tiling to content bounds and levels\n\t\tconst { tiling, levels, tileDimension, geojson, url } = this;\n\t\tconst projection = new ProjectionScheme();\n\t\ttiling.setProjection( projection );\n\t\ttiling.setContentBounds( ...projection.getBounds() );\n\n\t\ttiling.generateLevels(\n\t\t\tlevels,\n\t\t\tprojection.tileCountX,\n\t\t\tprojection.tileCountY,\n\t\t\t{\n\t\t\t\ttilePixelWidth: tileDimension,\n\t\t\t\ttilePixelHeight: tileDimension,\n\t\t\t},\n\t\t);\n\n\t\t// If a URL was provided and no geojson object yet, fetch it now (use fetchData so overlay can inject headers)\n\t\tif ( ! geojson && url ) {\n\n\t\t\tconst res = await this.fetchData( url );\n\t\t\tthis.geojson = await res.json();\n\n\t\t}\n\n\t\t// TODO: If geojson present, compute bounds from data (with padding) and set as content bounds.\n\t\t// Falls back to full projection bounds if no geojson or unable to compute an extent.\n\n\t\t// seems that this approach to optimize rendering by defining bounds\n\t\t// doesn't work if not using a very large offset for the bounds, maybe an error?\n\t\tconst geoBounds = this._geoJSONBounds( 50 ).map( v => v * MathUtils.DEG2RAD );\n\t\tthis.tiling.setContentBounds( ...geoBounds );\n\n\t}\n\n\t// main fetch per tile - > returns .Texture\n\tasync fetchItem( tokens, signal ) {\n\n\t\treturn this.drawCanvasImage( tokens );\n\n\t}\n\n\tdrawCanvasImage( tokens ) {\n\n\t\tconst { tiling, tileDimension, geojson } = this;\n\t\tconst [ x, y, level ] = tokens;\n\t\tconst tileBoundsDeg = tiling.getTileBounds( x, y, level, false, false ).map( v => MathUtils.RAD2DEG * v );\n\n\t\t// create canvas\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = tileDimension;\n\t\tcanvas.height = tileDimension;\n\n\t\t// draw features\n\t\tconst ctx = canvas.getContext( '2d' );\n\t\tconst features = this._featuresFromGeoJSON( geojson );\n\t\tfor ( let i = 0; i < features.length; i ++ ) {\n\n\t\t\tconst feature = features[ i ];\n\t\t\tif ( this._featureIntersectsTile( feature, tileBoundsDeg ) ) {\n\n\t\t\t\tthis._drawFeatureOnCanvas( ctx, feature, tileBoundsDeg, canvas.width, canvas.height );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tex = new CanvasTexture( canvas );\n\t\ttex.needsUpdate = true;\n\t\treturn tex;\n\n\t}\n\n\t// bbox quick test in projected units\n\t_featureIntersectsTile( feature, boundsDeg ) {\n\n\t\tconst featureBoundsDeg = this._getFeatureBounds( feature );\n\t\tif ( ! featureBoundsDeg ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// check for intersection between bounds\n\t\tconst [ fminX, fminY, fmaxX, fmaxY ] = featureBoundsDeg;\n\t\tconst [ minX, minY, maxX, maxY ] = boundsDeg;\n\t\treturn ! ( fmaxX < minX || fminX > maxX || fmaxY < minY || fminY > maxY );\n\n\t}\n\n\t_getFeatureBounds( feature ) {\n\n\t\tconst { geometry } = feature;\n\t\tif ( ! geometry ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst { type, coordinates } = geometry;\n\t\tlet minLon = Infinity;\n\t\tlet minLat = Infinity;\n\t\tlet maxLon = - Infinity;\n\t\tlet maxLat = - Infinity;\n\n\t\tconst expandBoundsByPoint = ( lon, lat ) => {\n\n\t\t\tminLon = Math.min( minLon, lon );\n\t\t\tmaxLon = Math.max( maxLon, lon );\n\t\t\tminLat = Math.min( minLat, lat );\n\t\t\tmaxLat = Math.max( maxLat, lat );\n\n\t\t};\n\n\t\tif ( type === 'Point' ) {\n\n\t\t\texpandBoundsByPoint( coordinates[ 0 ], coordinates[ 1 ] );\n\n\t\t} else if ( type === 'MultiPoint' || type === 'LineString' ) {\n\n\t\t\tcoordinates.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) );\n\n\t\t} else if ( type === 'MultiLineString' || type === 'Polygon' ) {\n\n\t\t\tcoordinates.forEach( ring => ring.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) ) );\n\n\t\t} else if ( type === 'MultiPolygon' ) {\n\n\t\t\tcoordinates.forEach( polygon =>\n\t\t\t\tpolygon.forEach( ring => ring.forEach( c => expandBoundsByPoint( c[ 0 ], c[ 1 ] ) ) ),\n\t\t\t);\n\n\t\t}\n\n\t\treturn [ minLon, minLat, maxLon, maxLat ];\n\n\t}\n\n\t// Normalize top-level geojson into an array of Feature objects\n\t_featuresFromGeoJSON( root ) {\n\n\t\tconst type = root.type;\n\t\tconst geomTypes = new Set( [ 'Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon' ] );\n\n\t\tif ( type === 'FeatureCollection' ) {\n\n\t\t\treturn root.features;\n\n\t\t} else if ( type === 'Feature' ) {\n\n\t\t\treturn [ root ];\n\n\t\t} else if ( type === 'GeometryCollection' ) {\n\n\t\t\treturn root.geometries.map( g => ( { type: 'Feature', geometry: g, properties: {} } ) );\n\n\t\t} else if ( geomTypes.has( type ) ) {\n\n\t\t\treturn [ { type: 'Feature', geometry: root, properties: {} } ];\n\n\t\t} else {\n\n\t\t\treturn [];\n\n\t\t}\n\n\t}\n\n\t// draw feature on canvas ( assumes intersects already )\n\t_drawFeatureOnCanvas( ctx, feature, tileBoundsDeg, width, height ) {\n\n\t\tconst { geometry = null, properties = {} } = feature;\n\t\tif ( ! geometry ) {\n\n\t\t\t// A feature may have null geometry in GeoJSON\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst [ minLonDeg, minLatDeg, maxLonDeg, maxLatDeg ] = tileBoundsDeg;\n\t\tconst strokeStyle = properties.strokeStyle || this.strokeStyle;\n\t\tconst fillStyle = properties.fillStyle || this.fillStyle;\n\t\tconst pointRadius = properties.pointRadius || this.pointRadius;\n\t\tconst strokeWidth = properties.strokeWidth || this.strokeWidth;\n\n\t\tctx.save();\n\t\tctx.strokeStyle = strokeStyle;\n\t\tctx.fillStyle = fillStyle;\n\t\tctx.lineWidth = strokeWidth;\n\n\t\t// Compute pixel from cartographic coordinates and tile bounds\n\t\tconst arr = new Array( 2 );\n\t\tconst projectPoint = ( lon, lat, target = arr ) => {\n\n\t\t\t// canvas y origin is top, projection y increases north -> flip\n\t\t\tconst x = MathUtils.mapLinear( lon, minLonDeg, maxLonDeg, 0, width );\n\t\t\tconst y = height - MathUtils.mapLinear( lat, minLatDeg, maxLatDeg, 0, height );\n\n\t\t\t// round to integer to gain performance\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#avoid_floating-point_coordinates_and_use_integers_instead\n\t\t\ttarget[ 0 ] = Math.round( x );\n\t\t\ttarget[ 1 ] = Math.round( y );\n\t\t\treturn target;\n\n\t\t};\n\n\t\tconst calculateAspectRatio = ( lon, lat ) => {\n\n\t\t\t// calculates the aspect ratio with which to draw points\n\t\t\tconst latRad = lat * MathUtils.DEG2RAD;\n\t\t\tconst lonRad = lon * MathUtils.DEG2RAD;\n\t\t\tconst pxLat = ( maxLatDeg - minLatDeg ) / height;\n\t\t\tconst pxLon = ( maxLonDeg - minLonDeg ) / width;\n\t\t\tconst pixelRatio = pxLon / pxLat;\n\n\t\t\t// TODO: this should use the ellipsoid defined on the relevant tiles renderer\n\t\t\treturn pixelRatio * calculateArcRatioAtPoint( WGS84_ELLIPSOID, latRad, lonRad );\n\n\t\t};\n\n\t\tconst type = geometry.type;\n\t\tif ( type === 'Point' ) {\n\n\t\t\tconst [ lon, lat ] = geometry.coordinates;\n\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\tconst drawRatio = calculateAspectRatio( lon, lat );\n\n\t\t\tctx.beginPath();\n\t\t\tctx.ellipse( px, py, pointRadius / drawRatio, pointRadius, 0, 0, Math.PI * 2 );\n\t\t\tctx.fill();\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiPoint' ) {\n\n\t\t\tgeometry.coordinates.forEach( ( [ lon, lat ] ) => {\n\n\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\tconst drawRatio = calculateAspectRatio( lon, lat );\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.ellipse( px, py, pointRadius / drawRatio, pointRadius, 0, 0, Math.PI * 2 );\n\t\t\t\tctx.fill();\n\t\t\t\tctx.stroke();\n\n\t\t\t} );\n\n\t\t} else if ( type === 'LineString' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiLineString' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( line ) => {\n\n\t\t\t\tline.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'Polygon' ) {\n\n\t\t\tctx.beginPath();\n\t\t\tgeometry.coordinates.forEach( ( ring, rIndex ) => {\n\n\t\t\t\tring.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tctx.closePath();\n\n\t\t\t} );\n\t\t\tctx.fill( 'evenodd' );\n\t\t\tctx.stroke();\n\n\t\t} else if ( type === 'MultiPolygon' ) {\n\n\t\t\tgeometry.coordinates.forEach( ( polygon ) => {\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tpolygon.forEach( ( ring, rIndex ) => {\n\n\t\t\t\t\tring.forEach( ( [ lon, lat ], i ) => {\n\n\t\t\t\t\t\tconst [ px, py ] = projectPoint( lon, lat );\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tctx.moveTo( px, py );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tctx.lineTo( px, py );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tctx.closePath();\n\n\t\t\t\t} );\n\t\t\t\tctx.fill( 'evenodd' );\n\t\t\t\tctx.stroke();\n\n\t\t\t} );\n\n\t\t}\n\n\t\tctx.restore();\n\n\t}\n\n\t// Compute geographic bounds in degrees from current geojson.\n\t_geoJSONBounds() {\n\n\t\t// TODO: add support for padding the bounding boxes\n\t\tconst features = this._featuresFromGeoJSON( this.geojson );\n\t\tlet minLon = Infinity;\n\t\tlet minLat = Infinity;\n\t\tlet maxLon = - Infinity;\n\t\tlet maxLat = - Infinity;\n\n\t\tfeatures.forEach( feature => {\n\n\t\t\tconst [ fMinLon, fMinLat, fMaxLon, fMaxLat ] = this._getFeatureBounds( feature );\n\t\t\tminLon = Math.min( minLon, fMinLon );\n\t\t\tminLat = Math.min( minLat, fMinLat );\n\t\t\tmaxLon = Math.max( maxLon, fMaxLon );\n\t\t\tmaxLat = Math.max( maxLat, fMaxLat );\n\n\t\t} );\n\n\t\treturn [ minLon, minLat, maxLon, maxLat ];\n\n\t}\n\n}\n","import { WebGLRenderTarget, Color, SRGBColorSpace, BufferAttribute, Matrix4, Vector3, Box3, Triangle, CanvasTexture } from 'three';\nimport { PriorityQueue } from '3d-tiles-renderer/core';\nimport { CesiumIonAuth, GoogleCloudAuth } from '3d-tiles-renderer/core/plugins';\nimport { TiledTextureComposer } from './overlays/TiledTextureComposer.js';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { forEachTileInBounds, getMeshesCartographicRange, getMeshesPlanarRange } from './overlays/utils.js';\nimport { wrapOverlaysMaterial } from './overlays/wrapOverlaysMaterial.js';\nimport { GeometryClipper } from '../utilities/GeometryClipper.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\nimport { MemoryUtils } from '3d-tiles-renderer/three';\nimport { GeoJSONImageSource } from './sources/GeoJSONImageSource.js';\nimport { WMSImageSource } from './sources/WMSImageSource.js';\n\nconst _matrix = /* @__PURE__ */ new Matrix4();\nconst _vec = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _sphereCenter = /* @__PURE__ */ new Vector3();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _box = /* @__PURE__ */ new Box3();\nconst SPLIT_TILE_DATA = Symbol( 'SPLIT_TILE_DATA' );\nconst SPLIT_HASH = Symbol( 'SPLIT_HASH' );\n\n// function for marking and releasing images in the given overlay\nfunction markOverlayImages( range, level, overlay, doRelease ) {\n\n\t// return null immediately if possible to allow for drawing without delay where possible\n\tif ( Array.isArray( overlay ) ) {\n\n\t\tconst promises = overlay\n\t\t\t.map( o => markOverlayImages( range, level, o, doRelease ) )\n\t\t\t.filter( p => p !== null );\n\n\t\tif ( promises.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t} else {\n\n\t\t\treturn Promise.all( promises );\n\n\t\t}\n\n\t}\n\n\tif ( ! overlay.isReady ) {\n\n\t\treturn overlay.whenReady().then( markImages );\n\n\t} else {\n\n\t\treturn markImages();\n\n\t}\n\n\tfunction markImages() {\n\n\t\tconst promises = [];\n\t\tconst { imageSource, tiling } = overlay;\n\t\tforEachTileInBounds( range, level, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\tif ( doRelease ) {\n\n\t\t\t\timageSource.release( tx, ty, tl );\n\n\t\t\t} else {\n\n\t\t\t\tpromises.push( imageSource.lock( tx, ty, tl ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst filteredPromises = promises.filter( p => p instanceof Promise );\n\t\tif ( filteredPromises.length !== 0 ) {\n\n\t\t\treturn Promise.all( filteredPromises );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n// returns the total number of tiles that will be drawn for the provided range\nfunction countTilesInRange( range, level, overlay ) {\n\n\tlet total = 0;\n\tforEachTileInBounds( range, level, overlay.tiling, overlay.isPlanarProjection, ( x, y, l ) => {\n\n\t\ttotal ++;\n\n\t} );\n\n\treturn total;\n\n}\n\n// Plugin for overlaying tiled image data on top of 3d tiles geometry.\nexport class ImageOverlayPlugin {\n\n\tget enableTileSplitting() {\n\n\t\treturn this._enableTileSplitting;\n\n\t}\n\n\tset enableTileSplitting( v ) {\n\n\t\tif ( this._enableTileSplitting !== v ) {\n\n\t\t\tthis._enableTileSplitting = v;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\toverlays = [],\n\t\t\tresolution = 256,\n\t\t\trenderer = null,\n\t\t\tenableTileSplitting = true,\n\t\t} = options;\n\n\t\t// plugin needs to run before other plugins that fetch data since content\n\t\t// is handled and loaded in a custom way\n\t\tthis.name = 'IMAGE_OVERLAY_PLUGIN';\n\t\tthis.priority = - 15;\n\n\t\t// options\n\t\tthis.renderer = renderer;\n\t\tthis.resolution = resolution;\n\t\tthis._enableTileSplitting = enableTileSplitting;\n\t\tthis.overlays = [];\n\n\t\t// internal\n\t\tthis.needsUpdate = false;\n\t\tthis.tiles = null;\n\t\tthis.tileComposer = null;\n\t\tthis.tileControllers = new Map();\n\t\tthis.overlayInfo = new Map();\n\t\tthis.usedTextures = new Set();\n\t\tthis.meshParams = new WeakMap();\n\t\tthis.pendingTiles = new Map();\n\t\tthis.processQueue = null;\n\t\tthis._onUpdateAfter = null;\n\t\tthis._onTileDownloadStart = null;\n\t\tthis._cleanupScheduled = false;\n\t\tthis._virtualChildResetId = 0;\n\t\tthis._bytesUsed = new WeakMap();\n\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.addOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\t// plugin functions\n\tinit( tiles ) {\n\n\t\tconst tileComposer = new TiledTextureComposer( this.renderer );\n\t\tconst processQueue = new PriorityQueue();\n\t\tprocessQueue.maxJobs = 10;\n\t\tprocessQueue.priorityCallback = ( a, b ) => {\n\n\t\t\tconst tileA = a.tile;\n\t\t\tconst tileB = b.tile;\n\n\t\t\tconst visibleA = tiles.visibleTiles.has( tileA );\n\t\t\tconst visibleB = tiles.visibleTiles.has( tileB );\n\t\t\tif ( visibleA !== visibleB ) {\n\n\t\t\t\t// load visible tiles first\n\t\t\t\treturn visibleA ? 1 : - 1;\n\n\t\t\t} else {\n\n\t\t\t\t// the fallback to the download queue tile priority\n\t\t\t\treturn tiles.downloadQueue.priorityCallback( tileA, tileB );\n\n\t\t\t}\n\n\t\t\t// TODO: we could prioritize by overlay order here to ensure consistency\n\n\t\t};\n\n\t\t// save variables\n\t\tthis.tiles = tiles;\n\t\tthis.tileComposer = tileComposer;\n\t\tthis.processQueue = processQueue;\n\n\t\t// init all existing tiles\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._processTileModel( scene, tile, true );\n\n\t\t} );\n\n\t\t// update callback for when overlays have changed\n\t\tthis._onUpdateAfter = async () => {\n\n\t\t\t// check if the projection changed for any of the overlays and refresh them\n\t\t\tlet overlayChanged = false;\n\t\t\tthis.overlayInfo.forEach( ( info, overlay ) => {\n\n\t\t\t\tif (\n\t\t\t\t\tBoolean( overlay.frame ) !== Boolean( info.frame ) ||\n\t\t\t\t\toverlay.frame && info.frame && ! info.frame.equals( overlay.frame )\n\t\t\t\t) {\n\n\t\t\t\t\tconst order = info.order;\n\t\t\t\t\tthis.deleteOverlay( overlay, false );\n\t\t\t\t\tthis.addOverlay( overlay, order );\n\n\t\t\t\t\toverlayChanged = true;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// trigger redraws for visible tiles if overlays updated\n\t\t\tif ( overlayChanged ) {\n\n\t\t\t\tconst maxJobs = processQueue.maxJobs;\n\t\t\t\tlet count = 0;\n\t\t\t\tprocessQueue.items.forEach( info => {\n\n\t\t\t\t\tif ( tiles.visibleTiles.has( info.tile ) ) {\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tprocessQueue.maxJobs = count + processQueue.currJobs;\n\t\t\t\tprocessQueue.tryRunJobs();\n\t\t\t\tprocessQueue.maxJobs = maxJobs;\n\n\t\t\t\tthis.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\t// update all the layer uvs\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.needsUpdate = false;\n\n\t\t\t\tconst { overlays, overlayInfo } = this;\n\t\t\t\toverlays.sort( ( a, b ) => {\n\n\t\t\t\t\treturn overlayInfo.get( a ).order - overlayInfo.get( b ).order;\n\n\t\t\t\t} );\n\n\t\t\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\t\t\tthis._updateLayers( tile );\n\n\t\t\t\t} );\n\n\t\t\t\tthis.resetVirtualChildren( ! this.enableTileSplitting );\n\t\t\t\ttiles.recalculateBytesUsed();\n\n\t\t\t\ttiles.dispatchEvent( { type: 'needs-rerender' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis._onTileDownloadStart = ( { tile } ) => {\n\n\t\t\tthis._initTileOverlayInfo( tile );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfter );\n\t\ttiles.addEventListener( 'tile-download-start', this._onTileDownloadStart );\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t} );\n\n\t}\n\n\tdisposeTile( tile ) {\n\n\t\tconst { overlayInfo, tileControllers, processQueue, pendingTiles } = this;\n\n\t\t// Cancel any ongoing tasks. If a tile is cancelled while downloading\n\t\t// this will not have been created, yet.\n\t\tif ( tileControllers.has( tile ) ) {\n\n\t\t\ttileControllers.get( tile ).abort();\n\t\t\ttileControllers.delete( tile );\n\t\t\tpendingTiles.delete( tile );\n\n\t\t}\n\n\t\t// stop any tile loads\n\t\toverlayInfo.forEach( ( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { meshInfo, range, meshRange, level, target, meshRangeMarked, rangeMarked } = tileInfo.get( tile );\n\n\t\t\t\t// release the ranges\n\t\t\t\tif ( meshRange !== null && meshRangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( meshRange, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( range !== null && rangeMarked ) {\n\n\t\t\t\t\tmarkOverlayImages( range, level, overlay, true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( target !== null ) {\n\n\t\t\t\t\t// release the render targets\n\t\t\t\t\ttarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t\ttileInfo.delete( tile );\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t}\n\n\t\t} ) );\n\n\t\t// Remove any items that reference the tile being disposed\n\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\treturn item.tile === tile;\n\n\t\t} );\n\n\t}\n\n\tcalculateBytesUsed( tile ) {\n\n\t\tconst { overlayInfo } = this;\n\t\tconst bytesUsed = this._bytesUsed;\n\n\t\tlet bytes = null;\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\tif ( tileInfo.has( tile ) ) {\n\n\t\t\t\tconst { target } = tileInfo.get( tile );\n\t\t\t\tbytes = bytes || 0;\n\t\t\t\tbytes += MemoryUtils.getTextureByteLength( target?.texture );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( bytes !== null ) {\n\n\t\t\tbytesUsed.set( tile, bytes );\n\t\t\treturn bytes;\n\n\t\t} else if ( bytesUsed.has( tile ) ) {\n\n\t\t\treturn bytesUsed.get( tile );\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tprocessTileModel( scene, tile ) {\n\n\t\treturn this._processTileModel( scene, tile );\n\n\t}\n\n\tasync _processTileModel( scene, tile, initialization = false ) {\n\n\t\tthis.tileControllers.set( tile, new AbortController() );\n\n\t\tif ( ! initialization ) {\n\n\t\t\t// we save all these pending tiles so that they can be correctly initialized if an\n\t\t\t// overlay is added in the time between when this function starts and after the async\n\t\t\t// await call. Otherwise the tile could be missed. But if we're initializing the plugin\n\t\t\t// then we don't need to do this because the tiles are already included in the traversal.\n\t\t\tthis.pendingTiles.set( tile, scene );\n\n\t\t}\n\n\t\tthis._wrapMaterials( scene );\n\t\tthis._initTileOverlayInfo( tile );\n\t\tawait this._initTileSceneOverlayInfo( scene, tile );\n\t\tthis.expandVirtualChildren( scene, tile );\n\t\tthis._updateLayers( tile );\n\n\t\tthis.pendingTiles.delete( tile );\n\n\t}\n\n\tdispose() {\n\n\t\tconst { tileComposer, tiles } = this;\n\n\t\t// dispose textures\n\t\ttileComposer.dispose();\n\n\t\t// dispose of all overlays\n\t\tconst overlays = [ ...this.overlays ];\n\t\toverlays.forEach( overlay => {\n\n\t\t\tthis.deleteOverlay( overlay );\n\n\t\t} );\n\n\t\t// reset the textures of the meshes\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tthis._updateLayers( tile );\n\t\t\tthis.disposeTile( tile );\n\n\t\t\tdelete tile[ SPLIT_HASH ];\n\n\t\t} );\n\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfter );\n\n\t\tthis.resetVirtualChildren( true );\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tthis.overlays.forEach( overlay => {\n\n\t\t\tif ( overlay.opacity > 0 ) {\n\n\t\t\t\toverlay.getAttributions( target );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tparseToMesh( buffer, tile, extension, uri ) {\n\n\t\tif ( extension === 'image_overlay_tile_split' ) {\n\n\t\t\treturn tile[ SPLIT_TILE_DATA ];\n\n\t\t}\n\n\t}\n\n\tasync resetVirtualChildren( fullDispose = false ) {\n\n\t\t// only run this if all the overlays are ready and tile targets have been generated, etc\n\t\t// so we can make an effort to only remove the necessary tiles.\n\t\tthis._virtualChildResetId ++;\n\t\tconst id = this._virtualChildResetId;\n\n\t\tawait Promise.all( this.overlays.map( o => o.whenReady() ) );\n\n\t\tif ( id !== this._virtualChildResetId ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// collect the tiles split into virtual tiles\n\t\tconst { tiles } = this;\n\t\tconst parents = new Set();\n\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\tif ( SPLIT_HASH in tile ) {\n\n\t\t\t\tparents.add( tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// dispose of the virtual children if this tile would not be split or the spilt could change\n\t\t// under the current overlays used.\n\t\tparents.forEach( parent => {\n\n\t\t\tif ( parent.parent === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst clone = parent.cached.scene.clone();\n\t\t\tclone.updateMatrixWorld();\n\n\t\t\tconst { hash } = this._getSplitVectors( clone, parent );\n\t\t\tif ( parent[ SPLIT_HASH ] !== hash || fullDispose ) {\n\n\t\t\t\t// TODO: if are parent tile is forcibly remove then we should make sure that all the children are, too?\n\t\t\t\tconst children = collectChildren( parent );\n\t\t\t\tchildren.sort( ( a, b ) => ( b.__depth || 0 ) - ( a.__depth || 0 ) );\n\n\t\t\t\t// note that we need to remove children from the processing queue in this case\n\t\t\t\t// because we are forcibly evicting them from the cache.\n\t\t\t\tchildren.forEach( child => {\n\n\t\t\t\t\ttiles.processNodeQueue.remove( child );\n\t\t\t\t\ttiles.lruCache.remove( child );\n\t\t\t\t\tchild.parent = null;\n\n\t\t\t\t} );\n\n\t\t\t\tparent.children.length = 0;\n\t\t\t\tparent.__childrenProcessed = 0;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// re-expand tiles if needed\n\t\tif ( ! fullDispose ) {\n\n\t\t\ttiles.forEachLoadedModel( ( scene, tile ) => {\n\n\t\t\t\tthis.expandVirtualChildren( scene, tile );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction collectChildren( root, target = [] ) {\n\n\t\t\troot.children.forEach( child => {\n\n\t\t\t\ttarget.push( child );\n\t\t\t\tcollectChildren( child, target );\n\n\t\t\t} );\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n\t_getSplitVectors( scene, tile, centerTarget = _center ) {\n\n\t\tconst { tiles, overlayInfo } = this;\n\n\t\t// get the center of the content\n\t\tconst box = new Box3();\n\t\tbox.setFromObject( scene );\n\t\tbox.getCenter( centerTarget );\n\n\t\t// find the vectors that are orthogonal to every overlay projection\n\t\tconst splitDirections = [];\n\t\tconst hashTokens = [];\n\t\toverlayInfo.forEach( ( { tileInfo }, overlay ) => {\n\n\t\t\t// if the tile has a render target associated with the overlay and the last level of detail\n\t\t\t// is not being displayed, yet, then we need to split\n\t\t\tconst info = tileInfo.get( tile );\n\t\t\tif ( info && info.target && overlay.tiling.maxLevel > info.level ) {\n\n\t\t\t\t// get the vector representing the projection direction\n\t\t\t\tif ( overlay.frame ) {\n\n\t\t\t\t\t_normal.set( 0, 0, 1 ).transformDirection( overlay.frame );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttiles.ellipsoid.getPositionToNormal( centerTarget, _normal );\n\t\t\t\t\tif ( _normal.length() < 1e-6 ) {\n\n\t\t\t\t\t\t_normal.set( 1, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// dedupe vectors in the hash\n\t\t\t\tconst token = `${ _normal.x.toFixed( 3 ) },${ _normal.y.toFixed( 3 ) },${ _normal.z.toFixed( 3 ) }_`;\n\t\t\t\tif ( ! hashTokens.includes( token ) ) {\n\n\t\t\t\t\thashTokens.push( token );\n\n\t\t\t\t}\n\n\t\t\t\t// construct the orthogonal vectors\n\t\t\t\tconst other = _vec.set( 0, 0, 1 );\n\t\t\t\tif ( Math.abs( _normal.dot( other ) ) > 1 - 1e-4 ) {\n\n\t\t\t\t\tother.set( 1, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tconst ortho0 = new Vector3().crossVectors( _normal, other ).normalize();\n\t\t\t\tconst ortho1 = new Vector3().crossVectors( _normal, ortho0 ).normalize();\n\t\t\t\tsplitDirections.push( ortho0, ortho1 );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Generate a reduced set of vectors by averages directions in a 45 degree cone so\n\t\t// we don't split unnecessarily\n\t\tconst directions = [];\n\t\twhile ( splitDirections.length !== 0 ) {\n\n\t\t\tconst normalized = splitDirections.pop().clone();\n\t\t\tconst average = normalized.clone();\n\t\t\tfor ( let i = 0; i < splitDirections.length; i ++ ) {\n\n\t\t\t\tconst dir = splitDirections[ i ];\n\t\t\t\tconst dotProduct = normalized.dot( dir );\n\t\t\t\tif ( Math.abs( dotProduct ) > Math.cos( Math.PI / 8 ) ) {\n\n\t\t\t\t\taverage.addScaledVector( dir, Math.sign( dotProduct ) );\n\t\t\t\t\tnormalized.copy( average ).normalize();\n\t\t\t\t\tsplitDirections.splice( i, 1 );\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdirections.push( average.normalize() );\n\n\t\t}\n\n\t\treturn { directions, hash: hashTokens.join( '' ) };\n\n\t}\n\n\tasync expandVirtualChildren( scene, tile ) {\n\n\t\tif ( tile.children.length !== 0 || this.enableTileSplitting === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// create a copy of the content to transform and split\n\t\tconst clone = scene.clone();\n\t\tclone.updateMatrixWorld();\n\n\t\t// get the directions to split on\n\t\tconst { directions, hash } = this._getSplitVectors( clone, tile, _center );\n\t\ttile[ SPLIT_HASH ] = hash;\n\n\t\t// if there are no directions to split on then exit early\n\t\tif ( directions.length === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// set up the splitter to ignore overlay uvs\n\t\tconst clipper = new GeometryClipper();\n\t\tclipper.attributeList = key => ! /^layer_uv_\\d+/.test( key );\n\t\tdirections.map( splitDirection => {\n\n\t\t\tclipper.addSplitOperation( ( geometry, i0, i1, i2, barycoord, matrixWorld ) => {\n\n\t\t\t\tTriangle.getInterpolatedAttribute( geometry.attributes.position, i0, i1, i2, barycoord, _vec );\n\t\t\t\treturn _vec.applyMatrix4( matrixWorld ).sub( _center ).dot( splitDirection );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// run the clipping operations by performing every permutation of sides\n\t\t// defined by the split directions\n\t\tconst children = [];\n\t\tclipper.forEachSplitPermutation( () => {\n\n\t\t\t// clip the object itself\n\t\t\tconst result = clipper.clipObject( clone );\n\n\t\t\t// remove the parent transform because it will be multiplied back in after the fact\n\t\t\tresult.matrix\n\t\t\t\t.premultiply( tile.cached.transformInverse )\n\t\t\t\t.decompose( result.position, result.quaternion, result.scale );\n\n\t\t\t// collect the meshes\n\t\t\tconst meshes = [];\n\t\t\tresult.traverse( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tconst material = c.material.clone();\n\t\t\t\t\tc.material = material;\n\t\t\t\t\tfor ( const key in material ) {\n\n\t\t\t\t\t\tconst value = material[ key ];\n\t\t\t\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\t\t\t\tif ( value.source.data instanceof ImageBitmap ) {\n\n\t\t\t\t\t\t\t\t// clone any image bitmap textures using canvas because if we share the texture then when\n\t\t\t\t\t\t\t\t// the clipped child is disposed then it will dispose of the parent tile texture data, as well.\n\t\t\t\t\t\t\t\tconst canvas = document.createElement( 'canvas' );\n\t\t\t\t\t\t\t\tcanvas.width = value.image.width;\n\t\t\t\t\t\t\t\tcanvas.height = value.image.height;\n\n\t\t\t\t\t\t\t\tconst ctx = canvas.getContext( '2d' );\n\t\t\t\t\t\t\t\tctx.scale( 1, - 1 );\n\t\t\t\t\t\t\t\tctx.drawImage( value.source.data, 0, 0, canvas.width, - canvas.height );\n\n\t\t\t\t\t\t\t\tconst tex = new CanvasTexture( canvas );\n\t\t\t\t\t\t\t\ttex.mapping = value.mapping;\n\t\t\t\t\t\t\t\ttex.wrapS = value.wrapS;\n\t\t\t\t\t\t\t\ttex.wrapT = value.wrapT;\n\t\t\t\t\t\t\t\ttex.minFilter = value.minFilter;\n\t\t\t\t\t\t\t\ttex.magFilter = value.magFilter;\n\t\t\t\t\t\t\t\ttex.format = value.format;\n\t\t\t\t\t\t\t\ttex.type = value.type;\n\t\t\t\t\t\t\t\ttex.anisotropy = value.anisotropy;\n\t\t\t\t\t\t\t\ttex.colorSpace = value.colorSpace;\n\t\t\t\t\t\t\t\ttex.generateMipmaps = value.generateMipmaps;\n\n\t\t\t\t\t\t\t\tmaterial[ key ] = tex;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( meshes.length === 0 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// generate a region bounding volume\n\t\t\tconst boundingVolume = {};\n\t\t\tif ( tile.boundingVolume.region ) {\n\n\t\t\t\tboundingVolume.region = getMeshesCartographicRange( meshes, this.tiles.ellipsoid ).region;\n\n\t\t\t}\n\n\t\t\t// create a sphere bounding volume\n\t\t\tif ( tile.boundingVolume.box || tile.boundingVolume.sphere ) {\n\n\t\t\t\t// TODO: we create a sphere even when a region is present because currently the handling of region volumes\n\t\t\t\t// is a bit flaky especially at small scales. OBBs are generated which can be imperfect resulting rays passing\n\t\t\t\t// through tiles. The same may be the case with frustum checks. In theory, though, we should not need a sphere\n\t\t\t\t// bounds if a region bounds are present.\n\n\t\t\t\t// compute the sphere center\n\t\t\t\t_box\n\t\t\t\t\t.setFromObject( result, true )\n\t\t\t\t\t.getCenter( _sphereCenter );\n\n\t\t\t\t// calculate the sq radius from all vertices\n\t\t\t\tlet maxSqRadius = 0;\n\t\t\t\tresult.traverse( c => {\n\n\t\t\t\t\tconst geometry = c.geometry;\n\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst sqRadius = _vec\n\t\t\t\t\t\t\t\t.fromBufferAttribute( position, i )\n\t\t\t\t\t\t\t\t.applyMatrix4( c.matrixWorld )\n\t\t\t\t\t\t\t\t.distanceToSquared( _sphereCenter );\n\n\t\t\t\t\t\t\tmaxSqRadius = Math.max( maxSqRadius, sqRadius );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tboundingVolume.sphere = [ ..._sphereCenter, Math.sqrt( maxSqRadius ) ];\n\n\t\t\t}\n\n\t\t\tchildren.push( {\n\t\t\t\trefine: 'REPLACE',\n\t\t\t\tgeometricError: tile.geometricError * 0.5,\n\t\t\t\tboundingVolume: boundingVolume,\n\t\t\t\tcontent: { uri: './child.image_overlay_tile_split' },\n\t\t\t\tchildren: [],\n\t\t\t\t[ SPLIT_TILE_DATA ]: result,\n\t\t\t} );\n\n\t\t} );\n\n\t\ttile.children.push( ...children );\n\n\t}\n\n\tfetchData( uri, options ) {\n\n\t\t// if this is our custom url indicating a tile split then return fake response\n\t\tif ( /image_overlay_tile_split/.test( uri ) ) {\n\n\t\t\treturn new ArrayBuffer();\n\n\t\t}\n\n\t}\n\n\t// public\n\taddOverlay( overlay, order = null ) {\n\n\t\tconst { tiles, overlays, overlayInfo } = this;\n\n\t\tif ( order === null ) {\n\n\t\t\t// set the order to the next largest order value\n\t\t\torder = overlays.reduce( ( v, o ) => Math.max( v, o.order + 1 ), 0 );\n\n\t\t}\n\n\t\tconst controller = new AbortController();\n\t\toverlays.push( overlay );\n\t\toverlayInfo.set( overlay, {\n\t\t\torder: order,\n\t\t\tuniforms: {},\n\t\t\ttileInfo: new Map(),\n\t\t\tcontroller: controller,\n\t\t\tframe: overlay.frame ? overlay.frame.clone() : null,\n\t\t} );\n\n\t\tif ( tiles !== null ) {\n\n\t\t\tthis._initOverlay( overlay );\n\n\t\t}\n\n\t}\n\n\tsetOverlayOrder( overlay, order ) {\n\n\t\tconst index = this.overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.overlayInfo.get( overlay ).order = order;\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\tdeleteOverlay( overlay, forceDispose = true ) {\n\n\t\tconst { overlays, overlayInfo, processQueue } = this;\n\t\tconst index = overlays.indexOf( overlay );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tconst { tileInfo, controller } = overlayInfo.get( overlay );\n\t\t\ttileInfo.forEach( ( { meshInfo, target } ) => {\n\n\t\t\t\tif ( target !== null ) {\n\n\t\t\t\t\ttarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tmeshInfo.clear();\n\n\t\t\t} );\n\n\t\t\ttileInfo.clear();\n\t\t\toverlayInfo.delete( overlay );\n\t\t\tcontroller.abort();\n\n\t\t\t// Remove any items that reference the overlay being disposed\n\t\t\tprocessQueue.removeByFilter( item => {\n\n\t\t\t\treturn item.overlay === overlay;\n\n\t\t\t} );\n\n\t\t\toverlays.splice( index, 1 );\n\t\t\tif ( forceDispose ) {\n\n\t\t\t\toverlay.dispose();\n\n\t\t\t}\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t}\n\n\t}\n\n\t// internal\n\t_calculateLevelFromOverlay( overlay, range, tile, normalized = false ) {\n\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\tconst { resolution } = this;\n\t\t\tconst { tiling } = overlay;\n\n\t\t\tconst normalizedRange = normalized ? range : tiling.toNormalizedRange( range );\n\t\t\tconst [ minX, minY, maxX, maxY ] = normalizedRange;\n\t\t\tconst w = maxX - minX;\n\t\t\tconst h = maxY - minY;\n\n\t\t\tlet level = 0;\n\t\t\tconst { maxLevel } = tiling;\n\t\t\tfor ( ; level < maxLevel; level ++ ) {\n\n\t\t\t\t// the number of pixels per image on each axis\n\t\t\t\tconst wProj = resolution / w;\n\t\t\t\tconst hProj = resolution / h;\n\n\t\t\t\tconst { pixelWidth, pixelHeight } = tiling.getLevel( level );\n\t\t\t\tif ( pixelWidth >= wProj || pixelHeight >= hProj ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: should this be one layer higher LoD?\n\t\t\treturn level;\n\n\t\t} else {\n\n\t\t\treturn tile.__depthFromRenderedParent - 1;\n\n\t\t}\n\n\t}\n\n\t// initialize the overlay to use the right fetch options, load all data for existing tiles\n\t_initOverlay( overlay ) {\n\n\t\tconst { tiles } = this;\n\n\t\tif ( ! overlay.isInitialized ) {\n\n\t\t\toverlay.imageSource.fetchData = ( ...args ) => tiles\n\t\t\t\t.downloadQueue\n\t\t\t\t.add( { priority: - performance.now() }, () => {\n\n\t\t\t\t\treturn overlay.fetch( ...args );\n\n\t\t\t\t} );\n\t\t\toverlay.init();\n\n\t\t}\n\n\t\tconst promises = [];\n\t\tconst initTile = async ( scene, tile ) => {\n\n\t\t\tthis._initTileOverlayInfo( tile, overlay );\n\n\t\t\tconst promise = this._initTileSceneOverlayInfo( scene, tile, overlay );\n\t\t\tpromises.push( promise );\n\n\t\t\t// mark tiles as needing an update after initialized so we get a trickle in of tiles\n\t\t\tawait promise;\n\t\t\tthis._updateLayers( tile );\n\n\t\t};\n\n\t\ttiles.forEachLoadedModel( initTile );\n\t\tthis.pendingTiles.forEach( ( scene, tile ) => {\n\n\t\t\tinitTile( scene, tile );\n\n\t\t} );\n\n\t\tPromise.all( promises ).then( () => {\n\n\t\t\tthis._markNeedsUpdate();\n\n\t\t} );\n\n\t}\n\n\t// wrap all materials in the given scene wit the overlay material shader\n\t_wrapMaterials( scene ) {\n\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.material ) {\n\n\t\t\t\tconst params = wrapOverlaysMaterial( c.material, c.material.onBeforeCompile );\n\t\t\t\tthis.meshParams.set( c, params );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// Initialize per-tile overlay information. This function triggers an async function but\n\t// does not need to be awaited for use since it's just locking textures which are awaited later.\n\t_initTileOverlayInfo( tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\toverlay.forEach( o => this._initTileOverlayInfo( tile, o ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// This function is resilient to multiple calls in case an overlay is added after a tile starts loading\n\t\t// and before it is loaded, meaning this function needs to be called twice to ensure it's initialized.\n\t\tconst { overlayInfo, processQueue } = this;\n\t\tif ( overlayInfo.get( overlay ).tileInfo.has( tile ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst level = tile.__depthFromRenderedParent - 1;\n\t\tconst info = {\n\t\t\trange: null,\n\t\t\tmeshRange: null,\n\t\t\tlevel: null,\n\t\t\ttarget: null,\n\t\t\tmeshInfo: new Map(),\n\n\t\t\trangeMarked: false,\n\t\t\tmeshRangeMarked: false,\n\t\t};\n\n\t\toverlayInfo\n\t\t\t.get( overlay )\n\t\t\t.tileInfo\n\t\t\t.set( tile, info );\n\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t// TODO: we could project the shape into the frame, compute 2d bounds, and then mark tiles\n\n\t\t} else {\n\n\t\t\t// If the tile has a region bounding volume then mark the tiles to preload\n\t\t\tif ( tile.boundingVolume.region ) {\n\n\t\t\t\tconst [ minLon, minLat, maxLon, maxLat ] = tile.boundingVolume.region;\n\t\t\t\tconst range = [ minLon, minLat, maxLon, maxLat ];\n\t\t\t\tinfo.range = range;\n\t\t\t\tinfo.level = this._calculateLevelFromOverlay( overlay, range, tile );\n\n\t\t\t\tprocessQueue\n\t\t\t\t\t.add( { tile, overlay }, () => {\n\n\t\t\t\t\t\tinfo.rangeMarked = true;\n\t\t\t\t\t\treturn markOverlayImages( range, level, overlay, false );\n\n\t\t\t\t\t} )\n\t\t\t\t\t.catch( () => {\n\n\t\t\t\t\t\t// the queue throws an error if a task is removed early\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the scene meshes\n\tasync _initTileSceneOverlayInfo( scene, tile, overlay = this.overlays ) {\n\n\t\tif ( Array.isArray( overlay ) ) {\n\n\t\t\treturn Promise.all( overlay.map( o => this._initTileSceneOverlayInfo( scene, tile, o ) ) );\n\n\t\t}\n\n\t\tconst { tiles, overlayInfo, resolution, tileComposer, tileControllers, usedTextures, processQueue } = this;\n\t\tconst { ellipsoid } = tiles;\n\t\tconst { controller, tileInfo } = overlayInfo.get( overlay );\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// wait for the overlay to be completely loaded so projection and tiling are available\n\t\tif ( ! overlay.isReady ) {\n\n\t\t\tawait overlay.whenReady();\n\n\t\t}\n\n\t\t// check if the overlay or tile have been disposed since starting this function\n\t\t// if the tileController is not present then the tile has been disposed of already\n\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// find all meshes to project on and ensure matrices are up to date\n\t\tconst meshes = [];\n\t\tscene.updateMatrixWorld();\n\t\tscene.traverse( c => {\n\n\t\t\tif ( c.isMesh ) {\n\n\t\t\t\tmeshes.push( c );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst { tiling, imageSource } = overlay;\n\t\tconst info = tileInfo.get( tile );\n\t\tlet range, uvs, heightInRange;\n\n\t\t// retrieve the uvs and range for all the meshes\n\t\tif ( overlay.isPlanarProjection ) {\n\n\t\t\t_matrix.copy( overlay.frame );\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.multiply( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tlet heightRange;\n\t\t\t( { range, uvs, heightRange } = getMeshesPlanarRange( meshes, _matrix, tiling ) );\n\t\t\theightInRange = ! ( heightRange[ 0 ] > 1 || heightRange[ 1 ] < 0 );\n\n\t\t} else {\n\n\t\t\t_matrix.identity();\n\t\t\tif ( scene.parent !== null ) {\n\n\t\t\t\t_matrix.copy( tiles.group.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\t( { range, uvs } = getMeshesCartographicRange( meshes, ellipsoid, _matrix, tiling ) );\n\t\t\theightInRange = true;\n\n\t\t}\n\n\t\tlet normalizedRange;\n\t\tif ( ! overlay.isPlanarProjection ) {\n\n\t\t\tnormalizedRange = tiling.toNormalizedRange( range );\n\n\t\t} else {\n\n\t\t\tnormalizedRange = range;\n\n\t\t}\n\n\t\t// calculate the tiling level here if not already created\n\t\tif ( info.level === null ) {\n\n\t\t\tinfo.level = this._calculateLevelFromOverlay( overlay, normalizedRange, tile, true );\n\n\t\t}\n\n\t\t// if the image projection is outside the 0, 1 uvw range or there are no textures to draw in\n\t\t// the tiled image set the don't allocate a texture for it.\n\t\tlet target = null;\n\t\tif ( heightInRange && countTilesInRange( range, info.level, overlay ) !== 0 ) {\n\n\t\t\ttarget = new WebGLRenderTarget( resolution, resolution, {\n\t\t\t\tdepthBuffer: false,\n\t\t\t\tstencilBuffer: false,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tcolorSpace: SRGBColorSpace,\n\t\t\t} );\n\n\t\t}\n\n\t\tinfo.meshRange = range;\n\t\tinfo.target = target;\n\n\t\tmeshes.forEach( ( mesh, i ) => {\n\n\t\t\tconst array = new Float32Array( uvs[ i ] );\n\t\t\tconst attribute = new BufferAttribute( array, 3 );\n\t\t\tinfo.meshInfo.set( mesh, { attribute } );\n\n\t\t} );\n\n\t\tif ( target !== null ) {\n\n\t\t\tawait processQueue\n\t\t\t\t.add( { tile, overlay }, async () => {\n\n\t\t\t\t\tinfo.meshRangeMarked = true;\n\n\t\t\t\t\tconst promise = markOverlayImages( range, info.level, overlay, false );\n\t\t\t\t\tif ( promise ) {\n\n\t\t\t\t\t\t// if the previous layer is present then draw it as an overlay to fill in any gaps while we wait for\n\t\t\t\t\t\t// the next set of textures\n\t\t\t\t\t\ttileComposer.setRenderTarget( target, normalizedRange );\n\t\t\t\t\t\ttileComposer.clear( 0xffffff, 0 );\n\n\t\t\t\t\t\tforEachTileInBounds( range, info.level - 1, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\t\t\t\t\t// draw using normalized bounds since the mercator bounds are non-linear\n\t\t\t\t\t\t\tconst span = tiling.getTileBounds( tx, ty, tl, true, false );\n\t\t\t\t\t\t\tconst tex = imageSource.get( tx, ty, tl );\n\t\t\t\t\t\t\tif ( tex && ! ( tex instanceof Promise ) ) {\n\n\t\t\t\t\t\t\t\ttileComposer.draw( tex, span );\n\t\t\t\t\t\t\t\tusedTextures.add( tex );\n\t\t\t\t\t\t\t\tthis._scheduleCleanup();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tawait promise;\n\n\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t// skip errors since this will throw when aborted\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if the overlay has been disposed since starting this function\n\t\t\t\t\tif ( controller.signal.aborted || tileController.signal.aborted ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// draw the textures\n\t\t\t\t\ttileComposer.setRenderTarget( target, normalizedRange );\n\t\t\t\t\ttileComposer.clear( 0xffffff, 0 );\n\n\t\t\t\t\tforEachTileInBounds( range, info.level, tiling, overlay.isPlanarProjection, ( tx, ty, tl ) => {\n\n\t\t\t\t\t\t// draw using normalized bounds since the mercator bounds are non-linear\n\t\t\t\t\t\tconst span = tiling.getTileBounds( tx, ty, tl, true, false );\n\t\t\t\t\t\tconst tex = imageSource.get( tx, ty, tl );\n\t\t\t\t\t\ttileComposer.draw( tex, span );\n\t\t\t\t\t\tusedTextures.add( tex );\n\t\t\t\t\t\tthis._scheduleCleanup();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.catch( () => {\n\n\t\t\t\t\t// the queue throws an error if a task is removed early\n\n\t\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t_updateLayers( tile ) {\n\n\t\tconst { overlayInfo, overlays, tileControllers } = this;\n\t\tconst tileController = tileControllers.get( tile );\n\n\t\t// by this point all targets should be present and we can force the memory to update\n\t\tthis.tiles.recalculateBytesUsed( tile );\n\n\t\t// if the tile has been disposed before this function is called then exit early\n\t\tif ( ! tileController || tileController.signal.aborted ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// update the uvs and texture overlays for each mesh\n\t\toverlays.forEach( ( overlay, i ) => {\n\n\t\t\tconst { tileInfo } = overlayInfo.get( overlay );\n\t\t\tconst { meshInfo, target } = tileInfo.get( tile );\n\t\t\tmeshInfo.forEach( ( { attribute }, mesh ) => {\n\n\t\t\t\tconst { geometry, material } = mesh;\n\t\t\t\tconst params = this.meshParams.get( mesh );\n\n\t\t\t\t// assign the new uvs\n\t\t\t\tconst key = `layer_uv_${ i }`;\n\t\t\t\tif ( geometry.getAttribute( key ) !== attribute ) {\n\n\t\t\t\t\tgeometry.setAttribute( key, attribute );\n\t\t\t\t\tgeometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t\t// set the uniform array lengths\n\t\t\t\tparams.layerMaps.length = overlays.length;\n\t\t\t\tparams.layerColor.length = overlays.length;\n\n\t\t\t\t// assign the uniforms\n\t\t\t\tparams.layerMaps.value[ i ] = target !== null ? target.texture : null;\n\t\t\t\tparams.layerColor.value[ i ] = overlay;\n\n\t\t\t\tmaterial.defines.LAYER_COUNT = overlays.length;\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t_scheduleCleanup() {\n\n\t\t// clean up textures used for drawing the tile overlays\n\t\tif ( ! this._cleanupScheduled ) {\n\n\t\t\tthis._cleanupScheduled = true;\n\t\t\trequestAnimationFrame( () => {\n\n\t\t\t\tconst { usedTextures } = this;\n\t\t\t\tusedTextures.forEach( tex => {\n\n\t\t\t\t\ttex.dispose();\n\n\t\t\t\t} );\n\n\t\t\t\tusedTextures.clear();\n\t\t\t\tthis._cleanupScheduled = false;\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t_markNeedsUpdate() {\n\n\t\tif ( this.needsUpdate === false ) {\n\n\t\t\tthis.needsUpdate = true;\n\t\t\tif ( this.tiles !== null ) {\n\n\t\t\t\tthis.tiles.dispatchEvent( { type: 'needs-update' } );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nclass ImageOverlay {\n\n\tget tiling() {\n\n\t\treturn this.imageSource.tiling;\n\n\t}\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tget isPlanarProjection() {\n\n\t\treturn Boolean( this.frame );\n\n\t}\n\n\tget aspectRatio() {\n\n\t\treturn this.tiling && this.isReady ? this.tiling.aspectRatio : 1;\n\n\t}\n\n\tget fetchOptions() {\n\n\t\treturn this.imageSource.fetchOptions;\n\n\t}\n\n\tset fetchOptions( v ) {\n\n\t\tthis.imageSource.fetchOptions = v;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\topacity = 1,\n\t\t\tcolor = 0xffffff,\n\t\t\tframe = null,\n\t\t\tpreprocessURL = null,\n\t\t} = options;\n\t\tthis.imageSource = null;\n\n\t\tthis.preprocessURL = preprocessURL;\n\t\tthis.opacity = opacity;\n\t\tthis.color = new Color( color );\n\t\tthis.frame = frame !== null ? frame.clone() : null;\n\t\tthis.isReady = false;\n\t\tthis.isInitialized = false;\n\n\t}\n\n\tinit() {\n\n\t\tthis.isInitialized = true;\n\t\tthis.whenReady().then( () => {\n\n\t\t\tthis.isReady = true;\n\n\t\t} );\n\n\t}\n\n\tfetch( url, options = {} ) {\n\n\t\tif ( this.preprocessURL ) {\n\n\t\t\turl = this.preprocessURL( url );\n\n\t\t}\n\n\t\treturn fetch( url, options );\n\n\t}\n\n\twhenReady() {\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.imageSource.dispose();\n\n\t}\n\n}\n\nexport class XYZTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new XYZImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class GeoJSONOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new GeoJSONImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class WMSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new WMSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class WMTSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new WMTSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class TMSTilesOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\t\tthis.imageSource = new TMSImageSource( options );\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis.url = options.url;\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this.imageSource.init();\n\n\t\tsuper.init();\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n}\n\nexport class CesiumIonOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, autoRefreshToken, assetId } = options;\n\t\tthis.assetId = assetId;\n\t\tthis.auth = new CesiumIonAuth( { apiToken, autoRefreshToken } );\n\t\tthis.imageSource = new TMSImageSource( options );\n\n\t\tthis.auth.authURL = `https://api.cesium.com/v1/assets/${ assetId }/endpoint`;\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis._attributions = [];\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis._attributions = json.attributions.map( att => ( {\n\t\t\t\t\tvalue: att.html,\n\t\t\t\t\ttype: 'html',\n\t\t\t\t\tcollapsible: att.collapsible,\n\t\t\t\t} ) );\n\n\t\t\t\tthis.imageSource.url = json.url;\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t\tsuper.init();\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn this.auth.fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\ttarget.push( ...this._attributions );\n\n\t}\n\n}\n\nexport class GoogleMapsOverlay extends ImageOverlay {\n\n\tconstructor( options = {} ) {\n\n\t\tsuper( options );\n\n\t\tconst { apiToken, sessionOptions, autoRefreshToken, logoUrl } = options;\n\t\tthis.logoUrl = logoUrl;\n\t\tthis.auth = new GoogleCloudAuth( { apiToken, sessionOptions, autoRefreshToken } );\n\t\tthis.imageSource = new XYZImageSource();\n\n\t\tthis.imageSource.fetchData = ( ...args ) => this.fetch( ...args );\n\t\tthis._logoAttribution = {\n\t\t\tvalue: '',\n\t\t\ttype: 'image',\n\t\t\tcollapsible: false,\n\t\t};\n\n\t}\n\n\tinit() {\n\n\t\tthis._whenReady = this\n\t\t\t.auth\n\t\t\t.refreshToken()\n\t\t\t.then( json => {\n\n\t\t\t\tthis.imageSource.tileDimension = json.tileWidth;\n\t\t\t\tthis.imageSource.url = 'https://tile.googleapis.com/v1/2dtiles/{z}/{x}/{y}';\n\t\t\t\treturn this.imageSource.init();\n\n\t\t\t} );\n\n\t\tsuper.init();\n\n\t}\n\n\tfetch( ...args ) {\n\n\t\treturn this.auth.fetch( ...args );\n\n\t}\n\n\twhenReady() {\n\n\t\treturn this._whenReady;\n\n\t}\n\n\tgetAttributions( target ) {\n\n\t\tif ( this.logoUrl ) {\n\n\t\t\tthis._logoAttribution.value = this.logoUrl;\n\t\t\ttarget.push( this._logoAttribution );\n\n\t\t}\n\n\t}\n\n}\n","import { Ray, Sphere } from 'three';\nimport { OBB } from '3d-tiles-renderer/three';\n\nexport class LoadRegionPlugin {\n\n\tconstructor() {\n\n\t\tthis.name = 'LOAD_REGION_PLUGIN';\n\t\tthis.regions = [];\n\t\tthis.tiles = null;\n\n\t}\n\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t}\n\n\taddRegion( region ) {\n\n\t\tif ( this.regions.indexOf( region ) === - 1 ) {\n\n\t\t\tthis.regions.push( region );\n\n\t\t}\n\n\t}\n\n\tremoveRegion( region ) {\n\n\t\tconst index = this.regions.indexOf( region );\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.regions.splice( index, 1 );\n\n\t\t}\n\n\t}\n\n\thasRegion( region ) {\n\n\t\treturn this.regions.indexOf( region ) !== - 1;\n\n\t}\n\n\tclearRegions() {\n\n\t\tthis.regions = [];\n\n\t}\n\n\t// Calculates shape intersections and associated error values to use. If \"mask\" shapes are present then\n\t// tiles are only loaded if they are within those shapes.\n\tcalculateTileViewError( tile, target ) {\n\n\t\tconst boundingVolume = tile.cached.boundingVolume;\n\t\tconst { regions, tiles } = this;\n\n\t\tlet inShape = false;\n\t\tlet inMask = null;\n\t\tlet maxError = - Infinity;\n\t\tfor ( const region of regions ) {\n\n\t\t\t// Check if the tile is intersecting the shape and calculate the\n\t\t\t// view and error values.\n\t\t\tconst intersects = region.intersectsTile( boundingVolume, tile, tiles );\n\t\t\tinShape = inShape || intersects;\n\t\t\tmaxError = Math.max( region.calculateError( tile, tiles ), maxError );\n\n\t\t\t// Store whether the tile is in a \"mask\" shape if they exist. If \"inMask\" is\n\t\t\t// still \"null\" by the end of the loop then there are no mask elements.\n\t\t\tif ( region.mask ) {\n\n\t\t\t\tinMask = inMask || intersects;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// A tile should only be visible if it intersects a shape and a mask shape or there\n\t\t// are no masks.\n\t\ttarget.inView = inShape && inMask !== false;\n\t\ttarget.error = maxError;\n\n\t\t// Returning \"false\" indicates \"no operation\" and all results will be ignored.\n\t\treturn target.inView || inMask !== null;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.regions = [];\n\n\t}\n\n}\n\n// Definitions of predefined regions\nexport class BaseRegion {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'LoadRegionPlugin: Region constructor has been changed to take options as an object.' );\n\t\t\toptions = { errorTarget: options };\n\n\t\t}\n\n\t\tconst {\n\t\t\terrorTarget = 10,\n\t\t\tmask = false,\n\t\t} = options;\n\n\t\tthis.errorTarget = errorTarget;\n\t\tthis.mask = mask;\n\n\t}\n\n\tintersectsTile() {}\n\n\tcalculateError( tile, tilesRenderer ) {\n\n\t\treturn tile.geometricError - this.errorTarget + tilesRenderer.errorTarget;\n\n\t}\n\n}\n\nexport class SphereRegion extends BaseRegion {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'SphereRegion: Region constructor has been changed to take options as an object.' );\n\t\t\toptions = {\n\t\t\t\terrorTarget: arguments[ 0 ],\n\t\t\t\tsphere: arguments[ 1 ],\n\t\t\t};\n\n\t\t}\n\n\t\tconst { sphere = new Sphere() } = options;\n\n\t\tsuper( options );\n\t\tthis.sphere = sphere.clone();\n\n\t}\n\n\tintersectsTile( boundingVolume ) {\n\n\t\treturn boundingVolume.intersectsSphere( this.sphere );\n\n\t}\n\n}\n\nexport class RayRegion extends BaseRegion {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'RayRegion: Region constructor has been changed to take options as an object.' );\n\t\t\toptions = {\n\t\t\t\terrorTarget: arguments[ 0 ],\n\t\t\t\tray: arguments[ 1 ],\n\t\t\t};\n\n\t\t}\n\n\t\tconst { ray = new Ray() } = options;\n\n\t\tsuper( options );\n\t\tthis.ray = ray.clone();\n\n\t}\n\n\tintersectsTile( boundingVolume ) {\n\n\t\treturn boundingVolume.intersectsRay( this.ray );\n\n\t}\n\n}\n\nexport class OBBRegion extends BaseRegion {\n\n\tconstructor( options = {} ) {\n\n\t\tif ( typeof options === 'number' ) {\n\n\t\t\tconsole.warn( 'RayRegion: Region constructor has been changed to take options as an object.' );\n\t\t\toptions = {\n\t\t\t\terrorTarget: arguments[ 0 ],\n\t\t\t\tobb: arguments[ 1 ],\n\t\t\t};\n\n\t\t}\n\n\t\tconst { obb = new OBB() } = options;\n\n\t\tsuper( options );\n\t\tthis.obb = obb.clone();\n\t\tthis.obb.update();\n\n\t}\n\n\tintersectsTile( boundingVolume ) {\n\n\t\treturn boundingVolume.intersectsOBB( this.obb );\n\n\t}\n\n}\n","import { LineSegments, BufferGeometry, Vector3, BufferAttribute, LineBasicMaterial } from 'three';\n\nconst _vector = new Vector3();\nconst axes = [ 'x', 'y', 'z' ];\nexport class SphereHelper extends LineSegments {\n\n\tconstructor( sphere, color = 0xffff00, angleSteps = 40 ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst positions = [];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis1 = axes[ i ];\n\t\t\tconst axis2 = axes[ ( i + 1 ) % 3 ];\n\t\t\t_vector.set( 0, 0, 0 );\n\n\t\t\tfor ( let a = 0; a < angleSteps; a ++ ) {\n\n\t\t\t\tlet angle;\n\t\t\t\tangle = 2 * Math.PI * a / ( angleSteps - 1 );\n\t\t\t\t_vector[ axis1 ] = Math.sin( angle );\n\t\t\t\t_vector[ axis2 ] = Math.cos( angle );\n\n\t\t\t\tpositions.push( _vector.x, _vector.y, _vector.z );\n\n\t\t\t\tangle = 2 * Math.PI * ( a + 1 ) / ( angleSteps - 1 );\n\t\t\t\t_vector[ axis1 ] = Math.sin( angle );\n\t\t\t\t_vector[ axis2 ] = Math.cos( angle );\n\n\t\t\t\tpositions.push( _vector.x, _vector.y, _vector.z );\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( positions ), 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.sphere = sphere;\n\t\tthis.type = 'SphereHelper';\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst sphere = this.sphere;\n\t\tthis.position.copy( sphere.center );\n\t\tthis.scale.setScalar( sphere.radius );\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n}\n","import { Mesh, Vector3, MathUtils, BoxGeometry, BufferGeometry, EdgesGeometry, LineSegments, BufferAttribute } from 'three';\nimport { EllipsoidRegion } from '3d-tiles-renderer/three';\n\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _norm2 = /* @__PURE__ */ new Vector3();\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _vec1 = /* @__PURE__ */ new Vector3();\nconst _vec2 = /* @__PURE__ */ new Vector3();\n\n// Converts a geometry with a given set of groups rendering a smaller set of\n// geometry into a new one with only the relevant triangles.\nfunction toGroupGeometry( geometry ) {\n\n\t// non indexed makes this process easier\n\tgeometry = geometry.toNonIndexed();\n\n\t// prep the arrays\n\tconst { groups } = geometry;\n\tconst { position, normal } = geometry.attributes;\n\tconst newNorm = [];\n\tconst newPos = [];\n\n\t// add the normals and the positions\n\tfor ( const group of groups ) {\n\n\t\tconst { start, count } = group;\n\t\tfor ( let i = start, l = ( start + count ); i < l; i ++ ) {\n\n\t\t\t_vec1.fromBufferAttribute( position, i );\n\t\t\t_vec2.fromBufferAttribute( normal, i );\n\n\t\t\tnewPos.push( ..._vec1 );\n\t\t\tnewNorm.push( ..._vec2 );\n\n\t\t}\n\n\t}\n\n\t// set the new geometry\n\tconst newGeometry = new BufferGeometry();\n\tnewGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( newPos ), 3 ) );\n\tnewGeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( newNorm ), 3 ) );\n\n\treturn newGeometry;\n\n}\n\nfunction getRegionGeometry( ellipsoidRegion, { computeNormals = false } = {} ) {\n\n\t// retrieve the relevant fields\n\tconst {\n\t\tlatStart = - Math.PI / 2, latEnd = Math.PI / 2,\n\t\tlonStart = 0, lonEnd = 2 * Math.PI,\n\t\theightStart = 0, heightEnd = 0,\n\t} = ellipsoidRegion;\n\n\t// get the attributes\n\tconst geometry = new BoxGeometry( 1, 1, 1, 32, 32 );\n\tconst { normal, position } = geometry.attributes;\n\n\t// clone the position buffer so we can reference it for normal calculations later\n\tconst refPosition = position.clone();\n\n\t// perturb the position buffer into an ellipsoid region\n\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t_pos.fromBufferAttribute( position, i );\n\n\t\tconst lat = MathUtils.mapLinear( _pos.x, - 0.5, 0.5, latStart, latEnd );\n\t\tconst lon = MathUtils.mapLinear( _pos.y, - 0.5, 0.5, lonStart, lonEnd );\n\n\t\tlet height = heightStart;\n\t\tellipsoidRegion.getCartographicToNormal( lat, lon, _norm );\n\t\tif ( _pos.z < 0 ) {\n\n\t\t\theight = heightEnd;\n\n\t\t}\n\t\tellipsoidRegion.getCartographicToPosition( lat, lon, height, _pos );\n\t\tposition.setXYZ( i, ..._pos );\n\n\t}\n\n\tif ( computeNormals ) {\n\n\t\t// compute the vertex normals so we can get the edge normals\n\t\tgeometry.computeVertexNormals();\n\n\t}\n\n\t// compute the top and bottom cap normals\n\tfor ( let i = 0, l = refPosition.count; i < l; i ++ ) {\n\n\t\t_pos.fromBufferAttribute( refPosition, i );\n\n\t\tconst lat = MathUtils.mapLinear( _pos.x, - 0.5, 0.5, latStart, latEnd );\n\t\tconst lon = MathUtils.mapLinear( _pos.y, - 0.5, 0.5, lonStart, lonEnd );\n\n\t\t_norm.fromBufferAttribute( normal, i );\n\t\tellipsoidRegion.getCartographicToNormal( lat, lon, _norm2 );\n\n\t\t// exclude the sides so we get sharp corners\n\t\tif ( Math.abs( _norm.dot( _norm2 ) ) > 0.1 ) {\n\n\t\t\tif ( _pos.z > 0 ) {\n\n\t\t\t\t_norm2.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tnormal.setXYZ( i, ..._norm2 );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport class EllipsoidRegionLineHelper extends LineSegments {\n\n\tconstructor( ellipsoidRegion = new EllipsoidRegion(), color = 0xffff00 ) {\n\n\t\tsuper();\n\t\tthis.ellipsoidRegion = ellipsoidRegion;\n\t\tthis.material.color.set( color );\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = getRegionGeometry( this.ellipsoidRegion );\n\t\tthis.geometry.dispose();\n\t\tthis.geometry = new EdgesGeometry( geometry, 80 );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nexport class EllipsoidRegionHelper extends Mesh {\n\n\tconstructor( ellipsoidRegion = new EllipsoidRegion(), color = 0xffff00 ) {\n\n\t\tsuper();\n\t\tthis.ellipsoidRegion = ellipsoidRegion;\n\t\tthis.material.color.set( color );\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\t// dispose of the existing geometry\n\t\tthis.geometry.dispose();\n\n\t\t// retrieve the relevant fields\n\t\tconst geometry = getRegionGeometry( this.ellipsoidRegion, { computeNormals: true } );\n\t\tconst { lonStart, lonEnd } = this;\n\n\t\t// exclude the side tris if the region wraps around\n\t\tif ( lonEnd - lonStart >= 2 * Math.PI ) {\n\n\t\t\tgeometry.groups.splice( 2, 2 );\n\t\t\tthis.geometry = toGroupGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tthis.geometry = geometry;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n","import { Box3Helper, Group, MeshStandardMaterial, PointsMaterial, Sphere, Color, MeshBasicMaterial } from 'three';\nimport { SphereHelper } from './objects/SphereHelper.js';\nimport { EllipsoidRegionLineHelper } from './objects/EllipsoidRegionHelper.js';\nimport { TraversalUtils } from '3d-tiles-renderer/core';\n\nconst ORIGINAL_MATERIAL = Symbol( 'ORIGINAL_MATERIAL' );\nconst HAS_RANDOM_COLOR = Symbol( 'HAS_RANDOM_COLOR' );\nconst HAS_RANDOM_NODE_COLOR = Symbol( 'HAS_RANDOM_NODE_COLOR' );\nconst LOAD_TIME = Symbol( 'LOAD_TIME' );\nconst PARENT_BOUND_REF_COUNT = Symbol( 'PARENT_BOUND_REF_COUNT' );\n\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst emptyRaycast = () => {};\nconst colors = {};\n\n// Return a consistent random color for an index\nfunction getIndexedRandomColor( index ) {\n\n\tif ( ! colors[ index ] ) {\n\n\t\tconst h = Math.random();\n\t\tconst s = 0.5 + Math.random() * 0.5;\n\t\tconst l = 0.375 + Math.random() * 0.25;\n\n\t\tcolors[ index ] = new Color().setHSL( h, s, l );\n\n\t}\n\treturn colors[ index ];\n\n}\n\n// color modes\nconst NONE = 0;\nconst SCREEN_ERROR = 1;\nconst GEOMETRIC_ERROR = 2;\nconst DISTANCE = 3;\nconst DEPTH = 4;\nconst RELATIVE_DEPTH = 5;\nconst IS_LEAF = 6;\nconst RANDOM_COLOR = 7;\nconst RANDOM_NODE_COLOR = 8;\nconst CUSTOM_COLOR = 9;\nconst LOAD_ORDER = 10;\n\nconst ColorModes = Object.freeze( {\n\tNONE,\n\tSCREEN_ERROR,\n\tGEOMETRIC_ERROR,\n\tDISTANCE,\n\tDEPTH,\n\tRELATIVE_DEPTH,\n\tIS_LEAF,\n\tRANDOM_COLOR,\n\tRANDOM_NODE_COLOR,\n\tCUSTOM_COLOR,\n\tLOAD_ORDER,\n} );\n\nexport class DebugTilesPlugin {\n\n\tstatic get ColorModes() {\n\n\t\treturn ColorModes;\n\n\t}\n\n\tget unlit() {\n\n\t\treturn this._unlit;\n\n\t}\n\n\tset unlit( v ) {\n\n\t\tif ( v !== this._unlit ) {\n\n\t\t\tthis._unlit = v;\n\t\t\tthis.materialsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tget colorMode() {\n\n\t\treturn this._colorMode;\n\n\t}\n\n\tset colorMode( v ) {\n\n\t\tif ( v !== this._colorMode ) {\n\n\t\t\tthis._colorMode = v;\n\t\t\tthis.materialsNeedUpdate = true;\n\n\t\t}\n\n\t}\n\n\tget enabled() {\n\n\t\treturn this._enabled;\n\n\t}\n\n\tset enabled( v ) {\n\n\t\tif ( v !== this._enabled && this.tiles !== null ) {\n\n\t\t\tif ( v ) {\n\n\t\t\t\tthis.init( this.tiles );\n\n\t\t\t} else {\n\n\t\t\t\tthis.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._enabled = v;\n\n\t}\n\n\tget displayParentBounds() {\n\n\t\treturn this._displayParentBounds;\n\n\t}\n\n\tset displayParentBounds( v ) {\n\n\t\tif ( this._displayParentBounds !== v ) {\n\n\t\t\tthis._displayParentBounds = v;\n\n\t\t\tif ( ! v ) {\n\n\t\t\t\t// Reset all ref counts\n\t\t\t\tthis.tiles.traverse( tile => {\n\n\t\t\t\t\ttile[ PARENT_BOUND_REF_COUNT ] = null;\n\t\t\t\t\tthis._onTileVisibilityChange( tile, tile.__visible );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t// Initialize ref count for existing tiles\n\t\t\t\tthis.tiles.traverse( tile => {\n\n\t\t\t\t\tif ( tile.__visible ) {\n\n\t\t\t\t\t\tthis._onTileVisibilityChange( tile, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconstructor( options ) {\n\n\t\toptions = {\n\t\t\tdisplayParentBounds: false,\n\t\t\tdisplayBoxBounds: false,\n\t\t\tdisplaySphereBounds: false,\n\t\t\tdisplayRegionBounds: false,\n\t\t\tcolorMode: NONE,\n\t\t\tmaxDebugDepth: - 1,\n\t\t\tmaxDebugDistance: - 1,\n\t\t\tmaxDebugError: - 1,\n\t\t\tcustomColorCallback: null,\n\t\t\tunlit: false,\n\t\t\tenabled: true,\n\t\t\t...options,\n\t\t};\n\n\t\tthis.name = 'DEBUG_TILES_PLUGIN';\n\t\tthis.tiles = null;\n\n\t\tthis._colorMode = null;\n\t\tthis._unlit = null;\n\t\tthis.materialsNeedUpdate = false;\n\n\t\tthis.extremeDebugDepth = - 1;\n\t\tthis.extremeDebugError = - 1;\n\t\tthis.boxGroup = null;\n\t\tthis.sphereGroup = null;\n\t\tthis.regionGroup = null;\n\n\t\t// options\n\t\tthis._enabled = options.enabled;\n\t\tthis._displayParentBounds = options.displayParentBounds;\n\t\tthis.displayBoxBounds = options.displayBoxBounds;\n\t\tthis.displaySphereBounds = options.displaySphereBounds;\n\t\tthis.displayRegionBounds = options.displayRegionBounds;\n\t\tthis.colorMode = options.colorMode;\n\t\tthis.maxDebugDepth = options.maxDebugDepth;\n\t\tthis.maxDebugDistance = options.maxDebugDistance;\n\t\tthis.maxDebugError = options.maxDebugError;\n\t\tthis.customColorCallback = options.customColorCallback;\n\t\tthis.unlit = options.unlit;\n\n\t\tthis.getDebugColor = ( value, target ) => {\n\n\t\t\ttarget.setRGB( value, value, value );\n\n\t\t};\n\n\t}\n\n\t// initialize the groups for displaying helpers, register events, and initialize existing tiles\n\tinit( tiles ) {\n\n\t\tthis.tiles = tiles;\n\n\t\t// initialize groups\n\t\tconst tilesGroup = tiles.group;\n\t\tthis.boxGroup = new Group();\n\t\tthis.boxGroup.name = 'DebugTilesRenderer.boxGroup';\n\t\ttilesGroup.add( this.boxGroup );\n\t\tthis.boxGroup.updateMatrixWorld();\n\n\t\tthis.sphereGroup = new Group();\n\t\tthis.sphereGroup.name = 'DebugTilesRenderer.sphereGroup';\n\t\ttilesGroup.add( this.sphereGroup );\n\t\tthis.sphereGroup.updateMatrixWorld();\n\n\t\tthis.regionGroup = new Group();\n\t\tthis.regionGroup.name = 'DebugTilesRenderer.regionGroup';\n\t\ttilesGroup.add( this.regionGroup );\n\t\tthis.regionGroup.updateMatrixWorld();\n\n\t\t// register events\n\t\tthis._onLoadTileSetCB = () => {\n\n\t\t\tthis._initExtremes();\n\n\t\t};\n\n\t\tthis._onLoadModelCB = ( { scene, tile } ) => {\n\n\t\t\tthis._onLoadModel( scene, tile );\n\n\t\t};\n\n\t\tthis._onDisposeModelCB = ( { tile } ) => {\n\n\t\t\tthis._onDisposeModel( tile );\n\n\t\t};\n\n\t\tthis._onUpdateAfterCB = () => {\n\n\t\t\tthis._onUpdateAfter();\n\n\t\t};\n\n\t\tthis._onTileVisibilityChangeCB = ( { scene, tile, visible } ) => {\n\n\t\t\tthis._onTileVisibilityChange( tile, visible );\n\n\t\t};\n\n\t\ttiles.addEventListener( 'load-tile-set', this._onLoadTileSetCB );\n\t\ttiles.addEventListener( 'load-model', this._onLoadModelCB );\n\t\ttiles.addEventListener( 'dispose-model', this._onDisposeModelCB );\n\t\ttiles.addEventListener( 'update-after', this._onUpdateAfterCB );\n\t\ttiles.addEventListener( 'tile-visibility-change', this._onTileVisibilityChangeCB );\n\n\t\tthis._initExtremes();\n\n\t\t// initialize an already-loaded tiles\n\t\ttiles.traverse( tile => {\n\n\t\t\tif ( tile.cached.scene ) {\n\n\t\t\t\tthis._onLoadModel( tile.cached.scene, tile );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttiles.visibleTiles.forEach( tile => {\n\n\t\t\tthis._onTileVisibilityChange( tile, true );\n\n\t\t} );\n\n\t}\n\n\tgetTileInformationFromActiveObject( object ) {\n\n\t\t// Find which tile this scene is associated with. This is slow and\n\t\t// intended for debug purposes only.\n\t\tlet targetTile = null;\n\t\tconst activeTiles = this.tiles.activeTiles;\n\t\tactiveTiles.forEach( tile => {\n\n\t\t\tif ( targetTile ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tconst scene = tile.cached.scene;\n\t\t\tif ( scene ) {\n\n\t\t\t\tscene.traverse( c => {\n\n\t\t\t\t\tif ( c === object ) {\n\n\t\t\t\t\t\ttargetTile = tile;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( targetTile ) {\n\n\t\t\treturn {\n\n\t\t\t\tdistanceToCamera: targetTile.__distanceFromCamera,\n\t\t\t\tgeometricError: targetTile.geometricError,\n\t\t\t\tscreenSpaceError: targetTile.__error,\n\t\t\t\tdepth: targetTile.__depth,\n\t\t\t\tisLeaf: targetTile.__isLeaf\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t_initExtremes() {\n\n\t\tif ( ! ( this.tiles && this.tiles.root ) ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// initialize the extreme values of the hierarchy\n\t\tlet maxDepth = - 1;\n\t\tlet maxError = - 1;\n\n\t\t// Note that we are not using this.tiles.traverse()\n\t\t// as we don't want to pay the cost of preprocessing tiles.\n\t\tthis.tiles.traverse( null, ( tile, _, depth ) => {\n\n\t\t\tmaxDepth = Math.max( maxDepth, depth );\n\t\t\tmaxError = Math.max( maxError, tile.geometricError );\n\n\t\t}, false );\n\n\t\tthis.extremeDebugDepth = maxDepth;\n\t\tthis.extremeDebugError = maxError;\n\n\t}\n\n\t_onUpdateAfter() {\n\n\t\tconst { tiles, colorMode } = this;\n\n\t\tif ( ! tiles.root ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.materialsNeedUpdate ) {\n\n\t\t\ttiles.forEachLoadedModel( scene => {\n\n\t\t\t\tthis._updateMaterial( scene );\n\n\t\t\t} );\n\t\t\tthis.materialsNeedUpdate = false;\n\n\t\t}\n\n\t\t// set box or sphere visibility\n\t\tthis.boxGroup.visible = this.displayBoxBounds;\n\t\tthis.sphereGroup.visible = this.displaySphereBounds;\n\t\tthis.regionGroup.visible = this.displayRegionBounds;\n\n\t\t// get max values to use for materials\n\t\tlet maxDepth = - 1;\n\t\tif ( this.maxDebugDepth === - 1 ) {\n\n\t\t\tmaxDepth = this.extremeDebugDepth;\n\n\t\t} else {\n\n\t\t\tmaxDepth = this.maxDebugDepth;\n\n\t\t}\n\n\t\tlet maxError = - 1;\n\t\tif ( this.maxDebugError === - 1 ) {\n\n\t\t\tmaxError = this.extremeDebugError;\n\n\t\t} else {\n\n\t\t\tmaxError = this.maxDebugError;\n\n\t\t}\n\n\t\tlet maxDistance = - 1;\n\t\tif ( this.maxDebugDistance === - 1 ) {\n\n\t\t\ttiles.getBoundingSphere( _sphere );\n\t\t\tmaxDistance = _sphere.radius;\n\n\t\t} else {\n\n\t\t\tmaxDistance = this.maxDebugDistance;\n\n\t\t}\n\n\t\tconst { errorTarget, visibleTiles } = tiles;\n\t\tlet sortedTiles;\n\t\tif ( colorMode === LOAD_ORDER ) {\n\n\t\t\tsortedTiles = Array.from( visibleTiles ).sort( ( a, b ) => {\n\n\t\t\t\treturn a[ LOAD_TIME ] - b[ LOAD_TIME ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// update plugins\n\t\tvisibleTiles.forEach( tile => {\n\n\t\t\tconst scene = tile.cached.scene;\n\n\t\t\t// create a random color per-tile\n\t\t\tlet h, s, l;\n\t\t\tif ( colorMode === RANDOM_COLOR ) {\n\n\t\t\t\th = Math.random();\n\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t}\n\n\t\t\tscene.traverse( c => {\n\n\t\t\t\tif ( colorMode === RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\th = Math.random();\n\t\t\t\t\ts = 0.5 + Math.random() * 0.5;\n\t\t\t\t\tl = 0.375 + Math.random() * 0.25;\n\n\t\t\t\t}\n\n\t\t\t\tif ( c.material ) {\n\n\t\t\t\t\tif ( colorMode !== RANDOM_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( colorMode !== RANDOM_NODE_COLOR ) {\n\n\t\t\t\t\t\tdelete c.material[ HAS_RANDOM_NODE_COLOR ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the color on the basic material\n\t\t\t\t\tswitch ( colorMode ) {\n\n\t\t\t\t\t\tcase DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depth / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RELATIVE_DEPTH: {\n\n\t\t\t\t\t\t\tconst val = tile.__depthFromRenderedParent / maxDepth;\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase SCREEN_ERROR: {\n\n\t\t\t\t\t\t\tconst val = tile.__error / errorTarget;\n\t\t\t\t\t\t\tif ( val > 1.0 ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setRGB( 1.0, 0.0, 0.0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase GEOMETRIC_ERROR: {\n\n\t\t\t\t\t\t\tconst val = Math.min( tile.geometricError / maxError, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase DISTANCE: {\n\n\t\t\t\t\t\t\t// We don't update the distance if the geometric error is 0.0 so\n\t\t\t\t\t\t\t// it will always be black.\n\t\t\t\t\t\t\tconst val = Math.min( tile.__distanceFromCamera / maxDistance, 1 );\n\t\t\t\t\t\t\tthis.getDebugColor( val, c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase IS_LEAF: {\n\n\t\t\t\t\t\t\tif ( ! tile.children || tile.children.length === 0 ) {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 1.0, c.material.color );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis.getDebugColor( 0.0, c.material.color );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RANDOM_NODE_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_NODE_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_NODE_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RANDOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( ! c.material[ HAS_RANDOM_COLOR ] ) {\n\n\t\t\t\t\t\t\t\tc.material.color.setHSL( h, s, l );\n\t\t\t\t\t\t\t\tc.material[ HAS_RANDOM_COLOR ] = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase CUSTOM_COLOR: {\n\n\t\t\t\t\t\t\tif ( this.customColorCallback ) {\n\n\t\t\t\t\t\t\t\tthis.customColorCallback( tile, c );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'DebugTilesRenderer: customColorCallback not defined' );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase LOAD_ORDER: {\n\n\t\t\t\t\t\t\tconst value = sortedTiles.indexOf( tile );\n\t\t\t\t\t\t\tthis.getDebugColor( value / ( sortedTiles.length - 1 ), c.material.color );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t_onTileVisibilityChange( tile, visible ) {\n\n\t\tif ( this.displayParentBounds ) {\n\n\t\t\tTraversalUtils.traverseAncestors( tile, current => {\n\n\t\t\t\tif ( current[ PARENT_BOUND_REF_COUNT ] == null ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( visible ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] ++;\n\n\t\t\t\t} else if ( current[ PARENT_BOUND_REF_COUNT ] > 0 ) {\n\n\t\t\t\t\tcurrent[ PARENT_BOUND_REF_COUNT ] --;\n\n\t\t\t\t}\n\n\t\t\t\tconst tileVisible = ( current === tile && visible ) || ( this.displayParentBounds && current[ PARENT_BOUND_REF_COUNT ] > 0 );\n\n\t\t\t\tthis._updateBoundHelper( current, tileVisible );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tthis._updateBoundHelper( tile, visible );\n\n\t\t}\n\n\t}\n\n\t_createBoundHelper( tile ) {\n\n\t\tconst tiles = this.tiles;\n\t\tconst cached = tile.cached;\n\t\tconst { sphere, obb, region } = cached.boundingVolume;\n\t\tif ( obb ) {\n\n\t\t\t// Create debug bounding box\n\t\t\t// In some cases the bounding box may have a scale of 0 in one dimension resulting\n\t\t\t// in the NaNs in an extracted rotation so we disable matrix updates instead.\n\t\t\tconst boxHelperGroup = new Group();\n\t\t\tboxHelperGroup.name = 'DebugTilesRenderer.boxHelperGroup';\n\t\t\tboxHelperGroup.matrix.copy( obb.transform );\n\t\t\tboxHelperGroup.matrixAutoUpdate = false;\n\n\t\t\tconst boxHelper = new Box3Helper( obb.box, getIndexedRandomColor( tile.__depth ) );\n\t\t\tboxHelper.raycast = emptyRaycast;\n\t\t\tboxHelperGroup.add( boxHelper );\n\n\t\t\tcached.boxHelperGroup = boxHelperGroup;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displayBoxBounds ) {\n\n\t\t\t\tthis.boxGroup.add( boxHelperGroup );\n\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sphere ) {\n\n\t\t\t// Create debug bounding sphere\n\t\t\tconst sphereHelper = new SphereHelper( sphere, getIndexedRandomColor( tile.__depth ) );\n\t\t\tsphereHelper.raycast = emptyRaycast;\n\t\t\tcached.sphereHelper = sphereHelper;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displaySphereBounds ) {\n\n\t\t\t\tthis.sphereGroup.add( sphereHelper );\n\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( region ) {\n\n\t\t\t// Create debug bounding region\n\t\t\tconst regionHelper = new EllipsoidRegionLineHelper( region, getIndexedRandomColor( tile.__depth ) );\n\t\t\tregionHelper.raycast = emptyRaycast;\n\n\t\t\t// recenter the geometry to avoid rendering artifacts\n\t\t\tconst sphere = new Sphere();\n\t\t\tregion.getBoundingSphere( sphere );\n\t\t\tregionHelper.position.copy( sphere.center );\n\n\t\t\tsphere.center.multiplyScalar( - 1 );\n\t\t\tregionHelper.geometry.translate( ...sphere.center );\n\n\t\t\tcached.regionHelper = regionHelper;\n\n\t\t\tif ( tiles.visibleTiles.has( tile ) && this.displayRegionBounds ) {\n\n\t\t\t\tthis.regionGroup.add( regionHelper );\n\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateHelperMaterial( tile, material ) {\n\n\t\tif ( tile.__visible || ! this.displayParentBounds ) {\n\n\t\t\tmaterial.opacity = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.opacity = 0.2;\n\n\t\t}\n\n\t\tconst transparent = material.transparent;\n\t\tmaterial.transparent = material.opacity < 1;\n\t\tif ( material.transparent !== transparent ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t_updateBoundHelper( tile, visible ) {\n\n\t\tconst cached = tile.cached;\n\n\t\tif ( ! cached ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst sphereGroup = this.sphereGroup;\n\t\tconst boxGroup = this.boxGroup;\n\t\tconst regionGroup = this.regionGroup;\n\n\t\tif ( visible && ( cached.boxHelperGroup == null && cached.sphereHelper == null && cached.regionHelper == null ) ) {\n\n\t\t\tthis._createBoundHelper( tile );\n\n\t\t}\n\n\t\tconst boxHelperGroup = cached.boxHelperGroup;\n\t\tconst sphereHelper = cached.sphereHelper;\n\t\tconst regionHelper = cached.regionHelper;\n\n\t\tif ( ! visible ) {\n\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.remove( boxHelperGroup );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.remove( sphereHelper );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.remove( regionHelper );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// TODO: consider updating the volumes based on the bounding regions here in case they've been changed\n\t\t\tif ( boxHelperGroup ) {\n\n\t\t\t\tboxGroup.add( boxHelperGroup );\n\t\t\t\tboxHelperGroup.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, boxHelperGroup.children[ 0 ].material );\n\n\t\t\t}\n\n\t\t\tif ( sphereHelper ) {\n\n\t\t\t\tsphereGroup.add( sphereHelper );\n\t\t\t\tsphereHelper.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, sphereHelper.material );\n\n\t\t\t}\n\n\t\t\tif ( regionHelper ) {\n\n\t\t\t\tregionGroup.add( regionHelper );\n\t\t\t\tregionHelper.updateMatrixWorld( true );\n\n\t\t\t\tthis._updateHelperMaterial( tile, regionHelper.material );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateMaterial( scene ) {\n\n\t\t// update the materials for debug rendering\n\t\tconst { colorMode, unlit } = this;\n\t\tscene.traverse( c => {\n\n\t\t\tif ( ! c.material ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst currMaterial = c.material;\n\t\t\tconst originalMaterial = c[ ORIGINAL_MATERIAL ];\n\n\t\t\t// dispose the previous material\n\t\t\tif ( currMaterial !== originalMaterial ) {\n\n\t\t\t\tcurrMaterial.dispose();\n\n\t\t\t}\n\n\t\t\t// assign the new material\n\t\t\tif ( colorMode !== NONE || unlit ) {\n\n\t\t\t\tif ( c.isPoints ) {\n\n\t\t\t\t\tconst pointsMaterial = new PointsMaterial();\n\t\t\t\t\tpointsMaterial.size = originalMaterial.size;\n\t\t\t\t\tpointsMaterial.sizeAttenuation = originalMaterial.sizeAttenuation;\n\t\t\t\t\tc.material = pointsMaterial;\n\n\t\t\t\t} else if ( unlit ) {\n\n\t\t\t\t\tc.material = new MeshBasicMaterial();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc.material = new MeshStandardMaterial();\n\t\t\t\t\tc.material.flatShading = true;\n\n\t\t\t\t}\n\n\t\t\t\t// if no debug rendering is happening then assign the material properties\n\t\t\t\tif ( colorMode === NONE ) {\n\n\t\t\t\t\tc.material.map = originalMaterial.map;\n\t\t\t\t\tc.material.color.set( originalMaterial.color );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tc.material = originalMaterial;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t_onLoadModel( scene, tile ) {\n\n\t\ttile[ LOAD_TIME ] = performance.now();\n\n\t\t// Cache the original materials\n\t\tscene.traverse( c => {\n\n\t\t\tconst material = c.material;\n\t\t\tif ( material ) {\n\n\t\t\t\tc[ ORIGINAL_MATERIAL ] = material;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Update the materials to align with the settings\n\t\tthis._updateMaterial( scene );\n\n\t}\n\n\t_onDisposeModel( tile ) {\n\n\t\tconst cached = tile.cached;\n\t\tif ( cached.boxHelperGroup ) {\n\n\t\t\tcached.boxHelperGroup.children[ 0 ].geometry.dispose();\n\t\t\tdelete cached.boxHelperGroup;\n\n\t\t}\n\n\t\tif ( cached.sphereHelper ) {\n\n\t\t\tcached.sphereHelper.geometry.dispose();\n\t\t\tdelete cached.sphereHelper;\n\n\t\t}\n\n\t\tif ( cached.regionHelper ) {\n\n\t\t\tcached.regionHelper.geometry.dispose();\n\t\t\tdelete cached.regionHelper;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst tiles = this.tiles;\n\n\t\ttiles.removeEventListener( 'load-tile-set', this._onLoadTileSetCB );\n\t\ttiles.removeEventListener( 'load-model', this._onLoadModelCB );\n\t\ttiles.removeEventListener( 'dispose-model', this._onDisposeModelCB );\n\t\ttiles.removeEventListener( 'update-after', this._onUpdateAfterCB );\n\t\ttiles.removeEventListener( 'tile-visibility-change', this._onTileVisibilityChangeCB );\n\n\t\t// reset all materials\n\t\tthis.colorMode = NONE;\n\t\tthis.unlit = false;\n\t\ttiles.forEachLoadedModel( scene => {\n\n\t\t\tthis._updateMaterial( scene );\n\n\t\t} );\n\n\t\t// dispose of all helper objects\n\t\ttiles.traverse( tile => {\n\n\t\t\tthis._onDisposeModel( tile );\n\n\t\t} );\n\n\t\tthis.boxGroup?.removeFromParent();\n\t\tthis.sphereGroup?.removeFromParent();\n\t\tthis.regionGroup?.removeFromParent();\n\n\t}\n\n}\n","import { TiledImageSource } from './TiledImageSource.js';\n\nexport class DeepZoomImageSource extends TiledImageSource {\n\n\tconstructor( options = {} ) {\n\n\t\tconst { url = null, ...rest } = options;\n\t\tsuper( rest );\n\n\t\tthis.url = url;\n\t\tthis.format = null;\n\t\tthis.stem = null;\n\n\t}\n\n\tgetUrl( x, y, level ) {\n\n\t\treturn `${ this.stem }_files/${ level }/${ x }_${ y }.${ this.format }`;\n\n\t}\n\n\tinit() {\n\n\t\tconst { url } = this;\n\n\t\t// If implementing DeepZoom with limitations like a fixed orthographic camera perspective then\n\t\t// the target tile level can be immediately 'jumped' to for the entire image and in-view tiles\n\t\t// can be immediately queried without any hierarchy traversal. Due the flexibility of camera\n\t\t// type, rotation, and per-tile error calculation we generate a hierarchy.\n\t\treturn this\n\t\t\t.fetchData( url, this.fetchOptions )\n\t\t\t.then( res => res.text() )\n\t\t\t.then( text => {\n\n\t\t\t\tconst xml = new DOMParser().parseFromString( text, 'text/xml' );\n\t\t\t\tif ( xml.querySelector( 'DisplayRects' ) || xml.querySelector( 'Collection' ) ) {\n\n\t\t\t\t\tthrow new Error( 'DeepZoomImagesPlugin: DisplayRect and Collection DZI files not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\t// Elements\n\t\t\t\tconst image = xml.querySelector( 'Image' );\n\t\t\t\tconst size = image.querySelector( 'Size' );\n\n\t\t\t\t// Image properties\n\t\t\t\tconst width = parseInt( size.getAttribute( 'Width' ) );\n\t\t\t\tconst height = parseInt( size.getAttribute( 'Height' ) );\n\t\t\t\tconst tileSize = parseInt( image.getAttribute( 'TileSize' ) );\n\t\t\t\tconst overlap = parseInt( image.getAttribute( 'Overlap' ) );\n\t\t\t\tconst format = image.getAttribute( 'Format' );\n\n\t\t\t\t// Assign deep zoom properties\n\t\t\t\tthis.format = format;\n\t\t\t\tthis.stem = url.split( /\\.[^.]+$/g )[ 0 ];\n\n\t\t\t\t// Assign tiling properties\n\t\t\t\tconst { tiling } = this;\n\t\t\t\tconst levels = Math.ceil( Math.log2( Math.max( width, height ) ) ) + 1;\n\t\t\t\ttiling.flipY = true;\n\t\t\t\ttiling.pixelOverlap = overlap;\n\t\t\t\ttiling.generateLevels( levels, 1, 1, {\n\t\t\t\t\ttilePixelWidth: tileSize,\n\t\t\t\t\ttilePixelHeight: tileSize,\n\t\t\t\t\tpixelWidth: width,\n\t\t\t\t\tpixelHeight: height,\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t}\n\n}\n","import { ImageFormatPlugin } from './ImageFormatPlugin.js';\nimport { DeepZoomImageSource } from './sources/DeepZoomImageSource.js';\n\n// Support for Deep Zoom Image format\n// https://openseadragon.github.io/\n\n// https://learn.microsoft.com/en-us/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc645077(v=vs.95)\nexport class DeepZoomImagePlugin extends ImageFormatPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst { url, ...rest } = options;\n\t\tsuper( rest );\n\n\t\tthis.name = 'DZI_TILES_PLUGIN';\n\t\tthis.imageSource = new DeepZoomImageSource( { url } );\n\n\t}\n\n}\n","import { WGS84_RADIUS, LoaderBase } from '3d-tiles-renderer/core';\nimport { ProjectionScheme } from '../images/utils/ProjectionScheme.js';\nimport { MathUtils } from 'three';\n\nconst EQUATOR_CIRCUMFERENCE = WGS84_RADIUS * Math.PI * 2;\nconst mercatorProjection = /* @__PURE__ */ new ProjectionScheme( 'EPSG:3857' );\n\nfunction isEPSG4326( crs ) {\n\n\treturn /:4326$/i.test( crs );\n\n}\n\nfunction isWebMercator( crs ) {\n\n\treturn /:3857$/i.test( crs );\n\n}\n\n// parse a series of space-separated numbers\nfunction parseTuple( tuple ) {\n\n\treturn tuple.trim().split( /\\s+/ ).map( v => parseFloat( v ) );\n\n}\n\n// swap the tuple order to lon, lat if crs is EPSG:4326 since the tiles renderer project\n// expects lon, lat order\nfunction correctTupleOrder( tuple, crs ) {\n\n\tif ( isEPSG4326( crs ) ) {\n\n\t\t[ tuple[ 1 ], tuple[ 0 ] ] = [ tuple[ 0 ], tuple[ 1 ] ];\n\n\t}\n\n}\n\n// web mercator specifies bounding boxes etc as meters assuming the width and height of the full image span\n// is aligned to the globe equator circumference.\nfunction correctTupleUnits( tuple, crs ) {\n\n\tif ( isWebMercator( crs ) ) {\n\n\t\ttuple[ 0 ] = mercatorProjection.convertProjectionToLongitude( 0.5 + tuple[ 0 ] / EQUATOR_CIRCUMFERENCE );\n\t\ttuple[ 1 ] = mercatorProjection.convertProjectionToLatitude( 0.5 + tuple[ 1 ] / EQUATOR_CIRCUMFERENCE );\n\n\t\t// to degrees\n\t\ttuple[ 0 ] *= MathUtils.RAD2DEG;\n\t\ttuple[ 1 ] *= MathUtils.RAD2DEG;\n\n\t\treturn tuple;\n\n\t}\n\n}\n\nfunction tupleToRadians( tuple ) {\n\n\ttuple[ 0 ] *= MathUtils.DEG2RAD;\n\ttuple[ 1 ] *= MathUtils.DEG2RAD;\n\n}\n\nexport class WMTSCapabilitiesLoader extends LoaderBase {\n\n\tparse( buffer ) {\n\n\t\tconst str = new TextDecoder( 'utf-8' ).decode( new Uint8Array( buffer ) );\n\t\tconst xml = new DOMParser().parseFromString( str, 'text/xml' );\n\t\tconst contents = xml.querySelector( 'Contents' );\n\n\t\tconst tileMatrixSets = getChildrenByTag( contents, 'TileMatrixSet' ).map( el => parseTileMatrixSet( el ) );\n\t\tconst layers = getChildrenByTag( contents, 'Layer' ).map( el => parseLayer( el ) );\n\t\tconst serviceIdentification = parseServiceIdentification( xml.querySelector( 'ServiceIdentification' ) );\n\n\t\tlayers.forEach( layer => {\n\n\t\t\tlayer.tileMatrixSets = layer.tileMatrixSetLinks.map( key => {\n\n\t\t\t\treturn tileMatrixSets.find( tms => tms.identifier === key );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\treturn {\n\t\t\tserviceIdentification,\n\t\t\ttileMatrixSets,\n\t\t\tlayers,\n\t\t};\n\n\t}\n\n}\n\n// parse <ows:ServiceIdentification> tag\nfunction parseServiceIdentification( el ) {\n\n\tconst title = el.querySelector( 'Title' ).textContent;\n\tconst abstract = el.querySelector( 'Abstract' )?.textContent || '';\n\tconst serviceType = el.querySelector( 'ServiceType' ).textContent;\n\tconst serviceTypeVersion = el.querySelector( 'ServiceTypeVersion' ).textContent;\n\n\treturn {\n\t\ttitle,\n\t\tabstract,\n\t\tserviceType,\n\t\tserviceTypeVersion,\n\t};\n\n}\n\n// parse <Layers> tag\nfunction parseLayer( el ) {\n\n\tconst title = el.querySelector( 'Title' ).textContent;\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst format = el.querySelector( 'Format' ).textContent;\n\tconst resourceUrls = getChildrenByTag( el, 'ResourceURL' ).map( el => {\n\n\t\treturn parseResourceUrl( el );\n\n\t} );\n\tconst tileMatrixSetLinks = getChildrenByTag( el, 'TileMatrixSetLink' ).map( el => {\n\n\t\treturn getChildrenByTag( el, 'TileMatrixSet' )[ 0 ].textContent;\n\n\t} );\n\tconst styles = getChildrenByTag( el, 'Style' ).map( el => {\n\n\t\treturn parseStyle( el );\n\n\t} );\n\tconst dimensions = getChildrenByTag( el, 'Dimension' ).map( el => {\n\n\t\treturn parseDimension( el );\n\n\t} );\n\n\tlet boundingBox = parseBoundingBox( el.querySelector( 'WGS84BoundingBox' ) );\n\tif ( ! boundingBox ) {\n\n\t\tboundingBox = parseBoundingBox( el.querySelector( 'BoundingBox' ) );\n\n\t}\n\n\treturn {\n\t\ttitle,\n\t\tidentifier,\n\t\tformat,\n\t\tdimensions,\n\t\ttileMatrixSetLinks,\n\t\tstyles,\n\t\tboundingBox,\n\t\tresourceUrls,\n\t};\n\n}\n\n// parse layer <ResourceURL> tag\nfunction parseResourceUrl( el ) {\n\n\tconst template = el.getAttribute( 'template' );\n\tconst format = el.getAttribute( 'format' );\n\tconst resourceType = el.getAttribute( 'resourceType' );\n\n\treturn {\n\t\ttemplate,\n\t\tformat,\n\t\tresourceType,\n\t};\n\n}\n\n// parse layer <Dimension> tag\nfunction parseDimension( el ) {\n\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst uom = el.querySelector( 'UOM' )?.textContent || '';\n\tconst defaultValue = el.querySelector( 'Default' ).textContent;\n\tconst current = el.querySelector( 'Current' )?.textContent === 'true';\n\tconst values = getChildrenByTag( el, 'Value' ).map( el => el.textContent );\n\treturn {\n\t\tidentifier,\n\t\tuom,\n\t\tdefaultValue,\n\t\tcurrent,\n\t\tvalues,\n\t};\n\n}\n\n// parse <ows:WGS84BoundingBox> and <BoundingBox> tags\nfunction parseBoundingBox( el ) {\n\n\tif ( ! el ) {\n\n\t\treturn null;\n\n\t}\n\n\tconst crs = el.nodeName.endsWith( 'WGS84BoundingBox' ) ? 'urn:ogc:def:crs:CRS::84' : el.getAttribute( 'crs' );\n\tconst lowerCorner = parseTuple( el.querySelector( 'LowerCorner' ).textContent );\n\tconst upperCorner = parseTuple( el.querySelector( 'UpperCorner' ).textContent );\n\n\tcorrectTupleOrder( lowerCorner, crs );\n\tcorrectTupleOrder( upperCorner, crs );\n\n\tcorrectTupleUnits( lowerCorner, crs );\n\tcorrectTupleUnits( upperCorner, crs );\n\n\ttupleToRadians( lowerCorner );\n\ttupleToRadians( upperCorner );\n\n\treturn {\n\t\tcrs,\n\t\tlowerCorner,\n\t\tupperCorner,\n\t\tbounds: [ ...lowerCorner, ...upperCorner ],\n\t};\n\n}\n\n// parse layer <Style> tag\nfunction parseStyle( el ) {\n\n\tconst title = el.querySelector( 'Title' )?.textContent || null;\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst isDefault = el.getAttribute( 'isDefault' ) === 'true';\n\n\treturn {\n\t\ttitle,\n\t\tidentifier,\n\t\tisDefault,\n\t};\n\n}\n\n// parse <TileMatrixSet> tag\nfunction parseTileMatrixSet( el ) {\n\n\tconst supportedCRS = el.querySelector( 'SupportedCRS' ).textContent;\n\tconst title = el.querySelector( 'Title' )?.textContent || '';\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst abstract = el.querySelector( 'Abstract' )?.textContent || '';\n\tconst tileMatrices = [];\n\tel\n\t\t.querySelectorAll( 'TileMatrix' )\n\t\t.forEach( ( el, i ) => {\n\n\t\t\tconst tm = parseTileMatrix( el );\n\n\t\t\tconst pixelSpan = 0.00028 * tm.scaleDenominator;\n\t\t\tconst groundWidth = tm.tileWidth * tm.matrixWidth * pixelSpan;\n\t\t\tconst groundHeight = tm.tileHeight * tm.matrixHeight * pixelSpan;\n\t\t\tlet bottomRightCorner;\n\n\t\t\tcorrectTupleOrder( tm.topLeftCorner, supportedCRS );\n\n\t\t\tif ( isWebMercator( supportedCRS ) ) {\n\n\t\t\t\tbottomRightCorner = [\n\t\t\t\t\ttm.topLeftCorner[ 0 ] + groundWidth,\n\t\t\t\t\ttm.topLeftCorner[ 1 ] - groundHeight,\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\tbottomRightCorner = [\n\t\t\t\t\ttm.topLeftCorner[ 0 ] + 360 * groundWidth / EQUATOR_CIRCUMFERENCE,\n\t\t\t\t\ttm.topLeftCorner[ 1 ] - 360 * groundHeight / EQUATOR_CIRCUMFERENCE,\n\t\t\t\t];\n\n\t\t\t}\n\n\t\t\tcorrectTupleUnits( bottomRightCorner, supportedCRS );\n\t\t\tcorrectTupleUnits( tm.topLeftCorner, supportedCRS );\n\n\t\t\ttupleToRadians( bottomRightCorner );\n\t\t\ttupleToRadians( tm.topLeftCorner );\n\n\t\t\t// construct the bounds\n\t\t\ttm.bounds = [ ...tm.topLeftCorner, ...bottomRightCorner ];\n\n\t\t\t// ensure min and max order is correct\n\t\t\t[ tm.bounds[ 1 ], tm.bounds[ 3 ] ] = [ tm.bounds[ 3 ], tm.bounds[ 1 ] ];\n\n\t\t\ttileMatrices.push( tm );\n\n\t\t} );\n\n\treturn {\n\t\ttitle,\n\t\tidentifier,\n\t\tabstract,\n\t\tsupportedCRS,\n\t\ttileMatrices,\n\t};\n\n}\n\n// parse tile matrix set <TileMatrix> tag\nfunction parseTileMatrix( el ) {\n\n\tconst identifier = el.querySelector( 'Identifier' ).textContent;\n\tconst tileWidth = parseFloat( el.querySelector( 'TileWidth' ).textContent );\n\tconst tileHeight = parseFloat( el.querySelector( 'TileHeight' ).textContent );\n\tconst matrixWidth = parseFloat( el.querySelector( 'MatrixWidth' ).textContent );\n\tconst matrixHeight = parseFloat( el.querySelector( 'MatrixHeight' ).textContent );\n\tconst scaleDenominator = parseFloat( el.querySelector( 'ScaleDenominator' ).textContent );\n\tconst topLeftCorner = parseTuple( el.querySelector( 'TopLeftCorner' ).textContent );\n\n\treturn {\n\t\tidentifier,\n\t\ttileWidth,\n\t\ttileHeight,\n\t\tmatrixWidth,\n\t\tmatrixHeight,\n\t\tscaleDenominator,\n\t\ttopLeftCorner,\n\t\tbounds: null,\n\t};\n\n}\n\n// utility for finding immediate children by tag name\nfunction getChildrenByTag( el, tag ) {\n\n\treturn [ ...el.children ].filter( c => c.tagName === tag );\n\n}\n","import { LoaderBase, WGS84_RADIUS } from '3d-tiles-renderer/core';\nimport { ProjectionScheme } from '../images/utils/ProjectionScheme';\nimport { MathUtils } from 'three';\n\nconst EQUATOR_CIRCUMFERENCE = WGS84_RADIUS * Math.PI * 2;\nconst mercatorProjection = /* @__PURE__ */ new ProjectionScheme( 'EPSG:3857' );\n\n// helper CRS checks (same logic used in WMTSCapabilitiesLoader)\n// TODO: Share these helpers with the WMTSCapabilitiesLoader\nfunction isEPSG4326( crs ) {\n\n\treturn /:4326$/i.test( crs );\n\n}\n\nfunction isWebMercator( crs ) {\n\n\treturn /:3857$/i.test( crs );\n\n}\n\n// convert from meters (web mercator) to degrees using the mercator projection helper\nfunction correctTupleUnits( tuple, crs ) {\n\n\t// TODO: consolidate this Mercator-units with WMTSLoader / move a helper onto ProjectionScheme?\n\tif ( isWebMercator( crs ) ) {\n\n\t\ttuple[ 0 ] = mercatorProjection.convertProjectionToLongitude( 0.5 + tuple[ 0 ] / ( Math.PI * 2 * EQUATOR_CIRCUMFERENCE ) );\n\t\ttuple[ 1 ] = mercatorProjection.convertProjectionToLatitude( 0.5 + tuple[ 1 ] / ( Math.PI * 2 * EQUATOR_CIRCUMFERENCE ) );\n\n\t\t// to degrees\n\t\ttuple[ 0 ] *= MathUtils.RAD2DEG;\n\t\ttuple[ 1 ] *= MathUtils.RAD2DEG;\n\n\t}\n\n\treturn tuple;\n\n}\n\n// swap order when CRS is EPSG:4326 (WMS 1.3 axis order)\nfunction correctTupleOrder( tuple, crs, version ) {\n\n\t// Before WMS 1.3.0 the latitude, longitude order for EPSG:4326 was declared to be in reverse and has\n\t// been fixed in later versions. Correct the tuple order for consistency if loading a file from a prior version.\n\t// See https://gis.stackexchange.com/questions/23347/getmap-wms-1-1-1-vs-1-3-0\n\tconst [ major, minor ] = version.split( '.' ).map( v => parseInt( v ) );\n\tconst shouldFixTupleOrder = major === 1 && minor < 3 || major < 1;\n\tif ( isEPSG4326( crs ) && shouldFixTupleOrder ) {\n\n\t\t[ tuple[ 0 ], tuple[ 1 ] ] = [ tuple[ 1 ], tuple[ 0 ] ];\n\n\t}\n\n}\n\n// convert degrees to radians in-place\nfunction tupleToRadians( tuple ) {\n\n\ttuple[ 0 ] *= MathUtils.DEG2RAD;\n\ttuple[ 1 ] *= MathUtils.DEG2RAD;\n\n}\n\n// parse \"BoundingBox\" tag for WMS using same normalization as WMTS (lower/upper corners, unit & order correction)\nfunction parseBoundingBox( el, version ) {\n\n\tif ( ! el ) {\n\n\t\treturn null;\n\n\t}\n\n\t// WMS may use CRS / crs / SRS attribute\n\tconst crs = el.getAttribute( 'CRS' ) || el.getAttribute( 'crs' ) || el.getAttribute( 'SRS' ) || '';\n\n\tconst minx = parseFloat( el.getAttribute( 'minx' ) );\n\tconst miny = parseFloat( el.getAttribute( 'miny' ) );\n\tconst maxx = parseFloat( el.getAttribute( 'maxx' ) );\n\tconst maxy = parseFloat( el.getAttribute( 'maxy' ) );\n\n\tconst lowerCorner = [ minx, miny ];\n\tconst upperCorner = [ maxx, maxy ];\n\n\tcorrectTupleOrder( lowerCorner, crs, version );\n\tcorrectTupleOrder( upperCorner, crs, version );\n\n\t// correct units if web mercator meters were provided\n\tcorrectTupleUnits( lowerCorner, crs );\n\tcorrectTupleUnits( upperCorner, crs );\n\n\t// convert degrees to radians for internal consistency with other loaders\n\ttupleToRadians( lowerCorner );\n\ttupleToRadians( upperCorner );\n\n\t// bounds in order [minLon, minLat, maxLon, maxLat] (in radians)\n\treturn { crs, bounds: [ ...lowerCorner, ...upperCorner ] };\n\n}\n\n// EX_GeographicBoundingBox (>= 1.3.0) and LatLonBoundingBox (<= 1.1.1) define the bounds of content\nfunction parseEXGeographicBoundingBox( el ) {\n\n\tconst west = parseFloat( el.querySelector( 'westBoundLongitude' ).textContent );\n\tconst east = parseFloat( el.querySelector( 'eastBoundLongitude' ).textContent );\n\tconst south = parseFloat( el.querySelector( 'southBoundLatitude' ).textContent );\n\tconst north = parseFloat( el.querySelector( 'northBoundLatitude' ).textContent );\n\n\tconst lowerCorner = [ west, south ];\n\tconst upperCorner = [ east, north ];\n\n\ttupleToRadians( lowerCorner );\n\ttupleToRadians( upperCorner );\n\n\treturn [ ...lowerCorner, ...upperCorner ];\n\n}\n\nfunction parseLatLonBoundingBox( el ) {\n\n\tconst west = parseFloat( el.getAttribute( 'minx' ).textContent );\n\tconst east = parseFloat( el.getAttribute( 'maxx' ).textContent );\n\tconst south = parseFloat( el.getAttribute( 'miny' ).textContent );\n\tconst north = parseFloat( el.getAttribute( 'maxy' ).textContent );\n\n\tconst lowerCorner = [ west, south ];\n\tconst upperCorner = [ east, north ];\n\n\ttupleToRadians( lowerCorner );\n\ttupleToRadians( upperCorner );\n\n\treturn [ ...lowerCorner, ...upperCorner ];\n\n}\n\n// Parse the \"Style\" tag along with the associated legend elements\nfunction parseStyle( el ) {\n\n\tconst name = el.querySelector( 'Name' ).textContent;\n\tconst title = el.querySelector( 'Title' ).textContent;\n\tconst legends = [ ...el.querySelectorAll( 'LegendURL' ) ].map( legendEl => {\n\n\t\t// width/height attrs on LegendURL\n\t\tconst width = parseInt( legendEl.getAttribute( 'width' ) );\n\t\tconst height = parseInt( legendEl.getAttribute( 'height' ) );\n\n\t\t// collect Format elements inside LegendURL\n\t\tconst format = legendEl.querySelector( 'Format' ).textContent;\n\n\t\t// OnlineResource may use xlink namespace\n\t\tconst online = legendEl.querySelector( 'OnlineResource' );\n\t\tconst url = readOnlineResourceHref( online );\n\n\t\treturn {\n\t\t\twidth,\n\t\t\theight,\n\t\t\tformat,\n\t\t\turl,\n\t\t};\n\n\t} );\n\n\treturn {\n\t\tname,\n\t\ttitle,\n\t\tlegends,\n\t};\n\n}\n\n// Parse a <Layer> element in addition to the child layers\nfunction parseLayer( el, version, inheritedProperties = {} ) {\n\n\t// TODO:\n\t// - Dimension\n\t// - Attribution\n\t// - AuthorityURL\n\t// - MinScaleDenominator\n\t// - MaxScaleDenominator\n\t// - cascaded, noSubsets, fixedWidth, fixedHeight attributes\n\n\tlet {\n\t\tstyles = [],\n\t\tcrs = [],\n\t\tcontentBoundingBox = null,\n\t\tqueryable = false,\n\t\topaque = false,\n\t} = inheritedProperties;\n\n\tconst name = el.querySelector( ':scope > Name' )?.textContent || null;\n\tconst title = el.querySelector( ':scope > Title' )?.textContent || '';\n\tconst abstract = el.querySelector( ':scope > Abstract' )?.textContent || '';\n\tconst keywords = [ ...el.querySelectorAll( ':scope > Keyword' ) ].map( k => k.textContent );\n\tconst boundingBoxEl = [ ...el.querySelectorAll( ':scope > BoundingBox' ) ];\n\tconst boundingBoxes = boundingBoxEl.map( el => parseBoundingBox( el, version ) );\n\n\t// See section 7.2.4.8 in the specification\n\t// Handle added inherited properties\n\tcrs = [\n\t\t...crs,\n\t\t...Array.from( el.querySelectorAll( 'CRS' ) ).map( c => c.textContent ),\n\t];\n\tstyles = [\n\t\t...styles,\n\t\t...Array.from( el.querySelectorAll( ':scope > Style' ) ).map( el => parseStyle( el ) ),\n\t];\n\n\t// Handle replaced inherited properties\n\tif ( el.hasAttribute( 'queryable' ) ) {\n\n\t\tqueryable = el.getAttribute( 'queryable' ) === '1';\n\n\t}\n\n\tif ( el.hasAttribute( 'opaque' ) ) {\n\n\t\topaque = el.getAttribute( 'opaque' ) === '1';\n\n\t}\n\n\t// These bounding boxes define the range of data present in the data set in a cartographic range\n\tif ( el.querySelector( 'EX_GeographicBoundingBox' ) ) {\n\n\t\tcontentBoundingBox = parseEXGeographicBoundingBox( el.querySelector( 'EX_GeographicBoundingBox' ) );\n\n\t} else if ( el.querySelector( 'LatLonBoundingBox' ) ) {\n\n\t\tcontentBoundingBox = parseLatLonBoundingBox( el.querySelector( 'LatLonBoundingBox' ) );\n\n\t}\n\n\t// Recursively parse sublayers\n\tconst subLayers = Array.from( el.querySelectorAll( ':scope > Layer' ) ).map( el => {\n\n\t\treturn parseLayer( el, version, {\n\t\t\t// add\n\t\t\tstyles,\n\t\t\tcrs,\n\n\t\t\t// replace\n\t\t\tcontentBoundingBox,\n\t\t\tqueryable,\n\t\t\topaque,\n\t\t} );\n\n\t} );\n\n\treturn {\n\t\tname,\n\t\ttitle,\n\t\tabstract,\n\t\tqueryable,\n\t\topaque,\n\t\tkeywords,\n\t\tcrs,\n\t\tboundingBoxes,\n\t\tcontentBoundingBox,\n\t\tstyles,\n\t\tsubLayers,\n\t};\n\n}\n\n// Parse the \"Service\" tag\nfunction parseService( el ) {\n\n\treturn {\n\t\tname: el.querySelector( 'Name' )?.textContent || '',\n\t\ttitle: el.querySelector( 'Title' )?.textContent || '',\n\t\tabstract: el.querySelector( 'Abstract' )?.textContent || '',\n\t\tkeywords: Array.from( el.querySelectorAll( 'Keyword' ) ).map( k => k.textContent ),\n\n\t\tmaxWidth: parseFloat( el.querySelector( 'MaxWidth' ) ) || null,\n\t\tmaxHeight: parseFloat( el.querySelector( 'MaxHeight' ) ) || null,\n\t\tlayerLimit: parseFloat( el.querySelector( 'LayerLimit' ) ) || null,\n\t};\n\n}\n\n// helper: read OnlineResource href (handles xlink namespace)\nfunction readOnlineResourceHref( el ) {\n\n\tif ( ! el ) {\n\n\t\treturn '';\n\n\t}\n\n\treturn (\n\t\tel.getAttribute( 'xlink:href' ) ||\n\t\tel.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) ||\n\t\t''\n\t).trim();\n\n}\n\n// parse a single operation (e.g. GetMap, GetCapabilities, GetFeatureInfo)\nfunction parseRequestOperation( opEl ) {\n\n\tconst formats = Array.from( opEl.querySelectorAll( 'Format' ) ).map( f => f.textContent.trim() );\n\tconst dcp = Array.from( opEl.querySelectorAll( 'DCPType' ) ).map( dcp => {\n\n\t\tconst httpEl = dcp.querySelector( 'HTTP' );\n\n\t\tconst getEl = httpEl.querySelector( 'Get OnlineResource' ) || httpEl.querySelector( 'Get > OnlineResource' ) || httpEl.querySelector( 'Get' );\n\t\tconst postEl = httpEl.querySelector( 'Post OnlineResource' ) || httpEl.querySelector( 'Post > OnlineResource' ) || httpEl.querySelector( 'Post' );\n\t\tconst getHref = readOnlineResourceHref( getEl );\n\t\tconst postHref = readOnlineResourceHref( postEl );\n\t\treturn { type: 'HTTP', get: getHref, post: postHref };\n\n\t} );\n\n\treturn { formats, dcp, href: dcp[ 0 ].get };\n\n}\n\n// parse the whole Request section, returning an object keyed by operation local name\nfunction parseRequest( el ) {\n\n\tconst ops = {};\n\tArray\n\t\t.from( el.querySelectorAll( ':scope > *' ) )\n\t\t.forEach( ( child ) => {\n\n\t\t\tconst requestType = child.localName;\n\t\t\tops[ requestType ] = parseRequestOperation( child );\n\n\t\t} );\n\treturn ops;\n\n}\n\n// Collect all sub layers with a valid name into a flat array for easier access\nfunction collectLayers( layers, target = [] ) {\n\n\tlayers.forEach( l => {\n\n\t\tif ( l.name !== null ) {\n\n\t\t\ttarget.push( l );\n\n\t\t}\n\n\t\tcollectLayers( l.subLayers, target );\n\n\t} );\n\n\treturn target;\n\n}\n\nexport class WMSCapabilitiesLoader extends LoaderBase {\n\n\tparse( buffer ) {\n\n\t\tconst str = new TextDecoder( 'utf-8' ).decode( new Uint8Array( buffer ) );\n\t\tconst xml = new DOMParser().parseFromString( str, 'text/xml' );\n\t\tconst rootEl = xml.querySelector( 'WMS_Capabilities' ) || xml.querySelector( 'WMT_MS_Capabilities' );\n\t\tconst version = rootEl.getAttribute( 'version' );\n\n\t\tconst capabilityEl = xml.querySelector( 'Capability' );\n\t\tconst service = parseService( xml.querySelector( ':scope > Service' ) );\n\t\tconst request = parseRequest( capabilityEl.querySelector( ':scope > Request' ) );\n\t\tconst rootLayers = Array.from( capabilityEl.querySelectorAll( ':scope > Layer' ) ).map( el => parseLayer( el, version ) );\n\t\tconst layers = collectLayers( rootLayers );\n\n\t\treturn { version, service, layers, request };\n\n\t}\n\n}\n"],"names":["GoogleAttributionsManager","line","add","creditsCount","tokens","l","t","a","b","countA","pair","TILES_3D_API","GoogleCloudAuthPlugin","apiToken","sessionOptions","autoRefreshToken","logoUrl","useRecommendedSettings","GoogleCloudAuth","tiles","auth","tile","visible","copyright","_b","_a","target","uri","options","_uv","Vector2","TILE_X","TILE_Y","TILE_LEVEL","ImageFormatPlugin","pixelSize","center","imageSource","url","plugin","buffer","extension","abortSignal","tx","ty","level","texture","sx","sy","x","y","z","boundingBox","geometry","PlaneGeometry","mesh","Mesh","MeshBasicMaterial","uvRange","uv","i","MathUtils","tiling","maxLevel","baseUrl","minLevel","tileCountX","tileCountY","children","child","tileset","pixelWidth","pixelHeight","minX","minY","maxX","maxY","extentsX","extentsY","centerX","centerY","levelWidth","levelHeight","geometricError","cx","cy","_v0","Vector3","_v1","getCartographicToMeterDerivative","ellipsoid","lat","lon","lonp","latp","dy","MIN_LON_VERTS","MIN_LAT_VERTS","_pos","_norm","_sphere","Sphere","EllipsoidProjectionTilesPlugin","shape","endCaps","rest","args","projection","west","south","east","north","latVerts","lonVerts","yVerts","xVerts","minU","minV","maxU","maxV","position","normal","vertCount","latLimit","vStep","prevLat","nextLat","u","v","isRoot","normalizedBounds","cartBounds","tilePixelWidth","tilePixelHeight","tileUWidth","tileVWidth","midLat","midV","lonFactor","latFactor","xDeriv","yDeriv","projectedPixelWidth","ProjectionScheme","scheme","ratio","mercatorN","value","yp","hash","DataCache","item","cache","data","key","abortController","info","res","e","force","disposeCallback","result","doBoundsIntersect","aMinX","aMinY","aMaxX","aMaxY","bMinX","bMinY","bMaxX","bMaxY","TilingScheme","levels","tileBounds","rootTileX","rootTileY","invLevel","levelPixelWidth","levelPixelHeight","bx","by","normalized","flipY","xStride","yStride","range","contentBounds","clampedMinX","clampedMinY","clampedMaxX","clampedMaxY","minTile","maxTile","minTileX","minTileY","maxTileX","maxTileY","rminx","rminy","rmaxx","rmaxy","tminx","tminy","tmaxx","tmaxy","bounds","fullMinU","fullMinV","fullMaxU","fullMaxV","clampToProjection","pixelOverlap","tileLeft","tileTop","tileRight","tileBottom","extents","invCenterY","normBounds","clampBounds","TiledImageSource","fetchOptions","blob","imageBitmap","Texture","SRGBColorSpace","tex","format","type","image","generateMipmaps","width","height","bytes","TextureUtils","signal","XYZImageSource","tileDimension","TMSImageSource","tileSets","text","xml","tileFormat","tileSetList","ts","tileWidth","tileHeight","srs","order","isCRS84","crs","WMTSImageSource","capabilities","layer","tileMatrixSet","style","dimensions","tms","supportedCRS","tm","matrixWidth","matrixHeight","dim","WMSImageSource","styles","contentBoundingBox","version","transparent","crsParam","bboxParam","minx","miny","maxx","maxy","params","XYZTilesPlugin","TMSTilesPlugin","WMTSTilesPlugin","WMSTilesPlugin","_tri","Triangle","_uvh","QuantizedMeshLoader","QuantizedMeshLoaderBase","manager","DefaultLoadingManager","Ellipsoid","solid","skirtLength","smoothSkirtNormals","minLat","maxLat","minLon","maxLon","header","indices","vertexData","edgeIndices","extensions","BufferGeometry","material","MeshStandardMaterial","includeNormals","vertexCount","positions","uvs","indexArr","normals","groupOffset","materialIndex","readUVHeight","readPosition","extNormals","indexOffset","westIndices","eastIndices","southIndices","northIndices","offset","westStrip","constructEdgeStrip","eastStrip","southStrip","northStrip","indexBuffer","BufferAttribute","mask","size","maskBuffer","map","DataTexture","RGFormat","UnsignedByteType","LinearMipMapLinearFilter","LinearFilter","index","h","heightOffset","topUvs","topPos","botUvs","botPos","sideIndices","triCount","t0","t1","b0","b1","total","botOffset","i3","nx","ny","nz","SPLIT_VALUE","vertNames","_vec","Vector4","_v2","GeometryClipper","ClipTrianglePool","callback","splitOperations","runPermutations","keepPositive","object","toRemove","c","m","trianglePool","attributeList","sourceGeometry","nextIndex","vertToNewIndexMap","start","count","i0","i1","i2","tri","triangles","s","barycoord","pushTriangle","attributes","sourceMesh","attr","cons","newAttr","keepNegative","edges","lerpValues","nv","pValue","npValue","tri0","tri1","tri2","minBound","negativeSide","ClipTriangle","vn","bc","name","readInterpolatedAttribute","hashVertex","arr","other","e0","e1","alpha","targetVertex","fromVertex","attribute","_cart","_pos0","_pos1","_pos2","_pos3","_temp","_temp2","_uv0","_uv1","_uv2","QuantizedMeshClipper","left","bottom","getUvSplitOperation","botResult","skirtResult","capGroup","capResult","pushVertex","pos","norm","capIndex","capUv","capPosition","capNormal","capTriangles","triOffset","ne","u0","u1","capLength","xUvOffset","yUvOffset","resultMesh","vertexIsClipped","posArr","uvArr","point","axis","TILE_AVAILABLE","INITIAL_HEIGHT_RANGE","isTileAvailable","available","availableSet","startX","startY","endX","endY","getMaxLevel","maxzoom","getMetadataAvailability","metadataAvailability","getTileHasMetadata","getContentUrl","QuantizedMeshPlugin","json","layerProjection","attribution","searchParams","clipper","loader","minHeight","maxHeight","metadata","isAvailable","region","hasChildren","CesiumIonAuthPlugin","assetId","CesiumIonAuth","error","att","_matrix","Matrix4","UpdateOnChangePlugin","camera","didCamerasChange","matrix","needsUpdate","compressAttribute","arrayType","minValue","array","newAttribute","itemSize","j","compressPositionAttribute","min","max","maxValue","bbMinValue","bbMaxValue","TileCompressionPlugin","scene","generateNormals","disableMipmaps","compressIndex","compressUvs","compressNormals","compressPosition","uvType","normalType","positionType","uv1","uv2","uv3","getField","def","isNumericType","isFloatComponentType","isVectorType","isMatrixType","readDataFromBufferToType","getTypeInstance","property","componentType","Matrix2","Matrix3","isTypeInstance","getArrayConstructorFromComponentType","resolveDefault","resolveDefaultElement","defaultValue","resolveNoData","noData","performResolution","isNoDataEqual","elements","normalizeValue","adjustValueScaleOffset","scale","adjustFromType","adjustMatrix","adjustVector","adjustScalar","initializeFromProperty","overrideCount","initializeFromClass","properties","prop","typeToComponentCount","ClassProperty","enums","accessorProperty","countOverride","enumSet","getEnumName","match","PropertySetAccessor","definition","classes","propertyClass","PropertyAttributeClassProperty","classProperty","attributeProperty","PropertyAttributeAccessor","id","PropertyTableClassProperty","tableProperty","buffers","arrayOffsets","arrayOffsetType","bufferCons","PropertyTableAccessor","bufferView","dataArray","stringIndex","stringLength","stringOffsets","stringOffsetType","stringOffsetBuffer","byteArray","byteIndex","bitIndex","_box","Box2","_TextureReadUtility","WebGLRenderer","WebGLRenderTarget","FullScreenQuad","ShaderMaterial","CustomBlending","ZeroFactor","OneFactor","_renderer","_target","pixel","dstPixel","TextureReadUtility","reader","getTextureCoordAttribute","getTriangleVertexIndices","faceIndex","getTexCoord","texCoord","getTexelIndices","fx","fy","px","py","_srcPixel","_dstPixel","PropertyTextureClassProperty","textureProperty","PropertyTextureAccessor","names","results","n","textures","accessorProperties","readTextureSampleResults","length","BufferCons","readBuffer","lj","StructuralMetadata","nodeMetadata","schema","propertyTables","propertyTextures","propertyAttributes","tableAccessors","textureAccessors","attributeAccessors","tableIndices","ids","table","triangle","accessor","promises","promise","attributeIndex","acc","EXT_NAME","getRelevantTextures","parser","textureCount","getRelevantBuffers","values","GLTFStructuralMetadataExtension","extensionsUsed","schemaPromise","rootExtension","path","requestHeader","crossOrigin","finalUri","fileLoader","FileLoader","rootMetadata","meshes","primitives","primitive","_pixel","getMaxBarycoordIndex","MeshFeatures","featureIds","closestIndex","featureId","nullFeatureId","channels","forEachPrimitiveExtension","GLTFMeshFeaturesExtension","GLTFCesiumRTCExtension","GLTFExtensionsPlugin","GLTFLoader","sphere","ReorientationPlugin","up","azimuth","elevation","roll","recenter","minRadii","cart","group","OBJECT_FRAME","UnloadTilesPlugin","delay","bytesTarget","LRUCache","DeferCallbackManager","lruCache","deferCallbacks","unloadCallback","clamp","FadeManager","fadeState","state","cb","noState","time","delta","fadeOutTarget","fadeInTarget","fadeOut","fadeIn","fadeInSign","fadeOutSign","FADE_PARAMS","wrapFadeMaterial","previousOnBeforeCompile","shader","FadeMaterialManager","fadeParams","PassThroughBatchedMesh","proxyTarget","instanceInfo","otherInstanceInfo","FadeBatchedMesh","oldFadeTexture","fadeArray","fadeTexture","InstanceDataTexture","src","dst","len","instance","prevValue","newValue","HAS_POPPED_IN","_fromPos","_toPos","_fromQuat","Quaternion","_toQuat","_scale","onUpdateBefore","fadeManager","onUpdateAfter","fadeMaterialManager","displayActiveTiles","fadingBefore","prevCameraTransforms","maximumFadeOutTiles","batchedMesh","cameras","fadingAfter","isMovingFast","currMatrix","prevMatrix","angleTo","positionTo","isFadingOut","TilesFadePlugin","otherBatchedMesh","wasFading","isFading","batchedPlugin","instanceIds","vec1","vec2","ModelViewBatchedMesh","BatchedMesh","instanceId","matrices","renderer","matricesTexture","modelViewMatricesTexture","Source","modelViewArray","instanceMatrix","shadowCamera","depthMaterial","_raycastMesh","_batchIntersects","ExpandingBatchedMesh","reservedVertexRange","reservedIndexRange","needsIndex","neededIndexCount","neededVertexCount","bestIndex","bestScore","freeGeometryIds","geometryInfo","reservedIndexCount","reservedVertexCount","score","expandPercent","_freeGeometryIds","resultId","needsMoreSpace","vertexNeedsSpace","indexNeedsSpace","batchedIndex","batchedPosition","newIndexCount","newVertexCount","addIndexCount","addVertexCount","geometryId","newCount","raycaster","intersects","batchGeometry","drawRange","Box3","intersect","isColorWhite","color","convertMapToArrayTexture","_textureRenderQuad","_whiteTex","BatchedTilesPlugin","REVISION","gl","instanceCount","textureSize","textureOptions","arrayTarget","WebGLArrayRenderTarget","indexCount","currentRenderTarget","targetDepth","newArrayTarget","hasCorrectAttributes","attrs","batchedAttrs","canAddMeshes","_invMatrix","_raycaster","Raycaster","_doubleSidedMaterial","DoubleSide","RAYCAST_DISTANCE","calculateSphere","TileFlatteningPlugin","active","positionsUpdated","positionsMap","shapes","geomMap","direction","thresholdMode","threshold","flattenRange","r2","ray","hit","rangeAlpha","aboveThreshold","_camera","OrthographicCamera","_color","Color","TiledTextureComposer","ComposeTextureMaterial","renderTarget","span","quad","currentAutoClear","currentClearColor","currentClearAlpha","forEachTileInBounds","clampedLevel","getGeometryCartographicChannel","geomToEllipsoidMatrix","posAttr","centerLat","centerLon","getMeshesCartographicRange","meshToEllipsoidMatrix","clampedRange","getGeometryPlanarChannel","meshToFrame","aspectRatio","minW","maxW","getMeshesPlanarRange","worldToFrame","heightRange","OVERLAY_PARAMS","wrapOverlaysMaterial","calculateArcRatioAtPoint","latDelta","GeoJSONImageSource","geojson","pointRadius","strokeStyle","strokeWidth","fillStyle","geoBounds","tileBoundsDeg","canvas","ctx","features","feature","CanvasTexture","boundsDeg","featureBoundsDeg","fminX","fminY","fmaxX","fmaxY","coordinates","expandBoundsByPoint","ring","polygon","root","geomTypes","g","minLonDeg","minLatDeg","maxLonDeg","maxLatDeg","projectPoint","calculateAspectRatio","latRad","lonRad","pxLat","WGS84_ELLIPSOID","drawRatio","rIndex","fMinLon","fMinLat","fMaxLon","fMaxLat","_center","_sphereCenter","_normal","SPLIT_TILE_DATA","SPLIT_HASH","markOverlayImages","overlay","doRelease","o","p","markImages","tl","filteredPromises","countTilesInRange","ImageOverlayPlugin","overlays","resolution","enableTileSplitting","tileComposer","processQueue","PriorityQueue","tileA","tileB","visibleA","visibleB","overlayChanged","maxJobs","overlayInfo","tileControllers","pendingTiles","tileInfo","meshInfo","meshRange","meshRangeMarked","rangeMarked","bytesUsed","MemoryUtils.getTextureByteLength","initialization","fullDispose","parents","parent","clone","collectChildren","centerTarget","box","splitDirections","hashTokens","token","ortho0","ortho1","directions","average","dir","dotProduct","splitDirection","matrixWorld","boundingVolume","maxSqRadius","sqRadius","controller","forceDispose","normalizedRange","w","wProj","hProj","initTile","usedTextures","tileController","heightInRange","ImageOverlay","opacity","frame","preprocessURL","XYZTilesOverlay","GeoJSONOverlay","WMSTilesOverlay","WMTSTilesOverlay","TMSTilesOverlay","CesiumIonOverlay","GoogleMapsOverlay","LoadRegionPlugin","regions","inShape","inMask","maxError","BaseRegion","errorTarget","tilesRenderer","SphereRegion","RayRegion","Ray","OBBRegion","obb","OBB","_vector","axes","SphereHelper","LineSegments","angleSteps","axis1","axis2","angle","LineBasicMaterial","_norm2","getRegionGeometry","ellipsoidRegion","computeNormals","latStart","latEnd","lonStart","lonEnd","heightStart","heightEnd","BoxGeometry","refPosition","EllipsoidRegionLineHelper","EllipsoidRegion","EdgesGeometry","ORIGINAL_MATERIAL","HAS_RANDOM_COLOR","HAS_RANDOM_NODE_COLOR","LOAD_TIME","PARENT_BOUND_REF_COUNT","emptyRaycast","colors","getIndexedRandomColor","NONE","SCREEN_ERROR","GEOMETRIC_ERROR","DISTANCE","DEPTH","RELATIVE_DEPTH","IS_LEAF","RANDOM_COLOR","RANDOM_NODE_COLOR","CUSTOM_COLOR","LOAD_ORDER","ColorModes","DebugTilesPlugin","tilesGroup","Group","targetTile","maxDepth","_","depth","colorMode","maxDistance","visibleTiles","sortedTiles","val","TraversalUtils.traverseAncestors","current","tileVisible","cached","boxHelperGroup","boxHelper","Box3Helper","sphereHelper","regionHelper","sphereGroup","boxGroup","regionGroup","unlit","currMaterial","originalMaterial","pointsMaterial","PointsMaterial","_c","DeepZoomImageSource","tileSize","overlap","DeepZoomImagePlugin","EQUATOR_CIRCUMFERENCE","WGS84_RADIUS","mercatorProjection","isEPSG4326","isWebMercator","parseTuple","tuple","correctTupleOrder","correctTupleUnits","tupleToRadians","WMTSCapabilitiesLoader","LoaderBase","str","contents","tileMatrixSets","getChildrenByTag","el","parseTileMatrixSet","layers","parseLayer","serviceIdentification","parseServiceIdentification","title","abstract","serviceType","serviceTypeVersion","identifier","resourceUrls","parseResourceUrl","tileMatrixSetLinks","parseStyle","parseDimension","parseBoundingBox","template","resourceType","uom","lowerCorner","upperCorner","isDefault","tileMatrices","parseTileMatrix","pixelSpan","groundWidth","groundHeight","bottomRightCorner","scaleDenominator","topLeftCorner","tag","major","minor","shouldFixTupleOrder","parseEXGeographicBoundingBox","parseLatLonBoundingBox","legends","legendEl","online","readOnlineResourceHref","inheritedProperties","queryable","opaque","keywords","k","boundingBoxes","subLayers","parseService","parseRequestOperation","opEl","formats","f","dcp","httpEl","getEl","postEl","getHref","postHref","parseRequest","ops","requestType","collectLayers","WMSCapabilitiesLoader","capabilityEl","service","request","rootLayers"],"mappings":"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"}