var _t = Object.defineProperty;
var At = (o, i, e) => i in o ? _t(o, i, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[i] = e;
var _ = (o, i, e) => (At(o, typeof i != "symbol" ? i + "" : i, e), e);
import { MeshBasicMaterial, ShaderLib, Color, ShaderChunk, Matrix4, Vector3 as Vector3$1, Group, DirectionalLight, AmbientLight, Vector2 as Vector2$1, TextureLoader, EquirectangularReflectionMapping, SRGBColorSpace, OrthographicCamera, Mesh, BufferGeometry, Float32BufferAttribute, Matrix3, MathUtils, Vector4, Quaternion as Quaternion$1, Ray, Frustum, UniformsUtils, ShaderMaterial, Object3D, Clock, AdditiveBlending, PlaneGeometry, MeshNormalMaterial, WebGLRenderTarget, DepthTexture, DepthStencilFormat, UnsignedInt248Type, NoBlending, NearestFilter, RGBAFormat, HalfFloatType, UnsignedByteType, RawShaderMaterial, ColorManagement, SRGBTransfer, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, CustomToneMapping, Scene, FloatType, LinearFilter, RepeatWrapping, UniformsLib, BoxGeometry, CanvasTexture, Texture, DstColorFactor, ZeroFactor, AddEquation, DstAlphaFactor, CustomBlending, DataTexture, RedFormat, Box3, CameraHelper, BufferAttribute, LineSegments, LineBasicMaterial, Box3Helper, DoubleSide, Plane, InterleavedBuffer, InterleavedBufferAttribute, Sphere, ClampToEdgeWrapping, Points, AnimationMixer, Raycaster, PerspectiveCamera, WebGLRenderer, GLSL3, SphereGeometry, FramebufferTexture, EventDispatcher, Euler, CylinderGeometry, OctahedronGeometry, Line, TorusGeometry, WebGLCubeRenderTarget, LinearMipmapLinearFilter, CubeCamera, PMREMGenerator, DataTextureLoader, DataUtils, LinearSRGBColorSpace, Loader, CubeTexture, FileLoader, CubeTextureLoader, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, OneFactor, REVISION, Box2, LoaderUtils, SpotLight, PointLight, MeshPhysicalMaterial, InstancedMesh, ImageBitmapLoader, PointsMaterial, Material, MeshStandardMaterial, PropertyBinding, SkinnedMesh, LineLoop, Skeleton, InterpolateLinear, AnimationClip, Bone, NearestMipmapNearestFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, MirroredRepeatWrapping, InterpolateDiscrete, FrontSide, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Interpolant, CompressedCubeTexture, CompressedArrayTexture, CompressedTexture, RGBA_ASTC_4x4_Format, RGB_BPTC_UNSIGNED_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGFormat, RGBA_ASTC_6x6_Format, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, Data3DTexture, NoColorSpace, LoopRepeat, LoopOnce, InstancedBufferAttribute, DefaultLoadingManager, SIGNED_RED_GREEN_RGTC2_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, RED_RGTC1_Format, RGB_BPTC_SIGNED_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_5x4_Format, RGBA_PVRTC_2BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBAIntegerFormat, RGIntegerFormat, RedIntegerFormat, AlphaFormat, IntType, UnsignedIntType, UnsignedShort5551Type, UnsignedShort4444Type, ShortType, UnsignedShortType, ByteType, EdgesGeometry, InstancedBufferGeometry, LoadingManager, CatmullRomCurve3, DepthFormat } from "three";
import urlJoin from "url-join";
import Uri from "urijs";
import { Group as Group$1, Emitter } from "shader-particle-system";
import { BlendFunction, EffectPass } from "postprocessing";
import proj4 from "proj4";
import TinySDF from "@mapbox/tiny-sdf";
import potpack from "potpack";
import RBush from "rbush";
import { bind, clear } from "size-sensor";
import md5 from "js-md5";
import "quickselect";
import parseWkt from "wellknown";
import earcut from "earcut";
import cdt2d from "cdt2d";
import KDBush from "kdbush";
import simpleheat from "simpleheat";
const CSS_NAMESPACE = "mapv";
function addClass(o, i) {
  if (o.className === void 0)
    o.className = i;
  else if (o.className !== i) {
    const e = o.className.split(/ +/);
    e.indexOf(i) === -1 && (e.push(i), o.className = e.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
  }
  return o;
}
function removeClass(o, i) {
  if (i)
    if (o.className === i)
      o.removeAttribute("class");
    else {
      const e = o.className.split(/ +/), r = e.indexOf(i);
      r !== -1 && (e.splice(r, 1), o.className = e.join(" "));
    }
  else
    o.className = void 0;
  return o;
}
const isStyleInjected = {};
function injectStyle(o, i) {
  if (isStyleInjected[o])
    return;
  const e = i || document, r = document.createElement("style");
  r.type = "text/css", r.innerHTML = o;
  const s = e.getElementsByTagName("head")[0];
  try {
    s.appendChild(r), isStyleInjected[o] = !0;
  } catch {
  }
}
const styleSheet = `.mapv-widgets-pane{position:absolute;z-index:15;bottom:0;left:0;right:0}.mapv-widgets-pane .bottom-right-anchor{position:absolute;width:52px;bottom:40px;right:20px}.mapv-widgets-pane .bottom-left-anchor{position:absolute;bottom:60px;left:20px}.mapv-widgets-pane .compass{width:52px;height:54px;margin-top:10px;visibility:visible;position:relative;background-size:266px;background-repeat:no-repeat;background-position:0 0}.mapv-widgets-pane .compass .compass-up{position:absolute;left:20px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-widgets-pane .compass .compass-up:hover{fill:#2c82ff}.mapv-widgets-pane .compass .compass-down{position:absolute;left:20px;bottom:2px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-widgets-pane .compass .compass-down:hover{fill:#2c82ff}.mapv-widgets-pane .compass .compass-left{cursor:pointer;position:absolute;top:5px;left:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px}.mapv-widgets-pane .compass .compass-left:hover{background-position:-89px -5px}.mapv-widgets-pane .compass .compass-right{cursor:pointer;position:absolute;top:5px;right:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px;transform:rotateY(180deg);-ms-transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-o-transform:rotateY(180deg);-moz-transform:rotateY(180deg)}.mapv-widgets-pane .compass .compass-right:hover{background-position:-89px -5px}.mapv-widgets-pane .compass .compass-center{cursor:pointer;position:absolute;top:11px;left:19px;width:14px;height:32px;background-size:266px;background-repeat:no-repeat;background-position:-56px -10px;transform:rotate(0)}.mapv-widgets-pane .zoom{width:26px;height:54px;visibility:visible;margin-left:13px;margin-top:10px}.mapv-widgets-pane .zoom .zoom-add{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:2px 2px 0 0;background-position:0 0}.mapv-widgets-pane .zoom .zoom-add:hover .zoom-add-tag{background-position:20px 0}.mapv-widgets-pane .zoom .zoom-add-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px}.mapv-widgets-pane .zoom .zoom-sub{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:0 0 2px 2px}.mapv-widgets-pane .zoom .zoom-sub:hover .zoom-sub-tag{background-position:10px 0}.mapv-widgets-pane .zoom .zoom-sub-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px;background-position:-10px 0}.mapv-widgets-pane .scale{position:absolute;bottom:10px;left:100px;visibility:visible;width:90px;height:26px}.mapv-widgets-pane .scale .scale-text{width:100%;font-size:10px;text-align:center;user-select:none;transition:width .3s}.mapv-widgets-pane .scale .scale-line{position:relative;width:100%;height:8px;user-select:none}.mapv-widgets-pane .scale .scale-line-mid{position:absolute;left:2px;right:2px;top:3px;bottom:2px;background-color:#333;overflow:hidden}.mapv-widgets-pane .scale .scale-line-left{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden}.mapv-widgets-pane .scale .scale-line-right{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden;right:0}.mapv-widgets-pane .drawer{position:absolute;right:31px;bottom:164px;margin:2px;cursor:pointer}.mapv-widgets-pane .drawer .drawer-btn{background-color:#fff;padding:5px 5px 0;border-radius:2px}.mapv-widgets-pane .drawer .drawer-btn:hover{background-color:#f3f3f3}.mapv-widgets-pane .drawer .drawer-icon{height:16px;width:16px;fill:#797979}.mapv-widgets-pane .drawer .drawer-list{position:absolute;right:32px;top:0;display:none;list-style:none;background-color:#fff;box-shadow:0 0 20px #00000026;white-space:nowrap;border-radius:2px}.mapv-widgets-pane .drawer .drawer-item{display:flex;align-items:center;padding:0 16px;height:24px;line-height:24px}.mapv-widgets-pane .drawer .drawer-item-check{margin:0}.mapv-widgets-pane .drawer .drawer-item-name{margin-left:6px;font-size:12px}.mapv-widgets-pane .drawer .drawer-arrow{width:0;height:0;border-width:4px;border-style:solid;border-color:transparent transparent transparent #fff;position:absolute;top:11px;right:-7px}.mapv-widgets-pane .mouse-location{position:absolute;bottom:10px;right:20px;visibility:visible;padding:2px 6px;background-color:#fff;font-size:14px;border-radius:2px}.mapv-widgets-pane .logo{position:absolute;width:81px;height:27px;bottom:10px;left:5px;visibility:visible}.mapv-widgets-pane .geo-locate{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-widgets-pane .fullscreen{background-color:#fff;height:26px;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc}.mapv-widgets-pane .export-image{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-widgets-pane .geo-locate:hover .widgets-group-svg,.mapv-widgets-pane .fullscreen:hover .widgets-group-svg,.mapv-widgets-pane .export-image:hover .widgets-group-svg{fill:#2c82ff}.mapv-widgets-pane .widgets-group-svg{margin:5px;height:16px;width:16px;fill:#999}.mapv-overlay-pane{position:absolute;z-index:10}.mapv-overlay-pane .mapv-marker{z-index:10}.mapv-overlay-pane .mapv-marker:hover{cursor:pointer}.mapv-overlay-pane .mapv-popup{width:250px;height:130px;z-index:20}.mapv-overlay-pane .mapv-popup .frame{width:248px;height:118px;background:white;border-radius:4px;border:1px solid #e6e1e1}.mapv-overlay-pane .mapv-popup .title{height:30px;border-bottom:1px solid #e6e1e1;line-height:30px;padding:2px 0 2px 10px;font-weight:500}.mapv-overlay-pane .mapv-popup .close{width:20px;height:31px;position:absolute;font-size:20px;text-align:center;right:5px;cursor:pointer}.mapv-overlay-pane .mapv-popup .triangle{width:0;height:0;border-top:10px solid white;border-left:12px solid transparent;border-right:12px solid transparent;margin-left:112px}.mapv-overlay-pane .mapv-popup .content{padding:5px 10px}.mapv-dom-points{position:absolute;z-index:10;user-select:none}.mapv-measure-pane{display:inline-block;position:absolute;height:30px;border-radius:5px;padding:0 5px;line-height:30px;background-color:#797774;color:#fff;transform:translate(-50%,-130%);overflow:visible;white-space:nowrap}.mapv-measure-pane:after{content:"";position:absolute;width:0;height:0;left:50%;bottom:0;border:6px solid transparent;border-top:6px solid #797774;background-color:transparent;transform:translate(-50%,10px)}.mapv-container{touch-action:none}.mapv-hidden{display:none!important}
`, extra_vertex_utils = `#define GLSLIFY 1
uniform float zoomUnits;

// position\u4E3Aworld coord
float getPixelSize(vec3 position) {
    if (isOrthographic) {
        return zoomUnits;
    }
    else {
        // projectionMatrix\u7B2C5\u4F4D\u542B\u4E49\u4E3Atan(fov / 2) = 2 * near / (top - bottom)
        return 0.2 * projectionMatrix[1][1] / resolution.y * distance(cameraPosition, position);
    }
}
`, selective_pars_vertex = `#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
attribute float objectIndex;
uniform float selectedObjectIndex;
varying float isSelected;
#endif`, selective_vertex = `#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
if (objectIndex == selectedObjectIndex) {
	isSelected = 1.0;
} else {
	isSelected = 0.0;
}
#endif`, selective_pars_fragment = `#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
varying float isSelected;
uniform vec4 selectedObjectColor;
uniform float selectedObjectColorMode;
#endif`, selective_fragment = `#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
if (isSelected == 1.0) {
	if (selectedObjectColorMode == 1.) {
		gl_FragColor = selectedObjectColor;
	} else {
		gl_FragColor.rgb = selectedObjectColor.rgb * selectedObjectColor.a + gl_FragColor.rgb * (1.0 - selectedObjectColor.a);
	}
	
}
#endif`, keepsize_pars_vertex = `#define GLSLIFY 1
uniform bool keepSize;
uniform float pixelRatio;
uniform vec2 resolution;
`, keepsize_vertex = `#define GLSLIFY 1
vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));
float pixelSize = getPixelSize(worldPosition.xyz);
if (keepSize) {
    transformed *= pixelSize;
}
`, uniform_zoomunits_pars = `#define GLSLIFY 1
`, emissive_pars_fragment = `#define GLSLIFY 1
#define MVT_EMISSIVE_SHADER

uniform vec3 emissive;`, emissive_fragment = `#define GLSLIFY 1
#ifdef MVT_EMISSIVE_SHADER
    vec4 out_emissive = vec4(emissive.rgb, 1.0);
#endif`, override_standard_emissivemap_pars_fragment = `#define GLSLIFY 1
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif`, override_standard_emissivemap_fragment = `#define GLSLIFY 1
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	// emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

    
#endif

if (isEmissive) {
    gl_FragColor = vec4(totalEmissiveRadiance, 1.0);
	#if defined( TONE_MAPPING )
	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
    #endif
    return;
}`, override_basic_color_pars_fragment = `#define GLSLIFY 1
#ifdef USE_COLOR

	varying vec3 vColor;

#endif`, override_basic_color_fragment = `#define GLSLIFY 1
if (isEmissive) {
    gl_FragColor = vec4(emissive, 1.0);
    #if defined( TONE_MAPPING )
	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
    #endif
    return;
}
#ifdef USE_COLOR

	diffuseColor.rgb *= vColor;

#endif`, animation_vertex = `#define GLSLIFY 1
#ifdef ENABLE_ANIMATION_ROTATE
    float rotateRatio = mod(elapsedTime, animationRotatePeriod) / animationRotatePeriod;
    if (animationPeriodOffset) {
        rotateRatio = mod(rotateRatio + instancedRandomFactor, 1.0);
    }
    float rotation = rotateRatio * 6.28;
    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * transformed.x - sin( rotation ) * transformed.y;
    rotatedPosition.y = sin( rotation ) * transformed.x + cos( rotation ) * transformed.y;
    transformed.xy = rotatedPosition;
#endif

#ifdef ENABLE_ANIMATION_JUMP
    float jumpRatio = mod(elapsedTime, animationJumpPeriod) / animationJumpPeriod;
    if (animationPeriodOffset) {
        jumpRatio = mod(jumpRatio + instancedRandomFactor, 1.0);
    }
    if (jumpRatio <= 0.5) {
        jumpRatio *= 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    } else {
        jumpRatio = (1.0 - jumpRatio) * 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    }
    #ifdef USE_SIZE3
        transformed.z += jumpRatio * animationJumpHeight / size3.z;
    #else
        transformed.z += jumpRatio * animationJumpHeight / size;
    #endif
#endif

#ifdef ENABLE_ANIMATION_SCALE
    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;
    if (animationPeriodOffset) {
        scaleRatio = mod(scaleRatio + instancedRandomFactor, 1.0);
    }

    vScale *= 1.0 + (targetScale - 1.0) * scaleRatio;

    if (opacityGradient) {
        if (targetScale > 1.0) {
            opacityRatio = 1.0 - (targetScale - 1.0) * scaleRatio;
        } else {
            opacityRatio = 1.0 + (targetScale - 1.0) * scaleRatio;
        }
    }

#endif

#ifdef ENABLE_ANIMATION_BREATH
    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;
    if (animationPeriodOffset) {
        scaleRatio = mod(scaleRatio + instancedRandomFactor, 1.0);
    }
    float repeatNum = scaleRatio / 0.25;
    float scaleFactor = mod(scaleRatio, 0.25) / 0.25;
    float scaleNum = scaleFactor * (maxScale - 1.0);
    float balance = (maxScale + minScale) / 2.0;

    if (repeatNum > 1.0 && repeatNum < 3.0) {
        // \u4E0B\u964D
        if (repeatNum < 2.0) {
            scaleNum = (1.0 - scaleFactor) * (maxScale - balance);
        } else {
            scaleNum = -scaleFactor * (balance - minScale);
        }
    } else if (repeatNum >= 3.0) {
        scaleNum = -(1.0 - scaleFactor) * (balance - minScale);
    }

    vScale *= balance + scaleNum;

    if (opacityGradient) {
        opacityRatio = (balance + scaleNum) / maxScale;
    }

#endif`, animation_pars_vertex = `#define GLSLIFY 1
uniform bool animationPeriodOffset;

#ifdef ENABLE_ANIMATION_ROTATE
uniform float animationRotatePeriod;
#endif

#ifdef ENABLE_ANIMATION_JUMP
uniform float animationJumpPeriod;
uniform float animationJumpHeight;
#endif

#ifdef ENABLE_ANIMATION_SCALE
uniform float animationPeriod;
uniform float targetScale;
uniform bool opacityGradient;
#endif

#ifdef ENABLE_ANIMATION_BREATH
uniform float animationPeriod;
uniform float maxScale;
uniform float minScale;
uniform bool opacityGradient;
#endif`, animation_label_vertex = `#define GLSLIFY 1
// \u5BF9\u975Einstance\u5BF9\u8C61\u6DFB\u52A0\u52A8\u753B
#ifdef ENABLE_ANIMATION_SCALE
    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;
    if (animationPeriodOffset) {
        scaleRatio = mod(scaleRatio, 1.0);
    }

    vScale *= 1.0 + (targetScale - 1.0) * scaleRatio;

    if (opacityGradient) {
        if (targetScale > 1.0) {
            opacityRatio = 1.0 - (targetScale - 1.0) * scaleRatio;
        } else {
            opacityRatio = 1.0 + (targetScale - 1.0) * scaleRatio;
        }
    }

#endif

#ifdef ENABLE_ANIMATION_JUMP
    float jumpRatio = mod(elapsedTime, animationJumpPeriod) / animationJumpPeriod;
    if (animationPeriodOffset) {
        jumpRatio = mod(jumpRatio, 1.0);
    }
    if (jumpRatio <= 0.5) {
        jumpRatio *= 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    } else {
        jumpRatio = (1.0 - jumpRatio) * 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    }

    float jumpHeight = jumpRatio * animationJumpHeight;
#endif

#ifdef ENABLE_ANIMATION_ROTATE
    float rotateRatio = mod(elapsedTime, animationRotatePeriod) / animationRotatePeriod;
    if (animationPeriodOffset) {
        rotateRatio = mod(rotateRatio, 1.0);
    }
    float rotation = rotateRatio * 6.28;
#endif

#ifdef ENABLE_ANIMATION_BREATH
    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;
    if (animationPeriodOffset) {
        scaleRatio = mod(scaleRatio, 1.0);
    }
    float repeatNum = scaleRatio / 0.25;
    float scaleFactor = mod(scaleRatio, 0.25) / 0.25;
    float scaleNum = scaleFactor * (maxScale - 1.0);
    float balance = (maxScale + minScale) / 2.0;

    if (repeatNum > 1.0 && repeatNum < 3.0) {
        // \u4E0B\u964D
        if (repeatNum < 2.0) {
            scaleNum = (1.0 - scaleFactor) * (maxScale - balance);
        } else {
            scaleNum = -scaleFactor * (balance - minScale);
        }
    } else if (repeatNum >= 3.0) {
        scaleNum = -(1.0 - scaleFactor) * (balance - minScale);
    }

    vScale *= balance + scaleNum;

    if (opacityGradient) {
        opacityRatio = (balance + scaleNum) / maxScale;
    }
#endif`, mrt_output_pars_fragment = `#define GLSLIFY 1
#ifndef DISABLE_MRT
    // layout(location = 1) out highp vec4 pc_fragColor1;
    // layout(location = 2) out highp vec4 pc_fragColor2;
    // layout(location = 3) out highp vec4 pc_fragColor3;
    // layout(location = 4) out highp vec4 pc_fragColor4;
    // layout(location = 5) out highp vec4 pc_fragColor5;
    // layout(location = 6) out highp vec4 pc_fragColor6;
    // layout(location = 7) out highp vec4 pc_fragColor7;
    #if defined(MVT_MRT_OUT_EMISSIVE)
        layout(location = MVT_MRT_OUT_EMISSIVE) out highp vec4 mvt_pc_emissive;
    #endif

    #if defined(MVT_MRT_OUT_NORMAL)
        layout(location = MVT_MRT_OUT_NORMAL) out highp vec4 mvt_pc_normal;
    #endif

    #if defined(MVT_MRT_OUT_METALLICROUGH)
        layout(location = MVT_MRT_OUT_METALLICROUGH) out highp vec4 mvt_pc_metallicRough;
    #endif
#endif

#if defined(MVT_EMISSIVE_UNIFORM)
// \u53D1\u5149\u989C\u8272\u81EA\u5B9A\u4E49
    #if defined(MVT_EMISSIVE_COLOR)
        uniform vec3 mvt_emissive;
    #endif  
    uniform float mvt_emissiveIntensity;
#endif`, mrt_output_fragment = `#define GLSLIFY 1
#ifndef DISABLE_MRT
    // \u81EA\u5B9A\u4E49\u53D1\u5149\u989C\u8272\uFF0C\u5B8C\u5168\u7531\u7740\u8272\u5668\u63A7\u5236 \u5728\u7740\u8272\u5668\u4E2D\u8F93\u51FA vec4 out_emissive;
    #ifdef MVT_MRT_OUT_EMISSIVE
        #if defined(MVT_EMISSIVE_SHADER)
            mvt_pc_emissive = out_emissive;
        #elif defined(STANDARD)
            mvt_pc_emissive.rgb = totalEmissiveRadiance;
            mvt_pc_emissive.a = pc_fragColor.a;
        #elif defined(PHONG)
            mvt_pc_emissive.rgb = totalEmissiveRadiance;
            mvt_pc_emissive.a = pc_fragColor.a;
        #elif defined(BASIC)
            mvt_pc_emissive.rgb = emissive;
            mvt_pc_emissive.a = pc_fragColor.a;
        // \u901A\u8FC7\u4F20\u5165\u7684uniform\u53D8\u91CF\u989C\u8272\u81EA\u53D1\u5149
        #elif defined(MVT_EMISSIVE_UNIFORM)
            // \u53D1\u5149\u989C\u8272\u81EA\u5B9A\u4E49
            #if defined(MVT_EMISSIVE_COLOR)
                mvt_pc_emissive.rgb = mvt_emissive * mvt_emissiveIntensity;
                mvt_pc_emissive.a = pc_fragColor.a;
            #else  
                mvt_pc_emissive = pc_fragColor * mvt_emissiveIntensity;
            #endif
        #else
            mvt_pc_emissive = vec4(0.0, 0.0, 0.0, 0.0);
        #endif  
    #endif

    #ifdef MVT_MRT_OUT_NORMAL
        #if defined(STANDARD)
            #ifndef FLAT_SHADED
                mvt_pc_normal = vec4(packNormalToRGB(vNormal), gl_FragCoord.z);
            #else
                mvt_pc_normal = vec4(0.0, 0.0, 0.0, 0.0);
            #endif
        #else
            #if defined(MVT_FRAG_NORMAL)
                mvt_pc_normal = vec4(packNormalToRGB(mvt_frag_normal), 1.0);
            #else
                mvt_pc_normal = vec4(0.0, 0.0, 0.0, 0.0);
            #endif
        #endif
    #endif

    #ifdef MVT_MRT_OUT_METALLICROUGH
        #if defined(STANDARD)
            mvt_pc_metallicRough = vec4(1.0 - material.roughness, 0.0, 0.0, 1.0);
        #else
            float temp_reflectionFactor = 0.0;
            #if defined(MVT_FRAG_REFLECTION_FACTOR)
                temp_reflectionFactor = mvt_frag_reflectionFactor;
            #endif
            mvt_pc_metallicRough = vec4(temp_reflectionFactor, 0.0, 0.0, 0.0);
        #endif
    #endif
    
    // pc_fragColor4 = vec4(1.0, 0.0, 1.0, 1.0);
    // pc_fragColor5 = vec4(0.0, 1.0, 0.0, 1.0);
    // pc_fragColor6 = vec4(0.0, 1.0, 0.0, 1.0);
    // pc_fragColor7 = vec4(0.0, 1.0, 0.0, 1.0);
#endif
`, nmrt_output_pars_fragment = `#define GLSLIFY 1
#if defined(MVT_EMISSIVE_UNIFORM)
    // \u53D1\u5149\u989C\u8272\u81EA\u5B9A\u4E49
    #if defined(MVT_EMISSIVE_COLOR)
        uniform vec3 mvt_emissive;
    #endif  
    uniform float mvt_emissiveIntensity;
#endif
uniform bool isEmissive;`, nmrt_output_fragment = `#define GLSLIFY 1
// if (isEmissive) {
#if defined(MVT_MODE_EMISSIVE)
    #if defined(MVT_EMISSIVE_SHADER)
        gl_FragColor = out_emissive;
    #elif defined(STANDARD)
        gl_FragColor.rgb = totalEmissiveRadiance;
    #elif defined(PHONG)
        gl_FragColor.rgb = totalEmissiveRadiance;
    #elif defined(BASIC)
        gl_FragColor.rgb = emissive;
    // \u901A\u8FC7\u4F20\u5165\u7684uniform\u53D8\u91CF\u989C\u8272\u81EA\u53D1\u5149
    #elif defined(MVT_EMISSIVE_UNIFORM)
        // \u53D1\u5149\u989C\u8272\u81EA\u5B9A\u4E49
        #if defined(MVT_EMISSIVE_COLOR)
            gl_FragColor.rgb = mvt_emissive * mvt_emissiveIntensity;
        #else
            gl_FragColor = gl_FragColor * mvt_emissiveIntensity;
        #endif
    #else
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    #endif
#endif
//}`, extra_meshbasic_frag_pars = `#define GLSLIFY 1
#define BASIC
uniform vec3 emissive;`, clip_pars_vertex = `#define GLSLIFY 1
#ifdef USE_CLIP
    varying vec3 clip_position;
    varying mat4 clip_modelMat4;
    #ifdef IS_INSTANCE
        varying mat4 clip_instanceMat4;
    #endif
#endif`, clip_vertex = `#define GLSLIFY 1
#ifdef USE_CLIP
    clip_position = position;
    clip_modelMat4 = modelMatrix;
    #ifdef IS_INSTANCE
        clip_instanceMat4 = instanceMatrix;
    #endif
#endif
`, clip_pars_fragment = `#define GLSLIFY 1
#ifdef USE_CLIP

    varying vec3 clip_position;
    varying mat4 clip_modelMat4;
    #ifdef IS_INSTANCE
        varying mat4 clip_instanceMat4;
    #endif

    struct ClipParameters {
        vec2 u_polygon[20];
        vec4 polygonBounds;
        int clip_type;
        bool clip_inside;
        vec2 clip_point;
        float clip_radius;
        float clip_maxDiff;
        vec2 clip_size;
    };

    uniform ClipParameters mvt_clipParameters;

    int areIntersecting(
        float v1x1, float v1y1, float v1x2, float v1y2,
        float v2x1, float v2y1, float v2x2, float v2y2
    ) {
        float d1, d2;
        float a1, a2, b1, b2, c1, c2;

        a1 = v1y2 - v1y1;
        b1 = v1x1 - v1x2;
        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);

        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;
        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;

        if (d1 > 0.0 && d2 > 0.0) return 0;
        if (d1 <= 0.0 && d2 <= 0.0) return 0;

        a2 = v2y2 - v2y1;
        b2 = v2x1 - v2x2;
        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);

        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;
        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;

        if (d1 > 0.0 && d2 > 0.0) return 0;
        if (d1 < 0.0 && d2 < 0.0) return 0;

        if ((a1 * b2) - (a2 * b1) == 0.0) return 2;

        return 1;
    }

    bool pointInPolygon(vec2 p) {
        vec4 polygonBounds = mvt_clipParameters.polygonBounds;
        float minX = polygonBounds.x;
        float minY = polygonBounds.y;
        float maxX = polygonBounds.z;
        float maxY = polygonBounds.w;
        if (p.x > maxX || p.x < minX || p.y > maxY || p.y < minY)
        {
            return false;
        }

        vec2 points[20] = mvt_clipParameters.u_polygon;
        float maxDiff = mvt_clipParameters.clip_maxDiff;
        int intersectCount = 0;

        #ifdef USE_CLIPCOUNT
            for (int i = 0; i < USE_CLIPCOUNT; i++) {
                vec2 vertex = points[i];

                vec2 vertex2;
                if (i == USE_CLIPCOUNT - 1) {
                    vertex2 = points[0];
                }
                else {
                    vertex2 = points[i + 1];
                }

                bool intersection = areIntersecting(p.x, p.y, p.x + maxDiff * 2.0, p.y, vertex.x, vertex.y, vertex2.x, vertex2.y) != 0;
                if (intersection) {
                    intersectCount++;
                }
            }
            return (intersectCount % 2) == 1;
        #else
            return false;
        #endif
    }

    bool pointInCircle(vec2 point) {
        float distance = length(point - mvt_clipParameters.clip_point);
        return distance < mvt_clipParameters.clip_radius;
    }

    bool pointInRect(vec2 point) {
        return (point.x > mvt_clipParameters.clip_point.x 
            && point.x < mvt_clipParameters.clip_point.x + mvt_clipParameters.clip_size.x
            && point.y > mvt_clipParameters.clip_point.y 
            && point.y < mvt_clipParameters.clip_point.y + mvt_clipParameters.clip_size.y);
    }

#endif`, clip_fragment = `#define GLSLIFY 1
#ifdef USE_CLIP
    vec4 worldCoord;

    #ifdef CUSTOM_WORLD_COORD
        worldCoord = vec4(vMP, 1.0);
    #else
        #ifdef IS_INSTANCE
            worldCoord = clip_modelMat4 * clip_instanceMat4 * vec4(clip_position, 1.0);
        #else
            worldCoord = clip_modelMat4 * vec4(clip_position, 1.0);
        #endif
    #endif
    bool isInside = false;
    if (mvt_clipParameters.clip_type == 0) {
        isInside = pointInPolygon(worldCoord.xy / worldCoord.w);
    }
    else if (mvt_clipParameters.clip_type == 1) {
        isInside = pointInCircle(worldCoord.xy / worldCoord.w);
    }
    else if (mvt_clipParameters.clip_type == 2) {
        isInside = pointInRect(worldCoord.xy / worldCoord.w);
    }
    
    bool clipInside = mvt_clipParameters.clip_inside;
    if (clipInside) {
        if (isInside) {
            discard;
        }
    }
    else {
        if (!isInside) {
            discard;
        }
    }
#endif`, depth_packing = `#define GLSLIFY 1
float mvt_linearize_depth(in float depth, in float cameraNear, in float cameraFar){
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float mvt_reconstruct_depth(sampler2D tDepth, const in vec2 uv, in float cameraNear, in float cameraFar){
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float mvtGetDepthFromTexture(sampler2D tDepth, vec2 uv, in float cameraNear, in float cameraFar) {
    #if defined( USE_LOGDEPTHBUF )
        return mvt_linearize_depth(mvt_reconstruct_depth(tDepth, uv, cameraNear, cameraFar), cameraNear, cameraFar);
    #else
        return texture2D(tDepth, uv).x;
    #endif
}
vec3 mvtGetWorldPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix, mat4 viewInverseMatrix) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);

    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];
    // clipSpacePosition *= clipW;
    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;
    
    // viewSpacePosition /= viewSpacePosition.w;
    // return viewSpacePosition.xyz;
    vec4 worldSpacePosition = viewInverseMatrix * viewSpacePosition;

    return worldSpacePosition.xyz / worldSpacePosition.w;
}

vec3 mvtGetViewPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);

    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];
    // clipSpacePosition *= clipW;
    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;
    
    viewSpacePosition /= viewSpacePosition.w;
    return viewSpacePosition.xyz;

}
`, depth_range_pars_fragment = `#define GLSLIFY 1
#ifdef MVT_USE_DEPTH_RANGE

uniform vec2 depthRange;

layout(location = 1) out highp vec4 pc_fragColor1;

float mvt_remapDepth(float depth) {
    return depth * (depthRange.y - depthRange.x) + depthRange.x;
}
#endif

#if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)
    varying float vLayerIndex;
#endif

`, depth_range_fragment = `#define GLSLIFY 1
#ifdef MVT_USE_DEPTH_RANGE
    // \u771F\u5B9E\u7684\u6DF1\u5EA6\uFF1A\u751F\u6210\u6DF1\u5EA6\u56FE
    #ifdef OPAQUE
        pc_fragColor1 = packDepthToRGBA(gl_FragDepthEXT);
        // pc_fragColor1 = vec4(gl_FragDepthEXT, 0., 0., 1);
    #else
        // \u7981\u6B62\u534A\u900F\u660E\u533A\u57DF\u6DF7\u5408\u6DF1\u5EA6
        pc_fragColor1 = vec4(1., 1., 1., 0);
    #endif
    // pc_fragColor = packDepthToRGBA(gl_FragDepthEXT);

    // layerIndex\u7B97\u7684\u5047\u6DF1\u5EA6\uFF1A\u5B58\u5230\u6DF1\u5EA6\u6570\u636E\u91CC
    #if defined(MVT_USE_VERTEX_ZINDEX)
        gl_FragDepthEXT = mvt_remapDepth(1.0 - vLayerIndex);
    #elif defined(MVT_USE_VERTEX_ZINDEX_LEGACY)
        gl_FragDepthEXT = mvt_remapDepth(gl_FragDepthEXT - vLayerIndex * 0.01);
    #else
        gl_FragDepthEXT = mvt_remapDepth(gl_FragDepthEXT);
    #endif
#endif`, output_pars_fragment = `#define GLSLIFY 1
uniform bool srgbTransformer;
uniform bool isLinearToneMapping;
uniform bool isReinhardToneMapping;
uniform bool isCineonToneMapping;
uniform bool isACESFilmicToneMapping;`, output_fragment = `#define GLSLIFY 1
if (isLinearToneMapping) {
    gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );
}
else if (isReinhardToneMapping) {
    gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );
}
// else if (isCineonToneMapping) {
//     gl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );
// }
else if (isACESFilmicToneMapping) {
    gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );
}

if (srgbTransformer) {
    gl_FragColor = sRGBTransferOETF( gl_FragColor );
}`, addNMrtSupportFragmentShader = (o) => {
  let i = `#include <mvt_nmrt_output_pars_fragment>
`, e = `#include <mvt_nmrt_output_fragment>
`, r = o;
  r = r.replace(
    "void main() {",
    i + "void main() {"
  );
  const s = r.lastIndexOf("}");
  return r = r.substring(0, s), r += e + "}", r;
}, addExtraCodeToShader = (o, i, e, r) => {
  if ((i || e) && (o = o.replace(
    "void main()",
    (i || "") + `void main()
` + (e || "")
  )), r) {
    const s = o.lastIndexOf("}");
    o = o.substring(0, s), o += r + "}";
  }
  return o;
}, shader_vertex_editable_beforeMainStart = `
attribute float _tileEditableValue;
`, shader_vertex_editable_beforeMainEnd = `
if (_tileEditableValue == 1.0) {
    gl_Position = vec4(-1.0, -1.0, -1.0, -1.0);
}
`, addEditableToVertexShader = (o) => addExtraCodeToShader(
  o,
  shader_vertex_editable_beforeMainStart,
  null,
  shader_vertex_editable_beforeMainEnd
), addClipableToVertexShader = (o) => {
  const i = "void main()";
  o = o.replace(
    i,
    `#include <mvt_clip_pars_vertex>
` + i
  );
  const e = o.indexOf(i), r = o.slice(e + i.length), s = e + i.length + r.indexOf("{") + 1;
  return o = o.slice(0, s) + `
    #include <mvt_clip_vertex>
` + o.slice(s), o;
}, addClipableToFragmentShader = (o) => {
  const i = "void main()";
  o = o.replace(
    i,
    `#include <mvt_clip_pars_fragment>
` + i
  );
  const e = o.indexOf(i), r = o.slice(e + i.length), s = e + i.length + r.indexOf("{") + 1;
  return o = o.slice(0, s) + `
    #include <mvt_clip_fragment>
` + o.slice(s), o;
}, overridePresetMaterials = () => {
  MeshBasicMaterial.prototype.emissiveIntensity = 1, ShaderLib.basic.uniforms.emissive = { value: new Color(0) }, ShaderLib.basic.uniforms.isEmissive = { value: !1 };
}, addExtraShaderChunks = () => {
  ShaderChunk.mvt_uniform_zoomunits_pars = uniform_zoomunits_pars, ShaderChunk.mvt_extra_vertex_utils = extra_vertex_utils, ShaderChunk.mvt_selective_pars_vertex = selective_pars_vertex, ShaderChunk.mvt_selective_vertex = selective_vertex, ShaderChunk.mvt_selective_pars_fragment = selective_pars_fragment, ShaderChunk.mvt_selective_fragment = selective_fragment, ShaderChunk.mvt_keepsize_pars_vertex = keepsize_pars_vertex, ShaderChunk.mvt_keepsize_vertex = keepsize_vertex, ShaderChunk.mvt_emissive_pars_fragment = emissive_pars_fragment, ShaderChunk.mvt_emissive_fragment = emissive_fragment, ShaderChunk.mvt_override_standard_emissivemap_pars_fragment = override_standard_emissivemap_pars_fragment, ShaderChunk.mvt_override_standard_emissivemap_fragment = override_standard_emissivemap_fragment, ShaderChunk.mvt_override_basic_color_pars_fragment = override_basic_color_pars_fragment, ShaderChunk.mvt_override_basic_color_fragment = override_basic_color_fragment, ShaderChunk.mvt_animation_pars_vertex = animation_pars_vertex, ShaderChunk.mvt_animation_vertex = animation_vertex, ShaderChunk.mvt_animation_label_vertex = animation_label_vertex, ShaderChunk.mvt_mrt_output_pars_fragment = mrt_output_pars_fragment, ShaderChunk.mvt_mrt_output_fragment = mrt_output_fragment, ShaderChunk.mvt_nmrt_output_pars_fragment = nmrt_output_pars_fragment, ShaderChunk.mvt_nmrt_output_fragment = nmrt_output_fragment, ShaderChunk.mvt_extra_meshbasic_frag_pars = extra_meshbasic_frag_pars, ShaderChunk.mvt_clip_pars_vertex = clip_pars_vertex, ShaderChunk.mvt_clip_vertex = clip_vertex, ShaderChunk.mvt_clip_pars_fragment = clip_pars_fragment, ShaderChunk.mvt_clip_fragment = clip_fragment, ShaderChunk.mvt_depth_packing = depth_packing, ShaderChunk.mvt_depth_range_pars_fragment = depth_range_pars_fragment, ShaderChunk.mvt_depth_range_fragment = depth_range_fragment, ShaderChunk.output_fragment = output_fragment, ShaderChunk.output_pars_fragment = output_pars_fragment;
}, overrideShaders = function() {
  addExtraShaderChunks(), overridePresetMaterials();
};
function isObject(o) {
  return o && typeof o == "object" && !Array.isArray(o);
}
function isNumber(o) {
  return !isNaN(o) && o !== null && !Array.isArray(o);
}
function defined$2(o) {
  return o != null;
}
function defaultValue$1(o, i) {
  return o != null ? o : i;
}
defaultValue$1.EMPTY_OBJECT = Object.freeze({});
defaultValue$1.EMPTY_MAT4 = Object.freeze(new Matrix4());
function deepMerge(o, ...i) {
  if (!i.length)
    return o;
  const e = i.shift();
  if (isObject(o) && isObject(e))
    for (const r in e)
      isObject(e[r]) && e[r].constructor === Object ? (o[r] || Object.assign(o, {
        [r]: {}
      }), deepMerge(o[r], e[r])) : Object.assign(o, {
        [r]: e[r]
      });
  return deepMerge(o, ...i);
}
function clone$2(o, i = !1) {
  if (o === null || typeof o != "object")
    return o;
  const e = new o.constructor();
  for (const r in o)
    if (o.hasOwnProperty(r)) {
      let s = o[r];
      i && (s = clone$2(s, i)), e[r] = s;
    }
  return e;
}
function combine$1(o, i, e) {
  e = defaultValue$1(e, !1);
  const r = {}, s = defined$2(o), a = defined$2(i);
  let c, l, h;
  if (s)
    for (c in o)
      o.hasOwnProperty(c) && (l = o[c], a && e && typeof l == "object" && i.hasOwnProperty(c) ? (h = i[c], typeof h == "object" ? r[c] = combine$1(l, h, e) : r[c] = l) : r[c] = l);
  if (a)
    for (c in i)
      i.hasOwnProperty(c) && !r.hasOwnProperty(c) && (h = i[c], r[c] = h);
  return r;
}
const object = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isObject,
  isNumber,
  defined: defined$2,
  defaultValue: defaultValue$1,
  deepMerge,
  clone: clone$2,
  combine: combine$1
}, Symbol.toStringTag, { value: "Module" }));
let baseUrl = null;
function getBaseUrl() {
  if (baseUrl !== null)
    return baseUrl;
  let o = "";
  if (typeof MAPV_BASE_URL == "string" ? o = MAPV_BASE_URL : o = getBaseUrlFromScript(), !o)
    throw new Error("Unable to determine base URL automatically, try defining a global variable called MAPV_BASE_URL.");
  return baseUrl = o, o;
}
const mapvScriptRegex = /((?:.*\/)|^)mapvthree(\.bmap)?\.(es|umd)\.js(?:\?|\#|$)/;
function getBaseUrlFromScript() {
  if (typeof document > "u")
    return;
  let o = document.getElementsByTagName("script");
  for (let i = 0, e = o.length; i < e; ++i) {
    let r = o[i].getAttribute("src"), s = mapvScriptRegex.exec(r);
    if (s !== null)
      return s[1];
  }
}
function getAssetUrl(...o) {
  return urlJoin(getBaseUrl(), ...o);
}
function getAbsoluteUri(o, i) {
  let e;
  if (typeof document < "u" && (e = document), !defined$2(i)) {
    if (typeof e > "u")
      return o;
    i = defaultValue$1(e.baseURI, e.location.href);
  }
  const r = new Uri(o);
  return r.scheme() !== "" ? r.toString() : r.absoluteTo(i).toString();
}
function getExtensionFromUri(o) {
  const i = new Uri(o);
  i.normalize();
  let e = i.path(), r = e.lastIndexOf("/");
  return r !== -1 && (e = e.substr(r + 1)), r = e.lastIndexOf("."), r === -1 ? e = "" : e = e.substr(r + 1), e;
}
function getBaseUri(o, i) {
  let e = "";
  const r = o.lastIndexOf("/");
  return r !== -1 && (e = o.substring(0, r + 1)), i && (o = new Uri(o), o.query().length !== 0 && (e += `?${o.query()}`), o.fragment().length !== 0 && (e += `#${o.fragment()}`)), e;
}
const urlUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getBaseUrl,
  getAssetUrl,
  getAbsoluteUri,
  getExtensionFromUri,
  getBaseUri
}, Symbol.toStringTag, { value: "Module" }));
class GradientColorLerp {
  constructor(i) {
    if (!i || i.length === 0)
      throw new Error("points is required");
    const e = i[0][1];
    e.isColor ? this._isColorFormat = !0 : e.isVector3 && (this._isVectorFormat = !0), this._points = i;
  }
  lerp(i, e) {
    if (i <= 0)
      return this._points[0][1];
    if (i >= 1)
      return this._points[this._points.length - 1][1];
    let r = 0;
    for (; r < this._points.length && !(i <= this._points[r][0]); r++)
      ;
    if (i > this._points[this._points.length - 1][0])
      return this._points[this._points.length - 1][1];
    const [s, a] = this._points[r - 1], [c, l] = this._points[r], h = (i - s) / (c - s);
    if (this._isVectorFormat) {
      const d = a.x + (l.x - a.x) * h, f = a.y + (l.y - a.y) * h, p = a.z + (l.z - a.z) * h;
      return e || (e = new Vector3$1()), e.set(d, f, p), e;
    } else if (this._isColorFormat) {
      const d = a.r + (l.r - a.r) * h, f = a.g + (l.g - a.g) * h, p = a.b + (l.b - a.b) * h;
      return e || (e = new Color()), e.set(d, f, p), e;
    }
    return a + (l - a) * h;
  }
}
class EmptySky extends Group {
  constructor(e = {}) {
    super();
    _(this, "isEmptySky", !0);
    _(this, "name", "EmptySky");
    _(this, "_addDefaultEnvMap", !1);
    _(this, "_time", -1);
    _(this, "_timeRatio", 10 / 24);
    _(this, "_skyLightIntensity", 1.2);
    _(this, "_sunLightIntensity", 2.2);
    _(this, "_skyLightAttenuationRatio", 0.2);
    _(this, "_sunIntensityBias", 0);
    _(this, "_sunIntensityScale", 0.8);
    _(this, "_envLightIntensity", 0.2);
    _(this, "_weather", "partlyCloudy");
    _(this, "_timeChangedListeners", []);
    _(this, "_sunDirection", new Vector3$1());
    _(this, "_localSunDirection", new Vector3$1());
    _(this, "_sunLightColorDay", new Color(16777215));
    _(this, "_sunLightColorSunset", new Color(15090944));
    _(this, "_sunLightColorCurrent", new Color(16777215));
    _(this, "_sunRadian", null);
    _(this, "_skyLightColorDay", new Color(16777215));
    _(this, "_skyLightColorNight", new Color(16777215));
    _(this, "_groundLightColorDay", new Color(16777215));
    _(this, "_groundLightColorNight", new Color(16758093));
    _(this, "_lightNeedsUpdate", !0);
    _(this, "_sunNeedsUpdate", !1);
    _(this, "_affectWorld", !1);
    _(this, "_presetWeatherProperties", {
      clear: {
        sunLightIntensity: 2.5,
        skyLightIntensity: 1.2
      },
      partlyCloudy: {
        sunLightIntensity: 2.2,
        skyLightIntensity: 1.2
      },
      cloudy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      overcast: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      foggy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      rainy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      snowy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      stormy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      }
    });
    _(this, "updateSunLightShadowCamera", () => {
      const e = this.engine;
      if (!e.renderer.shadowMap.enabled) {
        const r = this.sunLight;
        r.position.copy(this._sunDirection), r.target.position.set(0, 0, 0), r.updateMatrix(), r.updateMatrixWorld(), r.target.updateMatrix(), r.target.updateMatrixWorld();
        return;
      }
      e.rendering.shadow.updateShadow(this.sunLight, this._sunDirection, this);
    });
    const r = this.sunLight = new DirectionalLight(16777215, 0.6), s = this.skyLight = new AmbientLight(16755200, this._skyLightIntensity);
    s.position.set(0, 0, 1), r.castShadow = !0, r.shadow.mapSize = new Vector2$1(2048, 2048), r.shadow.bias = -1e-4, this.add(r), this.add(r.target), this.add(s), r.matrixAutoUpdate = !1, r.target.matrixAutoUpdate = !1, this._sunLightGradientColorLerp = new GradientColorLerp([
      [0, new Color("#395e8c")],
      [5.5 / 24, new Color("#395e8c")],
      [6 / 24, new Color("#ff0000")],
      [6.5 / 24, new Color("#fad277")],
      [7.5 / 24, new Color("#ffffff")],
      [12 / 24, new Color("#ffffff")]
    ]), this.envLightIntensity = 0.1, e.time !== void 0 && (this._time = e.time);
  }
  afterAddToEngine(e) {
    if (this.engine = e, !this.isDynamicSky && !this.isStaticSky && this._addDefaultEnvMap) {
      const s = new TextureLoader().load(getAssetUrl("assets/textures/sky/partlyCloudy_default.jpg"));
      s.mapping = EquirectangularReflectionMapping, s.colorSpace = SRGBColorSpace, e.rendering.scene.environment = s;
    }
    this.envLightIntensity = this._envLightIntensity;
  }
  _syncTimeFromClock() {
    const e = this.engine.clock.currentTime, r = this._time;
    this._time = e.getHours() * 3600 + e.getMinutes() * 60 + e.getSeconds(), this._timeRatio = this._time / 86400, this._timeChanged = r !== this._time;
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  onBeforeScenePrepareRender() {
    if (this._syncTimeFromClock(), (this._timeChanged || this._lightNeedsUpdate) && (this.updateLight(), this._lightNeedsUpdate = !1), this.updateSunLightShadowCamera(), this._timeChanged) {
      this._updateSunDirection(), this.onTimeChanged(this._time);
      for (const e of this._timeChangedListeners)
        e(this.time);
      this._timeChanged = !1;
    }
  }
  updateLight() {
    this.sunLight.intensity = this._sunLightIntensity, this.isCustomStaticSky ? this.skyLight.intensity = 0 : (this.skyLight.intensity = this._skyLightIntensity, this.skyLight.color.copy(this._skyLightColorDay)), this._sunLightColorCurrent = this._sunLightGradientColorLerp.lerp(this._timeRatio > 0.5 ? 1 - this._timeRatio : this._timeRatio), this.sunLight.color.copy(this._sunLightColorCurrent);
  }
  _updateSunDirection() {
    const e = this._time;
    if (this.engine && this.engine.map.isGlobe) {
      const s = this._sunRadian = (e / 86400 + 0.25) * Math.PI * 2, a = Math.cos(s), c = Math.sin(s);
      this._sunDirection.set(a, -c, 0), this._localSunDirection.set(-a, -c, 0);
    } else {
      const s = (e / 86400 - 0.25) * Math.PI * 2, a = Math.cos(s), c = Math.sin(s);
      this._localSunDirection.set(a, c, 0), this._sunDirection.set(a, 0, c), c < -0.1 && this._sunDirection.negate();
    }
  }
  addTimeChangedListener(e) {
    this._timeChangedListeners.indexOf(e) === -1 && this._timeChangedListeners.push(e);
  }
  removeTimeChangedListener(e) {
    const r = this._timeChangedListeners.indexOf(e);
    r !== -1 && this._timeChangedListeners.splice(r, 1);
  }
  onTimeChanged(e) {
  }
  onWeatherChanged(e) {
  }
  getPresetWeatherProperties(e) {
    return this._presetWeatherProperties[e];
  }
  dispose() {
  }
  get time() {
    return this._time;
  }
  set time(e) {
    console.warn("Sky.time is deprecated, please use engine.clock.currentTime instead"), this.engine.clock._setTimeLegacy(e);
  }
  get sunIntensityBias() {
    return this._sunIntensityBias;
  }
  set sunIntensityBias(e) {
    this._sunIntensityBias = e, this._lightNeedsUpdate = !0;
  }
  get sunIntensityScale() {
    return this._sunIntensityScale;
  }
  set sunIntensityScale(e) {
    this._sunIntensityScale = e, this._lightNeedsUpdate = !0;
  }
  get sunLightIntensity() {
    return this._sunLightIntensity;
  }
  set sunLightIntensity(e) {
    this._sunLightIntensity = e, this._lightNeedsUpdate = !0;
  }
  get skyLightIntensity() {
    return this._skyLightIntensity;
  }
  set skyLightIntensity(e) {
    this._skyLightIntensity = e, this._lightNeedsUpdate = !0;
  }
  get skyLightAttenuationRatio() {
    return this._skyLightAttenuationRatio;
  }
  set skyLightAttenuationRatio(e) {
    this._skyLightAttenuationRatio = e, this._lightNeedsUpdate = !0;
  }
  get sunDirection() {
    return this._sunDirection;
  }
  get localSunDirection() {
    return this._localSunDirection;
  }
  get affectWorld() {
    return this._affectWorld;
  }
  get envLightIntensity() {
    return this._envLightIntensity;
  }
  set envLightIntensity(e) {
    this._envLightIntensity = e, this.engine && (this.engine.renderer.envMapIntensity = e);
  }
}
class Pass {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const _camera$1 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
class FullscreenTriangleGeometry extends BufferGeometry {
  constructor() {
    super(), this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
}
const _geometry = new FullscreenTriangleGeometry();
class FullScreenQuad {
  constructor(i) {
    this._mesh = new Mesh(_geometry, i);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(i) {
    i.render(this._mesh, _camera$1);
  }
  get material() {
    return this._mesh.material;
  }
  set material(i) {
    this._mesh.material = i;
  }
}
const CopyShader = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
}, bufferVertexShader = `#define GLSLIFY 1
varying vec2 vUv;
void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`, mainVertShader$1 = `#define GLSLIFY 1
varying vec3 vWorldPosition;
varying vec2 vUv;
void main() {
    vUv = uv;
    //vWorldPosition = normalize(vec3(modelMatrix * vec4(position, 1.0)) - cameraPosition);
    vWorldPosition = normalize(vec3(position.x, position.y, position.z));
    // vWorldPosition = normalize(position);
    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.z = gl_Position.w;
}
`, commonFragShader$1 = `#define GLSLIFY 1
const float PI = 3.14159265358;

// Units are in megameters.
const float groundRadiusMM = 6.371 * 1.0;
const float atmosphereRadiusMM = 6.471 * 1.0;
const float maxSampleLength = 2.267;

const vec2 tLUTRes = vec2(256.0, 64.0)*1.;
const vec2 msLUTRes = vec2(32.0, 32.0)*1.;
const vec2 skyLUTRes = vec2(200.0, 200.0)*2.;

const vec3 groundAlbedo = vec3(0.1);

// These are per megameter.
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
const float rayleighAbsorptionBase = 0.0;

const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;

const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);

// Quality
const float sunTransmittanceSteps = 40.0;
const float mulScattSteps = 20.0;
const int sqrtSamples = 8;

const int numScatteringSteps = 16;

uniform float altitude;
uniform float viewHeight;
/*
 * Animates the sun movement.
 */
float getSunAltitude(float time)
{
    const float periodSec = 10.0;
    return (PI)*time/periodSec - PI/24.;
}
vec3 getSunDir(float time)
{
    // float altitude = getSunAltitude(time);
    // altitude = 2.8;
    return normalize(vec3(cos(altitude), sin(altitude), 0.0));
    // return normalize(vec3(0.0, sin(altitude), -cos(altitude)));

}

/* Animate camera */
vec3 getViewPos(float time){

    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0000 + viewHeight, 0.0);

    // anything beyond about 7 falls apart because the skyview lut doesn't have enough resolution
    float alt_range = 50.0;

    // viewPos.y += (sin(time/10.0 - PI/2.)*.5+.5) * (atmosphereRadiusMM - groundRadiusMM) * alt_range;

    return viewPos;
}

float getMiePhase(float cosTheta) {
    const float g = 0.8;
    const float scale = 3.0/(8.0*PI);

    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);
    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);

    return scale*num/denom;
}

float getRayleighPhase(float cosTheta) {
    const float k = 3.0/(16.0*PI);
    return k*(1.0+cosTheta*cosTheta);
}

void getScatteringValues(vec3 pos,
                         out vec3 rayleighScattering,
                         out float mieScattering,
                         out vec3 extinction) {
    float altitudeKM = (length(pos)-groundRadiusMM)*1000.0;
    // Note: Paper gets these switched up.
    float rayleighDensity = exp(-altitudeKM/8.0);
    float mieDensity = exp(-altitudeKM/1.2);

    rayleighScattering = rayleighScatteringBase*rayleighDensity;
    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;

    mieScattering = mieScatteringBase*mieDensity;
    float mieAbsorption = mieAbsorptionBase*mieDensity;

    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);

    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;
}

float safeacos(const float x) {
    return acos(clamp(x, -1.0, 1.0));
}

// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.
float rayIntersectSphere(vec3 ro, vec3 rd, float rad) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - rad*rad;
    if (c > 0.0 && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    // Special case: inside sphere, use far discriminant
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}

// From https://www.shadertoy.com/view/wlBXWK
vec2 rayIntersectSphere2D(
    vec3 start, // starting position of the ray
    vec3 dir, // the direction of the ray
    float radius // and the sphere radius
) {
    // ray-sphere intersection that assumes
    // the sphere is centered at the origin.
    // No intersection when result.x > result.y
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (radius * radius);
    float d = (b*b) - 4.0*a*c;
    if (d < 0.0) return vec2(1e5,-1e5);
    return vec2(
        (-b - sqrt(d))/(2.0*a),
        (-b + sqrt(d))/(2.0*a)
    );
}

/*
 * Same parameterization here.
 */
vec3 getValFromTLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {
    float height = length(pos);
    vec3 up = pos / height;
	float sunCosZenithAngle = dot(sunDir, up);
    vec2 uv = vec2(tLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),
                   tLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));
    uv /= bufferRes;
    // return pos;
    return texture2D(tex, uv).rgb;
}
vec3 getValFromMultiScattLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {
    float height = length(pos);
    vec3 up = pos / height;
	float sunCosZenithAngle = dot(sunDir, up);
    vec2 uv = vec2(msLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),
                   msLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));
    uv /= bufferRes;
    return texture2D(tex, uv).rgb;
}

/* 
 * Do raymarching : builds skyview lut inside atmoshpere, raymarches directly outside atmosphere
*/

vec3 raymarchScattering(sampler2D TLUT, vec2 TLUT_size, sampler2D MSLUT, vec2 MSLUT_size,
                              vec3 viewPos,
                              vec3 rayDir,
                              vec3 sunDir,
                              float numSteps,
                              float maxDistance) {
                              
                              
    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);
    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);

    float mindist, maxdist;

    if (atmos_intercept.x < atmos_intercept.y){
        // there is an atmosphere intercept!
        // start at the closest atmosphere intercept
        // trace the distance between the closest and farthest intercept
        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;
		maxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;
    } else {
        // no atmosphere intercept means no atmosphere!
        return vec3(0.0);
    }

    // if in the atmosphere start at the camera
    if (length(viewPos) < atmosphereRadiusMM) mindist=0.0;

    // if there's a terra intercept that's closer than the atmosphere one,
    // use that instead!
    if (terra_intercept > 0.0){ // confirm valid intercepts			
        maxdist = terra_intercept;
    }

    // start marching at the min dist
    vec3 pos = viewPos + mindist * rayDir;

    float cosTheta = dot(rayDir, sunDir);

	float miePhaseValue = getMiePhase(cosTheta);
	float rayleighPhaseValue = getRayleighPhase(-cosTheta);

    float diff = maxdist - mindist;

    diff = min((maxDistance - mindist), diff);

    vec3 lum = vec3(0.0);
    vec3 transmittance = vec3(1.0);
    float t = 0.0;

    // \u6700\u5C0F\u91C7\u6837\u6570\u8BBE\u7F6E\u4E3AnumSteps / 2.0,\u56E0\u4E3A\u91C7\u6837\u6570\u8D8A\u5C0F,\u589E\u52A0\u91C7\u6837\u70B9\u6548\u679C\u53D8\u5316\u8D8A\u5927
    float steps = max(numSteps / 2.0, floor(numSteps * (diff / maxSampleLength)));
    for (int fi = 0; fi < 100; fi++) {
        float i = float(fi);
        if (i >= steps) break;

        float newT = ((i + 0.3)/steps)*diff;
        float dt = newT - t;
        t = newT;

        vec3 newPos = pos + t*rayDir;

        vec3 rayleighScattering, extinction;
        float mieScattering;
        
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

        vec3 sampleTransmittance = exp(-dt*extinction);

        vec3 sunTransmittance = getValFromTLUT(TLUT, TLUT_size, newPos, sunDir);
        vec3 psiMS = getValFromMultiScattLUT(MSLUT, MSLUT_size, newPos, sunDir);

        vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);
        vec3 mieInScattering = mieScattering*(miePhaseValue*sunTransmittance + psiMS);
        vec3 inScattering = (rayleighInScattering + mieInScattering);

        // Integrated scattering within path segment.
        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

        lum += scatteringIntegral*transmittance;

        transmittance *= sampleTransmittance;
    }
    return lum;
}

vec3 getValFromSkyLUT(sampler2D viewTexture, vec3 viewPos, vec3 rayDir, vec3 sunDir) {

    float height = length(viewPos);
    vec3 up = viewPos / height;

    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);
    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2
    float azimuthAngle; // Between 0 and 2*PI

    vec3 right = cross(sunDir, up);
    vec3 forward = cross(up, right);

    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));
    float sinTheta = dot(projectedDir, right);
    float cosTheta = dot(projectedDir, forward);
    azimuthAngle = atan(sinTheta, cosTheta) + PI;

    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.
    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);
    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);
    // uv *= skyLUTRes;
    // uv /= viewResolution.xy;

    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);;
    return texture2D(viewTexture, uv).rgb;
}

vec3 jodieReinhardTonemap(vec3 c) {
    // From: https://www.shadertoy.com/view/tdSXzD
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);
    return mix(c / (l + 1.0), tc, tc);
}

vec4 toLinear(vec4 sRGB) {
    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
    vec4 lower = sRGB/vec4(12.92);

    // return mix(higher, lower, cutoff);
    // \u4F7F\u7528\u6761\u4EF6\u64CD\u4F5C\u7B26\u66FF\u4EE3 mix \u51FD\u6570
    return vec4(
        cutoff.x ? lower.x : higher.x,
        cutoff.y ? lower.y : higher.y,
        cutoff.z ? lower.z : higher.z,
        cutoff.w ? lower.w : higher.w
    );
}

vec4 colorSpaceTransform(vec4 color) {
    #ifdef USE_OPAQUE_POST_STAGE
        return toLinear(color);
    #else
        return color;
    #endif
}`, mainFragShader$1 = `#define GLSLIFY 1
/*
 * Modified version of Andrew Helmer's https://www.shadertoy.com/view/slSXRW 
 * implementation of Sebastian Hillare's Unreal engine sky-atmosphere
 * ... still doesn't implement aerial perspective lut, just makes space views possible
 * TODO: replace sunflare with something new that works
        allow density profiles, and thicker atmospheres (fails beyond 7.1 right now)
 */

/*
 * Final output basically looks up the value from the skyLUT, and then adds a sun on top,
 * does some tonemapping.
 */
#include <common>
varying vec2 vUv;
varying vec3 vWorldPosition;
uniform sampler2D transmittanceTexture;
uniform vec2 transmittanceResolution;
uniform sampler2D viewTexture;
uniform vec2 viewResolution;
uniform sampler2D scatteringTexture;
uniform vec2 scatteringResolution;
uniform vec2 iResolution;
uniform vec3 cameraDirection;
uniform vec3 upDirection;
uniform float uTime;
uniform bool uStarVisible;
uniform sampler2D uMoonMap;

const int star_iterations = 10;
const vec3 col_star = vec3( .8, 0.8, 0.7 );

const vec3 grayColor = vec3(0.5, 0.5, 0.5);

vec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {
    const float sunSolidAngle = 0.01*PI/180.0;
    const float minSunCosTheta = cos(sunSolidAngle);

    float cosTheta = dot(rayDir, sunDir);
    if (cosTheta >= minSunCosTheta) return vec3(1.0);

    float offset = minSunCosTheta - cosTheta;
    float gaussianBloom = exp(-offset*50000.0)*0.5;
    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;
    return vec3(gaussianBloom+invBloom);
}

float hash( float n ) { return fract(sin(n)*123.456789); }

vec2 rotate( in vec2 uv, float a) {
    float c = cos( a );
    float s = sin( a );
    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );
}

float noise( in vec3 p ) {
    vec3 fl = floor( p );
    vec3 fr = fract( p );
    fr = fr * fr * ( 3.0 - 2.0 * fr );

    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;
    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),
                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),
                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),
                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );
}

float fbm( in vec2 p, float t ) {
    float f;
    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;
    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;
    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;
    f += 0.0625 * noise( vec3( p, t ) );
    return f;
}

float fbmByTexture( vec2 p ) {
    return 0.5000 * texture2D( uMoonMap, p * 1.00 ).x + 
        0.2500 * texture2D( uMoonMap, p * 2.02 ).x + 
        0.1250 * texture2D( uMoonMap, p * 4.03 ).x + 
        0.0625 * texture2D( uMoonMap, p * 8.04 ).x;
}

// moon
vec3 moonWithBloom(vec3 rayDir, vec3 moonDir) {
    const float sunSolidAngle = .6 * PI / 180.0;
    const float minSunCosTheta = cos(sunSolidAngle);

    float cosTheta = dot(rayDir, moonDir);
    vec3 differ = rayDir - moonDir;
    if (cosTheta >= minSunCosTheta) {
        vec3 moon = vec3(0.98,0.97,0.95);
        // \u6708\u7403\u8000\u6591
        moon *= (0.30 + 0.4 * fbmByTexture(vec2(1.0) + vec2(0.2 + differ.xz + differ.yx)));

        return moon;
    }

    float offset = minSunCosTheta - cosTheta;
    float gaussianBloom = exp(-offset * 50000.0) * 0.5;
    float invBloom = 1.0 / (0.05 + offset * 300.0) * 0.01;
    return vec3(gaussianBloom+invBloom);
}

// \u661F\u7A7A\u80CC\u666F
vec3 doBackgroundStars( in vec3 dir ) {
    vec3 n  = abs( dir );
    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: 
            ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:
                                        dir.xy / dir.z;
    
    float f = 0.0;
    
    for( int i = 0 ; i < star_iterations; ++i ) {
        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );
        
        float t = 10. * uv.x * uv.y + uTime;
        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );
        f += smoothstep( 0.534, 0.535, u.x * u.y );
    }
    
    return f * col_star;
}

vec3 render( in vec2 uv, mat3 m ) {
    //create view ray
    vec3 rd  = m * normalize( vec3( uv, 1.0 ) );
    
    // background stars
    vec3 c = doBackgroundStars( rd );
    return c;
}

// vec4 toLinear(vec4 sRGB) {
//     bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
//     vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
//     vec4 lower = sRGB/vec4(12.92);

//     // return mix(higher, lower, cutoff);
//     // \u4F7F\u7528\u6761\u4EF6\u64CD\u4F5C\u7B26\u66FF\u4EE3 mix \u51FD\u6570
//     return vec4(
//         cutoff.x ? lower.x : higher.x,
//         cutoff.y ? lower.y : higher.y,
//         cutoff.z ? lower.z : higher.z,
//         cutoff.w ? lower.w : higher.w
//     );
// }

void main() {
    vec3 sunDir = getSunDir(0.);
    vec3 viewPos = getViewPos(0.);

    vec3 camDir = normalize(cameraDirection);
    float camFOVWidth = PI/3.0;
    // vec2 iResolution = vec2(1102, 1246);
    float camWidthScale = 2.0*tan(camFOVWidth/2.0);
    float camHeightScale = camWidthScale*iResolution.y/iResolution.x;

    vec3 camRight = normalize(cross(camDir, upDirection));
    vec3 camUp = normalize(cross(camRight, camDir));

    // camRight = viewMatrix[0].xzy;
    // camUp = viewMatrix[1].xzy;
    // camDir = viewMatrix[2].xzy;
    // vec2 xy = 2.0 * vWorldPosition.xy; // 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;
    vec2 xy = vWorldPosition.xy; // 2.0 * (gl_FragCoord.xy / iResolution.xy / 2.0) - 1.0;
    // vec3 rayDir = normalize(camDir + camRight*xy.x*camWidthScale + camUp*xy.y*camHeightScale);
    vec3 rayDir = normalize(vWorldPosition.xzy);
    vec3 lum;

    if (length(viewPos) < atmosphereRadiusMM * 1.0){
        lum = getValFromSkyLUT(viewTexture, viewPos, rayDir, sunDir);
    } else {
    
        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere
        lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,
                                scatteringTexture, scatteringResolution.xy,
                                viewPos, rayDir, sunDir, float(numScatteringSteps), 10e5);
        
        // This little bit of red helps to debug when the rendering switches to pure raymarching
        // lum += vec3(1e-3,0.0,0.0);
    }

    // Tonemapping and gamma. Super ad-hoc, probably a better way to do this.
    lum *= 100.0;
    lum = jodieReinhardTonemap(lum);
    lum = pow(lum, vec3(1.0/2.2));

    // lum += sunWithBloom(rayDir, sunDir);
    // Bloom should be added at the end, but this is subtle and works well.
    vec3 sunLum = sunWithBloom(rayDir, sunDir);
    // Use smoothstep to limit the effect, so it drops off to actual zero.
    sunLum = smoothstep(0.002, 1.0, sunLum);
    if (length(sunLum) > 0.0) {
        if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {
            sunLum *= 0.0;
        } else {
            // If the sun value is applied to this pixel, we need to calculate the transmittance to obscure it.
            sunLum *= getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, viewPos, sunDir);
        }
    }
    lum += sunLum;

    if (sunDir.y < 0.0) {
        vec2 uv = vUv - vec2(0.5);
        
        vec3 ww = normalize(vec3(1.04, 0.0, 2.628));
        vec3 uu = normalize( cross( ww, vec3( 0.0, 1.0, 0.0 ) ) );
        vec3 vv = normalize( cross( uu, ww ) );
        mat3 m = mat3( uu, vv, ww );

        // \u661F\u7A7A
        if (rayDir.y > 0.0 && uStarVisible) {
            // \u80CC\u666F\u521D\u59CB\u5316\u989C\u8272\uFF0C\u6E10\u53D8\u84DD\u9ED1\u8272
            lum += vec3( 0.035, 0.055, 0.085 );
            lum += vec3( 0.02, 0.05, 0.15 ) * (1. - rayDir.y);

            vec3 c = render( fract(uv * 30.0), m );

            // c = pow( c, vec3( 0.4545 ) );

            // \u661F\u7A7A\u95EA\u70C1
            float time = uTime / 20000.0;
            float twinkle = sin((uv.x-time+cos(uv.y*20.+time))*20.);
            twinkle *= cos((uv.y*.234-time*3.24+sin(uv.x*12.3+time*.243))*7.34);
            twinkle = (twinkle + 1.)/2.;
            lum += c * twinkle * (rayDir.y * 10.0) * (1.0 - pow(max(0.0, abs(-sunDir.y - 1.0) * 2.0 - 1.0), 2.0));
        }

        // \u6708\u4EAE
        vec3 moonLum = moonWithBloom(rayDir, -sunDir) * 2.0;
        if (length(moonLum) > 0.0) {
            float alpha = clamp(smoothstep(0.0, 0.2, rayDir.y), 0.01, 1.0);
            moonLum *= alpha;
        }
        lum += moonLum;

    }

    gl_FragColor = vec4(lum, 1.0);
    gl_FragColor = toLinear(gl_FragColor);

    // gl_FragColor.rgb = vWorldPosition;
    // float viewDistance = sqrt(length(vec3(rayDir.x * 10., 0.1, rayDir.z * 10.)));
    // vec2 cloudUV = rayDir.xz * viewDistance; //rayDir.xy * length(rayDir);
    // // cloudUV *= mix(1., 10., clamp(sqrt(rayDir.x * rayDir.x + rayDir.y * rayDir.y), 0.0, 1.0));
    // float cloudDensity = texture2D(tWeather, cloudUV * 10.0).x;
    // gl_FragColor.xy = (rayDir.xy + 1.0) * 0.5;
    // gl_FragColor.z += cloudDensity;
    // Peek at the Transmittance LUT
    // if (gl_FragCoord.x < skyLUTRes.x && gl_FragCoord.y < skyLUTRes.y) {
        // gl_FragColor = vec4(8.*texture(viewTexture, gl_FragCoord.xy/skyLUTRes * 0.2).rgb,1.0);
    // }
    // fragColor = vec4(100.*texture(transmittanceTexture, fragCoord.xy/iResolution.xy).rgb,1.0);

    // Peek at the Sky View LUT
    // gl_FragColor = vec4(8.*texture(viewTexture, gl_FragCoord.xy/iResolution.xy / 2.).rgb,1.0);

    // Peek at the Multiscattering LUT
    // fragColor = vec4(100.*texture(scatteringTexture, fragCoord.xy/iResolution.xy).rgb,1.0);
    // if (gl_FragCoord.x < msLUTRes.x && gl_FragCoord.y < msLUTRes.y) {
    //     gl_FragColor = vec4(100.*texture(scatteringTexture, gl_FragCoord.xy/iResolution / 2.).rgb,1.0);
    // }
    // gl_FragColor = vec4(100.*texture(transmittanceTexture, gl_FragCoord.xy/transmittanceResolution * 0.1).rgb,1.0);
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`, transmittanceFragShader = `#define GLSLIFY 1
// Buffer A generates the Transmittance LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and
// the value is the transmittance from that point to sun, through the atmosphere.
varying vec2 vUv;
vec3 getSunTransmittance(vec3 pos, vec3 sunDir) {
    if (rayIntersectSphere(pos, sunDir, groundRadiusMM) > 0.0) {
        return vec3(0.0);
    }

    float atmoDist = rayIntersectSphere(pos, sunDir, atmosphereRadiusMM);
    float t = 0.0;

    vec3 transmittance = vec3(1.0);
    for (float i = 0.0; i < sunTransmittanceSteps; i += 1.0) {
        float newT = ((i + 0.3)/sunTransmittanceSteps)*atmoDist;
        float dt = newT - t;
        t = newT;

        vec3 newPos = pos + t*sunDir;

        vec3 rayleighScattering, extinction;
        float mieScattering;
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

        transmittance *= exp(-dt*extinction);
    }
    return transmittance;
}

void main() {
    // if (gl_FragCoord.x >= (tLUTRes.x+1.5) || gl_FragCoord.y >= (tLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(gl_FragCoord.x, 0.0, tLUTRes.x-1.0)/tLUTRes.x;
    float v = vUv.y; // clamp(gl_FragCoord.y, 0.0, tLUTRes.y-1.0)/tLUTRes.y;

    float sunCosTheta = 2.0*u - 1.0;
    float sunTheta = safeacos(sunCosTheta);
    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);

    vec3 pos = vec3(0.0, height, 0.0);
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));

    gl_FragColor = vec4(getSunTransmittance(pos, sunDir), 1.0);
}
`, scatteringFragShader = `#define GLSLIFY 1
// Buffer B is the multiple-scattering LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and
// the value is the multiple scattering approximation (Psi_ms from the paper, Eq. 10).
varying vec2 vUv;
uniform sampler2D transmittanceTexture;
uniform vec2 transmittanceResolution;
vec3 getSphericalDir(float theta, float phi) {
     float cosPhi = cos(phi);
     float sinPhi = sin(phi);
     float cosTheta = cos(theta);
     float sinTheta = sin(theta);
     return vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);
}

// Calculates Equation (5) and (7) from the paper.
void getMulScattValues(vec3 pos, vec3 sunDir, out vec3 lumTotal, out vec3 fms) {
    lumTotal = vec3(0.0);
    fms = vec3(0.0);

    float invSamples = 1.0/float(sqrtSamples*sqrtSamples);
    for (int i = 0; i < sqrtSamples; i++) {
        for (int j = 0; j < sqrtSamples; j++) {
            // This integral is symmetric about theta = 0 (or theta = PI), so we
            // only need to integrate from zero to PI, not zero to 2*PI.
            float theta = PI * (float(i) + 0.5) / float(sqrtSamples);
            float phi = safeacos(1.0 - 2.0*(float(j) + 0.5) / float(sqrtSamples));
            vec3 rayDir = getSphericalDir(theta, phi);

            float atmoDist = rayIntersectSphere(pos, rayDir, atmosphereRadiusMM);
            float groundDist = rayIntersectSphere(pos, rayDir, groundRadiusMM);
            float tMax = atmoDist;
            if (groundDist > 0.0) {
                tMax = groundDist;
            }

            float cosTheta = dot(rayDir, sunDir);

            float miePhaseValue = getMiePhase(cosTheta);
            float rayleighPhaseValue = getRayleighPhase(-cosTheta);

            vec3 lum = vec3(0.0), lumFactor = vec3(0.0), transmittance = vec3(1.0);
            float t = 0.0;
            for (float stepI = 0.0; stepI < mulScattSteps; stepI += 1.0) {
                float newT = ((stepI + 0.3)/mulScattSteps)*tMax;
                float dt = newT - t;
                t = newT;

                vec3 newPos = pos + t*rayDir;

                vec3 rayleighScattering, extinction;
                float mieScattering;
                getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

                vec3 sampleTransmittance = exp(-dt*extinction);

                // Integrate within each segment.
                vec3 scatteringNoPhase = rayleighScattering + mieScattering;
                vec3 scatteringF = (scatteringNoPhase - scatteringNoPhase * sampleTransmittance) / extinction;
                lumFactor += transmittance*scatteringF;

                // This is slightly different from the paper, but I think the paper has a mistake?
                // In equation (6), I think S(x,w_s) should be S(x-tv,w_s).
                vec3 sunTransmittance = getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, newPos, sunDir);

                vec3 rayleighInScattering = rayleighScattering*rayleighPhaseValue;
                float mieInScattering = mieScattering*miePhaseValue;
                vec3 inScattering = (rayleighInScattering + mieInScattering)*sunTransmittance;

                // Integrated scattering within path segment.
                vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

                lum += scatteringIntegral*transmittance;
                transmittance *= sampleTransmittance;
            }

            if (groundDist > 0.0) {
                vec3 hitPos = pos + groundDist*rayDir;
                if (dot(pos, sunDir) > 0.0) {
                    hitPos = normalize(hitPos)*groundRadiusMM;
                    lum += transmittance*groundAlbedo*getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, hitPos, sunDir);
                }
            }

            fms += lumFactor*invSamples;
            lumTotal += lum*invSamples;
        }
    }
}

void main() {
    // if (fragCoord.x >= (msLUTRes.x+1.5) || fragCoord.y >= (msLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(fragCoord.x, 0.0, msLUTRes.x-1.0)/msLUTRes.x;
    float v = vUv.y; // clamp(fragCoord.y, 0.0, msLUTRes.y-1.0)/msLUTRes.y;

    float sunCosTheta = 2.0*u - 1.0;
    float sunTheta = safeacos(sunCosTheta);
    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);

    vec3 pos = vec3(0.0, height, 0.0);
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));

    vec3 lum, f_ms;
    getMulScattValues(pos, sunDir, lum, f_ms);

    // Equation 10 from the paper.
    vec3 psi = lum  / (1.0 - f_ms);
    gl_FragColor = vec4(1. * psi, 1.0);
    // gl_FragColor = vec4(vUv/ 1., 0.0, 1.0);
}
`, viewFragShader = `#define GLSLIFY 1
// Buffer C calculates the actual sky-view! It's a lat-long map (or maybe altitude-azimuth is the better term),
// but the latitude/altitude is non-linear to get more resolution near the horizon.
varying vec2 vUv;
uniform sampler2D transmittanceTexture;
uniform vec2 transmittanceResolution;
uniform sampler2D scatteringTexture;
uniform vec2 scatteringResolution;
uniform float mixGrayFactor;

void main() {
    // if (fragCoord.x >= (skyLUTRes.x+1.5) || fragCoord.y >= (skyLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(fragCoord.x, 0.0, skyLUTRes.x-1.0)/skyLUTRes.x;
    float v = vUv.y; // clamp(fragCoord.y, 0.0, skyLUTRes.y-1.0)/skyLUTRes.y;

    float azimuthAngle = (u - 0.5)*2.0*PI;

    // Non-linear mapping of altitude. See Section 5.3 of the paper.

    float adjV;
    if (v < 0.5) {
		float coord = 1.0 - 2.0*v;
		adjV = -coord*coord;
	} else {
		float coord = v*2.0 - 1.0;
		adjV = coord*coord;
	}

    vec3 viewPos = getViewPos(0.);

    float height = length(viewPos); vec3 up = viewPos / height;
    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5*PI;
    float altitudeAngle = adjV*0.5*PI - horizonAngle;

    float cosAltitude = cos(altitudeAngle);
    vec3 rayDir = vec3(cosAltitude*sin(azimuthAngle), sin(altitudeAngle), -cosAltitude*cos(azimuthAngle));

    float sunAltitude = (0.5*PI) - acos(dot(getSunDir(0.), up));
    vec3 sunDir = vec3(0.0, sin(sunAltitude), -cos(sunAltitude));

    vec3 lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,
                                  scatteringTexture, scatteringResolution.xy,
                                  viewPos, rayDir, sunDir, float(numScatteringSteps), 10e5);
    gl_FragColor = vec4(lum, 1.0);

    if (mixGrayFactor > 0.0) {
        lum = gl_FragColor.xyz;
        vec3 gray = vec3((lum.x + lum.y + lum.z) / 3.0);
        lum = mix(lum, gray, mixGrayFactor);
        gl_FragColor = vec4(lum, 1.0);
    }
}
`, postprocessingFragShader = `#define GLSLIFY 1
#include <mvt_depth_packing>
#include <packing>

varying vec2 vUv;
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
#if defined(MVT_USE_NORMAL_TEXTURE)
    uniform sampler2D tNormal;
#endif
uniform sampler2D tAtmosphere;
uniform float cameraNear;
uniform float cameraFar;
uniform mat4 projectionInverseMatrix;
uniform mat4 viewInverseMatrix;
uniform mat4 mvt_viewMatrix;
uniform sampler2D transmittanceTexture;
uniform vec2 transmittanceResolution;
uniform sampler2D viewTexture;
uniform vec2 viewResolution;
uniform sampler2D scatteringTexture;
uniform vec2 scatteringResolution;
uniform vec2 resolution;
uniform vec3 cameraDirection;
uniform vec3 sunDirection;
uniform bool isGlobe;
// uniform vec3 upDirection;
uniform vec2 fogDepthRange;
uniform mat3 rotationMatrix;

vec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {
    const float sunSolidAngle = 0.01*PI/180.0;
    const float minSunCosTheta = cos(sunSolidAngle);

    float cosTheta = dot(rayDir, sunDir);
    if (cosTheta >= minSunCosTheta) return vec3(1.0);

    float offset = minSunCosTheta - cosTheta;
    float gaussianBloom = exp(-offset*50000.0)*0.5;
    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;
    return vec3(gaussianBloom+invBloom);
}

void main() {
    vec4 diffuse = texelFetch(tDiffuse, ivec2(gl_FragCoord.xy), 0);
    float depthValue = texelFetch(tDepth, ivec2(gl_FragCoord), 0).x;
    // gl_FragColor = diffuse;
    // return;
    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);
    bool isTranslucent = diffuse.a < 1.0;
    if (diffuse.a < 1.0) {
        // // \u900F\u660E\u5EA6\u5C0F\u4E8E0.99\uFF0C\u4F7F\u7528\u6DF1\u5EA6\u503C
        // depthValue = 1.0;
        // depth = 1.0;
    }
    vec3 worldPosition = mvtGetWorldPositionByDepth(depth, vUv, projectionInverseMatrix, viewInverseMatrix); 
    vec3 viewPosition = mvtGetViewPositionByDepth(depth, vUv, projectionInverseMatrix);
    float viewDistance = length(viewPosition) / 100000.0;
    vec3 viewFrom = vec3(cameraPosition);

    vec3 viewTo = vec3(worldPosition.xy, 0.002);

    vec3 viewDir = normalize(viewTo - viewFrom);

    vec3 sunDir = sunDirection;
    vec3 viewPos = getViewPos(0.);

    float maxDistance = length(viewPosition) / 1000000.0;

    float camFOVWidth = 35.0 / 180.0 * PI;

    float camHeightScale = tan(camFOVWidth / 2.0);
    float camWidthScale = camHeightScale * resolution.x / resolution.y;

    vec3 camRight   = vec3( viewInverseMatrix[0][0],  viewInverseMatrix[0][1],  viewInverseMatrix[0][2]);
    vec3 camUp      = vec3( viewInverseMatrix[1][0],  viewInverseMatrix[1][1],  viewInverseMatrix[1][2]);
	vec3 camDir = vec3(-viewInverseMatrix[2][0], -viewInverseMatrix[2][1], -viewInverseMatrix[2][2]);

    vec2 nxy = vUv.xy * 2.0 - 1.0;
    vec3 rayDir = normalize(camDir + camRight * nxy.x * camWidthScale  + camUp * nxy.y * camHeightScale).xzy;

    vec3 lum;
    bool isInSpace = length(viewPos) > atmosphereRadiusMM * 1.0;
    float atmoFactor = 0.0;
    if (length(viewPos) < atmosphereRadiusMM * 1.0){
        // \u7981\u6B62\u534A\u900F\u660E\u50CF\u7D20\u53C2\u4E0E\u8BA1\u7B97raymarching
        if (depthValue < 0.99 && !isTranslucent) {
            lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,
                        scatteringTexture, scatteringResolution.xy,
                        viewPos, rayDir, sunDir, float(numScatteringSteps), maxDistance);
        }
        else {
            lum = getValFromSkyLUT(viewTexture, viewPos, rayDir, sunDir);
        }
        
    } else {
        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere
        lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,
                                scatteringTexture, scatteringResolution.xy,
                                viewPos, rayDir, sunDir, float(numScatteringSteps), 10e5);
        atmoFactor = clamp(lum.x * 30.0, 0.0, 1.0);
    }
    atmoFactor = clamp(lum.x * 30.0, 0.0, 1.0);
    lum *= 20.0;
    lum = jodieReinhardTonemap(lum);
    lum = pow(lum, vec3(1.0/2.2));

    if (depthValue > 0.99) {
        vec3 sunLum = vec3(0.0);
        sunLum = sunWithBloom(rayDir, sunDir);
        // Use smoothstep to limit the effect, so it drops off to actual zero.
        sunLum = smoothstep(0.002, 1.0, sunLum);
        if (length(sunLum) > 0.0) {
            if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {
                sunLum *= 0.0;
            }
        }
        lum += sunLum;
    }

    vec4 atmo = colorSpaceTransform(vec4(lum, 1.0));
    gl_FragColor = atmo;
 
    // \u4ECE50km\u9AD8\u5EA6\u5230100km\u9AD8\u5EA6\uFF0C\u5927\u6C14\u5C42\u9010\u6E10\u53D8\u6DE1
    float cameraHeight = cameraPosition.z;
    if (isGlobe) {
        cameraHeight = length(cameraPosition) - 6371000.0;
    }
    float ratio = 1.0 - clamp((cameraHeight - 50000.0) / 50000.0, 0.0, 1.0);
    ratio = 1.0;

    float viewRatio = 1.0;
    if (!isGlobe){
        viewRatio = 1.0 - dot(normalize(vec3(viewInverseMatrix[2])), vec3(0.0, 0.0, 1));
        viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);
    }

    float depthThreshold = mix(0.996, 0.992, clamp(cameraHeight / 100000.0, 0.0, 1.0));
    if (depthValue < depthThreshold && ratio > 0.0 && !isTranslucent) {

        float fogDepth = depthValue;
        float fogDensity = 1.;
        float fogStart = mix(0.8, 0.95, ratio);
        fogDepth = clamp((fogDepth - fogStart) / (1.0 - fogStart), 0.0, 1.0);
        
        float atmoFinalFactor = 0.0;
        if (isGlobe) {
            if (isInSpace) {
                atmoFinalFactor = atmoFactor;
            }
            else {
                float heightRatio = 1.0 - clamp(viewHeight * 10.0, 0.0, 1.0);
                heightRatio = heightRatio * heightRatio;
                float viewDepth = clamp((depthValue - fogDepthRange.x) / (fogDepthRange.y - fogDepthRange.x), 0.0, 1.0);
                viewDepth = 1.0 - exp(- 2.0 * viewDepth * viewDepth);
                atmoFinalFactor = mix(atmoFactor, viewDepth, heightRatio);
            }
        }
        else {
            atmoFinalFactor = fogDepth * ratio * viewRatio;
        }
        #if defined(MVT_DEBUG_INTENSITY)
            gl_FragColor = vec4(atmoFinalFactor, 0.0, 0.0, 1.0);
        #else
            gl_FragColor = mix(diffuse, atmo, atmoFinalFactor);
        #endif
    } 
    else {
        // \u6709\u989C\u8272\u7684\u533A\u57DF\u5FC5\u987B\u90FD\u5C1D\u8BD5\u53BB\u6DF7\u5408\uFF0C\u9700\u8981\u8003\u8651\u90E8\u5206depthTest\u5173\u95ED\u7684\u7269\u4F53\u4E5F\u9700\u8981\u663E\u793A
        if (diffuse.a > 0.001) {
            #if defined(MVT_DEBUG_INTENSITY)
                gl_FragColor = vec4(diffuse.a, 0.0, 0.0, 1.0);
            #else
                gl_FragColor.rgb = mix(gl_FragColor.rgb, diffuse.rgb / diffuse.a, diffuse.a);
            #endif
            // gl_FragColor.a = diffuse.a;
            // gl_FragColor = vec4(0.0, 1.0, 0.0, diffuse.a);
            // gl_FragColor = vec4(lum, 1.0);
        }
        else {
            // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
        
    }
}`, gradientFragShader = `#define GLSLIFY 1
#include <mvt_depth_packing>
#include <packing>

uniform vec3 highColor;
uniform vec3 color;
varying vec2 vUv;
uniform float cameraNear;
uniform float cameraFar;
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
uniform vec2 resolution;
uniform bool isGlobe;
uniform vec2 fogDepthRange;
uniform mat4 viewInverseMatrix;
uniform mat4 projectionInverseMatrix;
void main() {
    // float depthValue = texture2D(tDepth, vUv).x;
    // \u6309\u50CF\u7D20\u7CBE\u786E\u91C7\u6837\u6DF1\u5EA6\u503C
    float depthValue = texelFetch(tDepth, ivec2(gl_FragCoord), 0).x;
    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);
    vec3 viewPosition = mvtGetViewPositionByDepth(depth, vUv, projectionInverseMatrix);

    float maxDistance = length(viewPosition) / 1000000.0;
    vec4 diffuse = texture2D(tDiffuse, vUv);
    bool isTranslucent = diffuse.a < 1.0;

    vec3 viewPos = getViewPos(0.);

    float cameraHeight = cameraPosition.z;

    float camFOVWidth = 35.0 / 180.0 * PI;
    float camHeightScale = tan(camFOVWidth / 2.0);
    float camWidthScale = camHeightScale * resolution.x / resolution.y;

    vec3 camRight   = vec3( viewInverseMatrix[0][0],  viewInverseMatrix[0][1],  viewInverseMatrix[0][2]);
    vec3 camUp      = vec3( viewInverseMatrix[1][0],  viewInverseMatrix[1][1],  viewInverseMatrix[1][2]);
	vec3 camDir = vec3(-viewInverseMatrix[2][0], -viewInverseMatrix[2][1], -viewInverseMatrix[2][2]);

    vec2 nxy = vUv.xy * 2.0 - 1.0;
    vec3 rayDir = normalize(camDir + camRight * nxy.x * camWidthScale  + camUp * nxy.y * camHeightScale).xzy;

    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);
    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);

    float mindist, maxdist;
    float dist = 0.0;
    if (atmos_intercept.x < atmos_intercept.y){
        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;
        maxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;
    }
    float height = length(viewPos);
    if (height < atmosphereRadiusMM) mindist=0.0;
    if (terra_intercept > 0.0){ // confirm valid intercepts			
        maxdist = terra_intercept;
    }

    float depthThreshold = mix(0.996, 0.992, clamp(cameraHeight / 100000.0, 0.0, 1.0));
    float diff = maxdist - mindist;

    float cosTheta = groundRadiusMM / atmosphereRadiusMM;
    float cosRadians = acos(cosTheta);
    float maxAtmosphereDist = atmosphereRadiusMM * sin(cosRadians);

    float horizonDist = sqrt(height * height - groundRadiusMM * groundRadiusMM);
    // float factor = diff / horizonDist;

    // ratio\u7528\u4E8E\u53D6\u8FC7\u6E21\u989C\u8272
    // remappedRatio\u7528\u4E8E\u8BBE\u7F6E\u900F\u660E\u5EA6(\u7EBF\u6027\u8FC7\u6E21\u989C\u8272\u53D8\u5316\u592A\u5927,\u7528\u975E\u7EBF\u6027\u53D8\u5316)
    // https://www.desmos.com/calculator/raytthuk1q?lang=zh-CN
    float ratio;
    float factor;
    bool isInSpace = false;
    float remappedRatio;
    if (height < atmosphereRadiusMM) {
        if (depthValue < depthThreshold && !isTranslucent) {
            diff = min(maxDistance, maxdist) - mindist;
        }
        // \u901A\u8FC7\u7A7F\u8FC7\u5927\u6C14\u7684\u8DEF\u5F84\u548C\u4ECE\u5F53\u524D\u89C6\u70B9\u51FA\u53D1\u80FD\u591F\u7ECF\u8FC7\u7684\u6700\u957F\u8DEF\u5F84\u7684\u6BD4\u503C\u4F5C\u4E3Aratio
        ratio = clamp(1.0 - cos((PI / 2.0) * (diff / (maxAtmosphereDist + horizonDist))), 0.0, 1.0);
        remappedRatio = 1.0 - exp(-50.0 * ratio);
        if (terra_intercept > 0.0) factor = diff / horizonDist;
    }
    else {
        // \u901A\u8FC7\u7A7F\u8FC7\u5927\u6C14\u7684\u8DEF\u5F84\u8BA1\u7B97\u9AD8\u5EA6\uFF0C\u5229\u7528\u9AD8\u5EA6\u5F97\u5230ratio
        isInSpace = true;
        float halfDiff = diff * 0.5;
        float sinTheta = halfDiff / atmosphereRadiusMM;
        float sinRadians = asin(sinTheta);
        float atmospherHeight = atmosphereRadiusMM - groundRadiusMM;
        ratio = 1.0 - cos((PI / 2.0) * (diff / (maxAtmosphereDist * 2.0)));

        float ratioScale = min(max((atmospherHeight / viewHeight), 0.8), 1.0);
        float ratioScaled = (1.0 - ratioScale) * ratio + ratioScale;

        // \u968F\u7740\u9AD8\u5EA6\u7684\u4E0A\u5347\u900F\u660E\u5EA6\u4ECE\u975E\u7EBF\u6027\u53D8\u4E3A\u7EBF\u6027\u8FC7\u6E21
        float unlinearRatio = (1.0 - exp(-(10.0) * ratio));
        float h = min(max(((atmospherHeight * 2.0 - viewHeight) / atmospherHeight), 0.0) ,1.0);
        remappedRatio = (unlinearRatio * h + ratio * (1.0 - h)) * ratioScaled;
        if (terra_intercept > 0.0) factor = diff / maxAtmosphereDist;
    }

    float ratioValue = 1.0 - ratio;
    vec3 outColor;
    if (ratioValue <= 0.0) {
        outColor = color;
    }
    else if (ratioValue < 0.3) {
        float t = smoothstep(0.0, 1.0, (ratioValue / 0.3));
        outColor = mix(color, highColor, t);
    }
    else {
        outColor = highColor;
    }

    vec3 outputColor;
    if (terra_intercept > 0.0) {
        // \u5982\u679C\u548C\u5730\u7403\u76F8\u4EA4\uFF0C\u4F7F\u7528\u5E95\u90E8\u989C\u8272
        outputColor = color * factor;
    }
    else {
        outputColor = outColor * remappedRatio;
    }

    float viewRatio = 1.0;
    if (isGlobe) {
        // viewRatio = 1.0 - clamp(dot(normalize(vec3(viewInverseMatrix[2])), upDirection), 0.0, 1.0);
        // viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);
        // viewRatio = 1.;
    }
    else {
        viewRatio = 1.0 - dot(normalize(vec3(viewInverseMatrix[2])), vec3(0.0, 0.0, 1));
        viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);
    }

    outputColor = colorSpaceTransform(vec4(outputColor, 1.0)).rgb;

    float atmoFactor = diff / maxAtmosphereDist;
    if (depthValue < depthThreshold && ratio >= 0.0 && !isTranslucent) {
        vec4 atmo = colorSpaceTransform(vec4(color, 1.0));
        float fogDepth = depthValue;

        float fogDensity = 1.;
        float fogStart = mix(0.8, 0.95, ratio);
        fogDepth = clamp((fogDepth - fogStart) / (1.0 - fogStart), 0.0, 1.0);

        float atmoFinalFactor = 0.0;
        if (isGlobe) {
            if (isInSpace) {
                atmoFinalFactor = atmoFactor;
            }
            else {
                float heightRatio = 1.0 - clamp(viewHeight * 10.0, 0.0, 1.0);
                heightRatio = heightRatio * heightRatio;
                // float maxDistance = 0.5 + heightRatio * 2.0;
                float viewDepth = clamp((depthValue - fogDepthRange.x) / (fogDepthRange.y - fogDepthRange.x), 0.0, 1.0);
                viewDepth = 1.0 - exp(- 2.0 * viewDepth * viewDepth);
                atmoFinalFactor = mix(atmoFactor, viewDepth, heightRatio);
            }
        }
        else {
            atmoFinalFactor = fogDepth * ratio * viewRatio;
        }

        atmoFinalFactor *= atmoFinalFactor;

        gl_FragColor = mix(diffuse, atmo, atmoFinalFactor);
    }
    else {
        gl_FragColor = vec4(outputColor, 1.0);

        float t = abs(dot(rayDir, -viewPos));
        float distanceToGlobeCenter = sqrt(height * height - t * t);
        
        if (rayDir.y < 0.0 && distanceToGlobeCenter < groundRadiusMM) {
            gl_FragColor = colorSpaceTransform(vec4(color, 1.0)); 
        }

        if (diffuse.a > 0.001) {
            gl_FragColor.rgb = mix(gl_FragColor.rgb, diffuse.rgb / diffuse.a, diffuse.a);
        }
    }

    gl_FragColor.a = 1.0;

}`, SkyAtmosphereShader = {
  uniforms: {
    altitude: {
      value: 2.8
    },
    transmittanceTexture: {
      value: null
    },
    transmittanceResolution: {
      value: [256, 256]
    },
    scatteringTexture: {
      value: null
    },
    scatteringResolution: {
      value: [256, 256]
    },
    viewTexture: {
      value: null
    },
    viewResolution: {
      value: [256, 256]
    },
    cameraDirection: {
      value: new Vector3$1(0, 0.27, -1)
    },
    viewHeight: {
      value: 2e-4
    },
    upDirection: {
      value: new Vector3$1(0, 1, 0)
    },
    tWeather: {
      value: null
    },
    mixGrayFactor: {
      value: 0
    },
    isEmissive: {
      value: !1
    },
    uTime: {
      value: null
    },
    uStarVisible: {
      value: !0
    },
    uMoonMap: {
      value: null
    },
    isGlobe: {
      value: !1
    }
  },
  vertexShader: mainVertShader$1,
  fragmentShader: commonFragShader$1 + `
` + mainFragShader$1
}, SkyAtmosphereTransmittanceShader = {
  uniforms: {
    altitude: {
      value: 2.8
    },
    viewHeight: {
      value: 2e-4
    }
  },
  vertexShader: bufferVertexShader,
  fragmentShader: commonFragShader$1 + `
` + transmittanceFragShader
}, SkyAtmosphereScatteringShader = {
  uniforms: {
    altitude: {
      value: 2.8
    },
    transmittanceTexture: {
      value: null
    },
    transmittanceResolution: {
      value: [256, 256]
    },
    viewHeight: {
      value: 2e-4
    }
  },
  vertexShader: bufferVertexShader,
  fragmentShader: commonFragShader$1 + `
` + scatteringFragShader
}, SkyAtmosphereViewShader = {
  uniforms: {
    altitude: {
      value: 2.8
    },
    transmittanceTexture: {
      value: null
    },
    transmittanceResolution: {
      value: [256, 256]
    },
    scatteringTexture: {
      value: null
    },
    scatteringResolution: {
      value: [256, 256]
    },
    viewHeight: {
      value: 2e-4
    },
    mixGrayFactor: {
      value: 0
    }
  },
  vertexShader: bufferVertexShader,
  fragmentShader: commonFragShader$1 + `
` + viewFragShader
}, SkyAtmospherePostprocessingShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tDepth: {
      value: null
    },
    tNormal: {
      value: null
    },
    tAtmosphere: {
      value: null
    },
    cameraNear: {
      value: 0.1
    },
    cameraFar: {
      value: 1e3
    },
    projectionInverseMatrix: {
      value: new Matrix4()
    },
    viewInverseMatrix: {
      value: new Matrix4()
    },
    mvt_viewMatrix: {
      value: new Matrix4()
    },
    cameraPosition: {
      value: new Vector3$1()
    },
    altitude: {
      value: 2.8
    },
    viewHeight: {
      value: 2e-4
    },
    transmittanceTexture: {
      value: null
    },
    transmittanceResolution: {
      value: [256, 256]
    },
    scatteringTexture: {
      value: null
    },
    scatteringResolution: {
      value: [256, 256]
    },
    viewTexture: {
      value: null
    },
    viewResolution: {
      value: [256, 256]
    },
    resolution: {
      value: [256, 256]
    },
    cameraDirection: {
      value: new Vector3$1(0, 0.27, -1)
    },
    sunDirection: {
      value: new Vector3$1(0, 1, 0)
    },
    upDirection: {
      value: new Vector3$1(0, 0, 1)
    },
    isGlobe: {
      value: !1
    },
    fogDepthRange: {
      value: new Vector2$1(0, 1)
    },
    rotationMatrix: {
      value: new Matrix3()
    }
  },
  fragmentShader: commonFragShader$1 + `
` + postprocessingFragShader
}, SkyAtmosphereGradientShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tDepth: {
      value: null
    },
    cameraNear: {
      value: 0.1
    },
    cameraFar: {
      value: 1e3
    },
    viewInverseMatrix: {
      value: new Matrix4()
    },
    cameraPosition: {
      value: new Vector3$1()
    },
    viewHeight: {
      value: 2e-4
    },
    resolution: {
      value: [256, 256]
    },
    cameraDirection: {
      value: new Vector3$1(0, 0.27, -1)
    },
    sunDirection: {
      value: new Vector3$1(0, 1, 0)
    },
    isGlobe: {
      value: !1
    },
    fogDepthRange: {
      value: new Vector2$1(0, 1)
    },
    rotationMatrix: {
      value: new Matrix3()
    },
    projectionInverseMatrix: {
      value: new Matrix4()
    },
    color: {
      value: new Color()
    },
    highColor: {
      value: new Color()
    }
  },
  fragmentShader: commonFragShader$1 + `
` + gradientFragShader
}, scaleToGeodeticSurfaceIntersection = new Vector3$1(), scaleToGeodeticSurfaceGradient = new Vector3$1();
function scaleToGeodeticSurface(o, i, e, r, s) {
  const a = o.x, c = o.y, l = o.z, h = i.x, d = i.y, f = i.z, p = a * a * h * h, m = c * c * d * d, y = l * l * f * f, x = p + m + y, v = Math.sqrt(1 / x), S = scaleToGeodeticSurfaceIntersection.copy(o).multiplyScalar(v);
  if (x < r)
    return s || (s = new Vector3$1()), isFinite(v) ? s.copy(S) : void 0;
  const E = e.x, b = e.y, w = e.z, M = scaleToGeodeticSurfaceGradient;
  M.x = S.x * E * 2, M.y = S.y * b * 2, M.z = S.z * w * 2;
  let P = (1 - v) * o.length() / (0.5 * M.length()), D = 0, L, O, F, k, V, N, U, z, $, G, j;
  do {
    P -= D, F = 1 / (1 + P * E), k = 1 / (1 + P * b), V = 1 / (1 + P * w), N = F * F, U = k * k, z = V * V, $ = N * F, G = U * k, j = z * V, L = p * N + m * U + y * z - 1, O = p * $ * E + m * G * b + y * j * w;
    let Y = -2 * O;
    D = L / Y;
  } while (Math.abs(L) > 1e-12);
  return s ? (s.x = a * F, s.y = c * k, s.z = l * V, s) : new Vector3$1(
    a * F,
    c * k,
    l * V
  );
}
function defined$1(o) {
  return o != null;
}
function defaultValue(o, i) {
  return o != null ? o : i;
}
defaultValue.EMPTY_OBJECT = Object.freeze({});
function DeveloperError(o) {
  this.name = "DeveloperError", this.message = o;
  let i;
  try {
    throw new Error();
  } catch (e) {
    i = e.stack;
  }
  this.stack = i;
}
defined$1(Object.create) && (DeveloperError.prototype = Object.create(Error.prototype), DeveloperError.prototype.constructor = DeveloperError);
DeveloperError.prototype.toString = function() {
  let o = this.name + ": " + this.message;
  return defined$1(this.stack) && (o += `
` + this.stack.toString()), o;
};
DeveloperError.throwInstantiationError = function() {
  throw new DeveloperError(
    "This function defines an interface and should not be called directly."
  );
};
const ve = class {
  static equalsEpsilon(i, e, r, s) {
    r = defaultValue(r, 0), s = defaultValue(s, r);
    const a = Math.abs(i - e);
    return a <= s || a <= r * Math.max(Math.abs(i), Math.abs(e));
  }
  static toRadians(i) {
    return MathUtils.degToRad(i);
  }
  static clamp(i, e, r) {
    return i < e ? e : i > r ? r : i;
  }
  static acosClamped(i) {
    return Math.acos(ve.clamp(i, -1, 1));
  }
  static asinClamped(i) {
    return Math.asin(ve.clamp(i, -1, 1));
  }
  static sign(i) {
    return Math.sign(i);
  }
  static zeroToTwoPi(i) {
    if (i >= 0 && i <= ve.TWO_PI)
      return i;
    const e = ve.mod(i, ve.TWO_PI);
    return Math.abs(e) < ve.EPSILON14 && Math.abs(i) > ve.EPSILON14 ? ve.TWO_PI : e;
  }
  static mod(i, e) {
    return ve.sign(i) === ve.sign(e) && Math.abs(i) < Math.abs(e) ? i : (i % e + e) % e;
  }
  static chordLength(i, e) {
    return 2 * e * Math.sin(i * 0.5);
  }
  static negativePiToPi(i) {
    if (!defined$1(i))
      throw new DeveloperError("angle is required.");
    return i >= -ve.PI && i <= ve.PI ? i : ve.zeroToTwoPi(i + ve.PI) - ve.PI;
  }
  static normalize(i, e, r) {
    return r = Math.max(r - e, 0), r === 0 ? 0 : ve.clamp((i - e) / r, 0, 1);
  }
};
let CesiumMath = ve;
_(CesiumMath, "EPSILON1", 0.1), _(CesiumMath, "EPSILON2", 0.01), _(CesiumMath, "EPSILON3", 1e-3), _(CesiumMath, "EPSILON4", 1e-4), _(CesiumMath, "EPSILON5", 1e-5), _(CesiumMath, "EPSILON6", 1e-6), _(CesiumMath, "EPSILON7", 1e-7), _(CesiumMath, "EPSILON8", 1e-8), _(CesiumMath, "EPSILON9", 1e-9), _(CesiumMath, "EPSILON10", 1e-10), _(CesiumMath, "EPSILON11", 1e-11), _(CesiumMath, "EPSILON12", 1e-12), _(CesiumMath, "EPSILON13", 1e-13), _(CesiumMath, "EPSILON14", 1e-14), _(CesiumMath, "EPSILON15", 1e-15), _(CesiumMath, "EPSILON16", 1e-16), _(CesiumMath, "EPSILON17", 1e-17), _(CesiumMath, "EPSILON18", 1e-18), _(CesiumMath, "EPSILON19", 1e-19), _(CesiumMath, "EPSILON20", 1e-20), _(CesiumMath, "EPSILON21", 1e-21), _(CesiumMath, "PI", Math.PI), _(CesiumMath, "ONE_OVER_PI", 1 / Math.PI), _(CesiumMath, "PI_OVER_TWO", Math.PI / 2), _(CesiumMath, "PI_OVER_THREE", Math.PI / 3), _(CesiumMath, "PI_OVER_FOUR", Math.PI / 4), _(CesiumMath, "PI_OVER_SIX", Math.PI / 6), _(CesiumMath, "THREE_PI_OVER_TWO", 3 * Math.PI / 2), _(CesiumMath, "TWO_PI", 2 * Math.PI), _(CesiumMath, "ONE_OVER_TWO_PI", 1 / (2 * Math.PI)), _(CesiumMath, "RADIANS_PER_DEGREE", Math.PI / 180);
const mostOrthogonalAxisScratch = new Vector3$1();
let scratchN$1 = new Vector3$1(), scratchK$1 = new Vector3$1();
const wgs84RadiiSquared = new Vector3$1(
  6378137 * 6378137,
  6378137 * 6378137,
  6356752314245179e-9 * 6356752314245179e-9
), angleBetweenScratch$1 = new Vector3$1(), angleBetweenScratch2$1 = new Vector3$1(), he = class {
  constructor() {
    _(this, "COLUMN0ROW0", 0);
    _(this, "COLUMN0ROW1", 1);
    _(this, "COLUMN0ROW2", 2);
    _(this, "COLUMN1ROW0", 3);
    _(this, "COLUMN1ROW1", 4);
    _(this, "COLUMN1ROW2", 5);
    _(this, "COLUMN2ROW0", 6);
    _(this, "COLUMN2ROW1", 7);
    _(this, "COLUMN2ROW2", 8);
  }
  static clone(i, e) {
    if (!!i)
      return e.copy(i), e;
  }
  static equals(i, e) {
    return defined$1(i) && defined$1(e) ? i.equals(e) : !1;
  }
  static normalize(i, e) {
    return i === e ? (i.normalize(), i) : (e.copy(i), e.normalize(), e);
  }
  static add(i, e, r) {
    return r || (r = new Vector3$1()), r.addVectors(i, e);
  }
  static dot(i, e) {
    return i.dot(e);
  }
  static cross(i, e, r) {
    return r || (r = new Vector3$1()), r.crossVectors(i, e), r;
  }
  static magnitudeSquared(i) {
    return i.lengthSq();
  }
  static multiplyByScalar(i, e, r) {
    return r || (r = new Vector3$1()), r.copy(i).multiplyScalar(e), r;
  }
  static divideByScalar(i, e, r) {
    return r || (r = new Vector3$1()), r.x = i.x / e, r.y = i.y / e, r.z = i.z / e, r;
  }
  static subtract(i, e, r) {
    return r || (r = new Vector3$1()), r.subVectors(i, e), r;
  }
  static distance(i, e) {
    return i.distanceTo(e);
  }
  static negate(i, e) {
    return e || (e = new Vector3$1()), e.copy(i), e.negate(), e;
  }
  static multiplyComponents(i, e, r) {
    return r || (r = new Vector3$1()), r.multiplyVectors(i, e), r;
  }
  static magnitude(i) {
    return i.length();
  }
  static equalsEpsilon(i, e, r, s) {
    return i === e || defined$1(i) && defined$1(e) && CesiumMath.equalsEpsilon(
      i.x,
      e.x,
      r,
      s
    ) && CesiumMath.equalsEpsilon(
      i.y,
      e.y,
      r,
      s
    ) && CesiumMath.equalsEpsilon(
      i.z,
      e.z,
      r,
      s
    );
  }
  static fromCartesian4(i, e) {
    return e || (e = new Vector3$1()), e.set(i.x, i.y, i.z), e;
  }
  static fromElements(i, e, r, s) {
    return s || (s = new Vector3$1()), s.set(i, e, r), s;
  }
  static fromRadians(i, e, r, s, a) {
    r = defaultValue(r, 0);
    const c = defined$1(s) ? s.radiiSquared : wgs84RadiiSquared, l = Math.cos(e);
    scratchN$1.x = l * Math.cos(i), scratchN$1.y = l * Math.sin(i), scratchN$1.z = Math.sin(e), scratchN$1 = he.normalize(scratchN$1, scratchN$1), he.multiplyComponents(c, scratchN$1, scratchK$1);
    const h = Math.sqrt(he.dot(scratchN$1, scratchK$1));
    return scratchK$1 = he.divideByScalar(scratchK$1, h, scratchK$1), scratchN$1 = he.multiplyByScalar(scratchN$1, r, scratchN$1), defined$1(a) || (a = new Vector3$1()), he.add(scratchK$1, scratchN$1, a);
  }
  static angleBetween(i, e) {
    he.normalize(i, angleBetweenScratch$1), he.normalize(e, angleBetweenScratch2$1);
    const r = he.dot(angleBetweenScratch$1, angleBetweenScratch2$1), s = he.magnitude(
      he.cross(
        angleBetweenScratch$1,
        angleBetweenScratch2$1,
        angleBetweenScratch$1
      )
    );
    return Math.atan2(s, r);
  }
  static fromDegrees(i, e, r, s, a) {
    return i = CesiumMath.toRadians(i), e = CesiumMath.toRadians(e), he.fromRadians(i, e, r, s, a);
  }
};
let Cartesian3 = he;
_(Cartesian3, "ZERO", Object.freeze(new Vector3$1())), _(Cartesian3, "UNIT_X", Object.freeze(new Vector3$1(1, 0, 0))), _(Cartesian3, "UNIT_Y", Object.freeze(new Vector3$1(0, 1, 0))), _(Cartesian3, "UNIT_Z", Object.freeze(new Vector3$1(0, 0, 1))), _(Cartesian3, "abs", function(i, e) {
  return e.x = Math.abs(i.x), e.y = Math.abs(i.y), e.z = Math.abs(i.z), e;
}), _(Cartesian3, "mostOrthogonalAxis", function(i, e) {
  const r = he.normalize(i, mostOrthogonalAxisScratch);
  return he.abs(r, r), r.x <= r.y ? r.x <= r.z ? e = he.clone(he.UNIT_X, e) : e = he.clone(he.UNIT_Z, e) : r.y <= r.z ? e = he.clone(he.UNIT_Y, e) : e = he.clone(he.UNIT_Z, e), e;
});
const _inputVector3$1 = new Vector3$1(), _outputVector3$1 = new Vector3$1();
class Ellipsoid {
  constructor(i, e, r) {
    this._radii = new Vector3$1(i, e, r), this._radiiSquared = new Vector3$1(i * i, e * e, r * r), this._radiiToTheFourth = new Vector3$1(
      i * i * i * i,
      e * e * e * e,
      r * r * r * r
    ), this._oneOverRadii = new Vector3$1(
      i === 0 ? 0 : 1 / i,
      e === 0 ? 0 : 1 / e,
      r === 0 ? 0 : 1 / r
    ), this._oneOverRadiiSquared = new Vector3$1(
      i === 0 ? 0 : 1 / (i * i),
      e === 0 ? 0 : 1 / (e * e),
      r === 0 ? 0 : 1 / (r * r)
    ), this._minimumRadius = Math.min(i, e, r), this._maximumRadius = Math.max(i, e, r), this._centerToleranceSquared = 0.1, this._radiiSquared.z !== 0 && (this._squaredXOverSquaredZ = this._radiiSquared.x / this._radiiSquared.z);
  }
  static fromCartesian3(i) {
    return new Ellipsoid(i.x, i.y, i.z);
  }
  geodeticSurfaceNormalCartographic(i, e) {
    e || (e = new Vector3$1());
    const r = i.x, s = i.y, a = Math.cos(s), c = a * Math.cos(r), l = a * Math.sin(r), h = Math.sin(s);
    return e.set(c, l, h), e.normalize(), e;
  }
  cartographicDegreeToCartesian(i, e) {
    return _inputVector3$1.set(
      MathUtils.degToRad(i.x),
      MathUtils.degToRad(i.y),
      i.z
    ), this.cartographicToCartesian(_inputVector3$1, e);
  }
  cartographicToCartesian(i, e) {
    const r = this.geodeticSurfaceNormalCartographic(i);
    e || (e = new Vector3$1()), e.multiplyVectors(this._radiiSquared, r);
    const s = Math.sqrt(r.clone().dot(e));
    return e.divideScalar(s), r.multiplyScalar(i.z), e.add(r), e;
  }
  cartesianToCartographicDegree(i, e) {
    const r = this.cartesianToCartographic(i, e);
    if (!!r)
      return e = r, e.x = MathUtils.radToDeg(e.x), e.y = MathUtils.radToDeg(e.y), e;
  }
  scaleToGeodeticSurface(i, e) {
    return scaleToGeodeticSurface(
      i,
      this._oneOverRadii,
      this._oneOverRadiiSquared,
      this._centerToleranceSquared,
      e
    );
  }
  scaleToGeocentricSurface(i, e) {
    e || (e = new Vector3$1());
    const r = i.x, s = i.y, a = i.z, c = this._oneOverRadiiSquared, l = 1 / Math.sqrt(
      r * r * c.x + s * s * c.y + a * a * c.z
    );
    return e.copy(i).multiplyScalar(l);
  }
  cartesianToCartographic(i, e) {
    const r = this.scaleToGeodeticSurface(
      i,
      _outputVector3$1
    );
    if (!r)
      return;
    const s = this.geodeticSurfaceNormal(r), a = i.clone();
    a.sub(r);
    const c = Math.atan2(s.y, s.x), l = Math.asin(s.z), h = Math.sign(a.dot(i)) * a.length();
    return e || (e = new Vector3$1()), e.set(c, l, h), e;
  }
  geodeticSurfaceNormal(i, e) {
    return defined$1(e) || (e = new Vector3$1()), e.multiplyVectors(i, this._oneOverRadiiSquared), e.normalize(), e;
  }
  getSurfaceNormalIntersectionWithZAxis(i, e, r) {
    e = defaultValue(e, 0);
    const s = this._squaredXOverSquaredZ;
    if (defined$1(r) || (r = new Vector3$1()), r.x = 0, r.y = 0, r.z = i.z * (1 - s), !(Math.abs(r.z) >= this._radii.z - e))
      return r;
  }
  transformPositionToScaledSpace(i, e) {
    return Cartesian3.multiplyComponents(i, this._oneOverRadii, e);
  }
  static clone(i, e) {
    if (!i)
      return;
    const r = i._radii;
    return e ? (Cartesian3.clone(r, e._radii), Cartesian3.clone(i._radiiSquared, e._radiiSquared), Cartesian3.clone(i._radiiToTheFourth, e._radiiToTheFourth), Cartesian3.clone(i._oneOverRadii, e._oneOverRadii), Cartesian3.clone(i._oneOverRadiiSquared, e._oneOverRadiiSquared), e._minimumRadius = i._minimumRadius, e._maximumRadius = i._maximumRadius, e._centerToleranceSquared = i._centerToleranceSquared, e) : new Ellipsoid(r.x, r.y, r.z);
  }
  get radii() {
    return this._radii;
  }
  get radiiSquared() {
    return this._radiiSquared;
  }
  get radiiToTheFourth() {
    return this.radiiToTheFourth;
  }
  get oneOverRadii() {
    return this._oneOverRadii;
  }
  get oneOverRadiiSquared() {
    return this._oneOverRadiiSquared;
  }
  get maximumRadius() {
    return this._maximumRadius;
  }
  get minimumRadius() {
    return this._minimumRadius;
  }
}
Ellipsoid.WGS84 = Object.freeze(
  new Ellipsoid(6378137, 6378137, 6356752314245179e-9)
);
function GeographicProjection(o) {
  this._ellipsoid = defaultValue(o, Ellipsoid.WGS84), this._semimajorAxis = this._ellipsoid.maximumRadius, this._oneOverSemimajorAxis = 1 / this._semimajorAxis;
}
Object.defineProperties(GeographicProjection.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  }
});
GeographicProjection.prototype.project = function(o, i) {
  const e = this._semimajorAxis, r = o.x * e, s = o.y * e, a = o.z;
  return defined$1(i) ? (i.x = r, i.y = s, i.z = a, i) : new Vector3$1(r, s, a);
};
GeographicProjection.prototype.unproject = function(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("cartesian is required");
  const e = this._oneOverSemimajorAxis, r = o.x * e, s = o.y * e, a = o.z;
  return defined$1(i) ? (i.x = r, i.y = s, i.z = a, i) : new Vector3$1(r, s, a);
};
const angleBetweenScratch = new Vector2$1(), angleBetweenScratch2 = new Vector2$1(), nt = class {
  static clone(i, e) {
    return e.copy(i), e;
  }
  static fromElements(i, e, r) {
    return r || (r = new Vector2$1()), r.set(i, e), r;
  }
  static lerp(i, e, r, s) {
    return s || (s = new Vector2$1()), s.lerpVectors(i, e, r), s;
  }
  static equalsEpsilon(i, e, r, s) {
    return i === e || defined$1(i) && defined$1(e) && CesiumMath.equalsEpsilon(
      i.x,
      e.x,
      r,
      s
    ) && CesiumMath.equalsEpsilon(
      i.y,
      e.y,
      r,
      s
    );
  }
  static equals(i, e) {
    return i.equals(e);
  }
  static dot(i, e) {
    return i.dot(e);
  }
  static normalize(i, e) {
    return i === e ? (i.normalize(), i) : (e.copy(i), e.normalize(), e);
  }
  static add(i, e, r) {
    return r || (r = new Vector2$1()), r.addVectors(i, e);
  }
  static multiplyByScalar(i, e, r) {
    return r || (r = new Vector2$1()), r.copy(i).multiplyScalar(e), r;
  }
  static subtract(i, e, r) {
    return r || (r = new Vector2$1()), r.subVectors(i, e), r;
  }
  static distance(i, e) {
    return i.distanceTo(e);
  }
  static angleBetween(i, e) {
    return nt.normalize(i, angleBetweenScratch), nt.normalize(e, angleBetweenScratch2), CesiumMath.acosClamped(
      nt.dot(angleBetweenScratch, angleBetweenScratch2)
    );
  }
};
let Cartesian2 = nt;
_(Cartesian2, "ZERO", new Vector2$1());
Cartesian2.fromCartesian3 = Cartesian2.clone;
Cartesian2.fromCartesian4 = Cartesian2.clone;
class StaticMatrix3 {
  static fromQuaternion(i, e) {
    const r = i.x * i.x, s = i.x * i.y, a = i.x * i.z, c = i.x * i.w, l = i.y * i.y, h = i.y * i.z, d = i.y * i.w, f = i.z * i.z, p = i.z * i.w, m = i.w * i.w, y = r - l - f + m, x = 2 * (s - p), v = 2 * (a + d), S = 2 * (s + p), E = -r + l - f + m, b = 2 * (h - c), w = 2 * (a - d), M = 2 * (h + c), P = -r - l + f + m;
    return e || (e = new Matrix3()), e.set(y, x, v, S, E, b, w, M, P), e;
  }
  static getColumn(i, e, r) {
    const s = i.elements, a = e * 3, c = s[a], l = s[a + 1], h = s[a + 2];
    return r.x = c, r.y = l, r.z = h, r;
  }
  static multiplyByVector(i, e, r) {
    return r || (r = new Vector3$1()), r.copy(e), r.applyMatrix3(i), r;
  }
  static multiplyByScale(i, e, r) {
    r || (r = new Matrix3());
    const s = r.elements, a = i.elements;
    return s[0] = a[0] * e.x, s[1] = a[1] * e.x, s[2] = a[2] * e.x, s[3] = a[3] * e.y, s[4] = a[4] * e.y, s[5] = a[5] * e.y, s[6] = a[6] * e.z, s[7] = a[7] * e.z, s[8] = a[8] * e.z, r;
  }
  static transpose(i, e) {
    return e || (e = new Matrix3()), e.copy(i).transpose(), e;
  }
  static fromScale(i, e) {
    e || (e = new Matrix3());
    const r = e.elements;
    return r[0] = i.x, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = i.y, r[5] = 0, r[6] = 0, r[7] = 0, r[8] = i.z, e;
  }
  static multiply(i, e, r) {
    r || (r = new Matrix3());
    const s = i.elements, a = e.elements, c = r.elements, l = s[0], h = s[3], d = s[6], f = s[1], p = s[4], m = s[7], y = s[2], x = s[5], v = s[8], S = a[0], E = a[3], b = a[6], w = a[1], M = a[4], P = a[7], D = a[2], L = a[5], O = a[8];
    return c[0] = l * S + h * w + d * D, c[3] = l * E + h * M + d * L, c[6] = l * b + h * P + d * O, c[1] = f * S + p * w + m * D, c[4] = f * E + p * M + m * L, c[7] = f * b + p * P + m * O, c[2] = y * S + x * w + v * D, c[5] = y * E + x * M + v * L, c[8] = y * b + x * P + v * O, r;
  }
  static clone(i, e) {
    if (!!defined$1(i))
      return defined$1(e) ? (e.clone(i), e) : new Matrix3(
        i[0],
        i[3],
        i[6],
        i[1],
        i[4],
        i[7],
        i[2],
        i[5],
        i[8]
      );
  }
  static setColumn(i, e, r, s) {
    s = StaticMatrix3.clone(i, s);
    const a = s.elements, c = e * 3;
    return a[c] = r.x, a[c + 1] = r.y, a[c + 2] = r.z, s;
  }
}
StaticMatrix3.ZERO = Matrix3.ZERO = Object.freeze(
  new Matrix3(0, 0, 0, 0, 0, 0, 0, 0, 0)
);
StaticMatrix3.COLUMN0ROW0 = 0;
StaticMatrix3.COLUMN0ROW1 = 1;
StaticMatrix3.COLUMN0ROW2 = 2;
StaticMatrix3.COLUMN1ROW0 = 3;
StaticMatrix3.COLUMN1ROW1 = 4;
StaticMatrix3.COLUMN1ROW2 = 5;
StaticMatrix3.COLUMN2ROW0 = 6;
StaticMatrix3.COLUMN2ROW1 = 7;
StaticMatrix3.COLUMN2ROW2 = 8;
class StaticMatrix4 {
  static clone(i, e) {
    return e.copy(i), e;
  }
  static inverseTransformation(i, e) {
    return e.copy(i).invert(), e;
  }
  static multiplyByPoint(i, e, r) {
    const s = i.elements, a = e.x, c = e.y, l = e.z, h = s[0] * a + s[4] * c + s[8] * l + s[12], d = s[1] * a + s[5] * c + s[9] * l + s[13], f = s[2] * a + s[6] * c + s[10] * l + s[14];
    return r.x = h, r.y = d, r.z = f, r;
  }
  static multiplyByPointAsVector(i, e, r) {
    const s = i.elements, a = e.x, c = e.y, l = e.z, h = s[0] * a + s[4] * c + s[8] * l, d = s[1] * a + s[5] * c + s[9] * l, f = s[2] * a + s[6] * c + s[10] * l;
    return r.x = h, r.y = d, r.z = f, r;
  }
  static computeViewportTransformation(i, e, r, s) {
    defined$1(s) || (s = new Matrix4()), i = defaultValue(i, defaultValue.EMPTY_OBJECT);
    const a = defaultValue(i.x, 0), c = defaultValue(i.y, 0), l = defaultValue(i.width, 0), h = defaultValue(i.height, 0);
    e = defaultValue(e, 0), r = defaultValue(r, 1);
    const d = l * 0.5, f = h * 0.5, p = (r - e) * 0.5, m = d, y = f, x = p, v = a + d, S = c + f, E = e + p, b = 1, w = s.elements;
    return w[0] = m, w[1] = 0, w[2] = 0, w[3] = 0, w[4] = 0, w[5] = y, w[6] = 0, w[7] = 0, w[8] = 0, w[9] = 0, w[10] = x, w[11] = 0, w[12] = v, w[13] = S, w[14] = E, w[15] = b, s;
  }
  static equals(i, e) {
    return i.equals(e);
  }
  static multiplyByVector(i, e, r) {
    return r || (r = new Vector4()), r.copy(e), r.applyMatrix4(i), r;
  }
  static getColumn(i, e, r) {
    const s = i.elements, a = e * 4, c = s[a], l = s[a + 1], h = s[a + 2], d = s[a + 3];
    return r.x = c, r.y = l, r.z = h, r.w = d, r;
  }
  static fromTranslationQuaternionRotationScale(i, e, r, s) {
    s || (s = new Matrix4());
    const a = r.x, c = r.y, l = r.z, h = e.x * e.x, d = e.x * e.y, f = e.x * e.z, p = e.x * e.w, m = e.y * e.y, y = e.y * e.z, x = e.y * e.w, v = e.z * e.z, S = e.z * e.w, E = e.w * e.w, b = h - m - v + E, w = 2 * (d - S), M = 2 * (f + x), P = 2 * (d + S), D = -h + m - v + E, L = 2 * (y - p), O = 2 * (f - x), F = 2 * (y + p), k = -h - m + v + E, V = s.elements;
    return V[0] = b * a, V[1] = P * a, V[2] = O * a, V[3] = 0, V[4] = w * c, V[5] = D * c, V[6] = F * c, V[7] = 0, V[8] = M * l, V[9] = L * l, V[10] = k * l, V[11] = 0, V[12] = i.x, V[13] = i.y, V[14] = i.z, V[15] = 1, s;
  }
}
_(StaticMatrix4, "IDENTITY", Object.freeze(new Matrix4()));
StaticMatrix4.ZERO = Object.freeze(
  new Matrix4(
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  )
);
let scratchHPRQuaternion$1 = new Quaternion$1(), scratchHeadingQuaternion = new Quaternion$1(), scratchPitchQuaternion = new Quaternion$1(), scratchRollQuaternion = new Quaternion$1(), fromAxisAngleScratch = new Vector3$1();
class StaticQuaternion {
  static fromAxisAngle(i, e, r) {
    return r || (r = new Quaternion$1()), fromAxisAngleScratch.copy(i), fromAxisAngleScratch.normalize(), r.setFromAxisAngle(fromAxisAngleScratch, e), r;
  }
  static multiply(i, e, r) {
    return r || (r = new Quaternion$1()), r.multiplyQuaternions(i, e), r;
  }
  static fromHeadingPitchRoll(i, e) {
    return scratchRollQuaternion = StaticQuaternion.fromAxisAngle(
      Cartesian3.UNIT_X,
      i.roll,
      scratchHPRQuaternion$1
    ), scratchPitchQuaternion = StaticQuaternion.fromAxisAngle(
      Cartesian3.UNIT_Y,
      -i.pitch,
      e
    ), e = StaticQuaternion.multiply(
      scratchPitchQuaternion,
      scratchRollQuaternion,
      scratchPitchQuaternion
    ), scratchHeadingQuaternion = StaticQuaternion.fromAxisAngle(
      Cartesian3.UNIT_Z,
      -i.heading,
      scratchHPRQuaternion$1
    ), StaticQuaternion.multiply(scratchHeadingQuaternion, e, e);
  }
}
class Rectangle {
  constructor(i, e, r, s) {
    this.west = i || 0, this.south = e || 0, this.east = r || 0, this.north = s || 0;
  }
  get width() {
    return Rectangle.computeWidth(this);
  }
  get height() {
    return Rectangle.computeHeight(this);
  }
}
Rectangle.fromDegrees = function(o, i, e, r, s) {
  return o = MathUtils.degToRad(defaultValue(o, 0)), i = MathUtils.degToRad(defaultValue(i, 0)), e = MathUtils.degToRad(defaultValue(e, 0)), r = MathUtils.degToRad(defaultValue(r, 0)), defined$1(s) ? (s.west = o, s.south = i, s.east = e, s.north = r, s) : new Rectangle(o, i, e, r);
};
Rectangle.computeWidth = function(o) {
  let i = o.east;
  const e = o.west;
  return i < e && (i += CesiumMath.TWO_PI), i - e;
};
Rectangle.computeHeight = function(o) {
  return o.north - o.south;
};
Rectangle.clone = function(o, i) {
  if (!!defined$1(o))
    return defined$1(i) ? (i.west = o.west, i.south = o.south, i.east = o.east, i.north = o.north, i) : new Rectangle(o.west, o.south, o.east, o.north);
};
Rectangle.southwest = function(o, i) {
  return defined$1(i) ? (i.x = o.west, i.y = o.south, i.z = 0, i) : new Vector3$1(o.west, o.south);
};
Rectangle.northeast = function(o, i) {
  return defined$1(i) ? (i.x = o.east, i.y = o.north, i.z = 0, i) : new Vector3$1(o.east, o.north);
};
Rectangle.southeast = function(o, i) {
  return defined$1(i) ? (i.x = o.east, i.y = o.south, i.z = 0, i) : new Vector3$1(o.east, o.south);
};
Rectangle.northwest = function(o, i) {
  return defined$1(i) ? (i.x = o.west, i.y = o.north, i.z = 0, i) : new Vector3$1(o.west, o.north);
};
Rectangle.center = function(o, i) {
  let e = o.east;
  const r = o.west;
  e < r && (e += CesiumMath.TWO_PI);
  const s = CesiumMath.negativePiToPi((r + e) * 0.5), a = (o.south + o.north) * 0.5;
  return defined$1(i) ? (i.x = s, i.y = a, i.z = 0, i) : new Vector3$1(s, a);
};
Rectangle.contains = function(o, i) {
  let e = i.x;
  const r = i.y, s = o.west;
  let a = o.east;
  return a < s && (a += CesiumMath.TWO_PI, e < 0 && (e += CesiumMath.TWO_PI)), (e > s || CesiumMath.equalsEpsilon(e, s, CesiumMath.EPSILON14)) && (e < a || CesiumMath.equalsEpsilon(e, a, CesiumMath.EPSILON14)) && r >= o.south && r <= o.north;
};
const maxPI = Math.PI + 1e-5, minPI = -Math.PI - 1e-5, maxPIOverTwo = CesiumMath.PI_OVER_TWO + 1e-5, minPIOverTwo = -CesiumMath.PI_OVER_TWO - 1e-5;
Rectangle.fromBox = function(o, i, e = !1) {
  const r = o.min, s = o.max;
  let a = r.x / 180 * Math.PI, c = r.y / 180 * Math.PI, l = s.x / 180 * Math.PI, h = s.y / 180 * Math.PI;
  return e && (a < minPI && (a = -Math.PI), a > maxPI && (a = Math.PI), c < minPIOverTwo && (c = -CesiumMath.PI_OVER_TWO), c > maxPIOverTwo && (c = CesiumMath.PI_OVER_TWO), l > maxPI && (l = Math.PI), l < minPI && (l = -Math.PI), h > maxPIOverTwo && (h = CesiumMath.PI_OVER_TWO), h < minPIOverTwo && (h = -CesiumMath.PI_OVER_TWO)), defined$1(i) ? (i.west = a, i.south = c, i.east = l, i.north = h, i) : new Rectangle(a, c, l, h);
};
Rectangle.MAX_VALUE = Object.freeze(
  new Rectangle(
    -Math.PI,
    -CesiumMath.PI_OVER_TWO,
    Math.PI,
    CesiumMath.PI_OVER_TWO
  )
);
class HeadingPitchRange {
  constructor(i, e, r) {
    this.heading = defaultValue(i, 0), this.pitch = defaultValue(e, 0), this.range = defaultValue(r, 0);
  }
  clone(i, e) {
    if (!!defined$1(i))
      return defined$1(e) || (e = new HeadingPitchRange()), e.heading = i.heading, e.pitch = i.pitch, e.range = i.range, e;
  }
}
const Transforms = {}, scratchHPRQuaternion = new Quaternion$1(), scratchScale$2 = new Vector3$1(1, 1, 1), scratchHPRMatrix4 = new Matrix4(), vectorProductLocalFrame = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
};
let degeneratePositionLocalFrame = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, localFrameToFixedFrameCache = {}, scratchCalculateCartesian = {
  east: new Vector3$1(),
  north: new Vector3$1(),
  up: new Vector3$1(),
  west: new Vector3$1(),
  south: new Vector3$1(),
  down: new Vector3$1()
}, scratchFirstCartesian = new Vector3$1(), scratchSecondCartesian = new Vector3$1(), scratchThirdCartesian = new Vector3$1();
const defined = (o) => o !== void 0, zeroVector3 = new Vector3$1(), mathSign = (o) => (o = +o, o === 0 ? o : o > 0 ? 1 : -1), scratchN = new Vector3$1(), scratchK = new Vector3$1(), radianToEcef = function(o, i, e = 0, r) {
  const s = new Vector3$1(
    40680631590769,
    40680631590769,
    40408299984661445e-3
  ), a = Math.cos(i);
  scratchN.x = a * Math.cos(o), scratchN.y = a * Math.sin(o), scratchN.z = Math.sin(i), scratchN.normalize(), scratchK.multiplyVectors(s, scratchN);
  const c = Math.sqrt(scratchN.dot(scratchK));
  return scratchK.divideScalar(c), scratchN.multiplyScalar(e), defined(r) || (r = new Vector3$1()), r.addVectors(scratchK, scratchN);
}, lnglatToEcef = (o, i, e = 0, r) => radianToEcef(o * Math.PI / 180, i * Math.PI / 180, e, r);
Transforms.lnglatToEcef = lnglatToEcef;
Transforms.radianToEcef = radianToEcef;
Transforms.localFrameToFixedFrameGenerator = function(o, i) {
  if (!vectorProductLocalFrame.hasOwnProperty(o) || !vectorProductLocalFrame[o].hasOwnProperty(i))
    throw new Error(
      "firstAxis and secondAxis must be east, north, up, west, south or down."
    );
  let e = vectorProductLocalFrame[o][i], r, s = o + i;
  return defined(localFrameToFixedFrameCache[s]) ? r = localFrameToFixedFrameCache[s] : (r = function(a, c, l) {
    if (!defined(a))
      throw new Error("origin is required.");
    if (defined(l) || (l = new Matrix4()), a.equals(zeroVector3))
      scratchFirstCartesian.fromArray(degeneratePositionLocalFrame[o]), scratchSecondCartesian.fromArray(degeneratePositionLocalFrame[i]), scratchThirdCartesian.fromArray(degeneratePositionLocalFrame[e]);
    else if (Math.abs(a.x) < 1e-14 && Math.abs(a.y) < 1e-14) {
      let d = mathSign(a.z);
      scratchFirstCartesian.fromArray(degeneratePositionLocalFrame[o]), o !== "east" && o !== "west" && scratchFirstCartesian.multiplyScalar(d), scratchSecondCartesian.fromArray(degeneratePositionLocalFrame[i]), i !== "east" && i !== "west" && scratchSecondCartesian.multiplyScalar(d), scratchThirdCartesian.fromArray(degeneratePositionLocalFrame[e]), e !== "east" && e !== "west" && scratchThirdCartesian.multiplyScalar(d);
    } else {
      c = c || Ellipsoid.WGS84, c.geodeticSurfaceNormal(a, scratchCalculateCartesian.up);
      let d = scratchCalculateCartesian.up, f = scratchCalculateCartesian.east;
      f.x = -a.y, f.y = a.x, f.z = 0, scratchCalculateCartesian.east.copy(f).normalize(), scratchCalculateCartesian.north.crossVectors(d, f), scratchCalculateCartesian.down.copy(scratchCalculateCartesian.up).multiplyScalar(-1), scratchCalculateCartesian.west.copy(scratchCalculateCartesian.east).multiplyScalar(-1), scratchCalculateCartesian.south.copy(scratchCalculateCartesian.north).multiplyScalar(-1), scratchFirstCartesian = scratchCalculateCartesian[o], scratchSecondCartesian = scratchCalculateCartesian[i], scratchThirdCartesian = scratchCalculateCartesian[e];
    }
    const h = l.elements;
    return h[0] = scratchFirstCartesian.x, h[1] = scratchFirstCartesian.y, h[2] = scratchFirstCartesian.z, h[3] = 0, h[4] = scratchSecondCartesian.x, h[5] = scratchSecondCartesian.y, h[6] = scratchSecondCartesian.z, h[7] = 0, h[8] = scratchThirdCartesian.x, h[9] = scratchThirdCartesian.y, h[10] = scratchThirdCartesian.z, h[11] = 0, h[12] = a.x, h[13] = a.y, h[14] = a.z, h[15] = 1, l;
  }, localFrameToFixedFrameCache[s] = r), r;
};
Transforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
  "east",
  "north"
);
Transforms.headingPitchRollToFixedFrame = function(o, i, e, r, s) {
  r = r || Transforms.eastNorthUpToFixedFrame;
  const a = StaticQuaternion.fromHeadingPitchRoll(
    i,
    scratchHPRQuaternion
  ), c = StaticMatrix4.fromTranslationQuaternionRotationScale(
    Cartesian3.ZERO,
    a,
    scratchScale$2,
    scratchHPRMatrix4
  );
  return s = r(o, e, s), s.multiply(c);
};
Transforms.northEastDownToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
  "north",
  "east"
);
Transforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
  "north",
  "up"
);
Transforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
  "north",
  "west"
);
function Interval(o, i) {
  this.start = defaultValue(o, 0), this.stop = defaultValue(i, 0);
}
var QuadraticRealPolynomial = {};
QuadraticRealPolynomial.computeDiscriminant = function(o, i, e) {
  if (typeof o != "number")
    throw new DeveloperError("a is a required number.");
  if (typeof i != "number")
    throw new DeveloperError("b is a required number.");
  if (typeof e != "number")
    throw new DeveloperError("c is a required number.");
  var r = i * i - 4 * o * e;
  return r;
};
function addWithCancellationCheck$1(o, i, e) {
  var r = o + i;
  return CesiumMath.sign(o) !== CesiumMath.sign(i) && Math.abs(r / Math.max(Math.abs(o), Math.abs(i))) < e ? 0 : r;
}
QuadraticRealPolynomial.computeRealRoots = function(o, i, e) {
  if (typeof o != "number")
    throw new DeveloperError("a is a required number.");
  if (typeof i != "number")
    throw new DeveloperError("b is a required number.");
  if (typeof e != "number")
    throw new DeveloperError("c is a required number.");
  var r;
  if (o === 0)
    return i === 0 ? [] : [-e / i];
  if (i === 0) {
    if (e === 0)
      return [0, 0];
    var s = Math.abs(e), a = Math.abs(o);
    if (s < a && s / a < CesiumMath.EPSILON14)
      return [0, 0];
    if (s > a && a / s < CesiumMath.EPSILON14)
      return [];
    if (r = -e / o, r < 0)
      return [];
    var c = Math.sqrt(r);
    return [-c, c];
  } else if (e === 0)
    return r = -i / o, r < 0 ? [r, 0] : [0, r];
  var l = i * i, h = 4 * o * e, d = addWithCancellationCheck$1(l, -h, CesiumMath.EPSILON14);
  if (d < 0)
    return [];
  var f = -0.5 * addWithCancellationCheck$1(
    i,
    CesiumMath.sign(i) * Math.sqrt(d),
    CesiumMath.EPSILON14
  );
  return i > 0 ? [f / o, e / f] : [e / f, f / o];
};
var CubicRealPolynomial = {};
CubicRealPolynomial.computeDiscriminant = function(o, i, e, r) {
  if (typeof o != "number")
    throw new DeveloperError("a is a required number.");
  if (typeof i != "number")
    throw new DeveloperError("b is a required number.");
  if (typeof e != "number")
    throw new DeveloperError("c is a required number.");
  if (typeof r != "number")
    throw new DeveloperError("d is a required number.");
  var s = o * o, a = i * i, c = e * e, l = r * r, h = 18 * o * i * e * r + a * c - 27 * s * l - 4 * (o * c * e + a * i * r);
  return h;
};
function computeRealRoots(o, i, e, r) {
  var s = o, a = i / 3, c = e / 3, l = r, h = s * c, d = a * l, f = a * a, p = c * c, m = s * c - f, y = s * l - a * c, x = a * l - p, v = 4 * m * x - y * y, S, E;
  if (v < 0) {
    var b, w, M;
    f * d >= h * p ? (b = s, w = m, M = -2 * a * m + s * y) : (b = l, w = x, M = -l * y + 2 * c * x);
    var P = M < 0 ? -1 : 1, D = -P * Math.abs(b) * Math.sqrt(-v);
    E = -M + D;
    var L = E / 2, O = L < 0 ? -Math.pow(-L, 1 / 3) : Math.pow(L, 1 / 3), F = E === D ? -O : -w / O;
    return S = w <= 0 ? O + F : -M / (O * O + F * F + w), f * d >= h * p ? [(S - a) / s] : [-l / (S + c)];
  }
  var k = m, V = -2 * a * m + s * y, N = x, U = -l * y + 2 * c * x, z = Math.sqrt(v), $ = Math.sqrt(3) / 2, G = Math.abs(Math.atan2(s * z, -V) / 3);
  S = 2 * Math.sqrt(-k);
  var j = Math.cos(G);
  E = S * j;
  var Y = S * (-j / 2 - $ * Math.sin(G)), H = E + Y > 2 * a ? E - a : Y - a, W = s, q = H / W;
  G = Math.abs(Math.atan2(l * z, -U) / 3), S = 2 * Math.sqrt(-N), j = Math.cos(G), E = S * j, Y = S * (-j / 2 - $ * Math.sin(G));
  var Z = -l, X = E + Y < 2 * c ? E + c : Y + c, K = Z / X, ee = W * X, ie = -H * X - W * Z, re = H * Z, ne = (c * ie - a * re) / (-a * ie + c * ee);
  return q <= ne ? q <= K ? ne <= K ? [q, ne, K] : [q, K, ne] : [K, q, ne] : q <= K ? [ne, q, K] : ne <= K ? [ne, K, q] : [K, ne, q];
}
CubicRealPolynomial.computeRealRoots = function(o, i, e, r) {
  if (typeof o != "number")
    throw new DeveloperError("a is a required number.");
  if (typeof i != "number")
    throw new DeveloperError("b is a required number.");
  if (typeof e != "number")
    throw new DeveloperError("c is a required number.");
  if (typeof r != "number")
    throw new DeveloperError("d is a required number.");
  var s, a;
  if (o === 0)
    return QuadraticRealPolynomial.computeRealRoots(i, e, r);
  if (i === 0) {
    if (e === 0) {
      if (r === 0)
        return [0, 0, 0];
      a = -r / o;
      var c = a < 0 ? -Math.pow(-a, 1 / 3) : Math.pow(a, 1 / 3);
      return [c, c, c];
    } else if (r === 0)
      return s = QuadraticRealPolynomial.computeRealRoots(o, 0, e), s.Length === 0 ? [0] : [s[0], 0, s[1]];
    return computeRealRoots(o, 0, e, r);
  } else {
    if (e === 0)
      return r === 0 ? (a = -i / o, a < 0 ? [a, 0, 0] : [0, 0, a]) : computeRealRoots(o, i, 0, r);
    if (r === 0)
      return s = QuadraticRealPolynomial.computeRealRoots(o, i, e), s.length === 0 ? [0] : s[1] <= 0 ? [s[0], s[1], 0] : s[0] >= 0 ? [0, s[0], s[1]] : [s[0], 0, s[1]];
  }
  return computeRealRoots(o, i, e, r);
};
var QuarticRealPolynomial = {};
QuarticRealPolynomial.computeDiscriminant = function(o, i, e, r, s) {
  if (typeof o != "number")
    throw new DeveloperError("a is a required number.");
  if (typeof i != "number")
    throw new DeveloperError("b is a required number.");
  if (typeof e != "number")
    throw new DeveloperError("c is a required number.");
  if (typeof r != "number")
    throw new DeveloperError("d is a required number.");
  if (typeof s != "number")
    throw new DeveloperError("e is a required number.");
  var a = o * o, c = a * o, l = i * i, h = l * i, d = e * e, f = d * e, p = r * r, m = p * r, y = s * s, x = y * s, v = l * d * p - 4 * h * m - 4 * o * f * p + 18 * o * i * e * m - 27 * a * p * p + 256 * c * x + s * (18 * h * e * r - 4 * l * f + 16 * o * d * d - 80 * o * i * d * r - 6 * o * l * p + 144 * a * e * p) + y * (144 * o * l * e - 27 * l * l - 128 * a * d - 192 * a * i * r);
  return v;
};
function original(o, i, e, r) {
  var s = o * o, a = i - 3 * s / 8, c = e - i * o / 2 + s * o / 8, l = r - e * o / 4 + i * s / 16 - 3 * s * s / 256, h = CubicRealPolynomial.computeRealRoots(
    1,
    2 * a,
    a * a - 4 * l,
    -c * c
  );
  if (h.length > 0) {
    var d = -o / 4, f = h[h.length - 1];
    if (Math.abs(f) < CesiumMath.EPSILON14) {
      var p = QuadraticRealPolynomial.computeRealRoots(1, a, l);
      if (p.length === 2) {
        var m = p[0], y = p[1], x;
        if (m >= 0 && y >= 0) {
          var v = Math.sqrt(m), S = Math.sqrt(y);
          return [d - S, d - v, d + v, d + S];
        } else {
          if (m >= 0 && y < 0)
            return x = Math.sqrt(m), [d - x, d + x];
          if (m < 0 && y >= 0)
            return x = Math.sqrt(y), [d - x, d + x];
        }
      }
      return [];
    } else if (f > 0) {
      var E = Math.sqrt(f), b = (a + f - c / E) / 2, w = (a + f + c / E) / 2, M = QuadraticRealPolynomial.computeRealRoots(1, E, b), P = QuadraticRealPolynomial.computeRealRoots(1, -E, w);
      return M.length !== 0 ? (M[0] += d, M[1] += d, P.length !== 0 ? (P[0] += d, P[1] += d, M[1] <= P[0] ? [M[0], M[1], P[0], P[1]] : P[1] <= M[0] ? [P[0], P[1], M[0], M[1]] : M[0] >= P[0] && M[1] <= P[1] ? [P[0], M[0], M[1], P[1]] : P[0] >= M[0] && P[1] <= M[1] ? [M[0], P[0], P[1], M[1]] : M[0] > P[0] && M[0] < P[1] ? [P[0], M[0], P[1], M[1]] : [M[0], P[0], M[1], P[1]]) : M) : P.length !== 0 ? (P[0] += d, P[1] += d, P) : [];
    }
  }
  return [];
}
function neumark(o, i, e, r) {
  var s = e * e, a = i * i, c = o * o, l = -2 * i, h = e * o + a - 4 * r, d = c * r - e * i * o + s, f = CubicRealPolynomial.computeRealRoots(1, l, h, d);
  if (f.length > 0) {
    var p = f[0], m = i - p, y = m * m, x = o / 2, v = m / 2, S = y - 4 * r, E = y + 4 * Math.abs(r), b = c - 4 * p, w = c + 4 * Math.abs(p), M, P;
    if (p < 0 || S * w < b * E) {
      var D = Math.sqrt(b);
      M = D / 2, P = D === 0 ? 0 : (o * v - e) / D;
    } else {
      var L = Math.sqrt(S);
      M = L === 0 ? 0 : (o * v - e) / L, P = L / 2;
    }
    var O, F;
    x === 0 && M === 0 ? (O = 0, F = 0) : CesiumMath.sign(x) === CesiumMath.sign(M) ? (O = x + M, F = p / O) : (F = x - M, O = p / F);
    var k, V;
    v === 0 && P === 0 ? (k = 0, V = 0) : CesiumMath.sign(v) === CesiumMath.sign(P) ? (k = v + P, V = r / k) : (V = v - P, k = r / V);
    var N = QuadraticRealPolynomial.computeRealRoots(1, O, k), U = QuadraticRealPolynomial.computeRealRoots(1, F, V);
    if (N.length !== 0)
      return U.length !== 0 ? N[1] <= U[0] ? [N[0], N[1], U[0], U[1]] : U[1] <= N[0] ? [U[0], U[1], N[0], N[1]] : N[0] >= U[0] && N[1] <= U[1] ? [U[0], N[0], N[1], U[1]] : U[0] >= N[0] && U[1] <= N[1] ? [N[0], U[0], U[1], N[1]] : N[0] > U[0] && N[0] < U[1] ? [U[0], N[0], U[1], N[1]] : [N[0], U[0], N[1], U[1]] : N;
    if (U.length !== 0)
      return U;
  }
  return [];
}
QuarticRealPolynomial.computeRealRoots = function(o, i, e, r, s) {
  if (typeof o != "number")
    throw new DeveloperError("a is a required number.");
  if (typeof i != "number")
    throw new DeveloperError("b is a required number.");
  if (typeof e != "number")
    throw new DeveloperError("c is a required number.");
  if (typeof r != "number")
    throw new DeveloperError("d is a required number.");
  if (typeof s != "number")
    throw new DeveloperError("e is a required number.");
  if (Math.abs(o) < CesiumMath.EPSILON15)
    return CubicRealPolynomial.computeRealRoots(i, e, r, s);
  var a = i / o, c = e / o, l = r / o, h = s / o, d = a < 0 ? 1 : 0;
  switch (d += c < 0 ? d + 1 : d, d += l < 0 ? d + 1 : d, d += h < 0 ? d + 1 : d, d) {
    case 0:
      return original(a, c, l, h);
    case 1:
      return neumark(a, c, l, h);
    case 2:
      return neumark(a, c, l, h);
    case 3:
      return original(a, c, l, h);
    case 4:
      return original(a, c, l, h);
    case 5:
      return neumark(a, c, l, h);
    case 6:
      return original(a, c, l, h);
    case 7:
      return original(a, c, l, h);
    case 8:
      return neumark(a, c, l, h);
    case 9:
      return original(a, c, l, h);
    case 10:
      return original(a, c, l, h);
    case 11:
      return neumark(a, c, l, h);
    case 12:
      return original(a, c, l, h);
    case 13:
      return original(a, c, l, h);
    case 14:
      return original(a, c, l, h);
    case 15:
      return original(a, c, l, h);
    default:
      return;
  }
};
var IntersectionTests = {};
IntersectionTests.rayPlane = function(o, i, e) {
  if (!defined$1(o))
    throw new DeveloperError("ray is required.");
  if (!defined$1(i))
    throw new DeveloperError("plane is required.");
  defined$1(e) || (e = new Vector3$1());
  var r = o.origin, s = o.direction, a = i.normal, c = Cartesian3.dot(a, s);
  if (!(Math.abs(c) < CesiumMath.EPSILON15)) {
    var l = (-i.constant - Cartesian3.dot(a, r)) / c;
    if (!(l < 0))
      return e = Cartesian3.multiplyByScalar(s, l, e), Cartesian3.add(r, e, e);
  }
};
var scratchEdge0 = new Vector3$1(), scratchEdge1 = new Vector3$1(), scratchPVec = new Vector3$1(), scratchTVec = new Vector3$1(), scratchQVec = new Vector3$1();
IntersectionTests.rayTriangleParametric = function(o, i, e, r, s) {
  if (!defined$1(o))
    throw new DeveloperError("ray is required.");
  if (!defined$1(i))
    throw new DeveloperError("p0 is required.");
  if (!defined$1(e))
    throw new DeveloperError("p1 is required.");
  if (!defined$1(r))
    throw new DeveloperError("p2 is required.");
  s = defaultValue(s, !1);
  var a = o.origin, c = o.direction, l = Cartesian3.subtract(e, i, scratchEdge0), h = Cartesian3.subtract(r, i, scratchEdge1), d = Cartesian3.cross(c, h, scratchPVec), f = Cartesian3.dot(l, d), p, m, y, x, v;
  if (s) {
    if (f < CesiumMath.EPSILON6 || (p = Cartesian3.subtract(a, i, scratchTVec), y = Cartesian3.dot(p, d), y < 0 || y > f) || (m = Cartesian3.cross(p, l, scratchQVec), x = Cartesian3.dot(c, m), x < 0 || y + x > f))
      return;
    v = Cartesian3.dot(h, m) / f;
  } else {
    if (Math.abs(f) < CesiumMath.EPSILON6)
      return;
    var S = 1 / f;
    if (p = Cartesian3.subtract(a, i, scratchTVec), y = Cartesian3.dot(p, d) * S, y < 0 || y > 1 || (m = Cartesian3.cross(p, l, scratchQVec), x = Cartesian3.dot(c, m) * S, x < 0 || y + x > 1))
      return;
    v = Cartesian3.dot(h, m) * S;
  }
  return v;
};
IntersectionTests.rayTriangle = function(o, i, e, r, s, a) {
  var c = IntersectionTests.rayTriangleParametric(
    o,
    i,
    e,
    r,
    s
  );
  if (!(!defined$1(c) || c < 0))
    return defined$1(a) || (a = new Vector3$1()), Cartesian3.multiplyByScalar(o.direction, c, a), Cartesian3.add(o.origin, a, a);
};
var scratchLineSegmentTriangleRay = new Ray();
IntersectionTests.lineSegmentTriangle = function(o, i, e, r, s, a, c) {
  if (!defined$1(o))
    throw new DeveloperError("v0 is required.");
  if (!defined$1(i))
    throw new DeveloperError("v1 is required.");
  if (!defined$1(e))
    throw new DeveloperError("p0 is required.");
  if (!defined$1(r))
    throw new DeveloperError("p1 is required.");
  if (!defined$1(s))
    throw new DeveloperError("p2 is required.");
  var l = scratchLineSegmentTriangleRay;
  Cartesian3.clone(o, l.origin), Cartesian3.subtract(i, o, l.direction), Cartesian3.normalize(l.direction, l.direction);
  var h = IntersectionTests.rayTriangleParametric(
    l,
    e,
    r,
    s,
    a
  );
  if (!(!defined$1(h) || h < 0 || h > Cartesian3.distance(o, i)))
    return defined$1(c) || (c = new Vector3$1()), Cartesian3.multiplyByScalar(l.direction, h, c), Cartesian3.add(l.origin, c, c);
};
function solveQuadratic(o, i, e, r) {
  var s = i * i - 4 * o * e;
  if (!(s < 0)) {
    if (s > 0) {
      var a = 1 / (2 * o), c = Math.sqrt(s), l = (-i + c) * a, h = (-i - c) * a;
      return l < h ? (r.root0 = l, r.root1 = h) : (r.root0 = h, r.root1 = l), r;
    }
    var d = -i / (2 * o);
    if (d !== 0)
      return r.root0 = r.root1 = d, r;
  }
}
var raySphereRoots = {
  root0: 0,
  root1: 0
};
function raySphere(o, i, e) {
  defined$1(e) || (e = new Interval());
  var r = o.origin, s = o.direction, a = i.center, c = i.radius * i.radius, l = Cartesian3.subtract(r, a, scratchPVec), h = Cartesian3.dot(s, s), d = 2 * Cartesian3.dot(s, l), f = Cartesian3.magnitudeSquared(l) - c, p = solveQuadratic(h, d, f, raySphereRoots);
  if (!!defined$1(p))
    return e.start = p.root0, e.stop = p.root1, e;
}
IntersectionTests.raySphere = function(o, i, e) {
  if (!defined$1(o))
    throw new DeveloperError("ray is required.");
  if (!defined$1(i))
    throw new DeveloperError("sphere is required.");
  if (e = raySphere(o, i, e), !(!defined$1(e) || e.stop < 0))
    return e.start = Math.max(e.start, 0), e;
};
var scratchLineSegmentRay = new Ray();
IntersectionTests.lineSegmentSphere = function(o, i, e, r) {
  if (!defined$1(o))
    throw new DeveloperError("p0 is required.");
  if (!defined$1(i))
    throw new DeveloperError("p1 is required.");
  if (!defined$1(e))
    throw new DeveloperError("sphere is required.");
  var s = scratchLineSegmentRay;
  Cartesian3.clone(o, s.origin);
  var a = Cartesian3.subtract(i, o, s.direction), c = Cartesian3.magnitude(a);
  if (Cartesian3.normalize(a, a), r = raySphere(s, e, r), !(!defined$1(r) || r.stop < 0 || r.start > c))
    return r.start = Math.max(r.start, 0), r.stop = Math.min(r.stop, c), r;
};
var scratchQ = new Vector3$1(), scratchW = new Vector3$1();
IntersectionTests.rayEllipsoid = function(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("ray is required.");
  if (!defined$1(i))
    throw new DeveloperError("ellipsoid is required.");
  var e = i.oneOverRadii, r = Cartesian3.multiplyComponents(e, o.origin, scratchQ), s = Cartesian3.multiplyComponents(e, o.direction, scratchW), a = Cartesian3.magnitudeSquared(r), c = Cartesian3.dot(r, s), l, h, d, f, p;
  if (a > 1) {
    if (c >= 0)
      return;
    var m = c * c;
    if (l = a - 1, h = Cartesian3.magnitudeSquared(s), d = h * l, m < d)
      return;
    if (m > d) {
      f = c * c - d, p = -c + Math.sqrt(f);
      var y = p / h, x = l / p;
      return y < x ? new Interval(y, x) : {
        start: x,
        stop: y
      };
    }
    var v = Math.sqrt(l / h);
    return new Interval(v, v);
  } else if (a < 1)
    return l = a - 1, h = Cartesian3.magnitudeSquared(s), d = h * l, f = c * c - d, p = -c + Math.sqrt(f), new Interval(0, p / h);
  if (c < 0)
    return h = Cartesian3.magnitudeSquared(s), new Interval(0, -c / h);
};
function addWithCancellationCheck(o, i, e) {
  var r = o + i;
  return CesiumMath.sign(o) !== CesiumMath.sign(i) && Math.abs(r / Math.max(Math.abs(o), Math.abs(i))) < e ? 0 : r;
}
function quadraticVectorExpression(o, i, e, r, s) {
  var a = r * r, c = s * s, l = (o[StaticMatrix3.COLUMN1ROW1] - o[StaticMatrix3.COLUMN2ROW2]) * c, h = s * (r * addWithCancellationCheck(
    o[StaticMatrix3.COLUMN1ROW0],
    o[StaticMatrix3.COLUMN0ROW1],
    CesiumMath.EPSILON15
  ) + i.y), d = o[StaticMatrix3.COLUMN0ROW0] * a + o[StaticMatrix3.COLUMN2ROW2] * c + r * i.x + e, f = c * addWithCancellationCheck(
    o[StaticMatrix3.COLUMN2ROW1],
    o[StaticMatrix3.COLUMN1ROW2],
    CesiumMath.EPSILON15
  ), p = s * (r * addWithCancellationCheck(o[StaticMatrix3.COLUMN2ROW0], o[StaticMatrix3.COLUMN0ROW2]) + i.z), m, y = [];
  if (p === 0 && f === 0) {
    if (m = QuadraticRealPolynomial.computeRealRoots(l, h, d), m.length === 0)
      return y;
    var x = m[0], v = Math.sqrt(Math.max(1 - x * x, 0));
    if (y.push(new Vector3$1(r, s * x, s * -v)), y.push(new Vector3$1(r, s * x, s * v)), m.length === 2) {
      var S = m[1], E = Math.sqrt(Math.max(1 - S * S, 0));
      y.push(new Vector3$1(r, s * S, s * -E)), y.push(new Vector3$1(r, s * S, s * E));
    }
    return y;
  }
  var b = p * p, w = f * f, M = l * l, P = p * f, D = M + w, L = 2 * (h * l + P), O = 2 * d * l + h * h - w + b, F = 2 * (d * h - P), k = d * d - b;
  if (D === 0 && L === 0 && O === 0 && F === 0)
    return y;
  m = QuarticRealPolynomial.computeRealRoots(D, L, O, F, k);
  var V = m.length;
  if (V === 0)
    return y;
  for (var N = 0; N < V; ++N) {
    var U = m[N], z = U * U, $ = Math.max(1 - z, 0), G = Math.sqrt($), j;
    CesiumMath.sign(l) === CesiumMath.sign(d) ? j = addWithCancellationCheck(
      l * z + d,
      h * U,
      CesiumMath.EPSILON12
    ) : CesiumMath.sign(d) === CesiumMath.sign(h * U) ? j = addWithCancellationCheck(
      l * z,
      h * U + d,
      CesiumMath.EPSILON12
    ) : j = addWithCancellationCheck(
      l * z + h * U,
      d,
      CesiumMath.EPSILON12
    );
    var Y = addWithCancellationCheck(f * U, p, CesiumMath.EPSILON15), H = j * Y;
    H < 0 ? y.push(new Vector3$1(r, s * U, s * G)) : H > 0 ? y.push(new Vector3$1(r, s * U, s * -G)) : G !== 0 ? (y.push(new Vector3$1(r, s * U, s * -G)), y.push(new Vector3$1(r, s * U, s * G)), ++N) : y.push(new Vector3$1(r, s * U, s * G));
  }
  return y;
}
var firstAxisScratch = new Vector3$1(), secondAxisScratch = new Vector3$1(), thirdAxisScratch = new Vector3$1(), referenceScratch = new Vector3$1(), bCart = new Vector3$1(), bScratch = new Matrix3(), btScratch = new Matrix3(), diScratch = new Matrix3(), dScratch = new Matrix3(), cScratch = new Matrix3(), tempMatrix$2 = new Matrix3(), aScratch = new Matrix3(), sScratch = new Vector3$1(), closestScratch = new Vector3$1(), surfPointScratch = new Vector3$1();
IntersectionTests.grazingAltitudeLocation = function(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("ray is required.");
  if (!defined$1(i))
    throw new DeveloperError("ellipsoid is required.");
  var e = o.origin, r = o.direction;
  if (!Cartesian3.equals(e, Cartesian3.ZERO)) {
    var s = i.geodeticSurfaceNormal(e, firstAxisScratch);
    if (Cartesian3.dot(r, s) >= 0)
      return e;
  }
  var a = defined$1(this.rayEllipsoid(o, i)), c = i.transformPositionToScaledSpace(r, firstAxisScratch), l = Cartesian3.normalize(c, c), h = Cartesian3.mostOrthogonalAxis(c, referenceScratch), d = Cartesian3.normalize(
    Cartesian3.cross(h, l, secondAxisScratch),
    secondAxisScratch
  ), f = Cartesian3.normalize(
    Cartesian3.cross(l, d, thirdAxisScratch),
    thirdAxisScratch
  ), p = bScratch;
  p[0] = l.x, p[1] = l.y, p[2] = l.z, p[3] = d.x, p[4] = d.y, p[5] = d.z, p[6] = f.x, p[7] = f.y, p[8] = f.z;
  var m = StaticMatrix3.transpose(p, btScratch), y = StaticMatrix3.fromScale(i.radii, diScratch), x = StaticMatrix3.fromScale(i.oneOverRadii, dScratch), v = cScratch;
  v[0] = 0, v[1] = -r.z, v[2] = r.y, v[3] = r.z, v[4] = 0, v[5] = -r.x, v[6] = -r.y, v[7] = r.x, v[8] = 0;
  var S = StaticMatrix3.multiply(
    StaticMatrix3.multiply(m, x, tempMatrix$2),
    v,
    tempMatrix$2
  ), E = StaticMatrix3.multiply(StaticMatrix3.multiply(S, y, aScratch), p, aScratch), b = StaticMatrix3.multiplyByVector(S, e, bCart), w = quadraticVectorExpression(
    E,
    Cartesian3.negate(b, firstAxisScratch),
    0,
    0,
    1
  ), M, P, D = w.length;
  if (D > 0) {
    for (var L = Cartesian3.clone(Cartesian3.ZERO, closestScratch), O = Number.NEGATIVE_INFINITY, F = 0; F < D; ++F) {
      M = StaticMatrix3.multiplyByVector(
        y,
        StaticMatrix3.multiplyByVector(p, w[F], sScratch),
        sScratch
      );
      var k = Cartesian3.normalize(
        Cartesian3.subtract(M, e, referenceScratch),
        referenceScratch
      ), V = Cartesian3.dot(k, r);
      V > O && (O = V, L = Cartesian3.clone(M, L));
    }
    var N = i.cartesianToCartographic(
      L,
      surfPointScratch
    );
    return O = CesiumMath.clamp(O, 0, 1), P = Cartesian3.magnitude(
      Cartesian3.subtract(L, e, referenceScratch)
    ) * Math.sqrt(1 - O * O), P = a ? -P : P, N.z = P, i.cartographicToCartesian(N, new Vector3$1());
  }
};
var lineSegmentPlaneDifference = new Vector3$1();
IntersectionTests.lineSegmentPlane = function(o, i, e, r) {
  if (!defined$1(o))
    throw new DeveloperError("endPoint0 is required.");
  if (!defined$1(i))
    throw new DeveloperError("endPoint1 is required.");
  if (!defined$1(e))
    throw new DeveloperError("plane is required.");
  defined$1(r) || (r = new Vector3$1());
  var s = Cartesian3.subtract(
    i,
    o,
    lineSegmentPlaneDifference
  ), a = e.normal, c = Cartesian3.dot(a, s);
  if (!(Math.abs(c) < CesiumMath.EPSILON6)) {
    var l = Cartesian3.dot(a, o), h = -(e.constant + l) / c;
    if (!(h < 0 || h > 1))
      return Cartesian3.multiplyByScalar(s, h, r), Cartesian3.add(o, r, r), r;
  }
};
IntersectionTests.trianglePlaneIntersection = function(o, i, e, r) {
  if (!defined$1(o) || !defined$1(i) || !defined$1(e) || !defined$1(r))
    throw new DeveloperError("p0, p1, p2, and plane are required.");
  var s = r.normal, a = r.constant, c = Cartesian3.dot(s, o) + a < 0, l = Cartesian3.dot(s, i) + a < 0, h = Cartesian3.dot(s, e) + a < 0, d = 0;
  d += c ? 1 : 0, d += l ? 1 : 0, d += h ? 1 : 0;
  var f, p;
  if ((d === 1 || d === 2) && (f = new Vector3$1(), p = new Vector3$1()), d === 1) {
    if (c)
      return IntersectionTests.lineSegmentPlane(o, i, r, f), IntersectionTests.lineSegmentPlane(o, e, r, p), {
        positions: [o, i, e, f, p],
        indices: [
          0,
          3,
          4,
          1,
          2,
          4,
          1,
          4,
          3
        ]
      };
    if (l)
      return IntersectionTests.lineSegmentPlane(i, e, r, f), IntersectionTests.lineSegmentPlane(i, o, r, p), {
        positions: [o, i, e, f, p],
        indices: [
          1,
          3,
          4,
          2,
          0,
          4,
          2,
          4,
          3
        ]
      };
    if (h)
      return IntersectionTests.lineSegmentPlane(e, o, r, f), IntersectionTests.lineSegmentPlane(e, i, r, p), {
        positions: [o, i, e, f, p],
        indices: [
          2,
          3,
          4,
          0,
          1,
          4,
          0,
          4,
          3
        ]
      };
  } else if (d === 2)
    if (c)
      if (l) {
        if (!h)
          return IntersectionTests.lineSegmentPlane(o, e, r, f), IntersectionTests.lineSegmentPlane(i, e, r, p), {
            positions: [o, i, e, f, p],
            indices: [
              0,
              1,
              4,
              0,
              4,
              3,
              2,
              3,
              4
            ]
          };
      } else
        return IntersectionTests.lineSegmentPlane(e, i, r, f), IntersectionTests.lineSegmentPlane(o, i, r, p), {
          positions: [o, i, e, f, p],
          indices: [
            2,
            0,
            4,
            2,
            4,
            3,
            1,
            3,
            4
          ]
        };
    else
      return IntersectionTests.lineSegmentPlane(i, o, r, f), IntersectionTests.lineSegmentPlane(e, o, r, p), {
        positions: [o, i, e, f, p],
        indices: [
          1,
          2,
          4,
          1,
          4,
          3,
          0,
          3,
          4
        ]
      };
};
class StaticRay {
  static getPoint(i, e, r) {
    return r || (r = new Vector3$1()), r.copy(i.direction).multiplyScalar(e).add(i.origin), r;
  }
}
const SceneMode = {
  MORPHING: 0,
  COLUMBUS_VIEW: 1,
  SCENE2D: 2,
  SCENE3D: 3
};
SceneMode.getMorphTime = function(o) {
  return o === SceneMode.SCENE3D ? 1 : o === SceneMode.MORPHING ? void 0 : 0;
};
const SceneMode$1 = Object.freeze(SceneMode), MapMode2D = {
  ROTATE: 0,
  INFINITE_SCROLL: 1
};
Object.freeze(MapMode2D);
const cartesianToCartographicN = new Vector3$1(), cartesianToCartographicP = new Vector3$1(), cartesianToCartographicH = new Vector3$1(), wgs84OneOverRadii = new Vector3$1(
  1 / 6378137,
  1 / 6378137,
  1 / 6356752314245179e-9
), wgs84OneOverRadiiSquared = new Vector3$1(
  1 / (6378137 * 6378137),
  1 / (6378137 * 6378137),
  1 / (6356752314245179e-9 * 6356752314245179e-9)
), wgs84CenterToleranceSquared = CesiumMath.EPSILON1, at = class {
  static fromRadians(i, e, r, s) {
    return r = defaultValue(r, 0), defined$1(s) ? (s.x = i, s.y = e, s.z = r, s) : new Vector3$1(i, e, r);
  }
  static fromDegrees(i, e, r, s) {
    return i = CesiumMath.toRadians(i), e = CesiumMath.toRadians(e), at.fromRadians(i, e, r, s);
  }
  static fromCartesian(i, e, r) {
    const s = defined$1(e) ? e.oneOverRadii : wgs84OneOverRadii, a = defined$1(e) ? e.oneOverRadiiSquared : wgs84OneOverRadiiSquared, c = defined$1(e) ? e._centerToleranceSquared : wgs84CenterToleranceSquared, l = scaleToGeodeticSurface(
      i,
      s,
      a,
      c,
      cartesianToCartographicP
    );
    if (!defined$1(l))
      return;
    let h = Cartesian3.multiplyComponents(
      l,
      a,
      cartesianToCartographicN
    );
    h = Cartesian3.normalize(h, h);
    const d = Cartesian3.subtract(i, l, cartesianToCartographicH), f = Math.atan2(h.y, h.x), p = Math.asin(h.z), m = CesiumMath.sign(Cartesian3.dot(d, i)) * Cartesian3.magnitude(d);
    return defined$1(r) ? (r.x = f, r.y = p, r.z = m, r) : new Vector3$1(f, p, m);
  }
  static toCartesian(i, e, r) {
    return Cartesian3.fromRadians(
      i.x,
      i.y,
      i.z,
      e,
      r
    );
  }
  static clone(i, e) {
    if (!!defined$1(i))
      return defined$1(e) ? (e.x = i.x, e.y = i.y, e.z = i.z, e) : new Vector3$1(
        i.x,
        i.y,
        i.z
      );
  }
  static equals(i, e) {
    return i === e || defined$1(i) && defined$1(e) && i.x === e.x && i.y === e.y && i.z === e.z;
  }
  static equalsEpsilon(i, e, r) {
    return r = defaultValue(r, 0), i === e || defined$1(i) && defined$1(e) && CesiumMath.equalsEpsilon(i.x, e.x, r) && CesiumMath.equalsEpsilon(i.y, e.y, r) && CesiumMath.equalsEpsilon(i.z, e.z, r);
  }
};
let Cartographic = at;
_(Cartographic, "fromRadians", function(i, e, r, s) {
  return r = defaultValue(r, 0), defined$1(s) ? (s.x = i, s.y = e, s.z = r, s) : new Vector3$1(i, e, r);
}), _(Cartographic, "fromDegrees", function(i, e, r, s) {
  return i = CesiumMath.toRadians(i), e = CesiumMath.toRadians(e), at.fromRadians(i, e, r, s);
}), _(Cartographic, "ZERO", Object.freeze(new Vector3$1(0, 0, 0)));
function setConstants(o) {
  const i = o._uSquared, e = o._ellipsoid.maximumRadius, r = o._ellipsoid.minimumRadius, s = (e - r) / e, a = Math.cos(o._startHeading), c = Math.sin(o._startHeading), l = (1 - s) * Math.tan(o._start.y), h = 1 / Math.sqrt(1 + l * l), d = h * l, f = Math.atan2(l, a), p = h * c, m = p * p, y = 1 - m, x = Math.sqrt(y), v = i / 4, S = v * v, E = S * v, b = S * S, w = 1 + v - 3 * S / 4 + 5 * E / 4 - 175 * b / 64, M = 1 - v + 15 * S / 8 - 35 * E / 8, P = 1 - 3 * v + 35 * S / 4, D = 1 - 5 * v, L = w * f - M * Math.sin(2 * f) * v / 2 - P * Math.sin(4 * f) * S / 16 - D * Math.sin(6 * f) * E / 48 - Math.sin(8 * f) * 5 * b / 512, O = o._constants;
  O.a = e, O.b = r, O.f = s, O.cosineHeading = a, O.sineHeading = c, O.tanU = l, O.cosineU = h, O.sineU = d, O.sigma = f, O.sineAlpha = p, O.sineSquaredAlpha = m, O.cosineSquaredAlpha = y, O.cosineAlpha = x, O.u2Over4 = v, O.u4Over16 = S, O.u6Over64 = E, O.u8Over256 = b, O.a0 = w, O.a1 = M, O.a2 = P, O.a3 = D, O.distanceRatio = L;
}
function computeC(o, i) {
  return o * i * (4 + o * (4 - 3 * i)) / 16;
}
function computeDeltaLambda(o, i, e, r, s, a, c) {
  const l = computeC(o, e);
  return (1 - l) * o * i * (r + l * s * (c + l * a * (2 * c * c - 1)));
}
function vincentyInverseFormula(o, i, e, r, s, a, c) {
  const l = (i - e) / i, h = a - r, d = Math.atan((1 - l) * Math.tan(s)), f = Math.atan((1 - l) * Math.tan(c)), p = Math.cos(d), m = Math.sin(d), y = Math.cos(f), x = Math.sin(f), v = p * y, S = p * x, E = m * x, b = m * y;
  let w = h, M = CesiumMath.TWO_PI, P = Math.cos(w), D = Math.sin(w), L, O, F, k, V;
  do {
    P = Math.cos(w), D = Math.sin(w);
    const W = S - b * P;
    F = Math.sqrt(
      y * y * D * D + W * W
    ), O = E + v * P, L = Math.atan2(F, O);
    let q;
    F === 0 ? (q = 0, k = 1) : (q = v * D / F, k = 1 - q * q), M = w, V = O - 2 * E / k, isFinite(V) || (V = 0), w = h + computeDeltaLambda(
      l,
      q,
      k,
      L,
      F,
      O,
      V
    );
  } while (Math.abs(w - M) > CesiumMath.EPSILON12);
  const N = k * (i * i - e * e) / (e * e), U = 1 + N * (4096 + N * (N * (320 - 175 * N) - 768)) / 16384, z = N * (256 + N * (N * (74 - 47 * N) - 128)) / 1024, $ = V * V, G = z * F * (V + z * (O * (2 * $ - 1) - z * V * (4 * F * F - 3) * (4 * $ - 3) / 6) / 4), j = e * U * (L - G), Y = Math.atan2(
    y * D,
    S - b * P
  ), H = Math.atan2(p * D, S * P - b);
  o._distance = j, o._startHeading = Y, o._endHeading = H, o._uSquared = N;
}
const scratchCart1 = new Vector3$1(), scratchCart2 = new Vector3$1();
function computeProperties(o, i, e, r) {
  Cartesian3.normalize(
    r.cartographicToCartesian(i, scratchCart2),
    scratchCart1
  ), Cartesian3.normalize(
    r.cartographicToCartesian(e, scratchCart2),
    scratchCart2
  ), vincentyInverseFormula(
    o,
    r.maximumRadius,
    r.minimumRadius,
    i.x,
    i.y,
    e.x,
    e.y
  ), o._start = Cartographic.clone(
    i,
    o._start
  ), o._end = Cartographic.clone(e, o._end), o._start.z = 0, o._end.z = 0, setConstants(o);
}
function EllipsoidGeodesic(o, i, e) {
  const r = defaultValue(e, Ellipsoid.WGS84);
  this._ellipsoid = r, this._start = new Vector3$1(), this._end = new Vector3$1(), this._constants = {}, this._startHeading = void 0, this._endHeading = void 0, this._distance = void 0, this._uSquared = void 0, defined$1(o) && defined$1(i) && computeProperties(this, o, i, r);
}
Object.defineProperties(EllipsoidGeodesic.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  },
  surfaceDistance: {
    get: function() {
      return this._distance;
    }
  },
  start: {
    get: function() {
      return this._start;
    }
  },
  end: {
    get: function() {
      return this._end;
    }
  },
  startHeading: {
    get: function() {
      return this._startHeading;
    }
  },
  endHeading: {
    get: function() {
      return this._endHeading;
    }
  }
});
EllipsoidGeodesic.prototype.setEndPoints = function(o, i) {
  computeProperties(this, o, i, this._ellipsoid);
};
EllipsoidGeodesic.prototype.interpolateUsingFraction = function(o, i) {
  return this.interpolateUsingSurfaceDistance(
    this._distance * o,
    i
  );
};
EllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function(o, i) {
  const e = this._constants, r = e.distanceRatio + o / e.b, s = Math.cos(2 * r), a = Math.cos(4 * r), c = Math.cos(6 * r), l = Math.sin(2 * r), h = Math.sin(4 * r), d = Math.sin(6 * r), f = Math.sin(8 * r), p = r * r, m = r * p, y = e.u8Over256, x = e.u2Over4, v = e.u6Over64, S = e.u4Over16;
  let E = 2 * m * y * s / 3 + r * (1 - x + 7 * S / 4 - 15 * v / 4 + 579 * y / 64 - (S - 15 * v / 4 + 187 * y / 16) * s - (5 * v / 4 - 115 * y / 16) * a - 29 * y * c / 16) + (x / 2 - S + 71 * v / 32 - 85 * y / 16) * l + (5 * S / 16 - 5 * v / 4 + 383 * y / 96) * h - p * ((v - 11 * y / 2) * l + 5 * y * h / 2) + (29 * v / 96 - 29 * y / 16) * d + 539 * y * f / 1536;
  const b = Math.asin(Math.sin(E) * e.cosineAlpha), w = Math.atan(e.a / e.b * Math.tan(b));
  E = E - e.sigma;
  const M = Math.cos(2 * e.sigma + E), P = Math.sin(E), D = Math.cos(E), L = e.cosineU * D, O = e.sineU * P, k = Math.atan2(
    P * e.sineHeading,
    L - O * e.cosineHeading
  ) - computeDeltaLambda(
    e.f,
    e.sineAlpha,
    e.cosineSquaredAlpha,
    E,
    P,
    D,
    M
  );
  return defined$1(i) ? (i.x = this._start.x + k, i.y = w, i.z = 0, i) : new Vector3$1(this._start.x + k, w, 0);
};
const EasingFunction = {
  LINEAR: (o) => o,
  QUINTIC_IN_OUT: (o) => (o *= 2) < 1 ? 0.5 * o * o * o * o * o : 0.5 * ((o -= 2) * o * o * o * o + 2),
  CUBIC_OUT: (o) => --o * o * o + 1
}, scratchStartCart = new Vector3$1();
new Vector3$1();
const scratchCart = new Vector3$1();
new Vector3$1();
new Frustum();
const CameraFlightPath = {};
function getAltitude(o, i, e) {
  let r, s, a;
  const c = Math.tan(0.5 * CesiumMath.toRadians(o.fov));
  return r = o.near, s = o.near * c, a = o.aspect * s, Math.max(i * r / a, e * r / s);
}
function adjustAngleForLERP(o, i) {
  return CesiumMath.equalsEpsilon(
    o,
    CesiumMath.TWO_PI,
    CesiumMath.EPSILON11
  ) && (o = 0), i > o + Math.PI ? o += CesiumMath.TWO_PI : i < o - Math.PI && (o -= CesiumMath.TWO_PI), o;
}
const upScratch$2 = new Vector3$1(), rightScratch$2 = new Vector3$1();
function createHeightFunction(o, i, e, r, s, a) {
  let c = s;
  const l = Math.max(e, r);
  if (!c)
    if (a) {
      const h = o.position, d = i, f = o.up, p = o.right, m = o.frustum, y = scratchCart.subVectors(d, h), x = upScratch$2.copy(f).multiplyScalar(f.dot(y)).length(), v = rightScratch$2.copy(p).multiplyScalar(p.dot(y)).length();
      c = Math.min(
        getAltitude(m, x, v) * 0.2,
        1e9
      );
    } else {
      const h = o.position, d = i, f = scratchCart.subVectors(d, h);
      c = Math.hypot(f.x, f.y) * 0.2;
    }
  if (l < c) {
    const f = -Math.pow((c - e) * 1e6, 0.125), p = Math.pow((c - r) * 1e6, 1 / 8);
    return function(m) {
      const y = m * (p - f) + f;
      return -Math.pow(y, 8) / 1e6 + c;
    };
  }
  return function(h) {
    return (1 - h) * e + h * r;
  };
}
function createPitchFunction(o, i, e, r) {
  const s = e(0.5);
  if (defined$1(r) && e(0.5) > r) {
    const a = e(0), c = e(1), l = s - a, h = s - c;
    return function(d) {
      const f = e(d);
      if (d < 0.5) {
        const m = (f - a) / l;
        return (1 - m) * o + m * -CesiumMath.PI_OVER_TWO;
      }
      const p = (f - c) / h;
      return (1 - p) * -CesiumMath.PI_OVER_TWO + p * i;
    };
  }
  return function(a) {
    return (1 - a) * o + a * i;
  };
}
function shortestFlight(o, i) {
  const e = o.x - i.x;
  e < -CesiumMath.PI ? o.x += CesiumMath.TWO_PI : e > CesiumMath.PI && (i.x += CesiumMath.TWO_PI);
}
const scratchStart = new Vector3$1();
function createUpdate2D(o, i, e, r, s, a, c, l, h, d) {
  const f = o._ellipsoidCamera, p = scratchStart.copy(f.position), m = adjustAngleForLERP(f.heading, r), y = f.frustum.right - f.frustum.left, x = createHeightFunction(
    f,
    e,
    y,
    e.z,
    c
  );
  function v(S) {
    const E = S.time / i;
    f.setView({
      orientation: {
        heading: CesiumMath.lerp(m, r, E)
      }
    }), Cartesian2.lerp(p, e, E, f.position);
    const b = x(E), w = f.frustum, M = w.top / w.right, P = (b - (w.right - w.left)) / 2;
    w.right += P, w.left -= P, w.top = w.right * M, w.bottom = -w.top;
  }
  return v;
}
function createUpdate3D(o, i, e, r, s, a, c, l, h, d) {
  const f = o._ellipsoidCamera, m = o.mapProjection.ellipsoid, y = scratchStartCart.copy(f.positionCartographic), x = f.pitch, v = adjustAngleForLERP(f.heading, r), S = adjustAngleForLERP(f.roll, a), E = m.cartesianToCartographic(e);
  y.x = CesiumMath.zeroToTwoPi(y.x), E.x = CesiumMath.zeroToTwoPi(E.x), shortestFlight(y, E);
  const b = createHeightFunction(
    f,
    e,
    y.z,
    E.z,
    c,
    !0
  ), w = createPitchFunction(
    x,
    s,
    b,
    d
  );
  function M() {
    const P = y.x, D = E.x, L = y.y, O = E.y;
    return function(k) {
      const V = k.easingFunction;
      let N = k.time / i;
      V && (N = V(N));
      const U = Cartesian3.fromRadians(
        MathUtils.lerp(P, D, N),
        MathUtils.lerp(L, O, N),
        b(N),
        m
      );
      f.setView({
        destination: U,
        orientation: {
          heading: MathUtils.lerp(v, r, N),
          pitch: w(N),
          roll: MathUtils.lerp(S, a, N)
        }
      });
    };
  }
  return M();
}
function createUpdateCV(o, i, e, r, s, a, c, l, h, d) {
  const f = o._engine, p = f.camera, m = scratchStart.copy(p.position), y = MathUtils.degToRad(o.getPitch()), x = adjustAngleForLERP(MathUtils.degToRad(o.getHeading()), r), v = createHeightFunction(
    p,
    e,
    m.z,
    e.z,
    c,
    !1
  ), S = createPitchFunction(
    y,
    s,
    v,
    d
  );
  function E() {
    const b = m.x, w = e.x, M = m.y, P = e.y;
    function D(L) {
      const O = L.easingFunction;
      let F = L.time / i;
      O && (F = O(F));
      const k = new Vector3$1(
        MathUtils.lerp(b, w, F),
        MathUtils.lerp(M, P, F),
        v(F)
      );
      o.lookAt(f.map.unprojectArrayCoordinate(k.toArray()), {
        heading: MathUtils.radToDeg(MathUtils.lerp(x, r, F)),
        pitch: MathUtils.radToDeg(S(F))
      });
    }
    return D;
  }
  return E();
}
function wrapCallbackColumbus(o) {
  function i() {
    typeof o == "function" && o();
  }
  return i;
}
function wrapCallback(o, i) {
  function e() {
    typeof i == "function" && i(), o.enableInputs = !0;
  }
  return e;
}
function emptyFlight(o, i) {
  return {
    startObject: {},
    stopObject: {},
    duration: 0,
    complete: o,
    cancel: i
  };
}
CameraFlightPath.createTweenColumbus = function(o, i) {
  i = i || defaultValue.EMPTY_OBJECT;
  let e = i.destination;
  const r = o.mode;
  if (r === SceneMode$1.MORPHING)
    return emptyFlight();
  const s = i.maximumHeight, a = i.flyOverLongitude, c = i.flyOverLongitudeWeight, l = i.pitchAdjustHeight;
  let h = i.easingFunction;
  const d = o._engine.camera;
  let f = i.duration;
  f || (f = Math.ceil(Cartesian3.distance(d.position, e) / 1e6) + 2, f = Math.min(f, 3) * 1e3);
  const p = defaultValue(i.heading, 0), m = defaultValue(i.pitch, 0), y = wrapCallbackColumbus(i.complete), x = wrapCallbackColumbus(i.cancel);
  let v = Cartesian3.equalsEpsilon(
    e,
    d.position,
    CesiumMath.EPSILON10
  );
  const S = MathUtils.degToRad(o.getHeading()), E = MathUtils.degToRad(o.getPitch());
  if (v = v && CesiumMath.equalsEpsilon(
    CesiumMath.negativePiToPi(p),
    CesiumMath.negativePiToPi(S),
    CesiumMath.EPSILON10
  ) && CesiumMath.equalsEpsilon(
    CesiumMath.negativePiToPi(m),
    CesiumMath.negativePiToPi(E),
    CesiumMath.EPSILON10
  ), v)
    return emptyFlight(y, x);
  const b = new Array(4);
  b[SceneMode$1.SCENE2D] = createUpdate2D, b[SceneMode$1.SCENE3D] = createUpdate3D, b[SceneMode$1.COLUMBUS_VIEW] = createUpdateCV;
  const w = createUpdateCV(
    o,
    f,
    e,
    p,
    m,
    0,
    s,
    a,
    c,
    l
  );
  if (!defined$1(h)) {
    const M = d.position.z, P = r === e.z;
    M > P && M > 11500 ? h = EasingFunction.CUBIC_OUT : h = EasingFunction.QUINTIC_IN_OUT;
  }
  return {
    duration: f,
    easingFunction: h,
    startObject: {
      time: 0
    },
    stopObject: {
      time: f
    },
    update: w,
    complete: y,
    cancel: x
  };
};
CameraFlightPath.createTween = function(o, i) {
  return o.mode === SceneMode$1.SCENE3D ? CameraFlightPath.createTween3D(o, i) : CameraFlightPath.createTweenColumbus(o, i);
};
CameraFlightPath.createTween3D = function(o, i) {
  i = i || defaultValue.EMPTY_OBJECT;
  let e = i.destination;
  const r = o.mode;
  if (r === SceneMode$1.MORPHING)
    return emptyFlight();
  defaultValue(i.convert, !0);
  const a = o.mapProjection.ellipsoid, c = i.maximumHeight, l = i.flyOverLongitude, h = i.flyOverLongitudeWeight, d = i.pitchAdjustHeight;
  let f = i.easingFunction;
  const p = o.camera, m = o._ellipsoidCamera;
  let y = i.duration;
  y || (y = Math.ceil(Cartesian3.distance(p.position, e) / 1e6) + 2, y = Math.min(y, 3) * 1e3);
  const x = defaultValue(i.heading, 0), v = defaultValue(i.pitch, -CesiumMath.PI_OVER_TWO), S = defaultValue(i.roll, 0), E = o._controller;
  E.enableInputs = !1;
  const b = wrapCallback(E, i.complete), w = wrapCallback(E, i.cancel);
  m.frustum;
  let M = r === SceneMode$1.SCENE2D;
  if (M = M && Cartesian2.equalsEpsilon(p.position, e, CesiumMath.EPSILON6), M = M || r !== SceneMode$1.SCENE2D && Cartesian3.equalsEpsilon(
    e,
    p.position,
    CesiumMath.EPSILON10
  ), M = M && CesiumMath.equalsEpsilon(
    CesiumMath.negativePiToPi(x),
    CesiumMath.negativePiToPi(m.heading),
    CesiumMath.EPSILON10
  ) && CesiumMath.equalsEpsilon(
    CesiumMath.negativePiToPi(v),
    CesiumMath.negativePiToPi(m.pitch),
    CesiumMath.EPSILON10
  ) && CesiumMath.equalsEpsilon(
    CesiumMath.negativePiToPi(S),
    CesiumMath.negativePiToPi(m.roll),
    CesiumMath.EPSILON10
  ), M)
    return emptyFlight(b, w);
  const P = new Array(4);
  P[SceneMode$1.SCENE2D] = createUpdate2D, P[SceneMode$1.SCENE3D] = createUpdate3D, P[SceneMode$1.COLUMBUS_VIEW] = createUpdateCV;
  const D = P[o.mode](
    o,
    y,
    e,
    x,
    v,
    S,
    c,
    l,
    h,
    d
  );
  if (!defined$1(f)) {
    const L = m.positionCartographic.z, O = r === SceneMode$1.SCENE3D ? a.cartesianToCartographic(e).z : e.z;
    L > O && L > 11500 ? f = EasingFunction.CUBIC_OUT : f = EasingFunction.QUINTIC_IN_OUT;
  }
  return {
    duration: y,
    easingFunction: f,
    startObject: {
      time: 0
    },
    stopObject: {
      time: y
    },
    update: D,
    complete: b,
    cancel: w
  };
};
function Event() {
}
function computeView(o, i, e, r, s) {
  const a = s.elements;
  return a[0] = r.x, a[1] = e.x, a[2] = -i.x, a[3] = 0, a[4] = r.y, a[5] = e.y, a[6] = -i.y, a[7] = 0, a[8] = r.z, a[9] = e.z, a[10] = -i.z, a[11] = 0, a[12] = -r.dot(o), a[13] = -e.dot(o), a[14] = i.dot(o), a[15] = 1, s;
}
function updateViewMatrix(o) {
  computeView(
    o._position,
    o._direction,
    o._up,
    o._right,
    o._viewMatrix
  ), o._viewMatrix.multiplyMatrices(o._viewMatrix, o._actualInvTransform), o._invViewMatrix.copy(o._viewMatrix).invert();
}
const scratchCartesian$5 = new Vector3$1();
function updateMembers(o) {
  let e = o._position;
  const r = !Cartesian3.equals(e, o.position) || !1;
  r && (e = Cartesian3.clone(o.position, o._position));
  let s = o._direction;
  const a = !Cartesian3.equals(s, o.direction);
  a && (o.direction.normalize(), s = Cartesian3.clone(o.direction, o._direction));
  let c = o._up;
  const l = !Cartesian3.equals(c, o.up);
  l && (Cartesian3.normalize(o.up, o.up), c = Cartesian3.clone(o.up, o._up));
  let h = o._right;
  const d = !Cartesian3.equals(h, o.right);
  d && (Cartesian3.normalize(o.right, o.right), h = Cartesian3.clone(o.right, o._right));
  const f = o._transformChanged;
  o._transformChanged = !1, f && (StaticMatrix4.inverseTransformation(o._transform, o._invTransform), StaticMatrix4.clone(o._transform, o._actualTransform), StaticMatrix4.inverseTransformation(
    o._actualTransform,
    o._actualInvTransform
  ));
  const p = o._actualTransform;
  if ((r || f) && (o._positionWC = StaticMatrix4.multiplyByPoint(
    p,
    e,
    o._positionWC
  ), o._positionCartographic = o._ellipsoid.cartesianToCartographic(
    o._positionWC,
    o._positionCartographic
  )), a || l || d) {
    const m = Cartesian3.dot(
      s,
      Cartesian3.cross(c, h, scratchCartesian$5)
    );
    if (Math.abs(1 - m) > 0.02) {
      const y = 1 / Cartesian3.magnitudeSquared(c), x = Cartesian3.dot(c, s) * y, v = Cartesian3.multiplyByScalar(s, x, scratchCartesian$5);
      c = Cartesian3.normalize(
        Cartesian3.subtract(c, v, o._up),
        o._up
      ), Cartesian3.clone(c, o.up), h = Cartesian3.cross(s, c, o._right), Cartesian3.clone(h, o.right);
    }
  }
  (a || f) && (o._directionWC = StaticMatrix4.multiplyByPointAsVector(
    p,
    s,
    o._directionWC
  ), Cartesian3.normalize(o._directionWC, o._directionWC)), (l || f) && (o._upWC = StaticMatrix4.multiplyByPointAsVector(p, c, o._upWC), Cartesian3.normalize(o._upWC, o._upWC)), (d || f) && (o._rightWC = StaticMatrix4.multiplyByPointAsVector(
    p,
    h,
    o._rightWC
  ), Cartesian3.normalize(o._rightWC, o._rightWC)), (r || a || l || d || f) && updateViewMatrix(o);
}
function getHeading(o, i) {
  let e;
  return CesiumMath.equalsEpsilon(Math.abs(o.z), 1, CesiumMath.EPSILON3) ? e = Math.atan2(i.y, i.x) - CesiumMath.PI_OVER_TWO : e = Math.atan2(o.y, o.x) - CesiumMath.PI_OVER_TWO, CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(e);
}
function getPitch(o) {
  return CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(o.z);
}
function getRoll(o, i, e) {
  let r = 0;
  return CesiumMath.equalsEpsilon(Math.abs(o.z), 1, CesiumMath.EPSILON3) || (r = Math.atan2(-e.z, i.z), r = CesiumMath.zeroToTwoPi(r + CesiumMath.TWO_PI)), r;
}
const scratchHPRMatrix1 = new Matrix4(), scratchHPRMatrix2 = new Matrix4(), setTransformPosition = new Vector3$1(), setTransformUp = new Vector3$1(), setTransformDirection = new Vector3$1(), scratchSetViewCartesian = new Vector3$1(), scratchSetViewTransform1 = new Matrix4(), scratchSetViewTransform2 = new Matrix4(), scratchSetViewQuaternion = new Quaternion$1(), scratchSetViewMatrix3 = new Matrix3(), scratchSetViewCartographic = new Vector3$1();
function setView3D(o, i, e) {
  const r = StaticMatrix4.clone(
    o.transform,
    scratchSetViewTransform1
  ), s = Transforms.eastNorthUpToFixedFrame(
    i,
    o._ellipsoid,
    scratchSetViewTransform2
  );
  o._setTransform(s), Cartesian3.clone(Cartesian3.ZERO, o.position), e.heading = e.heading - CesiumMath.PI_OVER_TWO;
  const a = StaticQuaternion.fromHeadingPitchRoll(e, scratchSetViewQuaternion), c = StaticMatrix3.fromQuaternion(a, scratchSetViewMatrix3);
  StaticMatrix3.getColumn(c, 0, o.direction), StaticMatrix3.getColumn(c, 2, o.up), Cartesian3.cross(o.direction, o.up, o.right), o._setTransform(r);
}
function setViewCV(o, i, e, r) {
  const s = StaticMatrix4.clone(
    o.transform,
    scratchSetViewTransform1
  );
  if (o._setTransform(StaticMatrix4.IDENTITY), !Cartesian3.equals(i, o.positionWC)) {
    if (r) {
      const l = o._projection, h = l.ellipsoid.cartesianToCartographic(
        i,
        scratchSetViewCartographic
      );
      i = l.project(h, scratchSetViewCartesian);
    }
    Cartesian3.clone(i, o.position);
  }
  e.heading = e.heading - CesiumMath.PI_OVER_TWO;
  const a = Quaternion$1.fromHeadingPitchRoll(
    e,
    scratchSetViewQuaternion
  ), c = StaticMatrix3.fromQuaternion(a, scratchSetViewMatrix3);
  StaticMatrix3.getColumn(c, 0, o.direction), StaticMatrix3.getColumn(c, 2, o.up), Cartesian3.cross(o.direction, o.up, o.right), o._setTransform(s);
}
function setView2D(o, i, e, r) {
  const s = StaticMatrix4.clone(
    o.transform,
    scratchSetViewTransform1
  );
  if (o._setTransform(StaticMatrix4.IDENTITY), !Cartesian3.equals(i, o.positionWC)) {
    if (r) {
      const h = o._projection, d = h.ellipsoid.cartesianToCartographic(
        i,
        scratchSetViewCartographic
      );
      i = h.project(d, scratchSetViewCartesian);
    }
    Cartesian2.clone(i, o.position);
    const a = -i.z * 0.5, c = -a, l = o.frustum;
    if (c > a) {
      const h = l.top / l.right;
      l.right = c, l.left = a, l.top = l.right * h, l.bottom = -l.top;
    }
  }
  if (o._scene.mapMode2D === MapMode2D.ROTATE) {
    e.heading = e.heading - CesiumMath.PI_OVER_TWO, e.pitch = -CesiumMath.PI_OVER_TWO, e.roll = 0;
    const a = Quaternion$1.fromHeadingPitchRoll(
      e,
      scratchSetViewQuaternion
    ), c = StaticMatrix3.fromQuaternion(a, scratchSetViewMatrix3);
    StaticMatrix3.getColumn(c, 2, o.up), Cartesian3.cross(o.direction, o.up, o.right);
  }
  o._setTransform(s);
}
const scratchLookAtTransform = new Matrix4(), scratchLookAtMatrix4 = new Matrix4(), scratchLookAtHeadingPitchRangeOffset = new Vector3$1(), scratchLookAtHeadingPitchRangeQuaternion1 = new Quaternion$1(), scratchLookAtHeadingPitchRangeQuaternion2 = new Quaternion$1(), scratchHeadingPitchRangeMatrix3 = new Matrix3();
function offsetFromHeadingPitchRange(o, i, e) {
  i = CesiumMath.clamp(
    i,
    -CesiumMath.PI_OVER_TWO,
    CesiumMath.PI_OVER_TWO
  ), o = CesiumMath.zeroToTwoPi(o) - CesiumMath.PI_OVER_TWO;
  const r = StaticQuaternion.fromAxisAngle(
    Cartesian3.UNIT_Y,
    -i,
    scratchLookAtHeadingPitchRangeQuaternion1
  ), s = StaticQuaternion.fromAxisAngle(
    Cartesian3.UNIT_Z,
    -o,
    scratchLookAtHeadingPitchRangeQuaternion2
  ), a = StaticQuaternion.multiply(s, r, s), c = StaticMatrix3.fromQuaternion(
    a,
    scratchHeadingPitchRangeMatrix3
  ), l = Cartesian3.clone(
    Cartesian3.UNIT_X,
    scratchLookAtHeadingPitchRangeOffset
  );
  return StaticMatrix3.multiplyByVector(c, l, l), Cartesian3.negate(l, l), Cartesian3.multiplyByScalar(l, e, l), l;
}
const scratchToHPRDirection = new Vector3$1(), scratchToHPRUp = new Vector3$1(), scratchToHPRRight = new Vector3$1();
function directionUpToHeadingPitchRoll(o, i, e, r) {
  const s = Cartesian3.clone(
    e.direction,
    scratchToHPRDirection
  ), a = Cartesian3.clone(e.up, scratchToHPRUp), c = o._ellipsoid, l = Transforms.eastNorthUpToFixedFrame(
    i,
    c,
    scratchHPRMatrix1
  ), h = StaticMatrix4.inverseTransformation(
    l,
    scratchHPRMatrix2
  );
  StaticMatrix4.multiplyByPointAsVector(h, s, s), StaticMatrix4.multiplyByPointAsVector(h, a, a);
  const d = Cartesian3.cross(s, a, scratchToHPRRight);
  return r.heading = getHeading(s, a), r.pitch = getPitch(s), r.roll = getRoll(s, a, d), r;
}
const scratchFlyToDestination = new Vector3$1(), newOptions = {
  destination: void 0,
  heading: void 0,
  pitch: void 0,
  roll: void 0,
  duration: void 0,
  complete: void 0,
  cancel: void 0,
  endTransform: void 0,
  maximumHeight: void 0,
  easingFunction: void 0
}, scratchSetViewOptions = {
  destination: void 0,
  orientation: {
    direction: void 0,
    up: void 0,
    heading: void 0,
    pitch: void 0,
    roll: void 0
  },
  convert: void 0,
  endTransform: void 0
}, scratchHpr = {}, moveScratch = new Vector3$1();
var pickPerspCenter = new Vector3$1(), pickPerspXDir = new Vector3$1(), pickPerspYDir = new Vector3$1();
function getPickRayPerspective(o, i, e) {
  var r = o._scene.canvas, s = r.clientWidth, a = r.clientHeight, c = Math.tan(MathUtils.degToRad(o._camera.fov) * 0.5), l = o._camera.aspect * c, h = o._camera.near, d = 2 / s * i.x - 1, f = 2 / a * (a - i.y) - 1, p = o.positionWC;
  Cartesian3.clone(p, e.origin);
  var m = Cartesian3.multiplyByScalar(
    o.directionWC,
    h,
    pickPerspCenter
  );
  Cartesian3.add(p, m, m);
  var y = Cartesian3.multiplyByScalar(
    o.rightWC,
    d * h * l,
    pickPerspXDir
  ), x = Cartesian3.multiplyByScalar(
    o.upWC,
    f * h * c,
    pickPerspYDir
  ), v = Cartesian3.add(m, y, e.direction);
  return Cartesian3.add(v, x, v), Cartesian3.subtract(v, p, v), Cartesian3.normalize(v, v), e;
}
function zoom3D$1(o, i) {
  o.move(o.direction, i);
}
var pickEllipsoid3DRay = new Ray();
function pickEllipsoid3D(o, i, e, r) {
  e = defaultValue(e, Ellipsoid.WGS84);
  var s = o.getPickRay(i, pickEllipsoid3DRay), a = IntersectionTests.rayEllipsoid(s, e);
  if (!!a) {
    var c = a.start > 0 ? a.start : a.stop;
    return StaticRay.getPoint(s, c, r);
  }
}
var rotateScratchQuaternion = new Quaternion$1(), rotateScratchMatrix = new Matrix3(), lookScratchQuaternion = new Quaternion$1(), lookScratchMatrix = new Matrix3(), rotateVertScratchP = new Vector3$1(), rotateVertScratchA = new Vector3$1(), rotateVertScratchTan = new Vector3$1(), rotateVertScratchNegate = new Vector3$1();
function rotateVertical(o, i) {
  var e = o.position;
  if (defined$1(o.constrainedAxis) && !Cartesian3.equalsEpsilon(
    o.position,
    Cartesian3.ZERO,
    CesiumMath.EPSILON2
  )) {
    var r = Cartesian3.normalize(e, rotateVertScratchP), s = Cartesian3.equalsEpsilon(
      r,
      o.constrainedAxis,
      CesiumMath.EPSILON2
    ), a = Cartesian3.equalsEpsilon(
      r,
      Cartesian3.negate(o.constrainedAxis, rotateVertScratchNegate),
      CesiumMath.EPSILON2
    );
    if (!s && !a) {
      var c = Cartesian3.normalize(
        o.constrainedAxis,
        rotateVertScratchA
      ), l = Cartesian3.dot(r, c), h = CesiumMath.acosClamped(l);
      i > 0 && i > h && (i = h - CesiumMath.EPSILON4), l = Cartesian3.dot(
        r,
        Cartesian3.negate(c, rotateVertScratchNegate)
      ), h = CesiumMath.acosClamped(l), i < 0 && -i > h && (i = -h + CesiumMath.EPSILON4);
      var d = Cartesian3.cross(c, r, rotateVertScratchTan);
      o.rotate(d, i);
    } else
      (s && i < 0 || a && i > 0) && o.rotate(o.right, i);
  } else
    o.rotate(o.right, i);
}
function rotateHorizontal(o, i) {
  defined$1(o.constrainedAxis) ? o.rotate(o.constrainedAxis, i) : o.rotate(o.up, i);
}
const qe = class {
  constructor(i) {
    _(this, "_setTransform", (i) => {
      const e = Cartesian3.clone(this.positionWC, setTransformPosition), r = Cartesian3.clone(this.upWC, setTransformUp), s = Cartesian3.clone(this.directionWC, setTransformDirection);
      StaticMatrix4.clone(i, this._transform), this._transformChanged = !0, updateMembers(this);
      const a = this._actualInvTransform;
      StaticMatrix4.multiplyByPoint(a, e, this.position), StaticMatrix4.multiplyByPointAsVector(a, s, this.direction), StaticMatrix4.multiplyByPointAsVector(a, r, this.up), Cartesian3.cross(this.direction, this.up, this.right), updateMembers(this);
    });
    this._scene = i, this._camera = i.camera, this._ellipsoid = i._ellipsoid, this._transform = new Matrix4(), this._invTransform = new Matrix4(), this._actualTransform = new Matrix4(), this._actualInvTransform = new Matrix4(), this._transformChanged = !1, this.position = new Vector3$1(), this._position = new Vector3$1(), this._positionWC = new Vector3$1(), this._positionCartographic = new Vector3$1(), this._oldPositionWC = void 0, this.positionWCDeltaMagnitude = 0, this.positionWCDeltaMagnitudeLastFrame = 0, this.timeSinceMoved = 0, this._lastMovedTimestamp = 0, this.direction = new Vector3$1(), this._direction = new Vector3$1(), this._directionWC = new Vector3$1(), this.up = new Vector3$1(), this._up = new Vector3$1(), this._upWC = new Vector3$1(), this.right = new Vector3$1(), this._right = new Vector3$1(), this._rightWC = new Vector3$1(), this.defaultMoveAmount = 1e5, this.defaultLookAmount = Math.PI / 60, this.defaultRotateAmount = Math.PI / 3600, this.defaultZoomAmount = 1e5, this.constrainedAxis = void 0, this.maximumZoomFactor = 1.5, this._moveStart = new Event(), this._moveEnd = new Event(), this._changed = new Event(), this._changedPosition = void 0, this._changedDirection = void 0, this._changedFrustum = void 0, this.percentageChanged = 0.5, this._viewMatrix = new Matrix4(), this._invViewMatrix = new Matrix4(), updateViewMatrix(this), this._mode = SceneMode.SCENE3D, this._modeChanged = !0;
    const e = i.mapProjection;
    this._projection = e, this._maxCoord = e.project(
      new Vector3$1(Math.PI, CesiumMath.PI_OVER_TWO, 0)
    ), this._max2Dfrustum = void 0, rectangleCameraPosition3D(
      this,
      qe.DEFAULT_VIEW_RECTANGLE,
      this.position,
      !0
    );
    let r = Cartesian3.magnitude(this.position);
    r += r * qe.DEFAULT_VIEW_FACTOR, Cartesian3.normalize(this.position, this.position), Cartesian3.multiplyByScalar(this.position, r, this.position);
  }
  canPreloadFlight() {
    return defined$1(this._currentFlight);
  }
  setView(i) {
    i = defaultValue(i, {});
    let e = defaultValue(
      i.orientation,
      defaultValue.EMPTY_OBJECT
    );
    const r = this._mode;
    if (r === SceneMode.MORPHING)
      return;
    defined$1(i.endTransform) && this._setTransform(i.endTransform);
    let s = defaultValue(i.convert, !0), a = defaultValue(
      i.destination,
      Cartesian3.clone(this.positionWC, scratchSetViewCartesian)
    );
    defined$1(a) && defined$1(a.west) && (a = this.getRectangleCameraCoordinates(
      a,
      scratchSetViewCartesian
    ), s = !1), defined$1(e.direction) && (e = directionUpToHeadingPitchRoll(
      this,
      a,
      e,
      scratchSetViewOptions.orientation
    )), scratchHpr.heading = defaultValue(e.heading, 0), scratchHpr.pitch = defaultValue(e.pitch, -CesiumMath.PI_OVER_TWO), scratchHpr.roll = defaultValue(e.roll, 0), r === SceneMode.SCENE3D ? setView3D(this, a, scratchHpr) : r === SceneMode.SCENE2D ? setView2D(this, a, scratchHpr, s) : setViewCV(this, a, scratchHpr, s);
  }
  lookAt(i, e) {
    if (!defined$1(i))
      throw new DeveloperError("target is required");
    if (!defined$1(e))
      throw new DeveloperError("offset is required");
    if (this._mode === SceneMode.MORPHING)
      throw new DeveloperError("lookAt is not supported while morphing.");
    e = defaultValue(e, defaultValue.EMPTY_OBJECT), e.heading = defaultValue(e.heading, 0), e.pitch = defaultValue(e.pitch, -CesiumMath.PI_OVER_TWO), e.range = e.range || 0.01;
    const r = StaticMatrix4.clone(
      this.transform,
      scratchLookAtTransform
    );
    var s = Transforms.eastNorthUpToFixedFrame(
      i,
      Ellipsoid.WGS84,
      scratchLookAtMatrix4
    );
    this.lookAtTransform(s, e), this._mode === SceneMode.SCENE3D && this._setTransform(r);
  }
  lookAtTransform(i, e) {
    if (!defined$1(i))
      throw new DeveloperError("transform is required");
    if (this._mode === SceneMode.MORPHING)
      throw new DeveloperError(
        "lookAtTransform is not supported while morphing."
      );
    if (this._setTransform(i), !defined$1(e))
      return;
    let r;
    if (defined$1(e.heading) ? r = offsetFromHeadingPitchRange(
      e.heading,
      e.pitch,
      e.range
    ) : r = e, this._mode === SceneMode.SCENE2D) {
      Cartesian2.clone(Cartesian2.ZERO, this.position), Cartesian3.negate(r, this.up), this.up.z = 0, Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10 && Cartesian3.clone(Cartesian3.UNIT_Y, this.up), Cartesian3.normalize(this.up, this.up), this._setTransform(StaticMatrix4.IDENTITY), Cartesian3.negate(Cartesian3.UNIT_Z, this.direction), Cartesian3.cross(this.direction, this.up, this.right), Cartesian3.normalize(this.right, this.right);
      const s = this.frustum, a = s.top / s.right;
      s.right = Cartesian3.magnitude(r) * 0.5, s.left = -s.right, s.top = a * s.right, s.bottom = -s.top, this._setTransform(i);
      return;
    }
    Cartesian3.clone(r, this.position), Cartesian3.negate(this.position, this.direction), Cartesian3.normalize(this.direction, this.direction), Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right), Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10 && Cartesian3.clone(Cartesian3.UNIT_X, this.right), Cartesian3.normalize(this.right, this.right), Cartesian3.cross(this.right, this.direction, this.up), Cartesian3.normalize(this.up, this.up);
  }
  move(i, e) {
    const r = this.position;
    Cartesian3.multiplyByScalar(i, e, moveScratch), Cartesian3.add(r, moveScratch, r);
  }
  moveForward(i) {
    i = defaultValue(i, this.defaultMoveAmount), this.move(this.direction, i);
  }
  moveBackward(i) {
    i = defaultValue(i, this.defaultMoveAmount), this.move(this.direction, -i);
  }
  moveUp(i) {
    i = defaultValue(i, this.defaultMoveAmount), this.move(this.up, i);
  }
  moveDown(i) {
    i = defaultValue(i, this.defaultMoveAmount), this.move(this.up, -i);
  }
  moveRight(i) {
    i = defaultValue(i, this.defaultMoveAmount), this.move(this.right, i);
  }
  moveLeft(i) {
    i = defaultValue(i, this.defaultMoveAmount), this.move(this.right, -i);
  }
  rotateAroundPoint(i, e, r) {
    const s = new Vector3$1();
    Cartesian3.subtract(this.position, i, s);
    const a = defaultValue(r, this.defaultRotateAmount), c = StaticQuaternion.fromAxisAngle(e, -a, rotateScratchQuaternion), l = StaticMatrix3.fromQuaternion(c, rotateScratchMatrix);
    StaticMatrix3.multiplyByVector(l, s, s), StaticMatrix3.multiplyByVector(l, this.direction, this.direction), StaticMatrix3.multiplyByVector(l, this.up, this.up), StaticMatrix3.multiplyByVector(l, this.right, this.right), Cartesian3.add(s, i, this.position);
  }
  zoomIn(i) {
    i = defaultValue(i, this.defaultZoomAmount), zoom3D$1(this, i);
  }
  rotate(i, e) {
    var r = defaultValue(e, this.defaultRotateAmount), s = StaticQuaternion.fromAxisAngle(
      i,
      -r,
      rotateScratchQuaternion
    ), a = StaticMatrix3.fromQuaternion(s, rotateScratchMatrix);
    StaticMatrix3.multiplyByVector(a, this.position, this.position), StaticMatrix3.multiplyByVector(a, this.direction, this.direction), StaticMatrix3.multiplyByVector(a, this.up, this.up), Cartesian3.cross(this.direction, this.up, this.right), Cartesian3.cross(this.right, this.direction, this.up);
  }
  rotateDown(i) {
    i = defaultValue(i, this.defaultRotateAmount), rotateVertical(this, i);
  }
  rotateUp(i) {
    i = defaultValue(i, this.defaultRotateAmount), rotateVertical(this, -i);
  }
  rotateRight(i) {
    i = defaultValue(i, this.defaultRotateAmount), rotateHorizontal(this, -i);
  }
  rotateLeft(i) {
    i = defaultValue(i, this.defaultRotateAmount), rotateHorizontal(this, i);
  }
  look(i, e) {
    var r = defaultValue(e, this.defaultLookAmount), s = StaticQuaternion.fromAxisAngle(
      i,
      -r,
      lookScratchQuaternion
    ), a = StaticMatrix3.fromQuaternion(s, lookScratchMatrix), c = this.direction, l = this.up, h = this.right;
    StaticMatrix3.multiplyByVector(a, c, c), StaticMatrix3.multiplyByVector(a, l, l), StaticMatrix3.multiplyByVector(a, h, h);
  }
  lookLeft(i) {
    i = defaultValue(i, this.defaultLookAmount), this._mode !== SceneMode.SCENE2D && this.look(this.up, -i);
  }
  lookRight(i) {
    i = defaultValue(i, this.defaultLookAmount), this._mode !== SceneMode.SCENE2D && this.look(this.up, i);
  }
  lookUp(i) {
    i = defaultValue(i, this.defaultLookAmount), this._mode !== SceneMode.SCENE2D && this.look(this.right, -i);
  }
  lookDown(i) {
    i = defaultValue(i, this.defaultLookAmount), this._mode !== SceneMode.SCENE2D && this.look(this.right, i);
  }
  getPickRay(i, e) {
    if (!defined$1(i))
      throw new DeveloperError("windowPosition is required.");
    return defined$1(e) || (e = new Ray()), getPickRayPerspective(this, i, e);
  }
  pickEllipsoid(i, e, r) {
    return defined$1(r) || (r = new Vector3$1()), e = defaultValue(e, Ellipsoid.WGS84), r = pickEllipsoid3D(this, i, e, r), r;
  }
  worldToCameraCoordinates(i, e) {
    return defined$1(e) || (e = new Vector4(0, 0, 0, 0)), updateMembers(this), StaticMatrix4.multiplyByVector(this._actualInvTransform, i, e);
  }
  worldToCameraCoordinatesPoint(i, e) {
    if (!defined$1(i))
      throw new DeveloperError("cartesian is required.");
    return defined$1(e) || (e = new Vector3$1()), updateMembers(this), StaticMatrix4.multiplyByPoint(this._actualInvTransform, i, e);
  }
  cancelFlight() {
    if (defined$1(this._currentFlight)) {
      const i = this._currentFlight.listener;
      this._scene._engine.removePrepareRenderListener(i), this._currentFlight = void 0;
    }
  }
  completeFlight() {
    if (defined$1(this._currentFlight)) {
      const i = this._currentFlight.listener;
      this._scene._engine.removePrepareRenderListener(i);
      const r = {
        destination: void 0,
        orientation: {
          heading: void 0,
          pitch: void 0,
          roll: void 0
        }
      };
      r.destination = newOptions.destination, r.orientation.heading = newOptions.heading, r.orientation.pitch = newOptions.pitch, r.orientation.roll = newOptions.roll, this.setView(r), defined$1(this._currentFlight.complete) && this._currentFlight.complete(), this._currentFlight = void 0;
    }
  }
  flyTo(i) {
    i = defaultValue(i, {});
    let e = i.destination;
    if (this._mode === SceneMode.MORPHING)
      return;
    this.cancelFlight();
    const s = e instanceof Rectangle;
    s && (e = this.getRectangleCameraCoordinates(
      e,
      scratchFlyToDestination
    ));
    let a = defaultValue(
      i.orientation,
      defaultValue.EMPTY_OBJECT
    );
    if (defined$1(a.direction) && (a = directionUpToHeadingPitchRoll(
      this,
      e,
      a,
      scratchSetViewOptions.orientation
    )), defined$1(i.duration) && i.duration <= 0) {
      const m = scratchSetViewOptions;
      m.destination = i.destination, m.orientation.heading = a.heading, m.orientation.pitch = a.pitch, m.orientation.roll = a.roll, m.convert = i.convert, m.endTransform = i.endTransform, this.setView(m), typeof i.complete == "function" && i.complete();
      return;
    }
    const c = this;
    newOptions.destination = e, newOptions.heading = a.heading, newOptions.pitch = a.pitch, newOptions.roll = a.roll, newOptions.duration = i.duration, newOptions.complete = function() {
      c._currentFlight = void 0, defined$1(i.complete) && i.complete();
    }, newOptions.cancel = i.cancel, newOptions.endTransform = i.endTransform, newOptions.convert = s ? !1 : i.convert, newOptions.maximumHeight = i.maximumHeight, newOptions.pitchAdjustHeight = i.pitchAdjustHeight, newOptions.flyOverLongitude = i.flyOverLongitude, newOptions.flyOverLongitudeWeight = i.flyOverLongitudeWeight, newOptions.easingFunction = i.easingFunction;
    const l = this._scene, h = CameraFlightPath.createTween(l, newOptions);
    if (h.duration === 0) {
      typeof h.complete == "function" && h.complete();
      return;
    }
    const d = l._engine;
    let f = performance.now();
    function p(m) {
      const x = performance.now() - f, {
        duration: v,
        complete: S,
        update: E,
        easingFunction: b
      } = h;
      if (x >= v) {
        E({
          time: v,
          easingFunction: b
        }), d.removePrepareRenderListener(p), S();
        return;
      }
      E({
        time: x,
        easingFunction: b
      }), d.map.map._syncFromEllipsoidCamera(), d.requestRender();
    }
    d.addPrepareRenderListener(p), h.listener = p, this._currentFlight = h;
  }
  flyHome(i) {
    let e = new Vector3$1(), r = this._mode;
    if (r === SceneMode.MORPHING && this._scene.completeMorph(), r === SceneMode.SCENE2D)
      this.flyTo({
        destination: qe.DEFAULT_VIEW_RECTANGLE,
        duration: i,
        endTransform: StaticMatrix4.IDENTITY
      });
    else if (r === SceneMode.SCENE3D) {
      let s = this.getRectangleCameraCoordinates(
        qe.DEFAULT_VIEW_RECTANGLE
      ), a = Cartesian3.magnitude(s);
      a += a * qe.DEFAULT_VIEW_FACTOR, Cartesian3.normalize(s, s), Cartesian3.multiplyByScalar(s, a, s), this.flyTo({
        destination: s,
        duration: i,
        endTransform: StaticMatrix4.IDENTITY
      }), this._scene._engine.requestRender();
    } else if (r === SceneMode.COLUMBUS_VIEW) {
      let s = this._projection.ellipsoid.maximumRadius, a = new Vector3$1(0, -1, 1);
      a = Cartesian3.multiplyByScalar(
        Cartesian3.normalize(a, a),
        5 * s,
        a
      ), this.flyTo({
        destination: a,
        duration: i,
        orientation: {
          heading: 0,
          pitch: -Math.acos(Cartesian3.normalize(a, e).z),
          roll: 0
        },
        endTransform: StaticMatrix4.IDENTITY,
        convert: !1
      });
    }
  }
  getRectangleCameraCoordinates(i, e) {
    const r = this._mode;
    if (defined$1(e) || (e = new Vector3$1()), r === SceneMode.SCENE3D)
      return rectangleCameraPosition3D(this, i, e);
  }
  update() {
  }
  _adjustOrthographicFrustum(i) {
  }
  clone(i, e) {
    return defined$1(e) || (e = new qe(i._scene)), Cartesian3.clone(i.position, e.position), Cartesian3.clone(i.direction, e.direction), Cartesian3.clone(i.up, e.up), Cartesian3.clone(i.right, e.right), StaticMatrix4.clone(i._transform, e.transform), e._transformChanged = !0, e.frustum = i.frustum.clone(), e;
  }
  getLocalTransform() {
    const i = this._ellipsoid, e = StaticMatrix4.clone(this._transform, scratchHPRMatrix1), r = Transforms.eastNorthUpToFixedFrame(
      this.positionWC,
      i,
      scratchHPRMatrix2
    );
    this._setTransform(r);
    const s = new Matrix4();
    return s.set(
      this.right.x,
      this.up.x,
      -this.direction.x,
      0,
      this.right.y,
      this.up.y,
      -this.direction.y,
      0,
      this.right.z,
      this.up.z,
      -this.direction.z,
      0,
      0,
      0,
      0,
      1
    ), this._setTransform(e), s;
  }
  get transform() {
    return this._transform;
  }
  get inverseTransform() {
    return updateMembers(this), this._invTransform;
  }
  get viewMatrix() {
    return updateMembers(this), this._viewMatrix;
  }
  get inverseViewMatrix() {
    return updateMembers(this), this._invViewMatrix;
  }
  get positionCartographic() {
    return updateMembers(this), this._positionCartographic;
  }
  get positionWC() {
    return updateMembers(this), this._positionWC;
  }
  get directionWC() {
    return updateMembers(this), this._directionWC;
  }
  get upWC() {
    return updateMembers(this), this._upWC;
  }
  get rightWC() {
    return updateMembers(this), this._rightWC;
  }
  get heading() {
    const i = this._ellipsoid, e = StaticMatrix4.clone(this._transform, scratchHPRMatrix1), r = Transforms.eastNorthUpToFixedFrame(
      this.positionWC,
      i,
      scratchHPRMatrix2
    );
    this._setTransform(r);
    const s = getHeading(this.direction, this.up);
    return this._setTransform(e), s;
  }
  get pitch() {
    const i = this._ellipsoid, e = StaticMatrix4.clone(this._transform, scratchHPRMatrix1), r = Transforms.eastNorthUpToFixedFrame(
      this.positionWC,
      i,
      scratchHPRMatrix2
    );
    this._setTransform(r);
    const s = getPitch(this.direction);
    return this._setTransform(e), s;
  }
  get roll() {
    const i = this._ellipsoid, e = StaticMatrix4.clone(this._transform, scratchHPRMatrix1), r = Transforms.eastNorthUpToFixedFrame(
      this.positionWC,
      i,
      scratchHPRMatrix2
    );
    this._setTransform(r);
    const s = getRoll(this.direction, this.up, this.right);
    return this._setTransform(e), s;
  }
  get moveStart() {
    return this._moveStart;
  }
  get moveEnd() {
    return this._moveEnd;
  }
  get changed() {
    return this._changed;
  }
};
let EllipsoidCamera = qe;
_(EllipsoidCamera, "DEFAULT_VIEW_RECTANGLE", Rectangle.fromDegrees(
  73,
  -5,
  140,
  70
)), _(EllipsoidCamera, "DEFAULT_VIEW_FACTOR", 0.5), _(EllipsoidCamera, "DEFAULT_OFFSET", new HeadingPitchRange(
  0,
  Math.PI / 4,
  0
));
const viewRectangle3DCartographic1 = new Vector3$1(), viewRectangle3DCartographic2 = new Vector3$1(), viewRectangle3DNorthEast = new Vector3$1(), viewRectangle3DSouthWest = new Vector3$1(), viewRectangle3DNorthWest = new Vector3$1(), viewRectangle3DSouthEast = new Vector3$1(), viewRectangle3DNorthCenter = new Vector3$1(), viewRectangle3DSouthCenter = new Vector3$1(), viewRectangle3DCenter = new Vector3$1(), viewRectangle3DEquator = new Vector3$1(), defaultRF = {
  direction: new Vector3$1(),
  right: new Vector3$1(),
  up: new Vector3$1()
};
let viewRectangle3DEllipsoidGeodesic;
function computeD(o, i, e, r) {
  return Math.abs(Cartesian3.dot(i, e)) / r - Cartesian3.dot(o, e);
}
function rectangleCameraPosition3D(o, i, e, r) {
  const s = o._projection.ellipsoid, a = r ? o : defaultRF, c = i.north, l = i.south;
  let h = i.east;
  const d = i.west;
  d > h && (h += CesiumMath.TWO_PI);
  const f = (d + h) * 0.5;
  let p;
  if (l < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE && c > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE)
    p = 0;
  else {
    const V = viewRectangle3DCartographic1;
    V.x = f, V.y = c, V.z = 0;
    const N = viewRectangle3DCartographic2;
    N.x = f, N.y = l, N.z = 0;
    let U = viewRectangle3DEllipsoidGeodesic;
    (!defined$1(U) || U.ellipsoid !== s) && (viewRectangle3DEllipsoidGeodesic = U = new EllipsoidGeodesic(
      void 0,
      void 0,
      s
    )), U.setEndPoints(V, N), p = U.interpolateUsingFraction(
      0.5,
      viewRectangle3DCartographic1
    ).y;
  }
  const m = viewRectangle3DCartographic1;
  m.x = f, m.y = p, m.z = 0;
  const y = s.cartographicToCartesian(
    m,
    viewRectangle3DCenter
  ), x = viewRectangle3DCartographic1;
  x.x = h, x.y = c;
  const v = s.cartographicToCartesian(
    x,
    viewRectangle3DNorthEast
  );
  x.x = d;
  const S = s.cartographicToCartesian(
    x,
    viewRectangle3DNorthWest
  );
  x.x = f;
  const E = s.cartographicToCartesian(
    x,
    viewRectangle3DNorthCenter
  );
  x.y = l;
  const b = s.cartographicToCartesian(
    x,
    viewRectangle3DSouthCenter
  );
  x.x = h;
  const w = s.cartographicToCartesian(
    x,
    viewRectangle3DSouthEast
  );
  x.x = d;
  const M = s.cartographicToCartesian(
    x,
    viewRectangle3DSouthWest
  );
  Cartesian3.subtract(S, y, S), Cartesian3.subtract(w, y, w), Cartesian3.subtract(v, y, v), Cartesian3.subtract(M, y, M), Cartesian3.subtract(E, y, E), Cartesian3.subtract(b, y, b);
  const P = s.geodeticSurfaceNormal(y, a.direction);
  Cartesian3.negate(P, P);
  const D = Cartesian3.cross(P, Cartesian3.UNIT_Z, a.right);
  Cartesian3.normalize(D, D);
  const L = Cartesian3.cross(D, P, a.up);
  let O;
  const F = Math.tan(MathUtils.degToRad(o._camera.fov) * 0.5), k = o._camera.aspect * F;
  if (O = Math.max(
    computeD(P, L, S, F),
    computeD(P, L, w, F),
    computeD(P, L, v, F),
    computeD(P, L, M, F),
    computeD(P, L, E, F),
    computeD(P, L, b, F),
    computeD(P, D, S, k),
    computeD(P, D, w, k),
    computeD(P, D, v, k),
    computeD(P, D, M, k),
    computeD(P, D, E, k),
    computeD(P, D, b, k)
  ), l < 0 && c > 0) {
    const V = viewRectangle3DCartographic1;
    V.x = d, V.y = 0, V.z = 0;
    let N = s.cartographicToCartesian(
      V,
      viewRectangle3DEquator
    );
    Cartesian3.subtract(N, y, N), O = Math.max(
      O,
      computeD(P, L, N, F),
      computeD(P, D, N, k)
    ), V.x = h, N = s.cartographicToCartesian(
      V,
      viewRectangle3DEquator
    ), Cartesian3.subtract(N, y, N), O = Math.max(
      O,
      computeD(P, L, N, F),
      computeD(P, D, N, k)
    );
  }
  return Cartesian3.add(
    y,
    Cartesian3.multiplyByScalar(P, -O, viewRectangle3DEquator),
    e
  );
}
const _vector3$4 = new Vector3$1(), _up$3 = new Vector3$1(0, 0, 1);
class GradientSkyAtmospherePass extends Pass {
  constructor() {
    super(), this.uniforms = UniformsUtils.clone(SkyAtmosphereGradientShader.uniforms), this.material = new ShaderMaterial({
      defines: {
        MVT_USE_NORMAL_TEXTURE: !1
      },
      uniforms: this.uniforms,
      vertexShader: CopyShader.vertexShader,
      fragmentShader: SkyAtmosphereGradientShader.fragmentShader,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), this.needsSwap = !0, this.fsQuad = new FullScreenQuad(null), this.needsDepthTexture = !0, this.needsNormalTextureWhenMRT = !0;
  }
  render(i, e, r) {
    const s = this.sky;
    if (!s)
      return;
    const a = this.rendering, c = a.camera, l = a._engine, h = l.map.isGlobe, d = this.uniforms;
    d.tDiffuse.value = r.texture, d.tDepth.value = a.main.sceneRendering.depthTexture, d.isGlobe.value = h, d.viewInverseMatrix.value.copy(c.matrixWorld), d.projectionInverseMatrix.value.copy(c.projectionMatrixInverse), d.cameraNear.value = c.near, d.cameraFar.value = c.far, d.color.value.copy(s.color), d.highColor.value.copy(s.highColor), d.cameraPosition.value.copy(c.position);
    let f = l.map.getViewHeight();
    h ? f = Math.max(f / 1e6, 2e-4) : f = 2e-4, d.viewHeight.value = f, d.resolution = a.uniforms.resolution, d.sunDirection.value.copy(s.localSunDirection);
    let p = 0, m = 1;
    if (a._engine.map.mapType === "earth") {
      let S = a._engine.map._map._ellipsoidCamera;
      if (!this._sphereCamera) {
        const L = new Ellipsoid(6371e3, 6371e3, 6371e3);
        this._sphereCamera = new EllipsoidCamera({
          _ellipsoid: L,
          mapProjection: new GeographicProjection(L),
          camera: c
        });
      }
      const E = this._sphereCamera;
      E.position.copy(S.position), E.direction.copy(S.direction), E.up.copy(S.up), E.right.copy(S.right), S = E, d.viewInverseMatrix.value.copy(S.getLocalTransform());
      const b = d.viewInverseMatrix.value.elements;
      _vector3$4.set(b[8], b[9], b[10]);
      const w = MathUtils.clamp(_vector3$4.dot(_up$3), 0.1, 1), M = d.viewHeight.value * 1e6 / w, P = MathUtils.mapLinear(Math.sqrt(d.viewHeight.value * 10), 0, 1, 20, 2), D = Math.max(M + 100, M * P);
      p = a.renderState.getDepthByDistance(M), m = a.renderState.getDepthByDistance(D);
    }
    d.fogDepthRange.value.set(p, m);
    const y = i.autoClear, x = i.getRenderTarget();
    i.autoClear = !1, this.fsQuad.material = this.material, i.setRenderTarget(this.renderToScreen ? null : e), i.clear(!0, !1, !1), this.fsQuad.render(i), i.autoClear = y, i.setRenderTarget(x);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class DefaultSky extends EmptySky {
  constructor() {
    super(...arguments);
    _(this, "isDefaultSky", !0);
    _(this, "name", "DefaultSky");
    _(this, "_postPass", null);
    _(this, "_engine", null);
    _(this, "_presetWeatherProperties", {
      clear: {
        sunLightIntensity: 2.5,
        skyLightIntensity: 1.2
      },
      partlyCloudy: {
        sunLightIntensity: 2.2,
        skyLightIntensity: 1.2
      },
      cloudy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      overcast: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      foggy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      rainy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      snowy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      },
      stormy: {
        sunLightIntensity: 0,
        skyLightIntensity: 1.5
      }
    });
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e), this._engine = e, this._color = new Color(1, 1, 1, 1), this._highColor = new Color(153 / 255, 204 / 255, 255 / 255), this.initEnv();
  }
  beforeRemoveFromEngine(e) {
    e.rendering.main.postprocessings.remove(this._postPass), super.beforeRemoveFromEngine(e);
  }
  initEnv() {
    const e = this._engine, r = this._postPass = new GradientSkyAtmospherePass();
    r.renderOrder = 50, r.sky = this, e.rendering.main.opaquePostprocessings.add(r);
  }
  get highColor() {
    return this._highColor;
  }
  set highColor(e) {
    e.isColor && this._highColor.copy(e);
  }
  get color() {
    return this._color;
  }
  set color(e) {
    e.isColor && this._color.copy(e);
  }
  get enablePostPass() {
    return this._postPass.enabled || !1;
  }
  set enablePostPass(e) {
    this._postPass && (this._postPass.enabled = e);
  }
  dispose() {
    super.dispose();
  }
}
const _rotationMatrix$2 = new Matrix3();
class Snow extends Object3D {
  constructor(e, r, s = {}) {
    super();
    _(this, "update", (e) => {
      if (e.map.isGlobe) {
        const s = Transforms.eastNorthUpToFixedFrame(e.camera.position);
        this._system.setPositionRotationMatrix(_rotationMatrix$2.setFromMatrix4(s));
      }
      this._system.update(this._clock.getDelta());
    });
    _(this, "createSnow", () => new TextureLoader().load(getAssetUrl("assets/textures/sky/others/snow.png")));
    _(this, "createEmitter", () => {
      const e = Math.floor(1e4 * this._density), r = new Vector3$1(0, 0, -10).multiplyScalar(this._density), s = new Vector3$1(0, 0, -10).multiplyScalar(this._density);
      return new Emitter({
        maxAge: {
          value: 10
        },
        position: {
          value: new Vector3$1(0, 100, 150),
          spread: new Vector3$1(1e3, 1e3, 500)
        },
        acceleration: {
          value: r,
          spread: new Vector3$1(3, 3, 0)
        },
        velocity: {
          value: s,
          spread: new Vector3$1(5, 5, 0)
        },
        size: {
          value: 10
        },
        particleCount: e
      });
    });
    this._renderer = e, this._camera = r, this._density = Math.max(0.1, Math.min(5, defaultValue$1(s.density, 1))), this._clock = new Clock();
    const a = Math.floor(1e4 * 5), c = this._system = new Group$1({
      texture: {
        value: this.createSnow()
      },
      maxParticleCount: a
    }), l = this._emitter = this.createEmitter(r, e);
    c.addEmitter(l), this.add(c.mesh);
  }
  get density() {
    return this._density;
  }
  set density(e) {
    this._density = Math.max(0.1, Math.min(5, e)), this._emitter && this._system.removeEmitter(this._emitter), this._emitter = this.createEmitter(), this._system.addEmitter(this._emitter);
  }
  dispose() {
  }
}
const _rotationMatrix$1 = new Matrix3();
class Rain extends Object3D {
  constructor(e, r, s = {}) {
    super();
    _(this, "update", (e) => {
      if (e.map.isGlobe) {
        const s = Transforms.eastNorthUpToFixedFrame(e.camera.position);
        this._system.setPositionRotationMatrix(_rotationMatrix$1.setFromMatrix4(s));
      }
      this._system.update(this._clock.getDelta());
    });
    _(this, "createRain", () => new TextureLoader().load(getAssetUrl("assets/textures/sky/others/trace_01.png")));
    _(this, "createEmitter", () => {
      const e = Math.floor(2e4 * this._density), r = new Vector3$1(0, 0, -50).multiplyScalar(this._density), s = new Vector3$1(0, 10, -50).multiplyScalar(this._density);
      return new Emitter({
        maxAge: {
          value: 10
        },
        position: {
          value: new Vector3$1(0, 100, 250),
          spread: new Vector3$1(1e3, 1e3, 500)
        },
        acceleration: {
          value: r,
          spread: new Vector3$1(3, 3, 0)
        },
        velocity: {
          value: s,
          spread: new Vector3$1(3, 3, 0)
        },
        size: {
          value: 60
        },
        particleCount: e
      });
    });
    this._density = Math.max(0.1, Math.min(5, defaultValue$1(s.density, 1))), this._clock = new Clock();
    const a = Math.floor(2e4 * 5), c = this._system = new Group$1({
      texture: {
        value: this.createRain()
      },
      maxParticleCount: a
    }), l = this._emitter = this.createEmitter(r, e);
    c.addEmitter(l), this.add(c.mesh);
  }
  get density() {
    return this._density;
  }
  set density(e) {
    this._density = Math.max(0.1, Math.min(5, e)), this._emitter && this._system.removeEmitter(this._emitter), this._emitter = this.createEmitter(), this._system.addEmitter(this._emitter);
  }
  dispose() {
  }
}
const uniforms$u = UniformsUtils.clone({
  map: { value: null },
  color: { value: new Color(1, 1, 1) },
  opacity: { value: 1 },
  intensity: { value: 1 },
  emissiveStrength: { value: 4.5 },
  emissiveCoreBoost: { value: 1.2 },
  emissiveRimSoftness: { value: 0.4 },
  emissiveFlicker: { value: 1 }
}), vertexShader$v = `
    #include <common>

    varying vec2 vUv;

    void main() {
        vUv = uv;

        // \u7F51\u683C\u4E2D\u5FC3\uFF08\u5305\u542B\u5E73\u79FB\uFF09
        vec3 center = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

        // \u4ECE\u76F8\u673A\u5230\u4E2D\u5FC3\u7684\u65B9\u5411\uFF0C\u53EA\u4FDD\u7559\u6C34\u5E73\u5206\u91CF\uFF08Z \u8F74\u4E3A\u5782\u76F4\u65B9\u5411\uFF09
        vec3 toCamera = cameraPosition - center;
        toCamera.z = 0.0;
        float len = length(toCamera);
        if (len < 1e-5) {
            toCamera = vec3(0.0, 1.0, 0.0);
        }
        else {
            toCamera /= len;
        }

        // \u6784\u5EFA\u4FDD\u6301\u5782\u76F4\u7684\u671D\u5411\u57FA\uFF08Z \u8F74\u671D\u4E0A\uFF09
        vec3 up = vec3(0.0, 0.0, 1.0);
        vec3 right = normalize(cross(up, toCamera));
        vec3 forward = cross(right, up);

        // \u89E3\u6790\u7F29\u653E\u4FE1\u606F
        float scaleX = length(modelMatrix[0].xyz);
        float scaleY = length(modelMatrix[1].xyz);
        float scaleZ = length(modelMatrix[2].xyz);
        vec3 scaledPosition = vec3(position.x * scaleX, position.y * scaleY, position.z * scaleZ);

        vec3 worldPosition = center + right * scaledPosition.x + up * scaledPosition.y + forward * scaledPosition.z;
        gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition, 1.0);
    }
`, fragmentShader$x = `
    #include <common>
    uniform sampler2D map;
    uniform vec3 color;
    uniform float opacity;
    uniform float intensity;
    uniform float emissiveStrength;
    uniform float emissiveCoreBoost;
    uniform float emissiveRimSoftness;
    uniform float emissiveFlicker;
    varying vec2 vUv;

    void main() {
        vec4 tex = texture2D(map, vUv);
        if (tex.a <= 0.01) {
            discard;
        }
        float luminance = dot(tex.rgb, vec3(0.299, 0.587, 0.114));
        float coreFactor = pow(max(luminance, 1e-3), emissiveCoreBoost);
        float rimFactor = smoothstep(0.0, emissiveRimSoftness, tex.a);
        float hdrFactor = emissiveStrength * emissiveFlicker * intensity;

        vec3 finalColor = tex.rgb * color * coreFactor * hdrFactor;
        float finalAlpha = min(1.0, tex.a * opacity * rimFactor);
        gl_FragColor = vec4(finalColor, finalAlpha);
    }
`;
class LightningBillboardMaterial extends ShaderMaterial {
  constructor(i = {}) {
    super({
      uniforms: UniformsUtils.clone(uniforms$u),
      vertexShader: vertexShader$v,
      fragmentShader: fragmentShader$x,
      transparent: !0,
      depthWrite: !1,
      blending: AdditiveBlending
    }), this.setValues(i);
  }
}
class Thunderstorm extends Object3D {
  constructor(i, e, r = {}) {
    super(), this._clock = new Clock(), this._renderer = i, this._camera = e, this._options = r, this._lightningInterval = 3, this._lastLightningTime = 0, this._flashActive = !1, this._flashElapsed = 0, this._flashDuration = 0.45, this._lightningMesh = null, this._lightningFlickerSeed = Math.random() * Math.PI * 2, this._intervalRange = r.intervalRange || [1, 3], this._durationRange = r.durationRange || [0.35, 0.65], this.sceneSize = r.sceneSize || 500, this._scaleRange = r.scaleRange || [30, 40], this._distanceRange = r.distanceRange || [this.sceneSize * 0.25, this.sceneSize * 0.55], this._lateralRange = r.lateralRange || this.sceneSize * 0.2, this._emissiveStrength = r.emissiveStrength || 1.3, this._emissiveCoreBoost = r.emissiveCoreBoost || 1.05, this._emissiveRimSoftness = r.emissiveRimSoftness || 0.6, this._emissiveFlickerRange = r.emissiveFlickerRange || [0.92, 1.08], this._createLightningEffect();
  }
  _createRainSystem() {
    const i = Math.floor(1e4 * this._density), e = new Group$1({
      texture: {
        value: new TextureLoader().load(getAssetUrl("assets/textures/sky/others/trace_01.png"))
      },
      maxParticleCount: i
    }), r = new Vector3$1(0, 0, -80).multiplyScalar(this._density), s = new Vector3$1(0, 15, -80).multiplyScalar(this._density), a = new Emitter({
      maxAge: {
        value: 8
      },
      position: {
        value: new Vector3$1(0, 100, 250),
        spread: new Vector3$1(1500, 1500, 800)
      },
      acceleration: {
        value: r,
        spread: new Vector3$1(5, 5, 0)
      },
      velocity: {
        value: s,
        spread: new Vector3$1(5, 5, 0)
      },
      size: {
        value: 80 * this._density
      },
      particleCount: i
    });
    return e.addEmitter(a), e;
  }
  _createLightningEffect() {
    const i = new TextureLoader().load(getAssetUrl("assets/textures/weather/thunder.jpg")), e = new PlaneGeometry(1, 1);
    this._lightningMaterial = new LightningBillboardMaterial(), this._lightningMaterial.uniforms.map.value = i, this._lightningMaterial.uniforms.opacity.value = 0, typeof this._options.intensity == "number" && (this._lightningMaterial.uniforms.intensity.value = this._options.intensity), this._lightningMaterial.uniforms.emissiveStrength.value = this._emissiveStrength, this._lightningMaterial.uniforms.emissiveCoreBoost.value = this._emissiveCoreBoost, this._lightningMaterial.uniforms.emissiveRimSoftness.value = this._emissiveRimSoftness, this._lightningMaterial.uniforms.emissiveFlicker.value = this._emissiveFlickerRange[0], this._lightningContainer = new Object3D(), this._lightningMesh = new Mesh(e, this._lightningMaterial), this._lightningMesh.visible = !1, this._lightningMesh.renderOrder = 10;
    const r = MathUtils.randFloat(...this._scaleRange);
    this._lightningMesh.scale.set(r, r, 1), this._lightningContainer.add(this._lightningMesh), this.add(this._lightningContainer);
  }
  _generateLightningPosition(i) {
    var r, s;
    const e = this.sceneSize;
    if (this._camera) {
      const a = new Vector3$1();
      this._camera.getWorldDirection(a), a.z = 0, a.lengthSq() < 1e-4 ? a.set(0, 1, 0) : a.normalize();
      const c = new Vector3$1(-a.y, a.x, 0);
      c.lengthSq() < 1e-4 ? c.set(1, 0, 0) : c.normalize();
      const l = Number.isFinite((r = this._distanceRange) == null ? void 0 : r[0]) ? this._distanceRange[0] : this.sceneSize * 0.25, h = Number.isFinite((s = this._distanceRange) == null ? void 0 : s[1]) ? this._distanceRange[1] : this.sceneSize * 0.55, d = Math.max(10, Math.min(l, h)), f = Math.max(d + 10, Math.max(l, h)), p = Number.isFinite(this._lateralRange) ? this._lateralRange : this.sceneSize * 0.2, m = MathUtils.randFloat(d, f), y = MathUtils.randFloatSpread(p), x = MathUtils.randFloat(0, 15), v = new Vector3$1();
      return v.addScaledVector(a, m), v.addScaledVector(c, y), v.z = x, v;
    }
    return new Vector3$1(
      (Math.random() - 0.5) * e * 0.3,
      MathUtils.randFloat(e * 0.7, e * 1.05),
      30
    );
  }
  update(i) {
    const e = this._clock.getDelta();
    this._updateLightning(e, i);
  }
  _updateLightning(i, e) {
    if (this._lastLightningTime += i, !!this._lightningMesh)
      if (!this._flashActive && this._lastLightningTime > this._lightningInterval && this._triggerLightning(e), this._flashActive) {
        this._flashElapsed += i;
        const r = this._flashElapsed / this._flashDuration;
        if (r >= 1)
          this._endLightning();
        else {
          const s = 1 - r, a = Math.sin((this._flashElapsed + this._lightningFlickerSeed) * 40), c = 0.75 + 0.25 * a + Math.random() * 0.1, l = MathUtils.clamp(s * c, 0, 1);
          this._lightningMaterial.uniforms.opacity.value = l;
          const h = this._emissiveFlickerRange[0], d = this._emissiveFlickerRange[1], f = MathUtils.clamp(
            h + (d - h) * l + a * 0.02,
            h,
            d
          );
          this._lightningMaterial.uniforms.emissiveFlicker.value = f;
        }
      } else
        this._lightningMaterial && (this._lightningMaterial.uniforms.opacity.value = 0, this._lightningMaterial.uniforms.emissiveFlicker.value = this._emissiveFlickerRange[0]);
  }
  _triggerLightning(i) {
    if (!this._lightningMesh)
      return;
    this._flashActive = !0, this._flashElapsed = 0, this._flashDuration = MathUtils.randFloat(...this._durationRange), this._lightningInterval = MathUtils.randFloat(...this._intervalRange), this._lightningFlickerSeed = Math.random() * Math.PI * 2, this._lightningMesh.visible = !0;
    const e = MathUtils.randFloat(...this._scaleRange);
    this._lightningMesh.scale.set(e, e, 1), this._lightningMesh.position.copy(this._generateLightningPosition(i)), this._lightningMaterial.uniforms.opacity.value = 1, this._lightningMaterial.uniforms.emissiveFlicker.value = this._emissiveFlickerRange[1], this._lastLightningTime = 0;
  }
  _endLightning() {
    this._flashActive = !1, this._lightningMesh && (this._lightningMesh.visible = !1, this._lightningMaterial.uniforms.opacity.value = 0, this._lightningMaterial.uniforms.emissiveFlicker.value = this._emissiveFlickerRange[0]);
  }
  get density() {
    return this._density;
  }
  set density(i) {
    this._density = Math.max(0.1, Math.min(5, i));
  }
  dispose() {
    this._lightningContainer && this._lightningContainer.children.forEach((i) => {
      i.geometry && i.geometry.dispose(), i.material && (i.material.map && i.material.map.dispose(), i.material.dispose());
    });
  }
}
class DynamicWeather extends Object3D {
  constructor(e) {
    super();
    _(this, "_engine");
    _(this, "_sky");
    _(this, "_snow");
    _(this, "_rain");
    _(this, "_weather", "partlyCloudy");
    _(this, "_currentConverageTextureType", null);
    _(this, "_tCoverageIntensity", null);
    _(this, "_skyGroundColorBlue", new Color(1657983));
    _(this, "_skyGroundColorGray", new Color(11184810));
    _(this, "_weatherChangedListeners", []);
    _(this, "_sunLightScale", 1);
    _(this, "_skyLightScale", 1);
    _(this, "transitionDuration", 1e3);
    _(this, "_transitionStartTime", 0);
    _(this, "_transitionStartState", {});
    _(this, "_transitionEndState", {});
    _(this, "_inTransition", !1);
    _(this, "_modifyCount", 0);
    _(this, "beforeRemoveFromEngine", (e) => {
      this._sky.sunLightIntensity = 1, this._sky.skyLightIntensity = 0.5, this._sky.cloudIntensity = 0.2, this._sky.mixGrayFactor = 0, this._engine.rendering.fog.density = 0, this._engine.rendering.composition.coverageIntensity = 0, e.removePrepareRenderListener(this.handleBeforeRender);
    });
    _(this, "handleBeforeRender", (e) => {
      if (this._snow) {
        const r = this._engine.camera.position;
        this._snow.position.copy(r), this._snow.update(this._engine);
      }
      if (this._rain) {
        const r = this._engine.camera.position;
        this._rain.position.copy(r), this._rain.update(this._engine);
      }
      if (this._thunderstorm) {
        const r = this._engine.camera.position;
        this._thunderstorm.position.copy(r), this._thunderstorm.update(this._engine);
      }
      if (this._inTransition) {
        const r = (Date.now() - this._transitionStartTime) / this.transitionDuration;
        r > 1 && (this._inTransition = !1), this._updateWeatherTransitionState(r), e.requestRender();
      }
    });
    _(this, "_updateWeatherTransitionState", (e) => {
      e < 0 && (e = 0), e > 1 && (e = 1);
      const r = this._transitionStartState, s = this._transitionEndState;
      for (const a of Object.keys(r))
        this._sky[a] = MathUtils.lerp(
          r[a],
          s[a],
          e
        );
    });
    this._sky = e;
  }
  get weather() {
    return this._weather;
  }
  set weather(e) {
    if (!e || e === this._weather)
      return;
    const r = this._weather;
    this._weather = e, this._changeWeather(r, e);
    for (const s of this._weatherChangedListeners)
      s(e);
  }
  afterAddToEngine(e) {
    this._engine = e, e.addPrepareRenderListener(this.handleBeforeRender), this._changeWeather(this._weather, this._weather);
  }
  getCoverageTexture(e) {
    if (this._tCoverageIntensity === null || e !== this._currentConverageTextureType) {
      this._tCoverageIntensity && this._tCoverageIntensity.dispose();
      let r = "assets/textures/weather/TexturesCom_Snow_Plain_3x3_512_noise.jpg";
      e === "rain" && (r = "assets/textures/weather/TexturesCom_Ground_MudWet_512_roughness.jpg"), this._tCoverageIntensity = new TextureLoader().load(
        getAssetUrl(r),
        () => {
          this._engine.requestRender();
        }
      );
    }
    return this._tCoverageIntensity;
  }
  _changeWeather(e, r) {
    const s = this._engine, a = this._sky, c = a.getPresetWeatherProperties(e), l = a.getPresetWeatherProperties(r), h = [], d = [];
    for (const m of Object.keys(c))
      c[m] !== l[m] && (Number.isFinite(c[m]) && Number.isFinite(l[m]) ? h.push(m) : d.push(m));
    for (const m of Object.keys(l))
      c[m] === void 0 && d.push(m);
    let f = r === "snowy", p = ["rainy", "stormy", "thunderstorm"].includes(r);
    this._transitionStartState = {}, this._transitionEndState = {};
    for (const m of h)
      this._transitionStartState[m] = c[m], this._transitionEndState[m] = l[m];
    if (f) {
      if (!this._snow) {
        const m = this._snow = new Snow(s.renderer, s.camera);
        this.add(m);
      }
    } else
      this._snow && (this.remove(this._snow), this._snow.dispose(), this._snow = null);
    if (p) {
      if (r === "thunderstorm") {
        if (!this._thunderstorm) {
          const m = this._thunderstorm = new Thunderstorm(s.renderer, s.camera);
          this.add(m);
        }
      } else
        this._thunderstorm && (this.remove(this._thunderstorm), this._thunderstorm.dispose(), this._thunderstorm = null);
      if (!this._rain) {
        const m = r === "stormy" ? { density: 4 } : {}, y = this._rain = new Rain(s.renderer, s.camera, m);
        this.add(y), r === "stormy" ? this._rain.density = 4 : r === "rainy" ? this._rain.density = 1 : this._rain.density = 2;
      }
    } else
      this._rain && (this.remove(this._rain), this._rain.dispose(), this._rain = null), this._thunderstorm && (this.remove(this._thunderstorm), this._thunderstorm.dispose(), this._thunderstorm = null);
    if (!(h.length === 0 && d.length === 0)) {
      for (const m of d)
        this._sky[m] = l[m];
      this.transitionDuration <= 0 ? this._updateWeatherTransitionState(1) : (this._transitionStartTime = Date.now(), this._inTransition = !0, s.requestRender());
    }
  }
  addWeatherChangedListener(e) {
    this._weatherChangedListeners.indexOf(e) === -1 && this._weatherChangedListeners.push(e);
  }
  removeWeatherChangedListener(e) {
    const r = this._weatherChangedListeners.indexOf(e);
    r !== -1 && this._weatherChangedListeners.splice(r, 1);
  }
  get sunLightIntensity() {
    return this._transitionEndState.sunLightIntensity;
  }
  set sunLightIntensity(e) {
    this._modifyCount++, this._transitionEndState.sunLightIntensity = e;
  }
  get cloudIntensity() {
    return this._transitionEndState.cloudIntensity;
  }
  set cloudIntensity(e) {
    this._modifyCount++, this._transitionEndState.cloudIntensity = e;
  }
  get skyLightIntensity() {
    return this._transitionEndState.skyLightIntensity;
  }
  set skyLightIntensity(e) {
    this._modifyCount++, this._transitionEndState.skyLightIntensity = e;
  }
  get groundColor() {
    return this._sky.groundColor;
  }
  set groundColor(e) {
    this._sky.groundColor = e;
  }
  get mixGrayFactor() {
    return this._transitionEndState.mixGrayFactor;
  }
  set mixGrayFactor(e) {
    this._modifyCount++, this._transitionEndState.mixGrayFactor = e;
  }
  get coverageIntensity() {
    return this._transitionEndState.coverageIntensity;
  }
  set coverageIntensity(e) {
    this._modifyCount++, this._transitionEndState.coverageIntensity = e;
  }
  get tCoverageIntensity() {
    return this._engine.rendering.composition.tCoverageIntensity;
  }
  set tCoverageIntensity(e) {
    this._engine.rendering.composition.tCoverageIntensity = e;
  }
  get tRelectionEnhancement() {
    return this._engine.rendering.ssr.tEnhancement;
  }
  set tRelectionEnhancement(e) {
    this._engine.rendering.ssr.tEnhancement = e;
  }
  set fogDensity(e) {
    this._modifyCount++, this._transitionEndState.fogDensity = e;
  }
  get fogDensity() {
    return this._transitionEndState.fogDensity;
  }
  get skyLightScale() {
    return this._skyLightScale;
  }
  set skyLightScale(e) {
    this._skyLightScale = e;
  }
  get sunLightScale() {
    return this._sunLightScale;
  }
  set sunLightScale(e) {
    this._sunLightScale = e;
  }
}
const jitterOffsets = [
  [0, -0.33333333333333337],
  [-0.5, 0.33333333333333326],
  [0.5, -0.7777777777777778],
  [-0.75, -0.11111111111111116],
  [0.25, 0.5555555555555554],
  [-0.25, -0.5555555555555556],
  [0.75, 0.11111111111111116],
  [-0.875, 0.7777777777777777],
  [0.125, -0.9259259259259259],
  [-0.375, -0.2592592592592593],
  [0.625, 0.40740740740740744],
  [-0.625, -0.7037037037037037],
  [0.375, -0.03703703703703709],
  [-0.125, 0.6296296296296293],
  [0.875, -0.4814814814814815],
  [-0.9375, 0.18518518518518512]
];
class SceneRendering {
  constructor(i) {
    _(this, "_lastTextureRequirementsKey", -1);
    _(this, "_inited", !1);
    _(this, "_useFastEmissiveMethod", !0);
    _(this, "_jitterOffsets", jitterOffsets);
    _(this, "_jitterIndex", 0);
    this._rendering = i;
  }
  beginFrame() {
    if (!this._inited) {
      this._init(), this._inited = !0;
      return;
    }
    this._rendering.main.requirements.isTextureRequirementsChanged() && this._onTextureRequirementsChanged();
  }
  updateRenderTargetSamples(i) {
  }
  _onTextureRequirementsChanged() {
    this.dispose(), this._init();
  }
  _init() {
  }
  render() {
  }
  endFrame() {
  }
  dispose() {
  }
  isInStableRenderState() {
    return !0;
  }
  get useFastEmissiveMethod() {
    return this._useFastEmissiveMethod;
  }
  set useFastEmissiveMethod(i) {
    this._useFastEmissiveMethod = i;
  }
}
const PROJECTION_GEO = "EPSG:4326", PROJECTION_WEB_MERCATOR = "EPSG:3857", PROJECTION_ECEF = "EPSG:4978", PROJECTION_BD_MERCATOR = "BD:MERCATOR", PROJECTION_UTM = "UTM", PROJECTION_EQUAL_EARTH = "EPSG:8857", PROJECTION_SCREEN_PIXEL = "SCREEN_PIXEL", GEOMETRY_TYPE_POINT = 1, GEOMETRY_TYPE_LINE = 2, GEOMETRY_TYPE_POLYGON = 3, RENDER_STAGE_PREPARE = 0, RENDER_STAGE_SCENE = 10, RENDER_STAGE_BLOOM = 11, RENDER_STAGE_FEATURES = 20, RENDER_STAGE_POSTPROCESSING = 30;
class DirectSceneRendering extends SceneRendering {
  constructor() {
    super(...arguments);
    _(this, "isDirectSceneRendering", !0);
  }
  _init() {
    this._rendering.main, this._onTextureRequirementsChanged(), this._normalMaterial = new MeshNormalMaterial();
  }
  beginFrame() {
    if (!this._inited) {
      this._init(), this._inited = !0;
      return;
    }
    this._rendering.main.requirements.isTextureRequirementsChanged() && this._onTextureRequirementsChanged();
  }
  _onTextureRequirementsChanged() {
    const e = this._rendering, r = e.resolution, s = e.pixelRatio, c = e.main.requirements;
    c.needsEmissiveTexture ? (this._emissiveRenderTarget = new WebGLRenderTarget(r.x * s, r.y * s), this._emissiveRenderTarget.name = "EmissiveRenderTarget") : this._disposeEmissiveRenderTarget(), c.needsNormalTexture ? (this._normalRenderTarget = new WebGLRenderTarget(r.x * s, r.y * s), this._normalRenderTarget.name = "NormalRenderTarget") : this._disposeNormalRenderTarget();
  }
  render(e) {
    const r = this._rendering, s = r.renderState, a = r.stats, c = r.main, l = r.renderer, h = r._renderer.xr.isPresenting ? r.xr.camera : r.camera, d = r.scene, f = r.resolution;
    r.pixelRatio;
    const p = c.requirements;
    if (!s.viewChanged && p.enableRenderingJitter) {
      let [m, y] = this._jitterOffsets[this._debugEngineJitterIndex !== void 0 ? this._debugEngineJitterIndex : this._jitterIndex];
      h.setViewOffset(
        f.x,
        f.y,
        m / 2,
        y / 2,
        f.x,
        f.y
      ), this._jitterIndex = (this._jitterIndex + 1) % this._jitterOffsets.length;
    }
    if (l.extraProgramCacheKey = p.currentShaderKey, this.renderTarget) {
      if (!this._sceneRenderTarget || p.isRenderTargetTypeChanged()) {
        this._sceneRenderTarget && (this._sceneRenderTarget.dispose(), this._sceneRenderTarget = null);
        const m = r.resolution, y = r.pixelRatio, x = this._tDepth = new DepthTexture();
        x.generateMipmaps = !1, this._sceneRenderTarget = new WebGLRenderTarget(m.x * y, m.y * y, {
          type: p.getRenderTargetType()
        }), this._sceneRenderTarget.name = "SceneRenderTarget", p.enableStencilBuffer && (x.format = DepthStencilFormat, x.type = UnsignedInt248Type, this._sceneRenderTarget.stencilBuffer = !0), this._sceneRenderTarget.depthTexture = x, this._sceneRenderTarget.samples = r.features.antialias.samples;
      }
      l.setRenderTarget(this._sceneRenderTarget);
    } else
      l.getRenderTarget() && l.getRenderTarget().isXRRenderTarget || l.setRenderTarget(null), this._sceneRenderTarget && (this._sceneRenderTarget.dispose(), this._sceneRenderTarget = null);
    a.beginTimeStatsItem("renderScene"), l.render(d, h), a.endTimeStatsItem("renderScene"), this.renderTarget ? (this._fsQuad || (this._fsQuad = new FullScreenQuad(new ShaderMaterial({
      name: "DirectSceneRenderingCopy",
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      blending: NoBlending,
      depthTest: !1,
      uniforms: {
        tDiffuse: {
          value: this._sceneRenderTarget.texture
        },
        opacity: {
          value: 1
        }
      }
    }))), this._fsQuad.material.uniforms.tDiffuse.value = this._sceneRenderTarget.texture, l.setRenderTarget(this.renderTarget), this._fsQuad.render(l)) : this._fsQuad && (this._fsQuad.dispose(), this._fsQuad = null), r.opaquePostprocessings.hide();
    for (const m of e)
      m.onAfterColorPass && m.onAfterColorPass(r.engine);
    if (p.needsEmissiveTexture) {
      s.stage = RENDER_STAGE_BLOOM, l.extraProgramCacheKey = p.currentShaderKey + ",emissive";
      const m = /* @__PURE__ */ new Set(), y = /* @__PURE__ */ new Set();
      let x = null;
      d.traverseVisible((b) => {
        if (x = b.material, x) {
          if (this._useFastEmissiveMethod && !this._isEmissiveMaterial(x)) {
            b.visible = !1, m.add(b);
            return;
          }
          x.defines || (x.defines = {}), x.defines.MVT_MODE_EMISSIVE = !0, y.add(b);
        }
      }), this._useFastEmissiveMethod ? this._emissiveRenderTarget.depthTexture = this._sceneRenderTarget.depthTexture : this._emissiveRenderTarget.depthTexture && (this._emissiveRenderTarget.depthTexture = null), a.beginTimeStatsItem("renderEmissiveTexture"), l.setRenderTarget(this._emissiveRenderTarget);
      const v = l.autoClear;
      this._useFastEmissiveMethod && (l.autoClear = !1, l.clear(!0, !1, !0));
      const S = d.background;
      d.background = null;
      const E = l.shadowMap.enabled;
      l.shadowMap.enabled = !1, l.render(d, h), d.background = S, l.autoClear = v, l.shadowMap.enabled = E, a.endTimeStatsItem("renderEmissiveTexture");
      for (const b of y)
        b.material.defines.MVT_MODE_EMISSIVE = !1;
      if (this._useFastEmissiveMethod)
        for (const b of m)
          b.visible = !0;
      l.extraProgramCacheKey = "", l.setRenderTarget(this.renderTarget);
    }
    if (p.needsNormalTexture) {
      l.extraProgramCacheKey = p.currentShaderKey + ",normal", l.setRenderTarget(this._normalRenderTarget);
      const m = l.autoClear;
      l.autoClear = !1, l.clear();
      const y = d.background;
      d.background = null;
      const x = l.shadowMap.enabled;
      l.shadowMap.enabled = !1;
      const v = d.overrideMaterial;
      d.overrideMaterial = this._normalMaterial, l.render(d, h), l.autoClear = m, l.shadowMap.enabled = x, d.overrideMaterial = v, d.background = y, l.extraProgramCacheKey = "", l.setRenderTarget(this.renderTarget);
    }
    for (const m of e)
      m.onAfterMainPass && m.onAfterMainPass(r.engine);
    h.setViewOffset(
      f.x,
      f.y,
      0,
      0,
      f.x,
      f.y
    );
  }
  updateRenderTargetSamples(e) {
    const r = this._sceneRenderTarget;
    r && (r.samples = e);
  }
  _isBlackColor(e) {
    return e.r === 0 && e.g === 0 && e.b === 0;
  }
  _isEmissiveMaterial(e) {
    if (e.disableEmissive)
      return !1;
    if (e.isShaderMaterial || e.isRawShaderMaterial)
      return !0;
    if (e.isMeshBasicMaterial)
      return e.emissive && !this._isBlackColor(e.emissive);
    if (e.isMeshStandardMaterial || e.isMeshPhongMaterial || e.isMeshLambertMaterial || e.isMeshToonMaterial)
      return e.emissive && !this._isBlackColor(e.emissive) || !!e.emissiveMap;
  }
  _disposeEmissiveRenderTarget() {
    this._emissiveRenderTarget && (this._sceneRenderTarget && this._emissiveRenderTarget.depthTexture === this._sceneRenderTarget.depthTexture && (this._emissiveRenderTarget.depthTexture = null), this._emissiveRenderTarget.dispose(), this._emissiveRenderTarget = null);
  }
  _disposeNormalRenderTarget() {
    this._normalRenderTarget && (this._normalRenderTarget.dispose(), this._normalRenderTarget = null);
  }
  dispose() {
    const r = this._rendering.stats;
    r.removeTimeStatsItem("renderScene"), r.removeTimeStatsItem("renderEmissiveTexture"), this._disposeEmissiveRenderTarget(), this._disposeNormalRenderTarget(), this._fsQuad && (this._fsQuad.dispose(), this._fsQuad = null);
  }
  setSize(e, r) {
    const s = this._rendering;
    s.resolution;
    const a = s.pixelRatio;
    this._emissiveRenderTarget && this._emissiveRenderTarget.setSize(e * a, r * a), this._normalRenderTarget && this._normalRenderTarget.setSize(e * a, r * a), this._sceneRenderTarget && this._sceneRenderTarget.setSize(e * a, r * a);
  }
  get emissiveTexture() {
    return this._emissiveRenderTarget && this._emissiveRenderTarget.texture;
  }
  get normalTexture() {
    return this._normalRenderTarget && this._normalRenderTarget.texture;
  }
  get depthTexture() {
    return this._sceneRenderTarget && this._sceneRenderTarget.depthTexture;
  }
  get diffuseTexture() {
    return this._sceneRenderTarget && this._sceneRenderTarget.texture;
  }
}
class MRTSceneRendering extends SceneRendering {
  constructor() {
    super(...arguments);
    _(this, "isMRTSceneRendering", !0);
  }
  _init() {
    const e = this._rendering, r = e.resolution, s = e.main.requirements;
    let a = 1, c = {}, l = "";
    s.needsEmissiveTexture && (c.emissive = a, l += `#define MVT_MRT_OUT_EMISSIVE ${a}
`, a++), (s.needsNormalTextureWhenMRT || s.needsNormalTexture) && (c.normal = a, l += `#define MVT_MRT_OUT_NORMAL ${a}
`, a++), s.needsMetallicRoughTexture && (c.metallicRough = a, l += `#define MVT_MRT_OUT_METALLICROUGH ${a}
`, a++), this._textureChannelNameMap = c, l += `#include <mvt_mrt_output_pars_fragment>
`, this._fragBeforeMainStart = l, this._fragBeforeMainEnd = `#include <mvt_mrt_output_fragment>
`;
    const h = this._mainMrt = new WebGLRenderTarget(
      r.x * e.pixelRatio,
      r.y * e.pixelRatio,
      a,
      {
        samples: e.features.antialias.samples
      }
    ), d = this._tDepth = new DepthTexture();
    d.generateMipmaps = !1, s.enableStencilBuffer && (d.format = DepthStencilFormat, d.type = UnsignedInt248Type, h.stencilBuffer = !0), h.depthTexture = d, h.depthBuffer = !0;
    for (let f = 0, p = h.texture.length; f < p; f++)
      h.texture[f].minFilter = NearestFilter, h.texture[f].magFilter = NearestFilter, h.texture[f].format = RGBAFormat;
    h.texture.isTexture = !0, this._fsQuad || (this._fsQuad = new FullScreenQuad(new ShaderMaterial({
      name: CopyShader.name,
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      uniforms: {
        tDiffuse: {
          value: h.texture[0]
        },
        opacity: {
          value: 1
        }
      }
    })));
  }
  render() {
    const e = this._rendering, r = e.stats, s = e.renderer, a = e.main.requirements;
    s.extraProgramCacheKey = "mrt-" + a.currentTextureRequirementsKey + a.currentShaderKey, s.setRenderTarget(this._mainMrt), r.beginTimeStatsItem("renderMRTScene"), s.render(e.scene, e.camera), r.endTimeStatsItem("renderMRTScene"), s.extraProgramCacheKey = "", s.setRenderTarget(this.renderTarget), this._fsQuad.render(s);
  }
  updateRenderTargetSamples(e) {
    const r = this._mainMrt;
    r.samples = e;
  }
  modifyFragmentShader(e) {
    return addExtraCodeToShader(e, this._fragBeforeMainStart, null, this._fragBeforeMainEnd);
  }
  dispose() {
    this._rendering.stats.removeTimeStatsItem("renderMRTScene"), this._tDepth && (this._tDepth.dispose(), this._tDepth = null), this._mainMrt && (this._mainMrt.dispose(), this._mainMrt = null), this._fsQuad && (this._fsQuad.dispose(), this._fsQuad = null);
  }
  setSize(e, r) {
    const s = this._rendering, a = this._mainMrt;
    a && a.setSize(e * s.pixelRatio, r * s.pixelRatio);
  }
  get emissiveTexture() {
    return this._mainMrt && this._mainMrt.texture[this._textureChannelNameMap.emissive];
  }
  get normalTexture() {
    return this._mainMrt && this._mainMrt.texture[this._textureChannelNameMap.normal];
  }
  get metallicRoughTexture() {
    return this._mainMrt && this._mainMrt.texture[this._textureChannelNameMap.metallicRough];
  }
  get depthTexture() {
    return this._tDepth;
  }
  get diffuseTexture() {
    return this._mainMrt && this._mainMrt.texture[0];
  }
  get highPDepthTexture() {
    return this._mainMrt && this._mainMrt.texture[this._textureChannelNameMap.depth];
  }
}
class RenderingRequirements {
  constructor(i) {
    _(this, "needsEmissiveTexture", !1);
    _(this, "needsNormalTexture", !1);
    _(this, "needsNormalTextureWhenMRT", !1);
    _(this, "needsDepthTexture", !1);
    _(this, "needsMetallicRoughTexture", !1);
    _(this, "enableStencilBuffer", !1);
    _(this, "enableRenderingJitter", !1);
    _(this, "needsFloatRenderTarget", !1);
    _(this, "_lastNeedsFloatRenderTarget", null);
    _(this, "_lastTextureRequirementsKey", -1);
    _(this, "_currentTextureRequirementsKey", -1);
    _(this, "featuresShaderKey", "");
    this._rendering = i, this._renderingMain = i.main;
  }
  beginFrame() {
    this._resetTextureRequirements(), this._updateRequirements(), this._currentTextureRequirementsKey = this._updateTextureRequirementsKey();
  }
  _updateRequirements() {
    const i = this._renderingMain, e = i.features, r = i.postprocessings;
    this._rendering.useHighPrecisionBuffer && (this.needsFloatRenderTarget = !0), e.updateReqirements(this), r.updateReqirements(this);
  }
  _resetTextureRequirements() {
    this.needsEmissiveTexture = !1, this.needsNormalTexture = !1, this.needsNormalTextureWhenMRT = !1, this.needsDepthTexture = !1, this.needsMetallicRoughTexture = !1, this.enableStencilBuffer = !0, this.enableRenderingJitter = !1, this.needsFloatRenderTarget = !1;
  }
  _updateTextureRequirementsKey() {
    let i = 0;
    return this.needsEmissiveTexture && (i |= 1), this.needsNormalTexture && (i |= 2), this.needsDepthTexture && (i |= 4), this.needsMetallicRoughTexture && (i |= 8), this.enableStencilBuffer && (i |= 16), i;
  }
  isTextureRequirementsChanged() {
    return this._lastTextureRequirementsKey !== this._currentTextureRequirementsKey;
  }
  isRenderTargetTypeChanged() {
    return this._lastNeedsFloatRenderTarget !== this.needsFloatRenderTarget;
  }
  getRenderTargetType() {
    return this.needsFloatRenderTarget ? HalfFloatType : UnsignedByteType;
  }
  endFrame() {
    this._lastTextureRequirementsKey = this._currentTextureRequirementsKey, this._lastNeedsFloatRenderTarget = this.needsFloatRenderTarget;
  }
  get currentTextureRequirementsKey() {
    return this._currentTextureRequirementsKey;
  }
  get currentShaderKey() {
    return this.featuresShaderKey;
  }
}
class ShaderPass extends Pass {
  constructor(i, e = "tDiffuse") {
    super(), this.textureID = e, this.uniforms = null, this.material = null, i instanceof ShaderMaterial ? (this.uniforms = i.uniforms, this.material = i) : i && (this.uniforms = UniformsUtils.clone(i.uniforms), this.material = new ShaderMaterial({
      name: i.name !== void 0 ? i.name : "unspecified",
      defines: Object.assign({}, i.defines),
      uniforms: this.uniforms,
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader
    })), this._fsQuad = new FullScreenQuad(this.material);
  }
  render(i, e, r) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = r.texture), this._fsQuad.material = this.material, this.renderToScreen ? (i.setRenderTarget(null), this._fsQuad.render(i)) : (i.setRenderTarget(e), this.clear && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), this._fsQuad.render(i));
  }
  dispose() {
    this.material.dispose(), this._fsQuad.dispose();
  }
}
const OutputShader = {
  name: "OutputShader",
  uniforms: {
    tDiffuse: { value: null },
    toneMappingExposure: { value: 1 }
  },
  vertexShader: `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#elif defined( CUSTOM_TONE_MAPPING )

				gl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
};
class OutputPass extends Pass {
  constructor() {
    super(), this.uniforms = UniformsUtils.clone(OutputShader.uniforms), this.material = new RawShaderMaterial({
      name: OutputShader.name,
      uniforms: this.uniforms,
      vertexShader: OutputShader.vertexShader,
      fragmentShader: OutputShader.fragmentShader
    }), this._fsQuad = new FullScreenQuad(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  render(i, e, r) {
    this.uniforms.tDiffuse.value = r.texture, this.uniforms.toneMappingExposure.value = i.toneMappingExposure, (this._outputColorSpace !== i.outputColorSpace || this._toneMapping !== i.toneMapping) && (this._outputColorSpace = i.outputColorSpace, this._toneMapping = i.toneMapping, this.material.defines = {}, ColorManagement.getTransfer(this._outputColorSpace) === SRGBTransfer && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === LinearToneMapping ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === ReinhardToneMapping ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === CineonToneMapping ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === ACESFilmicToneMapping ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this._toneMapping === AgXToneMapping ? this.material.defines.AGX_TONE_MAPPING = "" : this._toneMapping === NeutralToneMapping ? this.material.defines.NEUTRAL_TONE_MAPPING = "" : this._toneMapping === CustomToneMapping && (this.material.defines.CUSTOM_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (i.setRenderTarget(null), this._fsQuad.render(i)) : (i.setRenderTarget(e), this.clear && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), this._fsQuad.render(i));
  }
  dispose() {
    this.material.dispose(), this._fsQuad.dispose();
  }
}
class UIPass extends Pass {
  constructor(i) {
    super(), this.name = "UIPass", this.needsSwap = !1, this.rendering = i, this.camera = i.camera, this._outputColorSpace = null, this._toneMapping = null, this._uiScene = null, this.material = new ShaderMaterial(CopyShader), this.material.name = "UIPassCopyShader", this.fsQuad = new FullScreenQuad(this.material);
  }
  render(i, e, r) {
    const s = this._uiScene = this.rendering.uiScene;
    s.visible = !0, i.setRenderTarget(r), (this._outputColorSpace !== i.outputColorSpace || this._toneMapping !== i.toneMapping) && (this._outputColorSpace = i.outputColorSpace, this._toneMapping = i.toneMapping, s.traverse((a) => {
      const c = a.material;
      c && (ColorManagement.getTransfer(this._outputColorSpace) === SRGBTransfer && (c.uniforms.srgbTransformer = { value: !0 }), this._toneMapping === LinearToneMapping ? c.uniforms.isLinearToneMapping = { value: !0 } : this._toneMapping === ReinhardToneMapping ? c.uniforms.isReinhardToneMapping = { value: !0 } : this._toneMapping === CineonToneMapping ? c.uniforms.isCineonToneMapping = { value: !0 } : this._toneMapping === ACESFilmicToneMapping && (c.uniforms.isACESFilmicToneMapping = { value: !0 }));
    })), i.autoClear = !1, i.render(s, this.camera), i.autoClear = !0, this.renderToScreen === !0 && (i.setRenderTarget(null), this.material.uniforms.tDiffuse.value = r.texture, this.fsQuad.render(i)), s.visible = !1;
  }
  dispose() {
    this.material.dispose(), this.material = null, this.fsQuad.dispose(), this.fsQuad = null;
  }
}
BlendFunction.NORMAL;
const _vector2$1 = new Vector2$1();
class Postprocessings {
  constructor(i) {
    _(this, "_postprocessings", []);
    _(this, "_validCount", 0);
    _(this, "_composer", null);
    _(this, "_outputPass", null);
    _(this, "_samples", 0);
    this._rendering = i;
  }
  setSize(i, e) {
    this._composer && this._composer.setSize(i, e);
    const r = this._rendering.engine.renderer.getDrawingBufferSize(_vector2$1);
    for (const s of this._postprocessings)
      s.setSize && (s instanceof EffectPass ? s.setSize(r.width, r.height) : s.setSize(i, e));
  }
  beginFrame() {
    if (this._outputPass || (this._outputPass = new OutputPass(), this._outputPass.renderOrder = 200, this.add(this._outputPass)), !this._uiPass) {
      const r = this._uiPass = new UIPass(this._rendering);
      r.material.transparent = !0, r.renderOrder = 3e3, this.add(r);
    }
    const e = this._rendering.uiScene.children.length > 0;
    this._uiPass.enabled = e, this._updatePostprocessings();
  }
  _updatePostprocessings() {
    let i = 0;
    for (let e = 0, r = this._postprocessings.length; e < r; e++)
      this._postprocessings[e].enabled && i++;
    this._validCount = i;
  }
  add(i) {
    const e = this._rendering, r = e.engine;
    if (this._postprocessings.indexOf(i) === -1) {
      if (i.rendering = this._rendering, i instanceof EffectPass) {
        const s = r.renderer.getDrawingBufferSize(_vector2$1), a = r.renderer.getContext().getContextAttributes().alpha, c = e.useHighPrecisionBuffer ? HalfFloatType : void 0;
        i.setRenderer(r.renderer), i.setSize(s.width, s.height), i.initialize(r.renderer, a, c);
      }
      this._postprocessings.push(i);
    }
    this._postprocessings.sort((s, a) => {
      const c = s.renderOrder || 0, l = a.renderOrder || 0;
      return c - l;
    });
  }
  remove(i) {
    const e = this._postprocessings.indexOf(i);
    e !== -1 && this._postprocessings.splice(e, 1);
  }
  render() {
    if (this._validCount <= 0)
      return;
    const i = this._rendering, e = i.sharedFullScreenRenderTargets, r = i.stats;
    r.beginTimeStatsItem("postprocessingRender");
    let s = i.renderer.getRenderTarget(), a = e.getAvailableRenderTarget();
    const c = i.renderState.deltaTime / 1e3;
    let l = this._validCount - 1, h = 0;
    for (let d = 0, f = this._postprocessings.length; d < f; d++) {
      const p = this._postprocessings[d];
      if (!!p.enabled) {
        if (l === h ? p.renderToScreen = !0 : p.renderToScreen = !1, p instanceof EffectPass ? p.render(i.renderer, s, a, c) : p.render(i.renderer, a, s, c), p.needsSwap && l !== h) {
          let m = s;
          s = a, a = m;
        }
        h++;
      }
    }
    e.releaseRenderTarget(s), r.endTimeStatsItem("postprocessingRender");
  }
  isInStableRenderState() {
    for (const i of this._postprocessings)
      if (i.enabled && i.isStable === !1)
        return !1;
    return !0;
  }
  updateReqirements(i) {
    for (const e of this._postprocessings)
      !e.enabled || (e.needsEmissiveTexture && (i.needsEmissiveTexture = !0), e.needsNormalTexture && (i.needsNormalTexture = !0), e.needsNormalTextureWhenMRT && (i.needsNormalTextureWhenMRT = !0), e.needsDepthTexture && (i.needsDepthTexture = !0), e.needsMetallicRoughTexture && (i.needsMetallicRoughTexture = !0), e.enableStencilBuffer && (i.enableStencilBuffer = !0), e.enableRenderingJitter && (i.enableRenderingJitter = !0));
  }
  endFrame() {
  }
  dispose() {
    this._postprocessingRenderTarget1 && (this._postprocessingRenderTarget1.dispose(), this._postprocessingRenderTarget1 = null);
  }
  get renderTarget1() {
    return this._postprocessingRenderTarget1;
  }
  get validCount() {
    return this._validCount;
  }
  get postprocessings() {
    return this._postprocessings;
  }
}
class OpaqueCopyPass extends Pass {
  constructor(i, e) {
    super(), this.enabled = !0, this.needsSwap = !0, this._camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1), this._scene = new Scene(), this._material = new ShaderMaterial({
      uniforms: {
        tDepth: { value: null },
        tDiffuse: { value: null }
      },
      vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position.xy, 0.0, 1.0);
                }
            `,
      fragmentShader: `
                varying vec2 vUv;
                uniform sampler2D tDiffuse;
                uniform sampler2D tDepth;

                void main() {
                    vec4 diffuse = texture2D(tDiffuse, vUv);
                    float depth = texture2D(tDepth, vUv).r;
                    gl_FragColor = diffuse;
                    gl_FragDepth = depth;
                }
            `
    }), this._quad = new FullScreenQuad(this._material), this.material = this._material, this.needsDepthTexture = !0, this.outputTarget = this._createRenderTarget(i, e);
  }
  _createRenderTarget(i, e) {
    const r = new DepthTexture(i, e, FloatType);
    return r.format = DepthStencilFormat, r.type = UnsignedInt248Type, new WebGLRenderTarget(i, e, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthTexture: r,
      depthBuffer: !0,
      stencilBuffer: !1
    });
  }
  render(i, e, r) {
    !this.enabled || (this._material.uniforms.tDiffuse.value = r.texture, this._material.uniforms.tDepth.value = r.depthTexture, i.setRenderTarget(e), i.clear(), this._quad.render(i), i.setRenderTarget(this.outputTarget), i.clear(), this._quad.render(i));
  }
  get texture() {
    return this.outputTarget.texture;
  }
  get depthTexture() {
    return this.outputTarget.depthTexture;
  }
  setSize(i, e) {
    this.outputTarget.setSize(i, e), this.outputTarget.depthTexture.image.width = i, this.outputTarget.depthTexture.image.height = e;
  }
}
const vertexShader$u = `#define GLSLIFY 1
// \u4E3A\u4E86\u505A\u6C34\u4F53\u5782\u76F4\u6DF1\u5EA6\uFF0C\u8981\u6C42\u6CD5\u7EBFnormal\u5FC5\u987B\u662F\u4E16\u754C\u7A7A\u95F4\u7684(\u5982\u4E00\u4E2APlane\u5E73\u9762z\u5728\u7403\u4E0A\u5C55\u793A, \u5C06\u5176\u77E9\u9635\u8F6C\u6362\u5230\u7403\u5750\u6807\u7CFB\u4E0B, \u8FD8\u9700\u53E6\u5916\u505A\u6CD5\u7EBF\u8BA1\u7B97, \u5C06\u5176\u4ECE(0, 0, 1)\u8F6C\u6362\u5230fixed system)
// \u5927\u90E8\u5206\u6C34\u4F53\u6570\u636E\u90FD\u6CA1\u6709\u6CD5\u7EBF\uFF0C\u6240\u4EE5\u8FD9\u91CC\u9ED8\u8BA4\u5E73\u9762\u5C31\u75280,0,1\u4FDD\u8BC1\u5927\u90E8\u5206\u60C5\u51B5\u6B63\u786E\uFF0C\u7403\u4E0A\u8BA1\u7B97ecefMatrix
uniform mat4 textureMatrix;
uniform float time;
uniform float size;
uniform float uOffsetScale;

#ifdef IS_GLOBE
attribute mat4 ecefMatrix;
varying mat4 vEcefMatrix;
#endif

varying vec2 vUv;
varying vec4 mirrorCoord;
varying vec4 worldPosition;
varying vec4 vClipSpace;
varying vec3 vWorldNormal;

#include <common>
#include <normal_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() {
    #ifdef IS_GLOBE
    vEcefMatrix = ecefMatrix;
        vec3 zNormal = normalize(vec3(ecefMatrix[0][2], ecefMatrix[1][2], ecefMatrix[2][2]));
    #else
        vec3 zNormal = vec3(0.0, 0.0, 1.0);
    #endif

    vUv = uv;
    mirrorCoord = modelMatrix * vec4(position, 1.0);
    worldPosition = mirrorCoord.xyzw;
    mirrorCoord = textureMatrix * mirrorCoord;
    // \u6C34\u4F53\u6270\u52A8
    float offset = cos(0.5 * (vUv.x * size) + 0.5 * (vUv.y * size)) * sin(time);
    offset += sin(0.8 * (vUv.x * size) + 0.8 * (vUv.y * size)) * cos(1.5 * time);
    worldPosition.xyz += zNormal * offset * uOffsetScale;
    vec4 mvPosition = viewMatrix * worldPosition;
    gl_Position = projectionMatrix * mvPosition;
    vWorldNormal = zNormal;

    vClipSpace = gl_Position;

    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>
    #include <logdepthbuf_vertex>
    #include <shadowmap_vertex>
}`, fragmentShader$w = `// http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL

precision highp float;
precision highp int;
#define GLSLIFY 1

uniform sampler2D tFoamNoise;
uniform float uDepthSoftness;
uniform vec3 uWaterShallowColor;
uniform vec3 uWaterDeepColor;
uniform float uFoamSpeed;
uniform float uFoamScale;
uniform float uFoamSoftness;
uniform mat4 projectionInverseMatrix;
uniform mat4 viewInverseMatrix;
uniform float uCrestFoam;
uniform vec3 uCrestFoamColor;
uniform float uFoamDepthSoftness;
uniform float uSpecularStrength;
uniform float pixelRatio;
uniform vec2 resolution;

// uniform sampler2D mirrorSampler;
uniform bool autoScale;
uniform float alpha;
uniform float time;
uniform float size;
uniform float distortionScale;
uniform sampler2D normalMap;
uniform sampler2D waterBedMap;
uniform vec3 sunColor;
uniform vec3 sunDirection;
uniform vec3 eye;
uniform vec3 waterColor;
uniform vec3 finalColor;
uniform sampler2D tDepth;
uniform sampler2D tScreen;
uniform float uCameraNear;
uniform float uCameraFar;
varying vec4 vClipSpace;
varying vec3 vWorldNormal;
#ifdef USE_ENVMAP
    uniform sampler2D envMap;
#else
    uniform vec3 reflectionColor;
#endif
uniform mat3 mvt_normalMatrix;

varying vec2 vUv;
varying vec4 mirrorCoord;
varying vec4 worldPosition;

uniform float uUvScale;

vec4 getNoise(vec2 uv) {
    vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);
    vec2 uv1 = uv / 107.0 - vec2(time / -19.0, time / 31.0);
    vec2 uv2 = uv / vec2(907.0, 803.0) + vec2(time / 101.0, time / 97.0);
    vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);
    vec4 noise = texture2D(normalMap, uv0) +
        texture2D(normalMap, uv1) +
        texture2D(normalMap, uv2) +
        texture2D(normalMap, uv3);
    return noise * 0.5 - 1.0;
}

void sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor) {
    vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));
    float direction = max(0.0, dot(eyeDirection, reflection));
    specularColor += pow(direction, shiny) * sunColor * spec;
    diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;
}

#define ENVMAP_TYPE_CUBE_UV

#include <common>
#include <packing>

#include <bsdfs>
#include <logdepthbuf_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

#include <cube_uv_reflection_fragment>

#define MVT_FRAG_REFLECTION_FACTOR
#define MVT_FRAG_NORMAL

/* texture tiling */
#define HASHSCALE1 443.8975
//----------------------------------------------------------------------------------------
//  1 out, 2 in...

float hash12(vec2 p) {
	vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
	p3 += dot(p3, p3.yzx + 19.19);
	return fract((p3.x + p3.y) * p3.z);
}

float noise(vec2 p){
	vec2 ip = floor(p);
	vec2 u = fract(p);
	u = u*u*(3.0-2.0*u);
	
	float res = mix(
		mix(hash12(ip),hash12(ip+vec2(1.0,0.0)),u.x),
		mix(hash12(ip+vec2(0.0,1.0)),hash12(ip+vec2(1.0,1.0)),u.x),u.y);
	//return res*res;
    return res;
}

#define HASHSCALE3 vec3(.1031, .1030, .0973)
//----------------------------------------------------------------------------------------
//  3 out, 1 in...
vec3 hash31(float p) {
	vec3 p3 = fract(vec3(p) * HASHSCALE3);
	p3 += dot(p3, p3.yzx+19.19);
	return fract((p3.xxy+p3.yzz)*p3.zyx); 
}

struct InterpNodes2 {
    vec2 seeds;
    vec2 weights;
};
InterpNodes2 GetNoiseInterpNodes(float smoothNoise) {
    vec2 globalPhases = vec2(smoothNoise * 0.5) + vec2(0.5, 0.0);
    vec2 phases = fract(globalPhases);
    vec2 seeds = floor(globalPhases) * 2.0 + vec2(0.0, 1.0);
    vec2 weights = min(phases, vec2(1.0) - phases) * 2.0;
    return InterpNodes2(seeds, weights);
}

vec4 PreserveVariance(vec4 linearColor, vec4 meanColor, float moment2) {
    return (linearColor - meanColor) / sqrt(moment2) + meanColor;
}

vec4 GetTextureSample(sampler2D tex, vec2 uvIn, float seed) {
    vec3 hash = hash31(seed);
    float ang = hash.x * 2.0 * PI;
    mat2 rotation = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));
    
    vec2 uv = rotation * uvIn + hash.yz;
    return texture2D(tex, uv);
}

const float layersCount = 5.0;
vec4 texture2D_NoTiling(sampler2D tex, vec2 uv) {
    InterpNodes2 interpNodes = GetNoiseInterpNodes(noise(uv) * layersCount);
    
    vec4 col;
    
    float moment2 = 0.0;
    for(int i = 0; i < 2; i++) {
        float weight = interpNodes.weights[i];
        moment2 += weight * weight;
        col += GetTextureSample(tex, uv, interpNodes.seeds[i]) * weight;
    }
    col = PreserveVariance(col, texture2D(tex, vec2(0.5), 10000.0), moment2);
    return col;
}

float step_distance(float value) {
    float n = 100.;
    if (value > 1000.) {
        n = 1000.;
    }
    if (value > 10000.) {
        n = 10000.;
    }
    if (value > 100000.) {
        n = 100000.;
    }
    return value - value / n;
}

float toLinearDepth (float zDepth) {
    float near = uCameraNear;
    float far = uCameraFar;
    return (2.0 * near * far / (far + near - (2.0 * zDepth - 1.0) * (far - near)));
}

vec2 clipSpaceToTexCoords(vec4 clipSpace) {
    vec2 ndc = (clipSpace.xy/clipSpace.w);
    vec2 textCoords = ndc/2.0+0.50;
    return textCoords;
}

float linearize_depth(in float depth, in float cameraNear, in float cameraFar){
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float reconstruct_depth(sampler2D tDepth, const in vec2 uv, in float cameraNear, in float cameraFar){
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float reconstruct_depth2(float depth, in float cameraNear, in float cameraFar){
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float getDepthFromTexture(sampler2D tDepth, vec2 uv) {
    #if defined( USE_LOGDEPTHBUF )
        return linearize_depth(reconstruct_depth(tDepth, uv, uCameraNear, uCameraFar), uCameraNear, uCameraFar);
    #else
        return texture2D(tDepth, uv).x;
    #endif
}

vec3 mvtGetViewPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);

    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];
    // clipSpacePosition *= clipW;
    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;
    
    viewSpacePosition /= viewSpacePosition.w;
    return viewSpacePosition.xyz;

}

vec3 mvtGetWorldPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix, mat4 viewInverseMatrix) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);

    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;
    vec4 worldSpacePosition = viewInverseMatrix * viewSpacePosition;

    return worldSpacePosition.xyz / worldSpacePosition.w;
}

float getDepth(float depth) {
    #if defined( USE_LOGDEPTHBUF )
        return linearize_depth(reconstruct_depth2(depth, uCameraNear, uCameraFar), uCameraNear, uCameraFar);
    #else
        return depth;
    #endif 
}

float calculateWaterDepthDiff (vec2 texCoords, float fragDepth) {
    float depth = getDepthFromTexture(tDepth, texCoords);
    float depth2 = getDepth(fragDepth);

    return abs(depth2 - depth);
}

float calculateWaterDepth (vec2 texCoords, float fragDepth) {
    float depth = getDepthFromTexture(tDepth, texCoords);
    vec3 worldPosition1 = mvtGetWorldPositionByDepth(depth, texCoords, projectionInverseMatrix, viewInverseMatrix);
    float floorDistance = toLinearDepth (depth);
    depth = getDepth(fragDepth);
    vec3 worldPosition2 = mvtGetWorldPositionByDepth(depth, texCoords, projectionInverseMatrix, viewInverseMatrix);
    return dot((worldPosition2 - worldPosition1), vWorldNormal);
}

vec2 refract_uv(vec2 uv, float strength, vec3 normal){
	float strength1 = strength;
	uv += strength1 * length(normal) - strength1 * 1.2;
	return uv;
}

float h12(vec2 p)
{
    return fract(sin(dot(p, vec2(32.52554, 45.5634))) * 12432.2355);
}

float n12(vec2 p)
{
    vec2 i = floor(p);
    vec2 f = fract(p);
    f *= f * (3.0 - 2.0 * f);
    return mix(
        mix(h12(i + vec2(0.0, 0.0)), h12(i + vec2(1.0, 0.0)), f.x),
        mix(h12(i + vec2(0.0, 1.0)), h12(i + vec2(1.0, 1.0)), f.x),
        f.y
    );
}

float caustics(vec2 p, float t)
{
    vec3 k = vec3(p, t);
    float l;
    mat3 m = mat3(-2, -1, 2,
                   3, -2, 1,
                   1,  2, 2);
    float n = n12(p);
    k = k * m * 0.5;
    l = length(0.5 - fract(k + n));
    k = k * m * 0.4;
    l = min(l, length(0.5 - fract(k + n)));
    k = k * m * 0.3;
    l = min(l, length(0.5 - fract(k + n)));
    return pow(l, 7.0) * 25.0;
}

vec2 hashVec2(vec2 p) {
    float x = fract(sin(dot(p ,vec2(127.1, 311.7))) * 43758.5453);
    float y = fract(sin(dot(p ,vec2(269.5, 183.3))) * 43758.5453);
    return vec2(x, y);
}

vec2 alignUv(vec2 uv) {
    vec2 texelSize = resolution * pixelRatio;
    return vec2((floor(uv * texelSize) + 0.5) / (texelSize));
}

void main() {

    float fragDepth = log2(vFragDepth) * logDepthBufFC * 0.5;
    // \u751F\u6210\u6270\u52A8\u6CD5\u7EBF
    vec3 N = normalize(vWorldNormal); // \u6CD5\u7EBF\u65B9\u5411
    vec3 T = normalize(cross(vec3(0.0, 1.0, 0.0), N)); // \u5207\u7EBF\u65B9\u5411\uFF08\u907F\u514D\u9000\u5316\uFF09
    if (length(T) < 1e-3) {
        T = normalize(cross(vec3(1.0, 0.0, 0.0), N));
    }
    vec3 B = cross(N, T); // \u526F\u6CD5\u7EBF

    vec2 uvValue = vUv * uUvScale;
    vec4 noise = getNoise(uvValue);
    float cameraDistance = length(cameraPosition.xyz - worldPosition.xyz);
    float logDistance = log2(cameraDistance) * logDepthBufFC * 0.5;
    vec3 surfaceNormal = normalize(noise.xyz * vec3(2.0, 2.0, 1.0));

    vec3 originNormal = surfaceNormal;
    surfaceNormal = normalize(
        surfaceNormal.x * T +
        surfaceNormal.y * B +
        surfaceNormal.z * N
    );

    // \u76F8\u673A\u65B9\u5411\u4E0E\u6270\u52A8\u65B9\u5411
    vec3 worldToEye = cameraPosition - worldPosition.xyz;
    vec3 eyeDirection = normalize(worldToEye);
    float dist = length(worldToEye);

    // \u6C34\u4F53\u989C\u8272\u900F\u660E\u5EA6\u8BBE\u7F6E
    float foamAlpha = 0.5;
    float shallowAlpha = 0.3;
    float deepAlpha = 0.99;

    // \u83B7\u53D6\u88C1\u526A\u7A7A\u95F4\u7684\u771F\u5B9E\u8D34\u56FE\u5750\u6807
    vec2 realCoords = clipSpaceToTexCoords(vClipSpace);

    realCoords = alignUv(realCoords);
    vec2 originRealCoords = realCoords;

    // \u539F\u59CB\u6C34\u6DF1\uFF08\u5CB8\u8FB9\u6548\u679C\u7528\uFF09
    float waterDepthOrigin = calculateWaterDepth(realCoords, fragDepth);
    float depthFade = smoothstep(0.0, 2.0, waterDepthOrigin);
    // \u6839\u636E\u8DDD\u79BB\u8FDB\u884C\u6270\u52A8\u8870\u51CF
    vec2 distortion = originNormal.xy * (0.001 + min(0.005, 1.0 / cameraDistance)) * distortionScale * depthFade;
    realCoords += distortion;

    // \u8BA1\u7B97\u6270\u52A8\u540E\u7684\u6DF1\u5EA6\u8D34\u56FE\u503C
    float disturbedDepth = texture2D(tDepth, realCoords).x;
    // \u6298\u5C04\u4F18\u5316
    // https://catlikecoding.com/unity/tutorials/flow/looking-through-water/
    // // \u5224\u65AD\u5F53\u524D\u7247\u5143\u662F\u5426\u4ECD\u7136\u5904\u4E8E\u6C34\u4E0B\uFF08\u907F\u514D\u6270\u52A8\u6C34\u4E0A\u56FE\u50CF\uFF09
    // bool isStillUnderwater = disturbedDepth > fragDepth + 1e-4;

    // \u6298\u5C04\u989C\u8272\u91C7\u6837\u903B\u8F91
    vec4 screenTex;
    realCoords = originRealCoords + distortion * smoothstep(0.0, 0.1, disturbedDepth - fragDepth) * 0.5;
    realCoords = alignUv(realCoords);
    screenTex = texture2D(tScreen, realCoords);

    // \u5F53\u524D\u6C34\u6DF1\u4F30\u8BA1
    float depth = texture2D(tDepth, realCoords).x;
    float waterDepth = calculateWaterDepth(realCoords, fragDepth);

    // \u6CE2\u5CF0\u6CE1\u6CAB\u5224\u65AD\uFF08z \u8D8B\u8FD1 1 \u8868\u793A\u7AD6\u76F4\uFF09
    float crestFoam = smoothstep(uCrestFoam, 1.0, originNormal.z);

    // \u83B7\u53D6\u6CE1\u6CAB\u566A\u58F0\u56FE
    vec4 foamNoise = texture2D(tFoamNoise, vUv * uFoamScale + uFoamSpeed * time);

    // \u8BA1\u7B97\u6CE1\u6CAB\u8FB9\u7F18\u7A0B\u5EA6
    float foamFactor = abs(foamNoise.r - clamp(waterDepth / uFoamSoftness, 0.0, 1.0));
    float foamEdge = smoothstep(0.0, 0.3, foamFactor);
    foamEdge = pow(foamEdge, 2.0);

    // \u5CB8\u8FB9\u6270\u52A8\u968F\u673A\u504F\u79FB
    float offset = (hash12(uvValue) - 0.5) * 0.2;
    float shallowMin = 0.1 + offset;
    float shallowMax = 0.3 + offset;
    float shallowFade = smoothstep(shallowMin, shallowMax, waterDepthOrigin);
    // float shallowFade = smoothstep(shallowMin, shallowMax, waterDepth);

    // \u6CE1\u6CAB\u89C6\u8DDD\u8870\u51CF\uFF08\u8D85\u8FC7 3000m \u6D88\u9664\uFF09
    // float foamDistanceFade = clamp(1.0 - cameraDistance / 3000.0, 0.0, 1.0);
    // \u89C6\u8DDD\u6E10\u9690\uFF0C\u4F7F\u7528 smoothstep \u66FF\u4EE3 clamp\uFF0C\u5E73\u6ED1\u8FC7\u6E21
    float foamDepthFade = smoothstep(uFoamDepthSoftness, 0.0, waterDepth);
    float foamDistanceFade = smoothstep(1000.0, 500.0, cameraDistance); // 3000m \u4EE5\u4E0A\u5B8C\u5168\u6D88\u5931\uFF0C2000m \u4EE5\u4E0B\u5B8C\u5168\u51FA\u73B0
    float foamAmount = foamEdge * foamDepthFade * shallowFade * foamDistanceFade;

    // \u8FDC\u8DDD\u79BB\u989C\u8272\u8870\u51CF
    float depthDistanceFade = clamp((1000.0 - cameraDistance) / 1000.0, 0.0, 1.0);

    // \u8BA1\u7B97\u989C\u8272\u6E10\u53D8\u548C\u900F\u660E\u5EA6\u6E10\u53D8\uFF08\u8FD1\u5CB8\u66F4\u6D45\u3001\u66F4\u900F\u660E\uFF09
    vec3 baseColor = mix(uWaterShallowColor, uWaterDeepColor, clamp(waterDepth / uDepthSoftness, 0.0, 1.0));
    vec3 shallowDeepColorFaded = mix(uWaterDeepColor, baseColor, depthDistanceFade);
    float baseAlpha = mix(shallowAlpha, deepAlpha, clamp(waterDepth / uDepthSoftness, 0.0, 1.0));
    float shallowDeepAlphaFaded = mix(deepAlpha, baseAlpha, depthDistanceFade);
    vec4 shallowDeepLerp = vec4(shallowDeepColorFaded, shallowDeepAlphaFaded);
    vec4 foamLerp = shallowDeepLerp;

    // \u6D6A\u5C16\u533A\u57DF\u6DF7\u5165\u84DD\u8272\uFF08\u6CE2\u5CF0\u589E\u5F3A\uFF09
    foamLerp.rgb = mix(uCrestFoamColor, foamLerp.rgb, crestFoam);
    vec4 waterColorFoam = foamLerp;
    vec4 waterColor = waterColorFoam;

    // Beer-Lambert \u6CD5\u5219\u505A\u6C34\u4E0B\u8870\u51CF
    vec3 beersCoeff = vec3(0.15, 0.35, 0.85);
    float depthDiff = calculateWaterDepthDiff(realCoords, fragDepth);
    vec3 attenuation = exp(-beersCoeff * depthDiff);
    waterColor *= vec4(attenuation, 1.0);

    // \u5CB8\u8FB9\u892A\u8272\u6743\u91CD
    float maxShoreFadeDepth = 3.0;
    float shoreFade = clamp(waterDepth / maxShoreFadeDepth, 0.0, 1.0);

    // \u6C34\u4E0B\u7126\u6563\u6548\u679C
    float causticsValue = caustics(uvValue / 10.0, time * .2);
    float causticsLevel = max(0.0, smoothstep(uDepthSoftness, 0.0, abs(waterDepth)));
    causticsLevel = pow(causticsLevel, 0.3);
    causticsValue *= causticsLevel;
    causticsValue = clamp(causticsValue, 0.0, 1.0) * 0.10;
    waterColor.rgb += vec3(causticsValue);

    // \u5149\u7167\u90E8\u5206\u8BA1\u7B97
    waterColorFoam = waterColor;
    vec3 diffuseLight = vec3(waterColorFoam.rgb);
    vec3 specularLight = vec3(0.0);
    vec3 reflectDir = reflect(-worldToEye, normalize((vec4(vNormal, 1.0) * viewMatrix).xyz));
    sunLight(surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);
    specularLight *= smoothstep(0.0, 0.1, dot(surfaceNormal, sunDirection)) * uSpecularStrength;

    #ifdef USE_ENVMAP
        vec3 reflectionSample = textureCubeUV(envMap, reflectDir, 0.0).xyz;
    #else
        vec3 reflectionSample = reflectionColor;
    #endif

    // \u83F2\u6D85\u5C14\u53CD\u5C04
    float theta = max(dot(eyeDirection, surfaceNormal), 0.0);
    float rf0 = 0.02;
    float t = clamp(1.0 - cameraDistance / 1000.0, 0.0, 1.0);
    t = smoothstep(0.0, 1.0, pow(t, 1.3));
    float exponent = mix(5.0, 50.0, t);
    float reflectance = rf0 + (1.0 - rf0) * pow((1.0 - theta), 5.0);

    float facing = max(0.0, dot(surfaceNormal, eyeDirection));
    float scatterFactor = mix(0.3, 1.0, pow(facing, 0.6));
    vec3 scatter = scatterFactor * waterColorFoam.xyz;

    vec2 uv = mirrorCoord.xy / mirrorCoord.w * 0.01;
    if(autoScale) {
        float scat = step_distance(cameraPosition.z) * 0.01;
        uv /= scat;
    }
    uv = uv * size + distortion;

    float r = pow(specularLight.r, 2.0);
    vec3 albedo = (sunColor * diffuseLight * 0.3 + scatter) + (reflectionSample * 0.9 + reflectionSample * specularLight) * r * max(0.5, reflectance);
    vec3 outgoingLight = albedo;

    // \u6700\u7EC8\u6C34\u4F53\u989C\u8272\u8F93\u51FA\uFF0C\u5305\u542B\u9AD8\u5149\u3001\u53CD\u5C04\u3001\u6563\u5C04
    vec4 composedWaterColor = vec4(outgoingLight, 1.0);

    // \u8FDC\u8DDD\u79BB\u81EA\u52A8\u5F3A\u5236\u4E0D\u900F\u660E\uFF0C\u907F\u514D\u6296\u52A8\uFF08\u6E10\u53D8\u66FF\u4EE3\u7A81\u53D8\uFF09
    float distFade = smoothstep(300.0, 2000.0, cameraDistance);
    // \u878D\u5408\u8FDB\u6700\u7EC8 shoreFade
    shoreFade = mix(shoreFade, 1.0, distFade);

    // \u6DF7\u5408\u80CC\u666F\u573A\u666F\u989C\u8272\uFF08screenTex\uFF09\u4E0E\u6C34\u4F53\u989C\u8272\uFF0C\u5CB8\u8FB9\u900F\u660E\u5EA6\u63A7\u5236
    composedWaterColor = mix(screenTex, composedWaterColor, waterColorFoam.a * shoreFade);

    // \u6DF7\u5408\u6CE1\u6CAB\u989C\u8272\uFF0C\u589E\u5F3A\u5CB8\u8FB9\u767D\u6CAB\u6548\u679C
    composedWaterColor = mix(composedWaterColor, vec4(1.0, 1.0, 1.0, shoreFade), foamAmount);

    composedWaterColor.rgb = clamp(composedWaterColor.rgb, 0.0, 100.0);
    gl_FragColor = vec4(composedWaterColor.rgb, 1.0);

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <logdepthbuf_fragment>
}
`;
function colorToArr4(o) {
  let i = convertSRGBColor(o).toArray(), e = i[3] === void 0 ? 1 : i[3];
  return [i[0], i[1], i[2], e];
}
function colorToRgbaArr(o) {
  let i = convertSRGBColor(o).toArray(), e = i[3] === void 0 ? 1 : i[3];
  return [i[0] * 255, i[1] * 255, i[2] * 255, e];
}
function normalizeColor(o) {
  const i = colorToArr4(o);
  return new Color(i[0], i[1], i[2]);
}
function convertSRGBColor(o) {
  if (!o)
    return new Color(1, 1, 1);
  if (o.isColor)
    return o;
  if (typeof o == "string") {
    const i = /^#([0-9A-Fa-f]{8})/, e = o.match(i);
    if (e) {
      const l = e[1], h = `#${l.slice(0, 6)}`, d = parseInt(l.slice(6, 8), 16) / 255, f = new Color(h);
      return new Vector4(f.r, f.g, f.b, d);
    }
    const r = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/, s = o.match(r);
    if (s) {
      const l = parseInt(s[1], 10), h = parseInt(s[2], 10), d = parseInt(s[3], 10), f = parseFloat(s[4]), p = `rgb(${l}, ${h}, ${d})`, m = new Color(p);
      return new Vector4(m.r, m.g, m.b, f);
    }
    const a = /hsla\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d.]+)\s*\)/, c = o.match(a);
    if (c) {
      const l = parseInt(c[1], 10) / 360, h = parseInt(c[2], 10) / 100, d = parseInt(c[3], 10) / 100, f = parseFloat(c[4]), p = new Color().setHSL(l, h, d);
      return new Vector4(p.r, p.g, p.b, f);
    }
  }
  return new Color(o);
}
function rgb565torgb(o) {
  const i = o >> 11, e = o >> 5 & 63, r = o & 31, s = Math.round(i / 31 * 255), a = Math.round(e / 63 * 255), c = Math.round(r / 31 * 255);
  return [s, a, c];
}
const colorUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  colorToArr4,
  colorToRgbaArr,
  normalizeColor,
  convertSRGBColor,
  rgb565torgb
}, Symbol.toStringTag, { value: "Module" })), emissiveUniforms = {
  mvt_emissive: {
    value: null
  },
  mvt_emissiveIntensity: {
    value: 1
  }
}, selectiveUniforms = {
  selectedObjectColor: {
    value: [1, 1, 0, 0.5]
  },
  selectedObjectIndex: {
    value: -1
  },
  selectedObjectColorMode: {
    value: 0
  }
}, keepSizeUniforms = {
  keepSize: {
    value: !1
  },
  zoomUnits: {
    value: 1
  }
}, defineMaterialNormalProperties = (o, i = []) => {
  for (let e of i)
    Object.defineProperty(o, e, {
      get: function() {
        return this.uniforms[e].value;
      },
      set: function(r) {
        this.uniforms[e].value = r;
      }
    });
}, defineMaterialColorProperties = (o, i = []) => {
  for (let e of i)
    Object.defineProperty(o, e, {
      get: function() {
        return this.uniforms[e].value;
      },
      set: function(r) {
        this.uniforms[e].value = normalizeColor(r);
      }
    });
}, defineMaterialAliasProperties = (o, i = []) => {
  for (let [e, r, s] of i)
    Object.defineProperty(o, e, {
      get: function() {
        return this.uniforms[r].value;
      },
      set: function(a) {
        this.uniforms[r].value = s ? s(a) : a;
      }
    });
}, defineMaterialBoolDefineProperties = (o, i = []) => {
  for (let [e, r] of i)
    Object.defineProperty(o, e, {
      get: function() {
        return !!this.defines[r];
      },
      set: function(s) {
        this[e] !== s && (s ? this.defines[r] = !0 : delete this.defines[r], this.needsUpdate = !0);
      }
    });
}, defineMaterialSelectiveProperties = (o) => {
  Object.defineProperties(o, {
    selectedObjectColor: {
      get: function() {
        return this.uniforms.selectedObjectColor.value;
      },
      set: function(i) {
        this.uniforms.selectedObjectColor.value = i;
      }
    },
    selectedObjectColorMode: {
      get: function() {
        return this.uniforms.selectedObjectColorMode.value;
      },
      set: function(i) {
        this.uniforms.selectedObjectColorMode.value = i;
      }
    },
    selectedObjectIndex: {
      get: function() {
        return this.uniforms.selectedObjectIndex.value;
      },
      set: function(i) {
        this.uniforms.selectedObjectIndex.value = i;
      }
    },
    selective: {
      get: function() {
        return !!this.defines.MVT_ENABLE_SELECTIVE;
      },
      set: function(i) {
        this.selective !== i && (i ? this.defines.MVT_ENABLE_SELECTIVE = !0 : delete this.defines.MVT_ENABLE_SELECTIVE, this.needsUpdate = !0);
      }
    }
  });
}, defineMaterialKeepSizeProperties = (o) => {
  Object.defineProperties(o, {
    keepSize: {
      get: function() {
        return this.uniforms.keepSize.value;
      },
      set: function(i) {
        this.uniforms.keepSize.value = i;
      }
    },
    zoomUnits: {
      get: function() {
        return this.uniforms.zoomUnits.value;
      },
      set: function(i) {
        this.uniforms.zoomUnits.value = i;
      }
    },
    zoomUnitsUniform: {
      get: function() {
        return this.uniforms.zoomUnits;
      },
      set: function(i) {
        this.uniforms.zoomUnits = i;
      }
    }
  });
}, defineMaterialEmissiveProperties = (o) => {
  Object.defineProperties(o, {
    emissiveEnabled: {
      get: function() {
        return this.defines.MVT_EMISSIVE_UNIFORM || !1;
      },
      set: function(i) {
        i ? this.defines.MVT_EMISSIVE_UNIFORM = !0 : delete this.defines.MVT_EMISSIVE_UNIFORM;
      }
    },
    emissive: {
      get: function() {
        return this.uniforms.mvt_emissive.value;
      },
      set: function(i) {
        i ? this.defines.MVT_EMISSIVE_COLOR = !0 : delete this.defines.MVT_EMISSIVE_COLOR, this.uniforms.mvt_emissive.value = i;
      }
    },
    emissiveIntensity: {
      get: function() {
        return this.uniforms.mvt_emissiveIntensity.value;
      },
      set: function(i) {
        this.uniforms.mvt_emissiveIntensity.value = i;
      }
    }
  });
}, generateCubeUVSize = (o) => {
  const i = o && o.source && o.source.data && o.source.data.height || null;
  if (i === null)
    return null;
  const e = Math.log2(i) - 2, r = 1 / i;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: r, maxMip: e };
};
class CommonShaderMaterial extends ShaderMaterial {
  constructor(e) {
    super();
    _(this, "isCommonShaderMaterial", !0);
    _(this, "setCommonUniforms", (e) => {
      for (const r of Object.keys(e))
        this.uniforms[r] = e[r];
    });
    this.setValues(e);
  }
}
const textureLoader$b = new TextureLoader(), foamTexture = textureLoader$b.load(getAssetUrl("assets/textures/water/foam_noise.webp"));
foamTexture.wrapS = foamTexture.wrapT = RepeatWrapping;
let normalMaps = {}, waterBedMaps = {};
const uniforms$t = UniformsUtils.merge([
  UniformsLib.fog,
  UniformsLib.lights,
  {
    envMap: { value: null },
    tDepth: { value: null },
    tScreen: { value: null },
    uCameraNear: { value: 0 },
    uOffsetScale: { value: 1 },
    uDepthSoftness: { value: 5 },
    uFoamDepthSoftness: { value: 1 },
    uFoamSoftness: { value: 3 },
    uFoamScale: { value: 100 },
    uFoamSpeed: { value: 0.05 },
    uCrestFoam: { value: 0.7 },
    uSpecularStrength: { value: 1.5 },
    uCrestFoamColor: { value: new Color(0.3, 0.3, 0.6) },
    viewInverseMatrix: { value: new Matrix4() },
    tFoamNoise: { value: foamTexture },
    uCameraFar: { value: 0 },
    uWaterShallowColor: { value: new Color(1 / 255, 46 * 0.5 / 255, 120 * 0.5 / 255) },
    uWaterDeepColor: { value: new Color(1 / 255, 46 / 255, 120 / 255) },
    projectionInverseMatrix: { value: new Matrix4() },
    alpha: { value: 1 },
    time: { value: 0 },
    autoScale: { value: !1 },
    size: { value: 1 },
    distortionScale: { value: 5 },
    sunColor: { value: new Color(16777215) },
    sunDirection: { value: new Vector3$1(0.70707, 0.70707, 0) },
    eye: { value: new Vector3$1() },
    waterColor: { value: new Color(7695) },
    reflectionColor: { value: new Color(7695) },
    finalColor: { value: new Color(12573183) },
    normalMap: { value: null },
    waterBedMap: { value: null },
    mvt_normalMatrix: { value: new Matrix3() },
    isEmissive: { value: !1 },
    uUvScale: { value: 1e3 }
  }
]), Ke = class extends CommonShaderMaterial {
  constructor(e = {}) {
    super();
    _(this, "_timeScaleFactor", 1e-3);
    _(this, "_style", "");
    _(this, "_useEnvMap", !0);
    _(this, "_waterColor", [1 / 255, 46 / 255, 120 / 255]);
    _(this, "_foamSpeed", 0.05);
    _(this, "_offsetScale", 1);
    _(this, "_depthSoftness", 5);
    _(this, "_foamDepthSoftness", 1);
    _(this, "_foamSoftness", 3);
    _(this, "_foamScale", 100);
    _(this, "_crestFoam", 0.7);
    _(this, "_crestFoamColor", [0.3, 0.3, 0.6]);
    _(this, "_specularStrength", 1.5);
    _(this, "_uvScale", 1e3);
    this.type = "WaterMaterial", this.vertexShader = vertexShader$u, this.fragmentShader = fragmentShader$w, this.isWaterMaterial = !0, this.lights = !0, this.transparent = !0, this.fog = !1, this.style = "lake", Object.assign(this.uniforms, UniformsUtils.clone(uniforms$t)), this.waterColor = defaultValue$1(e.waterColor, this._waterColor), this.foamSpeed = defaultValue$1(e.foamSpeed, this._foamSpeed), this.offsetScale = defaultValue$1(e.offsetScale, this._offsetScale), this.depthSoftness = defaultValue$1(e.depthSoftness, this._depthSoftness), this.foamDepthSoftness = defaultValue$1(e.foamDepthSoftness, this._foamDepthSoftness), this.foamSoftness = defaultValue$1(e.foamSoftness, this._foamSoftness), this.foamScale = defaultValue$1(e.foamScale, this._foamScale), this.crestFoam = defaultValue$1(e.crestFoam, this._crestFoam), this.crestFoamColor = defaultValue$1(e.crestFoamColor, this._crestFoamColor), this.specularStrength = defaultValue$1(e.specularStrength, this._specularStrength), this.uvScale = defaultValue$1(e.uvScale, this._uvScale), this.defines = {
      CUBEUV_TEXEL_WIDTH: 3255208333333333e-19,
      CUBEUV_TEXEL_HEIGHT: 244140625e-12,
      CUBEUV_MAX_MIP: "10.0"
    }, defineMaterialNormalProperties(this, [
      "sunColor",
      "reflectionColor",
      "finalColor",
      "autoScale",
      "size",
      "alpha",
      "distortionScale",
      "isEmissive"
    ]), Object.defineProperties(this, {
      waterBedMap: {
        get: function() {
          return this.uniforms.waterBedMap.value;
        },
        set: function(r) {
          r.wrapS = r.wrapT = RepeatWrapping, this.uniforms.waterBedMap.value && this.uniforms.waterBedMap.value.dispose(), this.uniforms.waterBedMap.value = r, this.needsUpdate = !0;
        }
      },
      normalMap: {
        get: function() {
          return this.uniforms.normalMap.value;
        },
        set: function(r) {
          r.wrapS = r.wrapT = RepeatWrapping, this.uniforms.normalMap.value && this.uniforms.normalMap.value.dispose(), this.uniforms.normalMap.value = r, this.needsUpdate = !0;
        }
      }
    }), this.setValues(e), Ke.instances.add(this);
  }
  onBeforeSceneRender(e, r, s, a) {
    this.uniforms.eye.value.copy(s.position);
    const c = e.rendering.opaquePostprocessings;
    if (this.uniforms.tScreen.value = c.texture, this.uniforms.tDepth.value = c.depthTexture, this.uniforms.uCameraNear.value = s.near, this.uniforms.uCameraFar.value = s.far, this.uniforms.time.value = e.rendering.uniforms.elapsedTime.value * this._timeScaleFactor, this.uniforms.projectionInverseMatrix.value.copy(s.projectionMatrixInverse), this.uniforms.viewInverseMatrix.value.copy(s.matrixWorld), this.uniforms.envMap.value !== r.environment) {
      this.uniforms.envMap.value = r.environment;
      const h = generateCubeUVSize(r.environment);
      h && (this.defines.CUBEUV_TEXEL_WIDTH = h.texelWidth, this.defines.CUBEUV_TEXEL_HEIGHT = h.texelHeight, this.defines.CUBEUV_MAX_MIP = h.maxMip + ".0"), r.environment && this._useEnvMap ? this.defines.USE_ENVMAP = !0 : delete this.defines.USE_ENVMAP;
    }
    this.uniforms.mvt_normalMatrix.value.getNormalMatrix(s.matrixWorld), this.setCommonUniforms(e.rendering.uniforms);
    const l = e.rendering.sky;
    l && this.uniforms.sunDirection.value.copy(l.sunDirection);
  }
  get useEnvMap() {
    return this._useEnvMap;
  }
  set useEnvMap(e) {
    this._useEnvMap = e;
  }
  get timeScaleFactor() {
    return this._timeScaleFactor;
  }
  set timeScaleFactor(e) {
    this._timeScaleFactor = e;
  }
  get waterColor() {
    return this._waterColor;
  }
  set waterColor(e) {
    this._waterColor = e, this.uniforms.uWaterDeepColor.value = new Color(e[0], e[1], e[2]), this.uniforms.uWaterShallowColor.value = new Color(e[0] / 2, e[1] / 2, e[2] / 2);
  }
  get foamSpeed() {
    return this._foamSpeed;
  }
  set foamSpeed(e) {
    this._foamSpeed = e, this.uniforms.uFoamSpeed.value = e;
  }
  get offsetScale() {
    return this._offsetScale;
  }
  set offsetScale(e) {
    this._offsetScale = e, this.uniforms.uOffsetScale.value = e;
  }
  get depthSoftness() {
    return this._depthSoftness;
  }
  set depthSoftness(e) {
    this._depthSoftness = e, this.uniforms.uDepthSoftness.value = e;
  }
  get foamDepthSoftness() {
    return this._foamDepthSoftness;
  }
  set foamDepthSoftness(e) {
    this._foamDepthSoftness = e, this.uniforms.uFoamDepthSoftness.value = e;
  }
  get foamSoftness() {
    return this._foamSoftness;
  }
  set foamSoftness(e) {
    this._foamSoftness = e, this.uniforms.uFoamSoftness.value = e;
  }
  get foamScale() {
    return this._foamScale;
  }
  set foamScale(e) {
    this._foamScale = e, this.uniforms.uFoamScale.value = e;
  }
  get crestFoam() {
    return this._crestFoam;
  }
  set crestFoam(e) {
    this._crestFoam = e, this.uniforms.uCrestFoam.value = e;
  }
  get crestFoamColor() {
    return this._crestFoamColor;
  }
  set crestFoamColor(e) {
    this._crestFoamColor = e, this.uniforms.uCrestFoamColor.value = new Color(e[0], e[1], e[2]);
  }
  get specularStrength() {
    return this._specularStrength;
  }
  set specularStrength(e) {
    this._specularStrength = e, this.uniforms.uSpecularStrength.value = e;
  }
  get style() {
    return this._style;
  }
  set style(e) {
    e !== this._style && (normalMaps[e] && waterBedMaps[e] ? (this.normalMap = normalMaps[e], this._style = e) : (e === "river" || e === "lake" || e === "ocean") && (textureLoader$b.load(getAssetUrl(`assets/textures/water/${e}_normal.webp`), (r) => {
      this.normalMap = r, normalMaps[e] = r;
    }), this._style = e));
  }
  get uvScale() {
    return this._uvScale;
  }
  set uvScale(e) {
    this._uvScale = e, this.uniforms.uUvScale.value = e;
  }
  dispose() {
    Ke.instances.delete(this);
    let e = [
      "envMap",
      "normalMap",
      "waterBedMap"
    ];
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      this.uniforms[s] && this.uniforms[s].value && this.uniforms[s].value.dispose();
    }
    normalMaps = {}, waterBedMaps = {}, super.dispose();
  }
  static hasActiveInstances() {
    return Ke.instances.size > 0;
  }
  static getActiveInstances() {
    return new Set(Ke.instances);
  }
};
let WaterMaterial = Ke;
_(WaterMaterial, "instances", /* @__PURE__ */ new Set());
class OpaquePostprocessings extends Postprocessings {
  constructor(e) {
    super(e);
    _(this, "_enableOpaqueCopy", !1);
    _(this, "_handleMeshBeforeRender", (e, r, s) => {
      if (this._rendering.renderState.stage !== RENDER_STAGE_SCENE || this._validCount <= 0)
        return;
      const c = this._rendering.sharedFullScreenRenderTargets;
      let l = e.getRenderTarget();
      const h = l;
      this._updateMultisampleRenderTarget(e, l);
      let d = c.getAvailableRenderTarget();
      const f = d;
      let p = null;
      const m = this._postprocessings;
      let y = this._validCount - 1, x = 0;
      for (let v = 0, S = m.length; v < S; v++) {
        const E = m[v];
        if (E.enabled) {
          if (E.render(e, d, l), y !== x && E.needsSwap)
            if (l === h)
              l = d, d = c.getAvailableRenderTarget(), p = d;
            else {
              let b = l;
              l = d, d = b;
            }
          x++;
        }
      }
      this._mesh.material.uniforms.tDiffuse.value = d.texture, c.releaseRenderTarget(f), p && c.releaseRenderTarget(p), e.setRenderTarget(h);
    });
    this._postprocessings = [], this._testRenderTarget = new WebGLRenderTarget(1, 1, {}), this._testScene = new Mesh(new BoxGeometry(1, 1, 1), new MeshBasicMaterial({})), this._testScene.frustumCulled = !1, this._opaqueCopyPass = new OpaqueCopyPass(), this.add(this._opaqueCopyPass);
  }
  beginFrame() {
    const e = WaterMaterial.hasActiveInstances();
    if (this._opaqueCopyPass.enabled = this._enableOpaqueCopy || e, this._updatePostprocessings(), this._rendering, this._validCount > 0) {
      if (!this._mesh) {
        const r = this._geometry = new BufferGeometry();
        r.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), r.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
        const s = this._material = new ShaderMaterial({
          depthTest: !1,
          name: "OpaquePostprocessingsCopy",
          uniforms: {
            tDiffuse: { value: null }
          },
          vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
          fragmentShader: `
                        uniform sampler2D tDiffuse;
                        varying vec2 vUv;

                        void main() {
                            vec4 color = texture2D(tDiffuse, vUv);
                            gl_FragColor = color;
                            // gl_FragColor = vec4(1.0, .0, .0, 1.0);
                        }
                    `
        }), a = this._mesh = new Mesh(r, s);
        a.isFSQuad = !0, a.frustumCulled = !1, a.renderOrder = 1e9, a.onBeforeRender = this._handleMeshBeforeRender, this._rendering.add(a);
      }
      this._mesh.visible = !0;
    } else
      this._mesh && (this._mesh.visible = !1);
  }
  add(e) {
    super.add(e);
    const r = e.material;
    r.defines ? r.defines.USE_OPAQUE_POST_STAGE = !0 : r.defines = {
      USE_OPAQUE_POST_STAGE: !0
    }, r.needsUpdate = !0;
  }
  _useMultisampledRTT(e, r) {
    const s = e.properties, a = e.extensions, l = e.capabilities.isWebGL2, h = s.get(r);
    return l && r.samples > 0 && a.has("WEBGL_multisampled_render_to_texture") === !0 && h.__useRenderToTexture !== !1;
  }
  _updateMultisampleRenderTarget(e, r) {
    if (e.capabilities.isWebGL2 && r.samples > 0 && this._useMultisampledRTT(e, r) === !1) {
      const c = e.getContext(), l = e.state, h = e.properties, d = r.isWebGLMultipleRenderTargets ? r.texture : [r.texture], f = r.width, p = r.height;
      let m = c.COLOR_BUFFER_BIT;
      const y = [], x = r.stencilBuffer ? c.DEPTH_STENCIL_ATTACHMENT : c.DEPTH_ATTACHMENT, v = h.get(r), S = r.isWebGLMultipleRenderTargets === !0;
      if (S)
        for (let E = 0; E < d.length; E++)
          l.bindFramebuffer(c.FRAMEBUFFER, v.__webglMultisampledFramebuffer), c.framebufferRenderbuffer(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0 + E, c.RENDERBUFFER, null), l.bindFramebuffer(c.FRAMEBUFFER, v.__webglFramebuffer), c.framebufferTexture2D(c.DRAW_FRAMEBUFFER, c.COLOR_ATTACHMENT0 + E, c.TEXTURE_2D, null, 0);
      l.bindFramebuffer(c.READ_FRAMEBUFFER, v.__webglMultisampledFramebuffer), l.bindFramebuffer(c.DRAW_FRAMEBUFFER, v.__webglFramebuffer);
      for (let E = 0; E < d.length; E++) {
        y.push(c.COLOR_ATTACHMENT0 + E), r.depthBuffer && y.push(x);
        const b = v.__ignoreDepthValues !== void 0 ? v.__ignoreDepthValues : !1;
        if (b === !1 && r.depthBuffer && (m |= c.DEPTH_BUFFER_BIT), S && c.framebufferRenderbuffer(
          c.READ_FRAMEBUFFER,
          c.COLOR_ATTACHMENT0,
          c.RENDERBUFFER,
          v.__webglColorRenderbuffer[E]
        ), b === !0 && (c.invalidateFramebuffer(c.READ_FRAMEBUFFER, [x]), c.invalidateFramebuffer(c.DRAW_FRAMEBUFFER, [x])), S) {
          const w = h.get(d[E]).__webglTexture;
          c.framebufferTexture2D(c.DRAW_FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, w, 0);
        }
        c.blitFramebuffer(0, 0, f, p, 0, 0, f, p, m, c.NEAREST);
      }
      if (l.bindFramebuffer(c.READ_FRAMEBUFFER, null), l.bindFramebuffer(c.DRAW_FRAMEBUFFER, null), S)
        for (let E = 0; E < d.length; E++) {
          l.bindFramebuffer(c.FRAMEBUFFER, v.__webglMultisampledFramebuffer), c.framebufferRenderbuffer(
            c.FRAMEBUFFER,
            c.COLOR_ATTACHMENT0 + E,
            c.RENDERBUFFER,
            v.__webglColorRenderbuffer[E]
          );
          const b = h.get(d[E]).__webglTexture;
          l.bindFramebuffer(c.FRAMEBUFFER, v.__webglFramebuffer), c.framebufferTexture2D(
            c.DRAW_FRAMEBUFFER,
            c.COLOR_ATTACHMENT0 + E,
            c.TEXTURE_2D,
            b,
            0
          );
        }
      l.bindFramebuffer(c.DRAW_FRAMEBUFFER, v.__webglMultisampledFramebuffer);
    }
  }
  _updatePostprocessings() {
    let e = 0;
    for (let r = 0, s = this._postprocessings.length; r < s; r++)
      this._postprocessings[r].enabled && e++;
    this._validCount = e;
  }
  render() {
  }
  endFrame() {
  }
  setSize(e, r) {
    for (let s = 0; s < this.postprocessings.length; s++)
      this.postprocessings[s].setSize(e * window.devicePixelRatio, r * window.devicePixelRatio);
  }
  show() {
    this._mesh && (this._mesh.visible = !0);
  }
  hide() {
    this._mesh && (this._mesh.visible = !1);
  }
  isInStableRenderState() {
    return !0;
  }
  get enableOpaqueCopy() {
    return this._enableOpaqueCopy;
  }
  set enableOpaqueCopy(e) {
    this._enableOpaqueCopy !== e && (this._enableOpaqueCopy = e);
  }
  get texture() {
    return this._opaqueCopyPass.texture;
  }
  get depthTexture() {
    return this._opaqueCopyPass.depthTexture;
  }
  dispose() {
    this._renderTarget && (this._renderTarget.dispose(), this._renderTarget = null), this._mesh && (this._rendering.remove(this._mesh), this._mesh.geometry.dispose(), this._mesh.material.dispose(), this._mesh = null);
  }
}
const LuminosityHighPassShader = {
  name: "LuminosityHighPassShader",
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new Color(0) },
    defaultOpacity: { value: 0 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
};
class UnrealBloomPass extends Pass {
  constructor(i, e = 1, r, s) {
    super(), this.strength = e, this.radius = r, this.threshold = s, this.resolution = i !== void 0 ? new Vector2$1(i.x, i.y) : new Vector2$1(256, 256), this.clearColor = new Color(0, 0, 0), this.needsSwap = !1, this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
    let a = Math.round(this.resolution.x / 2), c = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new WebGLRenderTarget(a, c, { type: HalfFloatType }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
    for (let f = 0; f < this.nMips; f++) {
      const p = new WebGLRenderTarget(a, c, { type: HalfFloatType });
      p.texture.name = "UnrealBloomPass.h" + f, p.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(p);
      const m = new WebGLRenderTarget(a, c, { type: HalfFloatType });
      m.texture.name = "UnrealBloomPass.v" + f, m.texture.generateMipmaps = !1, this.renderTargetsVertical.push(m), a = Math.round(a / 2), c = Math.round(c / 2);
    }
    const l = LuminosityHighPassShader;
    this.highPassUniforms = UniformsUtils.clone(l.uniforms), this.highPassUniforms.luminosityThreshold.value = s, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new ShaderMaterial({
      uniforms: this.highPassUniforms,
      vertexShader: l.vertexShader,
      fragmentShader: l.fragmentShader
    }), this.separableBlurMaterials = [];
    const h = [3, 5, 7, 9, 11];
    a = Math.round(this.resolution.x / 2), c = Math.round(this.resolution.y / 2);
    for (let f = 0; f < this.nMips; f++)
      this.separableBlurMaterials.push(this._getSeparableBlurMaterial(h[f])), this.separableBlurMaterials[f].uniforms.invSize.value = new Vector2$1(1 / a, 1 / c), a = Math.round(a / 2), c = Math.round(c / 2);
    this.compositeMaterial = this._getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = e, this.compositeMaterial.uniforms.bloomRadius.value = 0.1;
    const d = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms.bloomFactors.value = d, this.bloomTintColors = [new Vector3$1(1, 1, 1), new Vector3$1(1, 1, 1), new Vector3$1(1, 1, 1), new Vector3$1(1, 1, 1), new Vector3$1(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, this.copyUniforms = UniformsUtils.clone(CopyShader.uniforms), this.blendMaterial = new ShaderMaterial({
      uniforms: this.copyUniforms,
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      blending: AdditiveBlending,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), this._oldClearColor = new Color(), this._oldClearAlpha = 1, this._basic = new MeshBasicMaterial(), this._fsQuad = new FullScreenQuad(null);
  }
  dispose() {
    for (let i = 0; i < this.renderTargetsHorizontal.length; i++)
      this.renderTargetsHorizontal[i].dispose();
    for (let i = 0; i < this.renderTargetsVertical.length; i++)
      this.renderTargetsVertical[i].dispose();
    this.renderTargetBright.dispose();
    for (let i = 0; i < this.separableBlurMaterials.length; i++)
      this.separableBlurMaterials[i].dispose();
    this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this._basic.dispose(), this._fsQuad.dispose();
  }
  setSize(i, e) {
    let r = Math.round(i / 2), s = Math.round(e / 2);
    this.renderTargetBright.setSize(r, s);
    for (let a = 0; a < this.nMips; a++)
      this.renderTargetsHorizontal[a].setSize(r, s), this.renderTargetsVertical[a].setSize(r, s), this.separableBlurMaterials[a].uniforms.invSize.value = new Vector2$1(1 / r, 1 / s), r = Math.round(r / 2), s = Math.round(s / 2);
  }
  render(i, e, r, s, a) {
    i.getClearColor(this._oldClearColor), this._oldClearAlpha = i.getClearAlpha();
    const c = i.autoClear;
    i.autoClear = !1, i.setClearColor(this.clearColor, 0), a && i.state.buffers.stencil.setTest(!1), this.renderToScreen && (this._fsQuad.material = this._basic, this._basic.map = r.texture, i.setRenderTarget(null), i.clear(), this._fsQuad.render(i)), this.highPassUniforms.tDiffuse.value = r.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this._fsQuad.material = this.materialHighPassFilter, i.setRenderTarget(this.renderTargetBright), i.clear(), this._fsQuad.render(i);
    let l = this.renderTargetBright;
    for (let h = 0; h < this.nMips; h++)
      this._fsQuad.material = this.separableBlurMaterials[h], this.separableBlurMaterials[h].uniforms.colorTexture.value = l.texture, this.separableBlurMaterials[h].uniforms.direction.value = UnrealBloomPass.BlurDirectionX, i.setRenderTarget(this.renderTargetsHorizontal[h]), i.clear(), this._fsQuad.render(i), this.separableBlurMaterials[h].uniforms.colorTexture.value = this.renderTargetsHorizontal[h].texture, this.separableBlurMaterials[h].uniforms.direction.value = UnrealBloomPass.BlurDirectionY, i.setRenderTarget(this.renderTargetsVertical[h]), i.clear(), this._fsQuad.render(i), l = this.renderTargetsVertical[h];
    this._fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, i.setRenderTarget(this.renderTargetsHorizontal[0]), i.clear(), this._fsQuad.render(i), this._fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, a && i.state.buffers.stencil.setTest(!0), this.renderToScreen ? (i.setRenderTarget(null), this._fsQuad.render(i)) : (i.setRenderTarget(r), this._fsQuad.render(i)), i.setClearColor(this._oldClearColor, this._oldClearAlpha), i.autoClear = c;
  }
  _getSeparableBlurMaterial(i) {
    const e = [];
    for (let r = 0; r < i; r++)
      e.push(0.39894 * Math.exp(-0.5 * r * r / (i * i)) / i);
    return new ShaderMaterial({
      defines: {
        KERNEL_RADIUS: i
      },
      uniforms: {
        colorTexture: { value: null },
        invSize: { value: new Vector2$1(0.5, 0.5) },
        direction: { value: new Vector2$1(0.5, 0.5) },
        gaussianCoefficients: { value: e }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
    });
  }
  _getCompositeMaterial(i) {
    return new ShaderMaterial({
      defines: {
        NUM_MIPS: i
      },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
    });
  }
}
UnrealBloomPass.BlurDirectionX = new Vector2$1(1, 0);
UnrealBloomPass.BlurDirectionY = new Vector2$1(0, 1);
class Feature {
  constructor(i, e = {}) {
    _(this, "_enabled", !1);
    _(this, "name", "");
    _(this, "needsShaderKey", !1);
    this._options = e, this._enabled = !!e.enabled, this._rendering = i;
  }
  beginFrame() {
  }
  render() {
  }
  endFrame() {
  }
  getCurrentShaderKey() {
    return "";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(i) {
    this._enabled = !!i;
  }
}
class FeatureBloom extends Feature {
  constructor() {
    super(...arguments);
    _(this, "name", "bloom");
    _(this, "_lastEnabled", !1);
    _(this, "_strength", 0.1);
    _(this, "_threshold", 1);
    _(this, "_radius", 0);
    _(this, "needsFloatRenderTarget", !0);
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
    this.enabled;
  }
  _init() {
    const e = this._rendering, r = e.resolution, s = e.main, a = e.pixelRatio;
    this._bloomRenderTarget = new WebGLRenderTarget(
      r.x * a,
      r.y * a,
      {
        type: HalfFloatType
      }
    ), this._bloomRenderTarget.name = "bloomRenderTarget";
    const c = new Vector2$1();
    c.set(r.x * a, r.y * a);
    const l = this._bloomRenderPass = new UnrealBloomPass(c, this._strength, this._radius, this._threshold);
    l.renderOrder = 70, s.postprocessings.add(l), s.useMRT;
  }
  afterRender() {
    if (this.enabled) {
      const e = this._rendering;
      e.main, e.stats;
    }
  }
  getCurrentUsedTextures() {
    if (this.enabled)
      return [this._bloomRenderTarget.texture];
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    this._rendering.stats, this._bloomRenderPass && (this._rendering.main.postprocessings.remove(this._bloomRenderPass), this._bloomRenderPass.dispose(), this._bloomRenderPass = null);
  }
  get strength() {
    return this._strength;
  }
  set strength(e) {
    this._strength = e, this._bloomRenderPass && (this._bloomRenderPass.strength = e);
  }
  get radius() {
    return this._radius;
  }
  set radius(e) {
    this._radius = e, this._bloomRenderPass && (this._bloomRenderPass.radius = e);
  }
  get threshold() {
    return this._threshold;
  }
  set threshold(e) {
    this._threshold = e, this._bloomRenderPass && (this._bloomRenderPass.threshold = e);
  }
}
const fragmentShader$v = `
struct TextureInfo {
    vec2 offset;
    vec2 scale;
};
uniform sampler2D maps[MVT_TEXTURE_COUNT];
uniform sampler2D tDiffuse;
varying vec2 vUv;

uniform TextureInfo textureInfos[MVT_TEXTURE_COUNT];

void addTextureColor(sampler2D map, TextureInfo textureInfo) {
    vec2 transformedUv = (vUv - textureInfo.offset) * textureInfo.scale;
    if (transformedUv.x >= 0.0 && transformedUv.x <= 1.0 && transformedUv.y >= 0.0 && transformedUv.y <= 1.0) {
        // gl_FragColor += texture2D(map, transformedUv);
        vec4 sampleColor = texture2D(map, transformedUv);
        gl_FragColor.rgb = mix(sampleColor.rgb, gl_FragColor.rgb, 1.0 - sampleColor.a);
        gl_FragColor.a += sampleColor.a;
        // gl_FragColor = sampleColor + gl_FragColor;
    }
}
void main() {

    gl_FragColor = texture2D(tDiffuse, vUv);
    // gl_FragColor = vec4(0.5, 0, 0, 0.5);
    #if MVT_TEXTURE_COUNT > 0
        addTextureColor(maps[0], textureInfos[0]);
    #endif

    #if MVT_TEXTURE_COUNT > 1
        addTextureColor(maps[1], textureInfos[1]);
    #endif

    #if MVT_TEXTURE_COUNT > 2
        addTextureColor(maps[2], textureInfos[2]);
    #endif

    #if MVT_TEXTURE_COUNT > 3
        addTextureColor(maps[3], textureInfos[3]);
    #endif

    #if MVT_TEXTURE_COUNT > 4
        addTextureColor(maps[4], textureInfos[4]);
    #endif

    #if MVT_TEXTURE_COUNT > 5
        addTextureColor(maps[5], textureInfos[5]);
    #endif

    #if MVT_TEXTURE_COUNT > 6
        addTextureColor(maps[6], textureInfos[6]);
    #endif

    #if MVT_TEXTURE_COUNT > 7
        addTextureColor(maps[7], textureInfos[7]);
    #endif

    #if MVT_TEXTURE_COUNT > 8
        addTextureColor(maps[8], textureInfos[8]);
    #endif
}
`;
class AddTexturePass extends Pass {
  constructor() {
    super();
    const i = CopyShader;
    this.uniforms = {
      tDiffuse: { value: null },
      textureInfos: { value: null },
      maps: { value: null }
    }, this._lastTextureCount = 1, this.material = new ShaderMaterial({
      defines: {
        MVT_TEXTURE_COUNT: 1
      },
      uniforms: this.uniforms,
      vertexShader: i.vertexShader,
      fragmentShader: fragmentShader$v,
      depthTest: !1,
      depthWrite: !1
    }), this.needsSwap = !0, this.fsQuad = new FullScreenQuad(null);
  }
  render(i, e, r) {
    const s = i.autoClear;
    i.autoClear = !1, this.fsQuad.material = this.material, this.material.uniforms.tDiffuse.value = r.texture, i.setRenderTarget(this.renderToScreen ? null : e), i.clear(), this.fsQuad.render(i), i.autoClear = s;
  }
  updateTextures(i, e) {
    if (i.length !== e.length) {
      console.warn("textures and infos length must be equal");
      return;
    }
    this.uniforms.maps.value = i, this.uniforms.textureInfos.value = e, this._lastTextureCount !== e.length && (this.material.defines.MVT_TEXTURE_COUNT = e.length, this.material.needsUpdate = !0, this._lastTextureCount = e.length);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class FeatureStats extends Feature {
  constructor() {
    super(...arguments);
    _(this, "name", "stats");
    _(this, "_lastEnabled", !1);
    _(this, "_canvasWidth", 600);
    _(this, "_canvasHeight", 320);
    _(this, "_canvasPadding", 10);
    _(this, "_lastUpdateTime", 0);
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
    this.enabled && this._updateTexture();
  }
  _init() {
    const e = this._rendering, r = e.pixelRatio, s = this._canvas = document.createElement("canvas");
    this._context = s.getContext("2d"), s.width = this._canvasWidth * r, s.height = this._canvasHeight * r, this._texture = new CanvasTexture(s), this._texture.generateMipmaps = !1;
    const a = this._renderPass = new AddTexturePass();
    a.renderOrder = 10100, a.material.uniforms.textureInfos.value = [{
      offset: [0.2, 0.2],
      scale: [2.5, 2.5]
    }], a.material.uniforms.maps.value = [this._texture], e.main.postprocessings.add(this._renderPass);
  }
  _updateTexture() {
    const e = this._rendering, r = e.renderState;
    if (r.time - this._lastUpdateTime < 100)
      return;
    this._lastUpdateTime = r.time;
    const s = e.renderer, a = e.stats, c = this._context, l = e.pixelRatio;
    a.beginTimeStatsItem("updateStatsTexture"), c.save(), c.scale(l, l), c.clearRect(0, 0, this._canvasWidth, this._canvasHeight), c.fillStyle = "rgba(0, 0, 0, .6)", c.fillRect(0, 0, this._canvasWidth, this._canvasHeight), c.font = "14px sans-serif", c.textAlign = "right", c.fillStyle = "rgb(220,220,220)";
    const h = a.getSortedTimeStatsItems(), d = Math.min(h.length, 10);
    let f = this._canvasPadding + 100, p = this._canvasPadding + 20;
    c.fillText("average", f + 150, p), c.fillText("lastValue", f + 230, p), c.fillText("count", f + 310, p), c.fillText("total", f + 450, p), c.strokeStyle = "rgb(130,130,130)";
    for (let E = 0; E < d; E++) {
      f = this._canvasPadding + 100, p = this._canvasPadding + 50 + E * 20;
      const b = h[E];
      c.fillText(b.name, f + 50, p), c.fillText(b.average.toFixed(2), f + 150, p), c.fillText(b.lastValue.toFixed(2), f + 230, p), c.fillText(b.count.toFixed(0), f + 310, p), c.fillText(b.total.toFixed(2), f + 450, p), p += 5, c.beginPath(), c.moveTo(this._canvasPadding, p), c.lineTo(this._canvasWidth - this._canvasPadding, p), c.stroke();
    }
    const m = s.info;
    c.font = "13px sans-serif", c.textAlign = "left", f = this._canvasPadding, p = 270, c.fillText("frame: " + m.render.frame, f, p), f += 160, c.fillText("calls: " + m.render.calls, f, p), f += 160, c.fillText("triangles: " + m.render.triangles, f, p), f += 160, c.fillText("points: " + m.render.points, f, p), f = this._canvasPadding, p += 20, c.fillText("lines: " + m.render.lines, f, p), f += 160, c.fillText("geometries: " + m.memory.geometries, f, p), f += 160, c.fillText("textures: " + m.memory.textures, f, p), f += 160, c.fillText("programs: " + m.programs.length, f, p), f = this._canvasPadding, p += 20, c.fillText("postprocessing: " + e.main.postprocessings.validCount, f, p);
    const y = e.main.features.features;
    let x = "";
    for (const E of y)
      E.enabled && (x += E.name + " ");
    f += 160, c.fillText("features: " + x, f, p), f += 160, c.fillText("tasks: " + e.taskScheduler.taskCount, f, p), c.restore(), a.endTimeStatsItem("updateStatsTexture"), this._texture.needsUpdate = !0;
    const v = e.resolution, S = this._renderPass;
    S.material.uniforms.textureInfos.value[0].offset = [
      0.5 - this._canvasWidth / 2 / v.x,
      0.5 - this._canvasHeight / 2 / v.y
    ], S.material.uniforms.textureInfos.value[0].scale = [
      1 / (this._canvasWidth / v.x),
      1 / (this._canvasHeight / v.y)
    ];
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    const e = this._rendering;
    e.stats.removeTimeStatsItem("updateStatsTexture"), e.main.postprocessings.remove(this._renderPass), this._renderPass && this._renderPass.dispose(), this._texture && this._texture.dispose();
  }
}
const _baseReprojectionMaterial = new ShaderMaterial({
  uniforms: {
    numFrames: { value: 0 },
    tLastFrame: { value: null },
    height: { value: 1 },
    width: { value: 1 },
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  transparent: !0,
  blending: AdditiveBlending,
  depthTest: !1,
  depthWrite: !1,
  vertexShader: `
    varying vec2 Uv;

    void main() {
        Uv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
  fragmentShader: `
    // uniform float opacity;
    uniform float numFrames;
    uniform float height;
    uniform float width;
    uniform sampler2D tDiffuse;
    // uniform sampler2D tMotion;
    uniform sampler2D tLastFrame;
    varying vec2 Uv;

    void main() {
        vec4 texel = texture2D(tDiffuse, Uv);
        // vec4 pixelMovement = texture2D(tMotion, Uv);
        // vec2 oldPixelUv = Uv - ((pixelMovement.xy * 2.0) - 1.0);
        vec4 oldTexel = texture2D(tLastFrame, Uv);

        // Use simple neighbor clamping
        vec4 maxNeighbor = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 minNeighbor = vec4(1.0);
        vec4 average = vec4(0.0);

        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                vec2 neighborUv = Uv + vec2(float(x) / width, float(y) / height);
                vec4 neighborTexel = texture2D(tDiffuse, neighborUv);

                maxNeighbor = max(maxNeighbor, neighborTexel);
                minNeighbor = min(minNeighbor, neighborTexel);
                average += neighborTexel / 9.0;
            }
        }


        oldTexel = clamp(oldTexel, minNeighbor, maxNeighbor);

        // UE Method to get rid of flickering. Weight frame mixing amount
        // based on local contrast.
        float contrast = distance(average, texel);
        // # fix float type color range
        contrast = clamp(contrast, 0.0, 0.1);
        float weight = 0.1 * contrast;
        vec4 compositeColor = mix(oldTexel, texel, weight);

        gl_FragColor = compositeColor;
    }`
});
class TAAPass extends Pass {
  constructor() {
    super();
    _(this, "enableRenderingJitter", !0);
    _(this, "getCurrentUsedTextures", () => {
      const e = [];
      return this._scratchBuffer && e.push(this._scratchBuffer.texture), this._oldFrameTarget && e.push(this._oldFrameTarget.texture), e;
    });
    const e = CopyShader;
    this._oldClearColor = new Color(), this.uniforms = {
      tDiffuse: { value: null },
      opacity: { value: 1 }
    }, this._reprojectionMaterial = _baseReprojectionMaterial.clone(), this.material = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader,
      depthTest: !1,
      depthWrite: !1
    }), this.needsSwap = !0, this.fsQuad = new FullScreenQuad(null), this._isFirstFrame = !0;
  }
  render(e, r, s) {
    const a = this.rendering.resolution, c = this.rendering.pixelRatio, l = this.rendering.renderState, h = e.autoClear;
    e.autoClear = !1;
    let d = null;
    this._oldFrameTarget || (this._oldFrameTarget = new WebGLRenderTarget(
      a.x * c,
      a.y * c,
      {}
    )), !l.viewChanged && !this._isFirstFrame && !this._debugEngineForceRender ? (this._scratchBuffer || (this._scratchBuffer = new WebGLRenderTarget(
      a.x * c,
      a.y * c,
      {}
    )), d = this._reprojectionMaterial.uniforms, d.tLastFrame.value = this._oldFrameTarget.texture, d.height.value = s.height, d.width.value = s.width, d.tDiffuse.value = s.texture, this.fsQuad.material = this._reprojectionMaterial, e.setRenderTarget(this._scratchBuffer), e.clear(), this.fsQuad.render(e), d = this.material.uniforms, d.tDiffuse.value = this._scratchBuffer.texture, d.opacity.value = 1, this.fsQuad.material = this.material, e.setRenderTarget(this._oldFrameTarget), e.clear(), this.fsQuad.render(e), l.viewStableFrameCount < 32 && this.rendering.requestRender()) : (d = this.material.uniforms, d.tDiffuse.value = s.texture, d.opacity.value = 1, this.fsQuad.material = this.material, e.setRenderTarget(this._oldFrameTarget), e.clear(), this.fsQuad.render(e)), d = this.material.uniforms, d.tDiffuse.value = l.viewChanged ? s.texture : this._oldFrameTarget.texture, d.opacity.value = 1, this.fsQuad.material = this.material, e.setRenderTarget(this.renderToScreen ? null : r), e.clear(), this.fsQuad.render(e), e.autoClear = h, this._isFirstFrame = !1;
  }
  dispose() {
    this._reprojectionMaterial.dispose(), this.material.dispose(), this.fsQuad.dispose(), this._scratchBuffer && this._scratchBuffer.dispose(), this._oldFrameTarget && this._oldFrameTarget.dispose();
  }
}
const FXAAShader = {
  name: "FXAAShader",
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2$1(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;

		#define EDGE_STEP_COUNT 6
		#define EDGE_GUESS 8.0
		#define EDGE_STEPS 1.0, 1.5, 2.0, 2.0, 2.0, 4.0
		const float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );

		float _ContrastThreshold = 0.0312;
		float _RelativeThreshold = 0.063;
		float _SubpixelBlending = 1.0;

		vec4 Sample( sampler2D  tex2D, vec2 uv ) {

			return texture( tex2D, uv );

		}

		float SampleLuminance( sampler2D tex2D, vec2 uv ) {

			return dot( Sample( tex2D, uv ).rgb, vec3( 0.3, 0.59, 0.11 ) );

		}

		float SampleLuminance( sampler2D tex2D, vec2 texSize, vec2 uv, float uOffset, float vOffset ) {

			uv += texSize * vec2(uOffset, vOffset);
			return SampleLuminance(tex2D, uv);

		}

		struct LuminanceData {

			float m, n, e, s, w;
			float ne, nw, se, sw;
			float highest, lowest, contrast;

		};

		LuminanceData SampleLuminanceNeighborhood( sampler2D tex2D, vec2 texSize, vec2 uv ) {

			LuminanceData l;
			l.m = SampleLuminance( tex2D, uv );
			l.n = SampleLuminance( tex2D, texSize, uv,  0.0,  1.0 );
			l.e = SampleLuminance( tex2D, texSize, uv,  1.0,  0.0 );
			l.s = SampleLuminance( tex2D, texSize, uv,  0.0, -1.0 );
			l.w = SampleLuminance( tex2D, texSize, uv, -1.0,  0.0 );

			l.ne = SampleLuminance( tex2D, texSize, uv,  1.0,  1.0 );
			l.nw = SampleLuminance( tex2D, texSize, uv, -1.0,  1.0 );
			l.se = SampleLuminance( tex2D, texSize, uv,  1.0, -1.0 );
			l.sw = SampleLuminance( tex2D, texSize, uv, -1.0, -1.0 );

			l.highest = max( max( max( max( l.n, l.e ), l.s ), l.w ), l.m );
			l.lowest = min( min( min( min( l.n, l.e ), l.s ), l.w ), l.m );
			l.contrast = l.highest - l.lowest;
			return l;

		}

		bool ShouldSkipPixel( LuminanceData l ) {

			float threshold = max( _ContrastThreshold, _RelativeThreshold * l.highest );
			return l.contrast < threshold;

		}

		float DeterminePixelBlendFactor( LuminanceData l ) {

			float f = 2.0 * ( l.n + l.e + l.s + l.w );
			f += l.ne + l.nw + l.se + l.sw;
			f *= 1.0 / 12.0;
			f = abs( f - l.m );
			f = clamp( f / l.contrast, 0.0, 1.0 );

			float blendFactor = smoothstep( 0.0, 1.0, f );
			return blendFactor * blendFactor * _SubpixelBlending;

		}

		struct EdgeData {

			bool isHorizontal;
			float pixelStep;
			float oppositeLuminance, gradient;

		};

		EdgeData DetermineEdge( vec2 texSize, LuminanceData l ) {

			EdgeData e;
			float horizontal =
				abs( l.n + l.s - 2.0 * l.m ) * 2.0 +
				abs( l.ne + l.se - 2.0 * l.e ) +
				abs( l.nw + l.sw - 2.0 * l.w );
			float vertical =
				abs( l.e + l.w - 2.0 * l.m ) * 2.0 +
				abs( l.ne + l.nw - 2.0 * l.n ) +
				abs( l.se + l.sw - 2.0 * l.s );
			e.isHorizontal = horizontal >= vertical;

			float pLuminance = e.isHorizontal ? l.n : l.e;
			float nLuminance = e.isHorizontal ? l.s : l.w;
			float pGradient = abs( pLuminance - l.m );
			float nGradient = abs( nLuminance - l.m );

			e.pixelStep = e.isHorizontal ? texSize.y : texSize.x;

			if (pGradient < nGradient) {

				e.pixelStep = -e.pixelStep;
				e.oppositeLuminance = nLuminance;
				e.gradient = nGradient;

			} else {

				e.oppositeLuminance = pLuminance;
				e.gradient = pGradient;

			}

			return e;

		}

		float DetermineEdgeBlendFactor( sampler2D  tex2D, vec2 texSize, LuminanceData l, EdgeData e, vec2 uv ) {

			vec2 uvEdge = uv;
			vec2 edgeStep;
			if (e.isHorizontal) {

				uvEdge.y += e.pixelStep * 0.5;
				edgeStep = vec2( texSize.x, 0.0 );

			} else {

				uvEdge.x += e.pixelStep * 0.5;
				edgeStep = vec2( 0.0, texSize.y );

			}

			float edgeLuminance = ( l.m + e.oppositeLuminance ) * 0.5;
			float gradientThreshold = e.gradient * 0.25;

			vec2 puv = uvEdge + edgeStep * edgeSteps[0];
			float pLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;
			bool pAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;

			for ( int i = 1; i < EDGE_STEP_COUNT && !pAtEnd; i++ ) {

				puv += edgeStep * edgeSteps[i];
				pLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;
				pAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;

			}

			if ( !pAtEnd ) {

				puv += edgeStep * EDGE_GUESS;

			}

			vec2 nuv = uvEdge - edgeStep * edgeSteps[0];
			float nLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;
			bool nAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;

			for ( int i = 1; i < EDGE_STEP_COUNT && !nAtEnd; i++ ) {

				nuv -= edgeStep * edgeSteps[i];
				nLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;
				nAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;

			}

			if ( !nAtEnd ) {

				nuv -= edgeStep * EDGE_GUESS;

			}

			float pDistance, nDistance;
			if ( e.isHorizontal ) {

				pDistance = puv.x - uv.x;
				nDistance = uv.x - nuv.x;

			} else {

				pDistance = puv.y - uv.y;
				nDistance = uv.y - nuv.y;

			}

			float shortestDistance;
			bool deltaSign;
			if ( pDistance <= nDistance ) {

				shortestDistance = pDistance;
				deltaSign = pLuminanceDelta >= 0.0;

			} else {

				shortestDistance = nDistance;
				deltaSign = nLuminanceDelta >= 0.0;

			}

			if ( deltaSign == ( l.m - edgeLuminance >= 0.0 ) ) {

				return 0.0;

			}

			return 0.5 - shortestDistance / ( pDistance + nDistance );

		}

		vec4 ApplyFXAA( sampler2D  tex2D, vec2 texSize, vec2 uv ) {

			LuminanceData luminance = SampleLuminanceNeighborhood( tex2D, texSize, uv );
			if ( ShouldSkipPixel( luminance ) ) {

				return Sample( tex2D, uv );

			}

			float pixelBlend = DeterminePixelBlendFactor( luminance );
			EdgeData edge = DetermineEdge( texSize, luminance );
			float edgeBlend = DetermineEdgeBlendFactor( tex2D, texSize, luminance, edge, uv );
			float finalBlend = max( pixelBlend, edgeBlend );

			if (edge.isHorizontal) {

				uv.y += edge.pixelStep * finalBlend;

			} else {

				uv.x += edge.pixelStep * finalBlend;

			}

			return Sample( tex2D, uv );

		}

		void main() {

			gl_FragColor = ApplyFXAA( tDiffuse, resolution.xy, vUv );

		}`
}, SMAAEdgesShader = {
  name: "SMAAEdgesShader",
  defines: {
    SMAA_THRESHOLD: "0.1"
  },
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2$1(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		void SMAAEdgeDetectionVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAAEdgeDetectionVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {
			vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );

			// Calculate color deltas:
			vec4 delta;
			vec3 C = texture2D( colorTex, texcoord ).rgb;

			vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;
			vec3 t = abs( C - Cleft );
			delta.x = max( max( t.r, t.g ), t.b );

			vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;
			t = abs( C - Ctop );
			delta.y = max( max( t.r, t.g ), t.b );

			// We do the usual threshold:
			vec2 edges = step( threshold, delta.xy );

			// Then discard if there is no edge:
			if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )
				discard;

			// Calculate right and bottom deltas:
			vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;
			t = abs( C - Cright );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;
			t = abs( C - Cbottom );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the maximum delta in the direct neighborhood:
			float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );

			// Calculate left-left and top-top deltas:
			vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;
			t = abs( C - Cleftleft );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;
			t = abs( C - Ctoptop );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the final maximum delta:
			maxDelta = max( max( maxDelta, delta.z ), delta.w );

			// Local contrast adaptation in action:
			edges.xy *= step( 0.5 * maxDelta, delta.xy );

			return vec4( edges, 0.0, 0.0 );
		}

		void main() {

			gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );

		}`
}, SMAAWeightsShader = {
  name: "SMAAWeightsShader",
  defines: {
    SMAA_MAX_SEARCH_STEPS: "8",
    SMAA_AREATEX_MAX_DISTANCE: "16",
    SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
    SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
  },
  uniforms: {
    tDiffuse: { value: null },
    tArea: { value: null },
    tSearch: { value: null },
    resolution: { value: new Vector2$1(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];
		varying vec2 vPixcoord;

		void SMAABlendingWeightCalculationVS( vec2 texcoord ) {
			vPixcoord = texcoord / resolution;

			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components

			// And these for the searches, they indicate the ends of the loops:
			vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );

		}

		void main() {

			vUv = uv;

			SMAABlendingWeightCalculationVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )

		uniform sampler2D tDiffuse;
		uniform sampler2D tArea;
		uniform sampler2D tSearch;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[3];
		varying vec2 vPixcoord;

		#if __VERSION__ == 100
		vec2 round( vec2 x ) {
			return sign( x ) * floor( abs( x ) + 0.5 );
		}
		#endif

		float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {
			// Not required if searchTex accesses are set to point:
			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
			e.r = bias + e.r * scale;
			return 255.0 * texture2D( searchTex, e, 0.0 ).r;
		}

		float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			/**
				* @PSEUDO_GATHER4
				* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
				* sample between edge, thus fetching four edges in a row.
				* Sampling with different offsets in each direction allows to disambiguate
				* which edges are active from the four fetched ones.
				*/
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			// We correct the previous (-0.25, -0.125) offset we applied:
			texcoord.x += 0.25 * resolution.x;

			// The searches are bias by 1, so adjust the coords accordingly:
			texcoord.x += resolution.x;

			// Disambiguate the length added by the last step:
			texcoord.x += 2.0 * resolution.x; // Undo last step
			texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);

			return texcoord.x;
		}

		float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			texcoord.x -= 0.25 * resolution.x;
			texcoord.x -= resolution.x;
			texcoord.x -= 2.0 * resolution.x;
			texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );

			return texcoord.x;
		}

		float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y; // WebGL port note: Changed sign
			texcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y; // WebGL port note: Changed sign
			texcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {
			// Rounding prevents precision errors of bilinear filtering:
			vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;

			// We do a scale and bias for mapping to texel space:
			texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );

			// Move to proper place, according to the subpixel offset:
			texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

			return texture2D( areaTex, texcoord, 0.0 ).rg;
		}

		vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {
			vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );

			vec2 e = texture2D( edgesTex, texcoord ).rg;

			if ( e.g > 0.0 ) { // Edge at north
				vec2 d;

				// Find the distance to the left:
				vec2 coords;
				coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );
				coords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
				d.x = coords.x;

				// Now fetch the left crossing edges, two at a time using bilinear
				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
				// discern what value each edge has:
				float e1 = texture2D( edgesTex, coords, 0.0 ).r;

				// Find the distance to the right:
				coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );
				d.y = coords.x;

				// We want the distances to be in pixel units (doing this here allow to
				// better interleave arithmetic and memory accesses):
				d = d / resolution.x - pixcoord.x;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the right crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;

				// Ok, we know how this pattern looks like, now it is time for getting
				// the actual area:
				weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );
			}

			if ( e.r > 0.0 ) { // Edge at west
				vec2 d;

				// Find the distance to the top:
				vec2 coords;

				coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );
				coords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;
				d.x = coords.y;

				// Fetch the top crossing edges:
				float e1 = texture2D( edgesTex, coords, 0.0 ).g;

				// Find the distance to the bottom:
				coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );
				d.y = coords.y;

				// We want the distances to be in pixel units:
				d = d / resolution.y - pixcoord.y;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the bottom crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;

				// Get the area for this direction:
				weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );
			}

			return weights;
		}

		void main() {

			gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );

		}`
}, SMAABlendShader = {
  name: "SMAABlendShader",
  uniforms: {
    tDiffuse: { value: null },
    tColor: { value: null },
    resolution: { value: new Vector2$1(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		void SMAANeighborhoodBlendingVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAANeighborhoodBlendingVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform sampler2D tColor;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {
			// Fetch the blending weights for current pixel:
			vec4 a;
			a.xz = texture2D( blendTex, texcoord ).xz;
			a.y = texture2D( blendTex, offset[ 1 ].zw ).g;
			a.w = texture2D( blendTex, offset[ 1 ].xy ).a;

			// Is there any blending weight with a value greater than 0.0?
			if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {
				return texture2D( colorTex, texcoord, 0.0 );
			} else {
				// Up to 4 lines can be crossing a pixel (one through each edge). We
				// favor blending by choosing the line with the maximum weight for each
				// direction:
				vec2 offset;
				offset.x = a.a > a.b ? a.a : -a.b; // left vs. right
				offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs

				// Then we go in the direction that has the maximum weight:
				if ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical
					offset.y = 0.0;
				} else {
					offset.x = 0.0;
				}

				// Fetch the opposite color and lerp by hand:
				vec4 C = texture2D( colorTex, texcoord, 0.0 );
				texcoord += sign( offset ) * resolution;
				vec4 Cop = texture2D( colorTex, texcoord, 0.0 );
				float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );

				// WebGL port note: Added gamma correction
				C.xyz = pow(C.xyz, vec3(2.2));
				Cop.xyz = pow(Cop.xyz, vec3(2.2));
				vec4 mixed = mix(C, Cop, s);
				mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));

				return mixed;
			}
		}

		void main() {

			gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );

		}`
};
class SMAAPass extends Pass {
  constructor() {
    super(), this._edgesRT = new WebGLRenderTarget(1, 1, {
      depthBuffer: !1,
      type: HalfFloatType
    }), this._edgesRT.texture.name = "SMAAPass.edges", this._weightsRT = new WebGLRenderTarget(1, 1, {
      depthBuffer: !1,
      type: HalfFloatType
    }), this._weightsRT.texture.name = "SMAAPass.weights";
    const i = this, e = new Image();
    e.src = this._getAreaTexture(), e.onload = function() {
      i._areaTexture.needsUpdate = !0;
    }, this._areaTexture = new Texture(), this._areaTexture.name = "SMAAPass.area", this._areaTexture.image = e, this._areaTexture.minFilter = LinearFilter, this._areaTexture.generateMipmaps = !1, this._areaTexture.flipY = !1;
    const r = new Image();
    r.src = this._getSearchTexture(), r.onload = function() {
      i._searchTexture.needsUpdate = !0;
    }, this._searchTexture = new Texture(), this._searchTexture.name = "SMAAPass.search", this._searchTexture.image = r, this._searchTexture.magFilter = NearestFilter, this._searchTexture.minFilter = NearestFilter, this._searchTexture.generateMipmaps = !1, this._searchTexture.flipY = !1, this._uniformsEdges = UniformsUtils.clone(SMAAEdgesShader.uniforms), this._materialEdges = new ShaderMaterial({
      defines: Object.assign({}, SMAAEdgesShader.defines),
      uniforms: this._uniformsEdges,
      vertexShader: SMAAEdgesShader.vertexShader,
      fragmentShader: SMAAEdgesShader.fragmentShader
    }), this._uniformsWeights = UniformsUtils.clone(SMAAWeightsShader.uniforms), this._uniformsWeights.tDiffuse.value = this._edgesRT.texture, this._uniformsWeights.tArea.value = this._areaTexture, this._uniformsWeights.tSearch.value = this._searchTexture, this._materialWeights = new ShaderMaterial({
      defines: Object.assign({}, SMAAWeightsShader.defines),
      uniforms: this._uniformsWeights,
      vertexShader: SMAAWeightsShader.vertexShader,
      fragmentShader: SMAAWeightsShader.fragmentShader
    }), this._uniformsBlend = UniformsUtils.clone(SMAABlendShader.uniforms), this._uniformsBlend.tDiffuse.value = this._weightsRT.texture, this._materialBlend = new ShaderMaterial({
      uniforms: this._uniformsBlend,
      vertexShader: SMAABlendShader.vertexShader,
      fragmentShader: SMAABlendShader.fragmentShader
    }), this._fsQuad = new FullScreenQuad(null);
  }
  render(i, e, r) {
    this._uniformsEdges.tDiffuse.value = r.texture, this._fsQuad.material = this._materialEdges, i.setRenderTarget(this._edgesRT), this.clear && i.clear(), this._fsQuad.render(i), this._fsQuad.material = this._materialWeights, i.setRenderTarget(this._weightsRT), this.clear && i.clear(), this._fsQuad.render(i), this._uniformsBlend.tColor.value = r.texture, this._fsQuad.material = this._materialBlend, this.renderToScreen ? (i.setRenderTarget(null), this._fsQuad.render(i)) : (i.setRenderTarget(e), this.clear && i.clear(), this._fsQuad.render(i));
  }
  setSize(i, e) {
    this._edgesRT.setSize(i, e), this._weightsRT.setSize(i, e), this._materialEdges.uniforms.resolution.value.set(1 / i, 1 / e), this._materialWeights.uniforms.resolution.value.set(1 / i, 1 / e), this._materialBlend.uniforms.resolution.value.set(1 / i, 1 / e);
  }
  dispose() {
    this._edgesRT.dispose(), this._weightsRT.dispose(), this._areaTexture.dispose(), this._searchTexture.dispose(), this._materialEdges.dispose(), this._materialWeights.dispose(), this._materialBlend.dispose(), this._fsQuad.dispose();
  }
  _getAreaTexture() {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=";
  }
  _getSearchTexture() {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";
  }
}
class FeatureAntialias extends Feature {
  constructor(e, r) {
    super(e, r);
    _(this, "name", "AA");
    _(this, "_method", "msaa");
    _(this, "_lastMethod", "msaa");
    _(this, "_lastEnabled", !1);
    _(this, "_lastUseMRT", !1);
    _(this, "_samples", 0);
    this.enabled = r.enabled, this._method = r.method;
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._enableNewMethod() : this._disableOldMethod();
      return;
    }
    this.enabled && this._lastMethod !== this._method && (this._disableOldMethod(), this._enableNewMethod());
  }
  _disableOldMethod() {
    const e = this._lastMethod, r = this._rendering;
    e === "msaa" ? (r.updateContextParameters({
      antialias: !1
    }), r.main.sceneRendering.updateRenderTargetSamples(0), this._samples = 0) : e === "fxaa" ? (this._fxaaPass && r.main.postprocessings.remove(this._fxaaPass), this._fxaaPass = null) : e === "taa" ? (this._taaPass && r.main.postprocessings.remove(this._taaPass), this._taaPass = null) : e === "smaa" && (this._smaaPass && r.main.postprocessings.remove(this._smaaPass), this._smaaPass = null);
  }
  _enableNewMethod() {
    const e = this._method, r = this._rendering;
    if (e === "msaa")
      r.updateContextParameters({
        antialias: !0
      }), r.main.sceneRendering.updateRenderTargetSamples(4), this._samples = 4;
    else if (e === "fxaa") {
      const s = this._fxaaPass = new ShaderPass(FXAAShader), a = r.resolution, c = r.pixelRatio;
      s.uniforms.resolution.value.set(1 / a.x / c, 1 / a.y / c), s.renderOrder = 80, r.main.postprocessings.add(s);
    } else if (e === "taa") {
      const s = this._taaPass = new TAAPass();
      s.rendering = r, s.renderOrder = 80, r.main.postprocessings.add(s);
    } else if (e === "smaa") {
      const s = r.resolution, a = r.pixelRatio, c = this._smaaPass = new SMAAPass(s.x * a, s.y * a);
      c.renderOrder = 80, r.main.postprocessings.add(c);
    } else
      console.warn("Unknown antialias method:", e);
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._lastMethod = this._method;
  }
  dispose() {
    this.enabled && this._method !== "msaa" && this._disableOldMethod();
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
  get samples() {
    return this._samples;
  }
}
class FeatureBufferView extends Feature {
  constructor(e, r = {}) {
    super(e, r);
    _(this, "name", "bufferView");
    _(this, "_lastEnabled", !1);
    _(this, "_offset", 0);
    _(this, "_currentFrameTextures", []);
    this._offset = r.offset || 0;
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
  }
  _init() {
    const e = this._rendering, r = this._renderPass = new AddTexturePass();
    r.renderOrder = 10900, r.material.uniforms.textureInfos.value = [{
      offset: [0.2, 0.2],
      scale: [2.5, 2.5]
    }], r.material.uniforms.maps.value = [], e.main.postprocessings.add(this._renderPass);
  }
  afterRender() {
    if (!this.enabled)
      return;
    const e = [], r = this._rendering, s = r.main.sceneRendering;
    s.diffuseTexture && e.push(s.diffuseTexture), s.emissiveTexture && e.push(s.emissiveTexture), s.normalTexture && e.push(s.normalTexture), s.depthTexture && e.push(s.depthTexture), s.metallicRoughTexture && e.push(s.metallicRoughTexture);
    const a = r.main.features.features || [];
    for (let f = 0; f < a.length; f++) {
      const p = a[f];
      if (!!p.enabled && p.getCurrentUsedTextures) {
        const m = p.getCurrentUsedTextures();
        m && e.push(...m);
      }
    }
    const c = r.main.opaquePostprocessings.postprocessings || [];
    for (let f = 0; f < c.length; f++) {
      const p = c[f];
      if (p.getCurrentUsedTextures) {
        const m = p.getCurrentUsedTextures();
        m && e.push(...m);
      }
    }
    const l = r.main.postprocessings.postprocessings || [];
    for (let f = 0; f < l.length; f++) {
      const p = l[f];
      if (p.getCurrentUsedTextures) {
        const m = p.getCurrentUsedTextures();
        m && e.push(...m);
      }
    }
    this._currentFrameTextures.length > 0 && e.push(...this._currentFrameTextures);
    const h = [], d = e.slice(this._offset, this._offset + 4);
    if (d.length !== 0) {
      for (let f = 0; f < d.length; f++)
        h.push({
          offset: [f * 0.25, Math.floor(f / 4) * 0.25],
          scale: [4, 4]
        });
      this._renderPass.updateTextures(d, h);
    }
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._currentFrameTextures.length = 0;
  }
  addCurrentFrameTexture(e) {
    !this.enabled || this._currentFrameTextures.push(e);
  }
  dispose() {
    this._rendering.main.postprocessings.remove(this._renderPass), this._renderPass && this._renderPass.dispose();
  }
  get offset() {
    return this._offset;
  }
  set offset(e) {
    this._offset = e;
  }
}
class SimplexNoise {
  constructor(i = Math) {
    this.grad3 = [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1]
    ], this.grad4 = [
      [0, 1, 1, 1],
      [0, 1, 1, -1],
      [0, 1, -1, 1],
      [0, 1, -1, -1],
      [0, -1, 1, 1],
      [0, -1, 1, -1],
      [0, -1, -1, 1],
      [0, -1, -1, -1],
      [1, 0, 1, 1],
      [1, 0, 1, -1],
      [1, 0, -1, 1],
      [1, 0, -1, -1],
      [-1, 0, 1, 1],
      [-1, 0, 1, -1],
      [-1, 0, -1, 1],
      [-1, 0, -1, -1],
      [1, 1, 0, 1],
      [1, 1, 0, -1],
      [1, -1, 0, 1],
      [1, -1, 0, -1],
      [-1, 1, 0, 1],
      [-1, 1, 0, -1],
      [-1, -1, 0, 1],
      [-1, -1, 0, -1],
      [1, 1, 1, 0],
      [1, 1, -1, 0],
      [1, -1, 1, 0],
      [1, -1, -1, 0],
      [-1, 1, 1, 0],
      [-1, 1, -1, 0],
      [-1, -1, 1, 0],
      [-1, -1, -1, 0]
    ], this.p = [];
    for (let e = 0; e < 256; e++)
      this.p[e] = Math.floor(i.random() * 256);
    this.perm = [];
    for (let e = 0; e < 512; e++)
      this.perm[e] = this.p[e & 255];
    this.simplex = [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0]
    ];
  }
  noise(i, e) {
    let r, s, a;
    const c = 0.5 * (Math.sqrt(3) - 1), l = (i + e) * c, h = Math.floor(i + l), d = Math.floor(e + l), f = (3 - Math.sqrt(3)) / 6, p = (h + d) * f, m = h - p, y = d - p, x = i - m, v = e - y;
    let S, E;
    x > v ? (S = 1, E = 0) : (S = 0, E = 1);
    const b = x - S + f, w = v - E + f, M = x - 1 + 2 * f, P = v - 1 + 2 * f, D = h & 255, L = d & 255, O = this.perm[D + this.perm[L]] % 12, F = this.perm[D + S + this.perm[L + E]] % 12, k = this.perm[D + 1 + this.perm[L + 1]] % 12;
    let V = 0.5 - x * x - v * v;
    V < 0 ? r = 0 : (V *= V, r = V * V * this._dot(this.grad3[O], x, v));
    let N = 0.5 - b * b - w * w;
    N < 0 ? s = 0 : (N *= N, s = N * N * this._dot(this.grad3[F], b, w));
    let U = 0.5 - M * M - P * P;
    return U < 0 ? a = 0 : (U *= U, a = U * U * this._dot(this.grad3[k], M, P)), 70 * (r + s + a);
  }
  noise3d(i, e, r) {
    let s, a, c, l;
    const h = 0.3333333333333333, d = (i + e + r) * h, f = Math.floor(i + d), p = Math.floor(e + d), m = Math.floor(r + d), y = 1 / 6, x = (f + p + m) * y, v = f - x, S = p - x, E = m - x, b = i - v, w = e - S, M = r - E;
    let P, D, L, O, F, k;
    b >= w ? w >= M ? (P = 1, D = 0, L = 0, O = 1, F = 1, k = 0) : b >= M ? (P = 1, D = 0, L = 0, O = 1, F = 0, k = 1) : (P = 0, D = 0, L = 1, O = 1, F = 0, k = 1) : w < M ? (P = 0, D = 0, L = 1, O = 0, F = 1, k = 1) : b < M ? (P = 0, D = 1, L = 0, O = 0, F = 1, k = 1) : (P = 0, D = 1, L = 0, O = 1, F = 1, k = 0);
    const V = b - P + y, N = w - D + y, U = M - L + y, z = b - O + 2 * y, $ = w - F + 2 * y, G = M - k + 2 * y, j = b - 1 + 3 * y, Y = w - 1 + 3 * y, H = M - 1 + 3 * y, W = f & 255, q = p & 255, Z = m & 255, X = this.perm[W + this.perm[q + this.perm[Z]]] % 12, K = this.perm[W + P + this.perm[q + D + this.perm[Z + L]]] % 12, ee = this.perm[W + O + this.perm[q + F + this.perm[Z + k]]] % 12, ie = this.perm[W + 1 + this.perm[q + 1 + this.perm[Z + 1]]] % 12;
    let re = 0.6 - b * b - w * w - M * M;
    re < 0 ? s = 0 : (re *= re, s = re * re * this._dot3(this.grad3[X], b, w, M));
    let ne = 0.6 - V * V - N * N - U * U;
    ne < 0 ? a = 0 : (ne *= ne, a = ne * ne * this._dot3(this.grad3[K], V, N, U));
    let J = 0.6 - z * z - $ * $ - G * G;
    J < 0 ? c = 0 : (J *= J, c = J * J * this._dot3(this.grad3[ee], z, $, G));
    let oe = 0.6 - j * j - Y * Y - H * H;
    return oe < 0 ? l = 0 : (oe *= oe, l = oe * oe * this._dot3(this.grad3[ie], j, Y, H)), 32 * (s + a + c + l);
  }
  noise4d(i, e, r, s) {
    const a = this.grad4, c = this.simplex, l = this.perm, h = (Math.sqrt(5) - 1) / 4, d = (5 - Math.sqrt(5)) / 20;
    let f, p, m, y, x;
    const v = (i + e + r + s) * h, S = Math.floor(i + v), E = Math.floor(e + v), b = Math.floor(r + v), w = Math.floor(s + v), M = (S + E + b + w) * d, P = S - M, D = E - M, L = b - M, O = w - M, F = i - P, k = e - D, V = r - L, N = s - O, U = F > k ? 32 : 0, z = F > V ? 16 : 0, $ = k > V ? 8 : 0, G = F > N ? 4 : 0, j = k > N ? 2 : 0, Y = V > N ? 1 : 0, H = U + z + $ + G + j + Y, W = c[H][0] >= 3 ? 1 : 0, q = c[H][1] >= 3 ? 1 : 0, Z = c[H][2] >= 3 ? 1 : 0, X = c[H][3] >= 3 ? 1 : 0, K = c[H][0] >= 2 ? 1 : 0, ee = c[H][1] >= 2 ? 1 : 0, ie = c[H][2] >= 2 ? 1 : 0, re = c[H][3] >= 2 ? 1 : 0, ne = c[H][0] >= 1 ? 1 : 0, J = c[H][1] >= 1 ? 1 : 0, oe = c[H][2] >= 1 ? 1 : 0, _e = c[H][3] >= 1 ? 1 : 0, le = F - W + d, de = k - q + d, ce = V - Z + d, Re = N - X + d, Ee = F - K + 2 * d, Le = k - ee + 2 * d, ke = V - ie + 2 * d, se = N - re + 2 * d, pe = F - ne + 3 * d, fe = k - J + 3 * d, Ce = V - oe + 3 * d, He = N - _e + 3 * d, Me = F - 1 + 4 * d, Be = k - 1 + 4 * d, Se = V - 1 + 4 * d, Oe = N - 1 + 4 * d, Ie = S & 255, ze = E & 255, $e = b & 255, We = w & 255, st = l[Ie + l[ze + l[$e + l[We]]]] % 32, gt = l[Ie + W + l[ze + q + l[$e + Z + l[We + X]]]] % 32, ut = l[Ie + K + l[ze + ee + l[$e + ie + l[We + re]]]] % 32, dt = l[Ie + ne + l[ze + J + l[$e + oe + l[We + _e]]]] % 32, ft = l[Ie + 1 + l[ze + 1 + l[$e + 1 + l[We + 1]]]] % 32;
    let Fe = 0.6 - F * F - k * k - V * V - N * N;
    Fe < 0 ? f = 0 : (Fe *= Fe, f = Fe * Fe * this._dot4(a[st], F, k, V, N));
    let Ne = 0.6 - le * le - de * de - ce * ce - Re * Re;
    Ne < 0 ? p = 0 : (Ne *= Ne, p = Ne * Ne * this._dot4(a[gt], le, de, ce, Re));
    let Ve = 0.6 - Ee * Ee - Le * Le - ke * ke - se * se;
    Ve < 0 ? m = 0 : (Ve *= Ve, m = Ve * Ve * this._dot4(a[ut], Ee, Le, ke, se));
    let Te = 0.6 - pe * pe - fe * fe - Ce * Ce - He * He;
    Te < 0 ? y = 0 : (Te *= Te, y = Te * Te * this._dot4(a[dt], pe, fe, Ce, He));
    let ye = 0.6 - Me * Me - Be * Be - Se * Se - Oe * Oe;
    return ye < 0 ? x = 0 : (ye *= ye, x = ye * ye * this._dot4(a[ft], Me, Be, Se, Oe)), 27 * (f + p + m + y + x);
  }
  _dot(i, e, r) {
    return i[0] * e + i[1] * r;
  }
  _dot3(i, e, r, s) {
    return i[0] * e + i[1] * r + i[2] * s;
  }
  _dot4(i, e, r, s, a) {
    return i[0] * e + i[1] * r + i[2] * s + i[3] * a;
  }
}
new Vector2$1(), new Matrix4(), new Matrix4();
const SSAOBlurShader = {
  name: "SSAOBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2$1() }
  },
  vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		void main() {

			vec2 texelSize = ( 1.0 / resolution );
			float result = 0.0;

			for ( int i = - 2; i <= 2; i ++ ) {

				for ( int j = - 2; j <= 2; j ++ ) {

					vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
					result += texture2D( tDiffuse, vUv + offset ).r;

				}

			}

			gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );

		}`
}, SSAOShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1,
    KERNEL_SIZE: 32
  },
  uniforms: {
    tDiffuse: { value: null },
    tNormal: { value: null },
    tDepth: { value: null },
    tNoise: { value: null },
    kernel: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null },
    resolution: { value: new Vector2$1() },
    cameraProjectionMatrix: { value: new Matrix4() },
    cameraInverseProjectionMatrix: { value: new Matrix4() },
    kernelRadius: { value: 0.1 },
    minDistance: { value: 1e-4 },
    maxDistance: { value: 1e3 },
    intensity: { value: 1 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform sampler2D tNormal;
		uniform sampler2D tDepth;
		uniform sampler2D tNoise;

		uniform vec3 kernel[ KERNEL_SIZE ];

		uniform vec2 resolution;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float kernelRadius;
		uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance; // avoid the influence of fragments which are too far away
        uniform float intensity;
		varying vec2 vUv;

		#include <packing>

        float linearize_depth(in float depth){
            float a = cameraFar / (cameraFar - cameraNear);
            float b = cameraFar * cameraNear / (cameraNear - cameraFar);
            return a + b / depth;
        }

        float reconstruct_depth(const in vec2 uv){
            float depth = texture2D(tDepth, uv).x;
            return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
        }

        float getDepth(vec2 uv) {
            #if defined( USE_LOGDEPTHBUF )
                return linearize_depth(reconstruct_depth(uv));
            #else
                return texture2D(tDepth, uv).x;
            #endif
        }
		// float getDepth( const in vec2 screenPosition ) {

		// 	return texture2D( tDepth, screenPosition ).x;

		// }

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				// float fragCoordZ = texture2D( tDepth, screenPosition ).x;
                float fragCoordZ = getDepth(screenPosition);
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		float getViewZ( const in float depth ) {

			#if PERSPECTIVE_CAMERA == 1

				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );

			#else

				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );

			#endif

		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {

			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];

			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );

			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;

		}

		vec3 getViewNormal( const in vec2 screenPosition ) {

			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );

		}

		void main() {

            vec3 sampleNormal = texture2D( tNormal, vUv ).xyz;
            if (length(sampleNormal) < 0.5) {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                return;
            }
            vec3 viewNormal = unpackRGBToNormal(sampleNormal);

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
            // float depth = texture2D( tDepth, vUv ).x;
            // float logDepthBufFC = 2.0 / ( log( cameraFar + 1.0 ) / log(2.0) );
            // float viewZ = -1.0 * (exp2(depth / (logDepthBufFC * 0.5)) - 1.0);

			vec3 viewPosition = getViewPosition( vUv, depth, viewZ );

			vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
			vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );

			// compute matrix used to reorient a kernel vector

			vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
			vec3 bitangent = cross( viewNormal, tangent );
			mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );

		 float occlusion = 0.0;

		 for ( int i = 0; i < KERNEL_SIZE; i ++ ) {

				vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
				vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point

				vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );
                // project point and calculate NDC
				samplePointNDC /= samplePointNDC.w;

				vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates

				float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
				float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );

                // realDepth = getDepth(samplePointUv);
                // // realDepth = reconstruct_depth(samplePointUv);
                // sampleDepth = viewZToPerspectiveDepth(samplePoint.z, cameraNear, cameraFar);

                // sampleDepth = log2(sampleDepth + 1.0) / log2(cameraFar + 1.0);
                // compute linear depth of the sample view Z value
				float delta = sampleDepth - realDepth;

				if ( delta > minDistance && delta < maxDistance ) {
                // if ( delta > 0.00001 && delta < 0.0001) {
                    // if fragment is before sample point, increase occlusion

                    // occlusion += 1.0;
					occlusion += 1.0 * length(sampleVector) * intensity;

				}

			}

			occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );

			gl_FragColor = vec4( vec3((1.0 - occlusion) ), 1.0 );

		}`
};
class SSAOPass extends Pass {
  constructor(i, e) {
    super(), this.width = i !== void 0 ? i : 512, this.height = e !== void 0 ? e : 512, this.clear = !0, this.kernelRadius = 0.5, this.kernelSize = 32, this.kernel = [], this.noiseTexture = null, this.intensity = 1, this.minDistance = 1e-5, this.maxDistance = 1e-4, this.generateSampleKernel(), this.generateRandomKernelRotations(), this.ssaoMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOShader.defines),
      uniforms: UniformsUtils.clone(SSAOShader.uniforms),
      vertexShader: SSAOShader.vertexShader,
      fragmentShader: SSAOShader.fragmentShader,
      blending: NoBlending
    }), this.ssaoMaterial.uniforms.tNoise.value = this.noiseTexture, this.ssaoMaterial.uniforms.kernel.value = this.kernel, this.blurMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOBlurShader.defines),
      uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),
      vertexShader: SSAOBlurShader.vertexShader,
      fragmentShader: SSAOBlurShader.fragmentShader
    }), this.copyMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      transparent: !0,
      depthTest: !1,
      depthWrite: !1,
      blendSrc: DstColorFactor,
      blendDst: ZeroFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: DstAlphaFactor,
      blendDstAlpha: ZeroFactor,
      blendEquationAlpha: AddEquation
    }), this.fsQuad = new FullScreenQuad(null), this.originalClearColor = new Color(), this.needsNormalTexture = !0, this.needsDepthTexture = !0;
  }
  dispose() {
    this.ssaoRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.normalMaterial.dispose(), this.blurMaterial.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose(), this.fsQuad.dispose();
  }
  render(i, e, r) {
    this.ssaoRenderTarget || (this.ssaoRenderTarget = new WebGLRenderTarget(r.width, r.height, {})), this.blurRenderTarget || (this.blurRenderTarget = new WebGLRenderTarget(r.width, r.height, {}));
    const s = this.rendering, a = s.main.sceneRendering.normalTexture, c = s.main.sceneRendering.depthTexture;
    this.ssaoMaterial.uniforms.tDiffuse.value = r.texture, this.ssaoMaterial.uniforms.tNormal.value = a, this.ssaoMaterial.uniforms.tDepth.value = c, this.ssaoMaterial.uniforms.cameraNear.value = s.camera.near, this.ssaoMaterial.uniforms.cameraFar.value = s.camera.far, this.ssaoMaterial.uniforms.resolution.value.set(r.width, r.height), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(s.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(s.camera.projectionMatrixInverse), this.ssaoMaterial.uniforms.kernelRadius.value = this.kernelRadius, this.ssaoMaterial.uniforms.minDistance.value = this.minDistance, this.ssaoMaterial.uniforms.maxDistance.value = this.maxDistance, this.ssaoMaterial.uniforms.intensity.value = this.intensity, this.renderPass(i, this.ssaoMaterial, this.ssaoRenderTarget), this.blurMaterial.uniforms.resolution.value.set(r.width, r.height), this.blurMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.renderPass(i, this.blurMaterial, this.blurRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = r.texture, this.copyMaterial.blending = NoBlending, this.renderPass(i, this.copyMaterial, this.renderToScreen ? null : e), this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = CustomBlending, this.renderPass(i, this.copyMaterial, this.renderToScreen ? null : e);
  }
  renderPass(i, e, r, s, a) {
    i.getClearColor(this.originalClearColor);
    const c = i.getClearAlpha(), l = i.autoClear;
    i.setRenderTarget(r), i.autoClear = !1, s != null && (i.setClearColor(s), i.setClearAlpha(a || 0), i.clear()), this.fsQuad.material = e, this.fsQuad.render(i), i.autoClear = l, i.setClearColor(this.originalClearColor), i.setClearAlpha(c);
  }
  setSize(i, e) {
    this.width = i, this.height = e, this.ssaoRenderTarget.setSize(i, e), this.blurRenderTarget.setSize(i, e);
  }
  generateSampleKernel() {
    const i = this.kernelSize, e = this.kernel;
    for (let r = 0; r < i; r++) {
      const s = new Vector3$1();
      s.x = Math.random() * 2 - 1, s.y = Math.random() * 2 - 1, s.z = Math.random(), s.normalize();
      let a = r / i;
      a = MathUtils.lerp(0.1, 1, a * a), s.multiplyScalar(a), e.push(s);
    }
  }
  generateRandomKernelRotations() {
    const r = new SimplexNoise(), s = 4 * 4, a = new Float32Array(s);
    for (let c = 0; c < s; c++) {
      const l = Math.random() * 2 - 1, h = Math.random() * 2 - 1, d = 0;
      a[c] = r.noise3d(l, h, d);
    }
    this.noiseTexture = new DataTexture(a, 4, 4, RedFormat, FloatType), this.noiseTexture.wrapS = RepeatWrapping, this.noiseTexture.wrapT = RepeatWrapping, this.noiseTexture.needsUpdate = !0;
  }
}
class FeatureAo extends Feature {
  constructor(e, r) {
    super(e, r);
    _(this, "name", "AO");
    _(this, "_method", "ssao");
    _(this, "_ssaoKernelRadius", 0.5);
    _(this, "_ssaoMinDistance", 1e-5);
    _(this, "_ssaoMaxDistance", 1e-4);
    _(this, "_ssaoIntensity", 1);
    _(this, "_lastMethod", "ssao");
    _(this, "_lastEnabled", !1);
    this.enabled = r.enabled, this._method = r.method;
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._enableNewMethod() : this._disableOldMethod();
      return;
    }
    this.enabled && this._lastMethod !== this._method && (this._disableOldMethod(), this._enableNewMethod());
  }
  _disableOldMethod() {
    const e = this._lastMethod, r = this._rendering;
    e === "ssao" && (this._ssaoPass && r.main.postprocessings.remove(this._ssaoPass), this._ssaoPass = null);
  }
  _enableNewMethod() {
    const e = this._method, r = this._rendering;
    if (e === "ssao") {
      const s = this._ssaoPass = new SSAOPass();
      s.kernelRadius = this._ssaoKernelRadius, s.minDistance = this._ssaoMinDistance, s.maxDistance = this._ssaoMaxDistance, s.intensity = this._ssaoIntensity, s.renderOrder = 900, s.rendering = r, r.main.postprocessings.add(s);
    }
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._lastMethod = this._method;
  }
  dispose() {
    this.enabled && this._disableOldMethod();
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
  get ssaoKernelRadius() {
    return this._ssaoKernelRadius;
  }
  set ssaoKernelRadius(e) {
    this._ssaoKernelRadius = e, this._ssaoPass && (this._ssaoPass.kernelRadius = e);
  }
  get ssaoMinDistance() {
    return this._ssaoMinDistance;
  }
  set ssaoMinDistance(e) {
    this._ssaoMinDistance = e, this._ssaoPass && (this._ssaoPass.minDistance = e);
  }
  get ssaoMaxDistance() {
    return this._ssaoMaxDistance;
  }
  set ssaoMaxDistance(e) {
    this._ssaoMaxDistance = e, this._ssaoPass && (this._ssaoPass.maxDistance = e);
  }
  get ssaoIntensity() {
    return this._ssaoIntensity;
  }
  set ssaoIntensity(e) {
    this._ssaoIntensity = e, this._ssaoPass && (this._ssaoPass.intensity = e);
  }
}
const vertex_shader = `#define GLSLIFY 1
varying vec2 vUv;

void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`, fragment_shader = `precision highp sampler2D;
#define GLSLIFY 1
varying vec2 vUv;
uniform sampler2D tDepth;
uniform sampler2D tNormal;
uniform sampler2D tMetalness;
uniform sampler2D tDiffuse;

#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
uniform sampler2D tEnhancement;
uniform vec2 tEnhancementScale;
uniform mat4 mvt_viewInverseMatrix;
uniform mat3 mvt_normalInverseMatrix;
#endif

uniform float cameraRange;
uniform vec2 resolution;
uniform float opacity;
uniform float cameraNear;
uniform float cameraFar;
uniform float maxDistance;
uniform float thickness;
uniform mat4 cameraProjectionMatrix;
uniform mat4 cameraInverseProjectionMatrix;
uniform float threshold; // \u63A7\u5236\u53CD\u5C04\u6700\u4F4E\u9608\u503C\uFF0C\u4F4E\u4E8E\u6B64\u81F4\u7684\u4E0D\u8BA1\u7B97\uFF0C\u53EF\u63D0\u9AD8\u6027\u80FD

#include <packing>
float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
    //x0: point, x1: linePointA, x2: linePointB
    //https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
    return length(cross(x0 - x1, x0 - x2)) / length(x2 - x1);
}
float pointPlaneDistance(vec3 point, vec3 planePoint, vec3 planeNormal) {
    // https://mathworld.wolfram.com/Point-PlaneDistance.html
    //// https://en.wikipedia.org/wiki/Plane_(geometry)
    //// http://paulbourke.net/geometry/pointlineplane/
    float a = planeNormal.x, b = planeNormal.y, c = planeNormal.z;
    float x0 = point.x, y0 = point.y, z0 = point.z;
    float x = planePoint.x, y = planePoint.y, z = planePoint.z;
    float d = -(a * x + b * y + c * z);
    float distance = (a * x0 + b * y0 + c * z0 + d) / sqrt(a * a + b * b + c * c);
    return distance;
}
// https://stackoverflow.com/questions/40373184/world-space-position-from-logarithmic-depth-buffer
float linearize_depth(in float depth) {
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float reconstruct_depth(const in vec2 uv) {
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float get_logarithmic_depth(const in vec2 uv) {
    float depth = texture2D(tDepth, uv).x;
    float logDepthBufFC = 2.0 / ( log( cameraFar + 1.0 ) / log(2.0) );
    float invViewZ = exp2(depth / (logDepthBufFC * 0.5)) - 1.0;
    return viewZToPerspectiveDepth(-invViewZ, cameraNear, cameraFar);
}
float getDepth(const in vec2 uv) {
    #if defined( USE_LOGDEPTHBUF )
    // return linearize_depth(reconstruct_depth(uv)); //exp2(logDepth * 2.0 / logDepthBufFC) - 1.0;
    return get_logarithmic_depth(uv);
    #else
    return texture2D(tDepth, uv).x;
    #endif

}
float getViewZ(const in float depth) {
    #ifdef PERSPECTIVE_CAMERA
    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    #else
    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
    #endif
}
vec3 getViewPosition(const in vec2 uv, const in float depth/*clip space*/, const in float clipW) {
    vec4 clipPosition = vec4((vec3(uv, depth) - 0.5) * 2.0, 1.0);//ndc
    clipPosition *= clipW; //clip
    return (cameraInverseProjectionMatrix * clipPosition).xyz;//view
}
#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
vec3 getWorldPositionFromDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = cameraInverseProjectionMatrix * clipSpacePosition;
    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;
    return worldSpacePosition.xyz / worldSpacePosition.w;
}
#endif
vec3 getViewNormal(const in vec2 uv) {
    return unpackRGBToNormal(texture2D(tNormal, uv).xyz);
}
vec2 viewPositionToXY(vec3 viewPosition) {
    vec2 xy;
    vec4 clip = cameraProjectionMatrix * vec4(viewPosition, 1);
    xy = clip.xy;//clip
    float clipW = clip.w;
    xy /= clipW;//NDC
    xy = (xy + 1.) / 2.;//uv
    xy *= resolution;//screen
    return xy;
}
void main() {

    gl_FragColor = texture2D(tDiffuse, vUv);
   
    vec3 sampleNormal = texture2D(tNormal, vUv).xyz;
    if (length(sampleNormal) < 0.9) {
        return;
    }

    vec3 viewNormal = unpackRGBToNormal(sampleNormal);
    float depth = getDepth(vUv);
    #ifdef SELECTIVE
    // \u5B8C\u5168\u6CA1\u53CD\u5C04\u7684\u8868\u9762\u76F4\u63A5\u5254\u9664
    float intensity = texture2D(tMetalness, vUv).x;

    #if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
        float dirAlpha = dot(viewNormal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));
        if (dirAlpha > 0.5) {
            vec3 worldSpacePosition = getWorldPositionFromDepth(depth);
            vec2 enhancementUv = vec2(mod(worldSpacePosition.x, tEnhancementScale.x) / tEnhancementScale.x, 
                    mod(worldSpacePosition.y, tEnhancementScale.y) / tEnhancementScale.y);
            float enhancement = texture2D(tEnhancement, enhancementUv).x;
            intensity += (1.0 - enhancement);
        }
        // gl_FragColor = vec4(enhancement, 0.0, 0.0, 1.0);
        // return;
    #endif

         
    if(intensity < threshold)
        return;
    intensity -= threshold;
    intensity *= 1.0 / (1.0 - threshold);
    #endif

    
    float viewZ = getViewZ(depth);
    // z\u503C\u5DF2\u7ECF\u8D85\u8FC7\u76F8\u673A\u8FDC\u7AEF\u8DDD\u79BB
    if(-viewZ >= cameraFar)
        return;

    float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
    // \u76F8\u673A\u89C6\u56FE\u4E0B\u7684\u5F53\u524D\u7247\u5143\u5750\u6807
    vec3 viewPosition = getViewPosition(vUv, depth, clipW);

    // \u8D77\u70B9\u7684\u5C4F\u5E55\u5750\u6807
    vec2 d0 = gl_FragCoord.xy;
    vec2 d1;

    #ifdef PERSPECTIVE_CAMERA
    // \u5165\u5C04\u5149\u65B9\u5411\uFF0C\u76F8\u673A\u5728\u539F\u70B9\uFF0C\u65B9\u5411\u5373\u4E3A\u5750\u6807\u7684\u5355\u4F4D\u5411\u91CF
    vec3 viewIncidentDir = normalize(viewPosition);
    // \u53CD\u5C04\u5149\u65B9\u5411
    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);
    #else
    vec3 viewIncidentDir = vec3(0, 0, -1);
    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);
    #endif

    // \u53CD\u5C04\u5149\u7EBF\u6700\u957F\u8DDD\u79BB\u7531\u8F93\u5165\u7684\u6700\u5927\u53CD\u5C04\u8DDD\u79BB\u548C\u5165\u5C04\u89D2\u51B3\u5B9A
    float maxReflectRayLen = maxDistance / dot(-viewIncidentDir, viewNormal);
    // dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
    // if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
    // maxDistance/maxReflectRayLen=cos(theta)
    // maxDistance/maxReflectRayLen==dot(a,b)
    // maxReflectRayLen==maxDistance/dot(a,b)

    // \u53CD\u5C04\u6700\u8FDC\u8DDD\u79BB\u4E0B\u7684\u5750\u6807\u70B9
    vec3 d1viewPosition = viewPosition + viewReflectDir * maxReflectRayLen;
    #ifdef PERSPECTIVE_CAMERA
    if(d1viewPosition.z > -cameraNear) {
            //https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
        // \u5E94\u8BE5\u662F\u5904\u7406\u53CD\u5C04\u70B9\u6EA2\u51FA\u76F8\u673A\u89C6\u91CE\u5916\u7684\u60C5\u51B5
        float t = (-cameraNear - viewPosition.z) / viewReflectDir.z;
        d1viewPosition = viewPosition + viewReflectDir * t;
    }
    #endif
    // \u53CD\u5C04\u6700\u8FDC\u70B9\u5728\u5C4F\u5E55\u4E0A\u7684\u4F4D\u7F6E
    d1 = viewPositionToXY(d1viewPosition);

    // \u5C4F\u5E55\u50CF\u7D20\u8DDD\u79BB
    float totalLen = length(d1 - d0);
    float xLen = d1.x - d0.x;
    float yLen = d1.y - d0.y;
    // \u6700\u5927\u6B65\u6570\u53D6xy\u65B9\u5411\u8F83\u5927\u7684\u4E00\u4E2A\u65B9\u5411\uFF0C\u6BCF\u6B21\u6B65\u8FDB\u4E00\u4E2A\u50CF\u7D20
    float totalStep = max(abs(xLen), abs(yLen));
    // x\u65B9\u5411\u6BCF\u6B21\u6B65\u8FDB\u7684\u5927\u5C0F
    float xSpan = xLen / totalStep;
    // y\u65B9\u5411\u6BCF\u6B21\u6B65\u8FDB\u7684\u5927\u5C0F
    float ySpan = yLen / totalStep;
    // \u6B65\u8FDB\u6B21\u6570\u6700\u5927\u662F\u5C4F\u5E55\u5BF9\u89D2\u7EBF\u8DDD\u79BB\uFF08\u5E94\u8BE5\u662F\u6A2A\u5411\u6216\u8005\u7EB5\u5411\u7684\u6700\u5927\u503C\uFF09\uFF0C\u5B9E\u9645\u6B21\u6570\u8981\u8FDC\u5C0F\u4E8E\u8FD9\u4E2A
    for(float i = 0.; i < float(MAX_STEP); i += 4.0) {
        if(i >= totalStep)
            break;
        // march\u5230\u7684\u5F53\u524D\u5C4F\u5E55\u50CF\u7D20
        vec2 xy = vec2(d0.x + i * xSpan, d0.y + i * ySpan);
        // \u8DD1\u5230\u5C4F\u5E55\u5916march\u5931\u8D25
        if(xy.x < 0. || xy.x > resolution.x || xy.y < 0. || xy.y > resolution.y)
            break;
        // \u5F53\u524D\u767E\u5206\u6BD4
        float s = length(xy - d0) / totalLen;
        // \u5F53\u524Duv
        vec2 uv = xy / resolution;
        // \u8BA1\u7B97\u5F53\u524D\u70B9\u7684\u5404\u9879\u53C2\u6570\uFF0C\u548C\u4E00\u5F00\u59CB\u4E00\u6837
        float d = getDepth(uv);
        float vZ = getViewZ(d);
        // gl_FragColor = vec4(-vZ / 1000., 0.0, 0.0, 1.0);
        // return;
        if(-vZ >= cameraFar)
            continue;
        float cW = cameraProjectionMatrix[2][3] * vZ + cameraProjectionMatrix[3][3];
        // \u5F97\u5230\u5F53\u524D\u70B9\u7684viewposition
        vec3 vP = getViewPosition(uv, d, cW);

        // \u5F97\u5230\u5F53\u524D\u53CD\u5C04\u7EBF\u7684z
        #ifdef PERSPECTIVE_CAMERA
            // https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
        float recipVPZ = 1. / viewPosition.z;
        float viewReflectRayZ = 1. / (recipVPZ + s * (1. / d1viewPosition.z - recipVPZ));
        #else
        float viewReflectRayZ = viewPosition.z + s * (d1viewPosition.z - viewPosition.z);
        #endif

        // if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
        // https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
        // \u53CD\u5C04\u7EBF\u7684z\u5C0F\u4E8E\u5F53\u524D\u70B9\u7684z,\u5426\u5219\u5C31\u662F\u88AB\u906E\u6321\u4F4F\u4E86
        if(viewReflectRayZ <= vZ) {

            bool hit;
            #ifdef INFINITE_THICK
            hit = true;
            #else
            // \u70B9\u5230\u5C04\u7EBF\u7684\u8DDD\u79BB
            float away = pointToLineDistance(vP, viewPosition, d1viewPosition);

            // minThickness\u6CA1\u770B\u61C2\uFF0C\u548C\u6A2A\u5411\u90BB\u63A5\u70B9\u7684viewx\u5DEE\u503C\uFF0C\u5927\u7EA6\u4EE3\u8868\u4E86\u6B64\u5904\u4E00\u4E2A\u50CF\u7D20\u548C\u5B9E\u9645\u8DDD\u79BB\u7684\u6BD4\u4F8B\uFF0C\u4E583.0\uFF1F
            float minThickness;
            vec2 xyNeighbor = xy;
            xyNeighbor.x += 1.;
            vec2 uvNeighbor = xyNeighbor / resolution;
            vec3 vPNeighbor = getViewPosition(uvNeighbor, d, cW);
            minThickness = vPNeighbor.x - vP.x;
            minThickness *= 3.;
            float tk = max(minThickness, thickness);
            // \u5F53\u8DDD\u79BB\u5C0F\u4E8E\u9608\u503C\u65F6\u624D\u7B97\u662F\u771F\u6B63\u76F8\u4EA4
            hit = away <= tk;
            #endif

            if(hit) {
                vec3 vN = getViewNormal(uv);
                // \u76F8\u4EA4\u5230\u7269\u4F53\u7684\u53CD\u9762\u4E86\uFF0Cmarch\u65E0\u6548
                if(dot(viewReflectDir, vN) >= 0.)
                    continue;
                float distance = pointPlaneDistance(vP, viewPosition, viewNormal);
                // march\u8DDD\u79BB\u8D85\u8FC7\u6700\u5927
                if(distance > maxDistance)
                    break;
                float op = opacity;
                // \u968F\u7740\u8DDD\u79BB\u51CF\u5F31\u53CD\u5C04\uFF0C\u9632\u6B62\u53CD\u5C04\u7A81\u7136\u6D88\u5931
                #ifdef DISTANCE_ATTENUATION
                float ratio = 1. - (distance / maxDistance);
                float attenuation = ratio * ratio;
                op = opacity * attenuation;
                #endif
                // \u83F2\u6D85\u5C14\u53CD\u5C04\u5B9A\u5F8B\uFF0C\u4E0E\u89C6\u91CE\u89D2\u5EA6\u504F\u79BB\u8D8A\u5927\uFF0C\u989C\u8272\u6743\u91CD\u8D8A\u5927
                #ifdef FRESNEL
                float fresnelCoe = (dot(viewIncidentDir, viewReflectDir) + 1.) / 2.;
                op *= fresnelCoe;
                #endif
                // \u8BFB\u53D6\u53CD\u5C04\u989C\u8272\u8D4B\u7ED9\u5F53\u524D\u7247\u5143
                gl_FragColor = texture2D(tDiffuse, vUv);
                vec4 reflectColor = texture2D(tDiffuse, uv);
                reflectColor.a = op;
                #ifdef SELECTIVE
                reflectColor.a *= intensity;
                #endif
                gl_FragColor.rgb = mix(gl_FragColor.rgb, reflectColor.rgb, reflectColor.a);
                // gl_FragColor = vec4(1.0, 0, 0, 1.0);
                return;
                
                // break;
            }
        }
    }
    // gl_FragColor = texture2D(tDiffuse, vUv);
}`, uniforms$s = {
  tDiffuse: { value: null },
  tNormal: { value: null },
  tMetalness: { value: null },
  tEnhancement: { value: null },
  tEnhancementScale: { value: new Vector2$1(20, 20) },
  tDepth: { value: null },
  cameraNear: { value: null },
  cameraFar: { value: null },
  resolution: { value: new Vector2$1() },
  cameraProjectionMatrix: { value: new Matrix4() },
  cameraInverseProjectionMatrix: { value: new Matrix4() },
  mvt_viewInverseMatrix: { value: new Matrix4() },
  mvt_normalInverseMatrix: { value: new Matrix3() },
  opacity: { value: 0.5 },
  maxDistance: { value: 180 },
  cameraRange: { value: 0 },
  thickness: { value: 0.018 },
  logDepthBufFC: { value: 1 },
  threshold: { value: 0.6 }
};
class SsrMaterial extends ShaderMaterial {
  constructor(i) {
    super(), this.vertexShader = vertex_shader, this.fragmentShader = fragment_shader, this.uniforms = UniformsUtils.clone(uniforms$s), this.defines = {
      MAX_STEP: 0,
      PERSPECTIVE_CAMERA: !0,
      DISTANCE_ATTENUATION: !0,
      FRESNEL: !0,
      INFINITE_THICK: !1,
      SELECTIVE: !1
    }, defineMaterialNormalProperties(this, [
      "tDiffuse",
      "tNormal",
      "tDepth",
      "tMetalness",
      "cameraNear",
      "cameraFar",
      "threshold",
      "thickness",
      "opacity",
      "tEnhancementScale"
    ]), defineMaterialBoolDefineProperties(this, []), Object.defineProperties(this, {
      tEnhancement: {
        get: function() {
          return this.uniforms.tEnhancement.value;
        },
        set: function(e) {
          e ? (this.uniforms.tEnhancement.value = e, this.defines.MVT_SSR_USE_ENHANCEMENT_MAP = !0) : (this.uniforms.tEnhancement.value = null, delete this.defines.MVT_SSR_USE_ENHANCEMENT_MAP);
        }
      }
    }), this.setValues(i);
  }
  dispose() {
    let i = [
      "tEnhancement",
      "tDiffuse",
      "tNormal",
      "tDepth",
      "tMetalness"
    ];
    for (let e = 0; e < i.length; e++) {
      const r = i[e];
      this.uniforms[r] && this.uniforms[r].value && this.uniforms[r].value.dispose();
    }
    super.dispose();
  }
}
class SSRPass extends Pass {
  constructor() {
    super();
    const i = this.material = new SsrMaterial();
    i.defines.DISTANCE_ATTENUATION = !0, i.defines.SELECTIVE = !0, this.fsQuad = new FullScreenQuad(null), this.needsSwap = !0, this.needsMetallicRoughTexture = !0, this.needsNormalTexture = !0, this.needsDepthTexture = !0;
  }
  render(i, e, r) {
    const s = this.rendering, a = s.main.sceneRendering, c = s.camera, l = this.material;
    l.uniforms.tDiffuse.value = r.texture, l.uniforms.tDepth.value = a.depthTexture, l.uniforms.tNormal.value = a.normalTexture, l.uniforms.tMetalness.value = a.metallicRoughTexture;
    const h = new Vector2$1(r.width, r.height);
    l.uniforms.resolution.value = h, l.defines.MAX_STEP = Math.min(512, Math.sqrt(h.x * h.x + h.y * h.y)), l.uniforms.cameraProjectionMatrix.value.copy(c.projectionMatrix), l.uniforms.cameraInverseProjectionMatrix.value.copy(c.projectionMatrixInverse), l.uniforms.mvt_viewInverseMatrix.value.copy(c.matrixWorld), l.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(c.matrixWorldInverse), l.uniforms.cameraNear.value = c.near, l.uniforms.cameraFar.value = c.far, this.fsQuad.material = l, i.setRenderTarget(this.renderToScreen ? null : e), i.clear(), this.fsQuad.render(i);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class FeatureReflection extends Feature {
  constructor(e, r) {
    super(e, r);
    _(this, "name", "reflection");
    _(this, "_method", "ssr");
    _(this, "_lastMethod", "ssr");
    _(this, "_lastEnabled", !1);
    this.enabled = r.enabled, this._method = r.method;
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._enableNewMethod() : this._disableOldMethod();
      return;
    }
    this.enabled && this._lastMethod !== this._method && (this._disableOldMethod(), this._enableNewMethod());
  }
  _disableOldMethod() {
    const e = this._lastMethod, r = this._rendering;
    e === "ssr" && (this._ssrPass && r.main.postprocessings.remove(this._ssrPass), this._ssrPass = null);
  }
  _enableNewMethod() {
    const e = this._method, r = this._rendering;
    if (e === "ssr") {
      const s = this._ssrPass = new SSRPass();
      s.renderOrder = 800, s.rendering = r, r.main.postprocessings.add(s);
    }
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._lastMethod = this._method;
  }
  dispose() {
    this.enabled && this._disableOldMethod();
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
}
const _cameraToLightMatrix$1 = new Matrix4(), _center$2 = new Vector3$1(), _bbox$1 = new Box3(), _lightOrientationMatrix$1 = new Matrix4(), _lightOrientationMatrixInverse$1 = new Matrix4(), _up$2 = new Vector3$1(0, 1, 0);
class ShadowFrustum {
  constructor() {
    _(this, "maxFar", 500);
    _(this, "lightMargin", 100);
    this.vertices = {
      near: [
        new Vector3$1(),
        new Vector3$1(),
        new Vector3$1(),
        new Vector3$1()
      ],
      far: [
        new Vector3$1(),
        new Vector3$1(),
        new Vector3$1(),
        new Vector3$1()
      ]
    };
  }
  updateFromCameraProjectionMatrix(i) {
    const e = i.projectionMatrixInverse;
    this.vertices.near[0].set(1, 1, -1), this.vertices.near[1].set(1, -1, -1), this.vertices.near[2].set(-1, -1, -1), this.vertices.near[3].set(-1, 1, -1), this.vertices.near.forEach(function(s) {
      s.applyMatrix4(e);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1);
    let r = this.maxFar;
    this.vertices.far.forEach((s) => {
      s.applyMatrix4(e);
      const a = Math.abs(s.z);
      s.multiplyScalar(Math.min(r / a, 1));
    });
  }
  updateShadowBounds(i, e) {
    const r = i.shadow.camera, s = this.vertices.near, a = this.vertices.far, c = a[0];
    let l;
    c.distanceTo(a[2]) > c.distanceTo(s[2]) ? l = a[2] : l = s[2];
    let h = c.distanceTo(l);
    h += this.lightMargin, r.left = -h / 2, r.right = h / 2, r.top = h / 2, r.bottom = -h / 2, r.updateProjectionMatrix();
  }
  updateLightPosition(i, e, r, s = 1024) {
    _lightOrientationMatrix$1.lookAt(new Vector3$1(), e, _up$2), _lightOrientationMatrixInverse$1.copy(_lightOrientationMatrix$1).invert();
    const a = i.shadow.camera, c = (a.right - a.left) / s, l = (a.top - a.bottom) / s;
    _cameraToLightMatrix$1.multiplyMatrices(_lightOrientationMatrixInverse$1, r.matrixWorld);
    for (let p = 0; p < 4; p++)
      this.vertices.near[p].copy(this.vertices.near[p]).applyMatrix4(_cameraToLightMatrix$1), this.vertices.far[p].copy(this.vertices.far[p]).applyMatrix4(_cameraToLightMatrix$1);
    const h = this.vertices.near, d = this.vertices.far;
    _bbox$1.makeEmpty();
    for (let p = 0; p < 4; p++)
      _bbox$1.expandByPoint(h[p]), _bbox$1.expandByPoint(d[p]);
    a.near = 0.1;
    const f = _bbox$1.max.z - _bbox$1.min.z;
    a.far = f + this.lightMargin, a.far <= a.near && (a.far = a.near + Math.max(1, f + 1)), _bbox$1.getCenter(_center$2), _center$2.z = _bbox$1.max.z + this.lightMargin, _center$2.x = Math.floor(_center$2.x / c) * c, _center$2.y = Math.floor(_center$2.y / l) * l, _center$2.applyMatrix4(_lightOrientationMatrix$1), i.position.copy(_center$2), i.target.position.copy(_center$2), i.target.position.x += e.x, i.target.position.y += e.y, i.target.position.z += e.z;
  }
}
class DefaultShadow {
  constructor(i, e) {
    _(this, "_maxDistance", 500);
    this._shadowFeature = i, this._rendering = e, this._shadowFrustum = new ShadowFrustum();
  }
  update(i, e) {
    const r = this._rendering._engine, s = this._shadowFeature.shadowMapSize;
    i.shadow.mapSize.x !== s && (i.shadow.map && (i.shadow.map.dispose(), i.shadow.map = null), i.shadow.mapSize.set(s, s), i.shadow.needsUpdate = !0);
    const a = r.camera;
    this._shadowFrustum.maxFar = this._shadowFeature.maxDistance || this._maxDistance, this._shadowFrustum.updateFromCameraProjectionMatrix(a), this._shadowFrustum.updateShadowBounds(i, a), this._shadowFrustum.updateLightPosition(
      i,
      new Vector3$1(-e.x, -e.y, -e.z),
      a,
      s
    ), i.updateMatrix(), i.updateMatrixWorld(), i.target.updateMatrix(), i.target.updateMatrixWorld(), i.shadow.camera.updateProjectionMatrix(), i.shadow.bias = -1e-3, this._currenLight = i;
  }
  getCurrentUsedTextures() {
    if (this._currenLight)
      return [this._currenLight.shadow.map.texture];
  }
  showCurrentShadowCamera() {
    const i = this._rendering;
    this._currentViewCamera ? this._currentViewCamera.copy(this._currenLight.shadow.camera) : this._currentViewCamera = this._currenLight.shadow.camera, this._currenLight.updateWorldMatrix(!0, !1), this._currentViewCamera.applyMatrix4(this._currenLight.matrixWorld), this._shadowCameraHelper || (this._shadowCameraHelper = new CameraHelper(this._currentViewCamera), i.add(this._shadowCameraHelper));
  }
  hideCurrentShadowCamera() {
    const i = this._rendering;
    this._shadowCameraHelper && (i.remove(this._shadowCameraHelper), this._shadowCameraHelper.dispose(), this._shadowCameraHelper = null);
  }
  dispose() {
  }
}
const CSMShader = {
  lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
 	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

  		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
		vec2 cascade;
		float cascadeCenter;
		float closestEdge;
		float margin;
		float csmx;
		float csmy;

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
				// NOTE: Depth gets larger away from the camera.
				// cascade.x is closer, cascade.y is further
				cascade = CSM_cascades[ i ];
				cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
				closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
				margin = 0.25 * pow( closestEdge, 2.0 );
				csmx = cascade.x - margin / 2.0;
				csmy = cascade.y + margin / 2.0;
				if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

					float dist = min( linearDepth - csmx, csmy - linearDepth );
					float ratio = clamp( dist / margin, 0.0, 1.0 );

					vec3 prevColor = directLight.color;
					directionalLightShadow = directionalLightShadows[ i ];
					directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

					bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
					directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

					ReflectedLight prevLight = reflectedLight;
					RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

					bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
					float blendRatio = shouldBlend ? ratio : 1.0;

					reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
					reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
					reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
					reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

				}
			#endif

		}
		#pragma unroll_loop_end
	#elif defined (USE_SHADOWMAP)

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

				directionalLightShadow = directionalLightShadows[ i ];
				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )
		// note: no loop here - all CSM lights are in fact one light only
		getDirectionalLightInfo( directionalLights[0], directLight );
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, directLight );

			RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,
  lights_pars_begin: `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + ShaderChunk.lights_pars_begin
}, inverseProjectionMatrix = new Matrix4();
class CSMFrustum {
  constructor(i) {
    i = i || {}, this.zNear = i.webGL === !0 ? -1 : 0, this.vertices = {
      near: [
        new Vector3$1(),
        new Vector3$1(),
        new Vector3$1(),
        new Vector3$1()
      ],
      far: [
        new Vector3$1(),
        new Vector3$1(),
        new Vector3$1(),
        new Vector3$1()
      ]
    }, i.projectionMatrix !== void 0 && this.setFromProjectionMatrix(i.projectionMatrix, i.maxFar || 1e4);
  }
  setFromProjectionMatrix(i, e) {
    const r = this.zNear, s = i.elements[2 * 4 + 3] === 0;
    return inverseProjectionMatrix.copy(i).invert(), this.vertices.near[0].set(1, 1, r), this.vertices.near[1].set(1, -1, r), this.vertices.near[2].set(-1, -1, r), this.vertices.near[3].set(-1, 1, r), this.vertices.near.forEach(function(a) {
      a.applyMatrix4(inverseProjectionMatrix);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function(a) {
      a.applyMatrix4(inverseProjectionMatrix);
      const c = Math.abs(a.z);
      s ? a.z *= Math.min(e / c, 1) : a.multiplyScalar(Math.min(e / c, 1));
    }), this.vertices;
  }
  split(i, e) {
    for (; i.length > e.length; )
      e.push(new CSMFrustum());
    e.length = i.length;
    for (let r = 0; r < i.length; r++) {
      const s = e[r];
      if (r === 0)
        for (let a = 0; a < 4; a++)
          s.vertices.near[a].copy(this.vertices.near[a]);
      else
        for (let a = 0; a < 4; a++)
          s.vertices.near[a].lerpVectors(this.vertices.near[a], this.vertices.far[a], i[r - 1]);
      if (r === i.length - 1)
        for (let a = 0; a < 4; a++)
          s.vertices.far[a].copy(this.vertices.far[a]);
      else
        for (let a = 0; a < 4; a++)
          s.vertices.far[a].lerpVectors(this.vertices.near[a], this.vertices.far[a], i[r]);
    }
  }
  toSpace(i, e) {
    for (let r = 0; r < 4; r++)
      e.vertices.near[r].copy(this.vertices.near[r]).applyMatrix4(i), e.vertices.far[r].copy(this.vertices.far[r]).applyMatrix4(i);
  }
}
class CSMHelper extends Group {
  constructor(i) {
    super(), this.csm = i, this.displayFrustum = !0, this.displayPlanes = !0, this.displayShadowBounds = !0;
    const e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(24), s = new BufferGeometry();
    s.setIndex(new BufferAttribute(e, 1)), s.setAttribute("position", new BufferAttribute(r, 3, !1));
    const a = new LineSegments(s, new LineBasicMaterial());
    this.add(a), this.frustumLines = a, this.cascadeLines = [], this.cascadePlanes = [], this.shadowLines = [];
  }
  updateVisibility() {
    const i = this.displayFrustum, e = this.displayPlanes, r = this.displayShadowBounds, s = this.frustumLines, a = this.cascadeLines, c = this.cascadePlanes, l = this.shadowLines;
    for (let h = 0, d = a.length; h < d; h++) {
      const f = a[h], p = c[h], m = l[h];
      f.visible = i, p.visible = i && e, m.visible = r;
    }
    s.visible = i;
  }
  update() {
    const i = this.csm, e = i.camera, r = i.cascades, s = i.mainFrustum, a = i.frustums, c = i.lights, h = this.frustumLines.geometry.getAttribute("position"), d = this.cascadeLines, f = this.cascadePlanes, p = this.shadowLines;
    if (e === null)
      return;
    for (this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.updateMatrixWorld(!0); d.length > r; )
      this.remove(d.pop()), this.remove(f.pop()), this.remove(p.pop());
    for (; d.length < r; ) {
      const x = new Box3Helper(new Box3(), 16777215), v = new MeshBasicMaterial({ transparent: !0, opacity: 0.1, depthWrite: !1, side: DoubleSide }), S = new Mesh(new PlaneGeometry(), v), E = new Group(), b = new Box3Helper(new Box3(), 16776960);
      E.add(b), this.add(x), this.add(S), this.add(E), d.push(x), f.push(S), p.push(E);
    }
    for (let x = 0; x < r; x++) {
      const v = a[x], E = c[x].shadow.camera, b = v.vertices.far, w = d[x], M = f[x], P = p[x], D = P.children[0];
      w.box.min.copy(b[2]), w.box.max.copy(b[0]), w.box.max.z += 1e-4, M.position.addVectors(b[0], b[2]), M.position.multiplyScalar(0.5), M.scale.subVectors(b[0], b[2]), M.scale.z = 1e-4, this.remove(P), P.position.copy(E.position), P.quaternion.copy(E.quaternion), P.scale.copy(E.scale), P.updateMatrixWorld(!0), this.attach(P), D.box.min.set(E.bottom, E.left, -E.far), D.box.max.set(E.top, E.right, -E.near);
    }
    const m = s.vertices.near, y = s.vertices.far;
    h.setXYZ(0, y[0].x, y[0].y, y[0].z), h.setXYZ(1, y[3].x, y[3].y, y[3].z), h.setXYZ(2, y[2].x, y[2].y, y[2].z), h.setXYZ(3, y[1].x, y[1].y, y[1].z), h.setXYZ(4, m[0].x, m[0].y, m[0].z), h.setXYZ(5, m[3].x, m[3].y, m[3].z), h.setXYZ(6, m[2].x, m[2].y, m[2].z), h.setXYZ(7, m[1].x, m[1].y, m[1].z), h.needsUpdate = !0;
  }
  dispose() {
    const i = this.frustumLines, e = this.cascadeLines, r = this.cascadePlanes, s = this.shadowLines;
    i.geometry.dispose(), i.material.dispose();
    const a = this.csm.cascades;
    for (let c = 0; c < a; c++) {
      const l = e[c], h = r[c], f = s[c].children[0];
      l.dispose(), h.geometry.dispose(), h.material.dispose(), f.dispose();
    }
  }
}
const _cameraToLightMatrix = new Matrix4(), _lightSpaceFrustum = new CSMFrustum(), _center$1 = new Vector3$1(), _bbox = new Box3(), _uniformArray = [], _logArray = [], _lightOrientationMatrix = new Matrix4(), _lightOrientationMatrixInverse = new Matrix4(), _up$1 = new Vector3$1(0, 0, 1);
function uniformSplit(o, i, e, r) {
  for (let s = 1; s < o; s++)
    r.push((i + (e - i) * s / o) / e);
  r.push(1);
}
function logarithmicSplit(o, i, e, r) {
  for (let s = 1; s < o; s++)
    r.push(i * (e / i) ** (s / o) / e);
  r.push(1);
}
function practicalSplit(o, i, e, r, s) {
  _uniformArray.length = 0, _logArray.length = 0, logarithmicSplit(o, i, e, _logArray), uniformSplit(o, i, e, _uniformArray);
  for (let a = 1; a < o; a++)
    s.push(MathUtils.lerp(_uniformArray[a - 1], _logArray[a - 1], r));
  s.push(1);
}
const _presetShadowBias = [
  -5e-4,
  -8e-4,
  -15e-4,
  -4e-3
];
class CSMShadow {
  constructor(i, e) {
    _(this, "_lights", null);
    _(this, "_light", null);
    _(this, "_parent", null);
    _(this, "_cascades", 4);
    _(this, "_maxFar", 1e3);
    _(this, "_shadowMapSize", 1024);
    _(this, "_lightNear", 1);
    _(this, "_lightFar", 1e3);
    _(this, "_lightMargin", 100);
    _(this, "_shadowBias", -5e-4);
    _(this, "_mainFrustum", null);
    _(this, "_frustums", []);
    _(this, "_breaks", []);
    _(this, "_helper", null);
    _(this, "_fade", !0);
    this._shadowFeature = i, this._rendering = e, this._engine = e._engine, this._uniforms = {
      CSM_cascades: {
        value: []
      },
      cameraNear: {
        value: 1
      },
      shadowFar: {
        value: 1e3
      }
    };
  }
  init() {
    this._old_lights_fragment_begin = ShaderChunk.lights_fragment_begin, this._old_lights_pars_begin = ShaderChunk.lights_pars_begin, ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin, ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;
  }
  update(i, e, r) {
    this._rendering._engine, this._light && this._light !== i && this._destroyLight(), this._light || (this._createLight(i, r), this._light = i);
    const s = new Vector3$1(-e.x, -e.y, -e.z);
    this.updateFrame(i, s);
  }
  updateFrame(i, e) {
    const r = this._engine.camera, s = this._frustums;
    _lightOrientationMatrix.lookAt(new Vector3$1(), e, _up$1), _lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert();
    for (let a = 0; a < s.length; a++) {
      const c = this._lights[a];
      c.color.copy(i.color), c.intensity = i.intensity;
      const l = c.shadow.camera, h = (l.right - l.left) / this._shadowMapSize, d = (l.top - l.bottom) / this._shadowMapSize;
      _cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse, r.matrixWorld), s[a].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);
      const f = _lightSpaceFrustum.vertices.near, p = _lightSpaceFrustum.vertices.far;
      _bbox.makeEmpty();
      for (let m = 0; m < 4; m++)
        _bbox.expandByPoint(f[m]), _bbox.expandByPoint(p[m]);
      _bbox.getCenter(_center$1), _center$1.z = _bbox.max.z + this._lightMargin, _center$1.x = Math.floor(_center$1.x / h) * h, _center$1.y = Math.floor(_center$1.y / d) * d, _center$1.applyMatrix4(_lightOrientationMatrix), c.position.copy(_center$1), c.target.position.copy(_center$1), c.target.position.x += e.x, c.target.position.y += e.y, c.target.position.z += e.z;
    }
  }
  _createLight(i, e) {
    this._parent = e, this._lights = [], this._light = i, this._mainLightCastShadow = i.castShadow, i.castShadow = !1, i.visible = !1;
    for (let r = 0; r < this._cascades; r++) {
      const s = new DirectionalLight(i.color, i.intensity);
      s.castShadow = !0, s.shadow.mapSize.width = this._shadowMapSize, s.shadow.mapSize.height = this._shadowMapSize, s.shadow.camera.near = this._lightNear, s.shadow.camera.far = this._lightFar, s.shadow.bias = this._shadowBias, s.shadow.bias = _presetShadowBias[r], s.shadow.normalBias = 1e-4, e.add(s), e.add(s.target), this._lights.push(s);
    }
    this._mainFrustum = new CSMFrustum(), this._frustums = [], this.updateFrustums();
  }
  getBreaks() {
    const e = this._rendering._engine.camera, r = Math.min(e.far, this._maxFar);
    this._breaks.length = 0, practicalSplit(this._cascades, e.near, r, 0.5, this._breaks), this._breaks = [0.05, 0.2, 0.45, 1], this.getExtendedBreaks(this._uniforms.CSM_cascades.value);
  }
  initCascades() {
    const e = this._rendering._engine.camera;
    this._mainFrustum.setFromProjectionMatrix(e.projectionMatrix, this._maxFar), this._mainFrustum.split(this._breaks, this._frustums);
  }
  updateShadowBounds() {
    const i = this._frustums;
    for (let e = 0; e < i.length; e++) {
      const s = this._lights[e].shadow.camera, a = i[e], c = a.vertices.near, l = a.vertices.far, h = l[0];
      let d;
      h.distanceTo(l[2]) > h.distanceTo(c[2]) ? d = l[2] : d = c[2];
      let f = h.distanceTo(d);
      const p = this._engine.camera, m = Math.max(p.far, this._maxFar), y = a.vertices.far[0].z / (m - p.near), x = 0.25 * Math.pow(y, 2) * (m - p.near);
      f += x * 2, s.left = -f / 2, s.right = f / 2, s.top = f / 2, s.bottom = -f / 2, s.updateProjectionMatrix();
    }
  }
  updateUniforms() {
    const i = this._engine.camera, e = Math.min(i.far, this._maxFar), r = this._uniforms;
    r.cameraNear.value = i.near, r.shadowFar.value = e;
  }
  getExtendedBreaks(i) {
    for (; i.length < this._breaks.length; )
      i.push(new Vector2$1());
    i.length = this._breaks.length;
    for (let e = 0; e < this._cascades; e++) {
      const r = this._breaks[e], s = this._breaks[e - 1] || 0;
      i[e].x = s, i[e].y = r;
    }
  }
  updateFrustums() {
    this.getBreaks(), this.initCascades(), this.updateShadowBounds(), this.updateUniforms();
  }
  updateCSMShadow(i, e) {
    i.defines || (i.defines = {}), this._fade && (i.defines.CSM_FADE = ""), i.defines.USE_CSM = 1, i.defines.CSM_CASCADES = this._cascades, e.uniforms.CSM_cascades = this._uniforms.CSM_cascades, e.uniforms.cameraNear = this._uniforms.cameraNear, e.uniforms.shadowFar = this._uniforms.shadowFar;
  }
  _destroyLight() {
    const i = this._light;
    i.castShadow = this._mainLightCastShadow, i.visible = !0, this._light = null;
    for (const e of this._lights)
      this._parent.remove(e), this._parent.remove(e.target);
  }
  dispose() {
    ShaderChunk.lights_fragment_begin = this._old_lights_fragment_begin, ShaderChunk.lights_pars_begin = this._old_lights_pars_begin, this._destroyLight();
  }
  getCurrentUsedTextures() {
    const i = [];
    for (const e of this._lights)
      i.push(e.shadow.map.texture);
    return i;
  }
  get shadowBias() {
    return this._shadowBias;
  }
  set shadowBias(i) {
    this._shadowBias = i;
    for (const e of this._lights)
      e.shadow.bias = i;
  }
  get showHelper() {
    return !!this._helper;
  }
  set showHelper(i) {
    i ? (this._helper || (this._helper = new CSMHelper(this._lights)), this._parent.add(this._helper)) : (this._parent.remove(this._helper), this._helper = null);
  }
}
class FeatureShadow extends Feature {
  constructor(e, r) {
    super(e, r);
    _(this, "name", "shadow");
    _(this, "_method", "default");
    _(this, "_lastMethod", "default");
    _(this, "_lastEnabled", !1);
    _(this, "_shadowMapSize", 2048);
    _(this, "_maxDistance", 0);
    _(this, "needsShaderKey", !0);
    _(this, "updateShadow", (e, r, s) => {
      this._method === "default" ? this._defaultShadow.update(e, r) : this._method === "csm" && this._csmShadow.update(e, r, s);
    });
    _(this, "getCurrentUsedTextures", () => {
      if (!!this.enabled) {
        if (this._method === "csm")
          return this._csmShadow.getCurrentUsedTextures();
        if (this._method === "default")
          return this._defaultShadow.getCurrentUsedTextures();
      }
    });
    _(this, "updateCSMShadow", (e, r) => {
      this._method === "csm" && this._csmShadow.updateCSMShadow(e, r);
    });
    this.enabled = r.enabled, this._method = r.method, r.shadowMapSize && (this._shadowMapSize = r.shadowMapSize);
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._enableNewMethod() : this._disableOldMethod();
      return;
    }
    this.enabled && this._lastMethod !== this._method && (this._disableOldMethod(), this._enableNewMethod());
  }
  _enableNewMethod() {
    const e = this._method, r = this._rendering;
    r.renderer.shadowMap.enabled = !0, e === "default" ? (this._defaultShadow = new DefaultShadow(this, r), this._currentShaderKey = "1") : e === "csm" && (this._csmShadow = new CSMShadow(this, r), this._csmShadow.init(), this._currentShaderKey = "2"), this._lastMethod = e;
  }
  _disableOldMethod() {
    const e = this._lastMethod, r = this._rendering;
    r.renderer.shadowMap.enabled = !1, e === "default" ? (this._defaultShadow.dispose(), this._defaultShadow = null) : e === "csm" && (this._csmShadow.dispose(), this._csmShadow = null), this._currentShaderKey = "0";
  }
  getCurrentShaderKey() {
    return this._currentShaderKey;
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._lastMethod = this._method;
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
  set shadowMapSize(e) {
    this._shadowMapSize = e;
  }
  get shadowMapSize() {
    return this._shadowMapSize;
  }
  set maxDistance(e) {
    this._maxDistance = e;
  }
  get maxDistance() {
    return this._maxDistance;
  }
}
const fragmentShader$u = `
#include <packing>
uniform sampler2D tDiffuse;
varying vec2 vUv;

void main() {

    gl_FragColor = packDepthToRGBA(texture2D(tDiffuse, vUv).r);
}
`, unpackDownscale = 255 / 256, unpackFactors = new Vector4(
  unpackDownscale / (256 * 256 * 256),
  unpackDownscale / (256 * 256),
  unpackDownscale / 256,
  unpackDownscale
), _tempVector4$4 = new Vector4();
class FeatureDepthPicking extends Feature {
  constructor() {
    super(...arguments);
    _(this, "name", "depthPicking");
    _(this, "_lastEnabled", !1);
    _(this, "needsDepthTexture", !0);
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
  }
  _init() {
    const e = this._rendering, r = e.resolution, s = e.pixelRatio;
    this._depthColorRenderTarget = new WebGLRenderTarget(
      r.x * s,
      r.y * s,
      {
        depthBuffer: !1
      }
    ), this._fsQuad = new FullScreenQuad(new ShaderMaterial({
      name: CopyShader.name,
      vertexShader: CopyShader.vertexShader,
      fragmentShader: fragmentShader$u,
      uniforms: {
        tDiffuse: {
          value: null
        },
        opacity: {
          value: 1
        }
      }
    }));
  }
  _unpackRGBAToDepth(e) {
    return _tempVector4$4.set(e[0] / 255, e[1] / 255, e[2] / 255, e[3] / 255), _tempVector4$4.dot(unpackFactors);
  }
  async pickDepth(e, r) {
    const s = this._rendering, a = s.renderer, c = s.pixelRatio, l = new Uint8Array(4);
    a.readRenderTargetPixels(
      this._depthColorRenderTarget,
      e * c,
      r * c,
      1,
      1,
      l
    );
    let h = this._unpackRGBAToDepth(l);
    if (h > 0.99 || h < 1e-6)
      return null;
    const d = s.camera, f = d.far, p = d.near, m = 2 / (Math.log(f + 1) / Math.log(2));
    let y = Math.pow(2, h / (m * 0.5)) - 1;
    return y = -y, h = (p + y) * f / ((f - p) * y), h;
  }
  afterRender() {
    if (!this.enabled)
      return;
    const e = this._rendering, r = e.main.sceneRendering;
    if (!r.depthTexture)
      return;
    this._fsQuad.material.uniforms.tDiffuse.value = r.depthTexture;
    const s = e.renderer, a = s.autoClear;
    s.autoClear = !1, s.setRenderTarget(this._depthColorRenderTarget), s.clear(), this._fsQuad.render(s), s.autoClear = a;
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    this._fsQuad.material.dispose(), this._fsQuad.dispose(), this._depthColorRenderTarget.dispose(), this._depthColorRenderTarget = null, this._fsQuad = null;
  }
  get viewTextures() {
    return this._depthColorRenderTarget ? [this._depthColorRenderTarget.texture] : null;
  }
}
const fragmentShader$t = `

uniform sampler2D tDiffuse;
varying vec2 vUv;

uniform float saturation;
uniform float brightness;
uniform float contrast;

void main() {
    vec4 outColor = texture2D(tDiffuse, vUv);
    vec3 grayscale = vec3(dot(outColor.xyz,  vec3(0.2126, 0.7152, 0.0722)));
    outColor.xyz = mix(grayscale, outColor.xyz, 1.0 + saturation);

    outColor.xyz = 0.5 + (1.0 + contrast) * (outColor.xyz - 0.5);
    outColor.xyz = outColor.xyz + brightness;
    gl_FragColor = outColor;
}
`;
class ColorAdjustmentPass extends Pass {
  constructor() {
    super();
    const i = CopyShader;
    this.uniforms = {
      tDiffuse: { value: null },
      saturation: { value: 1 },
      brightness: { value: 0 },
      contrast: { value: 1 }
    }, this.material = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: i.vertexShader,
      fragmentShader: fragmentShader$t,
      depthTest: !1,
      depthWrite: !1
    }), this.needsSwap = !0, this.fsQuad = new FullScreenQuad(null);
  }
  render(i, e, r) {
    const s = i.autoClear;
    i.autoClear = !1, this.fsQuad.material = this.material, this.material.uniforms.tDiffuse.value = r.texture, i.setRenderTarget(this.renderToScreen ? null : e), i.clear(), this.fsQuad.render(i), i.autoClear = s;
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
  get saturation() {
    return this.uniforms.saturation.value;
  }
  set saturation(i) {
    this.uniforms.saturation.value = i;
  }
  get brightness() {
    return this.uniforms.brightness.value;
  }
  set brightness(i) {
    this.uniforms.brightness.value = i;
  }
  get contrast() {
    return this.uniforms.contrast.value;
  }
  set contrast(i) {
    this.uniforms.contrast.value = i;
  }
}
class FeatureColorAdjustment extends Feature {
  constructor(e, r) {
    super(e, r);
    _(this, "name", "ColorAdjustment");
    _(this, "_saturation", 0);
    _(this, "_brightness", 0);
    _(this, "_contrast", 0);
    this.enabled = r.enabled, r.saturation !== void 0 && (this._saturation = r.saturation), r.brightness !== void 0 && (this._brightness = r.brightness), r.contrast !== void 0 && (this._contrast = r.contrast);
  }
  beginFrame() {
    if (this.enabled && !this._renderPass) {
      const e = this._renderPass = new ColorAdjustmentPass();
      e.saturation = this._saturation, e.brightness = this._brightness, e.contrast = this._contrast, this._rendering.main.postprocessings.add(this._renderPass);
    } else
      !this.enabled && this._renderPass && (this._rendering.main.postprocessings.remove(this._renderPass), this._renderPass.dispose(), this._renderPass = null);
  }
  afterRender() {
  }
  endFrame() {
  }
  dispose() {
    this._renderPass && (this._rendering.main.postprocessings.remove(this._renderPass), this._renderPass.dispose(), this._renderPass = null);
  }
  get saturation() {
    return this._saturation;
  }
  set saturation(e) {
    this._saturation = e, this._renderPass && (this._renderPass.saturation = e);
  }
  get brightness() {
    return this._brightness;
  }
  set brightness(e) {
    this._brightness = e, this._renderPass && (this._renderPass.brightness = e);
  }
  get contrast() {
    return this._contrast;
  }
  set contrast(e) {
    this._contrast = e, this._renderPass && (this._renderPass.contrast = e);
  }
}
const fragmentShader$s = `
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
uniform sampler2D tVideo;
uniform mat4 projectionInverseMatrix;
uniform mat4 viewInverseMatrix;
uniform mat4 videoProjectionMatrix;
uniform mat4 videoViewMatrix;
uniform float cameraNear;
uniform float cameraFar;
uniform float opacity;

uniform float k1, k2, k3;
uniform float p1, p2;

varying vec2 vUv;

#include <packing>
#include <mvt_depth_packing>

bool visible(vec4 result) {
    result.x /= result.w;
    result.y /= result.w;
    result.z /= result.w;

    return result.x >= -1.0 && result.x <= 1.0 &&
           result.y >= -1.0 && result.y <= 1.0 &&
           result.z >= -1.0 && result.z <= 1.0;
}

// \u7578\u53D8\u6821\u6B63\u51FD\u6570
vec2 undistort(vec2 uv) {
    // \u5C06\u7EB9\u7406\u5750\u6807\u8F6C\u6362\u5230[-1, 1]\u8303\u56F4
    vec2 uvNorm = uv * 2.0 - 1.0;

    float r2 = uvNorm.x * uvNorm.x + uvNorm.y * uvNorm.y;
    float radialDistortion = 1.0 + k1 * r2 + k2 * r2 * r2 + k3 * r2 * r2 * r2;
    float tangentialDistortionX = 2.0 * p1 * uvNorm.x * uvNorm.y + p2 * (r2 + 2.0 * uvNorm.x * uvNorm.x);
    float tangentialDistortionY = p1 * (r2 + 2.0 * uvNorm.y * uvNorm.y) + 2.0 * p2 * uvNorm.x * uvNorm.y;

    uvNorm.x = uvNorm.x * radialDistortion + tangentialDistortionX;
    uvNorm.y = uvNorm.y * radialDistortion + tangentialDistortionY;

    // \u5C06\u7EB9\u7406\u5750\u6807\u8F6C\u6362\u56DE[0, 1]\u8303\u56F4
    return (uvNorm + 1.0) / 2.0;
}

void main() {
    vec4 diffuseColor = texture2D(tDiffuse, vUv);
    vec4 outputColor = diffuseColor;

    // \u8BA1\u7B97\u5F53\u524D\u7247\u5143\u7684\u4E16\u754C\u5750\u6807
    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);
    vec3 worldPosition = mvtGetWorldPositionByDepth(depth, vUv, projectionInverseMatrix, viewInverseMatrix);

    vec4 videoPos= videoProjectionMatrix * videoViewMatrix * vec4(worldPosition, 1.0);

    // \u5728\u89C6\u91CE\u5185\u7684\u7247\u5143\u624D\u8FDB\u884C\u878D\u5408
    if (visible(videoPos) && depth <= 0.999999) {
        vec4 gytyPosition = videoProjectionMatrix * videoViewMatrix * vec4(worldPosition.xyz, 1.0);
        gytyPosition= gytyPosition / gytyPosition.w;
        float s = (gytyPosition.s + 1.0) / 2.0;
        float t = (gytyPosition.t + 1.0) / 2.0;
        vec2 uv_depth = vec2(s, t);

        // \u5BF9\u7EB9\u7406\u5750\u6807\u8FDB\u884C\u7578\u53D8\u6821\u6B63
        uv_depth = undistort(uv_depth);
        if (uv_depth.x >= 0.0 && uv_depth.x <= 1.0 && uv_depth.y >= 0.0 && uv_depth.y <= 1.0) {
            vec4 videoColor = texture2D(tVideo, uv_depth);
            outputColor = mix(diffuseColor, videoColor, opacity);
        }
    }

    gl_FragColor = outputColor;
}
`;
class CameraFusionPass extends Pass {
  constructor(i, e) {
    super(), this.name = "CameraFusionPass", this.needsSwap = !0, this._camera = e;
    const r = CopyShader;
    this.uniforms = UniformsUtils.merge([
      UniformsUtils.clone(r.uniforms),
      {
        tDepth: { value: null },
        tVideo: { value: i },
        projectionInverseMatrix: { value: new Matrix4() },
        viewInverseMatrix: { value: new Matrix4() },
        videoProjectionMatrix: { value: new Matrix4() },
        videoViewMatrix: { value: new Matrix4() },
        cameraNear: { value: null },
        cameraFar: { value: null },
        cameraPosition: { value: new Vector3$1() },
        opacity: { value: 0.5 },
        k1: { value: 0 },
        k2: { value: 0 },
        k3: { value: 0 },
        p1: { value: 0 },
        p2: { value: 0 }
      }
    ]), this.material = new ShaderMaterial({
      name: "VideoFusionMaterial",
      uniforms: this.uniforms,
      vertexShader: r.vertexShader,
      fragmentShader: fragmentShader$s
    }), this.fsQuad = new FullScreenQuad(this.material);
  }
  render(i, e, r) {
    const s = this.rendering.camera, a = this._camera, c = this.uniforms;
    c.tDiffuse.value = r.texture, c.tDepth.value = this.rendering.main.sceneRendering.depthTexture, c.projectionInverseMatrix.value.copy(s.projectionMatrixInverse), c.viewInverseMatrix.value.copy(s.matrixWorld), c.cameraNear.value = s.near, c.cameraFar.value = s.far, a && (c.videoProjectionMatrix.value.copy(a.projectionMatrix), c.videoViewMatrix.value.copy(a.matrixWorldInverse)), this.renderToScreen === !0 ? (i.setRenderTarget(null), this.fsQuad.render(i)) : (i.setRenderTarget(e), i.clear(), this.fsQuad.render(i));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
  set camera(i) {
    this._camera = i;
  }
  get camera() {
    return this._camera;
  }
  set texture(i) {
    this.uniforms.tVideo.value = i;
  }
  get texture() {
    return this.uniforms.tVideo.value;
  }
  set opacity(i) {
    this.uniforms.opacity.value = i;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
}
class FeatureCameraFusion extends Feature {
  constructor() {
    super(...arguments);
    _(this, "name", "CameraFusion");
    _(this, "_lastEnabled", !1);
    _(this, "_camera", null);
    _(this, "_texture", null);
    _(this, "_opacity", 0.5);
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
  }
  _init() {
    const e = this._rendering, r = this._renderPass = new CameraFusionPass(this._texture, this._camera);
    r.opacity = this._opacity, r.renderOrder = 600, e.main.postprocessings.add(this._renderPass);
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    this._rendering.main.postprocessings.remove(this._renderPass), this._renderPass && (this._renderPass.dispose(), this._renderPass = null);
  }
  set camera(e) {
    e !== this._camera && (this._camera && this._rendering._engine.remove(this._camera), this._rendering._engine.add(e), this._renderPass && (this._renderPass.camera = e), this._camera = e);
  }
  get camera() {
    return this._camera;
  }
  set texture(e) {
    this._texture = e, this._renderPass && (this._renderPass.texture = e);
  }
  get texture() {
    return this._texture;
  }
  set opacity(e) {
    this._opacity = e, this._renderPass && (this._renderPass.opacity = e);
  }
  get opacity() {
    return this._opacity;
  }
}
class FeatureHDR extends Feature {
  constructor() {
    super(...arguments);
    _(this, "name", "HDR");
    _(this, "_bufferType", UnsignedByteType);
    _(this, "_exposure", 1);
    _(this, "_lastEnabled", !1);
    _(this, "needsFloatRenderTarget", !0);
  }
  beginFrame() {
    this._lastEnabled, this._enabled;
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  set enabled(e) {
    this._enabled = !!e;
  }
  get enabled() {
    return this._enabled;
  }
  set exposure(e) {
    this._exposure = e;
  }
  get exposure() {
    return this._exposure;
  }
}
class Features {
  constructor(i, e) {
    _(this, "_features", []);
    this._rendering = i, this._bloom = new FeatureBloom(this._rendering, e.bloom), this._features.push(this._bloom), this._antialias = new FeatureAntialias(this._rendering, e.antialias), this._features.push(this._antialias), this._ao = new FeatureAo(this._rendering, e.ao), this._features.push(this._ao), this._reflection = new FeatureReflection(this._rendering, e.reflection), this._features.push(this._reflection), this._bufferView = new FeatureBufferView(this._rendering, e.bufferView), this._features.push(this._bufferView), this._stats = new FeatureStats(this._rendering, e.stats), this._features.push(this._stats), this._shadow = new FeatureShadow(this._rendering, e.shadow), this._features.push(this._shadow), this._depthPicking = new FeatureDepthPicking(this._rendering, e.depthPicking), this._features.push(this._depthPicking), this._colorAdjustment = new FeatureColorAdjustment(this._rendering, e.colorAdjustment), this._features.push(this._colorAdjustment), this._cameraFusion = new FeatureCameraFusion(this._rendering), this._features.push(this._cameraFusion), this._hdr = new FeatureHDR(this._rendering, e.hdr), this._features.push(this._hdr);
  }
  beginFrame() {
    for (const i of this._features)
      i.beginFrame();
  }
  afterRender() {
    for (const i of this._features)
      i.afterRender && i.afterRender();
  }
  endFrame() {
    for (const i of this._features)
      i.endFrame();
  }
  updateReqirements(i) {
    const e = [];
    for (const r of this._features)
      !r.enabled || (r.needsEmissiveTexture && (i.needsEmissiveTexture = !0), r.needsNormalTexture && (i.needsNormalTexture = !0), r.needsDepthTexture && (i.needsDepthTexture = !0), r.needsMetallicRoughTexture && (i.needsMetallicRoughTexture = !0), r.needsFloatRenderTarget && (i.needsFloatRenderTarget = !0), r.needsShaderKey && e.push(r.getCurrentShaderKey()));
    i.featuresShaderKey = e.join("");
  }
  isInStableRenderState() {
    return !0;
  }
  get ao() {
    return this._ao;
  }
  get bloom() {
    return this._bloom;
  }
  get stats() {
    return this._stats;
  }
  get bufferView() {
    return this._bufferView;
  }
  get antialias() {
    return this._antialias;
  }
  get reflection() {
    return this._reflection;
  }
  get features() {
    return this._features;
  }
  get shadow() {
    return this._shadow;
  }
  get depthPicking() {
    return this._depthPicking;
  }
  get colorAdjustment() {
    return this._colorAdjustment;
  }
  get cameraFusion() {
    return this._cameraFusion;
  }
  get hdr() {
    return this._hdr;
  }
}
class SharedFullScreenRenderTargets {
  constructor(i) {
    _(this, "_renderTargets", []);
    _(this, "_locks", []);
    _(this, "_maxRenderTargets", 10);
    this._rendering = i;
  }
  beginFrame() {
    this._resetLocks(), this._rendering.main.requirements.isRenderTargetTypeChanged() && this._disposeRenderTargets();
  }
  _disposeRenderTargets() {
    const i = this._renderTargets;
    for (let e = 0; e < this._maxRenderTargets; e++)
      i[e] && (i[e].dispose(), i[e] = null);
  }
  _resetLocks() {
    const i = this._locks;
    for (let e = 0; e < this._maxRenderTargets; e++)
      i[e] = !1;
  }
  getAvailableRenderTarget() {
    const i = this._renderTargets, e = this._locks, r = this._rendering, s = r.resolution, a = r.pixelRatio, c = r.main.requirements.getRenderTargetType();
    for (let l = 0; l < this._maxRenderTargets; l++)
      if (i[l] || (i[l] = new WebGLRenderTarget(s.x * a, s.y * a, {
        type: c,
        depthBuffer: !1,
        magFilter: NearestFilter,
        minFilter: NearestFilter,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1
      }), i[l].name = `SharedFullScreenRenderTarget_${l}`), !e[l])
        return e[l] = !0, i[l];
    throw new Error("No available render target");
  }
  releaseRenderTarget(i) {
    const e = this._renderTargets, r = this._locks;
    for (let s = 0; s < this._maxRenderTargets; s++)
      if (e[s] === i) {
        r[s] = !1;
        return;
      }
    console.warn("Invalid render target to release");
  }
  releaseRenderTargetByIndex(i) {
    const e = this._locks;
    if (i < 0 || i >= this._maxRenderTargets) {
      console.warn("Invalid render target to release");
      return;
    }
    e[i] = !1;
  }
  lockRenderTarget(i) {
    const e = this._renderTargets, r = this._locks;
    for (let s = 0; s < this._maxRenderTargets; s++)
      if (e[s] === i) {
        r[s] = !0;
        return;
      }
    console.warn("Invalid render target to lock");
  }
  setSize(i, e) {
    const r = this._renderTargets, s = this._rendering.pixelRatio;
    for (let a = 0; a < this._maxRenderTargets; a++)
      r[a] && r[a].setSize(i * s, e * s);
  }
  endFrame() {
  }
}
class RenderingMainNew {
  constructor(i, e) {
    _(this, "_rendering");
    _(this, "_requirements");
    _(this, "_useMRT", !1);
    _(this, "_lastUseMRT", null);
    _(this, "_sceneRendering");
    _(this, "_features");
    _(this, "_postprocessings");
    _(this, "_opaquePostprocessings");
    i._main = this, this._rendering = i, this._requirements = new RenderingRequirements(i), this._features = new Features(i, e.features), this._postprocessings = new Postprocessings(i), this._opaquePostprocessings = new OpaquePostprocessings(i), this._sharedFullScreenRenderTargets = new SharedFullScreenRenderTargets(i), i.postprocessings = this._postprocessings, i.opaquePostprocessings = this._opaquePostprocessings, i.sharedFullScreenRenderTargets = this._sharedFullScreenRenderTargets, i.features = this._features;
  }
  beginFrame() {
    const i = this._rendering;
    if (i.isUseMRTChanged || !this._sceneRendering) {
      let e = !0;
      this._sceneRendering && (e = this._sceneRendering.useFastEmissiveMethod, this._sceneRendering.dispose()), i.useMRT ? this._sceneRendering = new MRTSceneRendering(this._rendering) : this._sceneRendering = new DirectSceneRendering(this._rendering), this._sceneRendering.useFastEmissiveMethod = e;
    }
    this._features.beginFrame(), this._requirements.beginFrame(), this._sharedFullScreenRenderTargets.beginFrame(), this._sceneRendering.beginFrame(), this._opaquePostprocessings.beginFrame(), this._postprocessings.beginFrame();
  }
  render(i) {
    const r = this._rendering.renderState, s = this._sceneRendering, a = this._features, c = this._postprocessings, l = this._opaquePostprocessings, h = this._sharedFullScreenRenderTargets;
    let d = null;
    (this._rendering.useMRT || c.validCount > 0 || l.validCount > 0) && (d = h.getAvailableRenderTarget()), s.renderTarget = d, r.stage = RENDER_STAGE_SCENE, l.show(), s.render(i), l.hide(), r.stage = RENDER_STAGE_FEATURES, a.afterRender(), (this._rendering.useMRT || c.validCount > 0) && (r.stage = RENDER_STAGE_POSTPROCESSING, c.render());
  }
  isInStableRenderState() {
    return this._sceneRendering.isInStableRenderState() && this._features.isInStableRenderState() && this._postprocessings.isInStableRenderState() && this._opaquePostprocessings.isInStableRenderState();
  }
  endFrame() {
    this._requirements.endFrame(), this._features.endFrame(), this._sceneRendering.endFrame(), this._opaquePostprocessings.endFrame(), this._postprocessings.endFrame(), this._sharedFullScreenRenderTargets.endFrame();
  }
  setSize(i, e) {
    this._rendering, this._sceneRendering && this._sceneRendering.setSize(i, e), this._sharedFullScreenRenderTargets && this._sharedFullScreenRenderTargets.setSize(i, e), this._opaquePostprocessings && this._opaquePostprocessings.setSize(i, e), this._postprocessings && this._postprocessings.setSize(i, e);
  }
  get sceneRendering() {
    return this._sceneRendering;
  }
  get useFastEmissiveMethod() {
    return this._sceneRendering.useFastEmissiveMethod;
  }
  set useFastEmissiveMethod(i) {
    this._sceneRendering.useFastEmissiveMethod = i;
  }
  get antialias() {
    return !0;
  }
  get rendering() {
    return this._rendering;
  }
  get requirements() {
    return this._requirements;
  }
  get features() {
    return this._features;
  }
  get postprocessings() {
    return this._postprocessings;
  }
  get opaquePostprocessings() {
    return this._opaquePostprocessings;
  }
}
const defaultGeoBoundingBox = new Box3(new Vector3$1(-180, -90, -100), new Vector3$1(180, 90, 100));
defaultGeoBoundingBox.isDefault = !0;
Object.freeze(defaultGeoBoundingBox);
Object.freeze(defaultGeoBoundingBox.min);
Object.freeze(defaultGeoBoundingBox.max);
const _tempVector3In = new Vector3$1(), _tempVector3Out = new Vector3$1(), projectBoundingBoxMethods = {
  MIN_MAX: 1,
  FOUR_CORNERS: 2,
  FOUR_CORNERS_WITH_EQUATOR: 3
};
class Projection {
  constructor() {
    _(this, "isProjection", !0);
    _(this, "isGeo", !1);
    _(this, "isAxisAligned", !1);
    _(this, "projectBoundingBoxMethod", projectBoundingBoxMethods.MIN_MAX);
  }
  projectCoordinate(i, e) {
    throw new Error("projectCoordinate() must be implemented in derived classes");
  }
  unprojectCoordinate(i, e) {
    throw new Error("unprojectCoordinate() must be implemented in derived classes");
  }
  geoBoxToProjectedBox(i, e, r = !0) {
    if (e || (e = new Box3()), this.projectBoundingBoxMethod === projectBoundingBoxMethods.MIN_MAX)
      this.projectCoordinate(i.min, e.min, r), this.projectCoordinate(i.max, e.max, r);
    else if (this.projectBoundingBoxMethod === projectBoundingBoxMethods.FOUR_CORNERS || this.projectBoundingBoxMethod === projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR) {
      let {
        x: s,
        y: a,
        z: c
      } = i.min, {
        x: l,
        y: h,
        z: d
      } = i.max;
      _tempVector3In.set(s, a, c), this.projectCoordinate(_tempVector3In, _tempVector3Out, r), e.expandByPoint(_tempVector3Out), _tempVector3In.set(l, h, d), this.projectCoordinate(_tempVector3In, _tempVector3Out, r), e.expandByPoint(_tempVector3Out), _tempVector3In.set(s, h, 0), this.projectCoordinate(_tempVector3In, _tempVector3Out, r), e.expandByPoint(_tempVector3Out), _tempVector3In.set(l, a, 0), this.projectCoordinate(_tempVector3In, _tempVector3Out, r), e.expandByPoint(_tempVector3Out), this.projectBoundingBoxMethod === projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR && a < 0 && h > 0 && (_tempVector3In.set(s, 0, 0), this.projectCoordinate(_tempVector3In, _tempVector3Out, r), e.expandByPoint(_tempVector3Out), _tempVector3In.set(l, 0, 0), this.projectCoordinate(_tempVector3In, _tempVector3Out, r), e.expandByPoint(_tempVector3Out));
    }
    return e;
  }
  getGeodeticSurfaceNormal(i, e) {
    return e || (e = new Vector3$1()), e.set(0, 0, 1), e;
  }
  getProjectedSurfaceNormal(i, e) {
    return e || (e = new Vector3$1()), e.set(0, 0, 1), e;
  }
  projectedBoxToGeoBox(i, e, r = !0) {
    return e || (e = new Box3()), this.unprojectCoordinate(i.min, e.min, r), this.unprojectCoordinate(i.max, e.max, r), e;
  }
  equals(i) {
    return i ? this.name === i.name : !1;
  }
  localFrameToFixedFrame(i, e) {
    return e || (e = new Matrix4()), e.identity(), e.setPosition(i), e;
  }
  get geoBoundingBox() {
    return this._geoBoundingBox || defaultGeoBoundingBox;
  }
  get projectedBoundingBox() {
    if (!this._projectedBoundingBox) {
      const i = this.geoBoundingBox;
      this._projectedBoundingBox = this.geoBoxToProjectedBox(i, null, !1);
    }
    return this._projectedBoundingBox;
  }
}
const extendUnprojectCoordinate = (o, i, e, r, s = !1) => {
  if (Math.abs(o) < r)
    return i;
  const a = o > 0 ? 1 : -1;
  if (s)
    return a * e;
  const l = (Math.abs(o) - r) / r;
  return a * (e * (1 + l));
}, extendProjectCoordinate = (o, i, e, r, s = !1) => {
  if (Math.abs(o) < e)
    return i;
  const a = o > 0 ? 1 : -1;
  if (s)
    return a * r;
  const l = (Math.abs(o) - e) / e;
  return a * (r * (1 + l));
}, D2R = Math.PI / 180, A$1 = 6378137, MAXEXTENT = 20037508, R2D = 180 / Math.PI, MAXLON = 85.0511287798;
function toMercator(o, i = null, e = !1) {
  var r = Math.abs(o[0]) <= 180 ? o[0] : o[0] - sign(o[0]) * 360;
  const s = i || [0, 0];
  return s[0] = A$1 * r * D2R, s[1] = A$1 * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * o[1] * D2R)), e ? (s[0] = extendProjectCoordinate(o[0], s[0], 180, MAXEXTENT), s[1] = extendProjectCoordinate(o[1], s[1], MAXLON, MAXEXTENT)) : (s[0] > MAXEXTENT && (s[0] = MAXEXTENT), s[0] < -MAXEXTENT && (s[0] = -MAXEXTENT), s[1] > MAXEXTENT && (s[1] = MAXEXTENT), s[1] < -MAXEXTENT && (s[1] = -MAXEXTENT)), s;
}
function toWgs84(o, i, e = !1) {
  const r = i || [0, 0];
  return r[0] = o[0] * R2D / A$1, r[1] = (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-o[1] / A$1))) * R2D, e && (r[0] = extendUnprojectCoordinate(o[0], r[0], 180, MAXEXTENT), r[1] = extendUnprojectCoordinate(o[1], r[1], MAXLON, MAXEXTENT)), r;
}
function sign(o) {
  return o < 0 ? -1 : o > 0 ? 1 : 0;
}
const _tempCoordinate = [0, 0], _inputArray$1 = [0, 0];
class WebMercatorProjection extends Projection {
  constructor() {
    super(...arguments);
    _(this, "name", PROJECTION_WEB_MERCATOR);
    _(this, "isAxisAligned", !0);
  }
  projectCoordinate(e, r, s = !1) {
    _inputArray$1[0] = e.x, _inputArray$1[1] = e.y, s || (_inputArray$1[0] < -180 && (_inputArray$1[0] = -180), _inputArray$1[0] > 180 && (_inputArray$1[0] = 180), _inputArray$1[1] < -85.0511287798 && (_inputArray$1[1] = -85.0511287798), _inputArray$1[1] > 85.0511287798 && (_inputArray$1[1] = 85.0511287798));
    const a = toMercator(_inputArray$1, _tempCoordinate, s);
    return r || (r = new Vector3$1()), r.x = a[0], r.y = a[1], r.z = e.z, r;
  }
  unprojectCoordinate(e, r, s = !1) {
    const a = toWgs84([e.x, e.y], _tempCoordinate, s);
    return r || (r = new Vector3$1()), r.x = a[0], r.y = a[1], r.z = e.z, r;
  }
}
class Cartesian4 {
  static clone(i, e) {
    return e || (e = new Vector4()), e.copy(i), e;
  }
  static fromElements(i, e, r, s, a) {
    return a || (a = new Vector4()), a.set(i, e, r, s), a;
  }
  static lerp(i, e, r, s) {
    return s || (s = new Vector4()), s.lerpVectors(i, e, r), s;
  }
  static equals(i, e) {
    return i.equals(e);
  }
  static normalize(i, e) {
    return i === e ? (i.normalize(), i) : (e.copy(i), e.normalize(), e);
  }
  static add(i, e, r) {
    return r || (r = new Vector4()), r.addVectors(i, e);
  }
  static multiplyByScalar(i, e, r) {
    return r || (r = new Vector4()), r.copy(i).multiplyScalar(e), r;
  }
  static subtract(i, e, r) {
    return r || (r = new Vector4()), r.subVectors(i, e), r;
  }
  static distance(i, e) {
    return i.distanceTo(e);
  }
}
_(Cartesian4, "ZERO", new Vector4(0, 0, 0, 0)), _(Cartesian4, "UNIT_W", Object.freeze(new Vector4(0, 0, 0, 1)));
const scratchNormal$1 = new Vector3$1(), scratchCartesian$4 = new Vector3$1(), scratchInverseTranspose = new Matrix4(), scratchPlaneCartesian4 = new Vector4(0, 0, 0, 0), scratchTransformNormal = new Vector3$1();
class StaticPlane {
  static fromPointNormal(i, e, r) {
    return r || (r = new Plane()), r.setFromNormalAndCoplanarPoint(e, i), r;
  }
  static fromCartesian4(i, e) {
    const r = Cartesian3.fromCartesian4(i, scratchNormal$1), s = i.w;
    if (!CesiumMath.equalsEpsilon(
      Cartesian3.magnitude(r),
      1,
      CesiumMath.EPSILON6
    ))
      throw new Error("normal must be normalized.");
    return defined$1(e) ? (Cartesian3.clone(r, e.normal), e.constant = s, e) : new StaticPlane(r, s);
  }
  static getPointDistance(i, e) {
    return Cartesian3.dot(i.normal, e) + i.constant;
  }
  static projectPointOntoPlane(i, e, r) {
    defined$1(r) || (r = new Vector3$1());
    const s = StaticPlane.getPointDistance(i, e), a = Cartesian3.multiplyByScalar(
      i.normal,
      s,
      scratchCartesian$4
    );
    return Cartesian3.subtract(e, a, r);
  }
  static transform(i, e, r) {
    const s = i.normal, a = i.constant, c = Matrix4.inverseTranspose(
      e,
      scratchInverseTranspose
    );
    let l = Cartesian4.fromElements(
      s.x,
      s.y,
      s.z,
      a,
      scratchPlaneCartesian4
    );
    l = Matrix4.multiplyByVector(
      c,
      l,
      l
    );
    const h = Cartesian3.fromCartesian4(
      l,
      scratchTransformNormal
    );
    return l = Cartesian4.divideByScalar(
      l,
      Cartesian3.magnitude(h),
      l
    ), Plane.fromCartesian4(l, r);
  }
  static clone(i, e) {
    return defined$1(e) ? (Cartesian3.clone(i.normal, e.normal), e.constant = i.constant, e) : new StaticPlane(i.normal, i.constant);
  }
  static equals(i, e) {
    return i.constant === e.constant && Cartesian3.equals(i.normal, e.normal);
  }
}
Plane.ORIGIN_XY_PLANE = Object.freeze(new StaticPlane(Cartesian3.UNIT_Z, 0));
Plane.ORIGIN_YZ_PLANE = Object.freeze(new StaticPlane(Cartesian3.UNIT_X, 0));
Plane.ORIGIN_ZX_PLANE = Object.freeze(new StaticPlane(Cartesian3.UNIT_Y, 0));
const scratchCart4 = new Vector4(0, 0, 0, 0), scratchProjectPointOntoPlaneRay$1 = new Ray(), scratchProjectPointOntoPlaneCartesian3$1 = new Vector3$1();
class EllipsoidTangentPlane {
  constructor(i, e) {
    if (e = defaultValue(e, Ellipsoid.WGS84), i = e.scaleToGeodeticSurface(i), !defined$1(i))
      throw new DeveloperError(
        "origin must not be at the center of the ellipsoid."
      );
    const r = Transforms.eastNorthUpToFixedFrame(i, e);
    this._ellipsoid = e, this._origin = i, this._xAxis = Cartesian3.fromCartesian4(
      StaticMatrix4.getColumn(r, 0, scratchCart4)
    ), this._yAxis = Cartesian3.fromCartesian4(
      StaticMatrix4.getColumn(r, 1, scratchCart4)
    );
    const s = Cartesian3.fromCartesian4(
      StaticMatrix4.getColumn(r, 2, scratchCart4)
    );
    this._plane = StaticPlane.fromPointNormal(i, s);
  }
  static fromPoints(i, e) {
    let r = i[0].x, s = i[0].y, a = i[0].z, c = i[0].x, l = i[0].y, h = i[0].z;
    for (let y = 0; y < i.length; y++) {
      const x = i[y], v = x.x, S = x.y, E = x.z;
      r = Math.min(v, r), c = Math.max(v, c), s = Math.min(S, s), l = Math.max(S, l), a = Math.min(E, a), h = Math.max(E, h);
    }
    const d = new Vector3$1(r, s, a), f = new Vector3$1(c, l, h), p = new Box3(d, f);
    let m = new Vector3$1();
    return m = p.getCenter(m), new EllipsoidTangentPlane(m, e);
  }
  projectPointToNearestOnPlane(i, e) {
    defined$1(e) || (e = new Cartesian2());
    const r = scratchProjectPointOntoPlaneRay$1;
    r.origin = i, Cartesian3.clone(this._plane.normal, r.direction);
    let s = IntersectionTests.rayPlane(
      r,
      this._plane,
      scratchProjectPointOntoPlaneCartesian3$1
    );
    if (defined$1(s) || (Cartesian3.negate(r.direction, r.direction), s = IntersectionTests.rayPlane(
      r,
      this._plane,
      scratchProjectPointOntoPlaneCartesian3$1
    )), defined$1(s)) {
      const a = Cartesian3.subtract(
        s,
        this._origin,
        s
      ), c = Cartesian3.dot(this._xAxis, a), l = Cartesian3.dot(this._yAxis, a);
      return defined$1(e) ? (e.x = c, e.y = l, e) : new Vector2$1(c, l);
    }
  }
  projectPointsOntoPlane(i, e) {
    defined$1(e) || (e = []);
    let r = 0;
    const s = i.length;
    for (let a = 0; a < s; a++) {
      const c = this.projectPointOntoPlane(i[a], e[r]);
      c && (e[r] = c, r++);
    }
    return e.length = r, e;
  }
  projectPointOntoPlane(i, e) {
    const r = scratchProjectPointOntoPlaneRay$1;
    r.origin = i, Cartesian3.normalize(i, r.direction);
    let s = IntersectionTests.rayPlane(
      r,
      this._plane,
      scratchProjectPointOntoPlaneCartesian3$1
    );
    if (defined$1(s) || (Cartesian3.negate(r.direction, r.direction), s = IntersectionTests.rayPlane(
      r,
      this._plane,
      scratchProjectPointOntoPlaneCartesian3$1
    )), defined$1(s)) {
      const a = Cartesian3.subtract(
        s,
        this._origin,
        s
      ), c = Cartesian3.dot(this._xAxis, a), l = Cartesian3.dot(this._yAxis, a);
      return defined$1(e) ? (e.x = c, e.y = l, e) : new Vector2$1(c, l);
    }
  }
  get ellipsoid() {
    return this._ellipsoid;
  }
  get origin() {
    return this._origin;
  }
  get plane() {
    return this._plane;
  }
  get xAxis() {
    return this._xAxis;
  }
  get yAxis() {
    return this._yAxis;
  }
  get zAxis() {
    return this._plane.normal;
  }
}
const Intersect = {
  OUTSIDE: -1,
  INTERSECTING: 0,
  INSIDE: 1
}, Intersect$1 = Object.freeze(Intersect);
class OrientedBoundingBox {
  constructor(i, e) {
    this.isOrientedBoundingBox = !0, this.center = Cartesian3.clone(defaultValue(i, Cartesian3.ZERO), new Vector3$1()), this.halfAxes = StaticMatrix3.clone(defaultValue(e, StaticMatrix3.ZERO));
  }
  intersectPlane(i) {
    return OrientedBoundingBox.intersectPlane(this, i);
  }
  distanceSquaredTo(i) {
    return OrientedBoundingBox.distanceSquaredTo(this, i);
  }
  computeCorners(i) {
    return OrientedBoundingBox.computeCorners(this, i);
  }
  getCenter(i) {
    return defined$1(i) ? (i.copy(this.center), i) : this.center.clone();
  }
  intersectsObb(i) {
    const e = this.center, r = i.center, s = this.halfAxes, a = i.halfAxes, c = new Vector3$1().subVectors(r, e), l = new Vector3$1(s.elements[0], s.elements[1], s.elements[2]), h = new Vector3$1(s.elements[3], s.elements[4], s.elements[5]), d = new Vector3$1(s.elements[6], s.elements[7], s.elements[8]), f = new Vector3$1(a.elements[0], a.elements[1], a.elements[2]), p = new Vector3$1(a.elements[3], a.elements[4], a.elements[5]), m = new Vector3$1(a.elements[6], a.elements[7], a.elements[8]), y = l.length(), x = h.length(), v = d.length();
    l.normalize(), h.normalize(), d.normalize();
    const S = f.length(), E = p.length(), b = m.length();
    f.normalize(), p.normalize(), m.normalize();
    let w, M, P;
    return w = y, M = S * Math.abs(l.dot(f)) + E * Math.abs(l.dot(p)) + b * Math.abs(l.dot(m)), P = Math.abs(c.dot(l)), !(P > w + M || (w = x, M = S * Math.abs(h.dot(f)) + E * Math.abs(h.dot(p)) + b * Math.abs(h.dot(m)), P = Math.abs(c.dot(h)), P > w + M) || (w = v, M = S * Math.abs(d.dot(f)) + E * Math.abs(d.dot(p)) + b * Math.abs(d.dot(m)), P = Math.abs(c.dot(d)), P > w + M) || (w = y * Math.abs(f.dot(l)) + x * Math.abs(f.dot(h)) + v * Math.abs(f.dot(d)), M = S, P = Math.abs(c.dot(f)), P > w + M) || (w = y * Math.abs(p.dot(l)) + x * Math.abs(p.dot(h)) + v * Math.abs(p.dot(d)), M = E, P = Math.abs(c.dot(p)), P > w + M) || (w = y * Math.abs(m.dot(l)) + x * Math.abs(m.dot(h)) + v * Math.abs(m.dot(d)), M = b, P = Math.abs(c.dot(m)), P > w + M));
  }
}
const scratchOffset$1 = new Vector3$1(), scratchScale$1 = new Vector3$1();
function fromPlaneExtents(o, i, e, r, s, a, c, l, h, d, f) {
  if (!defined$1(s) || !defined$1(a) || !defined$1(c) || !defined$1(l) || !defined$1(h) || !defined$1(d))
    throw new DeveloperError(
      "all extents (minimum/maximum X/Y/Z) are required."
    );
  defined$1(f) || (f = new OrientedBoundingBox());
  const p = f.halfAxes;
  StaticMatrix3.setColumn(p, 0, i, p), StaticMatrix3.setColumn(p, 1, e, p), StaticMatrix3.setColumn(p, 2, r, p);
  let m = scratchOffset$1;
  m.x = (s + a) / 2, m.y = (c + l) / 2, m.z = (h + d) / 2;
  const y = scratchScale$1;
  y.x = (a - s) / 2, y.y = (l - c) / 2, y.z = (d - h) / 2;
  const x = f.center;
  return m = StaticMatrix3.multiplyByVector(p, m, m), Cartesian3.add(o, m, x), StaticMatrix3.multiplyByScale(p, y, p), f;
}
const scratchRectangleCenterCartographic = new Vector3$1(), scratchRectangleCenter = new Vector3$1(), scratchPerimeterCartographicNC = new Vector3$1(), scratchPerimeterCartographicNW = new Vector3$1(), scratchPerimeterCartographicCW = new Vector3$1(), scratchPerimeterCartographicSW = new Vector3$1(), scratchPerimeterCartographicSC = new Vector3$1(), scratchPerimeterCartesianNC = new Vector3$1(), scratchPerimeterCartesianNW = new Vector3$1(), scratchPerimeterCartesianCW = new Vector3$1(), scratchPerimeterCartesianSW = new Vector3$1(), scratchPerimeterCartesianSC = new Vector3$1(), scratchPerimeterProjectedNC = new Vector2$1(), scratchPerimeterProjectedNW = new Vector2$1(), scratchPerimeterProjectedCW = new Vector2$1(), scratchPerimeterProjectedSW = new Vector2$1(), scratchPerimeterProjectedSC = new Vector2$1(), scratchPlaneOrigin = new Vector3$1(), scratchPlaneNormal = new Vector3$1(), scratchPlaneXAxis = new Vector3$1(), scratchHorizonCartesian = new Vector3$1(), scratchHorizonProjected = new Vector2$1(), scratchMaxY = new Vector3$1(), scratchMinY = new Vector3$1(), scratchZ = new Vector3$1(), scratchPlane$1 = new Plane(new Vector3$1(1, 0, 0), 0);
OrientedBoundingBox.fromRectangle = function(o, i, e, r, s) {
  if (!defined$1(o))
    throw new DeveloperError("rectangle is required");
  if (o.width < 0 || o.width > CesiumMath.TWO_PI)
    throw new DeveloperError("Rectangle width must be between 0 and 2 * pi");
  if (o.height < 0 || o.height > CesiumMath.PI)
    throw new DeveloperError("Rectangle height must be between 0 and pi");
  if (defined$1(r) && !CesiumMath.equalsEpsilon(
    r.radii.x,
    r.radii.y,
    CesiumMath.EPSILON15
  ))
    throw new DeveloperError(
      "Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)"
    );
  i = defaultValue(i, 0), e = defaultValue(e, 0), r = defaultValue(r, Ellipsoid.WGS84);
  let a, c, l, h, d, f, p;
  if (o.width <= CesiumMath.PI) {
    const L = Rectangle.center(
      o,
      scratchRectangleCenterCartographic
    ), O = r.cartographicToCartesian(
      L,
      scratchRectangleCenter
    ), F = new EllipsoidTangentPlane(O, r);
    p = F.plane;
    const k = L.x, V = o.south < 0 && o.north > 0 ? 0 : L.y, N = Cartographic.fromRadians(
      k,
      o.north,
      e,
      scratchPerimeterCartographicNC
    ), U = Cartographic.fromRadians(
      o.west,
      o.north,
      e,
      scratchPerimeterCartographicNW
    ), z = Cartographic.fromRadians(
      o.west,
      V,
      e,
      scratchPerimeterCartographicCW
    ), $ = Cartographic.fromRadians(
      o.west,
      o.south,
      e,
      scratchPerimeterCartographicSW
    ), G = Cartographic.fromRadians(
      k,
      o.south,
      e,
      scratchPerimeterCartographicSC
    ), j = r.cartographicToCartesian(
      N,
      scratchPerimeterCartesianNC
    );
    let Y = r.cartographicToCartesian(
      U,
      scratchPerimeterCartesianNW
    );
    const H = r.cartographicToCartesian(
      z,
      scratchPerimeterCartesianCW
    );
    let W = r.cartographicToCartesian(
      $,
      scratchPerimeterCartesianSW
    );
    const q = r.cartographicToCartesian(
      G,
      scratchPerimeterCartesianSC
    ), Z = F.projectPointToNearestOnPlane(
      j,
      scratchPerimeterProjectedNC
    ), X = F.projectPointToNearestOnPlane(
      Y,
      scratchPerimeterProjectedNW
    ), K = F.projectPointToNearestOnPlane(
      H,
      scratchPerimeterProjectedCW
    ), ee = F.projectPointToNearestOnPlane(
      W,
      scratchPerimeterProjectedSW
    ), ie = F.projectPointToNearestOnPlane(
      q,
      scratchPerimeterProjectedSC
    );
    return a = Math.min(
      X.x,
      K.x,
      ee.x
    ), c = -a, h = Math.max(X.y, Z.y), l = Math.min(ee.y, ie.y), U.z = $.z = i, Y = r.cartographicToCartesian(
      U,
      scratchPerimeterCartesianNW
    ), W = r.cartographicToCartesian(
      $,
      scratchPerimeterCartesianSW
    ), d = Math.min(
      StaticPlane.getPointDistance(p, Y),
      StaticPlane.getPointDistance(p, W)
    ), f = e, fromPlaneExtents(
      F.origin,
      F.xAxis,
      F.yAxis,
      F.zAxis,
      a,
      c,
      l,
      h,
      d,
      f,
      s
    );
  }
  const m = o.south > 0, y = o.north < 0, x = m ? o.south : y ? o.north : 0, v = Rectangle.center(
    o,
    scratchRectangleCenterCartographic
  ).x, S = Cartesian3.fromRadians(
    v,
    x,
    e,
    r,
    scratchPlaneOrigin
  );
  S.z = 0;
  const b = Math.abs(S.x) < CesiumMath.EPSILON10 && Math.abs(S.y) < CesiumMath.EPSILON10 ? Cartesian3.UNIT_X : Cartesian3.normalize(S, scratchPlaneNormal), w = Cartesian3.UNIT_Z, M = Cartesian3.cross(
    b,
    w,
    scratchPlaneXAxis
  );
  p = StaticPlane.fromPointNormal(S, b, scratchPlane$1);
  const P = Cartesian3.fromRadians(
    v + CesiumMath.PI_OVER_TWO,
    x,
    e,
    r,
    scratchHorizonCartesian
  );
  c = Cartesian3.dot(
    StaticPlane.projectPointOntoPlane(
      p,
      P,
      scratchHorizonProjected
    ),
    M
  ), a = -c, h = Cartesian3.fromRadians(
    0,
    o.north,
    y ? i : e,
    r,
    scratchMaxY
  ).z, l = Cartesian3.fromRadians(
    0,
    o.south,
    m ? i : e,
    r,
    scratchMinY
  ).z;
  const D = Cartesian3.fromRadians(
    o.east,
    x,
    e,
    r,
    scratchZ
  );
  return d = StaticPlane.getPointDistance(p, D), f = 0, fromPlaneExtents(
    S,
    M,
    w,
    b,
    a,
    c,
    l,
    h,
    d,
    f,
    s
  );
};
const scratchCartesianU = new Vector3$1(), scratchCartesianV = new Vector3$1(), scratchCartesianW = new Vector3$1(), scratchValidAxis2 = new Vector3$1(), scratchValidAxis3 = new Vector3$1(), scratchPPrime = new Vector3$1();
OrientedBoundingBox.distanceSquaredTo = function(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("box is required.");
  if (!defined$1(i))
    throw new DeveloperError("cartesian is required.");
  const e = Cartesian3.subtract(i, o.center, scratchOffset$1), r = o.halfAxes;
  let s = StaticMatrix3.getColumn(r, 0, scratchCartesianU), a = StaticMatrix3.getColumn(r, 1, scratchCartesianV), c = StaticMatrix3.getColumn(r, 2, scratchCartesianW);
  const l = Cartesian3.magnitude(s), h = Cartesian3.magnitude(a), d = Cartesian3.magnitude(c);
  let f = !0, p = !0, m = !0;
  l > 0 ? Cartesian3.divideByScalar(s, l, s) : f = !1, h > 0 ? Cartesian3.divideByScalar(a, h, a) : p = !1, d > 0 ? Cartesian3.divideByScalar(c, d, c) : m = !1;
  const y = !f + !p + !m;
  let x, v, S;
  if (y === 1) {
    let M = s;
    x = a, v = c, p ? m || (M = c, v = s) : (M = a, x = s), S = Cartesian3.cross(x, v, scratchValidAxis3), M === s ? s = S : M === a ? a = S : M === c && (c = S);
  } else if (y === 2) {
    x = s, p ? x = a : m && (x = c);
    let M = Cartesian3.UNIT_Y;
    Cartesian3.equalsEpsilon(M, x, CesiumMath.EPSILON3) && (M = Cartesian3.UNIT_X), v = Cartesian3.cross(x, M, scratchValidAxis2), Cartesian3.normalize(v, v), S = Cartesian3.cross(x, v, scratchValidAxis3), Cartesian3.normalize(S, S), x === s ? (a = v, c = S) : x === a ? (c = v, s = S) : x === c && (s = v, a = S);
  } else
    y === 3 && (s = Cartesian3.UNIT_X, a = Cartesian3.UNIT_Y, c = Cartesian3.UNIT_Z);
  const E = scratchPPrime;
  E.x = Cartesian3.dot(e, s), E.y = Cartesian3.dot(e, a), E.z = Cartesian3.dot(e, c);
  let b = 0, w;
  return E.x < -l ? (w = E.x + l, b += w * w) : E.x > l && (w = E.x - l, b += w * w), E.y < -h ? (w = E.y + h, b += w * w) : E.y > h && (w = E.y - h, b += w * w), E.z < -d ? (w = E.z + d, b += w * w) : E.z > d && (w = E.z - d, b += w * w), b;
};
OrientedBoundingBox.intersectPlane = function(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("box is required.");
  if (!defined$1(i))
    throw new DeveloperError("plane is required.");
  const e = o.center, r = i.normal, s = o.halfAxes, a = r.x, c = r.y, l = r.z, h = s.elements, d = Math.abs(
    a * h[StaticMatrix3.COLUMN0ROW0] + c * h[StaticMatrix3.COLUMN0ROW1] + l * h[StaticMatrix3.COLUMN0ROW2]
  ) + Math.abs(
    a * h[StaticMatrix3.COLUMN1ROW0] + c * h[StaticMatrix3.COLUMN1ROW1] + l * h[StaticMatrix3.COLUMN1ROW2]
  ) + Math.abs(
    a * h[StaticMatrix3.COLUMN2ROW0] + c * h[StaticMatrix3.COLUMN2ROW1] + l * h[StaticMatrix3.COLUMN2ROW2]
  ), f = Cartesian3.dot(r.clone(), e) + i.constant;
  return f <= -d ? Intersect$1.OUTSIDE : f >= d ? Intersect$1.INSIDE : Intersect$1.INTERSECTING;
};
const scratchXAxis = new Vector3$1(), scratchYAxis = new Vector3$1(), scratchZAxis = new Vector3$1();
OrientedBoundingBox.computeCorners = function(o, i) {
  defined$1(i) || (i = [
    new Vector3$1(),
    new Vector3$1(),
    new Vector3$1(),
    new Vector3$1(),
    new Vector3$1(),
    new Vector3$1(),
    new Vector3$1(),
    new Vector3$1()
  ]);
  const e = o.center, r = o.halfAxes, s = StaticMatrix3.getColumn(r, 0, scratchXAxis), a = StaticMatrix3.getColumn(r, 1, scratchYAxis), c = StaticMatrix3.getColumn(r, 2, scratchZAxis);
  return Cartesian3.clone(e, i[0]), Cartesian3.subtract(i[0], s, i[0]), Cartesian3.subtract(i[0], a, i[0]), Cartesian3.subtract(i[0], c, i[0]), Cartesian3.clone(e, i[1]), Cartesian3.subtract(i[1], s, i[1]), Cartesian3.subtract(i[1], a, i[1]), Cartesian3.add(i[1], c, i[1]), Cartesian3.clone(e, i[2]), Cartesian3.subtract(i[2], s, i[2]), Cartesian3.add(i[2], a, i[2]), Cartesian3.subtract(i[2], c, i[2]), Cartesian3.clone(e, i[3]), Cartesian3.subtract(i[3], s, i[3]), Cartesian3.add(i[3], a, i[3]), Cartesian3.add(i[3], c, i[3]), Cartesian3.clone(e, i[4]), Cartesian3.add(i[4], s, i[4]), Cartesian3.subtract(i[4], a, i[4]), Cartesian3.subtract(i[4], c, i[4]), Cartesian3.clone(e, i[5]), Cartesian3.add(i[5], s, i[5]), Cartesian3.subtract(i[5], a, i[5]), Cartesian3.add(i[5], c, i[5]), Cartesian3.clone(e, i[6]), Cartesian3.add(i[6], s, i[6]), Cartesian3.add(i[6], a, i[6]), Cartesian3.subtract(i[6], c, i[6]), Cartesian3.clone(e, i[7]), Cartesian3.add(i[7], s, i[7]), Cartesian3.add(i[7], a, i[7]), Cartesian3.add(i[7], c, i[7]), i;
};
OrientedBoundingBox.fromGeoBoundingBox = function(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("geoBoundingBox is required.");
  const e = o.min, r = o.max, s = Rectangle.fromBox(o, null, !0);
  return OrientedBoundingBox.fromRectangle(
    s,
    e.z,
    r.z,
    null,
    i
  );
};
class ECEFProjection extends Projection {
  constructor() {
    super(...arguments);
    _(this, "name", PROJECTION_ECEF);
  }
  projectCoordinate(e, r) {
    return Ellipsoid.WGS84.cartographicDegreeToCartesian(e, r);
  }
  unprojectCoordinate(e, r) {
    return Ellipsoid.WGS84.cartesianToCartographicDegree(e, r);
  }
  getGeodeticSurfaceNormal(e, r) {
    return r || (r = new Vector3$1()), Ellipsoid.WGS84.geodeticSurfaceNormalCartographic(e, r);
  }
  getProjectedSurfaceNormal(e, r) {
    return r || (r = new Vector3$1()), Ellipsoid.WGS84.geodeticSurfaceNormal(e, r);
  }
  geoBoxToProjectedBox(e, r) {
    return r || (r = new OrientedBoundingBox()), r = OrientedBoundingBox.fromGeoBoundingBox(e, r), r;
  }
  getLODSacleOfGeoBoundingBox(e) {
    if (e.min.y > 85 || e.max.y < -85)
      return 0;
    const r = (e.min.y + e.max.y) / 2;
    return Math.cos(MathUtils.degToRad(r));
  }
  localFrameToFixedFrame(e, r) {
    return r || (r = new Matrix4()), Transforms.eastNorthUpToFixedFrame(e, null, r), r;
  }
}
function MercatorProjection() {
}
function extend$1(o, i) {
  for (let e in i)
    o[e] = i[e];
}
function Point(o, i) {
  this.lng = o, this.lat = i;
}
extend$1(Point.prototype, {
  equals: function(o) {
    return this.lat === o.lat && this.lng === o.lng;
  },
  clone: function() {
    return new Point(this.lat, this.lng);
  },
  getLngSpan: function(o) {
    let i = this.lng, e = Math.abs(o - i);
    return e > 180 && (e = 360 - e), e;
  },
  sub: function(o) {
    return new Point(this.lat - o.lat, this.lng - o.lng);
  },
  toString: function() {
    return "Point";
  }
});
function Pixel(o, i) {
  this.x = o, this.y = i;
}
extend$1(MercatorProjection, {
  EARTHRADIUS: 637099681e-2,
  MCBAND: [1289059486e-2, 836237787e-2, 5591021, 348198983e-2, 167804312e-2, 0],
  LLBAND: [75, 60, 45, 30, 15, 0],
  MC2LL: [
    [1410526172116255e-23, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 173379812e-1],
    [-7435856389565537e-24, 8983055097726239e-21, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1026014486e-2],
    [-3030883460898826e-23, 898305509983578e-20, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 685681737e-2],
    [-1981981304930552e-23, 8983055099779535e-21, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 448277706e-2],
    [309191371068437e-23, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -23663490511e-14, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 25551644e-1],
    [2890871144776878e-24, 8983055095805407e-21, -3068298e-14, 7.47137025468032, -353937994e-14, -0.02145144861037, -1234426596e-14, 10322952773e-14, -323890364e-14, 826088.5]
  ],
  LL2MC: [
    [-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5],
    [8277824516172526e-19, 111320.7020463578, 6477955746671607e-7, -4082003173641316e-6, 1077490566351142e-5, -1517187553151559e-5, 1205306533862167e-5, -5124939663577472e-6, 9133119359512032e-7, 67.5],
    [0.00337398766765, 111320.7020202162, 4481351045890365e-9, -2339375119931662e-8, 7968221547186455e-8, -1159649932797253e-7, 9723671115602145e-8, -4366194633752821e-8, 8477230501135234e-9, 52.5],
    [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837749470245e-9, 992013.7397791013, -122195221711287e-8, 1340652697009075e-9, -620943.6990984312, 144416.9293806241, 37.5],
    [-3441963504368392e-19, 111320.7020576856, 278.2353980772752, 2485758690035394e-9, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5],
    [-3218135878613132e-19, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]
  ],
  getDistanceByMC: function(o, i) {
    if (!o || !i)
      return 0;
    let e, r, s, a;
    return o = this.convertMC2LL(o), !o || (e = this.toRadians(o.lng), r = this.toRadians(o.lat), i = this.convertMC2LL(i), !i) ? 0 : (s = this.toRadians(i.lng), a = this.toRadians(i.lat), this.getDistance(e, s, r, a));
  },
  getDistanceByLL: function(o, i) {
    if (!o || !i)
      return 0;
    o.lng = this.getLoop(o.lng, -180, 180), o.lat = this.getRange(o.lat, -74, 74), i.lng = this.getLoop(i.lng, -180, 180), i.lat = this.getRange(i.lat, -74, 74);
    let e, r, s, a;
    return e = this.toRadians(o.lng), s = this.toRadians(o.lat), r = this.toRadians(i.lng), a = this.toRadians(i.lat), this.getDistance(e, r, s, a);
  },
  convertMC2LL: function(s) {
    if (s == null)
      return new Point(0, 0);
    if (s.lng < 180 && s.lng > -180 && s.lat < 90 && s.lat > -90)
      return s;
    let i, e;
    i = new Point(Math.abs(s.lng), Math.abs(s.lat));
    for (let a = 0; a < this.MCBAND.length; a++)
      if (i.lat >= this.MCBAND[a]) {
        e = this.MC2LL[a];
        break;
      }
    let r = this.convertor(s, e);
    var s = new Point(r.lng.toFixed(6), r.lat.toFixed(6));
    return s;
  },
  convertLL2MC: function(a) {
    if (a == null)
      return new Point(0, 0);
    if (a.lng > 180 || a.lng < -180 || a.lat > 90 || a.lat < -90)
      return a;
    let i, e;
    a.lng = this.getLoop(a.lng, -180, 180), a.lat = this.getRange(a.lat, -74, 74), i = new Point(a.lng, a.lat);
    for (var r = 0; r < this.LLBAND.length; r++)
      if (i.lat >= this.LLBAND[r]) {
        e = this.LL2MC[r];
        break;
      }
    if (!e) {
      for (var r = 0; r < this.LLBAND.length; r++)
        if (i.lat <= -this.LLBAND[r]) {
          e = this.LL2MC[r];
          break;
        }
    }
    let s = this.convertor(a, e);
    var a = new Point(Number(s.lng), Number(s.lat));
    return a;
  },
  convertor: function(o, i) {
    if (!o || !i)
      return;
    let e = i[0] + i[1] * Math.abs(o.lng), r = Math.abs(o.lat) / i[9], s = i[2] + i[3] * r + i[4] * r * r + i[5] * r * r * r + i[6] * r * r * r * r + i[7] * r * r * r * r * r + i[8] * r * r * r * r * r * r;
    return e *= o.lng < 0 ? -1 : 1, s *= o.lat < 0 ? -1 : 1, new Point(e, s);
  },
  getDistance: function(o, i, e, r) {
    return this.EARTHRADIUS * Math.acos(Math.sin(e) * Math.sin(r) + Math.cos(e) * Math.cos(r) * Math.cos(i - o));
  },
  toRadians: function(o) {
    return Math.PI * o / 180;
  },
  toDegrees: function(o) {
    return 180 * o / Math.PI;
  },
  getRange: function(o, i, e) {
    return i != null && (o = Math.max(o, i)), e != null && (o = Math.min(o, e)), o;
  },
  getLoop: function(o, i, e) {
    for (; o > e; )
      o -= e - i;
    for (; o < i; )
      o += e - i;
    return o;
  }
});
extend$1(MercatorProjection.prototype, {
  lngLatToMercator: function(o) {
    return MercatorProjection.convertLL2MC(o);
  },
  lngLatToPoint: function(o) {
    let i = MercatorProjection.convertLL2MC(o);
    return new Pixel(i.lng, i.lat);
  },
  mercatorToLngLat: function(o) {
    return MercatorProjection.convertMC2LL(o);
  },
  pointToLngLat: function(o) {
    let i = new Point(o.x, o.y);
    return MercatorProjection.convertMC2LL(i);
  },
  pointToPixel: function(o, i, e, r, s) {
    if (!o)
      return;
    o = this.lngLatToMercator(o, s);
    let a = this.getZoomUnits(i), c = Math.round((o.lng - e.lng) / a + r.width / 2), l = Math.round((e.lat - o.lat) / a + r.height / 2);
    return new Pixel(c, l);
  },
  pixelToPoint: function(o, i, e, r, s) {
    if (!o)
      return;
    let a = this.getZoomUnits(i), c = e.lng + a * (o.x - r.width / 2), l = e.lat - a * (o.y - r.height / 2), h = new Point(c, l);
    return this.mercatorToLngLat(h, s);
  },
  getZoomUnits: function(o) {
    return Math.pow(2, 18 - o);
  }
});
const MAX_X = 2003772636e-2, MAX_Y = 1247410417e-2, MAX_LAT = 74, MIN_LAT = -MAX_LAT, _tempInput$1 = new Vector3$1();
class BaiduMercatorProjection extends Projection {
  constructor() {
    super(...arguments);
    _(this, "name", PROJECTION_BD_MERCATOR);
    _(this, "isAxisAligned", !0);
    _(this, "unprojectCoordinate", (e, r, s) => {
      r || (r = new Vector3$1()), _tempInput$1.copy(e), e.x < -MAX_X && (_tempInput$1.x = -MAX_X), e.x > MAX_X && (_tempInput$1.x = MAX_X), e.y < -MAX_Y && (_tempInput$1.y = -MAX_Y), e.y > MAX_Y && (_tempInput$1.y = MAX_Y);
      const a = MercatorProjection.convertMC2LL({ lng: _tempInput$1.x, lat: _tempInput$1.y });
      return r.set(Number(a.lng), Number(a.lat), _tempInput$1.z), s && (r.x = extendUnprojectCoordinate(e.x, r.x, 180, MAX_X), r.y = extendUnprojectCoordinate(e.y, r.y, MAX_LAT, MAX_Y)), r;
    });
  }
  projectCoordinate(e, r, s = !1) {
    r || (r = new Vector3$1()), _tempInput$1.copy(e), e.x < -180 && (_tempInput$1.x = -180), e.x > 180 && (_tempInput$1.x = 180), e.y < MIN_LAT && (_tempInput$1.y = MIN_LAT), e.y > MAX_LAT && (_tempInput$1.y = MAX_LAT);
    const a = MercatorProjection.convertLL2MC({ lng: _tempInput$1.x, lat: _tempInput$1.y });
    return r.set(Number(a.lng), Number(a.lat), _tempInput$1.z), s && (r.x = extendProjectCoordinate(e.x, r.x, 180, MAX_X), r.y = extendProjectCoordinate(e.y, r.y, MAX_LAT, MAX_Y)), r;
  }
}
const scaleFactor = 6378137 * Math.PI / 180;
class GeoProjection extends Projection {
  constructor() {
    super(...arguments);
    _(this, "name", PROJECTION_GEO);
    _(this, "isGeo", !0);
    _(this, "isAxisAligned", !0);
  }
  projectCoordinate(e, r) {
    return r || (r = new Vector3$1()), r.x = e.x * scaleFactor, r.y = e.y * scaleFactor, r.z = e.z, r;
  }
  unprojectCoordinate(e, r) {
    return r || (r = new Vector3$1()), r.x = e.x / scaleFactor, r.y = e.y / scaleFactor, r.z = e.z, r;
  }
}
class ScreenPixelProjection extends Projection {
  constructor() {
    super(...arguments);
    _(this, "name", PROJECTION_SCREEN_PIXEL);
    _(this, "isAxisAligned", !0);
  }
  projectCoordinate(e, r) {
    return r || (r = new Vector3$1()), r.x = e.x, r.y = -e.y, r.z = e.z, r;
  }
  unprojectCoordinate(e, r) {
    return r || (r = new Vector3$1()), r.x = e.x, r.y = -e.y, r.z = e.z, r;
  }
}
let globalId$1 = 1;
const _inputArray = new Array(2);
class GenericDefinedProjection extends Projection {
  constructor(i, e, r) {
    super(), i || (i = `custom_${globalId$1++}`), this._name = i, this._parameters = e, proj4.defs(this._name) || proj4.defs(this._name, e), r && r.isBox3 && (this._geoBoundingBox = r);
  }
  projectCoordinate(i, e, r) {
    _inputArray[0] = i.x, _inputArray[1] = i.y;
    const s = this.geoBoundingBox;
    _inputArray[0] < s.min.x && (_inputArray[0] = s.min.x), _inputArray[0] > s.max.x && (_inputArray[0] = s.max.x), _inputArray[1] < s.min.y && (_inputArray[1] = s.min.y), _inputArray[1] > s.max.y && (_inputArray[1] = s.max.y);
    const a = proj4("EPSG:4326", this.name, _inputArray);
    if (e || (e = new Vector3$1()), r) {
      const c = this.projectedBoundingBox;
      e.x = extendProjectCoordinate(i.x, a[0], s.max.x, c.max.x), e.y = extendProjectCoordinate(i.y, a[1], s.max.y, c.max.y);
    } else
      e.x = a[0], e.y = a[1];
    return e.z = i.z, e;
  }
  unprojectCoordinate(i, e, r) {
    const s = this.projectedBoundingBox;
    _inputArray[0] = i.x, _inputArray[1] = i.y, _inputArray[0] < s.min.x && (_inputArray[0] = s.min.x), _inputArray[0] > s.max.x && (_inputArray[0] = s.max.x), _inputArray[1] < s.min.y && (_inputArray[1] = s.min.y), _inputArray[1] > s.max.y && (_inputArray[1] = s.max.y);
    const a = proj4(this.name, "EPSG:4326", _inputArray);
    if (e || (e = new Vector3$1()), r) {
      const c = this.geoBoundingBox;
      e.x = extendUnprojectCoordinate(
        i.x,
        a[0],
        c.max.x,
        s.max.x
      ), e.y = extendUnprojectCoordinate(
        i.y,
        a[1],
        c.max.y,
        s.max.y
      );
    } else
      e.x = a[0], e.y = a[1];
    return e.z = i.z, e;
  }
  get name() {
    return this._name;
  }
}
const _cache = {}, projectionDefs = {
  "EPSG:5070": {
    parameters: "+proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs",
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,
    geoBoundingBox: [
      [-172.54, 23.81, 0],
      [-47.74, 86.46, 0]
    ]
  },
  "EPSG:8857": {
    parameters: "+proj=eqearth +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs",
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR
  }
};
for (let o = 1; o <= 60; o++) {
  let i = -180 + (o - 1) * 6, e = -180 + o * 6;
  i -= 12, e += 12, i < -180 && (i = -180), e > 180 && (e = 180), projectionDefs[`EPSG:${32600 + o}`] = {
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,
    geoBoundingBox: [
      [i, -80, 0],
      [e, 84, 0]
    ]
  }, projectionDefs[`EPSG:${32700 + o}`] = {
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,
    geoBoundingBox: [
      [i, -80, 0],
      [e, 84, 0]
    ]
  };
}
for (let o = 0; o < 11; o++) {
  let i = o + 13, e = i * 6 - 3, r = 1e6 * i + 5e5;
  projectionDefs[`EPSG:${4491 + o}`] = {
    parameters: `+proj=tmerc +lat_0=0 +lon_0=${e} +k=1 +x_0=${r} +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,
    geoBoundingBox: [
      [e - 3, 3, 0],
      [e + 3, 54, 0]
    ]
  }, projectionDefs[`EPSG:${4502 + o}`] = {
    parameters: `+proj=tmerc +lat_0=0 +lon_0=${e} +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,
    geoBoundingBox: [
      [e - 3, 3, 0],
      [e + 3, 54, 0]
    ]
  }, i = 25 + 2 * o, e = i * 3, r = 1e6 * i + 5e5, projectionDefs[`EPSG:${4513 + 2 * o}`] = {
    parameters: `+proj=tmerc +lat_0=0 +lon_0=${e} +k=1 +x_0=${r} +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,
    geoBoundingBox: [
      [e - 1.5, 3, 0],
      [e + 1.5, 54, 0]
    ]
  }, projectionDefs[`EPSG:${4534 + 2 * o}`] = {
    parameters: `+proj=tmerc +lat_0=0 +lon_0=${e} +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,
    geoBoundingBox: [
      [e - 1.5, 3, 0],
      [e + 1.5, 54, 0]
    ]
  }, i = 25 + 2 * o + 1, o < 10 && (e = i * 3, r = 1e6 * i + 5e5, projectionDefs[`EPSG:${4513 + 2 * o + 1}`] = {
    parameters: `+proj=tmerc +lat_0=0 +lon_0=${e} +k=1 +x_0=${r} +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,
    geoBoundingBox: [
      [e - 1.5, 3, 0],
      [e + 1.5, 54, 0]
    ]
  }, projectionDefs[`EPSG:${4534 + 2 * o + 1}`] = {
    parameters: `+proj=tmerc +lat_0=0 +lon_0=${e} +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,
    projectBoundingBoxMethod: projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,
    geoBoundingBox: [
      [e - 1.5, 3, 0],
      [e + 1.5, 54, 0]
    ]
  });
}
const normalizeProjectionName = (o) => (o = o.toUpperCase().trim(), o === "EPSG:900913" ? PROJECTION_WEB_MERCATOR : o === "GLOBE" || o === "ECEF" ? PROJECTION_ECEF : o), getProjection = (o) => {
  if (o = normalizeProjectionName(o), !_cache[o])
    switch (o) {
      case PROJECTION_WEB_MERCATOR:
        _cache[o] = new WebMercatorProjection();
        break;
      case PROJECTION_ECEF:
        _cache[o] = new ECEFProjection();
        break;
      case PROJECTION_BD_MERCATOR:
        _cache[o] = new BaiduMercatorProjection();
        break;
      case PROJECTION_GEO:
        _cache[o] = new GeoProjection();
        break;
      case PROJECTION_SCREEN_PIXEL:
        _cache[o] = new ScreenPixelProjection();
        break;
      default:
        let i = null;
        if (projectionDefs[o]) {
          const e = projectionDefs[o];
          let r = null;
          if (e.geoBoundingBox) {
            const s = e.geoBoundingBox;
            r = new Box3(
              new Vector3$1(
                s[0][0],
                s[0][1],
                s[0][2] || 0
              ),
              new Vector3$1(
                s[1][0],
                s[1][1],
                s[1][2] || 0
              )
            );
          }
          i = new GenericDefinedProjection(o, e.parameters, r), e.projectBoundingBoxMethod && (i.projectBoundingBoxMethod = e.projectBoundingBoxMethod);
        }
        if (!i)
          throw new Error(`Unsupported projection: ${o}`);
        _cache[o] = i;
        break;
    }
  return _cache[o];
}, _CoordTransformer = class {
  static _cacheKey(o, i) {
    return `${o}->${i}`;
  }
  static _clearPathCache() {
    _CoordTransformer._pathCache.clear();
  }
  static _findTransformPath(o, i, e = /* @__PURE__ */ new Set()) {
    const r = _CoordTransformer._cacheKey(o, i);
    if (_CoordTransformer._pathCache.has(r))
      return _CoordTransformer._pathCache.get(r);
    if (e.has(o))
      return _CoordTransformer._pathCache.set(r, null), null;
    if (e.add(o), _CoordTransformer._registeredTransformers[o] && _CoordTransformer._registeredTransformers[o][i]) {
      const s = [o, i];
      return _CoordTransformer._pathCache.set(r, s), s;
    }
    if (_CoordTransformer._registeredTransformers[o])
      for (const s of Object.keys(_CoordTransformer._registeredTransformers[o])) {
        const a = _CoordTransformer._findTransformPath(s, i, new Set(e));
        if (a) {
          const c = [o, ...a];
          return _CoordTransformer._pathCache.set(r, c), c;
        }
      }
    return _CoordTransformer._pathCache.set(r, null), null;
  }
  static transform(o, i, e, r) {
    if (o === i)
      return r.copy(e), r;
    const s = _CoordTransformer._findTransformPath(o, i);
    if (!s)
      return r.copy(e), r;
    let a = e;
    for (let c = 0; c < s.length - 1; c++) {
      const l = s[c], h = s[c + 1];
      a = _CoordTransformer._registeredTransformers[l][h](a, r);
    }
    return a;
  }
  static register(o, i, e) {
    _CoordTransformer._registeredTransformers[o] || (_CoordTransformer._registeredTransformers[o] = {}), _CoordTransformer._registeredTransformers[o][i] = e, _CoordTransformer._clearPathCache();
  }
  static unregister(o, i) {
    _CoordTransformer._registeredTransformers[o] && (delete _CoordTransformer._registeredTransformers[o][i], _CoordTransformer._clearPathCache());
  }
  static canTransform(o, i) {
    return o === i ? !1 : _CoordTransformer._findTransformPath(o, i) !== null;
  }
  static serialize() {
    const o = {};
    for (const i of Object.keys(_CoordTransformer._registeredTransformers)) {
      o[i] = {};
      for (const e of Object.keys(_CoordTransformer._registeredTransformers[i]))
        o[i][e] = _CoordTransformer._registeredTransformers[i][e].toString();
    }
    return JSON.stringify(o);
  }
  static deserialize(json) {
    const result = JSON.parse(json);
    for (const srcCoord of Object.keys(result))
      for (const targetCoord of Object.keys(result[srcCoord]))
        _CoordTransformer.register(srcCoord, targetCoord, eval(result[srcCoord][targetCoord]));
  }
};
let CoordTransformer = _CoordTransformer;
_(CoordTransformer, "_registeredTransformers", {}), _(CoordTransformer, "_pathCache", /* @__PURE__ */ new Map());
const _inputVector3 = new Vector3$1(), _outputVector3 = new Vector3$1(), fixCoordiates = (o, i) => {
  if (!!o)
    if (i === 0)
      o[2] === void 0 && (o[2] = 0);
    else
      for (const e of o)
        fixCoordiates(e, i - 1);
};
function getGeoFeatures(o, i) {
  if (!o)
    return [];
  let e = null;
  return i && projectGeoJSON(o, i), o.features ? e = o.features : Array.isArray(o) ? e = o : e = [o], e;
}
function projectGeoJSON(o, i) {
  if (!!o) {
    if (o.type === "FeatureCollection" || o.features) {
      const e = o.features;
      for (const r of e)
        projectGeoJSON(r, i);
    } else if (Array.isArray(o)) {
      const e = o;
      for (const r of e)
        projectGeoJSON(r, i);
    } else if (o.type === "Feature" || o.geometry) {
      if (!o.geometry)
        return;
      if (Array.isArray(o.geometry.coordinates)) {
        if (o.geometry[i.name])
          return;
        fixFeature(o);
        const e = projectArrayCoordinates(o.geometry.coordinates, i);
        o.geometry[i.name] = e;
      }
    }
  }
}
function projectArrayCoordinates(o, i) {
  if (Array.isArray(o[0])) {
    const e = [];
    for (let r of o)
      e.push(projectArrayCoordinates(r, i));
    return e;
  } else if (typeof o[0] == "number" || typeof o[0] == "string")
    return _inputVector3.set(o[0], o[1], o[2] || 0), i.projectCoordinate(_inputVector3, _outputVector3), [_outputVector3.x, _outputVector3.y, _outputVector3.z];
}
function unprojectArrayCoordinates(o, i) {
  if (Array.isArray(o[0])) {
    const e = [];
    for (let r of o)
      e.push(unprojectArrayCoordinates(r, i));
    return e;
  } else if (typeof o[0] == "number" || typeof o[0] == "string")
    return _inputVector3.set(o[0], o[1], o[2] || 0), i.unprojectCoordinate(_inputVector3, _outputVector3), [_outputVector3.x, _outputVector3.y, _outputVector3.z];
}
function transformArrayCoordinates(o, i, e) {
  if (Array.isArray(o[0])) {
    const r = [];
    for (let s of o)
      r.push(transformArrayCoordinates(s, i, e));
    return r;
  } else if (typeof o[0] == "number" || typeof o[0] == "string")
    return _inputVector3.set(o[0], o[1], o[2] || 0), CoordTransformer.transform(i, e, _inputVector3, _outputVector3), [_outputVector3.x, _outputVector3.y, _outputVector3.z];
}
function fixFeature(o) {
  o.type || (o.type = "Feature");
  const i = o.geometry.type, e = {
    Point: 0,
    MultiPoint: 1,
    LineString: 1,
    MultiLineString: 2,
    Polygon: 2,
    MultiPolygon: 3
  };
  return Object.keys(e).includes(i) && fixCoordiates(o.geometry.coordinates, e[i]), o;
}
function multiPointToPoints(o, i) {
  if (!o.geometry)
    return [];
  if (o.geometry.type === "Point")
    return [o];
  if (o.geometry.type === "MultiPoint" || o.geometry.type === "LineString") {
    const e = [], { type: r, geometry: s, ...a } = o;
    for (let c = 0; c < o.geometry.coordinates.length; c++) {
      const l = o.geometry.coordinates[c];
      if (i) {
        const h = o.geometry[i][c];
        e.push({
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: l,
            [i]: h
          },
          ...a
        });
      } else
        e.push({
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: l
          },
          ...a
        });
    }
    return e;
  }
  return [];
}
function multiLineStringToLineStrings(o, i) {
  if (!o.geometry)
    return [];
  if (o.geometry.type === "LineString")
    return [o];
  if (o.geometry.type === "MultiLineString" || o.geometry.type === "Polygon") {
    const e = [], { type: r, geometry: s, ...a } = o;
    for (let c = 0; c < o.geometry.coordinates.length; c++) {
      const l = o.geometry.coordinates[c];
      if (i) {
        const h = o.geometry[i][c];
        e.push({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: l,
            [i]: h
          },
          ...a
        });
      } else
        e.push({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: l
          },
          ...a
        });
    }
    return e;
  }
  return [];
}
function multiPolygonToPolygons(o, i) {
  if (!o.geometry)
    return [];
  if (o.geometry.type === "Polygon")
    return [o];
  if (o.geometry.type === "MultiPolygon") {
    const e = [], { type: r, geometry: s, ...a } = o;
    for (let c = 0; c < o.geometry.coordinates.length; c++) {
      const l = o.geometry.coordinates[c];
      if (i) {
        const h = o.geometry[i][c];
        e.push({
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: l,
            [i]: h
          },
          ...a
        });
      } else
        e.push({
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: l
          },
          ...a
        });
    }
    return e;
  }
  return [];
}
function convertLineString2Points(o) {
  let i = this.getGeoFeatures(o), e = [];
  for (let r = 0; r < i.length; r++) {
    const s = i[r], a = this.multiLineStringToLineStrings(s);
    for (let c = 0; c < a.length; c++) {
      const l = a[c], h = this.multiPointToPoints(l);
      e.push(...h);
    }
  }
  return e;
}
function convertPolygon2LineString(o) {
  let i = this.getGeoFeatures(o), e = [];
  for (let r = 0; r < i.length; r++) {
    const s = i[r], a = this.multiPolygonToPolygons(s);
    for (let c = 0; c < a.length; c++) {
      const l = a[c], h = this.multiLineStringToLineStrings(l);
      e.push(...h);
    }
  }
  return e;
}
function coordEach(o, i, e) {
  if (o === null)
    return;
  let r, s, a, c, l, h, d, f = 0, p = 0, m, y = o.type, x = y === "FeatureCollection", v = y === "Feature", S = x ? o.features.length : 1;
  for (let E = 0; E < S; E++) {
    d = x ? o.features[E].geometry : v ? o.geometry : o, m = d ? d.type === "GeometryCollection" : !1, l = m ? d.geometries.length : 1;
    for (let b = 0; b < l; b++) {
      let w = 0, M = 0;
      if (c = m ? d.geometries[b] : d, c === null)
        continue;
      h = c.coordinates;
      let P = c.type;
      switch (f = e && (P === "Polygon" || P === "MultiPolygon") ? 1 : 0, P) {
        case null:
          break;
        case "Point":
          if (i(
            h,
            p,
            E,
            w,
            M
          ) === !1)
            return !1;
          p++, w++;
          break;
        case "LineString":
        case "MultiPoint":
          for (r = 0; r < h.length; r++) {
            if (i(
              h[r],
              p,
              E,
              w,
              M
            ) === !1)
              return !1;
            p++, P === "MultiPoint" && w++;
          }
          P === "LineString" && w++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (r = 0; r < h.length; r++) {
            for (s = 0; s < h[r].length - f; s++) {
              if (i(
                h[r][s],
                p,
                E,
                w,
                M
              ) === !1)
                return !1;
              p++;
            }
            P === "MultiLineString" && w++, P === "Polygon" && M++;
          }
          P === "Polygon" && w++;
          break;
        case "MultiPolygon":
          for (r = 0; r < h.length; r++) {
            for (M = 0, s = 0; s < h[r].length; s++) {
              for (a = 0; a < h[r][s].length - f; a++) {
                if (i(
                  h[r][s][a],
                  p,
                  E,
                  w,
                  M
                ) === !1)
                  return !1;
                p++;
              }
              M++;
            }
            w++;
          }
          break;
        case "GeometryCollection":
          for (r = 0; r < c.geometries.length; r++)
            if (coordEach(c.geometries[r], i, e) === !1)
              return !1;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function geomEach(o, i) {
  let e, r, s, a, c, l, h, d, f, p, m = 0, y = o.type === "FeatureCollection", x = o.type === "Feature", v = y ? o.features.length : 1;
  for (e = 0; e < v; e++) {
    for (l = y ? o.features[e].geometry : x ? o.geometry : o, d = y ? o.features[e].properties : x ? o.properties : {}, f = y ? o.features[e].bbox : x ? o.bbox : void 0, p = y ? o.features[e].id : x ? o.id : void 0, h = l ? l.type === "GeometryCollection" : !1, c = h ? l.geometries.length : 1, s = 0; s < c; s++) {
      if (a = h ? l.geometries[s] : l, a === null) {
        if (i(
          null,
          m,
          d,
          f,
          p
        ) === !1)
          return !1;
        continue;
      }
      switch (a.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (i(
            a,
            m,
            d,
            f,
            p
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (r = 0; r < a.geometries.length; r++)
            if (i(
              a.geometries[r],
              m,
              d,
              f,
              p
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    m++;
  }
}
function featureEach(o, i) {
  if (o.type === "Feature")
    i(o, 0);
  else if (o.type === "FeatureCollection")
    for (let e = 0; e < o.features.length && i(o.features[e], e) !== !1; e++)
      ;
}
function geomReduce(o, i, e) {
  let r = e;
  return geomEach(
    o,
    function(s, a, c, l, h) {
      a === 0 && e === void 0 ? r = s : r = i(
        r,
        s,
        a,
        c,
        l,
        h
      );
    }
  ), r;
}
function getbbox(o, i = {}) {
  if (o.bbox != null && i.recompute !== !0)
    return o.bbox;
  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return coordEach(o, (r) => {
    e[0] > r[0] && (e[0] = r[0]), e[1] > r[1] && (e[1] = r[1]), e[2] < r[0] && (e[2] = r[0]), e[3] < r[1] && (e[3] = r[1]);
  }), e;
}
function getCoord(o) {
  if (Array.isArray(o))
    return o;
  if (o.type === "Feature") {
    if (o.geometry !== null)
      return o.geometry.coordinates;
  } else if (o.coordinates)
    return o.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function getGeom(o) {
  return o.type === "Feature" ? o.geometry : o;
}
function inBBox(o, i) {
  return i[0] <= o[0] && i[1] <= o[1] && i[2] >= o[0] && i[3] >= o[1];
}
function pointInPolygon(o, i) {
  let e = 0, r = 0, s = 0, a = 0, c = 0, l = 0, h = 0, d = 0, f = null, p = null;
  const m = o[0], y = o[1], x = i.length;
  for (e; e < x; e++) {
    r = 0;
    const v = i[e].length - 1, S = i[e];
    if (f = S[0], f[0] !== S[v][0] && f[1] !== S[v][1])
      throw new Error("First and last coordinates in a ring must be the same");
    for (c = f[0] - m, l = f[1] - y, r; r < v; r++) {
      if (p = S[r + 1], d = p[1] - y, l < 0 && d < 0 || l > 0 && d > 0) {
        f = p, l = d, c = f[0] - m;
        continue;
      }
      if (h = p[0] - o[0], d > 0 && l <= 0) {
        if (a = c * d - h * l, a > 0)
          s = s + 1;
        else if (a === 0)
          return 0;
      } else if (l > 0 && d <= 0) {
        if (a = c * d - h * l, a < 0)
          s = s + 1;
        else if (a === 0)
          return 0;
      } else if (d === 0 && l < 0) {
        if (a = c * d - h * l, a === 0)
          return 0;
      } else if (l === 0 && d < 0) {
        if (a = c * d - h * l, a === 0)
          return 0;
      } else if (l === 0 && d === 0) {
        if (h <= 0 && c >= 0)
          return 0;
        if (c <= 0 && h >= 0)
          return 0;
      }
      f = p, l = d, c = h;
    }
  }
  return s % 2 !== 0;
}
function booleanPointInPolygon(o, i, e = {}) {
  if (!o)
    throw new Error("point is required");
  if (!i)
    throw new Error("polygon is required");
  const r = getCoord(o), s = getGeom(i), a = s.type, c = i.bbox;
  let l = s.coordinates;
  if (c && inBBox(r, c) === !1)
    return !1;
  a === "Polygon" && (l = [l]);
  let h = !1;
  for (let d = 0; d < l.length; ++d) {
    const f = pointInPolygon(r, l[d]);
    if (f === 0)
      return !e.ignoreBoundary;
    f && (h = !0);
  }
  return h;
}
function feature(o, i, e = {}) {
  const r = { type: "Feature" };
  return (e.id === 0 || e.id) && (r.id = e.id), e.bbox && (r.bbox = e.bbox), r.properties = i || {}, r.geometry = o, r;
}
function featureCollection(o, i = {}) {
  const e = { type: "FeatureCollection" };
  return i.id && (e.id = i.id), i.bbox && (e.bbox = i.bbox), e.features = o, e;
}
function coordToPoint(o, i, e = {}) {
  if (!o)
    throw new Error("coordinates is required");
  if (!Array.isArray(o))
    throw new Error("coordinates must be an Array");
  if (o.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!isNumber(o[0]) || !isNumber(o[1]))
    throw new Error("coordinates must contain numbers");
  return feature({
    type: "Point",
    coordinates: o
  }, i, e);
}
function coordToLineString(o, i, e = {}) {
  if (!o)
    throw new Error("coordinates is required");
  if (!Array.isArray(o))
    throw new Error("coordinates must be an Array");
  return feature({
    type: "LineString",
    coordinates: o
  }, i, e);
}
function coordToPolygon(o, i, e = {}) {
  for (const s of o) {
    if (s.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (s[s.length - 1].length !== s[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let a = 0; a < s[s.length - 1].length; a++)
      if (s[s.length - 1][a] !== s[0][a])
        throw new Error("First and last Position are not equivalent.");
  }
  return feature({
    type: "Polygon",
    coordinates: o
  }, i, e);
}
function computeGeoJSONArea(o) {
  return geomReduce(
    o,
    (i, e) => i + calculateArea(e),
    0
  );
}
function calculateArea(o) {
  let i = 0, e;
  switch (o.type) {
    case "Polygon":
      return polygonArea(o.coordinates);
    case "MultiPolygon":
      for (e = 0; e < o.coordinates.length; e++)
        i += polygonArea(o.coordinates[e]);
      return i;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function polygonArea(o) {
  let i = 0;
  if (o && o.length > 0) {
    i += Math.abs(ringArea(o[0]));
    for (let e = 1; e < o.length; e++)
      i -= Math.abs(ringArea(o[e]));
  }
  return i;
}
function ringArea(o) {
  let i, e, r, s, a, c, l, h = 0;
  const d = o.length;
  if (d > 2) {
    for (l = 0; l < d; l++)
      l === d - 2 ? (s = d - 2, a = d - 1, c = 0) : l === d - 1 ? (s = d - 1, a = 0, c = 1) : (s = l, a = l + 1, c = l + 2), i = o[s], e = o[a], r = o[c], h += (MercatorProjection.toRadians(r[0]) - MercatorProjection.toRadians(i[0])) * Math.sin(MercatorProjection.toRadians(e[1]));
    h = h * 63710088e-1 * 63710088e-1 / 2;
  }
  return h;
}
function getcenter(o, i = {}) {
  const e = getbbox(o), r = (e[0] + e[2]) / 2, s = (e[1] + e[3]) / 2;
  return coordToPoint([r, s], i.properties, i);
}
function isLngLatArrValid(o) {
  return o[0] >= -180 && o[0] <= 180 && o[1] >= -90 && o[1] <= 90;
}
const geojsonUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getGeoFeatures,
  projectArrayCoordinates,
  unprojectArrayCoordinates,
  transformArrayCoordinates,
  fixFeature,
  multiPointToPoints,
  multiLineStringToLineStrings,
  multiPolygonToPolygons,
  convertLineString2Points,
  convertPolygon2LineString,
  coordEach,
  geomEach,
  featureEach,
  geomReduce,
  getbbox,
  getCoord,
  getGeom,
  inBBox,
  booleanPointInPolygon,
  feature,
  featureCollection,
  coordToPoint,
  coordToLineString,
  coordToPolygon,
  computeGeoJSONArea,
  getcenter,
  isLngLatArrValid
}, Symbol.toStringTag, { value: "Module" })), getCRSName = function(o) {
  return typeof o == "string" ? o : typeof o == "object" ? o.properties.name : null;
};
class DataItem {
  constructor(i, e = {}, r = !1) {
    _(this, "_originalCoordinates");
    _(this, "_attributes");
    _(this, "_id");
    _(this, "_sourceProjectionName");
    _(this, "_coordinates");
    _(this, "_projectedCoordinates", {});
    _(this, "_type");
    _(this, "_isMulti", !1);
    _(this, "_size", 1);
    _(this, "_isValid", !0);
    i || (console.warn("DataItem: feature is required"), this._isValid = !1);
    let s = null, a = {};
    if (Array.isArray(i))
      this._type = GEOMETRY_TYPE_POINT, this._originalCoordinates = i;
    else if (i.isVector3)
      this._type = GEOMETRY_TYPE_POINT, this._originalCoordinates = [i.x, i.y, i.z];
    else if (typeof i == "object") {
      const c = i.geometry;
      if (!c)
        console.warn("DataItem: geometry is required"), this._isValid = !1;
      else {
        const l = (c.type || "").toUpperCase();
        l === "POINT" ? this._type = GEOMETRY_TYPE_POINT : l === "LINESTRING" ? this._type = GEOMETRY_TYPE_LINE : l === "POLYGON" ? this._type = GEOMETRY_TYPE_POLYGON : l === "MULTIPOINT" ? (this._type = GEOMETRY_TYPE_POINT, this._isMulti = !0, this._size = c.coordinates.length) : l === "MULTILINESTRING" ? (this._type = GEOMETRY_TYPE_LINE, this._isMulti = !0, this._size = c.coordinates.length) : l === "MULTIPOLYGON" ? (this._type = GEOMETRY_TYPE_POLYGON, this._isMulti = !0, this._size = c.coordinates.length) : (this._isValid = !1, console.warn("DataItem: geometry is invalid")), this._originalCoordinates = c.coordinates;
      }
      i.crs && (s = getCRSName(i.crs)), i.properties && Object.assign(a, i.properties);
    } else
      console.warn("DataItem: feature is invalid");
    Object.assign(a, e), this._attributes = a, a.id !== void 0 && (this._id = a.id), !s && a.crs && (s = getCRSName(a.crs)), this._sourceProjectionName = s, !s || s === PROJECTION_GEO && !r ? this._coordinates = this._originalCoordinates : this._projectedCoordinates[s] = this._originalCoordinates;
  }
  _getTransformedCoordinates(i, e) {
    if (!this._transformedCoordinates) {
      const r = this.coordinates;
      i && e && CoordTransformer.canTransform(i, e) ? this._transformedCoordinates = transformArrayCoordinates(
        r,
        i,
        e
      ) : this._transformedCoordinates = r;
    }
    return this._transformedCoordinates;
  }
  getProjectedCoordinates(i, e = 0, r, s) {
    return this._projectedCoordinates[i.name] ? this._isMulti ? this._projectedCoordinates[i.name][e] : this._projectedCoordinates[i.name] : (this._projectedCoordinates[i.name] = projectArrayCoordinates(
      this._getTransformedCoordinates(r, s),
      i
    ), this._isMulti ? this._projectedCoordinates[i.name][e] : this._projectedCoordinates[i.name]);
  }
  toGeoJSON() {
    let i = "Point";
    return this._type === GEOMETRY_TYPE_LINE ? i = "LineString" : this._type === GEOMETRY_TYPE_POLYGON && (i = "Polygon"), this._isMulti && (i = "Multi" + i), {
      type: "Feature",
      geometry: {
        type: i,
        coordinates: this.coordinates
      },
      properties: this._attributes
    };
  }
  setCoordinates(i, e) {
    this._coordinates = null, this._projectedCoordinates = {}, this._isMulti && (this._size = i.length), e ? (this._sourceProjectionName = e.name, this._originalCoordinates = i, this._projectedCoordinates[e.name] = i) : this._coordinates = i;
  }
  setAttribute(i, e) {
    this._attributes[i] = e;
  }
  setAttributes(i) {
    Object.assign(this._attributes, i);
  }
  get attributes() {
    return this._attributes;
  }
  get id() {
    return this._id;
  }
  set id(i) {
    if (this._id !== void 0) {
      console.warn("DataItem: id is already set");
      return;
    }
    this._id = i;
  }
  get coordinates() {
    if (!this._coordinates) {
      const i = getProjection(this._sourceProjectionName);
      this._coordinates = unprojectArrayCoordinates(this._originalCoordinates, i);
    }
    return this._coordinates;
  }
  get sourceProjectionName() {
    return this._sourceProjectionName;
  }
  get type() {
    return this._type;
  }
  get isMulti() {
    return this._isMulti;
  }
  get size() {
    return this._size;
  }
  get isValid() {
    return this._isValid;
  }
}
const OPERATION_ADD = 1, OPERATION_REMOVE = 2, OPERATION_LOAD = 4;
class DataSource {
  constructor(i = {}) {
    _(this, "_generatedIdIndex", 1);
    _(this, "_objects", []);
    _(this, "_data", {});
    _(this, "_userData", []);
    _(this, "_userDataNeedsUpdate", !1);
    _(this, "_dataItems", []);
    _(this, "_attributeMap", /* @__PURE__ */ new Map());
    _(this, "_needsUpdate", !0);
    _(this, "_idIndexMap", {});
    _(this, "_indexIdMap", {});
    _(this, "_queuedData", []);
    _(this, "_isCurve", !1);
    _(this, "_filter", null);
    _(this, "_sourceCoordType");
    _(this, "_targetCoordType");
    this._options = i, this._sourceCoordType = i.coordType || void 0, this._id = i.id || new Date().valueOf(), i.attributes && this.defineAttributes(i.attributes);
  }
  async load(i) {
    if (!i || typeof i != "string") {
      console.warn("url is required");
      return;
    }
    try {
      const e = await fetch(i), r = await this._convertStreamingDataToObjectData(e);
      this._queuedData.push({
        operation: OPERATION_LOAD,
        data: r
      }), this.needsUpdate = !0;
    } catch (e) {
      console.error("load data error", e);
    }
    return this;
  }
  async _convertStreamingDataToObjectData(i) {
    console.error("please implement _convertStreamingDataToObjectData method");
  }
  _parseObjectDataToDataItems(i) {
    console.error("please implement _parseObjectDataToDataItems method");
  }
  defineAttribute(i, e) {
    return e ? this._attributeMap.set(i, e) : this._attributeMap.set(i, i), this.needsUpdate = !0, this;
  }
  setAttribute(i, e) {
    return console.warn("setAttribute is deprecated, please use defineAttribute instead."), this.defineAttribute(i, e);
  }
  defineAttributes(i) {
    let e = Object.keys(i);
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      this._attributeMap.set(s, i[s]);
    }
    return this.needsUpdate = !0, this;
  }
  setAttributes(i) {
    return console.warn("setAttributes is deprecated, please use defineAttributes instead."), this.defineAttributes(i);
  }
  undefineAttribute(i) {
    return this._attributeMap.delete(i), this.needsUpdate = !0, this;
  }
  removeAttribute(i) {
    return console.warn("removeAttribute is deprecated, please use undefineAttribute instead."), this.undefineAttribute(i);
  }
  undefineAllAttributes() {
    return this._attributeMap.clear(), this.needsUpdate = !0, this;
  }
  removeAttributes() {
    return console.warn("removeAttributes is deprecated, please use undefineAllAttributes instead."), this.undefineAllAttributes();
  }
  add(i) {
    return this._queuedData.push({
      operation: OPERATION_ADD,
      data: Array.isArray(i) ? i : [i]
    }), this.needsUpdate = !0, this;
  }
  remove(i) {
    return this._queuedData.push({
      operation: OPERATION_REMOVE,
      data: Array.isArray(i) ? i : [i]
    }), this.needsUpdate = !0, this;
  }
  setAttributeValue(i, e, r) {
    return this.setAttributeValues(i, {
      [e]: r
    });
  }
  setAttributeValues(i, e) {
    Array.isArray(i) || (i = [i]);
    for (let r = 0; r < i.length; r++) {
      const s = i[r], a = this._idIndexMap[s];
      a !== void 0 && this._dataItems[a].setAttributes(e);
    }
    return this.needsUpdate = !0, this;
  }
  setCoordinates(i, e, r) {
    Array.isArray(i) || (i = [i]);
    for (let s = 0; s < i.length; s++) {
      const a = i[s], c = this._idIndexMap[a];
      c !== void 0 && this._dataItems[c].setCoordinates(e, r);
    }
    return this.needsUpdate = !0, this;
  }
  get(i) {
    let e = {};
    if (!(!this.data.position || !this.data.position.length || i === void 0 || i >= this.data.position.length)) {
      for (const r in this.data)
        if (Object.hasOwnProperty.call(this.data, r)) {
          const s = this.data[r];
          e[r] = s[i];
        }
      return e;
    }
  }
  getDataItemIndex(i) {
    return this.data.index[i];
  }
  getDataItem(i) {
    const e = this.getDataItemIndex(i);
    if (e !== void 0)
      return this._dataItems[e];
  }
  exportToGeoJSON() {
    let i = [];
    for (let e = 0; e < this._dataItems.length; e++) {
      const r = this._dataItems[e];
      i.push(r.toGeoJSON());
    }
    return {
      type: "FeatureCollection",
      features: i
    };
  }
  _executeAddData(i) {
    for (let e = 0; e < i.length; e++) {
      const r = i[e];
      if (this._filter instanceof Function && !this._filter(r, e))
        continue;
      r.id || (r.id = "_gid_" + this._generatedIdIndex++);
      const s = r.id;
      if (this._idIndexMap[s] !== void 0)
        continue;
      const a = this._dataItems.length;
      this._indexIdMap[a] = s, this._idIndexMap[s] = a, this._dataItems.push(r);
    }
  }
  _executeRemoveData(i) {
    for (let e = 0; e < i.length; e++) {
      const r = i[e];
      let s;
      if (r instanceof DataItem || Array.prototype.toString.call(r) === "[object Object]" ? s = r.id : s = r, s !== void 0) {
        const a = this._idIndexMap[s];
        if (a === void 0) {
          console.warn("remove fail1", a, s);
          return;
        }
        const c = this._dataItems.length - 1;
        if (a > c) {
          console.warn("remove fail2", a, s);
          return;
        }
        if (a < c) {
          const l = this._indexIdMap[c];
          this._dataItems[a] = this._dataItems[c], this._indexIdMap[a] = l, this._idIndexMap[l] = a;
        }
        delete this._idIndexMap[s], delete this._indexIdMap[c], this._dataItems.length = this._dataItems.length - 1;
      }
    }
  }
  _processData(i) {
    this._templateDataLength = i.index.length;
    let e = null, r = 0;
    for (let s = 0; s < this._dataItems.length; s++)
      if (e = this._dataItems[s], !!e.isValid) {
        e.isMulti ? r = e.size : r = 1;
        for (let a = 0; a < r; a++) {
          const c = e.getProjectedCoordinates(
            this.projection,
            a,
            this._sourceCoordType,
            this._targetCoordType
          );
          i.position.push(c), i.index.push(s);
          for (const l of this._attributeMap.keys()) {
            let h;
            const d = this._attributeMap.get(l);
            e.attributes && e.attributes[d] !== void 0 && e.attributes[d] !== null ? h = e.attributes[d] : d instanceof Function && (h = d(e.attributes, e, a, s)), i[l].push(h);
          }
        }
      }
  }
  update() {
    if (this.isDirectBuffer) {
      this.needsUpdate = !1;
      return;
    }
    const i = this._queuedData.length;
    if (i > 0)
      for (let s = 0; s < i; s++) {
        const a = this._queuedData.shift();
        if (a.operation === OPERATION_LOAD) {
          const c = this._parseObjectDataToDataItems(a.data);
          this._executeAddData(c);
        } else
          a.operation === OPERATION_ADD ? this._executeAddData(a.data) : a.operation === OPERATION_REMOVE && this._executeRemoveData(a.data);
      }
    let e = {
      position: [],
      index: []
    }, r = [];
    for (const s of this._attributeMap.keys())
      e[s] = [];
    this._processData(e, r), this._data = e, this._userDataNeedsUpdate = !0, this.needsUpdate = !1;
  }
  setData(i) {
    this.clear(), this._queuedData.push({
      operation: OPERATION_LOAD,
      data: i
    }), this.needsUpdate = !0;
  }
  clear() {
    this._data = {}, this._userData = [], this._queuedData = [], this._dataItems = [], this.needsUpdate = !0, this._idIndexMap = {}, this._indexIdMap = {}, this.onClear();
  }
  setFilter(i) {
    this._filter = i, this.needsUpdate = !0;
  }
  onClear() {
  }
  _formatGeometry(i) {
    return i ? Array.isArray(i) ? {
      type: "Point",
      coordinates: i
    } : i.isVector3 ? {
      type: "Point",
      coordinates: [i.x, i.y, i.z]
    } : i : null;
  }
  dispose() {
    this.clear();
  }
  get dataItems() {
    return this._dataItems;
  }
  get size() {
    return this.needsUpdate && this.update(), this.data && this.data.position && this.data.position.length || 0;
  }
  get data() {
    return this._data;
  }
  get userData() {
    if (!this._userDataNeedsUpdate)
      return this._userData;
    if (!this._data || !this._data.position || !this._data.position.length)
      return [];
    const i = [];
    let e = null;
    for (let r = 0, s = this._data.position.length; r < s; r++) {
      const a = {
        position: this._data.position[r],
        index: this._data.index[r]
      };
      for (const c of this._attributeMap.keys())
        e = this._data[c] && this._data[c][r], a[c] = e;
      i.push(a);
    }
    return this._userData = i, this._userDataNeedsUpdate = !1, this._userData;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(i) {
    this._needsUpdate = i;
  }
  get objects() {
    return this._objects;
  }
  set objects(i) {
    this._objects = i;
  }
  set targetCoordType(i) {
    this._targetCoordType = i, this._sourceCoordType && this._targetCoordType && !CoordTransformer.canTransform(this._sourceCoordType, this._targetCoordType) && console.warn(`DataSource: ${this._sourceCoordType} to ${this._targetCoordType} is not supported`);
  }
  get sourceCoordType() {
    return this._sourceCoordType;
  }
  get targetCoordType() {
    return this._targetCoordType;
  }
}
class ThreeObject extends Object3D {
  constructor(e) {
    super();
    _(this, "_enableRtc", !0);
    _(this, "_cachedRtc", [0, 0, 0]);
    _(this, "makeMeshPositionOffset", (e) => {
      this._cachedRtc = [e[0], e[1], e[2] || 0], this.updateTransform();
    });
    _(this, "makeGeometryOffsetPosition", (e, r, s) => {
      if (!this._enableRtc)
        return;
      const a = e.boundingSphere && e.boundingSphere.center;
      if (!a) {
        this._cachedRtc = [0, 0, 0], this.updateTransform();
        return;
      }
      const { x: c, y: l, z: h } = a;
      e.isCustomInstancedBufferGeometry ? this.makePostionArrayOffset(e.attributes.instancedPosition.array, c, l, h, r, s) : (this.makePostionArrayOffset(e.attributes.position.array, c, l, h, r, s), e.attributes.position.array.length), e.computeBoundingSphere(), this._cachedRtc = [c, l, h], this.updateTransform();
    });
    _(this, "makePostionArrayOffset", (e, r, s, a, c, l) => {
      if (!e || e.length < 3)
        return;
      const h = typeof l == "number" ? Math.min(l, e.length) : e.length;
      let d = c || e;
      for (let f = 0; f < h - 2; f += 3)
        e[f] = d[f] - r, e[f + 1] = d[f + 1] - s, e[f + 2] = d[f + 2] - a;
    });
    _(this, "updateTransform", () => {
      const [e, r, s] = this._cachedRtc;
      this.position.set(e, r, s), this.updateMatrixWorld(!0);
    });
    Object.defineProperties(this, {
      enableRtc: {
        get: function() {
          return this._enableRtc;
        },
        set: function(r) {
          this._enableRtc = r;
        }
      }
    });
  }
  defineGeometryProxyProperties(e = []) {
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      Object.defineProperty(this, s, {
        get: function() {
          return this.geometry[s];
        },
        set: function(a) {
          this.geometry[s] = a;
        }
      });
    }
  }
  defineGeometryUpdateProxyProperties(e = []) {
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      Object.defineProperty(this, s, {
        get: function() {
          return this.geometry[s];
        },
        set: function(a) {
          this.geometry[s] = a, this.needsUpdate = !0;
        }
      });
    }
  }
  defineMaterialProxyProperties(e = []) {
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      Object.defineProperty(this, s, {
        get: function() {
          return this.material[s];
        },
        set: function(a) {
          this.material[s] = a;
        }
      });
    }
  }
  defineMaterialUpdateProxyProperties(e = []) {
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      Object.defineProperty(this, s, {
        get: function() {
          return this.material[s];
        },
        set: function(a) {
          this.material[s] = a, this.material.needsUpdate = !0;
        }
      });
    }
  }
  defineMaterialColorProxyProperties(e = []) {
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      Object.defineProperty(this, s, {
        get: function() {
          return this.material[s];
        },
        set: function(a) {
          this.material[s] = normalizeColor(a);
        }
      });
    }
  }
  raycast(e, r) {
    !this.visible || super.raycast(e, r);
  }
}
class GeoObject extends ThreeObject {
  constructor() {
    super(...arguments);
    _(this, "isGeoObject", !0);
    _(this, "dataAutoUpdate", !0);
    _(this, "_parameters");
    _(this, "_dataSource");
    _(this, "_dataSourceUpdated");
    _(this, "_needsUpdate");
    _(this, "_zooms", [0, 100]);
    _(this, "_zoomVisibleCache");
    _(this, "engine");
    _(this, "_attributeRenameMap", {});
    _(this, "travelFeatureLineCoordinate", (e, r, s) => {
      const a = e.geometry;
      if (!a || !a[r] || !a.type)
        return;
      const c = a[r];
      if (a.type === "LineString")
        s && s(c);
      else if (a.type === "MultiLineString" || a.type === "Polygon")
        for (let l of c)
          s && s(l);
      else if (a.type === "MultiPolygon")
        for (let l of c)
          for (let h of l)
            s && s(h);
    });
    _(this, "travelLineCoordinates", (e, r = "coordinates", s, a = 0) => {
      if (!(!Array.isArray(e) || !s))
        for (let c = 0, l = e.length; c < l; c++) {
          const h = e[c], d = a + c, f = h.geometry;
          if (!f || !f[r] || !f.type)
            continue;
          const p = f[r];
          if (f.type === "LineString")
            s && s(p, h, d);
          else if (f.type === "MultiLineString" || f.type === "Polygon")
            for (let m of p)
              s && s(m, h, d);
          else if (f.type === "MultiPolygon")
            for (let m of p)
              for (let y of m)
                s && s(y, h, d);
        }
    });
    _(this, "travelPolygonCoordinates", (e, r = "coordinates", s, a = 0) => {
      if (!(!Array.isArray(e) || !s))
        for (let c = 0, l = e.length; c < l; c++) {
          const h = e[c], d = a + c, f = h.geometry;
          if (!f || !f[r] || !f.type)
            continue;
          const p = f[r];
          if (f.type === "Polygon")
            s && s(p, h, d);
          else if (f.type === "MultiPolygon")
            for (let m of p)
              s && s(m, h, d);
          else if (f.type === "LineString")
            s && s([p], h, d);
          else if (f.type === "MultiLineString")
            for (let m of p)
              s && s([m], h, d);
        }
    });
    _(this, "travelPointCoordinates", (e, r = "coordinates", s, a = 0) => {
      if (!(!Array.isArray(e) || !s))
        for (let c = 0, l = e.length; c < l; c++) {
          const h = e[c], d = a + c, f = h.geometry;
          if (!f || !f[r] || !f.type)
            continue;
          const p = f[r];
          f.type === "Point" && s && s(p, h, d);
        }
    });
    _(this, "getPointsBounding", (e, r = "coordinates") => {
      let s = 1 / 0, a = 1 / 0, c = 1 / 0, l = -1 / 0, h = -1 / 0, d = -1 / 0;
      return this.travelPointCoordinates(e, r, (f) => {
        const [p, m, y = 0] = f;
        p < s && (s = p), p > l && (l = p), m < a && (a = m), m > h && (h = m), y < c && (c = y), y > d && (d = y);
      }), isFinite(s) || (s = 0), isFinite(l) || (l = 0), isFinite(a) || (a = 0), isFinite(h) || (h = 0), isFinite(c) || (c = 0), isFinite(d) || (d = 0), [s, a, c, l, h, d];
    });
  }
  get parameters() {
    return this._parameters;
  }
  set parameters(e) {
    this._parameters ? this._parameters = { ...this._parameters, ...e } : this._parameters = { ...this.getDefaultParams(), ...e };
  }
  get dataSource() {
    return Object.keys(this._attributeRenameMap).length === 0 ? this._dataSource : ((!this._proxyDataSource || this._proxyDataSourceNeedsUpdate) && (this._proxyDataSource = this._createProxyDataSource(), this._proxyDataSourceNeedsUpdate = !1), this._proxyDataSource);
  }
  set dataSource(e) {
    this.setDataSource(e);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  get zooms() {
    return this._zooms;
  }
  set zooms(e) {
    this._zooms = e;
  }
  get inZoomsRange() {
    const e = this.engine;
    return e ? e.map.getZoom() >= this.zooms[0] && e.map.getZoom() <= this.zooms[1] : !1;
  }
  _createProxyDataSource() {
    return new Proxy(this._dataSource, {
      get: (e, r) => r === "data" ? this._createMappedObjectProxy(e.data) : r === "userData" ? this._createLazyMappedArrayProxy(e.userData) : Reflect.get(e, r)
    });
  }
  _createMappedObjectProxy(e) {
    return new Proxy(e, {
      get: (r, s) => {
        const a = this._attributeRenameMap[s] || s;
        return r[a];
      },
      set: (r, s, a) => {
        const c = this._attributeRenameMap[s] || s;
        return r[c] = a, console.warn("property of dataSource should not be set by user in Proxy", s), !0;
      }
    });
  }
  _createLazyMappedArrayProxy(e) {
    return new Proxy(e, {
      get: (r, s) => {
        const a = Reflect.get(r, s);
        return typeof s == "string" && /^\d+$/.test(s) ? this._createMappedObjectProxy(a) : a;
      },
      set: (r, s, a) => (console.warn("property of dataSource should not be set by user in Proxy", s), Reflect.set(r, s, a))
    });
  }
  addAttributeRename(e, r) {
    this._attributeRenameMap[e] = r, this._proxyDataSourceNeedsUpdate = !0;
  }
  removeAttributeRename(e) {
    delete this._attributeRenameMap[e], this._proxyDataSourceNeedsUpdate = !0;
  }
  clearAttributeRename() {
    this._attributeRenameMap = {}, this._proxyDataSourceNeedsUpdate = !0;
  }
  afterAddToEngine(e) {
    this.engine = e, this.initObject();
    const r = e.map.isGlobe;
    this.material && (this.material.isGlobe = r), this.isInstancedMesh && this.material && (this.material.defines ? this.material.defines.IS_INSTANCE = !0 : this.material.defines = {
      IS_INSTANCE: !0
    });
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  initObject() {
  }
  getDefaultParams() {
    return {};
  }
  getEntityByIndex(e) {
    const r = this.dataSource;
    if (!r)
      return;
    const s = {
      index: e,
      value: r.getDataItem(e),
      itemIndex: r.getDataItemIndex(e),
      pairs: {}
    }, a = r.data;
    for (const c of Object.keys(a))
      s.pairs[c] = a[c][e];
    return s;
  }
  setDataSource(e) {
    if (!e) {
      if (this._dataSource) {
        const r = this._dataSource.objects.indexOf(this);
        r > -1 && this._dataSource.objects.splice(r, 1), this._dataSource = null, this.needsUpdate = !0, this.engine.requestRender();
      }
      return;
    }
    e.objects.indexOf(this) > -1 || (this._dataSource = e, e.targetCoordType = this.engine.map.coordType, e.projection = this.engine.map.projection, e.objects.push(this), this.needsUpdate = !0, this.engine.requestRender());
  }
  onBeforeScenePrepareRender(e, r, s, a) {
    !this.dataSource || (this.dataSource.needsUpdate && (this.dataSource.update(), this.needsUpdate = !0), this.dataAutoUpdate && this.needsUpdate && this._enableCollision && (e.rendering.collision.needsUpdate = !0), this.onBeforeScenePrepareRenderHook && this.onBeforeScenePrepareRenderHook(e, r, s, a), this.visible && !this.inZoomsRange ? (this._zoomVisibleCache = this.visible, this.visible = !1) : !this.visible && this._zoomVisibleCache && this.inZoomsRange && (this.visible = this._zoomVisibleCache, this._zoomVisibleCache = void 0));
  }
  onBeforeSceneRender(e, r, s, a) {
    !this.dataSource || (this.dataAutoUpdate && this.needsUpdate && !this._enableCollision ? this._updateData() : this.dataAutoUpdate && this.isGroundPrimitive && this.isDynamic ? this._updateData() : this.dataAutoUpdate && this._collisionUpdated ? (this._updateData(), this._collisionUpdated = !1) : this.geometry && this.geometry.needsUpdate && this.geometry.updateGeometry && (this.geometry.updateGeometry(), this.afterGeometryUpdate && this.afterGeometryUpdate()), this.onBeforeSceneRenderHook && this.onBeforeSceneRenderHook(e, r, s, a));
  }
  _updateData() {
  }
  collisionTest(e) {
    return {};
  }
  onDispose() {
  }
  dispose() {
    if (this.geometry && this.geometry.dispose(), this.material)
      if (Array.isArray(this.material))
        for (let e = 0; e < this.material.length; e++)
          this.material[e].dispose();
      else
        this.material.dispose();
    this.onDispose();
  }
  bindTerrain(e) {
    this._terrain = e;
  }
}
class GeoMesh extends GeoObject {
  constructor() {
    super(...arguments);
    _(this, "isMesh", !0);
  }
}
const _offset$1 = new Vector3$1(), _box$3 = new Box3(), _boxMorphTargets = new Box3(), _vector$6 = new Vector3$1();
class SymbolGeometry extends BufferGeometry {
  constructor(i) {
    super(i), this.parameters = i, this._drawRange = 0, this._init = !1;
  }
  setData(i) {
    if (this._init) {
      this.updateData(i);
      return;
    }
    const {
      positions: e,
      indices: r,
      typesAndPIndices: s,
      uvs: a,
      whs: c,
      rotateZs: l,
      offsets: h,
      instanceRotationMatrices: d,
      styles: f,
      drawRange: p,
      fadeOpacityAndSince: m,
      stretch: y
    } = i;
    a.length > 0 && this.setAttribute("uv", new Float32BufferAttribute(a, 2)), l.length > 0 && this.setAttribute("rotateZ", new Float32BufferAttribute(l, 1)), h.length > 0 && this.setAttribute("offset", new Float32BufferAttribute(h, 2)), d.length > 0 && this.setAttribute("instanceRotationMatrix", new Float32BufferAttribute(d, 9)), m.length > 0 && this.setAttribute("fadeOpacityAndSince", new Float32BufferAttribute(m, 2)), this.setAttribute("whAndSize", new Float32BufferAttribute(c, 3)), this.setAttribute("stretch", new Float32BufferAttribute(y, 4));
    const x = new InterleavedBuffer(f, 9);
    this.setAttribute("fillStyles", new InterleavedBufferAttribute(x, 4, 0)), this.setAttribute("strokeStyles", new InterleavedBufferAttribute(x, 4, 4)), this.setAttribute("strokeWidth", new InterleavedBufferAttribute(x, 1, 8)), this.setAttribute("position", new Float32BufferAttribute(e, 3));
    const v = new InterleavedBuffer(s, 2);
    this.setAttribute("pIndex", new InterleavedBufferAttribute(v, 1, 1)), this.setAttribute("type", new InterleavedBufferAttribute(v, 1, 0)), this.setIndex(r), this._drawRange = p, this._init = !0;
  }
  updateData(i) {
    const {
      positions: e,
      uvs: r,
      whs: s,
      rotateZs: a,
      offsets: c,
      instanceRotationMatrices: l,
      styles: h,
      typesAndPIndices: d,
      indices: f,
      drawRange: p,
      fadeOpacityAndSince: m,
      stretch: y
    } = i, x = p / 3, v = this.getAttribute("position");
    for (let N = 0; N < x; N++)
      v.setXYZ(N, e[N * 3], e[N * 3 + 1], e[N * 3 + 2]);
    v.needsUpdate = !0;
    const S = this.getAttribute("uv");
    if (S)
      for (let N = 0; N < x; N++)
        S.setXY(N, r[N * 2], r[N * 2 + 1]);
    S.needsUpdate = !0;
    const E = this.getAttribute("rotateZ");
    if (E)
      for (let N = 0; N < x; N++)
        E.setX(N, a[N]);
    E.needsUpdate = !0;
    const b = this.getAttribute("offset");
    if (b)
      for (let N = 0; N < x; N++)
        b.setXYZW(
          N,
          c[N * 2],
          c[N * 2 + 1]
        );
    b.needsUpdate = !0;
    const w = this.getAttribute("fadeOpacityAndSince");
    if (w)
      for (let N = 0; N < x; N++)
        w.setXY(N, m[N * 2], m[N * 2 + 1]);
    w.needsUpdate = !0;
    const M = this.getAttribute("instanceRotationMatrix");
    if (M)
      for (let N = 0; N < x; N++) {
        const U = N * 9;
        M.set([
          l[U],
          l[U + 1],
          l[U + 2],
          l[U + 3],
          l[U + 4],
          l[U + 5],
          l[U + 6],
          l[U + 7],
          l[U + 8]
        ], U);
      }
    M.needsUpdate = !0;
    const P = this.getAttribute("whAndSize");
    if (P)
      for (let N = 0; N < x; N++)
        P.setXYZ(N, s[N * 3], s[N * 3 + 1], s[N * 3 + 2]);
    P.needsUpdate = !0;
    const D = this.getAttribute("stretch");
    if (D)
      for (let N = 0; N < x; N++)
        D.setXYZW(N, y[N * 4], y[N * 4 + 1], y[N * 4 + 2], y[N * 4 + 3]);
    D.needsUpdate = !0;
    const L = this.getAttribute("fillStyles"), O = this.getAttribute("strokeStyles"), F = this.getAttribute("strokeWidth");
    if (L && O)
      for (let N = 0; N < x; N++)
        L.setXYZW(N, h[N * 9], h[N * 9 + 1], h[N * 9 + 2], h[N * 9 + 3]), O.setXYZW(
          N,
          h[N * 9 + 4],
          h[N * 9 + 5],
          h[N * 9 + 6],
          h[N * 9 + 7]
        ), F.setX(N, h[N * 9 + 8]);
    L.needsUpdate = !0, O.needsUpdate = !0, F.needsUpdate = !0;
    const k = this.getAttribute("type"), V = this.getAttribute("pIndex");
    if (k && V)
      for (let N = 0; N < x; N++)
        k.setX(N, d[N * 2]), V.setX(N, d[N * 2 + 1]);
    k.needsUpdate = !0, V.needsUpdate = !0, this._drawRange = p, this.setIndex(f);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    const i = this.attributes.position, e = this.morphAttributes.position;
    if (i && i.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ), this.boundingSphere.set(new Vector3$1(), 1 / 0);
      return;
    }
    if (i) {
      const r = this.boundingSphere.center, s = i.array.slice(0, this._drawRange);
      if (_box$3.setFromArray(s), e)
        for (let c = 0, l = e.length; c < l; c++) {
          const h = e[c];
          _boxMorphTargets.setFromBufferAttribute(h), this.morphTargetsRelative ? (_vector$6.addVectors(_box$3.min, _boxMorphTargets.min), _box$3.expandByPoint(_vector$6), _vector$6.addVectors(_box$3.max, _boxMorphTargets.max), _box$3.expandByPoint(_vector$6)) : (_box$3.expandByPoint(_boxMorphTargets.min), _box$3.expandByPoint(_boxMorphTargets.max));
        }
      _box$3.getCenter(r);
      let a = 0;
      for (let c = 0, l = s.length; c < l; c += 3)
        _vector$6.fromArray(s, c), a = Math.max(a, r.distanceToSquared(_vector$6));
      if (e)
        for (let c = 0, l = e.length; c < l; c++) {
          const h = e[c], d = this.morphTargetsRelative;
          for (let f = 0, p = h.count; f < p; f++)
            _vector$6.fromBufferAttribute(h, f), d && (_offset$1.fromBufferAttribute(i, f), _vector$6.add(_offset$1)), a = Math.max(a, r.distanceToSquared(_vector$6));
        }
      this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
        this
      );
    }
  }
}
const vertexShader$t = `#define GLSLIFY 1
#include <common>
uniform vec2 pixelOffset;
uniform vec3 positionOffset;
uniform bool u_flat;

#ifdef RENDER_IN_POSTPROCESS
    uniform float cameraFar;
#endif

#ifdef IS_GLOBE
    attribute mat3 instanceRotationMatrix;
#endif

attribute float pIndex;
attribute vec3 whAndSize;
attribute vec4 stretch;
// attribute float size;
attribute float rotateZ;
attribute float type;
attribute vec4 strokeStyles;
attribute vec4 fillStyles;
attribute float strokeWidth;
attribute vec2 offset;

varying vec2 v_uv;
varying float v_type;
varying float v_iconOpacity;
varying float vScale;
varying float opacityRatio;
varying vec4 vStretch;

varying vec4 vStrokeStyles;
varying vec4 vFillStyles;
varying float vSize;
varying float vStrokeWidth;

#ifdef RENDER_IN_POSTPROCESS
    varying vec2 vClipSpacePosition;
    varying float vLogDepth;
#endif

uniform float elapsedTime;
#ifdef MVT_ENABLE_FADE
    attribute vec2 fadeOpacityAndSince;
    uniform float fadeDuration;
    varying float vFadeOpacity;
#endif

// \u4EC5\u4EC5text\u6709\u7684
// offset, anchor, strokeStyles

vec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {
    float x = coord.x;
    float y = coord.y;
    if (corner == 1.0) {
        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);
    } else if (corner == 2.0) {
        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else if (corner == 3.0) {
        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else {
        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);
    }
    return vec3(x, y, coord.z);
}

#include <logdepthbuf_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>
#include <mvt_animation_pars_vertex>
void main() {
    v_uv = uv;
    v_type = type;

    opacityRatio = 1.0;
    vScale = 1.0;
    vStretch = stretch;

    #include <mvt_animation_label_vertex>

    vec2 wh = whAndSize.xy;
    float size = whAndSize.z;

    mat4 currentInstanceMatrix = mat4(1.0);
    vec3 currentPosition = position;
    #ifdef IS_GLOBE
        currentInstanceMatrix = mat4(
            vec4(instanceRotationMatrix[0], 0.0),
            vec4(instanceRotationMatrix[1], 0.0),
            vec4(instanceRotationMatrix[2], 0.0),
            vec4(position, 1.0)
        );

        currentPosition = vec3(0.0, 0.0, 0.0);
    #endif

    #ifdef ENABLE_ANIMATION_JUMP
        currentPosition.z += jumpHeight;
    #endif

    vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));

    #ifdef RENDER_IN_POSTPROCESS
        vec4 clipSpacePosition = projectionMatrix * viewMatrix * worldPosition;
        vClipSpacePosition.xy = ((clipSpacePosition.xy / clipSpacePosition.w) + 1.0) / 2.0;

        float fcoef = 1.0 / log2(cameraFar + 1.0);
        float logDepth = log2(max(1e-6, 1.0 + clipSpacePosition.w)) * fcoef;
        vLogDepth = logDepth;
    #endif

    if (type == 0.0) {
        float iconRotateZ = rotateZ;
        v_iconOpacity = fillStyles.w;
        // vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        if (u_flat) {
            float hw = wh.x * 0.5 * vScale;
            float hh = wh.y * 0.5 * vScale;

            if (keepSize) {
                float pixelSize = getPixelSize(worldPosition.xyz);
                hw *= pixelSize;
                hh *= pixelSize;
            }

            #ifdef ENABLE_ANIMATION_ROTATE
            iconRotateZ += rotation;
            #endif
            vec3 current = transformCoord(currentPosition, vec2(hw, hh), pIndex, -iconRotateZ);

            gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);
        }
        else {
            worldPosition.x += positionOffset.x;
            worldPosition.y += positionOffset.y;
            worldPosition.z += positionOffset.z;
            gl_Position = projectionMatrix * viewMatrix * worldPosition;
            float w = gl_Position.w;
            gl_Position /= w;

            float hw = wh.x / resolution.x * vScale;
            float hh = wh.y / resolution.y * vScale;

            float pixelSize = getPixelSize(worldPosition.xyz);
            float iconOffsetX = offset.x * 2.0 / resolution.x * vScale;
            float iconOffsetY = offset.y * 2.0 / resolution.y * vScale;
            if (!keepSize) {
                hw = hw / pixelSize;
                hh = hh / pixelSize;

                iconOffsetX /= pixelSize;
                iconOffsetY /= pixelSize;
            }
            gl_Position.x += pixelOffset.x / resolution.x;
            gl_Position.y += pixelOffset.y / resolution.y;

            if (pIndex == 1.0) {
                gl_Position.x -= hw;
                gl_Position.y += hh;
            } else if (pIndex == 2.0) {
                gl_Position.x += hw;
                gl_Position.y += hh;
            } else if (pIndex == 3.0) {
                gl_Position.x += hw;
                gl_Position.y -= hh;
            } else {
                gl_Position.x -= hw;
                gl_Position.y -= hh;
            }

            gl_Position.x += iconOffsetX;
            gl_Position.y += iconOffsetY;

            gl_Position *= w;
        }
    }
    else {
        float textRotateZ = rotateZ;

        // vec4 worldPosition = (modelMatrix * vec4(position, 1.0));

        if (u_flat) {
            // viewMatrix[0]\u8868\u793A\u76F8\u673A\u7684\u53F3\u65B9\u5411\uFF0C\u4E0D\u7BA1\u76F8\u673A\u5982\u4F55\u503E\u659Ctilt\uFF0C\u6CD5\u5411\u91CF\u90FD\u6307\u5411\u6B63\u5317\u65B9\u5411\uFF0C\u6B63\u597D\u53EF\u4EE5\u7528\u6765\u8BA1\u7B97\u548C\u6587\u5B57\u7684\u5939\u89D2
            mat4 localViewMatrix = viewMatrix * currentInstanceMatrix;
            vec4 right = localViewMatrix[0];
            float theta = dot(vec2(sin(textRotateZ), cos(textRotateZ)), vec2(-right.y, right.x));
            if (theta < 0.0) {
                textRotateZ += PI;
            }
            // TODO \u652F\u6301offset
            float hw = wh.x * 0.5 * vScale;
            float hh = wh.y * 0.5 * vScale;

            float pixelSize = getPixelSize(worldPosition.xyz);
            float xOffset = offset.x * vScale;
            float yOffset = offset.y * vScale;
            if (keepSize) {
                hw = hw * pixelSize;
                hh = hh * pixelSize;

                xOffset *= pixelSize;
                yOffset *= pixelSize;
            }

            #ifdef ENABLE_ANIMATION_ROTATE
            textRotateZ += rotation;
            #endif
            vec3 transformedPoint =  transformCoord(currentPosition, vec2(xOffset, yOffset), 2.0, -textRotateZ);
            vec3 current = transformCoord(transformedPoint, vec2(hw, hh), pIndex, -textRotateZ);

            gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);

            // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        }
        else {
            // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);
            worldPosition.x += positionOffset.x;
            worldPosition.y += positionOffset.y;
            worldPosition.z += positionOffset.z;
            vec4 pos = projectionMatrix * viewMatrix * worldPosition;
            float w = pos.w;
            vec3 screen = pos.xyz / w;

            float hw = wh.x / resolution.x * vScale;
            float hh = wh.y / resolution.y * vScale;

            float textOffsetX = offset.x * 2.0 / resolution.x * vScale;
            float textOffsetY = offset.y * 2.0 / resolution.y * vScale;
            if (!keepSize) {
                float pixelSize = getPixelSize(worldPosition.xyz);
                hw = hw / pixelSize;
                hh = hh / pixelSize;

                textOffsetX /= pixelSize;
                textOffsetY /= pixelSize;
            }

            screen.x += pixelOffset.x / resolution.x;
            screen.y += pixelOffset.y / resolution.y;

            vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -textRotateZ);

            current = vec3(current.x + textOffsetX, current.y + textOffsetY, current.z);

            gl_Position = vec4(current, 1.0);

            gl_Position *= w;

        }

        vStrokeStyles = strokeStyles;
        vFillStyles = fillStyles;
        vSize = size;
        vStrokeWidth = strokeWidth;
    }

    #ifdef MVT_ENABLE_FADE
        float fadeDiff = (elapsedTime - fadeOpacityAndSince.y) / fadeDuration;
        if (fadeOpacityAndSince.x > 2.0) {
            fadeDiff = clamp(fadeDiff, 0.0, 1.0);
            vFadeOpacity = fadeOpacityAndSince.x - fadeDiff - 2.0;
            // vFadeOpacity = vFadeOpacity * vFadeOpacity;
        } else {
            vFadeOpacity = fadeOpacityAndSince.x + fadeDiff;
            // vFadeOpacity = sqrt(vFadeOpacity);
        }
        vFadeOpacity = clamp(vFadeOpacity, 0.0, 1.0);
    #endif

    #include <logdepthbuf_vertex>
}`, fragmentShader$r = `#define GLSLIFY 1
#ifdef USE_ICON
uniform sampler2D spriteMap;
uniform sampler2D map;
#endif

#ifdef USE_TEXT
uniform sampler2D textMap;
#endif
uniform sampler2D depthTexture;
uniform float pixelRatio;
uniform bool useMap;

varying vec2 v_uv;
varying float v_type;
varying float v_iconOpacity;
varying vec4 vFillStyles;
varying vec4 vStrokeStyles;
varying float vStrokeWidth;
varying float vSize;
varying vec4 vStretch;

#ifdef RENDER_IN_POSTPROCESS
    varying vec2 vClipSpacePosition;
    varying float vLogDepth;
#endif

#ifdef MVT_ENABLE_FADE
    varying float vFadeOpacity;
#endif

#include <logdepthbuf_pars_fragment>
#include <tonemapping_pars_fragment>
#include <output_pars_fragment>
void main() {
    // #ifdef RENDER_IN_POSTPROCESS
    //     float depthValue = texture2D(depthTexture, vClipSpacePosition).r;
    //     float bias = 0.002; // \u907F\u514D\u8BBE\u7F6E\u4E00\u4E2A\u9608\u503C\uFF0C\u7CBE\u5EA6\u8BEF\u5DEE\u9020\u6210\u6587\u5B57\u7ED8\u5236\u4E0D\u7A33\u5B9A
    //     if (vLogDepth > depthValue + bias) {
    //         discard;
    //     }
    // #endif

    // \u4E09\u683C\u62C9\u4F38, \u89E3\u51B3\u62C9\u4F38\u53D8\u5F62\u95EE\u9898
    vec2 uv = v_uv;
    if (v_uv.x < vStretch.x + vStretch.w) {
        uv.x = vStretch.x + (v_uv.x - vStretch.x) * vStretch.z;
    }
    else if (v_uv.x > vStretch.y - vStretch.w) {
        uv.x = vStretch.y - (vStretch.y - v_uv.x) * vStretch.z;
    }
    else {
        float startU = vStretch.x + vStretch.w * vStretch.z;
        float endU = vStretch.y - vStretch.w * vStretch.z;
        float uvOffset = endU - startU;

        uv.x = startU + (v_uv.x - (vStretch.x + vStretch.w)) / (vStretch.y - vStretch.x - vStretch.w * 2.0) * uvOffset;
    }
    if (v_type == 0.0) {
        #ifdef USE_ICON
            if (useMap) {
                gl_FragColor = texture2D(map, vec2(uv.x, 1.0 - uv.y));
            }
            else {
                gl_FragColor = texture2D(spriteMap, vec2(uv.x, 1.0 - uv.y));
            }

            gl_FragColor.a *= v_iconOpacity;
        #endif
    }
    else {
        #ifdef USE_TEXT
            float fontScale = vSize / 24.0;
            float gamma = (0.105 / pixelRatio) / fontScale;
            float buff = (256.0 - 64.0) / 256.0;

            float distance = texture2D(textMap, vec2(v_uv.x, v_uv.y)).r;
            float alpha = smoothstep(buff - gamma, buff + gamma, distance);
            vec3 fontColor = vFillStyles.xyz;
            float fillAlpha = vFillStyles.w;

            if (vStrokeWidth > 0.0) {
                float inFill = alpha;
                float outlineBuffer = (6.0 - vStrokeWidth / fontScale) / 8.0;
                float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);

                float ratio = smoothstep(0.0, 1.0, inFill);
                fontColor = mix(vStrokeStyles.xyz, fontColor, ratio);
                fillAlpha = mix(vStrokeStyles.w, fillAlpha, ratio);
                alpha = inBorder;
            }

            gl_FragColor = vec4(fontColor, alpha * fillAlpha);
        #endif

    }

    #ifdef MVT_ENABLE_FADE
        gl_FragColor.a *= vFadeOpacity;
    #endif

    if (gl_FragColor.a <= 0.) {
        discard;
    }

    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>

    #include <output_fragment>
}`, commonUniforms = {
  height: { value: 0 },
  size: { value: 1 },
  size3: { value: [1, 1, 1] },
  resolution: { value: [1, 1] },
  zoomUnits: { value: 1 },
  color: { value: [1, 0, 0] },
  opacity: { value: 1 }
}, animationUnifroms = {
  animationRotatePeriod: { value: 4e3 },
  animationJumpPeriod: { value: 4e3 },
  animationJumpHeight: { value: 30 },
  animationPeriodOffset: { value: !1 },
  animationEffect: { value: !0 },
  animationEffectPeriod: { value: 4e3 },
  animationPeriod: { value: 4e3 }
}, defineCommonProperties = (o) => {
  Object.defineProperties(o, {
    color: {
      get: function() {
        return this.uniforms.color.value;
      },
      set: function(i) {
        this.uniforms.color.value = normalizeColor(i);
      }
    },
    height: {
      get: function() {
        return this.uniforms.height.value;
      },
      set: function(i) {
        this.uniforms.height.value = i;
      }
    },
    size: {
      get: function() {
        return this.uniforms.size.value;
      },
      set: function(i) {
        this.uniforms.size.value = i;
      }
    },
    size3: {
      get: function() {
        return this.uniforms.size3.value;
      },
      set: function(i) {
        Array.isArray(i) && i.length === 3 && (this.uniforms.size3.value = i);
      }
    },
    useSize3: {
      get: function() {
        return this.defines.USE_SIZE3;
      },
      set: function(i) {
        i === this.defines.USE_SIZE3 && (this.defines.USE_SIZE3 = !!i), this.needsUpdate = !0;
      }
    },
    opacity: {
      get: function() {
        return this.uniforms.opacity.value;
      },
      set: function(i) {
        this.uniforms.opacity.value = i;
      }
    }
  });
}, defineAnimationProperties = (o) => {
  Object.defineProperties(o, {
    animationRotate: {
      get: function() {
        return !!this.defines.ENABLE_ANIMATION_ROTATE;
      },
      set: function(i) {
        i !== this.animationRotate && (i ? this.defines.ENABLE_ANIMATION_ROTATE = !0 : delete this.defines.ENABLE_ANIMATION_ROTATE, this.needsUpdate = !0);
      }
    },
    animationRotatePeriod: {
      get: function() {
        return this.uniforms.animationRotatePeriod.value;
      },
      set: function(i) {
        this.uniforms.animationRotatePeriod.value = i;
      }
    },
    animationJump: {
      get: function() {
        return !!this.defines.ENABLE_ANIMATION_JUMP;
      },
      set: function(i) {
        i !== this.animationJump && (i ? this.defines.ENABLE_ANIMATION_JUMP = !0 : delete this.defines.ENABLE_ANIMATION_JUMP, this.needsUpdate = !0);
      }
    },
    animationJumpPeriod: {
      get: function() {
        return this.uniforms.animationJumpPeriod.value;
      },
      set: function(i) {
        this.uniforms.animationJumpPeriod.value = i;
      }
    },
    animationJumpHeight: {
      get: function() {
        return this.uniforms.animationJumpHeight.value;
      },
      set: function(i) {
        this.uniforms.animationJumpHeight.value = i;
      }
    },
    animationPeriodOffset: {
      get: function() {
        return this.uniforms.animationPeriodOffset.value;
      },
      set: function(i) {
        this.uniforms.animationPeriodOffset.value = i;
      }
    },
    animationEffect: {
      get: function() {
        return this.uniforms.animationEffect.value;
      },
      set: function(i) {
        this.uniforms.animationEffect.value = i;
      }
    },
    animationEffectPeriod: {
      get: function() {
        return this.uniforms.animationEffectPeriod.value;
      },
      set: function(i) {
        this.uniforms.animationEffectPeriod.value = i;
      }
    },
    animationScale: {
      get: function() {
        return !!this.defines.ENABLE_ANIMATION_SCALE;
      },
      set: function(i) {
        i !== this.animationScale && (i ? this.defines.ENABLE_ANIMATION_SCALE = !0 : delete this.defines.ENABLE_ANIMATION_SCALE, this.needsUpdate = !0);
      }
    },
    animationBreath: {
      get: function() {
        return !!this.defines.ENABLE_ANIMATION_BREATH;
      },
      set: function(i) {
        i !== this.animationBreath && (i ? this.defines.ENABLE_ANIMATION_BREATH = !0 : delete this.defines.ENABLE_ANIMATION_BREATH, this.needsUpdate = !0);
      }
    },
    animationPeriod: {
      get: function() {
        return this.uniforms.animationPeriod.value;
      },
      set: function(i) {
        this.uniforms.animationPeriod.value = i;
      }
    }
  });
}, uniforms$r = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  commonUniforms,
  animationUnifroms,
  {
    spriteMap: { value: null },
    textMap: { value: null },
    map: { value: null },
    useMap: { value: !1 },
    pixelOffset: { value: [0, 0] },
    positionOffset: { value: [0, 0, 0] },
    targetScale: { value: 2 },
    minScale: { value: 0 },
    maxScale: { value: 2 },
    opacityGradient: { value: !1 },
    opacity: { value: 1 },
    keepSize: {
      value: !0
    },
    depthTexture: {
      value: null
    },
    u_flat: {
      value: !1
    },
    cameraFar: {
      value: 0
    },
    srgbTransformer: {
      value: !1
    },
    fadeDuration: {
      value: 300
    }
  }
]), textureLoader$a = new TextureLoader();
class SymbolMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "SymbolMaterial", this.vertexShader = vertexShader$t, this.fragmentShader = fragmentShader$r, this.transparent = !0, this.depthTest = !1, this._mapSrc = "", Object.assign(this.uniforms, UniformsUtils.clone(uniforms$r)), defineCommonProperties(this), defineAnimationProperties(this), defineMaterialKeepSizeProperties(this), defineMaterialAliasProperties(this, [
      ["flat", "u_flat"]
    ]), defineMaterialBoolDefineProperties(this, [
      ["isRenderInPostprocess", "RENDER_IN_POSTPROCESS"],
      ["isGlobe", "IS_GLOBE"],
      ["useText", "USE_TEXT"],
      ["useIcon", "USE_ICON"],
      ["enableFade", "MVT_ENABLE_FADE"]
    ]), defineMaterialNormalProperties(this, [
      "depthTexture",
      "cameraFar",
      "resolution",
      "pixelOffset",
      "positionOffset",
      "opacity",
      "fadeDuration"
    ]), Object.defineProperties(this, {
      spriteTexture: {
        get: function() {
          return this.uniforms.spriteMap.value;
        },
        set: function(e) {
          if (!e) {
            this.uniforms.spriteMap.value = null;
            return;
          }
          this.uniforms.spriteMap.value = e;
        }
      },
      textTexture: {
        get: function() {
          return this.uniforms.textMap.value;
        },
        set: function(e) {
          if (!e) {
            this.uniforms.textMap.value = null;
            return;
          }
          this.uniforms.textMap.value = e;
        }
      },
      mapSrc: {
        get: function() {
          return this._mapSrc;
        },
        set: function(e) {
          if (this.mapSrc !== e) {
            if (this.uniforms.map.value && this.uniforms.map.value.dispose(), !e) {
              this.uniforms.map.value = null, this.uniforms.useMap.value = !1;
              return;
            }
            textureLoader$a.load(e, (s) => {
              s.wrapS = s.wrapT = ClampToEdgeWrapping, s.colorSpace = SRGBColorSpace, this.uniforms.map.value = s, this.uniforms.useMap.value = !0, this._mapSrc = e;
            });
          }
        }
      }
    }), this.setValues(i);
  }
  dispose() {
    this.uniforms.spriteMap.value && this.uniforms.spriteMap.value.dispose(), this.uniforms.textMap.value && this.uniforms.textMap.value.dispose(), super.dispose();
  }
}
const MISSING_CHAR_WIDTH = 32, SINGLE_LINE = [];
function nextPowOfTwo(o) {
  return Math.pow(2, Math.ceil(Math.log2(o)));
}
function getDefaultCharacterSet() {
  const o = [];
  for (let i = 32; i < 128; i++)
    o.push(String.fromCharCode(i));
  return o;
}
function buildMappingWithContext({
  characterSet: o,
  context: i,
  fontHeight: e,
  buffer: r,
  maxCanvasWidth: s,
  mapping: a = {},
  xOffset: c = 0,
  yOffset: l = 0,
  defaultFontWeight: h,
  fontFamily: d
}) {
  let f = 0, p = c, m = 0;
  for (const y of o) {
    const { char: x, fontWeight: v } = y, S = x + defaultValue$1(v, h) + d;
    if (!a[S]) {
      const E = i.measureText(x), b = Math.ceil(E.width);
      let w = E.actualBoundingBoxAscent + E.actualBoundingBoxDescent;
      w === 0 && (w = b), w += r, p + b + r * 2 > s && (p = 0, f++, m = 0), m = Math.max(m, e + r * 2), a[S] = {
        x: p + r,
        y: l + f * m + r,
        width: b,
        height: m,
        layoutWidth: b,
        layoutHeight: e,
        textHeight: Math.ceil(Math.max(w, b))
      }, p += b + r * 2;
    }
  }
  return {
    mapping: a,
    xOffset: p,
    yOffset: l + f * m,
    canvasHeight: nextPowOfTwo(l + (f + 1) * m)
  };
}
function getTextWidth(o, i, e, r) {
  var a;
  let s = 0;
  for (let c = i; c < e; c++) {
    const l = o[c];
    s += ((a = r[l]) == null ? void 0 : a.layoutWidth) || 0;
  }
  return s;
}
function breakAll(o, i, e, r, s, a) {
  let c = i, l = 0;
  for (let h = i; h < e; h++) {
    const d = getTextWidth(o, h, h + 1, s);
    l + d > r && (c < h && a.push(h), c = h, l = 0), l += d;
  }
  return l;
}
function breakWord(o, i, e, r, s, a) {
  let c = i, l = i, h = i, d = 0;
  for (let f = i; f < e; f++)
    if ((o[f] === " " || o[f + 1] === " " || f + 1 === e) && (h = f + 1), h > l) {
      let p = getTextWidth(o, l, h, s);
      d + p > r && (c < l && (a.push(l), c = l, d = 0), p > r && (p = breakAll(
        o,
        l,
        h,
        r,
        s,
        a
      ), c = a[a.length - 1])), l = h, d += p;
    }
  return d;
}
function autoWrapping(o, i, e, r, s = 0, a) {
  a === void 0 && (a = o.length);
  const c = [];
  return i === "break-all" ? breakAll(o, s, a, e, r, c) : breakWord(o, s, a, e, r, c), c;
}
function transformRow(o, i, e, r, s, a, c) {
  let l = 0, h = 0;
  for (let d = i; d < e; d++) {
    const f = o[d], p = r[f];
    p ? (h || (h = p.layoutHeight), s[d] = l + p.layoutWidth / 2, l += p.layoutWidth + c) : (s[d] = l, l += MISSING_CHAR_WIDTH);
  }
  a[0] = l - c, a[1] = h;
}
function transformParagraph(o, i, e, r, s, a, c = 0, l = [0, 0]) {
  var O, F;
  let h;
  Array.isArray(i) ? h = i : h = Array.from(i);
  const d = h.length, f = new Array(d), p = new Array(d), m = new Array(d), y = (r === "break-word" || r === "break-all") && isFinite(s) && s > 0, x = [0, 0], v = [0, 0], S = [];
  let E = 0, b = 0, w = 0, M = 0, P = 1;
  const [D, L] = l;
  for (let k = 0; k <= d; k++) {
    const V = o[k];
    if ((V === "\\" || k === d) && (M = k), M > w) {
      const N = y ? autoWrapping(h, r, s, a, w, M) : SINGLE_LINE;
      for (let U = 0; U <= N.length; U++) {
        const z = U === 0 ? w : N[U - 1], $ = U < N.length ? N[U] : M;
        transformRow(h, z, $, a, f, v, c + D);
        for (let G = z; G < $; G++) {
          const j = h[G], Y = ((O = a[j]) == null ? void 0 : O.layoutOffsetY) || 0, H = ((F = a[j]) == null ? void 0 : F.textHeight) || 0;
          p[G] = b - Y, m[G] = v[0], S.push(H), E += H;
        }
        b += v[1] * e + L, x[0] = Math.max(x[0], v[0]);
      }
      w = M;
    }
    V === "\\" && (f[w] = 0, p[w] = 0, m[w] = 0, w++, P++);
  }
  return x[1] = Math.max(0, b), { x: f, y: p, rowWidth: m, size: x, rowNum: P, heightSize: E, textHeights: S };
}
const measureCache = {};
function wrapText(o, i, e, r) {
  const s = r + "," + e + "," + i;
  let a = measureCache[s];
  if (!a) {
    const c = i.split(" ");
    if (c.length > 1) {
      const h = o.measureText("M").width * r;
      let d = "";
      const f = [];
      for (let p = 0, m = c.length; p < m; ++p) {
        const y = c[p], x = d + (d ? " " : "") + y;
        o.measureText(x).width <= h ? d = x : (d && f.push(d), d = y);
      }
      d && f.push(d);
      for (let p = 0, m = f.length; p < m && m > 1; ++p) {
        const y = f[p];
        if (o.measureText(y).width < h * 0.35) {
          const v = o.measureText(f[p - 1]).width, S = o.measureText(f[p + 1]).width, E = p > 0 ? v : 1 / 0, b = p < m - 1 ? S : 1 / 0;
          f.splice(p, 1), m -= 1, E < b ? (f[p - 1] += " " + y, p -= 1) : f[p] = y + " " + f[p];
        }
      }
      for (let p = 0, m = f.length - 1; p < m; ++p) {
        const y = f[p], x = f[p + 1];
        if (o.measureText(y) > h * 0.7 && o.measureText(x) < h * 0.6) {
          const v = y.split(" "), S = v.pop();
          o.measureText(S) < h * 0.2 && (f[p] = v.join(" "), f[p + 1] = S + " " + x), m -= 1;
        }
      }
      a = f.join("\\");
    } else
      a = i;
    measureCache[s] = a;
  }
  return a;
}
class LRUCache$1 {
  constructor(i) {
    _(this, "triggerRemoveEvent", (i, e) => {
      try {
        this.onRemove(e, i);
      } catch (r) {
        console.warn("error occurs when disposing tile", r);
      }
    });
    this.cache = {}, this.head = this.tail = null, this.length = 0, this.max = i.max || 1e3, this.maxAge = i.maxAge || 0, this.onRemove = i.onRemove || (() => {
    });
  }
  clear() {
    for (const i of Object.keys(this.cache)) {
      const e = this.cache[i];
      this.triggerRemoveEvent(i, e.value);
    }
    this.cache = {}, this.head = this.tail = null, this.length = 0;
  }
  remove(i) {
    if (!this.cache.hasOwnProperty(i))
      return;
    const e = this.cache[i];
    return delete this.cache[i], this._unlink(i, e.prev, e.next), e.value;
  }
  _unlink(i, e, r) {
    this.length--, this.length === 0 ? this.head = this.tail = null : this.head === i ? (this.head = e, this.cache[this.head].next = null) : this.tail === i ? (this.tail = r, this.cache[this.tail].prev = null) : (this.cache[e].next = r, this.cache[r].prev = e);
  }
  peek(i) {
    if (!this.cache.hasOwnProperty(i))
      return;
    const e = this.cache[i];
    if (!!this._checkAge(i, e))
      return e.value;
  }
  set(i, e) {
    let r = null;
    if (this.cache.hasOwnProperty(i)) {
      if (r = this.cache[i], r.value = e, this.maxAge && (r.modified = Date.now()), i === this.head)
        return e;
      this._unlink(i, r.prev, r.next);
    } else
      r = {
        value: e,
        modified: 0,
        next: null,
        prev: null
      }, this.maxAge && (r.modified = Date.now()), this.cache[i] = r, this.length === this.max && this.evict();
    return this.length++, r.next = null, r.prev = this.head, this.head && (this.cache[this.head].next = i), this.head = i, this.tail || (this.tail = i), e;
  }
  _checkAge(i, e) {
    return this.maxAge && Date.now() - e.modified > this.maxAge ? (this.remove(i), this.triggerRemoveEvent(e.value, i), !1) : !0;
  }
  has(i) {
    return this.cache.hasOwnProperty(i) && this._checkAge(i, this.cache[i]);
  }
  get(i) {
    if (!this.cache.hasOwnProperty(i))
      return;
    const e = this.cache[i];
    if (!!this._checkAge(i, e))
      return this.head !== i && (i === this.tail ? (this.tail = e.next, this.cache[this.tail].prev = null) : this.cache[e.prev].next = e.next, this.cache[e.next].prev = e.prev, this.cache[this.head].next = i, e.prev = this.head, e.next = null, this.head = i), e.value;
  }
  evict() {
    if (!this.tail)
      return;
    const i = this.tail, e = this.remove(this.tail);
    this.triggerRemoveEvent(i, e);
  }
}
const INITIAL_CANVAS_WIDTH = 512, INITIAL_CANVAS_HEIGHT = 512, SDF_SCALE$2 = 1, fontSettings$2 = {
  fontSize: 24 * SDF_SCALE$2,
  buffer: 3 * SDF_SCALE$2,
  radius: 8 * SDF_SCALE$2
};
function getNewChars(o) {
  let i;
  return typeof o == "string" ? i = new Set(Array.from(o)) : i = new Set(o), i;
}
function setTextStyle(o, i, e, r) {
  o.font = `${e}px ${i}`, o.fillStyle = "#000", o.textAlign = "start", o.textBaseline = "top";
}
const lruCacheSize = 2e3, localGlyphs = new LRUCache$1({
  max: lruCacheSize
});
class FontAtlasManager {
  constructor() {
    _(this, "props", {});
    _(this, "_entry", {});
    _(this, "_textureData", new Uint8Array(INITIAL_CANVAS_WIDTH * INITIAL_CANVAS_HEIGHT));
    _(this, "_currentWidth", INITIAL_CANVAS_WIDTH);
    _(this, "_currentHeight", INITIAL_CANVAS_HEIGHT);
    _(this, "_xOffset", 0);
    _(this, "_yOffset", 0);
    _(this, "_mapping", {});
    _(this, "_canvasHeight", 0);
    _(this, "_atlas");
    _(this, "_ctx");
    _(this, "_version", 0);
  }
  get atlas() {
    return this._atlas;
  }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  setProps(i = {}) {
    Object.assign(this.props, i);
    const e = getNewChars(this.props.characterSet);
    this._generateFontAtlas(e);
    const r = this._createTextureData(e);
    this._atlas = r;
  }
  async setPropsAsync(i, e = {}, r = 30) {
    Object.assign(this.props, e);
    const s = getNewChars(this.props.characterSet), a = Array.from(s);
    this._prepareFontAtlas();
    let c = 0;
    const l = a.length;
    return new Promise((h) => {
      const d = () => {
        const f = Math.min(c + r, l), p = a.slice(c, f);
        this._generateFontAtlas(p), this._processCharBatch(p) ? c = 0 : c = f, c < l ? i.addTask(() => Promise.resolve(d())) : (this._finalizeTextureData(), h());
      };
      i.addTask(() => Promise.resolve(d()));
    });
  }
  _prepareFontAtlas() {
    const i = document.createElement("canvas");
    i.width = this._currentWidth, this._ctx = i.getContext("2d", { willReadFrequently: !0 }), setTextStyle(this._ctx, this.props.fontFamily, fontSettings$2.fontSize);
  }
  _generateFontAtlas(i) {
    var l;
    const { fontSize: e, buffer: r, radius: s } = fontSettings$2, { fontFamily: a, sdf: c } = this.props;
    if (!!c)
      for (const h of i) {
        let d, f;
        typeof h == "string" ? (d = this.props.fontWeight, f = h) : (d = defaultValue$1(h.fontWeight || ((l = h.textStyle) == null ? void 0 : l.fontWeight), this.props.fontWeight), f = h.char);
        const p = f + d + a;
        if (localGlyphs.get(p))
          continue;
        let m = this._entry[a];
        m || (this._entry[a] = {}, m = this._entry[a]);
        let y = m[d];
        y || (y = new TinySDF({ fontSize: e, buffer: r, radius: s, fontFamily: a, fontWeight: `${d}` }), y.ctx.textBaseline = "top", this._entry[a][d] = y);
        const x = y.draw(f);
        localGlyphs.set(p, x);
      }
  }
  _processCharBatch(i) {
    const { fontWeight: e, fontFamily: r } = this.props, { buffer: s } = fontSettings$2, { mapping: a, canvasHeight: c, xOffset: l, yOffset: h } = buildMappingWithContext({
      characterSet: i,
      context: this._ctx,
      fontHeight: fontSettings$2.fontSize,
      buffer: s,
      maxCanvasWidth: this._currentWidth,
      mapping: this._mapping,
      xOffset: this._xOffset,
      yOffset: this._yOffset,
      defaultFontWeight: e,
      fontFamily: r
    });
    c > this._currentHeight && (this._currentHeight = c, this._textureData = new Uint8Array(this._currentWidth * this._currentHeight));
    const d = this._ctx.canvas.width, f = this._textureData;
    for (const p of i) {
      const m = typeof p == "string" ? p : p.char, y = typeof p == "string" ? e : defaultValue$1(p.fontWeight, e), x = m + y + r, { data: v, width: S, height: E, glyphTop: b } = localGlyphs.get(x), w = a[x];
      w.layoutOffsetY = b;
      const M = Math.floor(w.y * d + w.x);
      for (let P = 0; P < E; P++) {
        const D = M + P * d, L = P * S;
        for (let O = 0; O < S; O++)
          f[D + O] = v[L + O];
      }
    }
    this._xOffset = l, this._yOffset = h;
  }
  _finalizeTextureData() {
    const i = new Uint8Array(this._textureData);
    this._atlas = {
      textureData: i,
      xOffset: this._xOffset,
      yOffset: this._yOffset,
      mapping: this._mapping,
      width: this._currentWidth,
      height: this._currentHeight
    };
  }
  _debugRenderTexture() {
    let i = document.getElementById("debug-texture-atlas");
    i || (i = document.createElement("canvas"), i.id = "debug-texture-atlas", i.style.position = "fixed", i.style.left = "20px", i.style.bottom = "20px", i.style.zIndex = "10000", i.style.imageRendering = "pixelated", document.body.appendChild(i));
    const { textureData: e, width: r, height: s } = this._atlas, a = 4, c = 480, l = 480;
    let h = r * a, d = s * a;
    if (h > c || d > l) {
      const m = Math.min(c / h, l / d);
      h = Math.floor(r * a * m), d = Math.floor(s * a * m);
    }
    i.width = h, i.height = d;
    const f = i.getContext("2d"), p = f.createImageData(h, d);
    for (let m = 0; m < d; m++)
      for (let y = 0; y < h; y++) {
        const x = Math.floor(y / h * r), S = Math.floor(m / d * s) * r + x, E = e[S] || 0, b = (m * h + y) * 4;
        p.data[b] = E, p.data[b + 1] = E, p.data[b + 2] = E, p.data[b + 3] = 255;
      }
    f.putImageData(p, 0, 0), this._atlas.mapping && (f.strokeStyle = "rgba(255, 0, 0, 0.3)", f.lineWidth = 1, Object.values(this._atlas.mapping).forEach((m) => {
      const y = m.x / r * h, x = m.y / s * d, v = m.width / r * h, S = m.height / s * d;
      f.strokeRect(y, x, v, S);
    }));
  }
  _createTextureData(i) {
    return this._reset(), this._prepareFontAtlas(), this._processCharBatch(Array.from(i)), this._finalizeTextureData(), this._atlas;
  }
  _reset() {
    this._textureData && this._textureData.fill(0), this._mapping = {}, this._xOffset = 0, this._yOffset = 0;
  }
}
class FadeData {
  constructor(i = {}) {
    _(this, "_fadeDuration", 300);
    _(this, "_idField", "id");
    _(this, "_lastData", []);
    _(this, "_filterData", []);
    _(this, "_lastDataMap", {});
    _(this, "_fadeSinceField", "fadeSince");
    _(this, "_fadeOpacityField", "fadeOpacity");
    _(this, "_stableTime", 0);
    _(this, "_debugTrackLogId", null);
    this._fadeDuration = defaultValue$1(i.fadeDuration, 300);
  }
  processId(i) {
    return i;
  }
  _dataToMap(i) {
    if (!Array.isArray(i))
      return {};
    const e = {};
    for (const r of i) {
      const s = this.processId(r[this._idField]);
      s !== void 0 && (e[s] = r);
    }
    return e;
  }
  isStable(i) {
    return i >= this._stableTime;
  }
  update(i, e, r = !1) {
    Array.isArray(i) || (console.warn("data should be an array"), i = []);
    let s = e;
    const a = this._dataToMap(i), c = r && this._dataToMap(this.filterData), l = this._lastDataMap, h = this._lastData, d = this._fadeDuration, f = [];
    for (const p of i) {
      const m = this.processId(p[this._idField]), y = m && l[m];
      if (this._debugTrackLogId, y) {
        const x = y[this._fadeOpacityField] || 0, v = y[this._fadeSinceField];
        if (this._debugTrackLogId, x > 2) {
          this._debugTrackLogId;
          const S = e - v;
          p[this._fadeOpacityField] = 1e-3, p[this._fadeSinceField] = e - (d - S), f.push(p), s = Math.max(s, e + d);
        } else
          this._debugTrackLogId, p[this._fadeOpacityField] = y[this._fadeOpacityField], p[this._fadeSinceField] = y[this._fadeSinceField], f.push(p), s = Math.max(s, v + d);
      } else
        this._debugTrackLogId, p[this._fadeSinceField] = e, p[this._fadeOpacityField] = 1e-3, m === void 0 && (p[this._fadeOpacityField] = 1), f.push(p), s = Math.max(s, e + d);
    }
    for (const p of h) {
      const m = this.processId(p[this._idField]);
      if (m !== void 0 && (this._debugTrackLogId, !(r && !c[m]) && !a[m])) {
        const y = p[this._fadeOpacityField] || 0, x = p[this._fadeSinceField], v = e - x;
        if (y <= 1)
          this._debugTrackLogId, p[this._fadeOpacityField] = 3, v < d ? p[this._fadeSinceField] = e - (d - v) : p[this._fadeSinceField] = e, f.push(p), a[m] = p, s = Math.max(s, e + d);
        else {
          this._debugTrackLogId;
          let S = y - v / d - 2;
          S = MathUtils.clamp(S, 0, 1), S > 0 && (f.push(p), a[m] = p, s = Math.max(s, x + d));
        }
      }
    }
    this._stableTime = s, this._lastData = f, this._lastDataMap = a;
  }
  get filterData() {
    return this._filterData;
  }
  set filterData(i) {
    this._filterData = i;
  }
  get data() {
    return this._lastData;
  }
  get fadeDuration() {
    return this._fadeDuration;
  }
  set fadeDuration(i) {
    this._fadeDuration = i;
  }
}
const getFontSize = (o, i, e, r, s, a = 1, c = 1) => (o.font = `${c}px Microsoft Yahei`, o.textBaseline = "top", o.measureText(e).width + i[1] + i[3] >= r || c * a + 1 * (a - 1) + i[0] + i[2] >= s ? c - 1 : getFontSize(o, i, e, r, s, a, c + 1)), createSprite = (o, i, e, r = {}) => {
  let s = !1;
  const a = potpack(o);
  let { fillStyle: c, fontSize: l, gap: h, padding: d, dpr: f, drawText: p = !0, textAlign: m } = r;
  const y = a.w, x = a.h;
  (e.width !== y || e.height !== x) && (s = !0), e.width = y || 1, e.height = x || 1, i.save(), m && (i.textAlign = m);
  for (let v = 0; v < o.length; v++) {
    const S = o[v], E = S.icon, b = S.text;
    if (i.drawImage(E, S.x + h[0] / 2, S.y + h[1] / 2, S.width, S.height), defined$2(b) && p) {
      const w = `${String(b)}`.split("\\");
      w.forEach((M, P) => {
        l === "auto" && (l = getFontSize(i, d, M, S.width, S.height, w.length)), i.font = `${l}px Microsoft Yahei`, i.fillStyle = c, i.textBaseline = "top", i.fillText(
          M,
          S.x + h[0] / 2 + (m === "center" ? S.width / 2 : d[3]),
          S.y + h[1] / 2 + d[0] + (Number(l) + 1) * P
        );
      });
    }
  }
  return i.restore(), s;
}, url2canvas = (o, i, e) => {
  if (typeof o == "object")
    i(o);
  else {
    let r = new Image();
    r.crossOrigin = "anonymous", r.onload = function() {
      let s = r.width, a = r.height, c = document.createElement("canvas");
      c.width = s, c.height = a, c.getContext("2d").drawImage(r, 0, 0, s, a), i && i(c);
    }, r.onerror = function() {
      e && e();
    }, r.src = o;
  }
}, _tempPosition$1 = new Vector3$1(), _tempMatrix$2 = new Matrix4();
let curStyleId$2;
class TextBoxCalculator {
  constructor(i, e = {}) {
    this.ctx = i, this.engine = e.engine, this.dpr = this.engine.rendering.pixelRatio, this.padding = e.padding || [0, 0], this._textPadding = e.textPadding || [0, 0], this._textSize = e.textSize || 16, this._textWeight = e.textWeight || "normal", this._textStrokeWidth = e.textStrokeWidth || 0, this._textFamily = e.textFamily || "sans-serif";
  }
  getTextBox(i, e) {
    const r = this.ctx, s = this.dpr;
    this._textSize;
    const a = this._textFamily, c = this.padding, l = this._textPadding;
    i.textSize = defaultValue$1(i.textSize, this._textSize), i.textWeight = defaultValue$1(i.textWeight, this._textWeight), i.textStrokeWidth = defaultValue$1(i.textStrokeWidth, this._textStrokeWidth);
    const { textSize: h, textWeight: d, textStrokeWidth: f, maxWidth: p } = i;
    let m = String(i.text || "");
    const y = this.getStrictStyleId(i);
    r.save(), r.scale(s, s), r.textBaseline = "top";
    let x = i.textSize;
    if (y !== curStyleId$2 ? (this._setCanvasFont(r, h, d, f, a), curStyleId$2 = y) : r.font = `${i.textSize}px ${a}`, defined$2(p) && m && (m = wrapText(r, m, r.font, p)), e) {
      const w = i.rotateZ, M = this._processTextLayout(m, x), P = M.flat();
      this._calculateTransform(i.position, _tempMatrix$2);
      const D = _tempMatrix$2.extractRotation(_tempMatrix$2), L = this._applyRotateZ(P, w, D), O = this._calculateWidths(M), F = Math.max(...O) + 2 * c[0], k = x * O.length + 2 * c[1];
      return r.restore(), {
        width: F,
        height: k,
        wrappedText: m,
        widthList: O,
        chars: L,
        rotationMatrix: D
      };
    }
    const v = m.split("\\"), S = v.map((w) => r.measureText(w).width + (w.length - 1) * l[0]), E = Math.max(...S) + 2 * c[0], b = (x + l[1]) * v.length + 2 * c[1];
    return r.restore(), {
      width: E,
      height: b,
      wrappedText: m,
      widthList: S
    };
  }
  _setCanvasFont(i, e, r, s, a) {
    r >= 10 && r % 10 === 0 ? i.font = `${r} ${e}px ${a}` : i.font = `${e}px ${a}`, s > 0 && (i.lineWidth = s);
  }
  _processTextLayout(i, e) {
    const r = this.ctx, s = this.padding, a = String(i).split("\\"), l = -(a.length * e) / 2;
    return a.map((h, d) => {
      const f = [];
      let p = 0;
      for (const y of h) {
        const x = r.measureText(y).width;
        f.push({
          char: y,
          width: x,
          height: e,
          offsetX: 0,
          offsetY: -(l + e / 2 + d * e)
        }), p += x;
      }
      let m = -p / 2;
      for (const y of f)
        m += y.width / 2, y.offsetX = m, m += y.width / 2, y.width += 2 * s[0];
      return f;
    });
  }
  _applyRotateZ(i, e, r) {
    const s = this.engine.camera.matrixWorld;
    return this._calculateRotation(s, r, e) < 0 && (e += Math.PI), i.map(({ offsetX: c, offsetY: l, ...h }) => ({
      ...h,
      offsetX: c * Math.cos(e) - l * Math.sin(e),
      offsetY: c * Math.sin(e) + l * Math.cos(e)
    }));
  }
  _calculateRotation(i, e, r) {
    const s = new Matrix4().multiplyMatrices(i, e), a = s.elements[0], c = s.elements[1];
    return Math.sin(r) * -c + Math.cos(r) * a;
  }
  _calculateWidths(i) {
    return i.map(
      (e) => e.reduce((r, s) => r + s.width, 0)
    );
  }
  getStrictStyleId(i) {
    const {
      text: e,
      textSize: r,
      textWeight: s,
      textStrokeWidth: a
    } = i;
    return [
      e,
      r,
      s,
      a
    ].join("_");
  }
  _calculateTransform(i, e) {
    return this.engine.map.isGlobe ? (e || (e = new Matrix4()), Transforms.eastNorthUpToFixedFrame(_tempPosition$1.fromArray(i), null, e), e) : defaultValue$1.EMPTY_MAT4;
  }
}
class GeometryBufferBuilder {
  constructor(i = 3e4) {
    this.maxChar = i, this._initBuffers();
  }
  _initBuffers() {
    const i = this.maxChar;
    this.data = {
      positions: new Float32Array(i * 3),
      typesAndPIndices: new Float32Array(i * 2),
      rotateZs: new Float32Array(i),
      uvs: new Float32Array(i * 2),
      offsets: new Float32Array(i * 2),
      instanceRotationMatrices: new Float32Array(i * 9),
      whs: new Float32Array(i * 3),
      stretch: new Float32Array(i * 4),
      styles: new Float32Array(i * 9),
      fadeOpacityAndSince: new Float32Array(i * 2),
      indices: []
    }, this.offsets = {
      positionsOffset: 0,
      typesAndPIndicesOffset: 0,
      rotateZsOffset: 0,
      uvsOffset: 0,
      offsetsOffset: 0,
      instanceRotationMatricesOffset: 0,
      whsOffset: 0,
      stylesOffset: 0,
      fadeOpacityAndSinceOffset: 0,
      stretchOffset: 0
    }, this._cachePositions = [];
  }
  clear() {
    Object.keys(this.offsets).forEach((i) => this.offsets[i] = 0), this.data.indices.length = 0, this._cachePositions.length = 0;
  }
  packPosition(i, e, r) {
    for (let s = 0; s < 4; s++) {
      const a = this.offsets.positionsOffset;
      this.data.positions[a] = i, this.data.positions[a + 1] = e, this.data.positions[a + 2] = r, this.offsets.positionsOffset += 3, this._cachePositions.push(i, e, r);
    }
  }
  packUV(i) {
    this.data.uvs.set(i, this.offsets.uvsOffset), this.offsets.uvsOffset += 8;
  }
  packOffset(i, e) {
    for (let r = 0; r < 4; r++)
      this.data.offsets[this.offsets.offsetsOffset++] = i, this.data.offsets[this.offsets.offsetsOffset++] = e;
  }
  packTypeAndPIndex(i) {
    const e = this.offsets.typesAndPIndicesOffset;
    this.data.typesAndPIndices.set([i, 0, i, 1, i, 2, i, 3], e), this.offsets.typesAndPIndicesOffset += 8;
  }
  packRotateZ(i) {
    for (let e = 0; e < 4; e++)
      this.data.rotateZs[this.offsets.rotateZsOffset++] = i;
  }
  packStyle(i, e, r) {
    for (let s = 0; s < 4; s++) {
      const a = this.offsets.stylesOffset;
      this.data.styles.set([
        i[0],
        i[1],
        i[2],
        i[3],
        e[0],
        e[1],
        e[2],
        e[3],
        r
      ], a), this.offsets.stylesOffset += 9;
    }
  }
  packWH(i, e, r = 0) {
    for (let s = 0; s < 4; s++)
      this.data.whs[this.offsets.whsOffset++] = i, this.data.whs[this.offsets.whsOffset++] = e, this.data.whs[this.offsets.whsOffset++] = r;
  }
  packStretch(i = 0, e = 0, r = 1, s = 0) {
    for (let a = 0; a < 4; a++)
      this.data.stretch[this.offsets.stretchOffset++] = i, this.data.stretch[this.offsets.stretchOffset++] = e, this.data.stretch[this.offsets.stretchOffset++] = r, this.data.stretch[this.offsets.stretchOffset++] = s;
  }
  packRotationMatrix(i) {
    const e = i.elements;
    for (let r = 0; r < 4; r++)
      this.data.instanceRotationMatrices.set(e, this.offsets.instanceRotationMatricesOffset), this.offsets.instanceRotationMatricesOffset += 9;
  }
  packFade(i, e) {
    for (let r = 0; r < 4; r++)
      this.data.fadeOpacityAndSince[this.offsets.fadeOpacityAndSinceOffset++] = i, this.data.fadeOpacityAndSince[this.offsets.fadeOpacityAndSinceOffset++] = e;
  }
  packQuadIndices(i) {
    const e = i * 4;
    this.data.indices.push(
      e,
      e + 2,
      e + 1,
      e,
      e + 3,
      e + 2
    );
  }
  get drawRange() {
    return this.offsets.positionsOffset;
  }
}
const textAnchors = [
  "left",
  "right",
  "top",
  "bottom",
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
], currentInstanceMatrix = new Matrix4(), tempPosition = new Vector3$1(), tempRotationMatrix = new Matrix3(), TEXT_ALIGN$1 = {
  center: 0,
  left: 1,
  right: -1
}, SDF_SCALE$1 = 1, fontSettings$1 = {
  fontSize: 24 * SDF_SCALE$1,
  buffer: 3 * SDF_SCALE$1,
  radius: 8 * SDF_SCALE$1
}, SymbolType = {
  ICON: "icon",
  TEXT: "text",
  ICONTEXT: "icontext"
}, defaultUv = [0, 1, 0, 0, 1, 0, 1, 1], defaultOffset = [0, 0], _tempMatrix4$5 = new Matrix4(), _tempVector3$8 = new Vector3$1(), _tempVector2$4 = new Vector2$1(), _tempVector4$3 = new Vector4(), _tempOffset$1 = new Vector2$1(), _tempA$1 = new Vector3$1(), _morphA$1 = new Vector3$1(), _xAxis = new Vector3$1(), _yAxis = new Vector3$1();
class Label extends GeoMesh {
  constructor(e = {}) {
    super(e);
    _(this, "isEventEntitySupported", !0);
    _(this, "parameters");
    _(this, "spriteTexture");
    _(this, "textTexture");
    _(this, "_maxChar", 3e4);
    _(this, "_version", 0);
    _(this, "_cacheData", []);
    _(this, "oldMapTextureRes", /* @__PURE__ */ new Map());
    _(this, "iconUrlHash", new LRUCache$1({
      max: 100,
      onRemove: (e, r) => {
        const s = this.boxHash.get(r), a = this.boxes.indexOf(s);
        a >= 0 && this.boxes.splice(a, 1), this.boxHash.delete(r);
      }
    }));
    _(this, "boxHash", /* @__PURE__ */ new Map());
    _(this, "gap", [4, 4]);
    _(this, "_labelQuadStarts", []);
    _(this, "geometry");
    _(this, "material");
    _(this, "canvas");
    _(this, "ctx");
    _(this, "cachedTextData", []);
    _(this, "_collisionBoxCache", new LRUCache$1({
      max: 1e3
    }));
    _(this, "isRenderInPostprocess", !1);
    this.parameters = e, this.spriteTexture = e.spriteTexture, this.vertexIcons = e.vertexIcons, this.flat = defaultValue$1(e.flat, !1), this.symbolType = defaultValue$1(e.type, SymbolType.ICON), this._enableFade = defaultValue$1(e.enableFade, !1), this._enableFadeFilter = defaultValue$1(e.enableFadeFilter, !0), this._textSize = defaultValue$1(e.textSize, 16), this._textFamily = defaultValue$1(e.textFamily, "sans-serif"), e.textFillStyle ? this._textFillStyle = Array.isArray(e.textFillStyle) ? e.textFillStyle : colorToRgbaArr(e.textFillStyle) : this._textFillStyle = [255, 255, 255, 1], e.textStrokeStyle ? this._textStrokeStyle = Array.isArray(e.textStrokeStyle) ? e.textStrokeStyle : colorToRgbaArr(e.textStrokeStyle) : this._textStrokeStyle = [0, 0, 0, 1], this._textStrokeWidth = defaultValue$1(e.textStrokeWidth, 0), this._textAnchor = defaultValue$1(e.textAnchor, "center"), this._textOffset = defaultValue$1(e.textOffset, [0, 0]), this._textWeight = defaultValue$1(e.textWeight, "400"), this._rotateZ = defaultValue$1(e.rotateZ, 0), this._textPadding = defaultValue$1(e.textPadding, [0, 2]), this._padding = defaultValue$1(e.padding, [2, 2]), this.textAlign = defaultValue$1(this.parameters.textAlign, "center"), this.isRenderInPostprocess = this.parameters.isRenderInPostprocess || !1, this.symbolType === SymbolType.TEXT ? (this._iconWidth = 0, this._iconHeight = 0) : (this._iconWidth = defaultValue$1(this.parameters.iconWidth, 40), this._iconHeight = defaultValue$1(this.parameters.iconHeight, 40)), this._offset = defaultValue$1(this.parameters.offset, [0, 0]), this._fadeData = new FadeData({
      fadeDuration: this.parameters.fadeDuration
    }), this._fadeData.processId = (c) => c && c.split("_")[0], this._useIconScale = defaultValue$1(this.parameters.useIconScale, !1);
    const r = new FontAtlasManager();
    this.fontAtalasManager = r;
    const s = this.canvas = document.createElement("canvas");
    s.width = s.height = 1;
    const a = this.ctx = s.getContext("2d");
    a.textAlign = "start", a.textBaseline = "top", this.vertexIcons && (this.iconCanvas = document.createElement("canvas"), this.iconCanvas.width = this.iconCanvas.height = 1, this.iconCtx = this.iconCanvas.getContext("2d"), this.spriteTexture = new CanvasTexture(this.iconCanvas), this.spriteTexture.colorSpace = SRGBColorSpace), this.defineMaterialProxyProperties([
      "mapSrc",
      "transparent",
      "depthTest",
      "depthWrite",
      "opacity",
      "flat",
      "keepSize",
      "vertexColors",
      "positionOffset",
      "pixelOffset"
    ]), this.boxes = [];
  }
  initObject() {
    const e = this.symbolType === SymbolType.TEXT || this.symbolType === SymbolType.ICONTEXT, r = this.symbolType === SymbolType.ICON || this.symbolType === SymbolType.ICONTEXT, { fontFamily: s, fillStyle: a, strokeStyle: c, vertexIcons: l, textSize: h, useIconScale: d, ...f } = this.parameters;
    this.geometry = new SymbolGeometry(this.parameters), this.material = new SymbolMaterial({
      useText: e,
      useIcon: r,
      ...f
    });
    const p = this.engine.map.isGlobe;
    this.material.isGlobe = p, this.material.enableFade = this._enableFade, this.material.setCommonUniforms(this.engine.rendering.uniforms), this.material.spriteTexture = this.spriteTexture, this.textBoxCalculator = new TextBoxCalculator(this.ctx, {
      engine: this.engine,
      defaultFontSize: this._textSize,
      defaultFontFamily: this._textFamily,
      defaultTextStrokeWidth: this._textStrokeWidth,
      padding: this._padding,
      textPadding: this._textPadding,
      textSize: this._textSize,
      textWeight: this._textWeight,
      textStrokeWidth: this._textStrokeWidth,
      textFamily: this._textFamily
    }), this.bufferBuilder = new GeometryBufferBuilder(3e4);
  }
  collisionTest(e) {
    const r = e.boundingBox, s = this.symbolType === SymbolType.TEXT && this.flat;
    return r && !s ? r : this.computeBoundingBox(e);
  }
  computeBoundingBox(e) {
    const r = this.symbolType, s = e.iconSize || [], a = defaultValue$1(s[0], this._iconWidth), c = defaultValue$1(s[1], this._iconHeight), l = e.tolerance || 0;
    if (r === SymbolType.ICON)
      return {
        width: a,
        height: c,
        tolerance: l
      };
    const h = defaultValue$1(e.textAnchor, this._textAnchor), d = h ? textAnchors.indexOf(h) + 1 : 0;
    if (r === SymbolType.TEXT) {
      const f = this.expandTextVariants(e), p = [], m = [];
      for (let y = 0; y < f.length; y++) {
        f[y];
        const x = this.textBoxCalculator.getTextBox(e, this.flat), { offsetX: v, offsetY: S } = this._getTextOrIconOffset(d, x.width, x.height);
        m.push({
          ...x,
          offsetX: v,
          offsetY: S,
          textBox: x,
          tolerance: l
        }), p.push(x);
      }
      return p.length > 1 ? (e.textBox = p, m) : (e.textBox = p[0], m[0]);
    }
    if (r === SymbolType.ICONTEXT) {
      const f = this.expandTextVariants(e), p = [], m = [];
      for (let y = 0; y < f.length; y++) {
        const x = f[y], v = this.textBoxCalculator.getTextBox(x, this.flat);
        if (y === 0) {
          const { offsetX: S, offsetY: E, width: b, height: w } = this._getTextIconOffset(v, d, a, c);
          p.push({
            width: b,
            height: w,
            offsetX: S,
            offsetY: E,
            textBox: v,
            tolerance: l
          });
        } else {
          const { offsetX: S, offsetY: E } = this._getTextOrIconOffset(d, v.width, v.height);
          p.push({
            width: v.width,
            height: v.height,
            offsetX: S,
            offsetY: E,
            textBox: v,
            tolerance: l
          });
        }
        m.push(v);
      }
      return m.length > 1 ? (e.textBox = m, p) : (e.textBox = m[0], p[0]);
    }
  }
  _getTextIconOffset(e, r, s, a) {
    const c = this._padding, l = e.width, h = e.height;
    let d = 0, f = 0, p = 0, m = 0;
    switch (r) {
      case 0:
        d = Math.max(l, s), f = Math.max(h, a);
        break;
      case 1:
        d = l + s + c[0], f = Math.max(h, s), p = (l + c[0]) / 2;
        break;
      case 2:
        d = l + s + c[0], f = Math.max(h, s), p = -(l + c[0]) / 2;
        break;
      case 3:
        d = Math.max(l, s), f = h + a + c[1], m = (h + c[1]) / 2;
        break;
      case 4:
        d = Math.max(l, s), f = h + a + c[1], m = -(h + c[1]) / 2;
        break;
      case 5:
        d = l + s + c[0], f = h + a + c[1], p = (l + c[0]) / 2, m = (h + c[1]) / 2;
        break;
      case 6:
        d = l + s + c[0], f = h + a + c[1], p = -(l + c[0]) / 2, m = (h + c[1]) / 2;
        break;
      case 7:
        d = l + s + c[0], f = h + a + c[1], p = (l + c[0]) / 2, m = -(h + c[1]) / 2;
        break;
      case 8:
        d = l + s + c[0], f = h + a + c[1], p = -(l + c[0]) / 2, m = -(h + c[1]) / 2;
        break;
    }
    return {
      width: d,
      height: f,
      offsetX: p,
      offsetY: m
    };
  }
  _getTextOrIconOffset(e, r, s) {
    let a = 0, c = 0;
    switch (e) {
      case 0:
        break;
      case 1:
        a = r / 2;
        break;
      case 2:
        a = -r / 2;
        break;
      case 3:
        c = s / 2;
        break;
      case 4:
        c = -s / 2;
        break;
      case 5:
        a = r / 2, c = s / 2;
        break;
      case 6:
        a = -r / 2, c = s / 2;
        break;
      case 7:
        a = r / 2, c = -s / 2;
        break;
      case 8:
        a = -r / 2, c = -s / 2;
        break;
    }
    return {
      offsetX: a,
      offsetY: c
    };
  }
  _updateData() {
    this._version++, this.bufferBuilder.clear(), this._labelQuadStarts.length = 0;
    let e = this.dataSource.userData;
    this._enableCollision && this._collisionData && (e = this._collisionData), this._enableFade && (this._fadeData.filterData = this.dataSource.userData, this._fadeData.update(
      e,
      this.engine.rendering.uniforms.elapsedTime.value,
      this._enableFadeFilter
    ), e = this._fadeData.data), this.packBuffer(e), this.needsUpdate = !1;
  }
  packBuffer(e) {
    if (!e)
      return;
    const r = this._version, s = this.symbolType, a = this.engine.map.isGlobe;
    e = e.filter((h) => {
      if (h.checkVisible && a) {
        const d = h.position;
        return tempPosition.fromArray(d), this.engine.map.map.occluder.isPointVisible(tempPosition);
      }
      return !0;
    });
    let c = 0;
    const l = this.engine.rendering.taskScheduler;
    s === SymbolType.ICON ? this.updateIconHash(e).then(() => {
      this._version === r && l.addTask(() => new Promise((h) => {
        this._version === r && (this.updateIconSprite(), c = this.packIconBuffer(e, c), this._commitBuffer(), h());
      }));
    }) : s === SymbolType.TEXT ? this.updateTextSprite(e).then(() => {
      this._version === r && l.addTask(() => new Promise((h) => {
        this._version === r && (this.updateTextSpriteTexture(), this.packTextBuffer(e, c), this._commitBuffer(), h());
      }));
    }) : s === SymbolType.ICONTEXT && this.updateTextSprite(e).then(() => {
      this._version === r && this.updateIconHash(e).then(() => {
        this._version === r && l.addTask(() => new Promise((h) => {
          this._version === r && (this.updateTextSpriteTexture(), this.updateIconSprite(), c = this.packIconAndTextBuffer(e, c), this._commitBuffer(), h());
        }));
      });
    });
  }
  _commitBuffer() {
    this.bufferBuilder.data.drawRange = this.bufferBuilder.drawRange, this.geometry.setData(this.bufferBuilder.data), this._enableFade && (this.material.fadeDuration = this._fadeData.fadeDuration), this.geometry.computeBoundingSphere();
    const e = this.bufferBuilder.offsets.positionsOffset;
    this.makeGeometryOffsetPosition(this.geometry, this.bufferBuilder._cachePositions, e), this.engine.requestRender(), this._cacheData.length = 0;
  }
  updateIconDataItem(e, r) {
    const s = this.vertexIcons, a = this.iconCanvas, c = this._textPadding, l = this._useIconScale;
    if (s) {
      const h = e.position, d = defaultValue$1(e.iconSize, []), f = defaultValue$1(d[0], this._iconWidth);
      let p = defaultValue$1(d[1], this._iconHeight);
      const m = e.offset || defaultOffset, y = e.textDrawOnIcon, x = e.icon, v = e.rotateZ, S = this.boxHash.get(x);
      if (!S)
        return r;
      l && (p = f * S.h / S.w), this.packPosition(h), this.packRotationMatrix(h), this.packRotateZ(v);
      const E = S.x / a.width, b = (S.x + S.w) / a.width, w = (S.y + S.h) / a.height, M = S.y / a.height;
      if (this.packIconUV([E, w, E, M, b, M, b, w]), y) {
        let P;
        e.boundingBox && e.boundingBox.textBox ? P = e.boundingBox.textBox : P = e.textBox || this.textBoxCalculator.getTextBox(e, this.flat);
        const D = Math.ceil(P.width), L = Math.ceil(P.height), O = 5, F = D + O * 2, k = Math.max(L, p) + c[1] * 2, V = Math.round(F), N = Math.round(k / 2);
        this.packWH(V, N, 0);
        const U = V / N / (f / p), $ = O / F * (b - E);
        this.packStretch(E, b, U, $);
      } else
        this.packWH(f, p, 0), this.packStretch(0, 0, 1, 0);
      this.packOffset(m[0], m[1]), this.packTypeAndPIndex(0), this.packIconStyle(), this.packFade(e), this.bufferBuilder.packQuadIndices(r);
    } else {
      const h = e.position, d = e.offset || defaultOffset;
      let f = e.iconUvs;
      const p = e.rotateZ, m = e.iconOpacity, y = e.iconSize || [], x = defaultValue$1(y[0], this._iconWidth), v = defaultValue$1(y[1], this._iconHeight);
      this.packPosition(h), this.packRotationMatrix(h), this.packRotateZ(p), this.packWH(x, v, 0), this.packStretch(0, 0, 1, 0), this.packOffset(d[0], d[1]), f || (f = defaultUv), this.packIconUV(f), this.packIconStyle(m), this.packTypeAndPIndex(0), this.packFade(e), this.bufferBuilder.packQuadIndices(r);
    }
    return r++, r;
  }
  isSplitArray(e, r) {
    const s = ["text", "textSize", "textWeight", "textAnchor", "textStrokeWidth"];
    if (!Array.isArray(r))
      return !1;
    if (s.includes(e))
      return !0;
    const a = r.every((c) => typeof c == "number");
    return ["textFillStyle", "textStrokeStyle", "textOffset"].includes(e) && a ? !1 : r.length > 1;
  }
  expandTextVariants(e) {
    var l;
    const r = [
      "text",
      "textFillStyle",
      "textStrokeStyle",
      "textStrokeWidth",
      "textOffset",
      "textSize",
      "textWeight",
      "textAnchor",
      "textBox"
    ], s = Array.isArray(e.text) ? e.text : null;
    if (!s)
      return [e];
    const a = s.length, c = [];
    for (let h = 0; h < a; h++) {
      const d = { ...e };
      for (const f of r) {
        const p = e[f];
        this.isSplitArray(f, p) && (d[f] = (l = p[h]) != null ? l : p[p.length - 1]);
      }
      c.push(d);
    }
    return c;
  }
  packIconAndTextBuffer(e, r = 0) {
    const [s, a] = this.material.resolution || [];
    if (isNaN(s) || s <= 0 || isNaN(a) || a <= 0) {
      console.warn("resolution is invalid");
      return;
    }
    for (let c = 0; c < e.length; c++) {
      const l = e[c];
      this._labelQuadStarts.push(r), r = this.updateIconDataItem(l, r);
      const h = this.expandTextVariants(l);
      for (let d = 0; d < h.length; d++)
        r = this.updateTextDataItem(h[d], r);
    }
    return r;
  }
  packIconBuffer(e, r = 0) {
    const [s, a] = this.material.resolution || [];
    if (isNaN(s) || s <= 0 || isNaN(a) || a <= 0) {
      console.warn("resolution is invalid");
      return;
    }
    for (let c = 0; c < e.length; c++)
      this._labelQuadStarts.push(r), r = this.updateIconDataItem(e[c], r);
    return r;
  }
  async updateIconHash(e) {
    if (this.vertexIcons) {
      const r = this.getTextureAndHash(e, "icon", 0, 0, !0);
      Array.isArray(r) && await Promise.all(r);
    }
  }
  async updateTextSprite(e) {
    const r = e;
    let s = /* @__PURE__ */ new Map(), a = !1, c = {};
    this.fontAtalasManager && this.fontAtalasManager.mapping && (c = this.fontAtalasManager.mapping);
    for (let l = 0; l < r.length; l++) {
      const h = r[l];
      let d = h.text, f;
      Array.isArray(d) ? f = d.map((x) => String(x)) : f = [String(d)];
      const p = f.length, m = defaultValue$1(h.textWeight, this._textWeight), y = defaultValue$1(h.textFamily, this._textFamily);
      for (let x = 0; x < p; x++) {
        const v = f[x];
        let S = m;
        Array.isArray(m) && (S = m[x]);
        const E = Array.from(v);
        for (let b = 0, w = E.length; b < w; b++) {
          const M = E[b], P = M + S + y;
          s.set(P, {
            char: M,
            fontWeight: S
          }), c[P] || (a = !0);
        }
      }
    }
    a && await this.updateTextTexture(s.values());
  }
  getTextureAndHash(e, r, s, a, c) {
    const l = this.iconUrlHash;
    if (!c && this.oldMapTextureRes)
      return this.oldMapTextureRes;
    const d = e.map((p) => p[r]).filter((p) => {
      const m = !defined$2(l.get(p));
      return m && l.set(p, String(l.length)), m;
    });
    return d.length === 0 ? this.oldMapTextureRes : d.map((p) => new Promise((m) => {
      url2canvas(p, (y) => {
        l.set(p, y), m(p);
      });
    }));
  }
  updateIconSprite() {
    if (!this.iconCanvas)
      return this.oldMapTextureRes;
    const e = this.iconCtx, r = this.iconUrlHash, s = r.cache;
    for (let c in s)
      if (s.hasOwnProperty(c)) {
        const l = s[c].value;
        if (!defined$2(l) || typeof l == "string" || typeof l == "number")
          continue;
        const h = this.boxes.findIndex((y) => y.key === c);
        if (h >= 0) {
          const [y] = this.boxes.splice(h, 1);
          this.boxes.unshift(y);
          continue;
        }
        const d = l.width, f = l.height, p = d + this.gap[0], m = f + this.gap[1];
        this.boxes.unshift({ w: p, h: m, width: d, height: f, key: c, icon: l });
      }
    let a = !1;
    return this.boxes.forEach((c) => {
      const l = c.key;
      this.boxHash.has(l) || (a = !0, this.boxHash.set(c.key, c));
    }), a && (createSprite(
      this.boxes,
      e,
      this.iconCanvas,
      {
        gap: this.gap,
        padding: [2, 2],
        dpr: this.engine.rendering.pixelRatio
      }
    ) && this.spriteTexture.dispose(), this.spriteTexture.needsUpdate = !0, this.material.spriteTexture = this.spriteTexture, this.material.isIconMap = !0), this.oldMapTextureRes = {
      texture: this.spriteTexture,
      iconUrlHash: r
    }, this.oldMapTextureRes;
  }
  getEntityByIndex(e) {
    const r = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const s = {
      index: e,
      value: r.getDataItem(e),
      itemIndex: r.getDataItemIndex(e),
      pairs: {}
    }, a = r.data;
    for (const c of Object.keys(a))
      s.pairs[c] = a[c][e];
    return s;
  }
  async updateTextTexture(e) {
    const r = Array.from(e);
    this._fontSettings = {
      fontFamily: this._textFamily,
      fontWeight: "400",
      characterSet: r,
      sdf: !0,
      ...fontSettings$1
    }, this.fontAtalasManager.setProps(this._fontSettings);
  }
  updateTextSpriteTexture() {
    const e = this.fontAtalasManager.atlas;
    if (!e)
      return;
    const { textureData: r, width: s, height: a } = e;
    !this.textTexture || this.textTexture.image.width !== s || this.textTexture.image.height !== a ? (this.textTexture && this.textTexture.dispose(), this.textTexture = new DataTexture(r, s, a), this.textTexture.minFilter = this.textTexture.magFilter = LinearFilter, this.textTexture.format = RedFormat, this.textTexture.needsUpdate = !0, this.material.textTexture = this.textTexture) : (this.textTexture.image.data.set(r), this.textTexture.needsUpdate = !0);
  }
  packTextBuffer(e, r = 0) {
    const [s, a] = this.material.resolution || [];
    if (isNaN(s) || s <= 0 || isNaN(a) || a <= 0) {
      console.warn("resolution is invalid");
      return;
    }
    for (let c = 0; c < e.length; c++) {
      this._labelQuadStarts.push(r);
      const l = this.expandTextVariants(e[c]);
      for (let h = 0; h < l.length; h++)
        r = this.updateTextDataItem(l[h], r);
    }
    return r;
  }
  updateTextDataItem(e, r) {
    const a = "break-word", { mapping: c } = this.fontAtalasManager.atlas || {}, l = e.position;
    let h;
    e.boundingBox && e.boundingBox.textBox ? h = e.boundingBox.textBox : h = e.textBox || this.textBoxCalculator.getTextBox(e, this.flat);
    const d = h.wrappedText, f = h.widthList, p = Math.max(...f);
    e.textSize = defaultValue$1(e.textSize, this._textSize), e.textWeight = defaultValue$1(e.textWeight, this._textWeight), e.textFillStyle ? e.textFillStyle = Array.isArray(e.textFillStyle) ? e.textFillStyle : colorToRgbaArr(e.textFillStyle) : e.textFillStyle = this._textFillStyle, e.textStrokeStyle ? e.textStrokeStyle = Array.isArray(e.textStrokeStyle) ? e.textStrokeStyle : colorToRgbaArr(e.textStrokeStyle) : e.textStrokeStyle = this._textStrokeStyle, e.textStrokeWidth = defaultValue$1(e.textStrokeWidth, this._textStrokeWidth), e.textOffset = defaultValue$1(e.textOffset, this._textOffset), e.textDrawOnIcon = defaultValue$1(e.textDrawOnIcon, !1), e.textFamily = defaultValue$1(e.textFamily, this._textFamily), e.icon = defaultValue$1(e.icon, this.mapSrc), e.iconSize = defaultValue$1(e.iconSize, [this._iconWidth, this._iconHeight]), e.rotateZ = defaultValue$1(e.rotateZ, this._rotateZ);
    const m = e.textWeight, y = e.textSize, x = e.rotateZ, v = e.textFamily, S = y / this._fontSettings.fontSize, E = Array.from(d).map((L) => L + m + v), b = this._textPadding.map((L) => L / S), w = transformParagraph(d, E, 1, a, p * y, c, 0, b), M = w.x.length, P = Array.from(d);
    let D = 0;
    for (let L = 0; L < M; L++) {
      const O = P[L];
      if (O === "\\")
        continue;
      const F = c[O + m + v];
      if (!F)
        return;
      this.packPosition(l), this.packTextOffset(e, w, L), this.packTextUV(F), this.packTextWh(e, F), this.packStretch(0, 0, 1, 0), this.packTextStyle(e), this.packTypeAndPIndex(1), this.packRotateZ(x), this.packRotationMatrix(l), this.packFade(e), this.bufferBuilder.packQuadIndices(r + D), D++;
    }
    return r += D, r;
  }
  packRotateZ(e) {
    e = e || 0, this.bufferBuilder.packRotateZ(e);
  }
  packRotationMatrix(e) {
    this.engine.map.isGlobe && (this._calculateTransform(e, currentInstanceMatrix), tempRotationMatrix.setFromMatrix4(currentInstanceMatrix), this.bufferBuilder.packRotationMatrix(tempRotationMatrix));
  }
  packPosition(e) {
    this.bufferBuilder.packPosition(e[0], e[1], e[2]);
  }
  packFade(e) {
    if (this._enableFade) {
      const { fadeOpacity: r, fadeSince: s } = e;
      this.bufferBuilder.packFade(r, s);
    }
  }
  packOffset(e, r) {
    this.bufferBuilder.packOffset(e, r);
  }
  packWH(e, r, s) {
    this.bufferBuilder.packWH(e, r, s);
  }
  packStretch(e, r, s, a) {
    this.bufferBuilder.packStretch(e, r, s, a);
  }
  packTypeAndPIndex(e) {
    this.bufferBuilder.packTypeAndPIndex(e);
  }
  packIconStyle(e = 1) {
    this.bufferBuilder.packStyle([1, 1, 1, e], [0, 0, 0, 0], 0);
  }
  packIconUV(e) {
    this.bufferBuilder.packUV(e);
  }
  packTextStyle(e) {
    var c, l;
    let {
      textStrokeStyle: r,
      textStrokeWidth: s,
      textFillStyle: a
    } = e;
    this.bufferBuilder.packStyle(
      [a[0] / 255, a[1] / 255, a[2] / 255, (c = a[3]) != null ? c : 1],
      [r[0] / 255, r[1] / 255, r[2] / 255, (l = r[3]) != null ? l : 1],
      s
    );
  }
  packTextWh(e, r) {
    const {
      textSize: s
    } = e;
    let { width: a, height: c } = r;
    a += this._fontSettings.buffer * 2;
    const l = s / this._fontSettings.fontSize;
    this.bufferBuilder.packWH(a * l, c * l, s);
  }
  packTextUV(e) {
    const {
      width: r,
      height: s
    } = this.fontAtalasManager.atlas || {};
    let { x: a, y: c, width: l, height: h } = e;
    l += this._fontSettings.buffer * 2;
    const d = a / r, f = c / s, p = d + l / r, m = f + h / s;
    this.bufferBuilder.packUV([d, m, d, f, p, f, p, m]);
  }
  packTextOffset(e, r, s) {
    const {
      x: a,
      y: c,
      rowWidth: l,
      rowNum: h,
      size: [d, f]
    } = r, p = this._useIconScale, {
      textSize: m,
      textOffset: y,
      textAnchor: x = this._textAnchor,
      iconSize: v = [],
      icon: S
    } = e, E = defaultValue$1(v[0], this._iconWidth);
    let b = defaultValue$1(v[1], this._iconHeight);
    const w = this.boxHash.get(S);
    p && w && (b = E * w.h / w.w);
    const M = this._padding, D = (1 - TEXT_ALIGN$1[this.textAlign]) * (d - l[s]) / 2;
    let L = (0 - 1) * d / 2 + D + a[s] + y[0], O = f / h * (h - 1) / 2 - c[s] + y[1], F = 0, k = 0;
    const V = defined$2(x) ? textAnchors.indexOf(x) + 1 : 0, N = d - l[s];
    switch (V) {
      case 1:
        L += d / 2 - N / 2, F += E / 2 + M[0];
        break;
      case 2:
        L -= d / 2 - N / 2, F -= E / 2 + M[0];
        break;
      case 3:
        O -= f / 2, k -= b / 2 + M[1];
        break;
      case 4:
        O += f / 2, k += b / 2 + M[1];
        break;
      case 5:
        L += d / 2, F += E / 2 + M[0], O -= f / 2, k -= b / 2 + M[1];
        break;
      case 6:
        L -= d / 2, F -= E / 2 + M[0], O -= f / 2, k -= b / 2 + M[1];
        break;
      case 7:
        L += d / 2, F += E / 2 + M[0], O += d / 2, F += E / 2 + M[0];
        break;
      case 8:
        L -= d / 2, F -= E / 2 + M[0], O += d / 2, F += E / 2 + M[0];
        break;
    }
    const U = m / this._fontSettings.fontSize, z = e.offset || defaultOffset, $ = L * U + F + z[0], G = O * U + k + z[1];
    this.bufferBuilder.packOffset($, G);
  }
  _calculateTransform(e, r) {
    return this.engine.map.isGlobe ? (r || (r = new Matrix4()), Transforms.eastNorthUpToFixedFrame(tempPosition.fromArray(e), null, r), r) : defaultValue$1.EMPTY_MAT4;
  }
  onBeforeScenePrepareRenderHook(e, r, s) {
    const a = e.rendering.main.sceneRendering.depthTexture;
    this.material.uniforms.depthTexture.value = a, this.material.uniforms.cameraFar.value = e.rendering.camera.far;
  }
  onBeforeSceneRender(e, r, s, a) {
    super.onBeforeSceneRender(e, r, s, a), this._enableFade && !this._fadeData.isStable(a.elapsedTime) && e.requestRender();
  }
  onDispose() {
    this.spriteTexture && this.spriteTexture.dispose(), this.textTexture && this.textTexture.dispose();
  }
  getPixelSize(e) {
    const { camera: r, rendering: s } = this.engine;
    return r.isOrthographicCamera ? this.material.uniforms.zoomUnits.value : 0.2 * r.projectionMatrix.elements[5] / s.resolution.y * r.position.distanceTo(e);
  }
  _findLabelIndexByQuad(e) {
    if (!this._labelQuadStarts || this._labelQuadStarts.length === 0)
      return e;
    let r = 0, s = this._labelQuadStarts.length - 1;
    for (; r < s; ) {
      const a = Math.ceil((r + s) / 2);
      this._labelQuadStarts[a] <= e ? r = a : s = a - 1;
    }
    return r;
  }
  getVertexPosition(e, r) {
    const s = this.geometry, a = s.attributes.position, c = s.morphAttributes.position, l = s.attributes.whAndSize, h = s.attributes.offset, d = s.morphTargetsRelative;
    r.fromBufferAttribute(a, e), _tempVector2$4.fromBufferAttribute(l, e), _tempOffset$1.fromBufferAttribute(h, e);
    const f = this.engine.map.isGlobe;
    if (f) {
      const M = s.attributes.instanceRotationMatrix.array, P = e * 9;
      _xAxis.set(M[P], M[P + 1], M[P + 2]), _yAxis.set(M[P + 3], M[P + 4], M[P + 5]);
    }
    const p = e % 4;
    let m = _tempVector2$4.x / 2, y = _tempVector2$4.y / 2, x = _tempOffset$1.x, v = _tempOffset$1.y;
    if (this.keepSize) {
      const w = this.position, M = this.getPixelSize(_tempVector3$8.addVectors(w, r));
      m *= M, y *= M, x *= M, v *= M;
    }
    p === 1 ? m = -m : p === 2 || (p === 3 ? y = -y : (y = -y, m = -m));
    const S = m + x, E = y + v;
    f ? (_tempVector3$8.set(0, 0, 0), _tempVector3$8.addScaledVector(_xAxis, S), _tempVector3$8.addScaledVector(_yAxis, E), r.add(_tempVector3$8)) : (r.x += S, r.y += E);
    const b = this.morphTargetInfluences;
    if (c && b) {
      _morphA$1.set(0, 0, 0);
      for (let w = 0, M = c.length; w < M; w++) {
        const P = b[w], D = c[w];
        P !== 0 && (_tempA$1.fromBufferAttribute(D, e), d ? _morphA$1.addScaledVector(_tempA$1, P) : _morphA$1.addScaledVector(_tempA$1.sub(r), P));
      }
      r.add(_morphA$1);
    }
    return r;
  }
  raycast(e, r) {
    if (!this.visible)
      return;
    if (this.flat) {
      this.geometry.boundingSphere === null && this.geometry.computeBoundingSphere();
      let O = Math.max(this._iconWidth, this._iconHeight) * 10;
      this.keepSize && (O *= this.material.uniforms.zoomUnits.value), this.geometry.boundingSphere.radius += O, Mesh.prototype.raycast.call(this, e, r), this.geometry.boundingSphere.radius -= O;
      return;
    }
    const a = this.geometry, c = this.position, l = a.getAttribute("position");
    if (!l || !l.array || !l.array.length)
      return;
    let h = e.camera;
    h || (h = this.engine.camera);
    const d = e.mouse;
    if (!d)
      return;
    const f = d.x, p = d.y, m = this.material.uniforms.resolution.value;
    _tempMatrix4$5.multiplyMatrices(h.projectionMatrix, h.matrixWorldInverse), _tempMatrix4$5.multiplyMatrices(_tempMatrix4$5, this.matrixWorld);
    const y = l.array;
    let x = 0, v = 0, S = 0, E = 0, b = 0, w = 0;
    const M = this.bufferBuilder.offsets.positionsOffset, P = a.getAttribute("whAndSize"), D = a.getAttribute("offset");
    let L = 0;
    for (let O = 0, F = M - 11; O < F; O += 12) {
      _tempVector4$3.set(y[O], y[O + 1], y[O + 2], 1), _tempVector4$3.applyMatrix4(_tempMatrix4$5), _tempVector4$3.divideScalar(_tempVector4$3.w);
      const k = P.getX(L), V = P.getY(L);
      let N = D.getX(L) * 2 / m.x, U = D.getY(L) * 2 / m.y;
      if (b = k / m.x, w = V / m.y, !this.keepSize) {
        const z = this.getPixelSize(
          _tempVector3$8.set(
            y[O] + c.x,
            y[O + 1] + c.y,
            y[O + 2] + c.z
          )
        );
        N /= z, U /= z, b /= z, w /= z;
      }
      if (_tempVector4$3.x += N, _tempVector4$3.y += U, x = _tempVector4$3.x - b, S = _tempVector4$3.x + b, v = _tempVector4$3.y - w, E = _tempVector4$3.y + w, x <= f && S >= f && v <= p && E >= p) {
        _tempVector3$8.set(y[O], y[O + 1], y[O + 2]), _tempVector3$8.applyMatrix4(this.matrixWorld);
        const $ = {
          instanceId: this._findLabelIndexByQuad(O / 12),
          object: this,
          distance: _tempVector3$8.distanceTo(h.position),
          point: _tempVector3$8.clone()
        };
        r.push($);
      }
      L += 4;
    }
  }
  get enableFade() {
    return this._enableFade;
  }
  set enableFade(e) {
    this._enableFade = e, this.material.enableFade = e;
  }
}
Label.prototype._computeIntersections = Mesh.prototype._computeIntersections;
class ScreenTextGeometry extends BufferGeometry {
  constructor(i) {
    super(), this.parameters = i || {};
  }
  setData(i, e) {
    const r = [], s = [], a = [], c = [], l = [], h = [], d = [], f = [], p = [];
    let m = 0;
    for (const v of i) {
      const {
        x: S,
        y: E,
        char: b,
        rotation: w = 0,
        size: M = 26,
        fillColor: P = [1, 1, 1, 1],
        strokeColor: D = [0, 0, 0, 1],
        strokeWidth: L = 0
      } = v, O = e[b];
      if (!O)
        continue;
      m++;
      const F = 24, V = F + 3 * 2, N = M / F, U = V * N / 2, z = [
        [-U, -U],
        [U, -U],
        [-U, U],
        [U, U]
      ];
      for (const [$, G] of z)
        r.push(0, 0, 0), s.push(S, E), a.push($, G), c.push(w), h.push(M), d.push(...P), f.push(...D), p.push(L);
      l.push(
        O.startU,
        O.endV,
        O.endU,
        O.endV,
        O.startU,
        O.startV,
        O.endU,
        O.startV
      );
    }
    const y = [], x = m;
    for (let v = 0; v < x; v++) {
      const S = v * 4;
      y.push(S, S + 2, S + 1), y.push(S + 1, S + 2, S + 3);
    }
    this.setAttribute("position", new Float32BufferAttribute(new Float32Array(r), 3)), this.setAttribute("aScreenPosition", new Float32BufferAttribute(new Float32Array(s), 2)), this.setAttribute("aOffset", new Float32BufferAttribute(new Float32Array(a), 2)), this.setAttribute("aRotation", new Float32BufferAttribute(new Float32Array(c), 1)), this.setAttribute("aAtlasUV", new Float32BufferAttribute(new Float32Array(l), 2)), this.setAttribute("aSize", new Float32BufferAttribute(new Float32Array(h), 1)), this.setAttribute("aFillColor", new Float32BufferAttribute(new Float32Array(d), 4)), this.setAttribute("aStrokeColor", new Float32BufferAttribute(new Float32Array(f), 4)), this.setAttribute("aStrokeWidth", new Float32BufferAttribute(new Float32Array(p), 1)), this.setIndex(y);
  }
}
const vertexShader$s = `#define GLSLIFY 1
// \u5C4F\u5E55\u5750\u6807\uFF08\u50CF\u7D20\uFF09
attribute vec2 aScreenPosition;
// \u5C40\u90E8\u504F\u79FB\uFF08\u76F8\u5BF9\u5B57\u7B26\u4E2D\u5FC3\uFF09
attribute vec2 aOffset;
// \u65CB\u8F6C\u89D2\u5EA6
attribute float aRotation;
// \u56FE\u96C6UV
attribute vec2 aAtlasUV;
// \u5B57\u7B26\u5927\u5C0F
attribute float aSize;
// \u6837\u5F0F\u5C5E\u6027
attribute vec4 aFillColor;
attribute vec4 aStrokeColor;
attribute float aStrokeWidth;

varying vec2 vUv;
varying float vSize;
varying vec4 vFillColor;
varying vec4 vStrokeColor;
varying float vStrokeWidth;

uniform vec2 resolution;
uniform float pixelRatio;

void main() {
    // \u5E94\u7528\u65CB\u8F6C\u5230\u5C40\u90E8\u504F\u79FB
    float s = sin(aRotation);
    float c = cos(aRotation);
    vec2 rotatedOffset = vec2(
        c * aOffset.x - s * aOffset.y,
        s * aOffset.x + c * aOffset.y
    );
    
    // \u8BA1\u7B97\u6700\u7EC8\u5C4F\u5E55\u5750\u6807
    vec2 screenPos = aScreenPosition + rotatedOffset;
    
    // \u5C4F\u5E55\u5750\u6807 \u2192 NDC\u5750\u6807
    vec2 ndc;
    ndc.x = (screenPos.x / resolution.x) * 2.0 - 1.0;
    ndc.y = 1.0 - (screenPos.y / resolution.y) * 2.0;
    
    // \u8F93\u51FA\u4F4D\u7F6E\uFF08z=0 \u5728\u6700\u524D\u9762\uFF09
    gl_Position = vec4(ndc, 0.0, 1.0);
    
    // \u4F20\u9012UV\u3001\u5927\u5C0F\u548C\u6837\u5F0F
    vUv = aAtlasUV;
    vSize = aSize;
    vFillColor = aFillColor;
    vStrokeColor = aStrokeColor;
    vStrokeWidth = aStrokeWidth;
}

`, fragmentShader$q = `#define GLSLIFY 1
varying vec2 vUv;
varying float vSize;
varying vec4 vFillColor;
varying vec4 vStrokeColor;
varying float vStrokeWidth;

uniform sampler2D textMap;
uniform float opacity;
uniform float pixelRatio;

#include <tonemapping_pars_fragment>
#include <output_pars_fragment>

void main() {
    // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    // \u4ECE SDF \u7EB9\u7406\u91C7\u6837
    float distance = texture2D(textMap, vUv).r;
    
    // SDF \u6E32\u67D3\u53C2\u6570\uFF08\u4E0E Symbol \u6750\u8D28\u76F8\u540C\uFF09
    float fontScale = vSize / 24.0;
    float gamma = (0.105 / pixelRatio) / fontScale;
    float buff = (256.0 - 64.0) / 256.0;
    
    // \u8BA1\u7B97\u6587\u5B57\u7684 alpha
    float alpha = smoothstep(buff - gamma, buff + gamma, distance);
    
    // \u4F7F\u7528per-instance\u7684\u586B\u5145\u989C\u8272
    vec3 fontColor = vFillColor.xyz;
    float fillAlpha = vFillColor.w;
    
    // \u5982\u679C\u6709\u63CF\u8FB9\uFF0C\u6DF7\u5408\u63CF\u8FB9\u548C\u586B\u5145
    if (vStrokeWidth > 0.0) {
        float inFill = alpha;
        float outlineBuffer = (6.0 - vStrokeWidth / fontScale) / 8.0;
        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);
        
        float ratio = smoothstep(0.0, 1.0, inFill);
        fontColor = mix(vStrokeColor.xyz, fontColor, ratio);
        fillAlpha = mix(vStrokeColor.w, fillAlpha, ratio);
        alpha = inBorder;
    }
    
    // \u8F93\u51FA\u6700\u7EC8\u989C\u8272
    gl_FragColor = vec4(fontColor, alpha * fillAlpha);
    
    // Alpha \u6D4B\u8BD5
    if (gl_FragColor.a <= 0.01) {
        discard;
    }
    
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <output_fragment>
}

`;
class ScreenTextMaterial extends ShaderMaterial {
  constructor(i = {}) {
    super(), this.vertexShader = vertexShader$s, this.fragmentShader = fragmentShader$q, this.name = "ScreenTextMaterial";
    const e = i.color || "#ffffff", r = i.strokeColor || "#000000", s = this._hexToRgba(e), a = this._hexToRgba(r);
    this.uniforms = UniformsUtils.clone({
      textMap: { value: null },
      opacity: { value: i.opacity || 1 },
      resolution: { value: new Vector2$1(800, 600) },
      pixelRatio: { value: 1 },
      fillColor: { value: new Vector4(...s) },
      strokeColor: { value: new Vector4(...a) },
      strokeWidth: { value: i.strokeWidth || 0 },
      fontSize: { value: i.fontSize || 24 }
    }), this.transparent = !0, this.depthTest = !1, this.depthWrite = !1, this._defineProxyProperties([
      "opacity",
      "strokeWidth",
      "fontSize"
    ]), this._defineColorProperties(), i && this.setValues(i);
  }
  _hexToRgba(i, e = 1) {
    i = i.replace("#", ""), i.length === 3 && (i = i.split("").map((c) => c + c).join(""));
    const r = parseInt(i.substring(0, 2), 16) / 255, s = parseInt(i.substring(2, 4), 16) / 255, a = parseInt(i.substring(4, 6), 16) / 255;
    return [r, s, a, e];
  }
  _rgbaToHex(i) {
    const e = Math.round(i[0] * 255), r = Math.round(i[1] * 255), s = Math.round(i[2] * 255);
    return "#" + [e, r, s].map((a) => a.toString(16).padStart(2, "0")).join("");
  }
  _defineProxyProperties(i) {
    i.forEach((e) => {
      Object.defineProperty(this, e, {
        get: function() {
          return this.uniforms[e].value;
        },
        set: function(r) {
          this.uniforms[e].value = r;
        }
      });
    });
  }
  _defineColorProperties() {
    Object.defineProperty(this, "color", {
      get: function() {
        const i = [
          this.uniforms.fillColor.value.x,
          this.uniforms.fillColor.value.y,
          this.uniforms.fillColor.value.z,
          this.uniforms.fillColor.value.w
        ];
        return this._rgbaToHex(i);
      },
      set: function(i) {
        const e = this._hexToRgba(i);
        this.uniforms.fillColor.value.set(...e);
      }
    });
  }
}
function clamp(o, i, e) {
  return Math.max(i, Math.min(e, o));
}
class Vector2 {
  constructor(i = 0, e = 0) {
    Vector2.prototype.isVector2 = !0, this.x = i, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(i) {
    this.x = i;
  }
  get height() {
    return this.y;
  }
  set height(i) {
    this.y = i;
  }
  set(i, e) {
    return this.x = i, this.y = e, this;
  }
  setScalar(i) {
    return this.x = i, this.y = i, this;
  }
  setX(i) {
    return this.x = i, this;
  }
  setY(i) {
    return this.y = i, this;
  }
  setComponent(i, e) {
    switch (i) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + i);
    }
    return this;
  }
  getComponent(i) {
    switch (i) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + i);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(i) {
    return this.x = i.x, this.y = i.y, this;
  }
  add(i) {
    return this.x += i.x, this.y += i.y, this;
  }
  addScalar(i) {
    return this.x += i, this.y += i, this;
  }
  addVectors(i, e) {
    return this.x = i.x + e.x, this.y = i.y + e.y, this;
  }
  addScaledVector(i, e) {
    return this.x += i.x * e, this.y += i.y * e, this;
  }
  sub(i) {
    return this.x -= i.x, this.y -= i.y, this;
  }
  subScalar(i) {
    return this.x -= i, this.y -= i, this;
  }
  subVectors(i, e) {
    return this.x = i.x - e.x, this.y = i.y - e.y, this;
  }
  multiply(i) {
    return this.x *= i.x, this.y *= i.y, this;
  }
  multiplyScalar(i) {
    return this.x *= i, this.y *= i, this;
  }
  divide(i) {
    return this.x /= i.x, this.y /= i.y, this;
  }
  divideScalar(i) {
    return this.multiplyScalar(1 / i);
  }
  applyMatrix3(i) {
    const e = this.x, r = this.y, s = i.elements;
    return this.x = s[0] * e + s[3] * r + s[6], this.y = s[1] * e + s[4] * r + s[7], this;
  }
  min(i) {
    return this.x = Math.min(this.x, i.x), this.y = Math.min(this.y, i.y), this;
  }
  max(i) {
    return this.x = Math.max(this.x, i.x), this.y = Math.max(this.y, i.y), this;
  }
  clamp(i, e) {
    return this.x = clamp(this.x, i.x, e.x), this.y = clamp(this.y, i.y, e.y), this;
  }
  clampScalar(i, e) {
    return this.x = clamp(this.x, i, e), this.y = clamp(this.y, i, e), this;
  }
  clampLength(i, e) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(clamp(r, i, e));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(i) {
    return this.x * i.x + this.y * i.y;
  }
  cross(i) {
    return this.x * i.y - this.y * i.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(i) {
    const e = Math.sqrt(this.lengthSq() * i.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const r = this.dot(i) / e;
    return Math.acos(clamp(r, -1, 1));
  }
  distanceTo(i) {
    return Math.sqrt(this.distanceToSquared(i));
  }
  distanceToSquared(i) {
    const e = this.x - i.x, r = this.y - i.y;
    return e * e + r * r;
  }
  manhattanDistanceTo(i) {
    return Math.abs(this.x - i.x) + Math.abs(this.y - i.y);
  }
  setLength(i) {
    return this.normalize().multiplyScalar(i);
  }
  lerp(i, e) {
    return this.x += (i.x - this.x) * e, this.y += (i.y - this.y) * e, this;
  }
  lerpVectors(i, e, r) {
    return this.x = i.x + (e.x - i.x) * r, this.y = i.y + (e.y - i.y) * r, this;
  }
  equals(i) {
    return i.x === this.x && i.y === this.y;
  }
  fromArray(i, e = 0) {
    return this.x = i[e], this.y = i[e + 1], this;
  }
  toArray(i = [], e = 0) {
    return i[e] = this.x, i[e + 1] = this.y, i;
  }
  fromBufferAttribute(i, e) {
    return this.x = i.getX(e), this.y = i.getY(e), this;
  }
  rotateAround(i, e) {
    const r = Math.cos(e), s = Math.sin(e), a = this.x - i.x, c = this.y - i.y;
    return this.x = a * r - c * s + i.x, this.y = a * s + c * r + i.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Quaternion {
  constructor(i = 0, e = 0, r = 0, s = 1) {
    this.isQuaternion = !0, this._x = i, this._y = e, this._z = r, this._w = s;
  }
  static slerpFlat(i, e, r, s, a, c, l) {
    let h = r[s + 0], d = r[s + 1], f = r[s + 2], p = r[s + 3];
    const m = a[c + 0], y = a[c + 1], x = a[c + 2], v = a[c + 3];
    if (l === 0) {
      i[e + 0] = h, i[e + 1] = d, i[e + 2] = f, i[e + 3] = p;
      return;
    }
    if (l === 1) {
      i[e + 0] = m, i[e + 1] = y, i[e + 2] = x, i[e + 3] = v;
      return;
    }
    if (p !== v || h !== m || d !== y || f !== x) {
      let S = 1 - l;
      const E = h * m + d * y + f * x + p * v, b = E >= 0 ? 1 : -1, w = 1 - E * E;
      if (w > Number.EPSILON) {
        const P = Math.sqrt(w), D = Math.atan2(P, E * b);
        S = Math.sin(S * D) / P, l = Math.sin(l * D) / P;
      }
      const M = l * b;
      if (h = h * S + m * M, d = d * S + y * M, f = f * S + x * M, p = p * S + v * M, S === 1 - l) {
        const P = 1 / Math.sqrt(h * h + d * d + f * f + p * p);
        h *= P, d *= P, f *= P, p *= P;
      }
    }
    i[e] = h, i[e + 1] = d, i[e + 2] = f, i[e + 3] = p;
  }
  static multiplyQuaternionsFlat(i, e, r, s, a, c) {
    const l = r[s], h = r[s + 1], d = r[s + 2], f = r[s + 3], p = a[c], m = a[c + 1], y = a[c + 2], x = a[c + 3];
    return i[e] = l * x + f * p + h * y - d * m, i[e + 1] = h * x + f * m + d * p - l * y, i[e + 2] = d * x + f * y + l * m - h * p, i[e + 3] = f * x - l * p - h * m - d * y, i;
  }
  get x() {
    return this._x;
  }
  set x(i) {
    this._x = i, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(i) {
    this._y = i, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(i) {
    this._z = i, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(i) {
    this._w = i, this._onChangeCallback();
  }
  set(i, e, r, s) {
    return this._x = i, this._y = e, this._z = r, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(i) {
    return this._x = i.x, this._y = i.y, this._z = i.z, this._w = i.w, this._onChangeCallback(), this;
  }
  setFromEuler(i, e = !0) {
    const r = i._x, s = i._y, a = i._z, c = i._order, l = Math.cos, h = Math.sin, d = l(r / 2), f = l(s / 2), p = l(a / 2), m = h(r / 2), y = h(s / 2), x = h(a / 2);
    switch (c) {
      case "XYZ":
        this._x = m * f * p + d * y * x, this._y = d * y * p - m * f * x, this._z = d * f * x + m * y * p, this._w = d * f * p - m * y * x;
        break;
      case "YXZ":
        this._x = m * f * p + d * y * x, this._y = d * y * p - m * f * x, this._z = d * f * x - m * y * p, this._w = d * f * p + m * y * x;
        break;
      case "ZXY":
        this._x = m * f * p - d * y * x, this._y = d * y * p + m * f * x, this._z = d * f * x + m * y * p, this._w = d * f * p - m * y * x;
        break;
      case "ZYX":
        this._x = m * f * p - d * y * x, this._y = d * y * p + m * f * x, this._z = d * f * x - m * y * p, this._w = d * f * p + m * y * x;
        break;
      case "YZX":
        this._x = m * f * p + d * y * x, this._y = d * y * p + m * f * x, this._z = d * f * x - m * y * p, this._w = d * f * p - m * y * x;
        break;
      case "XZY":
        this._x = m * f * p - d * y * x, this._y = d * y * p - m * f * x, this._z = d * f * x + m * y * p, this._w = d * f * p + m * y * x;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + c);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(i, e) {
    const r = e / 2, s = Math.sin(r);
    return this._x = i.x * s, this._y = i.y * s, this._z = i.z * s, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(i) {
    const e = i.elements, r = e[0], s = e[4], a = e[8], c = e[1], l = e[5], h = e[9], d = e[2], f = e[6], p = e[10], m = r + l + p;
    if (m > 0) {
      const y = 0.5 / Math.sqrt(m + 1);
      this._w = 0.25 / y, this._x = (f - h) * y, this._y = (a - d) * y, this._z = (c - s) * y;
    } else if (r > l && r > p) {
      const y = 2 * Math.sqrt(1 + r - l - p);
      this._w = (f - h) / y, this._x = 0.25 * y, this._y = (s + c) / y, this._z = (a + d) / y;
    } else if (l > p) {
      const y = 2 * Math.sqrt(1 + l - r - p);
      this._w = (a - d) / y, this._x = (s + c) / y, this._y = 0.25 * y, this._z = (h + f) / y;
    } else {
      const y = 2 * Math.sqrt(1 + p - r - l);
      this._w = (c - s) / y, this._x = (a + d) / y, this._y = (h + f) / y, this._z = 0.25 * y;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(i, e) {
    let r = i.dot(e) + 1;
    return r < 1e-8 ? (r = 0, Math.abs(i.x) > Math.abs(i.z) ? (this._x = -i.y, this._y = i.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -i.z, this._z = i.y, this._w = r)) : (this._x = i.y * e.z - i.z * e.y, this._y = i.z * e.x - i.x * e.z, this._z = i.x * e.y - i.y * e.x, this._w = r), this.normalize();
  }
  angleTo(i) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(i), -1, 1)));
  }
  rotateTowards(i, e) {
    const r = this.angleTo(i);
    if (r === 0)
      return this;
    const s = Math.min(1, e / r);
    return this.slerp(i, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(i) {
    return this._x * i._x + this._y * i._y + this._z * i._z + this._w * i._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let i = this.length();
    return i === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (i = 1 / i, this._x = this._x * i, this._y = this._y * i, this._z = this._z * i, this._w = this._w * i), this._onChangeCallback(), this;
  }
  multiply(i) {
    return this.multiplyQuaternions(this, i);
  }
  premultiply(i) {
    return this.multiplyQuaternions(i, this);
  }
  multiplyQuaternions(i, e) {
    const r = i._x, s = i._y, a = i._z, c = i._w, l = e._x, h = e._y, d = e._z, f = e._w;
    return this._x = r * f + c * l + s * d - a * h, this._y = s * f + c * h + a * l - r * d, this._z = a * f + c * d + r * h - s * l, this._w = c * f - r * l - s * h - a * d, this._onChangeCallback(), this;
  }
  slerp(i, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(i);
    const r = this._x, s = this._y, a = this._z, c = this._w;
    let l = c * i._w + r * i._x + s * i._y + a * i._z;
    if (l < 0 ? (this._w = -i._w, this._x = -i._x, this._y = -i._y, this._z = -i._z, l = -l) : this.copy(i), l >= 1)
      return this._w = c, this._x = r, this._y = s, this._z = a, this;
    const h = 1 - l * l;
    if (h <= Number.EPSILON) {
      const y = 1 - e;
      return this._w = y * c + e * this._w, this._x = y * r + e * this._x, this._y = y * s + e * this._y, this._z = y * a + e * this._z, this.normalize(), this;
    }
    const d = Math.sqrt(h), f = Math.atan2(d, l), p = Math.sin((1 - e) * f) / d, m = Math.sin(e * f) / d;
    return this._w = c * p + this._w * m, this._x = r * p + this._x * m, this._y = s * p + this._y * m, this._z = a * p + this._z * m, this._onChangeCallback(), this;
  }
  slerpQuaternions(i, e, r) {
    return this.copy(i).slerp(e, r);
  }
  random() {
    const i = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), r = Math.random(), s = Math.sqrt(1 - r), a = Math.sqrt(r);
    return this.set(
      s * Math.sin(i),
      s * Math.cos(i),
      a * Math.sin(e),
      a * Math.cos(e)
    );
  }
  equals(i) {
    return i._x === this._x && i._y === this._y && i._z === this._z && i._w === this._w;
  }
  fromArray(i, e = 0) {
    return this._x = i[e], this._y = i[e + 1], this._z = i[e + 2], this._w = i[e + 3], this._onChangeCallback(), this;
  }
  toArray(i = [], e = 0) {
    return i[e] = this._x, i[e + 1] = this._y, i[e + 2] = this._z, i[e + 3] = this._w, i;
  }
  fromBufferAttribute(i, e) {
    return this._x = i.getX(e), this._y = i.getY(e), this._z = i.getZ(e), this._w = i.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(i) {
    return this._onChangeCallback = i, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Vector3 {
  constructor(i = 0, e = 0, r = 0) {
    Vector3.prototype.isVector3 = !0, this.x = i, this.y = e, this.z = r;
  }
  set(i, e, r) {
    return r === void 0 && (r = this.z), this.x = i, this.y = e, this.z = r, this;
  }
  setScalar(i) {
    return this.x = i, this.y = i, this.z = i, this;
  }
  setX(i) {
    return this.x = i, this;
  }
  setY(i) {
    return this.y = i, this;
  }
  setZ(i) {
    return this.z = i, this;
  }
  setComponent(i, e) {
    switch (i) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + i);
    }
    return this;
  }
  getComponent(i) {
    switch (i) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + i);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(i) {
    return this.x = i.x, this.y = i.y, this.z = i.z, this;
  }
  add(i) {
    return this.x += i.x, this.y += i.y, this.z += i.z, this;
  }
  addScalar(i) {
    return this.x += i, this.y += i, this.z += i, this;
  }
  addVectors(i, e) {
    return this.x = i.x + e.x, this.y = i.y + e.y, this.z = i.z + e.z, this;
  }
  addScaledVector(i, e) {
    return this.x += i.x * e, this.y += i.y * e, this.z += i.z * e, this;
  }
  sub(i) {
    return this.x -= i.x, this.y -= i.y, this.z -= i.z, this;
  }
  subScalar(i) {
    return this.x -= i, this.y -= i, this.z -= i, this;
  }
  subVectors(i, e) {
    return this.x = i.x - e.x, this.y = i.y - e.y, this.z = i.z - e.z, this;
  }
  multiply(i) {
    return this.x *= i.x, this.y *= i.y, this.z *= i.z, this;
  }
  multiplyScalar(i) {
    return this.x *= i, this.y *= i, this.z *= i, this;
  }
  multiplyVectors(i, e) {
    return this.x = i.x * e.x, this.y = i.y * e.y, this.z = i.z * e.z, this;
  }
  applyEuler(i) {
    return this.applyQuaternion(_quaternion$1.setFromEuler(i));
  }
  applyAxisAngle(i, e) {
    return this.applyQuaternion(_quaternion$1.setFromAxisAngle(i, e));
  }
  applyMatrix3(i) {
    const e = this.x, r = this.y, s = this.z, a = i.elements;
    return this.x = a[0] * e + a[3] * r + a[6] * s, this.y = a[1] * e + a[4] * r + a[7] * s, this.z = a[2] * e + a[5] * r + a[8] * s, this;
  }
  applyNormalMatrix(i) {
    return this.applyMatrix3(i).normalize();
  }
  applyMatrix4(i) {
    const e = this.x, r = this.y, s = this.z, a = i.elements, c = 1 / (a[3] * e + a[7] * r + a[11] * s + a[15]);
    return this.x = (a[0] * e + a[4] * r + a[8] * s + a[12]) * c, this.y = (a[1] * e + a[5] * r + a[9] * s + a[13]) * c, this.z = (a[2] * e + a[6] * r + a[10] * s + a[14]) * c, this;
  }
  applyQuaternion(i) {
    const e = this.x, r = this.y, s = this.z, a = i.x, c = i.y, l = i.z, h = i.w, d = 2 * (c * s - l * r), f = 2 * (l * e - a * s), p = 2 * (a * r - c * e);
    return this.x = e + h * d + c * p - l * f, this.y = r + h * f + l * d - a * p, this.z = s + h * p + a * f - c * d, this;
  }
  project(i) {
    return this.applyMatrix4(i.matrixWorldInverse).applyMatrix4(i.projectionMatrix);
  }
  unproject(i) {
    return this.applyMatrix4(i.projectionMatrixInverse).applyMatrix4(i.matrixWorld);
  }
  transformDirection(i) {
    const e = this.x, r = this.y, s = this.z, a = i.elements;
    return this.x = a[0] * e + a[4] * r + a[8] * s, this.y = a[1] * e + a[5] * r + a[9] * s, this.z = a[2] * e + a[6] * r + a[10] * s, this.normalize();
  }
  divide(i) {
    return this.x /= i.x, this.y /= i.y, this.z /= i.z, this;
  }
  divideScalar(i) {
    return this.multiplyScalar(1 / i);
  }
  min(i) {
    return this.x = Math.min(this.x, i.x), this.y = Math.min(this.y, i.y), this.z = Math.min(this.z, i.z), this;
  }
  max(i) {
    return this.x = Math.max(this.x, i.x), this.y = Math.max(this.y, i.y), this.z = Math.max(this.z, i.z), this;
  }
  clamp(i, e) {
    return this.x = clamp(this.x, i.x, e.x), this.y = clamp(this.y, i.y, e.y), this.z = clamp(this.z, i.z, e.z), this;
  }
  clampScalar(i, e) {
    return this.x = clamp(this.x, i, e), this.y = clamp(this.y, i, e), this.z = clamp(this.z, i, e), this;
  }
  clampLength(i, e) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(clamp(r, i, e));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(i) {
    return this.x * i.x + this.y * i.y + this.z * i.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(i) {
    return this.normalize().multiplyScalar(i);
  }
  lerp(i, e) {
    return this.x += (i.x - this.x) * e, this.y += (i.y - this.y) * e, this.z += (i.z - this.z) * e, this;
  }
  lerpVectors(i, e, r) {
    return this.x = i.x + (e.x - i.x) * r, this.y = i.y + (e.y - i.y) * r, this.z = i.z + (e.z - i.z) * r, this;
  }
  cross(i) {
    return this.crossVectors(this, i);
  }
  crossVectors(i, e) {
    const r = i.x, s = i.y, a = i.z, c = e.x, l = e.y, h = e.z;
    return this.x = s * h - a * l, this.y = a * c - r * h, this.z = r * l - s * c, this;
  }
  projectOnVector(i) {
    const e = i.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const r = i.dot(this) / e;
    return this.copy(i).multiplyScalar(r);
  }
  projectOnPlane(i) {
    return _vector$5.copy(this).projectOnVector(i), this.sub(_vector$5);
  }
  reflect(i) {
    return this.sub(_vector$5.copy(i).multiplyScalar(2 * this.dot(i)));
  }
  angleTo(i) {
    const e = Math.sqrt(this.lengthSq() * i.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const r = this.dot(i) / e;
    return Math.acos(clamp(r, -1, 1));
  }
  distanceTo(i) {
    return Math.sqrt(this.distanceToSquared(i));
  }
  distanceToSquared(i) {
    const e = this.x - i.x, r = this.y - i.y, s = this.z - i.z;
    return e * e + r * r + s * s;
  }
  manhattanDistanceTo(i) {
    return Math.abs(this.x - i.x) + Math.abs(this.y - i.y) + Math.abs(this.z - i.z);
  }
  setFromSpherical(i) {
    return this.setFromSphericalCoords(i.radius, i.phi, i.theta);
  }
  setFromSphericalCoords(i, e, r) {
    const s = Math.sin(e) * i;
    return this.x = s * Math.sin(r), this.y = Math.cos(e) * i, this.z = s * Math.cos(r), this;
  }
  setFromCylindrical(i) {
    return this.setFromCylindricalCoords(i.radius, i.theta, i.y);
  }
  setFromCylindricalCoords(i, e, r) {
    return this.x = i * Math.sin(e), this.y = r, this.z = i * Math.cos(e), this;
  }
  setFromMatrixPosition(i) {
    const e = i.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(i) {
    const e = this.setFromMatrixColumn(i, 0).length(), r = this.setFromMatrixColumn(i, 1).length(), s = this.setFromMatrixColumn(i, 2).length();
    return this.x = e, this.y = r, this.z = s, this;
  }
  setFromMatrixColumn(i, e) {
    return this.fromArray(i.elements, e * 4);
  }
  setFromMatrix3Column(i, e) {
    return this.fromArray(i.elements, e * 3);
  }
  setFromEuler(i) {
    return this.x = i._x, this.y = i._y, this.z = i._z, this;
  }
  setFromColor(i) {
    return this.x = i.r, this.y = i.g, this.z = i.b, this;
  }
  equals(i) {
    return i.x === this.x && i.y === this.y && i.z === this.z;
  }
  fromArray(i, e = 0) {
    return this.x = i[e], this.y = i[e + 1], this.z = i[e + 2], this;
  }
  toArray(i = [], e = 0) {
    return i[e] = this.x, i[e + 1] = this.y, i[e + 2] = this.z, i;
  }
  fromBufferAttribute(i, e) {
    return this.x = i.getX(e), this.y = i.getY(e), this.z = i.getZ(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const i = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, r = Math.sqrt(1 - e * e);
    return this.x = r * Math.cos(i), this.y = e, this.z = r * Math.sin(i), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const _vector$5 = /* @__PURE__ */ new Vector3(), _quaternion$1 = /* @__PURE__ */ new Quaternion();
function isPointEqual(o, i, e = 1e-6) {
  return getDistance(o, i) < e;
}
function getDistance(o, i) {
  return Math.sqrt(
    Math.pow(o[0] - i[0], 2) + Math.pow(o[1] - i[1], 2) + Math.pow((o[2] || 0) - (i[2] || 0), 2)
  );
}
function intepolateScalar(o, i, e) {
  return o + (i - o) * e;
}
function intepolateArray3(o, i, e) {
  return [
    o[0] + (i[0] - o[0]) * e,
    o[1] + (i[1] - o[1]) * e,
    o[2] + (i[2] - o[2]) * e
  ];
}
function getDirection(o, i, e) {
  return e || (e = new Vector2()), e.fromArray([i[0] - o[0], i[1] - o[1]]), e.normalize(), e;
}
function getDirection3(o, i, e) {
  return e || (e = new Vector3()), e.fromArray([i[0] - o[0], i[1] - o[1], i[2] - o[2]]), e.normalize(), e;
}
const arc1Scratch = new Vector3(), normalScratch = new Vector3(), r1Scratch = new Vector3(), mcScratch = new Vector3();
function calculateCircleCenter1(o, i, e) {
  arc1Scratch.subVectors(i, o);
  const r = arc1Scratch.length();
  arc1Scratch.normalize(), normalScratch.crossVectors(e, arc1Scratch).normalize(), r1Scratch.crossVectors(normalScratch, e).normalize();
  let s = arc1Scratch.normalize().dot(e);
  s = Math.asin(s);
  const a = mcScratch.copy(normalScratch).cross(arc1Scratch).normalize(), l = r / 2 / Math.cos(s) * Math.sin(s);
  return o.clone().add(i).multiplyScalar(0.5).add(a.multiplyScalar(l));
}
const dirAScratch = new Vector3(), dirBScratch = new Vector3(), interPointAScratch = new Vector3(), interPointBScratch = new Vector3(), lerpPointScratch = new Vector3(), offsetScratch = new Vector3();
function getRadiusCenter3D(o, i, e) {
  const [r, s, a] = o, [c, l, h] = i, d = dirAScratch.set(s[0] - r[0], s[1] - r[1], s[2] - r[2]).normalize(), f = dirBScratch.set(l[0] - c[0], l[1] - c[1], l[2] - c[2]).normalize(), p = s[0] - r[0], m = s[1] - r[1], y = s[2] - r[2], x = 1 - a;
  interPointAScratch.set(
    r[0] + p * x,
    r[1] + m * x,
    r[2] + y * x
  );
  const v = l[0] - c[0], S = l[1] - c[1], E = l[2] - c[2];
  interPointBScratch.set(
    c[0] + v * h,
    c[1] + S * h,
    c[2] + E * h
  );
  const b = calculateCircleCenter1(interPointAScratch, interPointBScratch, d), M = interPointAScratch.clone().sub(b).length();
  lerpPointScratch.lerpVectors(interPointAScratch, interPointBScratch, e / 2), offsetScratch.copy(lerpPointScratch).sub(b);
  const P = offsetScratch.length();
  offsetScratch.multiplyScalar(M / P), lerpPointScratch.copy(b).add(offsetScratch), offsetScratch.normalize();
  const L = d.clone().cross(f).normalize().cross(offsetScratch).normalize();
  return {
    point: lerpPointScratch.toArray(),
    direction: L.toArray()
  };
}
const removeDuplicatesEpsilon = CesiumMath.EPSILON10;
function equalsEpsilon(o, i, e) {
  if (o === i)
    return !0;
  if (defined$2(o) && defined$2(i) && Array.isArray(o) && Array.isArray(i)) {
    let r = !0;
    return o.forEach((s, a) => {
      r = r && CesiumMath.equalsEpsilon(o[a], i[a], e);
    }), r;
  }
  return !1;
}
function arrayRemoveDuplicates(o, i, e) {
  if (!o)
    return;
  i = i || !1;
  const r = defined$2(e), s = o.length;
  if (s < 2)
    return o;
  let a, c = o[0], l, h, d = 0, f = -1;
  for (a = 1; a < s; ++a)
    l = o[a], equalsEpsilon(c, l, removeDuplicatesEpsilon) ? (defined$2(h) || (h = o.slice(0, a), d = a - 1, f = 0), r && e.push(a)) : (defined$2(h) && (h.push(l), d = a, r && (f = e.length)), c = l);
  return i && equalsEpsilon(o[0], o[s - 1], removeDuplicatesEpsilon) && (r && (defined$2(h) ? e.splice(f, 0, d) : e.push(s - 1)), defined$2(h) ? h.length -= 1 : h = o.slice(0, -1)), defined$2(h) ? h : o;
}
function slerpVectors(o, i, e) {
  const r = MathUtils.clamp(o.dot(i), -1, 1), s = Math.acos(r) * e, a = i.clone().sub(o.clone().multiplyScalar(r)).normalize();
  return o.clone().multiplyScalar(Math.cos(s)).add(a.multiplyScalar(Math.sin(s)));
}
function numberOfPoints$2(o, i, e) {
  let r;
  return o.isVector3 ? r = o.distanceTo(i) : r = getDistance(o, i), Math.ceil(r / e);
}
const subdivideHeightsScratchArray$3 = [];
function subdivideHeights$3(o, i, e) {
  const r = subdivideHeightsScratchArray$3;
  r.length = o;
  let s = 0;
  if (i === e) {
    for (s = 0; s < o; s++)
      r[s] = i;
    return r;
  }
  const c = (e - i) / o;
  for (let l = 0; l < o; l++) {
    const h = i + l * c;
    r[l] = h;
  }
  return r;
}
const cartoScratch$1 = new Vector3$1(), cartesianScratch$1 = new Vector3$1();
function extractHeights$1(o, i) {
  const e = o.length, r = new Array(e);
  for (let s = 0; s < e; s++)
    cartesianScratch$1.fromArray(o[s]), r[s] = i.cartesianToCartographic(cartesianScratch$1, cartoScratch$1).z;
  return r;
}
const scaleFirst$3 = new Vector3$1(), scaleLast$2 = new Vector3$1(), carto1$3 = new Vector3$1(), carto2$2 = new Vector3$1(), cartesian$3 = new Vector3$1();
new Vector3$1();
const ellipsoidGeodesic$3 = new EllipsoidGeodesic(), scratchP0 = new Vector3$1(), scratchP1 = new Vector3$1(), scratchLerpPoint = new Vector3$1();
function generateCartesianArcColumbus(o, i, e, r, s, a, c) {
  const l = scratchP0.copy(o), h = scratchP1.copy(i), d = numberOfPoints$2(o, i, e), f = subdivideHeights$3(d, r, s);
  let p = c;
  l.z = r, l.toArray(a, p), p += 3;
  for (let m = 1; m < d; m++) {
    scratchLerpPoint.copy(l);
    const y = scratchLerpPoint.lerp(h, m / d);
    y.z = f[m], y.toArray(a, p), p += 3;
  }
  return p;
}
function generateCartesianArc(o, i, e, r, s, a, c, l) {
  const h = r.scaleToGeodeticSurface(o, scaleFirst$3), d = r.scaleToGeodeticSurface(i, scaleLast$2), f = numberOfPoints$2(o, i, e), p = r.cartesianToCartographic(h, carto1$3), m = r.cartesianToCartographic(d, carto2$2), y = subdivideHeights$3(f, s, a);
  ellipsoidGeodesic$3.setEndPoints(p, m);
  const x = ellipsoidGeodesic$3.surfaceDistance / f;
  let v = l;
  p.z = s;
  let S = r.cartographicToCartesian(p, cartesian$3);
  S.toArray(c, v), v += 3;
  for (let E = 1; E < f; E++) {
    const b = ellipsoidGeodesic$3.interpolateUsingSurfaceDistance(
      E * x,
      carto2$2
    );
    b.z = y[E], S = r.cartographicToCartesian(b, cartesian$3), S.toArray(c, v), v += 3;
  }
  return v;
}
function CubicBezierP0(o, i) {
  const e = 1 - o;
  return e * e * e * i;
}
function CubicBezierP1(o, i) {
  const e = 1 - o;
  return 3 * e * e * o * i;
}
function CubicBezierP2(o, i) {
  return 3 * (1 - o) * o * o * i;
}
function CubicBezierP3(o, i) {
  return o * o * o * i;
}
function CubicBezier(o, i, e, r, s) {
  return CubicBezierP0(o, i) + CubicBezierP1(o, e) + CubicBezierP2(o, r) + CubicBezierP3(o, s);
}
const _start = new Vector3$1(), _end = new Vector3$1(), _startCarto = new Vector3$1(), _endCarto = new Vector3$1(), _controlCarto1 = new Vector3$1(), _controlCarto2 = new Vector3$1(), _controlCartesian1 = new Vector3$1(), _controlCartesian2 = new Vector3$1(), _controlSurfaceNormal1 = new Vector3$1(), _controlSurfaceNormal2 = new Vector3$1(), ellipsoidGeodesic$2 = new EllipsoidGeodesic(), _getQuarter = function(o, i) {
  let e = o[0], r = o[1], s = i[0], a = i[1], c = (3 * e + s) / 4, l = (3 * r + a) / 4;
  return [c, l];
}, _getDistance = function(o, i) {
  let e = o[0], r = o[1], s = i[0], a = i[1];
  return Math.sqrt(
    Math.pow(e - s, 2) + Math.pow(r - a, 2)
  );
}, _getControlPoint = function(o, i, e = 1) {
  return [..._getQuarter(o, i), _getDistance(o, i) / e];
};
function getECEFControlPoints(o, i, e = 2) {
  _start.fromArray(o), _end.fromArray(i), Ellipsoid.WGS84.cartesianToCartographic(_start, _startCarto), Ellipsoid.WGS84.cartesianToCartographic(_end, _endCarto), ellipsoidGeodesic$2.setEndPoints(_startCarto, _endCarto);
  const r = ellipsoidGeodesic$2.surfaceDistance, s = r / e;
  ellipsoidGeodesic$2.interpolateUsingSurfaceDistance(r / 3, _controlCarto1), Ellipsoid.WGS84.cartographicToCartesian(_controlCarto1, _controlCartesian1), Ellipsoid.WGS84.geodeticSurfaceNormalCartographic(_controlCarto1, _controlSurfaceNormal1), ellipsoidGeodesic$2.interpolateUsingSurfaceDistance(r * 2 / 3, _controlCarto2), Ellipsoid.WGS84.cartographicToCartesian(_controlCarto2, _controlCartesian2), Ellipsoid.WGS84.geodeticSurfaceNormalCartographic(_controlCarto2, _controlSurfaceNormal2);
  const a = _controlCartesian1.addScaledVector(_controlSurfaceNormal1, s), c = _controlCartesian2.addScaledVector(_controlSurfaceNormal2, s);
  return [
    a.toArray(),
    c.toArray()
  ];
}
function getPlaneControlPoint(o, i, e) {
  const r = _getControlPoint(o, i, e), s = _getControlPoint(i, o, e);
  return [r, s];
}
function getBezierPoint(o, i, e, r, s) {
  return [
    CubicBezier(o, i[0], e[0], r[0], s[0]),
    CubicBezier(o, i[1], e[1], r[1], s[1]),
    CubicBezier(o, i[2], e[2], r[2], s[2])
  ];
}
function getCurve(o, i) {
  const {
    divisions: e = 20,
    heightRatio: r = 2,
    isGlobe: s
  } = i, [a, c] = [o[0], o[o.length - 1]];
  let l = s ? getECEFControlPoints : getPlaneControlPoint;
  const [h, d] = l(a, c, r), f = [];
  for (let p = 0; p <= e; p++) {
    const m = p / e;
    f.push(getBezierPoint(m, a, h, d, c));
  }
  return f;
}
const scaleFirst$2 = new Vector3$1(), scaleLast$1 = new Vector3$1(), carto1$2 = new Vector3$1(), carto2$1 = new Vector3$1(), cartesian$2 = new Vector3$1(), lastPoint$1 = new Vector3$1(), ellipsoidGeodesic$1 = new EllipsoidGeodesic(), tempTrans$1 = new Vector3$1(), scratchPrevPosition = new Vector3$1(), scratchPosition$2 = new Vector3$1(), scratchPosition1 = new Vector3$1(), scratchPosition2 = new Vector3$1(), scratchNextPosition = new Vector3$1(), scratchDiff = new Vector3$1(), p0Scratch$2 = new Vector3$1(), p1Scratch$4 = new Vector3$1(), MERCATOR_LENGTH = 200375083427892e-7;
class PolylineGeometry extends BufferGeometry {
  constructor(e) {
    super();
    _(this, "isFatLineGeometry", !0);
    this.parameters = e, this._granularity = e.granularity || CesiumMath.RADIANS_PER_DEGREE * 0.5, this._needsUpdate = !1, this._needsCounter = !1, this._height = e.height || 0, this._isCurve = e.isCurve || !1, this._flags = {
      lastFlip: -1,
      started: !1,
      normal: null,
      totalDistance: 0
    };
  }
  setData(e) {
    if (this._needsUpdate = !0, this._isCurve && e.position.length > 0 && Array.isArray(e.position[0]) && Array.isArray(e.position[0][0]) && !Array.isArray(e.position[0][0][0]))
      for (let r = 0; r < e.position.length; r++) {
        const s = e.position[r];
        e.position[r] = getCurve(s, {
          isGlobe: this.engine.map.isGlobe
        });
      }
    this.cachedData = e, (this.parameters.dashed || this.parameters.enableAnimation || this.parameters.mapSrc || this.parameters.map) && (this._needsCounter = !0), this.updateGeometry(), this.needsUpdate = !1;
  }
  updateGeometryColumbus(e) {
    const r = [], s = [], a = [], c = [], l = [], h = [], d = [], f = [];
    let p = 0;
    const m = this.parameters.vertexColors;
    for (let y = 0, x = e.position.length; y < x; y++) {
      let v = arrayRemoveDuplicates(e.position[y]);
      if (v.length < 2)
        continue;
      const S = e.index[y], E = this.parameters.vertexColors ? colorToArr4(e.color[y]) : [1, 1, 1, 1];
      v = v.map((L) => [L[0], L[1], L[2] + this._height || 0]);
      const b = v.map((L) => L[2] + this._height), w = MERCATOR_LENGTH * (this._granularity / Math.PI), M = this.generateArcColumbus({
        positions: v,
        minDistance: w,
        height: b
      });
      this.packAttribute(M, r, c, l, h, f);
      const P = M.length / 3, D = P - 1;
      for (let L = 0; L < D; L++)
        s.push(p, p + 2, p + 1), s.push(p + 1, p + 2, p + 3), p += 4;
      d.push(...new Array((P * 2 - 2) * 2).fill(S)), m && a.push(...new Array((P * 2 - 2) * 6).fill(E).flat());
    }
    this.cachedPositions = r, this.cachedPrevs = c, this.cachedNexts = l, this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("prev", new Float32BufferAttribute(c, 3)), this.setAttribute("expandAndPrev", new Float32BufferAttribute(f, 2)), this.setAttribute("next", new Float32BufferAttribute(l, 3)), this.setAttribute("objectIndex", new Float32BufferAttribute(d, 1)), this.setAttribute("uv", new Float32BufferAttribute(h, 2)), m && this.setAttribute("aColor", new Float32BufferAttribute(a, 4)), this.setIndex(s);
  }
  updateGeometry3D(e) {
    const r = [], s = [], a = [], c = [], l = [], h = [], d = [], f = [], p = this._granularity, m = this.engine.map.map.ellipsoid || Ellipsoid.WGS84, y = CesiumMath.chordLength(
      p,
      m.maximumRadius
    );
    let x = 0;
    const v = this.parameters.vertexColors;
    for (let S = 0, E = e.position.length; S < E; S++) {
      let b = arrayRemoveDuplicates(e.position[S]);
      if (b.length < 2)
        continue;
      const w = e.index[S], M = this.parameters.vertexWidths ? e.lineWidth[S] : this.parameters.lineWidth, P = this.parameters.vertexColors ? colorToArr4(e.color[S]) : [1, 1, 1, 1], D = extractHeights$1(b, m).map((V) => V + this._height), L = this.generateArc({
        positions: b,
        minDistance: y,
        ellipsoid: m,
        height: D,
        width: M
      }), O = r.length;
      this.packAttribute(L, r, c, l, h, f);
      const k = L.length / 3 - 1;
      for (let V = 0; V < k; V++)
        s.push(x, x + 2, x + 1), s.push(x + 1, x + 2, x + 3), x += 4;
      d.push(...new Array((r.length - O) / 3).fill(w)), v && a.push(...new Array(r.length - O).fill(P).flat());
    }
    this.cachedPositions = r, this.cachedPrevs = c, this.cachedNexts = l, this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("prev", new Float32BufferAttribute(c, 3)), this.setAttribute("next", new Float32BufferAttribute(l, 3)), this.setAttribute("expandAndPrev", new Float32BufferAttribute(f, 2)), this.setAttribute("uv", new Float32BufferAttribute(h, 2)), this.setAttribute("objectIndex", new Float32BufferAttribute(d, 1)), v && this.setAttribute("aColor", new Float32BufferAttribute(a, 4)), this.setIndex(s);
  }
  updateGeometry() {
    const e = this.cachedData;
    this.engine.map.isGlobe ? this.updateGeometry3D(e) : this.updateGeometryColumbus(e);
  }
  packAttribute(e, r, s, a, c, l) {
    const h = e.length / 3, d = new Float32Array(h);
    for (let p = 1; p < h; p++) {
      const m = e.slice(p * 3, p * 3 + 3), y = e.slice((p - 1) * 3, (p - 1) * 3 + 3);
      d[p] = d[p - 1] + getDistance(m, y);
    }
    const f = d[d.length - 1];
    for (let p = 0; p < h; p++) {
      scratchPosition$2.fromArray(e, p * 3), p === 0 ? (scratchNextPosition.fromArray(e, 1 * 3), scratchDiff.subVectors(scratchPosition$2, scratchNextPosition), scratchPrevPosition.addVectors(scratchPosition$2, scratchDiff)) : scratchPrevPosition.fromArray(e, (p - 1) * 3), p === h - 1 ? (scratchPosition1.fromArray(e, (h - 1) * 3), scratchPosition2.fromArray(e, (h - 2) * 3), scratchDiff.subVectors(scratchPosition1, scratchPosition2), scratchNextPosition.addVectors(scratchPosition1, scratchDiff)) : scratchNextPosition.fromArray(e, (p + 1) * 3);
      const m = d[p] / f, y = p === 0 ? 2 : 0, x = p === h - 1 ? 2 : 4;
      for (let v = y; v < x; v++) {
        r.push(scratchPosition$2.x, scratchPosition$2.y, scratchPosition$2.z), s.push(scratchPrevPosition.x, scratchPrevPosition.y, scratchPrevPosition.z), a.push(scratchNextPosition.x, scratchNextPosition.y, scratchNextPosition.z);
        const S = v - 2 < 0 ? -1 : 1;
        l.push(2 * (v % 2) - 1), l.push(S);
        const E = v % 2;
        c.push(m, E);
      }
    }
  }
  generateArcColumbus(e) {
    e || (e = {});
    const r = e.positions, s = r.length;
    let a = e.minDistance, c = e.height || 0;
    const l = Array.isArray(c);
    defined$2(a) || (a = MERCATOR_LENGTH * (this._granularity / Math.PI));
    let h = 0, d;
    for (d = 0; d < s - 1; d++)
      h += numberOfPoints$2(r[d], r[d + 1], a);
    let f = 0;
    const p = (h + 1) * 3, m = new Array(p);
    for (d = 0; d < s - 1; d++) {
      p0Scratch$2.fromArray(r[d]), p1Scratch$4.fromArray(r[d + 1]);
      const y = l ? c[d] : c, x = l ? c[d + 1] : c;
      f = generateCartesianArcColumbus(
        p0Scratch$2,
        p1Scratch$4,
        a,
        y,
        x,
        m,
        f
      );
    }
    return lastPoint$1.set(...r[s - 1]), lastPoint$1.z = l ? c[s - 1] : c, lastPoint$1.toArray(m, f), f += 3, m;
  }
  generateArc(e) {
    e || (e = {});
    const r = e.positions, s = r.length, a = e.ellipsoid || Ellipsoid.WGS84;
    let c = e.height || 0;
    const l = Array.isArray(c);
    if (s < 1)
      return [];
    if (s === 1) {
      tempTrans$1.fromArray(r[0]);
      const E = a.scaleToGeodeticSurface(tempTrans$1, scaleFirst$2);
      if (c = l ? c[0] : c, c !== 0) {
        const b = a.geodeticSurfaceNormal(E, cartesian$2);
        Cartesian3.multiplyByScalar(b, c, b), Cartesian3.add(E, b, E);
      }
      return [E.x, E.y, E.z];
    }
    let h = e.minDistance;
    defined$2(h) || (h = CesiumMath.chordLength(this._granularity, a.maximumRadius));
    let d = 0, f;
    for (let E = 0; E < s - 1; E++)
      d += numberOfPoints$2(r[E], r[E + 1], h);
    const p = (d + 1) * 3, m = new Array(p);
    let y = 0;
    const x = new Vector3$1();
    for (f = 0; f < s - 1; f++) {
      p0Scratch$2.fromArray(r[f]), p1Scratch$4.fromArray(r[f + 1]), x.crossVectors(p0Scratch$2, p1Scratch$4).normalize();
      const E = l ? c[f] : c, b = l ? c[f + 1] : c;
      y = generateCartesianArc(
        p0Scratch$2,
        p1Scratch$4,
        h,
        a,
        E,
        b,
        m,
        y
      );
    }
    lastPoint$1.set(...r[s - 1]);
    const v = a.cartesianToCartographic(lastPoint$1, carto1$2);
    return v.z = l ? c[s - 1] : c, a.cartographicToCartesian(v, cartesian$2).toArray(m, y), y += 3, m;
  }
  generateCartesianArc(e, r, s, a, c, l, h, d, f, p, m, y) {
    const x = a.scaleToGeodeticSurface(e, scaleFirst$2), v = a.scaleToGeodeticSurface(r, scaleLast$1), S = numberOfPoints$2(e, r, s), E = a.cartesianToCartographic(x, carto1$2), b = a.cartesianToCartographic(v, carto2$1), w = subdivideHeights$3(S, c, l);
    ellipsoidGeodesic$1.setEndPoints(E, b);
    const M = ellipsoidGeodesic$1.surfaceDistance / S;
    let P = d;
    E.z = c;
    const D = new Vector3$1().copy(f).negate();
    let L = a.cartographicToCartesian(E, cartesian$2);
    L.toArray(h, P), f.toArray(p, P), m.push(y), P += 3, L.toArray(h, P), D.toArray(p, P), m.push(y), P += 3;
    for (let O = 1; O < S; O++) {
      const F = ellipsoidGeodesic$1.interpolateUsingSurfaceDistance(
        O * M,
        carto2$1
      );
      F.z = w[O], L = a.cartographicToCartesian(F, cartesian$2), L.toArray(h, P), f.toArray(p, P), m.push(y), P += 3, L.toArray(h, P), D.toArray(p, P), m.push(y), P += 3;
    }
    return P;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
}
const vertexShader$r = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec3 color;
#endif

attribute vec3 prev;
attribute vec3 next;
attribute vec2 expandAndPrev;

uniform float elapsedTime;
uniform bool vertexColors;
uniform float lineWidth;
uniform float height;
uniform float cameraNear;
uniform float cameraFar;
uniform mat4 viewportTransform;
uniform mat4 viewportOrthographicTransform;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vZoomUnits;
varying vec2 vDir;

#ifdef USE_DASH
varying float vPolylineAngle;
#endif

#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

vec2 project(vec4 coord) {
    vec2 screen = coord.xy / coord.w;
    vec2 clip = (screen.xy + 1.0) * 0.5;
    return clip * resolution;
}

vec4 unproject(vec2 projected, float z, float w) {
    vec2 clip = projected / resolution;
    vec2 screen = clip * 2.0 - 1.0;
    return vec4(screen * w, z, w);
}

vec4 eyeToWindowCoordinates(vec4 positionEC) {
    vec4 q = projectionMatrix * positionEC;
    q.xyz /= q.w;
    q.xyz = (viewportTransform * vec4(q.xyz, 1.0)).xyz;

    return q;

}

bool equalsEpsilon(vec3 left, vec3 right, float epsilon) {
    return all(lessThanEqual(abs(left - right), vec3(epsilon)));
}

void clipLineSegmentToNearPlane(
    vec3 p0,
    vec3 p1,
    out vec4 positionWC,
    out bool clipped,
    out bool culledByNearPlane,
    out vec4 clippedPositionEC)
{
    culledByNearPlane = false;
    clipped = false;

    vec3 p0ToP1 = p1 - p0;
    float magnitude = length(p0ToP1);
    vec3 direction = normalize(p0ToP1);

    float endPoint0Distance = cameraNear + p0.z;

    float denominator = -direction.z;

    if (endPoint0Distance > 0.0 && abs(denominator) < 0.0000001)
    {
        culledByNearPlane = true;
    }
    else if (endPoint0Distance > 0.0)
    {
        float t = endPoint0Distance / denominator;
        if (t < 0.0 || t > magnitude)
        {
            culledByNearPlane = true;
        }
        else
        {
            // Segment crosses the near plane, update p0 to lie exactly on it.
            p0 = p0 + t * direction;
            p0.z = min(p0.z, -cameraNear);

            clipped = true;
        }
    }

    clippedPositionEC = vec4(p0, 1.0);
    positionWC = eyeToWindowCoordinates(clippedPositionEC);
}

const float piOverFour = 0.7853981633974483;

void main() {
    #include <begin_vertex>

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = vec4(color, 1.0);
    #endif

    vec4 prevEC = modelViewMatrix * vec4(prev, 1.0);
    vec4 nextEC = modelViewMatrix * vec4(next, 1.0);
    vec4 positionEC = modelViewMatrix * vec4(transformed, 1.0);

    float direction = expandAndPrev.x;
    bool usePrevious = expandAndPrev.y < 0.0;

    #ifdef USE_DASH
        vec4 positionWindow = eyeToWindowCoordinates(positionEC);
        vec4 previousWindow = eyeToWindowCoordinates(prevEC);
        vec4 nextWindow = eyeToWindowCoordinates(nextEC);

        vec2 lineDir;
        if (usePrevious) {
            lineDir = normalize(positionWindow.xy - previousWindow.xy);
        }
        else {
            lineDir = normalize(nextWindow.xy - positionWindow.xy);
        }
        float angle = atan(lineDir.x, lineDir.y) - 1.570796327;

        angle = floor(angle / piOverFour + 0.5) * piOverFour;
        vPolylineAngle = angle;
    #endif

    vec4 clippedPrevWC, clippedPrevEC;
    bool prevSegmentClipped, prevSegmentCulled;
    clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);

    vec4 clippedNextWC, clippedNextEC;
    bool nextSegmentClipped, nextSegmentCulled;
    clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);

    bool segmentClipped, segmentCulled;
    vec4 clippedPositionWC, clippedPositionEC;
    clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC);
    
    vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);
    vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);

    // \u5982\u679C\u7247\u6BB5\u88AB\u88C1\u526A\uFF0C\u4E0D\u80FD\u4F7F\u7528\u5176\u6765\u8BA1\u7B97\u65B9\u5411
    if (prevSegmentCulled)
    {
        directionToPrevWC = -directionToNextWC;
    }
    else if (nextSegmentCulled)
    {
        directionToNextWC = -directionToPrevWC;
    }

    vec2 thisSegmentForwardWC;
    vec2 otherSegmentForwardWC;
    if (usePrevious)
    {
        thisSegmentForwardWC = -directionToPrevWC;
        otherSegmentForwardWC = directionToNextWC;
    }
    else
    {
        thisSegmentForwardWC = directionToNextWC;
        otherSegmentForwardWC =  -directionToPrevWC;
    }

    vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x);
    vec2 leftWC = thisSegmentLeftWC;
    float expandWidth = lineWidth * 0.5;

    // \u6839\u636E\u5939\u89D2\u504F\u79FB\u9876\u70B9
    if (
        !equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), 1.0)
        && !equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), 1.0))
    {

        vec2 otherSegmentLeftWC = vec2(-otherSegmentForwardWC.y, otherSegmentForwardWC.x);
        vec2 leftSumWC = thisSegmentLeftWC + otherSegmentLeftWC;
        float leftSumLength = length(leftSumWC);
        leftWC = leftSumLength < 0.000001 ? thisSegmentLeftWC : (leftSumWC / leftSumLength);

        vec2 u = -thisSegmentForwardWC;
        vec2 v = leftWC;
        float sinAngle = abs(u.x * v.y - u.y * v.x);
        expandWidth = clamp(expandWidth / sinAngle, 0.0, lineWidth * 2.0);
    }

    vec2 pos = clippedPositionWC.xy + (leftWC * expandWidth) * direction;
    vec4 windowCoordinates = vec4(pos, -clippedPositionWC.z, 1.0) * (projectionMatrix * clippedPositionEC).w;

    vec4 finalPosition = viewportOrthographicTransform * windowCoordinates;

    gl_Position = finalPosition;

    #include <beginnormal_vertex>
    #include <fog_vertex>
    #include <logdepthbuf_vertex>
}`, fragmentShader$p = `#define GLSLIFY 1
#include <common>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

varying vec3 vLightFront;
varying vec3 vIndirectFront;

uniform float lineWidth;
uniform float opacity;
uniform float alphaTest;
uniform float elapsedTime;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vZoomUnits;

#ifdef USE_DASH
uniform float pixelRatio;
varying float vPolylineAngle;

const float maskLength = 16.0;

mat2 rotate(float rad) {
    float c = cos(rad);
    float s = sin(rad);
    return mat2(
        c, s,
        -s, c
    );
}
#endif

void main() {

    vec4 c = vColor;
    // TODO
    // \u652F\u6301\u865A\u7EBF\u548C\u8D34\u56FE
    #ifdef USE_DASH
        vec2 pos = rotate(vPolylineAngle) * gl_FragCoord.xy;

        float oddOrEven = fract( pos.x / (20.0 * pixelRatio));
        if (oddOrEven > 0.5) {
            discard;
        }
    #endif
    c *= opacity;
    gl_FragColor = c;

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}`, uniforms$q = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  emissiveUniforms,
  {
    lineWidth: { value: 10 },
    color: { value: [0, 1, 1] },
    opacity: { value: 1 },
    resolution: { value: new Vector2$1(1, 1) },
    dashArray: { value: 20 },
    dashOffset: { value: 0 },
    dashRatio: { value: 0.5 },
    alphaTest: { value: 0 },
    vertexColors: { value: !1 },
    elapsedTime: { value: 0 },
    isEmissive: { value: !1 },
    viewportTransform: { value: new Matrix4() },
    viewportOrthographicTransform: { value: new Matrix4() },
    cameraNear: { value: 0 },
    cameraFar: { value: 0 }
  }
]);
class PolylineMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "PolylineMaterial", this.isPolylineMaterial = !0, this.fog = !0, this.fragmentShader = fragmentShader$p, this.side = DoubleSide, this.vertexShader = vertexShader$r, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$q)), defineMaterialNormalProperties(this, [
      "lineWidth",
      "opacity",
      "dashArray",
      "dashOffset",
      "dashRatio",
      "alphaTest",
      "isEmissive",
      "cameraNear",
      "cameraFar"
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["dashed", "USE_DASH"]
    ]), defineMaterialEmissiveProperties(this), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(i);
  }
  dispose() {
    this.uniforms.map && this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
const _inverseMatrix$1 = new Matrix4(), _ray$2 = new Ray(), _sphere$3 = new Sphere(), _viewportTransform$1 = new Matrix4(), _viewportOrthographicTransform = new Matrix4();
class PolylineInternal extends GeoMesh {
  constructor(e) {
    super();
    _(this, "isEventEntitySupported", !0);
    _(this, "_resolution", new Vector2$1());
    _(this, "geometry");
    _(this, "material");
    _(this, "color");
    _(this, "vertexColors");
    _(this, "emissive");
    _(this, "map");
    _(this, "opacity");
    _(this, "alphaTest");
    _(this, "dashed");
    _(this, "dashArray");
    _(this, "dashOffset");
    _(this, "dashRatio");
    _(this, "makeGeometryOffsetPosition", (e) => {
      if (!this._enableRtc)
        return;
      const r = e.boundingSphere && e.boundingSphere.center;
      if (!r) {
        this._cachedRtc = [0, 0, 0], this.updateTransform();
        return;
      }
      const { x: s, y: a, z: c } = r, l = e.cachedPositions, h = e.cachedPrevs, d = e.cachedNexts;
      this.makePostionArrayOffset(e.attributes.position.array, s, a, c, l), this.makePostionArrayOffset(e.attributes.prev.array, s, a, c, h), this.makePostionArrayOffset(e.attributes.next.array, s, a, c, d), this.geometry.computeBoundingSphere(), this._cachedRtc = [s, a, c], this.updateTransform();
    });
    this.parameters = e, this.defineMaterialProxyProperties([
      "height",
      "transparent",
      "opacity",
      "alphaTest",
      "dashed",
      "dashArray",
      "dashOffset",
      "dashRatio",
      "color",
      "vertexColors",
      "vertexWidths",
      "emissive"
    ]);
  }
  getDefaultParams() {
    return {
      lineWidth: 4
    };
  }
  computeViewportOrthographicTransform(e, r, s, a) {
    r = r || 0, s = s || 1;
    const c = e.x || 0, l = e.y || 0, h = c + e.width || 0, d = l + e.height | 0;
    let f = 1 / (h - c), p = 1 / (d - l), m = 1 / (s - r);
    const y = -(h + c) * f, x = -(d + l) * p, v = -(s + r) * m;
    f *= 2, p *= 2, m *= -2;
    const S = a.elements;
    return S[0] = f, S[1] = 0, S[2] = 0, S[3] = 0, S[4] = 0, S[5] = p, S[6] = 0, S[7] = 0, S[8] = 0, S[9] = 0, S[10] = m, S[11] = 0, S[12] = y, S[13] = x, S[14] = v, S[15] = 1, a;
  }
  computeViewportTransformation(e, r, s, a) {
    const c = e.x || 0, l = e.y || 0, h = e.width || 0, d = e.height || 0;
    r = r || 0, s = s || 1;
    const f = h * 0.5, p = d * 0.5, m = (s - r) * 0.5, y = f, x = p, v = m, S = c + f, E = l + p, b = r + m, w = 1, M = a.elements;
    return M[0] = y, M[1] = 0, M[2] = 0, M[3] = 0, M[4] = 0, M[5] = x, M[6] = 0, M[7] = 0, M[8] = 0, M[9] = 0, M[10] = v, M[11] = 0, M[12] = S, M[13] = E, M[14] = b, M[15] = w, a;
  }
  initObject() {
    const { lineJoin: e, lineCap: r, isCurve: s, flat: a, keepSize: c, ...l } = this.parameters, h = this.geometry = new PolylineGeometry(this.parameters);
    h.engine = this.engine, (this.material = new PolylineMaterial(l)).setCommonUniforms(this.engine.rendering.uniforms);
  }
  onBeforeScenePrepareRenderHook() {
    this._cameraNear !== this.engine.camera.near && (this.material.uniforms.cameraNear.value = this.engine.camera.near, this._cameraNear = this.engine.camera.near), this._cameraFar !== this.engine.camera.far && (this.material.uniforms.cameraFar.value = this.engine.camera.far, this._cameraFar = this.engine.camera.far);
    const { x: e, y: r } = this.engine.rendering.uniforms.resolution.value;
    (this._resolution.x !== e || this._resolution.y !== r) && (this.material.uniforms.viewportTransform.value.copy(this.computeViewportTransformation({
      width: this.engine.rendering.uniforms.resolution.value.x,
      height: this.engine.rendering.uniforms.resolution.value.y
    }, 0, 1, _viewportTransform$1)), this.material.uniforms.viewportOrthographicTransform.value.copy(this.computeViewportOrthographicTransform({
      width: this.engine.rendering.uniforms.resolution.value.x,
      height: this.engine.rendering.uniforms.resolution.value.y
    }, 0, 1, _viewportOrthographicTransform)), this._resolution.set(e, r));
  }
  _updateData() {
    const e = this.dataSource.data;
    this.geometry.setData(e), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry), this.geometry.computeBoundingBox(), this.needsUpdate = !1;
  }
  afterGeometryUpdate() {
    this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry), this.geometry.computeBoundingBox();
  }
  get lineWidth() {
    return this.parameters.lineWidth;
  }
  set lineWidth(e) {
    this.parameters.lineWidth = e;
  }
  raycast(e, r) {
    if (!this.visible)
      return;
    const s = this.geometry, a = this.matrixWorld, c = e.params.Line.threshold, l = s.drawRange;
    let h = this.lineWidth / 2;
    if (h *= this.material.uniforms.zoomUnits.value, s.boundingSphere === null && s.computeBoundingSphere(), _sphere$3.copy(s.boundingSphere), _sphere$3.applyMatrix4(a), _sphere$3.radius += h, e.ray.intersectsSphere(_sphere$3) === !1)
      return;
    _inverseMatrix$1.copy(a).invert(), _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$1);
    const d = h / ((this.scale.x + this.scale.y + this.scale.z) / 3), f = d * d, p = new Vector3$1(), m = new Vector3$1(), y = new Vector3$1(), x = new Vector3$1(), v = 2;
    if (s.isBufferGeometry) {
      const S = s.index, E = s.attributes, b = E.position, w = E.objectIndex;
      if (S !== null) {
        const M = Math.max(0, l.start), P = Math.min(S.count, l.start + l.count);
        for (let D = M, L = P - 1; D < L; D += v) {
          const O = S.getX(D), F = S.getX(D + 1);
          if (p.fromBufferAttribute(b, O), m.fromBufferAttribute(b, F), _ray$2.distanceSqToSegment(p, m, x, y) > f)
            continue;
          x.applyMatrix4(this.matrixWorld);
          const V = e.ray.origin.distanceTo(x);
          if (V < e.near || V > e.far)
            continue;
          const N = w.getX(O), U = w.getX(F);
          N === U && r.push({
            distance: V,
            point: y.clone().applyMatrix4(this.matrixWorld),
            index: w.getX(O),
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const M = Math.max(0, l.start), P = Math.min(b.count, l.start + l.count);
        for (let D = M, L = P - 1; D < L; D += v) {
          if (p.fromBufferAttribute(b, D), m.fromBufferAttribute(b, D + 1), _ray$2.distanceSqToSegment(p, m, x, y) > f)
            continue;
          x.applyMatrix4(this.matrixWorld);
          const F = e.ray.origin.distanceTo(x);
          F < e.near || F > e.far || r.push({
            distance: F,
            point: y.clone().applyMatrix4(this.matrixWorld),
            index: D,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    }
    e.params.Line.threshold = c;
  }
}
function computeNormal(o) {
  return new Vector2$1(-o.y, o.x);
}
function computeMiter(o, i) {
  let e = new Vector2$1();
  return e.addVectors(o, i), e.normalize(), computeNormal(e);
}
function vector2RotateTo(o, i) {
  let e = o.x * i.x + o.y * i.y, r = Math.sqrt(o.x * o.x + o.y * o.y), s = Math.sqrt(i.x * i.x + i.y * i.y), a = Math.acos(e / (r * s));
  return o.x * i.y - i.x * o.y < 0 && (a = 2 * Math.PI - a), a;
}
function rotatePoint(o, i, e) {
  const r = o.clone().sub(i), s = Math.cos(e), a = Math.sin(e), c = r.x * s + r.y * a, l = -r.x * a + r.y * s, h = new Vector2$1(c, l);
  return h.add(i), h;
}
function isAOConcaveAngle(o, i, e) {
  const r = [e[0] - i[0], e[1] - i[1]], s = [o[0] - i[0], o[1] - i[1]], c = (r[0] * s[0] + r[1] * s[1]) / Math.sqrt((r[0] * r[0] + r[1] * r[1]) * (s[0] * s[0] + s[1] * s[1])), l = -r[1] * s[0] + r[0] * s[1];
  return c > -0.866 && l < 0;
}
class ShadowVolumeLineGeometry extends BufferGeometry {
  constructor() {
    super(...arguments);
    _(this, "_volumeSegmentLines", (e, r, s, a, c, l, h, d, f, p, m) => {
      let y = 0, x = new Vector2$1();
      const v = [h[0], h[1]], S = [l[0], l[1]];
      let E = getDirection(S, v);
      if (m && (x = computeNormal(E), this._volumeExtrusions(e, r, a, s, l, x, f)), !d)
        x = computeNormal(E), this._volumeExtrusions(e, r, a, s, h, x, f), y += 2;
      else {
        const b = [d[0], d[1]];
        let w = getDirection(v, b), M = new Vector2$1();
        M.addVectors(E, w), M.normalize();
        const P = computeMiter(E, w), D = computeNormal(E), L = Math.min(f, f / P.dot(D));
        this._volumeExtrusions(e, r, a, s, h, P, L), y += 2;
      }
      return y;
    });
    _(this, "_volumeExtrusions", (e, r, s, a, c, l, h) => {
      s.push(l.x, l.y, 0, -l.x, -l.y, 0), e.push(c[0] + l.x * h / 2, c[1] + l.y * h / 2, c[2]), r.push(c[0] - l.x * h / 2, c[1] - l.y * h / 2, c[2]), a.push(h, h);
    });
  }
  createVolumeGeometry(e, r) {
    let s = this.parameters.lineWidth * r, a = [];
    for (let c = 0; c < e.length; c++) {
      const { vertices: l } = this.lineToShadowVolumeMesh(e[c], s);
      a.push([l]);
    }
    return a;
  }
  lineToShadowVolumeMesh(e, r) {
    let s = 0, a = null, c = null, l = null, h = null;
    const d = [], f = [], p = [], m = [], y = [], x = [];
    let v = !0;
    for (let b = 1, w = e.length - 1; b <= w; b++) {
      if (a = h || e[b - 1], c = e[b], l = e[b + 1], l && isPointEqual(c, l)) {
        h = a;
        continue;
      }
      const M = this._volumeSegmentLines(
        y,
        x,
        m,
        f,
        p,
        a,
        c,
        l,
        r,
        s,
        v
      );
      M !== -1 && (s += M, h = null), v = !1;
    }
    const S = this.conversion(y, 3), E = this.conversion(x, 3);
    return d.push(...S.concat(E.reverse())), d.push(d[0]), {
      vertices: d,
      indices: p,
      normals: f,
      widths: m
    };
  }
  conversion(e, r) {
    let s = e.length, a = s % r === 0 ? s / r : Math.floor(s / r + 1), c = [];
    for (let l = 0; l < a; l++) {
      let h = e.slice(l * r, l * r + r);
      c.push(h);
    }
    return c;
  }
}
const scaleFirst$1 = new Vector3$1(), scaleLast = new Vector3$1(), carto1$1 = new Vector3$1(), carto2 = new Vector3$1(), carto3 = new Vector3$1(), cartoNext = new Vector3$1(), cartesian$1 = new Vector3$1(), cartesian2 = new Vector3$1(), cartesianOffset = new Vector3$1(), cartesianPrev = new Vector3$1(), cartesianNext = new Vector3$1(), lastMiterScratch = new Vector3$1();
new Vector3$1();
const negativeNormalScratch = new Vector3$1(), negativeMiterScratch = new Vector3$1(), ellipsoidGeodesic = new EllipsoidGeodesic();
function numberOfPoints$1(o, i, e) {
  let r;
  return o.isVector3 ? r = o.distanceTo(i) : r = getDistance(o, i), Math.ceil(r / e);
}
const subdivideHeightsScratchArray$2 = [], subdivideHeights$2 = (o, i, e) => {
  const r = subdivideHeightsScratchArray$2;
  r.length = o;
  let s = 0;
  if (i === e) {
    for (s = 0; s < o; s++)
      r[s] = i;
    return r;
  }
  const c = (e - i) / o;
  for (let l = 0; l < o; l++) {
    const h = i + l * c;
    r[l] = h;
  }
  return r;
};
function direction$1(o, i, e) {
  return e.copy(o).sub(i), e.normalize(), e;
}
function tangentDirection(o, i, e, r) {
  return direction$1(o, i, r), r.cross(e).normalize(), r.cross(e).normalize(), r;
}
const cosine90 = 0, forwardScratch = new Vector3$1(), toPreviousScratch = new Vector3$1(), toNextScratch = new Vector3$1();
function computeVertexMiterNormal(o, i, e, r, s) {
  const a = tangentDirection(
    o,
    i,
    r,
    toPreviousScratch
  ), c = tangentDirection(e, i, r, toNextScratch);
  s.copy(a).add(c).normalize();
  const l = forwardScratch.copy(r).cross(s), h = c.dot(l) < cosine90;
  return h && s.negate(), {
    miter: s,
    isFlip: h
  };
}
const p0Scratch$1 = new Vector3$1(), p1Scratch$3 = new Vector3$1(), p2Scratch$2 = new Vector3$1();
class FatLineGeometry extends ShadowVolumeLineGeometry {
  constructor(e) {
    super();
    _(this, "isFatLineGeometry", !0);
    _(this, "_segmentLines", (e, r, s, a, c, l, h, d, f, p, m, y, x, v, S, E, b) => {
      let w = 0, M = new Vector2$1(), P = new Vector2$1(), D = new Vector2$1();
      const L = this.parameters.lineCap === "square", O = this.parameters.lineCap === "round", F = this.parameters.lineJoin === "bevel", k = this.parameters.lineJoin === "round", V = [m[0], m[1]], N = [p[0], p[1]];
      let U = this.getFlatDirection(N, V), z = 0;
      this._needsCounter && (z = getDistance(m, p), this._flags.totalDistance += z), this._flags.normal || (this._flags.normal = new Vector2$1(), this._flags.normal = computeNormal(U));
      let $ = 1, G = -1, j, Y, H;
      if (!this._flags.started)
        if (this._flags.started = !0, j = this._flags.totalDistance - z, H = this._flags.totalDistance, Y = j - z, L) {
          const W = new Vector2$1(), q = new Vector2$1();
          W.addVectors(this._flags.normal, U), q.subVectors(this._flags.normal, U), h.push(
            q.x,
            q.y,
            0,
            -W.x,
            -W.y,
            0
          ), e.push(
            p[0],
            p[1],
            p[2],
            p[0],
            p[1],
            p[2]
          );
          const Z = [m[0] - p[0], m[1] - p[1], m[2] - p[2]];
          S.push(
            p[0] + Z[0],
            p[1] + Z[0],
            p[2] + Z[0],
            p[0] + Z[0],
            p[1] + Z[0],
            p[2] + Z[0]
          ), E.push(
            m[0],
            m[1],
            m[2],
            m[0],
            m[1],
            m[2]
          ), r.push(
            this._flags.totalDistance - z,
            0,
            this._flags.totalDistance - z,
            1
          ), s.push(
            j,
            j
          ), a.push(
            Y,
            H,
            Y,
            H
          ), l.push(
            x,
            G,
            x,
            G
          ), c.push(0, 0), this.parameters.vertexColors && d.push(
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3]
          );
        } else if (O) {
          const W = U.clone();
          W.negate();
          const q = new Vector2$1();
          q.subVectors(this._flags.normal, U), q.normalize();
          const Z = new Vector2$1();
          Z.addVectors(this._flags.normal, U), Z.normalize();
          const X = this._flags.normal.clone(), K = this._flags.normal.clone();
          K.negate(), h.push(W.x, W.y, 0), h.push(q.x, q.y, 0), h.push(-Z.x, -Z.y, 0), h.push(X.x, X.y, 0), h.push(K.x, K.y, 0);
          const ee = [m[0] - p[0], m[1] - p[1], m[2] - p[2]];
          for (let ie = 0; ie < 5; ie++)
            e.push(p[0], p[1], p[2]), S.push(p[0] + ee[0], p[1] + ee[1], p[2] + ee[2]), E.push(m[0], m[1], m[2]), l.push(x, G), r.push(this._flags.totalDistance - z, 0), s.push(j), a.push(Y, H), c.push(0), this.parameters.vertexColors && d.push(v[0], v[1], v[2], v[3]);
          f.push(
            b + 0,
            b + 2,
            b + 1,
            b + 1,
            b + 2,
            b + 3,
            b + 3,
            b + 2,
            b + 4
          ), w += 3, b += 3;
        } else
          this._extrusions(
            e,
            h,
            r,
            s,
            a,
            c,
            l,
            d,
            p,
            p,
            m,
            this._flags.normal,
            j,
            Y,
            H,
            x,
            G,
            !0,
            v,
            S,
            E
          );
      if (f.push(
        ...this._flags.lastFlip === -1 ? [b + 0, b + 1, b + 2] : [b + 1, b + 0, b + 2]
      ), j = this._flags.totalDistance, Y = this._flags.totalDistance - z, !y)
        H = j + z;
      else {
        const W = getDistance(m, y);
        H = j + W;
      }
      if (y) {
        const W = [y[0], y[1]];
        P = this.getFlatDirection(V, W), D.addVectors(U, P), D.normalize();
        const q = computeMiter(U, P), Z = computeNormal(U), X = x / q.dot(Z);
        let K = D.dot(this._flags.normal) > 0 ? -1 : 1, ee = F;
        if (!ee && this.parameters.lineJoin === "miter" && Math.abs(X) > (this.parameters.miterLimit || x * 2) && (ee = !0), ee) {
          const ie = Math.min(x * 2, Math.abs(X));
          h.push(this._flags.normal.x * K, this._flags.normal.y * K, 0), h.push(-q.x * K, -q.y * K, 0), e.push(
            m[0],
            m[1],
            m[2],
            m[0],
            m[1],
            m[2]
          ), S.push(
            p[0],
            p[1],
            p[2],
            p[0],
            p[1],
            p[2]
          ), E.push(
            y[0],
            y[1],
            y[2],
            y[0],
            y[1],
            y[2]
          ), l.push(
            x,
            $,
            ie,
            $
          ), s.push(
            j,
            j
          ), a.push(
            Y,
            H,
            Y,
            H
          ), c.push(0, 0), f.push(
            ...this._flags.lastFlip === -K ? this._flags.lastFlip === -1 ? [b + 2, b + 1, b + 3] : [b + 1, b + 2, b + 3] : this._flags.lastFlip === -1 ? [b + 0, b + 2, b + 3] : [b + 2, b + 0, b + 3]
          ), M = computeNormal(P), this._flags.normal.copy(M), h.push(this._flags.normal.x * K, this._flags.normal.y * K, 0), e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(y[0], y[1], y[2]), l.push(x, $), s.push(j), a.push(Y, H), c.push(0), h.push(-q.x * K, -q.y * K, 0), e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(y[0], y[1], y[2]), l.push(ie, G), s.push(j), a.push(Y, H), c.push(0), h.push(this._flags.normal.x * K, this._flags.normal.y * K, 0), e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(y[0], y[1], y[2]), l.push(
            x,
            G
          ), s.push(j), a.push(Y, H), c.push(0), f.push(
            ...K === 1 ? [b + 2, b + 3, b + 4] : [b + 3, b + 2, b + 4]
          ), this._flipedUV(r, this._flags.totalDistance, K, !0), this.parameters.vertexColors && d.push(
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3]
          ), w += 5;
        } else if (k) {
          const ie = Math.min(x * 2, Math.abs(X));
          h.push(this._flags.normal.x * K, this._flags.normal.y * K, 0), e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(y[0], y[1], y[2]), l.push(
            x,
            $
          ), s.push(j), a.push(Y, H), c.push(0), h.push(q.x * K, q.y * K, 0), e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(y[0], y[1], y[2]), l.push(
            x,
            $
          ), s.push(j), a.push(Y, H), c.push(0), h.push(q.x * K, q.y * K, 0), e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(y[0], y[1], y[2]), l.push(
            x,
            G
          ), s.push(j), a.push(Y, H), c.push(0), h.push(-q.x * K, -q.y * K, 0), e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(y[0], y[1], y[2]), l.push(ie, $), s.push(j), a.push(Y, H), c.push(0), h.push(-q.x * K, -q.y * K, 0), e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(y[0], y[1], y[2]), l.push(ie, G), s.push(j), a.push(Y, H), c.push(0), f.push(
            ...this._flags.lastFlip === -K ? this._flags.lastFlip === -1 ? [b + 2, b + 1, b + 5, b + 2, b + 5, b + 3] : [b + 1, b + 2, b + 5, b + 5, b + 2, b + 3] : this._flags.lastFlip === -1 ? [b + 0, b + 2, b + 5, b + 2, b + 3, b + 5] : [b + 2, b + 0, b + 5, b + 3, b + 2, b + 5]
          ), M = computeNormal(P), this._flags.normal.copy(M), h.push(this._flags.normal.x * K, this._flags.normal.y * K, 0), e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(y[0], y[1], y[2]), l.push(x, G), s.push(j), a.push(Y, H), c.push(0), f.push(
            ...K === -1 ? [b + 6, b + 4, b + 7] : [b + 4, b + 6, b + 7]
          ), this._flipedUV(r, this._flags.totalDistance, K, !1), this.parameters.vertexColors && d.push(
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3]
          ), w += 6;
        } else
          this._extrusions(
            e,
            h,
            r,
            s,
            a,
            c,
            l,
            d,
            m,
            p,
            y,
            q,
            j,
            Y,
            H,
            X,
            $,
            !1,
            v,
            S,
            E
          ), this._extrusions(
            e,
            h,
            r,
            s,
            a,
            c,
            l,
            d,
            m,
            p,
            y,
            q,
            j,
            Y,
            H,
            X,
            G,
            !1,
            v,
            S,
            E
          ), f.push(
            ...this._flags.lastFlip === -1 ? [b + 2, b + 1, b + 3] : [b + 2, b + 0, b + 3]
          ), K = -1, this._flags.normal.copy(q), w += 4;
        this._flags.lastFlip = K;
      } else {
        if (this._flags.normal = computeNormal(U), L) {
          const W = new Vector2$1(), q = new Vector2$1();
          W.addVectors(U, this._flags.normal), q.subVectors(U, this._flags.normal), h.push(
            W.x,
            W.y,
            0,
            q.x,
            q.y,
            0
          ), e.push(
            m[0],
            m[1],
            m[2],
            m[0],
            m[1],
            m[2]
          ), S.push(
            p[0],
            p[1],
            p[2],
            p[0],
            p[1],
            p[2]
          );
          const Z = [m[0] - p[0], m[1] - p[1], m[2] - p[2]];
          E.push(
            m[0] + Z[0],
            m[1] + Z[1],
            m[2] + Z[2],
            m[0] + Z[0],
            m[1] + Z[1],
            m[2] + Z[2]
          ), l.push(x, $, x, $), r.push(
            this._flags.totalDistance,
            0,
            this._flags.totalDistance,
            1
          ), s.push(
            j,
            j
          ), a.push(
            Y,
            H,
            Y,
            H
          ), c.push(0, 0), this.parameters.vertexColors && d.push(
            v[0],
            v[1],
            v[2],
            v[3],
            v[0],
            v[1],
            v[2],
            v[3]
          );
        } else
          this._extrusions(
            e,
            h,
            r,
            s,
            a,
            c,
            l,
            d,
            m,
            p,
            y,
            this._flags.normal,
            j,
            Y,
            H,
            x,
            $,
            !1,
            v,
            S,
            E
          );
        if (f.push(
          ...this._flags.lastFlip === -1 ? [b + 2, b + 1, b + 3] : [b + 2, b + 0, b + 3]
        ), w += 2, O) {
          const W = new Vector2$1();
          W.addVectors(U, this._flags.normal), W.normalize();
          const q = new Vector2$1();
          q.subVectors(U, this._flags.normal), q.normalize();
          const Z = U.clone();
          h.push(W.x, W.y, 0), h.push(q.x, q.y, 0), h.push(Z.x, Z.y, 0);
          const X = m[0] + (m[0] - p[0]), K = m[1] + (m[1] - p[1]), ee = m[2] + (m[2] - p[2]);
          for (let ie = 0; ie < 3; ie++)
            e.push(m[0], m[1], m[2]), S.push(p[0], p[1], p[2]), E.push(X, K, ee), l.push(x, $), r.push(this._flags.totalDistance, 0), s.push(j), a.push(
              Y,
              H,
              Y,
              H
            ), c.push(0), this.parameters.vertexColors && d.push(v[0], v[1], v[2], v[3]);
          f.push(
            b + 2,
            b + 3,
            b + 4,
            b + 4,
            b + 3,
            b + 5,
            b + 4,
            b + 5,
            b + 6
          ), w += 3;
        }
      }
      return w;
    });
    _(this, "_extrusions", (e, r, s, a, c, l, h, d, f, p, m, y, x, v, S, E, b, w, M, P, D) => {
      if (r.push(
        y.x,
        y.y,
        0,
        -y.x,
        -y.y,
        0
      ), e.push(
        f[0],
        f[1],
        f[2],
        f[0],
        f[1],
        f[2]
      ), w) {
        const L = [m[0] - f[0], m[1] - f[1], m[2] - f[2]];
        P.push(
          p[0] - L[0],
          p[1] - L[1],
          p[2] - L[2],
          p[0] - L[0],
          p[1] - L[1],
          p[2] - L[2]
        );
      } else
        P.push(
          p[0],
          p[1],
          p[2],
          p[0],
          p[1],
          p[2]
        );
      if (m)
        D.push(
          m[0],
          m[1],
          m[2],
          m[0],
          m[1],
          m[2]
        );
      else {
        const L = [f[0] - p[0], f[1] - p[1], f[2] - p[2]];
        D.push(
          f[0] + L[0],
          f[1] + L[1],
          f[2] + L[2],
          f[0] + L[0],
          f[1] + L[1],
          f[2] + L[2]
        );
      }
      h.push(
        E,
        b,
        E,
        b
      ), s.push(x, 0, x, 1), a.push(x, x), c.push(v, S, v, S), l.push(0, 0), this.parameters.vertexColors && d.push(
        M[0],
        M[1],
        M[2],
        M[3],
        M[0],
        M[1],
        M[2],
        M[3]
      );
    });
    this.parameters = e, this._granularity = e.granularity || CesiumMath.RADIANS_PER_DEGREE, this._needsUpdate = !1, this._needsCounter = !1, this._height = e.height || 0, this._isCurve = e.isCurve || !1, this._flags = {
      lastFlip: -1,
      started: !1,
      normal: null,
      totalDistance: 0
    };
  }
  setData(e) {
    if (this._needsUpdate = !0, this._isCurve && e.position.length > 0 && Array.isArray(e.position[0]) && Array.isArray(e.position[0][0]) && !Array.isArray(e.position[0][0][0]))
      for (let r = 0; r < e.position.length; r++) {
        const s = e.position[r];
        e.position[r] = getCurve(s, {
          isGlobe: this.engine.map.isGlobe
        });
      }
    this.cachedData = e, (this.parameters.dashed || this.parameters.enableAnimation || this.parameters.mapSrc || this.parameters.map) && (this._needsCounter = !0), this.updateGeometry(), this._needsUpdate = !1;
  }
  updateGeometryColumbus(e) {
    const r = [], s = [], a = [], c = [], l = [], h = [], d = [], f = [], p = [], m = [], y = [], x = [], v = [], S = [];
    let E = 0;
    for (let b = 0; b < e.position.length; b++) {
      const w = arrayRemoveDuplicates(e.position[b]), M = e.index[b], P = this.parameters.vertexWidths ? e.lineWidth[b] : this.parameters.lineWidth, D = this.parameters.vertexColors ? colorToArr4(e.color[b]) : [1, 1, 1, 1];
      this._flags = {
        lastFlip: -1,
        started: !1,
        normal: null,
        totalDistance: 0
      };
      const L = w.length;
      let O = r.length / 3, F = Math.random();
      y.push(F, F), a.push(0, 0), x.push(M, M);
      for (let k = 1; k < L; k++) {
        const V = w[k - 1], N = w[k], U = k < L - 1 ? w[k + 1] : null, z = this._segmentLines(
          r,
          s,
          h,
          d,
          m,
          l,
          p,
          f,
          c,
          V,
          N,
          U,
          P,
          D,
          v,
          S,
          O
        );
        z !== -1 && (O += z);
        for (let $ = 0; $ < z; $++)
          a.push(k / L), this._needsCounter && this.parameters.enableAnimationChaos && y.push(F), x.push(M);
        E = Math.max(this._flags.totalDistance, E);
      }
      if (this._needsCounter)
        for (let k = 0; k < m.length; k++)
          m[k] = E;
    }
    this.cachedPositions = r, this.cachedPrevs = v, this.cachedNexts = S, this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("prev", new Float32BufferAttribute(v, 3)), this.setAttribute("next", new Float32BufferAttribute(S, 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2)), this.setAttribute("normal", new Float32BufferAttribute(p, 3)), this.setAttribute("expandAndPrev", new Float32BufferAttribute(l, 2)), this.setAttribute("counter", new Float32BufferAttribute(a, 1)), this.setAttribute("objectIndex", new Float32BufferAttribute(x, 1)), this._needsCounter && (this.setAttribute("lengths", new Float32BufferAttribute(h, 1)), this.setAttribute("totalLength", new Float32BufferAttribute(m, 1)), this.setAttribute("prevAndNextLength", new Float32BufferAttribute(d, 2)), this.setAttribute("randomFactor", new Float32BufferAttribute(y, 1))), this.parameters.vertexColors && this.setAttribute("aColor", new Float32BufferAttribute(f, 4)), this.setIndex(c), this.computeBoundingSphere();
  }
  updateGeometry3D(e) {
    const r = [], s = [], a = [], c = [], l = [], h = [], d = [], f = [], p = [], m = [], y = [], x = [], v = this._granularity, S = this.engine.map.map.ellipsoid || Ellipsoid.WGS84, E = CesiumMath.chordLength(
      v,
      S.maximumRadius
    );
    let b = 0;
    const w = this.parameters.vertexColors;
    let M = 0;
    for (let D = 0, L = e.position.length; D < L; D++) {
      const O = [];
      let F = arrayRemoveDuplicates(e.position[D]);
      const k = e.index[D], V = this.parameters.vertexWidths ? e.lineWidth[D] : this.parameters.lineWidth, N = this.parameters.vertexColors ? colorToArr4(e.color[D]) : [1, 1, 1, 1], U = extractHeights$1(F, S).map((ee) => ee + this._height), {
        positions: z,
        normals: $,
        lengths: G,
        randoms: j,
        totalLength: Y,
        prevs: H,
        nexts: W,
        expandAndPrevs: q,
        prevAndNextLengths: Z,
        uvs: X
      } = this.generateArc({
        positions: F,
        indices: a,
        minDistance: E,
        ellipsoid: S,
        height: U,
        width: V,
        bevelIndices: O
      });
      M = Math.max(M, Y);
      const K = z.length / 3;
      for (let ee = 0; ee < K; ee += 4) {
        a.push(b + ee, b + ee + 1, b + ee + 2), a.push(b + ee + 2, b + ee + 1, b + ee + 3);
        const ie = ee + 4;
        O.includes(ie) && (a.push(b + ee + 2, b + ee + 3, b + ie), ee++);
      }
      b += K, r.push(...z), h.push(...$), m.push(...H), p.push(...W), s.push(...X), x.push(...Z), y.push(...q), f.push(...new Array(G.length).fill(k)), w && l.push(...new Array(G.length).fill(N).flat()), this._needsCounter && (c.push(...G), this.parameters.enableAnimationChaos && d.push(...j));
    }
    let P;
    this._needsCounter && (P = new Array(r.length / 3).fill(M)), this.cachedPositions = r, this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("prev", new Float32BufferAttribute(m, 3)), this.setAttribute("next", new Float32BufferAttribute(p, 3)), this.setAttribute("expandAndPrev", new Float32BufferAttribute(y, 2)), this.setAttribute("normal", new Float32BufferAttribute(h, 3)), this.setAttribute("objectIndex", new Float32BufferAttribute(f, 1)), this.setAttribute("uv", new Float32BufferAttribute(s, 2)), this.setAttribute("prevAndNextLength", new Float32BufferAttribute(x, 2)), w && this.setAttribute("aColor", new Float32BufferAttribute(l, 4)), this._needsCounter && this.setAttribute("totalLength", new Float32BufferAttribute(P, 1)), this.setIndex(a);
  }
  updateGeometry() {
    const e = this.cachedData;
    this.engine.map.isGlobe ? this.updateGeometry3D(e) : this.updateGeometryColumbus(e);
  }
  getFlatDirection(e, r) {
    return isPointEqual(e, r) ? this._flags.normal ? new Vector2$1(this._flags.normal.y, -this._flags.normal.x) : new Vector2$1(1, 0) : getDirection(e, r);
  }
  generateArc(e) {
    e || (e = {});
    const r = e.positions, s = e.indices, a = e.bevelIndices || [], c = r.length, l = e.ellipsoid || Ellipsoid.WGS84, h = e.width || 1;
    let d = e.height || 0;
    const f = Array.isArray(d);
    if (c < 1)
      return [];
    if (c === 1) {
      const X = l.scaleToGeodeticSurface(r[0], scaleFirst$1);
      if (d = f ? d[0] : d, d !== 0) {
        const K = l.geodeticSurfaceNormal(X, cartesian$1);
        Cartesian3.multiplyByScalar(K, d, K), Cartesian3.add(X, K, X);
      }
      return [X.x, X.y, X.z];
    }
    let p = e.minDistance;
    defined$2(p) || (p = CesiumMath.chordLength(this._granularity, l.maximumRadius));
    let m = 0;
    for (let X = 0; X < c - 1; X++)
      m += numberOfPoints$1(r[X], r[X + 1], p);
    const y = c - 2, x = m * 2 + y, v = x, S = x * 2, E = x * 3, b = new Array(E), w = new Array(E), M = new Array(v), P = new Array(v), D = new Array(E), L = new Array(E), O = new Array(S), F = new Array(S), k = new Array(S), V = new Array(v);
    let N = 0, U = 0;
    const z = new Vector3$1(), $ = new Vector3$1();
    let G;
    const j = {
      lastFlip: !1,
      curFlip: !1
    }, Y = {
      last: 0,
      next: 0
    }, H = new Vector3$1(), W = new Vector3$1();
    let q;
    for (let X = 0; X < c - 1; X++) {
      if (p0Scratch$1.fromArray(r[X]), p1Scratch$3.fromArray(r[X + 1]), z.crossVectors(p0Scratch$1, p1Scratch$3).normalize(), X < c - 2) {
        Ellipsoid.WGS84.geodeticSurfaceNormal(p1Scratch$3, H), p2Scratch$2.fromArray(r[X + 2]), $.crossVectors(p1Scratch$3, p2Scratch$2).normalize();
        const { isFlip: oe } = computeVertexMiterNormal(p0Scratch$1, p1Scratch$3, p2Scratch$2, H, W);
        q = W, j.curFlip = !oe;
      } else
        q = z;
      const K = G || z;
      Y.last = Math.min(h * 2, Math.abs(h / K.dot(z))), Y.next = Math.min(h * 2, Math.abs(h / q.dot(z)));
      const ee = f ? d[X] : d, ie = f ? d[X + 1] : d, re = X < c - 2, ne = this.generateCartesianArc(
        p0Scratch$1,
        p1Scratch$3,
        p,
        l,
        ee,
        ie,
        b,
        D,
        L,
        N,
        z,
        $,
        q,
        K,
        Y,
        j,
        w,
        h,
        M,
        O,
        U,
        re,
        a,
        F,
        V
      );
      N = ne.index;
      const J = ne.surfaceDistance;
      U += J, G || (G = lastMiterScratch), q && G.copy(q), j.lastFlip = j.curFlip;
    }
    const Z = Math.random();
    P.fill(Z);
    for (let X = 0; X < V.length; X++) {
      let K, ee, ie = X - 1;
      for (; ie >= 0 && V[ie] === V[X]; )
        ie--;
      let re = X + 1;
      for (; re < V.length && V[re] === V[X]; )
        re++;
      ie < 0 ? K = 0 : K = M[ie], re >= V.length ? ee = M[M.length - 1] : ee = M[re], k[X * 2] = K, k[X * 2 + 1] = ee;
    }
    return {
      positions: b,
      normals: w,
      lengths: M,
      randoms: P,
      totalLength: U,
      prevs: D,
      nexts: L,
      expandAndPrevs: O,
      prevAndNextLengths: k,
      uvs: F,
      indices: s
    };
  }
  generateCartesianArc(e, r, s, a, c, l, h, d, f, p, m, y, x, v, S, E, b, w, M, P, D, L, O, F, k) {
    const V = a.scaleToGeodeticSurface(e, scaleFirst$1), N = a.scaleToGeodeticSurface(r, scaleLast), U = numberOfPoints$1(e, r, s), z = a.cartesianToCartographic(V, carto1$1), $ = a.cartesianToCartographic(N, carto2), G = subdivideHeights$2(U, c, l), { lastFlip: j, curFlip: Y } = E;
    ellipsoidGeodesic.setEndPoints(z, $);
    const H = ellipsoidGeodesic.surfaceDistance / U;
    let W = p;
    z.z = c, $.z = l;
    const q = negativeNormalScratch.copy(m).negate(), Z = v ? negativeMiterScratch.copy(v).negate() : void 0, X = S.last, K = S.next;
    let ee = m, ie = q, re = w, ne = w;
    j ? (ie = Z, ne = X) : (ee = v || m, re = X);
    let J = W / 3, oe = a.cartographicToCartesian(z, cartesian$1);
    if (oe.toArray(h, W), ee.toArray(b, W), M[J] = D, F[J * 2] = D, F[J * 2 + 1] = 0, P[J * 2] = re, P[J * 2 + 1] = -1, k[J] = 1, W += 3, J = W / 3, oe.toArray(h, W), ie.toArray(b, W), P[J * 2] = ne, P[J * 2 + 1] = -1, M[J] = D, F[J * 2] = D, F[J * 2 + 1] = 1, k[J] = 1, W += 3, U > 1) {
      const ce = ellipsoidGeodesic.interpolateUsingSurfaceDistance(
        H,
        cartoNext
      );
      ce.z = G[1], a.cartographicToCartesian(ce, cartesian2);
    } else
      a.cartographicToCartesian($, cartesian2);
    cartesianOffset.subVectors(cartesian$1, cartesian2), cartesianOffset.add(cartesian$1), cartesianOffset.toArray(d, p), cartesianOffset.toArray(d, p + 3), cartesian2.toArray(f, p), cartesian2.toArray(f, p + 3);
    let _e;
    for (let ce = 1; ce < U; ce++)
      _e ? carto3.copy(cartoNext) : ellipsoidGeodesic.interpolateUsingSurfaceDistance(
        ce * H,
        carto3
      ), U === ce + 1 ? _e = $ : (_e = ellipsoidGeodesic.interpolateUsingSurfaceDistance(
        (ce + 1) * H,
        cartoNext
      ), _e.z = G[ce + 1]), carto3.z = G[ce], cartesianPrev.copy(cartesian$1), oe = a.cartographicToCartesian(carto3, cartesian$1), a.cartographicToCartesian(_e, cartesianNext), J = W / 3, oe.toArray(h, W), m.toArray(b, W), P[J * 2] = w, P[J * 2 + 1] = 1, cartesianPrev.toArray(d, W), cartesianNext.toArray(f, W), M[J] = D + ce * H, F[J * 2] = D + ce * H, F[J * 2 + 1] = 0, k[J] = -1, W += 3, J = W / 3, oe.toArray(h, W), q.toArray(b, W), P[J * 2] = w, P[J * 2 + 1] = 1, cartesianPrev.toArray(d, W), cartesianNext.toArray(f, W), M[J] = D + ce * H, F[J * 2] = D + ce * H, F[J * 2 + 1] = 1, k[J] = -1, W += 3, J = W / 3, oe.toArray(h, W), m.toArray(b, W), P[J * 2] = w, P[J * 2 + 1] = -1, cartesianPrev.toArray(d, W), cartesianNext.toArray(f, W), M[J] = D + ce * H, F[J * 2] = D + ce * H, F[J * 2 + 1] = 0, k[J] = 1, W += 3, J = W / 3, oe.toArray(h, W), q.toArray(b, W), P[J * 2] = w, P[J * 2 + 1] = -1, cartesianPrev.toArray(d, W), cartesianNext.toArray(f, W), M[J] = D + ce * H, F[J * 2] = D + ce * H, F[J * 2 + 1] = 1, k[J] = 1, W += 3;
    const le = ellipsoidGeodesic.surfaceDistance;
    a.cartographicToCartesian($, cartesian2), cartesianOffset.subVectors(cartesian2, cartesian$1), cartesianOffset.add(cartesian2);
    const de = x ? negativeMiterScratch.copy(x).negate() : void 0;
    return ee = m, ie = q, re = w, ne = w, L && (Y ? (ie = de || m, ne = K) : (ee = x || m, re = K)), J = W / 3, cartesian2.toArray(h, W), ee.toArray(b, W), M[J] = D + le, P[J * 2] = re, P[J * 2 + 1] = 1, F[J * 2] = D + le, F[J * 2 + 1] = 0, cartesian$1.toArray(d, W), cartesianOffset.toArray(f, W), k[J] = -1, W += 3, J = W / 3, cartesian2.toArray(h, W), ie.toArray(b, W), M[J] = D + le, P[J * 2] = ne, P[J * 2 + 1] = 1, cartesian$1.toArray(d, W), cartesianOffset.toArray(f, W), F[J * 2] = D + le, F[J * 2 + 1] = 1, k[J] = -1, W += 3, L && (J = W / 3, O.push(J), cartesian2.toArray(h, W), Y ? y.toArray(b, W) : negativeNormalScratch.copy(y).negate().toArray(b, W), M[J] = D + le, P[J * 2] = w, P[J * 2 + 1] = 1, F[J * 2] = D + le, F[J * 2 + 1] = 1, k[J] = -1, cartesian$1.toArray(d, W), cartesianOffset.toArray(f, W), W += 3), {
      index: W,
      surfaceDistance: le,
      lastLength: H
    };
  }
  _flipedUV(e, r, s, a) {
    a ? s === -1 ? e.push(r, 1, r, 0, r, 1, r, 0, r, 1) : e.push(r, 0, r, 1, r, 0, r, 1, r, 0) : s === -1 ? e.push(r, 1, r, 1, r, 1, r, 0, r, 0, r, 1) : e.push(r, 0, r, 0, r, 0, r, 1, r, 1, r, 0);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  get isCurve() {
    return this._isCurve;
  }
  set isCurve(e) {
    this._isCurve = e, this.needsUpdate = !0, this.engine.requestRender();
  }
}
const vertexShader$q = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec3 color;
#endif

attribute float totalLength;
attribute float lengths;
attribute float randomFactor;

#ifdef USE_PREV_NEXT
uniform float cameraNear;
uniform float cameraFar;
uniform mat4 viewportTransform;
uniform float fovX;
uniform float fovY;
attribute vec3 prev;
attribute vec3 next;
attribute vec2 expandAndPrev;
#else
attribute float aWidth;
#endif

#ifdef MVT_USE_EXTENT_CLIP
attribute vec2 extentVertex;
varying vec2 vExtentVertex;
#endif

uniform float elapsedTime;
uniform bool vertexColors;
uniform bool antialias;
uniform float antialiasFactor;
uniform float lineWidth;
uniform float height;
uniform float uZoomUnits;
uniform bool useZoomUnits;

varying vec2 vUV;
varying vec3 vNormal;
varying vec4 vColor;
varying float vAliasPart;
varying float vCounter;
varying float vLength;
varying float vTotalLength;
varying float vZoomUnits;
varying float vClippedLength;

#ifdef USE_ANIMATION
uniform float animationSpeed;
uniform float animationTailType;
uniform float animationTailRatio;
uniform float animationTailLength;
uniform float animationIdle;
varying float vAnimationOpacity;
#endif

#ifdef MVT_USE_VERTEX_DASHARRAY
attribute float aDashArray;
varying float vDashArray;
#endif

#ifdef MVT_USE_VERTEX_DASHRATIO
attribute float aDashRatio;
varying float vDashRatio;
uniform float useLength;
#endif

attribute vec2 prevAndNextLength;

#ifdef USE_DASH
varying vec2 vPrevAndNextLength;
#endif

float branchFreeTernary(bool comparison, float a, float b) {
    float useA = float(comparison);
    return a * useA + b * (1.0 - useA);
}

#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

#if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)
attribute float layerIndex;
varying float vLayerIndex;
#endif

#ifdef USE_PREV_NEXT

vec4 eyeToWindowCoordinates(vec4 positionEC) {
    vec4 q = projectionMatrix * positionEC;
    q.xyz /= q.w;
    q.xyz = (viewportTransform * vec4(q.xyz, 1.0)).xyz;

    return q;
}

void clipLineSegmentWithLengthToNearPlane(
    vec3 p0,
    vec3 p1,
    float l0,
    float l1,
    out vec4 positionWC,
    out bool clipped,
    out bool culledByNearPlane,
    out vec4 clippedPositionEC,
    out float clippedLength
)
{
    culledByNearPlane = false;
    clippedLength = l0;
    clipped = false;

    vec3 p0ToP1 = p1 - p0;
    float magnitude = length(p0ToP1);
    vec3 direction = normalize(p0ToP1);
    float lengthDistance = l1 - l0;

    float endPoint0Distance = cameraNear + p0.z;

    float denominator = -direction.z;

    if (endPoint0Distance > 0.0 && abs(denominator) < 0.0000001)
    {
        culledByNearPlane = true;
    }
    else if (endPoint0Distance > 0.0)
    {
        float t = endPoint0Distance / denominator;
        if (t < 0.0 || t > magnitude)
        {
            culledByNearPlane = true;
        }
        else
        {
            // Segment crosses the near plane, update p0 to lie exactly on it.
            p0 = p0 + t * direction;
            p0.z = min(p0.z, -cameraNear);

            l0 = mix(l0, l1, t / magnitude);

            // clippedLength = l0 + (t / ma)

            clipped = true;
        }
    }

    // \u89C6\u9525\u4F53\u53C2\u6570
    float tanHalfFovX = tan(fovX / 2.0 * 1.5);
    float tanHalfFovY = tan(fovY / 2.0 * 1.5);

    vec4 planes[4];
    planes[0] = vec4( 1,  0,  tanHalfFovX, 0); // Left
    planes[1] = vec4(-1,  0,  tanHalfFovX, 0); // Right
    planes[2] = vec4( 0,  1,  tanHalfFovY, 0); // Bottom
    planes[3] = vec4( 0, -1,  tanHalfFovY, 0); // Top

    vec3 p0Clone = p0;
    float lengthClone = l0;
    float mint = 10.0;
    for (int i = 0; i < 2; i++) {
        vec4 plane = planes[i];
        float d0 = dot(vec4(p0, 1.0), plane);
        float d1 = dot(vec4(p1, 1.0), plane);

        if (d0 > 0.0 && d1 > 0.0) {
            // \u7EBF\u6BB5\u5B8C\u5168\u5728\u8BE5\u88C1\u526A\u5E73\u9762\u5916\uFF0C\u5254\u9664
            culledByNearPlane = true;
        }
        else if (d0 > 0.0) {
            // p0 \u5728\u5916\uFF0Cp1 \u5728\u5185\uFF0C\u8BA1\u7B97\u4EA4\u70B9
            mint = min(mint, d0 / (d0 - d1));
            p0Clone = mix(p0, p1, mint);
            lengthClone = mix(l0, l1, mint);
            // clippedLength = l0 - (mint / lengthDistance);
            clipped = true;
        }
    }

    p0 = p0Clone;
    l0 = lengthClone;
    mint = 10.0;
    for (int i = 2; i < 4; i++) {
        vec4 plane = planes[i];
        float d0 = dot(vec4(p0, 1.0), plane);
        float d1 = dot(vec4(p1, 1.0), plane);

        if (d0 > 0.0 && d1 > 0.0) {
            // \u7EBF\u6BB5\u5B8C\u5168\u5728\u8BE5\u88C1\u526A\u5E73\u9762\u5916\uFF0C\u5254\u9664
            culledByNearPlane = true;
        }
        else if (d0 > 0.0) {
            // p0 \u5728\u5916\uFF0Cp1 \u5728\u5185\uFF0C\u8BA1\u7B97\u4EA4\u70B9
            mint = min(mint, d0 / (d0 - d1));
            p0Clone = mix(p0, p1, mint);
            lengthClone = mix(l0, l1, mint);
            // clippedLength = l0 + (mint * lengthDistance);
            // clippedLength = l0 - (mint / lengthDistance);
            clipped = true;
        }
    }

    p0 = p0Clone;
    clippedLength = lengthClone;

    clippedPositionEC = vec4(p0, 1.0);
    positionWC = eyeToWindowCoordinates(clippedPositionEC);

}

void clipLineSegmentToNearPlane(
    vec3 p0,
    vec3 p1,
    out vec4 positionWC,
    out bool clipped,
    out bool culledByNearPlane,
    out vec4 clippedPositionEC)
{
    culledByNearPlane = false;
    clipped = false;

    vec3 p0ToP1 = p1 - p0;
    float magnitude = length(p0ToP1);
    vec3 direction = normalize(p0ToP1);

    float endPoint0Distance = cameraNear + p0.z;

    float denominator = -direction.z;

    if (endPoint0Distance > 0.0 && abs(denominator) < 0.0000001)
    {
        culledByNearPlane = true;
    }
    else if (endPoint0Distance > 0.0)
    {
        float t = endPoint0Distance / denominator;
        if (t < 0.0 || t > magnitude)
        {
            culledByNearPlane = true;
        }
        else
        {
            // Segment crosses the near plane, update p0 to lie exactly on it.
            p0 = p0 + t * direction;
            p0.z = min(p0.z, -cameraNear);

            clipped = true;
        }
    }

    // \u89C6\u9525\u4F53\u53C2\u6570
    float tanHalfFovX = tan(fovX / 2.0 * 1.5);
    float tanHalfFovY = tan(fovY / 2.0 * 1.5);

    vec4 planes[4];
    planes[0] = vec4( 1,  0,  tanHalfFovX, 0); // Left
    planes[1] = vec4(-1,  0,  tanHalfFovX, 0); // Right
    planes[2] = vec4( 0,  1,  tanHalfFovY, 0); // Bottom
    planes[3] = vec4( 0, -1,  tanHalfFovY, 0); // Top

    vec3 p0Clone = p0;
    float mint = 10.0;
    for (int i = 0; i < 2; i++) {
        vec4 plane = planes[i];
        float d0 = dot(vec4(p0, 1.0), plane);
        float d1 = dot(vec4(p1, 1.0), plane);

        if (d0 > 0.0 && d1 > 0.0) {
            // \u7EBF\u6BB5\u5B8C\u5168\u5728\u8BE5\u88C1\u526A\u5E73\u9762\u5916\uFF0C\u5254\u9664
            culledByNearPlane = true;
        }
        else if (d0 > 0.0) {
            // p0 \u5728\u5916\uFF0Cp1 \u5728\u5185\uFF0C\u8BA1\u7B97\u4EA4\u70B9
            mint = min(mint, d0 / (d0 - d1));
            p0Clone = mix(p0, p1, mint);
            clipped = true;
        }
    }

    p0 = p0Clone;
    mint = 10.0;
    for (int i = 2; i < 4; i++) {
        vec4 plane = planes[i];
        float d0 = dot(vec4(p0, 1.0), plane);
        float d1 = dot(vec4(p1, 1.0), plane);

        if (d0 > 0.0 && d1 > 0.0) {
            // \u7EBF\u6BB5\u5B8C\u5168\u5728\u8BE5\u88C1\u526A\u5E73\u9762\u5916\uFF0C\u5254\u9664
            culledByNearPlane = true;
        }
        else if (d0 > 0.0) {
            // p0 \u5728\u5916\uFF0Cp1 \u5728\u5185\uFF0C\u8BA1\u7B97\u4EA4\u70B9
            mint = min(mint, d0 / (d0 - d1));
            p0Clone = mix(p0, p1, mint);
            clipped = true;
        }
    }

    p0 = p0Clone;

    clippedPositionEC = vec4(p0, 1.0);
    positionWC = eyeToWindowCoordinates(clippedPositionEC);

}

#endif

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = vec4(color, 1.0);
    #endif

    vUV = uv;
    // vCounter = counter;
    // vLength = uv.x;
    vTotalLength = totalLength;

    #ifdef MVT_USE_EXTENT_CLIP
    vExtentVertex = extentVertex;
    #endif

    #include <begin_vertex>

    #ifdef USE_PREV_NEXT
        float width = expandAndPrev.x;
        float pixelSize;
        vec4 worldPosition;
        if (keepSize) {
            vec4 prevEC = modelViewMatrix * vec4(prev, 1.0);
            vec4 nextEC = modelViewMatrix * vec4(next, 1.0);
            vec4 positionEC = modelViewMatrix * vec4(transformed, 1.0);

            bool usePrevious = expandAndPrev.y > 0.0;

            vec4 clippedPrevWC, clippedPrevEC;
            bool prevSegmentClipped, prevSegmentCulled;
            clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);

            vec4 clippedNextWC, clippedNextEC;
            bool nextSegmentClipped, nextSegmentCulled;
            clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);

            bool segmentClipped, segmentCulled;
            vec4 clippedPositionWC, clippedPositionEC;
            float clippedLength;
            clipLineSegmentWithLengthToNearPlane(
                positionEC.xyz,
                usePrevious ? prevEC.xyz : nextEC.xyz,
                uv.x,
                usePrevious ? prevAndNextLength.x : prevAndNextLength.y,
                clippedPositionWC,
                segmentClipped,
                segmentCulled,
                clippedPositionEC,
                clippedLength
            );

            vClippedLength = clippedLength;
            
            vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);
            vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);

            vec4 prevWorld = modelMatrix * vec4(prev, 1.0);
            vec4 nextWorld = modelMatrix * vec4(next, 1.0);
            vec2 directionToPrevWC1 = normalize(nextWorld.xy - prevWorld.xy);
            vec2 directionNormal = vec2(-directionToPrevWC1.y, directionToPrevWC1.x);
            worldPosition = inverse(viewMatrix) * (clippedPositionEC);
            pixelSize = getPixelSize(worldPosition.xyz);
        }
        else {
            worldPosition = modelMatrix * vec4(transformed, 1.0);
            pixelSize = getPixelSize(worldPosition.xyz);
            vClippedLength = uv.x;
        }
    #else 
        vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);
        float pixelSize = getPixelSize(worldPosition.xyz);
        float width = aWidth;

        #ifdef MVT_USE_VERTEX_DASHRATIO
            vClippedLength = lengths;
        #else
            vClippedLength = uv.x;
        #endif
    #endif

    // pixelSize\u4E0D\u5982\u7EDF\u4E00\u7684zoomUnits\u7684\u6548\u679C
    // vZoomUnits = branchFreeTernary(useZoomUnits, uZoomUnits, pixelSize);
    vZoomUnits = branchFreeTernary(useZoomUnits, uZoomUnits, zoomUnits);

    vec3 extrude = normal.xyz * width / 2.0;
    float pixelWidth = width;
    if (keepSize) {
        extrude *= pixelSize;
        pixelWidth *= pixelSize;
    }
    if (antialias) {
        // \u6297\u952F\u9F7F\u865A\u5316\u5BBD\u5EA6\u7684\u5355\u4F4D\u4E00\u5B9A\u662F\u50CF\u7D20\uFF0C\u7EBF\u4E24\u4FA7\u5404\u865A\u53160.5\u4E2A\u50CF\u7D20
        float aliasFeatureWidth = 0.5 * antialiasFactor * pixelSize;
        extrude += normal.xyz * aliasFeatureWidth;
        float halfWidth = pixelWidth / 2.0;
        vNormal = normalize(normal.xyz);
        vAliasPart = 1. - (2. * aliasFeatureWidth / (halfWidth + aliasFeatureWidth));
    }
    worldPosition.xyz += extrude;
    // worldPosition.z += height;

    #if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)
        vLayerIndex = layerIndex;
    #endif
    
    #ifdef USE_ANIMATION
        float tailLength = animationTailType == 1.0 ? vTotalLength * animationTailRatio : animationTailLength;

        #ifdef ANIMATION_CHAOS
            float currentTime = elapsedTime + randomFactor * 1000.0 * 3600.;
        #else
            float currentTime = elapsedTime;
        #endif
        float currentLength = mod(currentTime * animationSpeed, vTotalLength + tailLength + animationIdle * animationSpeed);
        vAnimationOpacity = (vClippedLength - (currentLength - tailLength)) / tailLength;
    #endif

    vec4 mvPosition = viewMatrix * worldPosition;
    gl_Position = projectionMatrix * mvPosition;

    #ifdef MVT_USE_VERTEX_DASHARRAY
    vDashArray = aDashArray;
    #endif

    #ifdef MVT_USE_VERTEX_DASHRATIO
    vDashRatio = aDashRatio;
    #endif

    #include <beginnormal_vertex>
    #include <fog_vertex>
    #include <logdepthbuf_vertex>
}`, fragmentShader$o = `#define GLSLIFY 1
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_depth_range_pars_fragment>

varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef MVT_USE_EXTENT_CLIP
varying vec2 vExtentVertex;
#endif

uniform sampler2D map;
uniform bool useMap;
uniform bool keepSize;
uniform bool antialias;
uniform float lineWidth;
uniform float mapGap;
uniform float opacity;
uniform float alphaTest;
uniform float elapsedTime;
uniform bool flipUv;
uniform bool isSingle;
uniform bool needRound;
uniform bool useMeterUnits;

varying vec2 vUV;
varying vec3 vNormal;
varying vec4 vColor;
varying float vAliasPart;
varying float vCounter;
varying float vLength;
varying float vTotalLength;
varying float vZoomUnits;

#ifdef USE_ANIMATION
uniform float animationInterval;
varying float vAnimationOpacity;
#endif

#ifdef USE_DASH
#ifdef MVT_USE_VERTEX_DASHARRAY
varying float vDashArray;
#else
uniform float dashArray;
#endif
uniform float dashOffset;
#ifdef MVT_USE_VERTEX_DASHRATIO
varying float vDashRatio;
#else
uniform float dashRatio;
#endif
uniform bool keepDashLength;
varying float vDashOpacity;
#endif

varying float vClippedLength;

vec2 branchFreeTernary(bool comparison, vec2 a, vec2 b) {
    float useA = float(comparison);
    return a * useA + b * (1.0 - useA);
}
void main() {

   vec4 c = vColor;

    #ifdef MVT_USE_EXTENT_CLIP
    if (vExtentVertex.x < 0.0 || vExtentVertex.x > 1.0 || vExtentVertex.y < 0.0 || vExtentVertex.y > 1.0) {
        discard;
    }
    #endif
 
    if(useMap) {
        // icon\u4E4B\u95F4\u7684\u95F4\u9694\uFF0C\u7ECF\u9A8C\u503C\u4E3A\u95F4\u969450\u500D\u5BBD\u5EA6\uFF0C\u6BD4\u8F83\u7A00\u758F\u4E14\u597D\u770B
        float margin = lineWidth * mapGap;
        float halfMargin = margin / 2.0;
        float texWidth = lineWidth;
        if (keepSize && !useMeterUnits) {
            margin *= vZoomUnits;
            texWidth *= vZoomUnits;
        }
        if (needRound && vClippedLength > (texWidth + margin)) {
            discard;
        }
        float delta = mod(vClippedLength, texWidth + margin);
        float uvx;
        if (isSingle) {
            uvx = vClippedLength / vTotalLength;
        }
        else {
            uvx = (delta - halfMargin) / texWidth;
        }
        if (delta >= halfMargin && delta <= halfMargin + texWidth) {
            vec2 uv = branchFreeTernary(flipUv, vec2(vUV.y, uvx), vec2(uvx, vUV.y));
            vec4 texture = texture2D(map, uv);
            // c = texture.a >= 0.5 ? texture : c;
            c = texture;
        }
    }

    #ifdef USE_ANIMATION
        float animationAlpha = vAnimationOpacity;
        if (animationInterval > 0.0) {
            animationAlpha = mod(vAnimationOpacity, animationInterval);
        }
        if (animationAlpha > 1.0 || animationAlpha < 0.0) {
            discard;
        }
        c.a *= animationAlpha;
    #endif

    #ifdef USE_DASH
        #ifdef MVT_USE_VERTEX_DASHARRAY
        float darray = vDashArray;
        #else
        float darray = dashArray;
        #endif

        #ifdef MVT_USE_VERTEX_DASHRATIO
        float dratio = vDashRatio;
        #else
        float dratio = dashRatio;
        #endif
        if (keepSize && keepDashLength) {
            darray *= vZoomUnits;
        }
        c.a *= step(mod(vClippedLength + dashOffset, darray), (darray * dratio));
    #endif

    if (c.a < alphaTest) {
        discard;
    }

    // \u6297\u952F\u9F7F make line edge antialias
    if (antialias) {
        float blur = 1.0;
        // blur = 1.0 - smoothstep(vAliasPart, 1.0, length(vNormal));
        blur = 1.0 - (length(vNormal) - vAliasPart) / (1.0 - vAliasPart);
        blur = clamp(blur, 0.0, 1.0);
        c.a *= blur;
    }

    gl_FragColor = c;

    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
    #include <mvt_depth_range_fragment>
}`, textureLoader$9 = new TextureLoader(), uniforms$p = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  emissiveUniforms,
  {
    antialias: { value: !1 },
    antialiasFactor: { value: 1 },
    lineWidth: { value: 100 },
    keepSize: { value: !1 },
    map: { value: null },
    useMap: { value: !1 },
    mapGap: { value: 50 },
    color: { value: [0, 1, 1] },
    height: { value: 0 },
    opacity: { value: 1 },
    resolution: { value: new Vector2$1(1, 1) },
    sizeAttenuation: { value: 1 },
    dashArray: { value: 20 },
    dashOffset: { value: 0 },
    dashRatio: { value: 0.5 },
    alphaTest: { value: 0 },
    repeat: { value: new Vector2$1(1, 1) },
    vertexColors: { value: !1 },
    vertexZIndexLegacy: { value: !1 },
    vertexZIndex: { value: !1 },
    elapsedTime: { value: 0 },
    enableAnimation: { value: !1 },
    enableAnimationChaos: { value: !1 },
    animationInterval: { value: 0 },
    animationSpeed: { value: 1 },
    animationTailType: { value: 1 },
    animationTailRatio: { value: 0.2 },
    animationTailLength: { value: 100 },
    animationIdle: { value: 1e3 },
    isEmissive: { value: !1 },
    keepDashLength: { value: !0 },
    depthRange: { value: new Vector2$1(0, 1) },
    viewportTransform: { value: new Matrix4() },
    cameraNear: { value: 0 },
    cameraFar: { value: 0 },
    fovX: { value: 0 },
    fovY: { value: 0 },
    uZoomUnits: { value: 1 },
    flipUv: { value: !1 },
    useZoomUnits: { value: !1 },
    useLength: { value: !1 },
    isSingle: { value: !1 },
    needRound: { value: !1 },
    useMeterUnits: { value: !1 }
  }
]);
class FatLineMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "FatLineMaterial", this.isFatLineMaterial = !0, this.fog = !0, this.fragmentShader = fragmentShader$o, this.vertexShader = vertexShader$q, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$p)), defineMaterialNormalProperties(this, [
      "antialias",
      "mapGap",
      "isSingle",
      "flipUv",
      "lineWidth",
      "keepSize",
      "height",
      "opacity",
      "dashArray",
      "dashOffset",
      "dashRatio",
      "alphaTest",
      "animationInterval",
      "animationSpeed",
      "animationTailType",
      "animationTailRatio",
      "animationTailLength",
      "animationIdle",
      "isEmissive",
      "keepDashLength",
      "depthRange",
      "antialiasFactor",
      "useLength",
      "needRound",
      "useMeterUnits"
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexZIndexLegacy", "MVT_USE_VERTEX_ZINDEX_LEGACY"],
      ["vertexZIndex", "MVT_USE_VERTEX_ZINDEX"],
      ["enableAnimation", "USE_ANIMATION"],
      ["enableAnimationChaos", "ANIMATION_CHAOS"],
      ["dashed", "USE_DASH"],
      ["enableDepthRange", "MVT_USE_DEPTH_RANGE"],
      ["enableExtentClip", "MVT_USE_EXTENT_CLIP"],
      ["vertexDashArray", "MVT_USE_VERTEX_DASHARRAY"],
      ["vertexDashRatio", "MVT_USE_VERTEX_DASHRATIO"],
      ["enablePrevAndNext", "USE_PREV_NEXT"]
    ]), defineMaterialEmissiveProperties(this), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const r = this.mapSrc, s = "url_map";
          if (this.userData[s] === e)
            return;
          if (r && r.dispose(), !e) {
            this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[s];
            return;
          }
          const c = textureLoader$9.load(e);
          c.wrapS = c.wrapT = ClampToEdgeWrapping, this.uniforms.map.value = c, this.userData[s] = e, this.uniforms.useMap.value = !0;
        }
      },
      map: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const r = this.map;
          if (!e) {
            r.dispose(), this.uniforms.map.value = null, this.uniforms.useMap.value = !1;
            return;
          }
          this.uniforms.map.value = e, this.uniforms.useMap.value = !0;
        }
      },
      zoomUnits: {
        get: function() {
          return this.uniforms.uZoomUnits.value;
        },
        set: function(e) {
          this.uniforms.uZoomUnits.value = e, this.uniforms.useZoomUnits.value = !0;
        }
      }
    }), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(i);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
new Vector3$1();
new Vector3$1();
const _inverseMatrix = new Matrix4(), _ray$1 = new Ray(), _sphere$2 = new Sphere(), _viewportTransform = new Matrix4();
class FatLineInternal extends GeoMesh {
  constructor(e) {
    super();
    _(this, "isEventEntitySupported", !0);
    _(this, "_resolution", new Vector2$1());
    _(this, "geometry");
    _(this, "material");
    _(this, "lineJoin");
    _(this, "lineCap");
    _(this, "miterLimit");
    _(this, "keepSize");
    _(this, "color");
    _(this, "vertexColors");
    _(this, "mapSrc");
    _(this, "opacity");
    _(this, "alphaTest");
    _(this, "dashed");
    _(this, "dashArray");
    _(this, "dashOffset");
    _(this, "dashRatio");
    _(this, "enableAnimation");
    _(this, "enableAnimationChaos");
    _(this, "animationSpeed");
    _(this, "animationTailType");
    _(this, "animationTailRatio");
    _(this, "animationTailLength");
    _(this, "animationIdle");
    _(this, "makeGeometryOffsetPosition", (e) => {
      if (!this._enableRtc)
        return;
      const r = e.boundingSphere && e.boundingSphere.center;
      if (!r) {
        this._cachedRtc = [0, 0, 0], this.updateTransform();
        return;
      }
      const { x: s, y: a, z: c } = r, l = e.cachedPositions, h = e.cachedPrevs, d = e.cachedNexts;
      this.makePostionArrayOffset(e.attributes.position.array, s, a, c, l), e.attributes.prev && this.makePostionArrayOffset(e.attributes.prev.array, s, a, c, h), e.attributes.next && this.makePostionArrayOffset(e.attributes.next.array, s, a, c, d), this.geometry.computeBoundingSphere(), this._cachedRtc = [s, a, c], this.updateTransform();
    });
    this.parameters = e, this.raycastBuffer = this.parameters.raycastBuffer || 0, this.parameters.lineJoin = this.parameters.lineJoin || "bevel", this.defineGeometryProxyProperties([
      "lineJoin",
      "lineCap",
      "miterLimit",
      "isCurve"
    ]), this.defineMaterialProxyProperties([
      "antialias",
      "map",
      "mapSrc",
      "mapGap",
      "height",
      "keepSize",
      "transparent",
      "opacity",
      "alphaTest",
      "dashed",
      "dashArray",
      "dashOffset",
      "dashRatio",
      "enableAnimation",
      "enableAnimationChaos",
      "animationInterval",
      "animationSpeed",
      "animationTailType",
      "animationTailRatio",
      "animationTailLength",
      "animationIdle",
      "color",
      "vertexColors",
      "vertexWidths",
      "emissive",
      "keepDashLength",
      "needRound",
      "useMeterUnits"
    ]);
  }
  getDefaultParams() {
    return {
      lineWidth: 4
    };
  }
  initObject() {
    const { lineJoin: e, lineCap: r, isCurve: s, flat: a, ...c } = this.parameters, l = this.geometry = new FatLineGeometry(this.parameters);
    l.engine = this.engine, c.enablePrevAndNext = !0, (this.material = new FatLineMaterial(c)).setCommonUniforms(this.engine.rendering.uniforms);
  }
  _updateData() {
    const e = this.dataSource.data;
    this.geometry.setData(e), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), this.makeGeometryOffsetPosition(this.geometry), this.needsUpdate = !1;
  }
  afterGeometryUpdate() {
    this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox();
  }
  computeViewportTransformation(e, r, s, a) {
    const c = e.x || 0, l = e.y || 0, h = e.width || 0, d = e.height || 0;
    r = r || 0, s = s || 1;
    const f = h * 0.5, p = d * 0.5, m = (s - r) * 0.5, y = f, x = p, v = m, S = c + f, E = l + p, b = r + m, w = 1, M = a.elements;
    return M[0] = y, M[1] = 0, M[2] = 0, M[3] = 0, M[4] = 0, M[5] = x, M[6] = 0, M[7] = 0, M[8] = 0, M[9] = 0, M[10] = v, M[11] = 0, M[12] = S, M[13] = E, M[14] = b, M[15] = w, a;
  }
  onBeforeScenePrepareRenderHook() {
    const { x: e, y: r } = this.engine.rendering.uniforms.resolution.value;
    (this._resolution.x !== e || this._resolution.y !== r) && (this.material.uniforms.viewportTransform.value.copy(this.computeViewportTransformation({
      width: this.engine.rendering.uniforms.resolution.value.x,
      height: this.engine.rendering.uniforms.resolution.value.y
    }, 0, 1, _viewportTransform)), this._resolution.set(e, r)), this.material.uniforms.cameraNear.value = this.engine.camera.near, this.material.uniforms.cameraFar.value = this.engine.camera.far, this.material.uniforms.fovY.value = this.engine.camera.fov / 180 * Math.PI, this.material.uniforms.fovX.value = this.material.uniforms.fovY.value * this.engine.camera.aspect;
  }
  get lineWidth() {
    return this.parameters.lineWidth;
  }
  set lineWidth(e) {
    this.parameters.lineWidth = e, this.needsUpdate = !0, this.engine.requestRender();
  }
  raycast(e, r) {
    if (!this.visible)
      return;
    const s = this.geometry, a = this.matrixWorld, c = e.params.Line.threshold, l = s.drawRange;
    let h = this.lineWidth / 2 + this.raycastBuffer;
    if (this.material.keepSize && (h *= this.material.uniforms.zoomUnits.value), s.boundingSphere === null && s.computeBoundingSphere(), _sphere$2.copy(s.boundingSphere), _sphere$2.applyMatrix4(a), _sphere$2.radius += h, e.ray.intersectsSphere(_sphere$2) === !1)
      return;
    _inverseMatrix.copy(a).invert(), _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix);
    const d = h / ((this.scale.x + this.scale.y + this.scale.z) / 3), f = d * d, p = new Vector3$1(), m = new Vector3$1(), y = new Vector3$1(), x = new Vector3$1(), v = 2;
    if (s.isBufferGeometry) {
      const S = s.index, E = s.attributes, b = E.position, w = E.objectIndex;
      if (S !== null) {
        const M = Math.max(0, l.start), P = Math.min(S.count, l.start + l.count);
        for (let D = M, L = P - 1; D < L; D += v) {
          const O = S.getX(D), F = S.getX(D + 1);
          if (p.fromBufferAttribute(b, O), m.fromBufferAttribute(b, F), _ray$1.distanceSqToSegment(p, m, x, y) > f)
            continue;
          x.applyMatrix4(this.matrixWorld);
          const V = e.ray.origin.distanceTo(x);
          if (V < e.near || V > e.far)
            continue;
          const N = w.getX(O), U = w.getX(F);
          N === U && r.push({
            distance: V,
            point: y.clone().applyMatrix4(this.matrixWorld),
            index: N,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const M = Math.max(0, l.start), P = Math.min(b.count, l.start + l.count);
        for (let D = M, L = P - 1; D < L; D += v) {
          if (p.fromBufferAttribute(b, D), m.fromBufferAttribute(b, D + 1), _ray$1.distanceSqToSegment(p, m, x, y) > f)
            continue;
          x.applyMatrix4(this.matrixWorld);
          const F = e.ray.origin.distanceTo(x);
          F < e.near || F > e.far || r.push({
            distance: F,
            point: y.clone().applyMatrix4(this.matrixWorld),
            index: D,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    }
    e.params.Line.threshold = c;
  }
}
class Polyline extends Group {
  constructor(e = {}) {
    super();
    _(this, "_object");
    e.flat ? this._object = new FatLineInternal(e) : this._object = new PolylineInternal(e);
    const s = new Proxy(this, {
      get: (a, c, l) => {
        if (c in a)
          return Reflect.get(a, c, l);
        const h = Reflect.get(this._object, c, l);
        return typeof h == "function" ? h.bind(this._object) : h;
      },
      set: (a, c, l, h) => c in a ? Reflect.set(a, c, l, h) : Reflect.set(this._object, c, l, h)
    });
    return s.add(this._object), s;
  }
}
class GeoPoints extends GeoObject {
  constructor() {
    super(...arguments);
    _(this, "isPoints", !0);
    _(this, "isEventEntitySupported", !0);
  }
  get size() {
    return this.material.size;
  }
  set size(e) {
    this.material.size = e;
  }
  raycast(e, r) {
    if (!this.visible)
      return;
    const s = e.params.Points.threshold;
    let a = s * this.size;
    this.material.uniforms.zoomUnits && (a *= this.material.uniforms.zoomUnits.value), e.params.Points.threshold = a / 2, Points.prototype.raycast.call(this, e, r), e.params.Points.threshold = s;
  }
  getEntityByIndex(e) {
    const r = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const s = {
      value: r.getDataItem(e),
      itemIndex: r.getDataItemIndex(e),
      pairs: {}
    }, a = r.data;
    for (const c of Object.keys(a))
      s.pairs[c] = a[c][e], s[c] = a[c][e];
    return s;
  }
}
class SimplePointGeometry extends BufferGeometry {
  constructor(i) {
    super(i), this.parameters = i;
  }
  setData(i) {
    const { vertexSizes: e, vertexColors: r } = this.parameters, { aPositions: s, aObjectIndices: a, aMapIndexs: c, aColors: l, aSizes: h } = i;
    this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("objectIndex", new Float32BufferAttribute(a, 1)), this.setAttribute("aMapIndex", new Float32BufferAttribute(c, 1)), r && this.setAttribute("aColor", new Float32BufferAttribute(l, 4)), e && this.setAttribute("aSize", new Float32BufferAttribute(h, 1));
  }
}
const vertexShader$p = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_SIZE
    attribute float aSize;
    varying float vSize;
#endif

#ifdef MVT_USE_VERTEX_OFFSET
    attribute vec2 aOffset;
#else
    uniform vec2 uOffset;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
    varying vec4 vColor;
#endif

uniform float size;
uniform float pixelRatio;
uniform vec2 resolution;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 
    #include <mvt_selective_vertex>

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);

    #ifdef MVT_USE_VERTEX_OFFSET
        vec2 offset = aOffset * 2. * pixelRatio * pixelSize;
    #else
        vec2 offset = uOffset * 2. * pixelRatio * pixelSize;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.xy = gl_Position.xy - offset;

    #ifdef MVT_USE_VERTEX_SIZE
        vSize = aSize * pixelRatio;
        gl_PointSize = vSize;
    #else
        gl_PointSize = size * pixelRatio;
    #endif

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #endif

    #include <logdepthbuf_vertex>
}`, fragmentShader$n = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif
uniform float uShapeType;
uniform float opacity;

#ifdef MVT_USE_VERTEX_SIZE
    varying float vSize;
#else
    uniform float size;
#endif
uniform bool useMap;
uniform sampler2D map;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        gl_FragColor = vColor;
    #else
        gl_FragColor = vec4(color, 1.0);
    #endif

    if (uShapeType == 2.) {
        float d = distance(gl_PointCoord, vec2(0.5, 0.5));
        #ifdef MVT_USE_VERTEX_SIZE
            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);
        #else
            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);
        #endif
        
        if (alpha <= 0.) {
            discard;
        } else {
            gl_FragColor.a *= alpha;
        }
    }
 
    if (useMap) {
        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);
     //    gl_FragColor.a += tColor.a;
        
        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);
        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);
        // gl_FragColor.a += tColor.a;
        // gl_FragColor = tColor;
    }

    if (gl_FragColor.a <= 0.) {
        discard;
    }

    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}`, textureLoader$8 = new TextureLoader(), uniforms$o = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  emissiveUniforms,
  {
    isEmissive: { value: !1 },
    color: { value: [1, 1, 0] },
    size: { value: 30 },
    vertexColors: { value: !1 },
    vertexSizes: { value: !1 },
    uShapeType: { value: 2 },
    opacity: { value: 1 },
    map: { value: null },
    useMap: { value: !1 },
    uOffset: { value: [0, 0] }
  }
]);
class SimplePointMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "SimplePointMaterial", this.vertexShader = vertexShader$p, this.fragmentShader = fragmentShader$n, this.isSimplePointMaterial = !0, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$o)), defineMaterialSelectiveProperties(this), defineMaterialNormalProperties(this, [
      "size",
      "uShapeType",
      "opacity",
      "isEmissive"
    ]), defineMaterialAliasProperties(this, [
      ["offset", "uOffset"]
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexSizes", "MVT_USE_VERTEX_SIZE"]
    ]), defineMaterialEmissiveProperties(this), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const r = this.mapSrc, s = "url_map";
          if (this.userData[s] === e)
            return;
          if (r && r.dispose(), !e) {
            this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[s];
            return;
          }
          const c = textureLoader$8.load(e);
          c.wrapS = c.wrapT = ClampToEdgeWrapping, this.uniforms.map.value = c, this.userData[s] = e, this.uniforms.useMap.value = !0;
        }
      }
    }), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(i);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
class SimplePoint extends GeoPoints {
  constructor(e) {
    super(e);
    _(this, "geometry");
    _(this, "material");
    _(this, "color");
    _(this, "vertexColors");
    _(this, "size");
    _(this, "vertexSizes");
    _(this, "opacity");
    this.parameters = e, this.defineMaterialProxyProperties([
      "size",
      "uShapeType",
      "opacity",
      "emissive",
      "vertexColors",
      "vertexSizes",
      "color",
      "mapSrc"
    ]), this.defineMaterialUpdateProxyProperties([
      "transparent"
    ]);
  }
  collisionTest(e) {
    return this.parameters.vertexSizes && e.size ? {
      width: e.size,
      height: e.size
    } : {
      width: this.size,
      height: this.size
    };
  }
  initObject() {
    this.geometry = new SimplePointGeometry(this.parameters), this.material = new SimplePointMaterial(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  _updateData() {
    const e = this.dataSource.data, { vertexSizes: r, vertexColors: s } = this.parameters;
    let a = [];
    this._enableCollision && this._collisionData ? a = this._collisionData : a = this.dataSource.userData;
    const c = [], l = [], h = [], d = [];
    for (let f = 0; f < a.length; f++) {
      const p = a[f].position, m = a[f].index;
      if (c.push(...p), l.push(m), s && e.color) {
        let y = colorToArr4(a[f].color);
        h.push(y[0], y[1], y[2], y[3]);
      }
      r && e.size && d.push(a[f].size);
    }
    this.geometry.setData({
      aPositions: c,
      aObjectIndices: l,
      aColors: h,
      aSizes: d
    }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, c), this.needsUpdate = !1;
  }
}
const et = class extends DataSource {
  constructor(i) {
    super(i), this.type = "GeoJSONDataSource";
  }
  async _convertStreamingDataToObjectData(i) {
    return await i.json();
  }
  _parseObjectDataToDataItems(i) {
    let e = null, r = null;
    Array.isArray(i) ? e = i : Array.isArray(i.features) || i.type === "FeatureCollection" ? (e = i.features, r = i.properties) : i.type === "Feature" && (e = [i]);
    const s = [];
    for (let a = 0; a < e.length; a++)
      s.push(new DataItem(e[a], r));
    return s;
  }
};
let GeoJSONDataSource = et;
_(GeoJSONDataSource, "fromGeoJSON", function(i, e) {
  typeof i == "string" && console.error("It seems that you are trying to pass a URL to GeoJSONDataSource.fromGeoJSON, please use GeoJSONDataSource.fromURL instead.");
  let r = new et(e);
  return r.setData(i), r;
}), _(GeoJSONDataSource, "fromURL", async function(i, e) {
  let r = new et(e);
  return await r.load(i), r;
}), _(GeoJSONDataSource, "fromGeoJSONObject", function(i, e) {
  return console.warn("GeoJSONDataSource.fromGeoJSONObject is deprecated, please use GeoJSONDataSource.fromGeoJSON instead."), et.fromGeoJSON(i, e);
}), _(GeoJSONDataSource, "fromObject", function(i, e) {
  return console.warn("GeoJSONDataSource.fromObject is deprecated, please use GeoJSONDataSource.fromGeoJSON instead."), et.fromGeoJSON(i, e);
});
const SDF_FONT_SIZE = 24, SDF_BUFFER = 3, SDF_RADIUS = 8;
class ScreenText extends GeoMesh {
  constructor(e = {}) {
    super();
    _(this, "engine");
    _(this, "parameters");
    _(this, "fontAtlasManager");
    _(this, "atlasTexture");
    this.parameters = {
      fontSize: 26,
      fontFamily: "sans-serif",
      fontWeight: "400",
      color: "#ffffff",
      opacity: 1,
      strokeWidth: 0,
      strokeColor: "#000000",
      keepUpright: !0,
      textMaxAngle: 45,
      clippingBuffer: 256,
      debug: !1,
      ...e
    }, this.frustumCulled = !1, this.matrixAutoUpdate = !1, this.renderOrder = 999, this.FlipState = {
      unknown: 0,
      flipRequired: 1,
      flipNotRequired: 2
    }, this._flipStates = /* @__PURE__ */ new Map(), this._textsAlongLinesData = [], this._tempMatrix4 = new Matrix4(), this._tempVector2 = new Vector2$1(), this._tempVector4 = new Vector4(), this._tempVector4_2 = new Vector4(), this._measureCanvas = document.createElement("canvas"), this._measureCanvas.width = this._measureCanvas.height = 1, this._measureCtx = this._measureCanvas.getContext("2d"), this._emptyFrameCount = 0, this._emptyFrameThreshold = 3, this._placeTextCache = /* @__PURE__ */ new Map(), this._shapeCache = new LRUCache$1({ max: 500 }), this._debugPolyline = null, this._debugNormalPoints = null, this._debugAnchorPoints = null;
  }
  initObject() {
    this.geometry = new ScreenTextGeometry(this.parameters), this.material = new ScreenTextMaterial(this.parameters), this._initFontAtlas(), this._defineProxyProperties([
      "color",
      "opacity"
    ]);
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e), this._updateResolution(), this.parameters.debug && this._initDebugObjects();
  }
  _initDebugObjects() {
    !this.engine || this.parameters.debug && (this._debugPolyline = new Polyline({
      color: "#ff0000",
      opacity: 0.6,
      linewidth: 2
    }), this.engine.add(this._debugPolyline), this._debugNormalPoints = new SimplePoint({
      color: "#00ff00",
      size: 6
    }), this.engine.add(this._debugNormalPoints), this._debugAnchorPoints = new SimplePoint({
      color: "#ff0000",
      size: 12
    }), this.engine.add(this._debugAnchorPoints));
  }
  collisionTest(e) {
    const { text: r, linePoints: s, position: a } = e;
    if (!r || !s || !a)
      return null;
    const c = {
      id: e.id,
      text: r,
      line: s,
      anchor: a,
      anchorIndex: e.anchorIndex,
      textFillStyle: e.textFillStyle,
      textSize: e.textSize,
      textStrokeStyle: e.textStrokeStyle,
      textStrokeWidth: e.textStrokeWidth
    };
    let l = this._placeTextCache.get(e.id);
    return l || (l = this._placeTextAlongLine(c, !0), e.id && this._placeTextCache.set(e.id, l || [])), !l || l.length === 0 ? null : {
      chars: l,
      isProjected: !0,
      tolerance: e.tolerance || 0,
      width: 100,
      height: 100
    };
  }
  _updateResolution() {
    this.engine && this.engine.renderer && this.material && (this.engine.renderer.getSize(this._tempVector2), this.material.uniforms.resolution.value.set(this._tempVector2.x, this._tempVector2.y), this.material.uniforms.pixelRatio.value = this.engine.renderer.getPixelRatio());
  }
  _initFontAtlas() {
    this.fontAtlasManager = new FontAtlasManager();
    const e = this.parameters.fontWeight || "400", r = this.parameters.fontFamily || "sans-serif", s = {
      buffer: SDF_BUFFER,
      radius: SDF_RADIUS,
      fontSize: SDF_FONT_SIZE
    };
    this.fontAtlasManager.setProps({
      fontFamily: r,
      fontWeight: e,
      characterSet: [],
      sdf: !0,
      ...s
    }), this.atlasTexture = new DataTexture(
      new Uint8Array(512 * 512),
      512,
      512,
      RedFormat
    ), this.atlasTexture.wrapS = this.atlasTexture.wrapT = ClampToEdgeWrapping, this.atlasTexture.minFilter = this.atlasTexture.magFilter = LinearFilter, this.atlasTexture.generateMipmaps = !1, this.atlasTexture.needsUpdate = !0, this.material.uniforms.textMap.value = this.atlasTexture;
  }
  _defineProxyProperties(e) {
    e.forEach((r) => {
      Object.defineProperty(this, r, {
        get: function() {
          return this.material ? this.material[r] : void 0;
        },
        set: function(s) {
          this.material && (this.material[r] = s);
        }
      });
    });
  }
  setTexts(e) {
    if (!this.geometry)
      return;
    if (this._updateResolution(), !e || e.length === 0) {
      this._emptyFrameCount++, this._emptyFrameCount >= this._emptyFrameThreshold && (this.geometry.setData([], {}), this._lastCharCount = 0);
      return;
    }
    this._emptyFrameCount = 0, this._lastCharCount = e.length;
    const r = /* @__PURE__ */ new Set();
    for (const d of e)
      d.char && r.add(d.char);
    r.size > 0 && this._updateFontAtlas([...r]);
    const s = {}, a = this.fontAtlasManager.mapping, c = this.fontAtlasManager.atlas, l = this.parameters.fontFamily || "sans-serif", h = this.parameters.fontWeight || "400";
    if (a && c) {
      const d = c.width, f = c.height;
      for (const p of r) {
        const m = p + h + l, y = a[m];
        if (y) {
          const x = y.x, v = y.y;
          let S = y.width;
          const E = y.height;
          S += SDF_BUFFER * 2;
          const b = x / d, w = v / f, M = b + S / d, P = w + E / f;
          s[p] = {
            startU: b,
            startV: P,
            endU: M,
            endV: w
          };
        }
      }
    }
    this.geometry.setData(e, s);
  }
  _updateFontAtlas(e) {
    const r = this.parameters.fontWeight || "400", s = this.parameters.fontFamily || "sans-serif", a = {
      buffer: SDF_BUFFER,
      radius: SDF_RADIUS,
      fontSize: SDF_FONT_SIZE
    }, c = Array.from(e).map((h) => ({
      char: h,
      fontWeight: r
    }));
    this.fontAtlasManager.setProps({
      fontFamily: s,
      fontWeight: r,
      characterSet: c,
      sdf: !0,
      ...a
    });
    const l = this.fontAtlasManager.atlas;
    if (l && l.textureData) {
      const h = this.fontAtlasManager.atlas;
      !this.atlasTexture || this.atlasTexture.image.width !== h.width || this.atlasTexture.image.height !== h.height ? (this.atlasTexture && this.atlasTexture.dispose(), this.atlasTexture = new DataTexture(
        h.textureData,
        h.width,
        h.height,
        RedFormat
      ), this.atlasTexture.wrapS = this.atlasTexture.wrapT = ClampToEdgeWrapping, this.atlasTexture.minFilter = this.atlasTexture.magFilter = LinearFilter, this.atlasTexture.generateMipmaps = !1, this.atlasTexture.needsUpdate = !0) : (this.atlasTexture.image.data.set(h.textureData), this.atlasTexture.needsUpdate = !0), this.material.uniforms.textMap.value = this.atlasTexture;
    }
  }
  setTextAlongLine(e, r, s) {
    this.setTextsAlongLines([{ text: e, line: r, anchor: s }]);
  }
  setTextsAlongLines(e) {
    if (!this.engine) {
      console.error("\u274C ScreenText \u672A\u6DFB\u52A0\u5230\u5F15\u64CE\uFF0C\u65E0\u6CD5\u8BA1\u7B97\u5C4F\u5E55\u5750\u6807");
      return;
    }
    this._textsAlongLinesData = e.map((r, s) => ({
      ...r,
      id: r.id || `text_${s}_${r.text}`
    }));
  }
  onBeforeScenePrepareRenderHook(e, r, s) {
    if (this._updateResolution(), this._textsAlongLinesData && this._textsAlongLinesData.length > 0)
      try {
        this._updateTextsAlongLines(this._textsAlongLinesData);
      } catch (a) {
        console.error("\u6CBF\u7EBF\u6587\u5B57\u66F4\u65B0\u5931\u8D25:", a);
      }
  }
  _updateTextsAlongLines(e) {
    const r = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      let c;
      a.id && this._placeTextCache.has(a.id) ? c = this._placeTextCache.get(a.id) : c = this._placeTextAlongLine(a, s), c && c.length > 0 && r.push(...c);
    }
    this._placeTextCache.clear(), this.setTexts(r);
  }
  _placeTextAlongLine(e) {
    const {
      text: r,
      line: s,
      anchor: a,
      anchorIndex: c,
      id: l,
      textFillStyle: h,
      textSize: d,
      textStrokeStyle: f,
      textStrokeWidth: p
    } = e, m = l || r, y = !this._initializedGroups || !this._initializedGroups.has(m);
    this._initializedGroups || (this._initializedGroups = /* @__PURE__ */ new Set());
    const x = this.engine.camera, S = this.engine.rendering.renderState.viewMatrixWorldInverse;
    this._tempMatrix4.multiplyMatrices(x.projectionMatrix, S), this.engine.renderer.getSize(this._tempVector2);
    const E = this._lineToScreenCoords(s, this._tempMatrix4, this._tempVector2);
    let b;
    if (c !== void 0 && c >= 0) {
      let $ = -1;
      for (let G = 0; G < E.length; G++)
        if (E[G].originalIndex === c) {
          $ = G;
          break;
        }
      if ($ === -1)
        return [];
      if (b = E[$], b.originalW <= 0)
        return [];
      $ === E.length - 1 ? b.segment = Math.max(0, E.length - 2) : b.segment = $;
    } else {
      if (b = this._worldToScreen(a, this._tempMatrix4, this._tempVector2), this._isPointBehindCamera(a, this._tempMatrix4))
        return [];
      b.segment = this._findSegmentForAnchor(b, E);
    }
    if (!this._isAnchorVisible(b, this._tempVector2))
      return [];
    const w = d !== void 0 ? d : this.parameters.fontSize, M = this._parseColorToRgba(h, this.parameters.color), P = this._parseColorToRgba(f, this.parameters.strokeColor), D = p !== void 0 ? p : this.parameters.strokeWidth, L = w + D * 2, O = `${r}_${L}_${this.parameters.fontFamily}_${this.parameters.fontWeight}`;
    let F = this._shapeCache.get(O);
    if (!F) {
      if (F = this._shapeText(r, L), !F || !F.glyphs || F.glyphs.length === 0)
        return [];
      this._shapeCache.set(O, F);
    }
    let k = !1, V = !1;
    if (this.parameters.keepUpright && F.glyphs.length >= 2) {
      const $ = F.glyphs[0], G = F.glyphs[F.glyphs.length - 1], Y = (G.x + G.width) / 2, H = $.x + $.width / 2 - Y, W = G.x + G.width / 2 - Y, q = this._placeGlyphAlongLine(
        H,
        b,
        E,
        !1
      ), Z = this._placeGlyphAlongLine(
        W,
        b,
        E,
        !1
      );
      if (q && Z) {
        const X = this._tempVector2.x / this._tempVector2.y, K = (Z.x - q.x) * X, ee = Z.y - q.y;
        let ie = "horizontal", re = this._requiresOrientationChange(K, ee, ie);
        re && re.useVertical && (ie = "vertical", re = this._requiresOrientationChange(K, ee, ie)), re && re.needsFlipping ? (k = !0, this._flipStates.set(m, this.FlipState.flipRequired)) : this._flipStates.set(m, this.FlipState.flipNotRequired), V = Math.abs(ee) > Math.abs(K);
      }
    }
    const U = (F.glyphs[F.glyphs.length - 1].x + F.glyphs[F.glyphs.length - 1].width) / 2, z = [];
    for (let $ = 0; $ < F.glyphs.length; $++) {
      const G = F.glyphs[$], j = G.x + G.width / 2 - U, Y = this._placeGlyphAlongLine(
        j,
        b,
        E,
        k,
        V
      );
      if (!Y)
        return y && this._initializedGroups.add(m), [];
      z.push({
        x: Y.x,
        y: Y.y,
        char: G.char,
        rotation: Y.angle,
        size: w,
        fillColor: M,
        strokeColor: P,
        strokeWidth: D
      });
    }
    return y && this._initializedGroups.add(m), z;
  }
  _parseColorToRgba(e, r = "#ffffff") {
    if (e || (e = r), Array.isArray(e)) {
      const s = e[0] > 1 ? e[0] / 255 : e[0], a = e[1] > 1 ? e[1] / 255 : e[1], c = e[2] > 1 ? e[2] / 255 : e[2], l = e.length > 3 ? e[3] > 1 ? e[3] / 255 : e[3] : 1;
      return [s, a, c, l];
    }
    if (typeof e == "string") {
      const s = e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (s) {
        const a = parseInt(s[1], 10) / 255, c = parseInt(s[2], 10) / 255, l = parseInt(s[3], 10) / 255, h = s[4] !== void 0 ? parseFloat(s[4]) : 1;
        return [a, c, l, h];
      }
      if (e.startsWith("#")) {
        let a = e.replace("#", "");
        a.length === 3 && (a = a.split("").map((d) => d + d).join(""));
        const c = parseInt(a.substring(0, 2), 16) / 255, l = parseInt(a.substring(2, 4), 16) / 255, h = parseInt(a.substring(4, 6), 16) / 255;
        return [c, l, h, 1];
      }
    }
    return [1, 1, 1, 1];
  }
  _shapeText(e, r) {
    const s = this._measureCtx;
    s.font = `${r}px ${this.parameters.fontFamily || "sans-serif"}`;
    const a = [];
    let c = 0;
    for (let l = 0; l < e.length; l++) {
      const h = e[l], f = s.measureText(h).width;
      a.push({
        char: h,
        x: c,
        width: f,
        advance: f
      }), c += f;
    }
    return {
      glyphs: a,
      totalWidth: c
    };
  }
  _distance(e, r) {
    const s = r.x - e.x, a = r.y - e.y;
    return Math.sqrt(s * s + a * a);
  }
  _lineToScreenCoords(e, r, s) {
    const a = [];
    for (let h = 0; h < e.length; h++) {
      const d = e[h];
      this._tempVector4.set(d[0], d[1], d[2], 1), this._tempVector4.applyMatrix4(r), a.push({
        x: this._tempVector4.x,
        y: this._tempVector4.y,
        z: this._tempVector4.z,
        w: this._tempVector4.w,
        originalIndex: h
      });
    }
    const c = [];
    for (let h = 0; h < a.length; h++) {
      const d = a[h], f = a[h + 1];
      if (d.w > 0 && c.push(d), f && (d.w > 0 && f.w <= 0 || d.w <= 0 && f.w > 0)) {
        const m = (1e-3 - d.w) / (f.w - d.w), y = {
          x: d.x + m * (f.x - d.x),
          y: d.y + m * (f.y - d.y),
          z: d.z + m * (f.z - d.z),
          w: 1e-3,
          isClipped: !0,
          originalSegment: h,
          originalIndex: void 0
        };
        c.push(y);
      }
    }
    const l = [];
    for (let h = 0; h < c.length; h++) {
      const d = c[h], f = d.x / d.w, p = d.y / d.w, m = d.z / d.w, y = (f + 1) / 2 * s.x, x = (-p + 1) / 2 * s.y;
      l.push({
        x: y,
        y: x,
        z: m,
        originalW: d.w,
        isClipped: d.isClipped || !1,
        originalIndex: d.originalIndex
      });
    }
    return l;
  }
  _worldToScreen(e, r, s) {
    this._tempVector4_2.set(e[0], e[1], e[2], 1), this._tempVector4_2.applyMatrix4(r), this._tempVector4_2.divideScalar(this._tempVector4_2.w);
    const a = (this._tempVector4_2.x + 1) / 2 * s.x, c = (-this._tempVector4_2.y + 1) / 2 * s.y;
    return { x: a, y: c };
  }
  _findSegmentForAnchor(e, r) {
    let s = 1 / 0, a = 0;
    for (let c = 0; c < r.length - 1; c++) {
      const l = this._pointToSegmentDistance(
        e,
        r[c],
        r[c + 1]
      );
      l < s && (s = l, a = c);
    }
    return a;
  }
  _pointToSegmentDistance(e, r, s) {
    const a = e.x, c = e.y, l = r.x, h = r.y, d = s.x, f = s.y, p = d - l, m = f - h, y = p * p + m * m;
    if (y === 0)
      return this._distance(e, r);
    let x = ((a - l) * p + (c - h) * m) / y;
    x = Math.max(0, Math.min(1, x));
    const v = l + x * p, S = h + x * m, E = a - v, b = c - S;
    return Math.sqrt(E * E + b * b);
  }
  _isAnchorVisible(e, r) {
    const { clippingBuffer: s } = this.parameters, a = s / r.x * 2, c = s / r.y * 2, l = e.x / r.x * 2 - 1, h = 1 - e.y / r.y * 2;
    return l >= -1 - a && l <= 1 + a && h >= -1 - c && h <= 1 + c;
  }
  _isPointBehindCamera(e, r) {
    return this._tempVector4_2.set(e[0], e[1], e[2] || 0, 1), this._tempVector4_2.applyMatrix4(r), this._tempVector4_2.w <= 0;
  }
  _isInFlipRetainRange(e, r) {
    const s = Math.tan(85 * Math.PI / 180);
    return e === 0 || Math.abs(r / e) > s;
  }
  _requiresOrientationChange(e, r, s = "horizontal") {
    return Math.abs(r) > Math.abs(e) ? r < 0 ? {
      needsFlipping: !0,
      useVertical: !0
    } : null : e < 0 ? { needsFlipping: !0 } : null;
  }
  _placeGlyphAlongLine(e, r, s, a = !1, c = !1) {
    const l = !this._placeGlyphDebugDone;
    if (!r || r.segment === void 0 || !s || s.length < 2 || r.segment > s.length - 2)
      return null;
    if (Math.abs(e) < 1e-6) {
      const $ = s[r.segment], G = s[r.segment + 1], j = G.x - $.x, Y = G.y - $.y, H = Math.atan2(Y, j);
      let q = (a ? Math.PI : 0) + H;
      return c && (q -= Math.PI / 2), {
        x: r.x,
        y: r.y,
        z: r.z || 0,
        angle: q,
        segment: r.segment
      };
    }
    let h = e > 0 ? 1 : -1, d = 0, f = !1;
    a && (h *= -1, d = Math.PI);
    const p = h < 0 ? Math.PI : 0, m = s[r.segment], y = s[r.segment + 1];
    if (!m || !y)
      return null;
    const x = Math.abs(e);
    let v = r.segment, S = x, E = { x: r.x, y: r.y, z: r.z || 0 }, b = h > 0 ? s[v + 1] : s[v], w = this._distance(E, b);
    w < 1e-6 && (h > 0 ? v >= s.length - 2 || (v++, E = s[v], b = s[v + 1], w = this._distance(E, b)) : v <= 0 || (v--, E = s[v + 1], b = s[v], w = this._distance(E, b)));
    let M = null;
    for (; S > w; ) {
      if (S -= w, M && this.parameters.textMaxAngle < 180) {
        const $ = {
          x: M.end.x - M.start.x,
          y: M.end.y - M.start.y,
          z: (M.end.z || 0) - (M.start.z || 0)
        }, G = {
          x: b.x - E.x,
          y: b.y - E.y,
          z: (b.z || 0) - (E.z || 0)
        }, j = Math.sqrt($.x * $.x + $.y * $.y + $.z * $.z), Y = Math.sqrt(G.x * G.x + G.y * G.y + G.z * G.z);
        if (j > 0 && Y > 0) {
          const W = ($.x * G.x + $.y * G.y + $.z * G.z) / (j * Y), q = this.parameters.textMaxAngle * Math.PI / 180, Z = Math.cos(q);
          if (W < Z)
            return null;
        }
      }
      if (M = {
        start: E,
        end: b
      }, v += h, v < 0) {
        const $ = s[0], G = s[1], j = {
          x: G.x - $.x,
          y: G.y - $.y,
          z: (G.z || 0) - ($.z || 0)
        }, Y = Math.sqrt(j.x * j.x + j.y * j.y + j.z * j.z);
        if (Y === 0 || !isFinite(S) || S > Y)
          return null;
        const H = {
          x: j.x / Y,
          y: j.y / Y,
          z: j.z / Y
        };
        E = {
          x: $.x - H.x * S,
          y: $.y - H.y * S,
          z: ($.z || 0) - H.z * S
        }, b = $, w = S, S = 0, v = 0, f = !0;
        break;
      }
      if (v >= s.length - 1) {
        const $ = s[s.length - 2], G = s[s.length - 1], j = {
          x: G.x - $.x,
          y: G.y - $.y,
          z: (G.z || 0) - ($.z || 0)
        }, Y = Math.sqrt(j.x * j.x + j.y * j.y + j.z * j.z);
        if (Y === 0 || !isFinite(S) || S > Y)
          return null;
        const H = {
          x: j.x / Y,
          y: j.y / Y,
          z: j.z / Y
        }, W = {
          x: G.x + H.x * S,
          y: G.y + H.y * S,
          z: (G.z || 0) + H.z * S
        };
        E = G, b = W, w = S, v = s.length - 2, f = !0;
        break;
      }
      E = h > 0 ? s[v] : s[v + 1], b = h > 0 ? s[v + 1] : s[v], w = this._distance(E, b);
    }
    const P = S / w, D = E, L = b, O = D.x + (L.x - D.x) * P, F = D.y + (L.y - D.y) * P, k = (D.z || 0) + ((L.z || 0) - (D.z || 0)) * P, V = L.x - D.x, N = L.y - D.y, U = Math.atan2(N, V);
    let z;
    return f ? z = d + U : z = d + p + U, c && (z -= Math.PI / 2), l && (this._placeGlyphDebugDone = !0), { x: O, y: F, z: k, angle: z, segment: v };
  }
  _updateData() {
    if (!this.dataSource || !this.engine)
      return;
    let e = this.dataSource.userData;
    this._enableCollision && this._collisionData && (e = this._collisionData);
    const r = [], s = [], a = [], c = [];
    for (let l = 0; l < e.length; l++) {
      const h = [
        e[l].position[0],
        e[l].position[1],
        e[l].position[2] || 0
      ], d = e[l].text, f = e[l].linePoints;
      if (!d || !f || !Array.isArray(f))
        continue;
      const p = e[l].id || `text_${l}_${d}`, m = e[l].anchorIndex;
      r.push({
        text: d,
        line: f,
        anchor: h,
        anchorIndex: m,
        id: p,
        textFillStyle: e[l].textFillStyle,
        textSize: e[l].textSize,
        textStrokeStyle: e[l].textStrokeStyle,
        textStrokeWidth: e[l].textStrokeWidth
      });
    }
    if (this.parameters.debug && this.engine.map) {
      const l = this.dataSource.userData;
      for (let h = 0; h < l.length; h++) {
        const d = l[h].linePoints, f = l[h].anchorIndex, p = l[h].id;
        if (!d || !Array.isArray(d) || d.length < 2)
          continue;
        const m = d.map(
          (y) => this.engine.map.unprojectArrayCoordinate(y)
        ).filter((y) => y && y.length >= 2);
        m.length >= 2 && s.push({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: m
          },
          properties: { textId: p }
        }), d.forEach((y, x) => {
          const v = this.engine.map.unprojectArrayCoordinate(y);
          v && v.length >= 2 && (x === f ? c.push({
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: v
            },
            properties: { textId: p, index: x }
          }) : a.push({
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: v
            },
            properties: { textId: p, index: x }
          }));
        });
      }
    }
    this.parameters.debug && this._updateDebugObjects(s, a, c), r.length > 0 ? this.setTextsAlongLines(r) : this.setTexts([]), this.needsUpdate = !1;
  }
  _updateDebugObjects(e, r, s) {
    if (!(!this._debugPolyline || !this._debugNormalPoints || !this._debugAnchorPoints))
      try {
        e.length > 0 ? this._debugPolyline.dataSource = GeoJSONDataSource.fromGeoJSON(e) : this._debugPolyline.dataSource = GeoJSONDataSource.fromGeoJSON([]), r.length > 0 ? this._debugNormalPoints.dataSource = GeoJSONDataSource.fromGeoJSON(r) : this._debugNormalPoints.dataSource = GeoJSONDataSource.fromGeoJSON([]), s.length > 0 ? this._debugAnchorPoints.dataSource = GeoJSONDataSource.fromGeoJSON(s) : this._debugAnchorPoints.dataSource = GeoJSONDataSource.fromGeoJSON([]);
      } catch (a) {
        console.error("Failed to update debug objects:", a);
      }
  }
  showAtlasDebug(e = {}) {
    const {
      size: r = 300,
      position: s = "top-right",
      autoUpdate: a = !0
    } = e;
    this._debugPanel && this._debugPanel.remove();
    const c = document.createElement("div");
    c.style.position = "fixed", c.style.zIndex = "10000", c.style.background = "rgba(0, 0, 0, 0.8)", c.style.padding = "10px", c.style.borderRadius = "5px", c.style.boxShadow = "0 2px 10px rgba(0,0,0,0.5)", c.style.fontFamily = "monospace", c.style.fontSize = "12px", c.style.color = "#fff";
    const l = {
      "top-left": { top: "10px", left: "10px" },
      "top-right": { top: "10px", right: "10px" },
      "bottom-left": { bottom: "10px", left: "10px" },
      "bottom-right": { bottom: "10px", right: "10px" }
    };
    Object.assign(c.style, l[s] || l["top-right"]);
    const h = document.createElement("div");
    h.textContent = "ScreenText Atlas Debug", h.style.marginBottom = "10px", h.style.fontWeight = "bold", h.style.borderBottom = "1px solid #666", h.style.paddingBottom = "5px", c.appendChild(h);
    const d = document.createElement("div");
    d.style.marginBottom = "10px", c.appendChild(d);
    const f = document.createElement("div");
    f.style.border = "1px solid #666", f.style.background = "#222", f.style.display = "flex", f.style.justifyContent = "center", f.style.alignItems = "center", f.style.overflow = "hidden", c.appendChild(f);
    const p = document.createElement("canvas");
    p.style.maxWidth = `${r}px`, p.style.maxHeight = `${r}px`, p.style.imageRendering = "pixelated", f.appendChild(p);
    const m = document.createElement("button");
    m.textContent = "\u2715", m.style.position = "absolute", m.style.top = "10px", m.style.right = "10px", m.style.background = "#ff4444", m.style.border = "none", m.style.color = "#fff", m.style.width = "20px", m.style.height = "20px", m.style.borderRadius = "3px", m.style.cursor = "pointer", m.style.fontSize = "14px", m.style.lineHeight = "1", m.onclick = () => this.hideAtlasDebug(), c.appendChild(m), document.body.appendChild(c), this._debugPanel = c;
    const y = () => {
      if (!this.atlasTexture || !this._debugPanel)
        return;
      const x = this.fontAtlasManager.atlas;
      if (!x || !x.textureData)
        return;
      const v = this.fontAtlasManager.mapping, S = v ? Object.keys(v).length : 0, E = x.width, b = x.height, w = this._lastCharCount || 0;
      d.innerHTML = `
                <div>Atlas Size: ${E} \xD7 ${b}</div>
                <div>Cached Chars: ${S}</div>
                <div>Rendered Chars: ${w}</div>
                <div>Type: SDF Texture</div>
            `, p.width = E, p.height = b;
      const M = p.getContext("2d"), P = M.createImageData(E, b), D = x.textureData;
      for (let L = 0; L < D.length; L++) {
        const O = D[L], F = L * 4;
        P.data[F] = O, P.data[F + 1] = O, P.data[F + 2] = O, P.data[F + 3] = 255;
      }
      if (M.putImageData(P, 0, 0), v && S > 0 && S < 100) {
        M.strokeStyle = "rgba(255, 0, 0, 0.5)", M.lineWidth = 1;
        for (const L of Object.values(v)) {
          const O = L.x, F = L.y, k = L.width + SDF_BUFFER * 2, V = L.height;
          M.strokeRect(O, F, k, V);
        }
      }
    };
    return y(), a && (this._debugUpdateInterval = setInterval(y, 100)), this;
  }
  hideAtlasDebug() {
    return this._debugPanel && (this._debugPanel.remove(), this._debugPanel = null), this._debugUpdateInterval && (clearInterval(this._debugUpdateInterval), this._debugUpdateInterval = null), this;
  }
  getAtlasTexture() {
    return this.atlasTexture;
  }
  getFontAtlasManager() {
    return this.fontAtlasManager;
  }
  getCharacterSet() {
    var l;
    const e = (l = this.fontAtlasManager) == null ? void 0 : l.mapping;
    if (!e)
      return /* @__PURE__ */ new Set();
    const r = this.parameters.fontWeight || "400", s = this.parameters.fontFamily || "sans-serif", a = r + s, c = /* @__PURE__ */ new Set();
    for (const h of Object.keys(e))
      if (h.endsWith(a)) {
        const d = h.slice(0, -a.length);
        c.add(d);
      }
    return c;
  }
  dispose() {
    this.hideAtlasDebug(), this._debugPolyline && (this.engine && this.engine.remove(this._debugPolyline), this._debugPolyline.dispose(), this._debugPolyline = null), this._debugNormalPoints && (this.engine && this.engine.remove(this._debugNormalPoints), this._debugNormalPoints.dispose(), this._debugNormalPoints = null), this._debugAnchorPoints && (this.engine && this.engine.remove(this._debugAnchorPoints), this._debugAnchorPoints.dispose(), this._debugAnchorPoints = null), this._shapeCache && this._shapeCache.clear(), this._placeTextCache && this._placeTextCache.clear(), this._flipStates && this._flipStates.clear(), this.geometry && this.geometry.dispose(), this.material && this.material.dispose(), this.atlasTexture && this.atlasTexture.dispose();
  }
}
function bucketSort(o) {
  let i = o.reduce((e, r) => {
    let s = +r.split("-")[0];
    return Math.max(s, e);
  }, 0);
  return o = o.sort((e, r) => {
    const s = e.split("-"), a = r.split("-");
    let c = s[0], l = s[1], h = s[2], d = a[0], f = a[1], p = a[2];
    if (c !== i) {
      const m = i - c;
      l = l * Math.pow(2, m), h = h * Math.pow(2, m);
    }
    if (d !== i) {
      const m = i - d;
      f = f * Math.pow(2, m), p = p * Math.pow(2, m);
    }
    return l !== f ? f - l : p - h;
  }), o.reverse(), o;
}
const getUUID = () => new Date().getTime() + Math.random().toString(36).slice(2);
class RenderingLabel {
  constructor(i) {
    _(this, "_blocks", {});
    _(this, "_collisionLabels", {
      icon_text: {},
      text_flat: {},
      text_fix: {},
      icon_flat: {},
      icon_flat_with_depth: {},
      icon: {}
    });
    _(this, "_removalBuffer", []);
    _(this, "_removalBufferSize", 6);
    _(this, "_timers", {});
    _(this, "_enabled", !1);
    _(this, "_spriteTexture", null);
    this._rendering = i;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(i) {
    i !== this._enabled && (this._enabled = i, i ? this.init() : this.dispose());
  }
  set spriteTexture(i) {
    this._spriteTexture || (this._spriteTexture = i);
  }
  init() {
    this.initCollisionLabel(), this.initLabel();
  }
  initCollisionLabel() {
    const i = this._iconDataSource = new DataSource(), e = this._icon = this._rendering.add(new Label({
      type: "icon",
      vertexIcons: !0,
      enableFade: !0,
      isRenderInPostprocess: !0
    }));
    i.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), e.dataSource = i;
    const r = this._iconUvDataSource = new DataSource(), s = this._iconUv = this._rendering.add(new Label({
      spriteTexture: this._spriteTexture,
      transparent: !0,
      enableFade: !0,
      isRenderInPostprocess: !0,
      type: "icon"
    }));
    r.defineAttributes({
      id: "id",
      iconUvs: "iconUvs",
      iconSize: "iconSize",
      iconOpacity: "iconOpacity",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), s.dataSource = r;
    const a = this._iconFlatUvDataSource = new DataSource(), c = this._iconFlatUv = this._rendering.add(new Label({
      spriteTexture: this._spriteTexture,
      transparent: !0,
      isRenderInPostprocess: !0,
      enableFade: !0,
      flat: !0,
      type: "icon"
    }));
    a.defineAttributes({
      id: "id",
      iconUvs: "iconUvs",
      iconSize: "iconSize",
      iconOpacity: "iconOpacity",
      rotateZ: "rotateZ",
      boundingBox: "boundingBox",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), c.dataSource = a;
    const l = this._textFlatDataSource = new DataSource(), h = this._textFlat = this._rendering.add(new Label({
      type: "text",
      isRenderInPostprocess: !0,
      enableFade: !0,
      flat: !0
    }));
    l.defineAttributes({
      id: "id",
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      textWeight: "textWeight",
      rotateZ: "rotateZ",
      boundingBox: "boundingBox",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), h.dataSource = l;
    const d = this._textFixedDataSource = new DataSource(), f = this._textFixed = this._rendering.add(new Label({
      type: "text",
      isRenderInPostprocess: !0,
      enableFade: !0,
      flat: !1
    }));
    d.defineAttributes({
      id: "id",
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textWeight: "textWeight",
      textAnchor: "textAnchor",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), f.dataSource = d;
    const p = this._iconTextDataSource = new DataSource(), m = this._iconText = this._rendering.add(new Label({
      type: "icontext",
      vertexIcons: !0,
      enableFade: !0,
      isRenderInPostprocess: !0
    }));
    p.defineAttributes({
      id: "id",
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textWeight: "textWeight",
      textAnchor: "textAnchor",
      textDrawOnIcon: "textDrawOnIcon",
      icon: "icon",
      iconSize: "iconSize",
      direction: "direction",
      rotateZ: "rotateZ",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), m.dataSource = p;
    const y = this._iconTextUvDataSource = new DataSource(), x = this._iconTextUv = this._rendering.add(new Label({
      type: "icontext",
      isRenderInPostprocess: !0,
      spriteTexture: this._spriteTexture,
      enableFade: !0,
      transparent: !0
    }));
    y.defineAttributes({
      id: "id",
      type: "type",
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textWeight: "textWeight",
      textOffset: "textOffset",
      textAnchor: "textAnchor",
      textDrawOnIcon: "textDrawOnIcon",
      rotateZ: "rotateZ",
      iconUvs: "iconUvs",
      iconSize: "iconSize",
      iconOpacity: "iconOpacity",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), x.dataSource = y;
    const v = this._roadLabelDataSource = new DataSource(), S = this._roadLabel = this._rendering.add(new ScreenText({
      fontSize: 16,
      color: "#000000",
      strokeWidth: 2,
      strokeColor: "#ffffff",
      keepUpright: !0,
      textMaxAngle: 45,
      debug: !1
    }));
    v.defineAttributes({
      text: "text",
      linePoints: "linePoints",
      anchorIndex: "anchorIndex",
      id: "id",
      rank: "rank",
      bucket: "bucket",
      distance: "distance",
      tolerance: "tolerance",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth"
    }), S.dataSource = v, this._rendering.collision.setGroupOption("poi", {
      enabledBucketCache: !0,
      requireClip: !1,
      bucketSort
    }), this._rendering.collision.add(e, { margin: [2, 2] }, "poi"), this._rendering.collision.add(s, { margin: [2, 2] }, "poi"), this._rendering.collision.add(c, { margin: [2, 2] }, "poi"), this._rendering.collision.add(h, { margin: [2, 2] }, "poi"), this._rendering.collision.add(f, { margin: [2, 2] }, "poi"), this._rendering.collision.add(m, { margin: [2, 2] }, "poi"), this._rendering.collision.add(x, { margin: [2, 2] }, "poi"), this._rendering.collision.add(S, { margin: [2, 2] }, "poi");
  }
  initLabel() {
    const i = this._labelIconDataSource = new DataSource(), e = this._labelIcon = this._rendering.add(new Label({
      type: "icon",
      vertexIcons: !0,
      isRenderInPostprocess: !0
    }));
    i.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      offset: "offset"
    }), e.dataSource = i;
    const r = this._labelIconFlatDataSource = new DataSource(), s = this._labelIconFlat = this._rendering.add(new Label({
      vertexIcons: !0,
      transparent: !0,
      isRenderInPostprocess: !0,
      flat: !0,
      type: "icon"
    }));
    r.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      offset: "offset",
      iconUvs: "iconUvs",
      iconOpacity: "iconOpacity",
      rotateZ: "rotateZ"
    }), s.dataSource = r;
    const a = this._labelIconFlatDepthDataSource = new DataSource(), c = this._labelIconFlatDepth = this._rendering.add(new Label({
      vertexIcons: !0,
      transparent: !0,
      depthTest: !0,
      keepSize: !1,
      flat: !0,
      type: "icon"
    }));
    a.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      offset: "offset",
      iconUvs: "iconUvs",
      iconOpacity: "iconOpacity",
      rotateZ: "rotateZ"
    }), c.dataSource = a;
    const l = this._labelTextFlatDataSource = new DataSource(), h = this._labelTextFlat = this._rendering.add(new Label({
      type: "text",
      isRenderInPostprocess: !0,
      flat: !0
    }));
    l.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      rotateZ: "rotateZ"
    }), h.dataSource = l;
    const d = this._labelTextFixedDataSource = new DataSource(), f = this._labelTextFixed = this._rendering.add(new Label({
      type: "text",
      isRenderInPostprocess: !0,
      flat: !1
    }));
    d.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      offset: "offset"
    }), f.dataSource = d;
    const p = this._labelIconTextDataSource = new DataSource(), m = this._labelIconText = this._rendering.add(new Label({
      type: "icontext",
      vertexIcons: !0,
      isRenderInPostprocess: !0
    }));
    p.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      textDrawOnIcon: "textDrawOnIcon",
      icon: "icon",
      iconSize: "iconSize",
      direction: "direction",
      rotateZ: "rotateZ",
      offset: "offset"
    }), m.dataSource = p;
  }
  getLabelType(i) {
    let e = i.type;
    if (e)
      return e;
    const r = i.flat;
    let s = !1, a = !1;
    if (i.text && (s = !0), i.mapSrc) {
      const { width: c, height: l } = i;
      i.icon = i.mapSrc, i.iconSize = [c || 40, l || 40], a = !0;
    }
    return s && a ? e = "icon_text" : s ? e = r ? "text_flat" : "text_fix" : a && (e = r ? "icon_flat" : "icon"), e;
  }
  processLabel(i) {
    return i.type = this.getLabelType(i), i;
  }
  _getCollisionLabel(i) {
    let e = i.type || this.getLabelType(i), r = i.group || "default";
    i.attributes && i.attributes.group && (r = i.attributes.group);
    const s = this._collisionLabels[e];
    if (s[r])
      return s[r];
    let a;
    const c = new DataSource();
    return e === "icon_text" ? (a = this._rendering.add(new Label({
      type: "icontext",
      vertexIcons: !0,
      isRenderInPostprocess: !0
    })), c.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textWeight: "textWeight",
      textAnchor: "textAnchor",
      textDrawOnIcon: "textDrawOnIcon",
      icon: "icon",
      iconSize: "iconSize",
      direction: "direction",
      rotateZ: "rotateZ",
      offset: "offset",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })) : e === "icon" ? (a = this._rendering.add(new Label({
      type: "icon",
      vertexIcons: !0,
      isRenderInPostprocess: !0
    })), c.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      offset: "offset",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })) : e === "icon_flat" ? (a = this._rendering.add(new Label({
      vertexIcons: !0,
      transparent: !0,
      isRenderInPostprocess: !0,
      flat: !0,
      type: "icon"
    })), c.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      offset: "offset",
      iconUvs: "iconUvs",
      iconOpacity: "iconOpacity",
      rotateZ: "rotateZ",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })) : e === "text_flat" ? (a = this._rendering.add(new Label({
      type: "text",
      isRenderInPostprocess: !0,
      flat: !0
    })), c.defineAttributes({
      text: "text",
      textSize: "textSize",
      textWeight: "textWeight",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      rotateZ: "rotateZ",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })) : e === "text_fix" && (a = this._rendering.add(new Label({
      type: "text",
      isRenderInPostprocess: !0,
      flat: !1
    })), c.defineAttributes({
      text: "text",
      textSize: "textSize",
      textWeight: "textWeight",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      offset: "offset",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })), a.dataSource = c, s[r] = a, this._rendering.collision.add(a, { margin: [0, 0] }, r), a;
  }
  addCollisionLabel(i) {
    const e = i.type, r = !!e;
    r || this.processLabel(i);
    const s = this.computeBoundingBox(i);
    i.boundingBox = s;
    let a = i;
    if (!(i instanceof DataItem) && Array.prototype.toString.call(i) === "[object Object]") {
      const { position: c, forceProjected: l, ...h } = i;
      h.isCustom = !r, a = new DataItem(c, h, l);
    }
    if (e === "icon_text")
      this._iconTextDataSource.add(a);
    else if (e === "icon_text_uv")
      this._iconTextUvDataSource.add(a);
    else if (e === "icon")
      this._iconDataSource.add(a);
    else if (e === "icon_uv")
      this._iconUvDataSource.add(a);
    else if (e === "icon_flat_uv")
      this._iconFlatUvDataSource.add(a);
    else if (e === "text_flat" || e === "labelp")
      this._textFlatDataSource.add(a);
    else if (e === "text_fix")
      this._textFixedDataSource.add(a);
    else {
      const c = this._getCollisionLabel(i), l = i.type;
      let h = i.group || "default";
      i.attributes && i.attributes.group && (h = i.attributes.group), this._clearLabelFromRemovalBuffer(l, h), c.dataSource.add(a);
    }
    return a;
  }
  addNormalLabel(i) {
    let e = i;
    if (!(i instanceof DataItem) && Array.prototype.toString.call(i) === "[object Object]") {
      const { position: r, forceProjected: s, ...a } = i;
      e = new DataItem(r, a, s);
    }
    return i.type === "icon" ? this._labelIconDataSource.add(e) : i.type === "icon_flat" ? this._labelIconFlatDataSource.add(e) : i.type === "icon_flat_with_depth" ? this._labelIconFlatDepthDataSource.add(e) : i.type === "text_flat" ? this._labelTextFlatDataSource.add(e) : i.type === "text_fix" ? this._labelTextFixedDataSource.add(e) : i.type === "icon_text" && this._labelIconTextDataSource.add(e), e;
  }
  addLabel(i) {
    if (this.enabled || (this.enabled = !0), !i.position) {
      console.warn("need position");
      return;
    }
    let r;
    return i.collision ? r = this.addCollisionLabel(i) : (this.processLabel(i), r = this.addNormalLabel(i)), r;
  }
  addLabels(i, e) {
    this.enabled || (this.enabled = !0);
    const r = this._rendering.taskScheduler.addTask(this._createLabelTask(i));
    return e = e || getUUID(), this._blocks[e] = r, r.promise;
  }
  _createLabelTask(i) {
    return () => new Promise((r, s) => {
      try {
        const a = [];
        for (const c of i) {
          const l = defaultValue$1(c.collision, !0);
          if (c.collision = l, l) {
            const h = this.addCollisionLabel(c);
            a.push(h);
          } else {
            const h = this.addNormalLabel(c);
            a.push(h);
          }
        }
        this._rendering.requestRender(), r(a);
      } catch (a) {
        s(a);
      }
    });
  }
  computeBoundingBox(i) {
    this.enabled || (this.enabled = !0);
    let e;
    return i.type === "icon_text" ? e = this._iconText.computeBoundingBox(i) : i.type === "icon_text_uv" ? e = this._iconTextUv.computeBoundingBox(i) : i.type === "icon" ? e = this._icon.computeBoundingBox(i) : i.type === "icon_uv" ? e = this._iconUv.computeBoundingBox(i) : i.type === "icon_flat_uv" ? e = this._iconFlatUv.computeBoundingBox(i) : i.type === "text_flat" || i.type === "labelp" ? e = this._textFlat.computeBoundingBox(i) : i.type === "text_fix" && (e = this._textFixed.computeBoundingBox(i)), e;
  }
  _checkRemoveCollisionLabel(i, e) {
    if (i.dataSource.userData.length === 1) {
      const s = e.type || this.getLabelType(e);
      let a = e.group || "default";
      e.attributes && e.attributes.group && (a = e.attributes.group);
      const c = `${s}-${a}`;
      this._removalBuffer.find((h) => h.key === c) || this._removalBuffer.push({
        collisionLabel: i,
        key: c
      }), this._removalBuffer.length >= this._removalBufferSize && this._flushPartialRemovalBuffer();
    }
  }
  _flushPartialRemovalBuffer() {
    const i = Math.floor(this._removalBuffer.length / 2), e = this._removalBuffer.splice(0, i);
    for (const r of e) {
      const { collisionLabel: s, key: a } = r;
      if (!s || !s.dataSource)
        continue;
      const [c, l] = a.split("-");
      this._rendering.remove(s), this._rendering.collision.remove(s, l), this._collisionLabels[c] && delete this._collisionLabels[c][l];
    }
  }
  _clearLabelFromRemovalBuffer(i, e) {
    const r = `${i}-${e}`, s = this._removalBuffer.findIndex((a) => a.key === r);
    s !== -1 && this._removalBuffer.splice(s, 1);
  }
  removeCollisionLabel(i) {
    if (i.isCustom || i.attributes && i.attributes.isCustom) {
      const r = this._getCollisionLabel(i);
      r.dataSource.remove(i), this._checkRemoveCollisionLabel(r, i, r.dataSource);
      return;
    }
    i.type === "icon_text" ? this._iconTextDataSource.remove(i) : i.type === "icon_text_uv" ? this._iconTextUvDataSource.remove(i) : i.type === "icon" ? this._iconDataSource.remove(i) : i.type === "icon_uv" ? this._iconUvDataSource.remove(i) : i.type === "icon_flat_uv" ? this._iconFlatUvDataSource.remove(i) : i.type === "text_flat" || i.type === "labelp" ? this._textFlatDataSource.remove(i) : i.type === "text_fix" && this._textFixedDataSource.remove(i);
  }
  removeNormalLabel(i) {
    const e = i.attributes;
    let r = i.type;
    e && e.type && (r = e.type), r === "icon" ? this._labelIconDataSource.remove(i) : r === "icon_flat" ? this._labelIconFlatDataSource.remove(i) : r === "icon_flat_with_depth" ? this._labelIconFlatDepthDataSource.remove(i) : r === "text_flat" ? this._labelTextFlatDataSource.remove(i) : r === "text_fix" ? this._labelTextFixedDataSource.remove(i) : r === "icon_text" && this._labelIconTextDataSource.remove(i);
  }
  removeLabel(i) {
    let e = i.collision;
    e || (e = i.attributes && i.attributes.collision), e ? this.removeCollisionLabel(i) : this.removeNormalLabel(i);
  }
  removeLabels(i, e) {
    const r = this._blocks[e];
    if (r && !r.isStart()) {
      r.cancel(), delete this._blocks[e];
      return;
    }
    for (const s of i) {
      const a = defaultValue$1(s.collision, !0);
      s.collision = a, this.removeLabel(s);
    }
    this._rendering.requestRender();
  }
  addRoadLabels(i, e) {
    this.enabled || (this.enabled = !0);
    for (const r of i) {
      const { position: s, ...a } = r, c = new DataItem(s, a);
      this._roadLabelDataSource.add(c);
    }
  }
  removeRoadLabels(i) {
    for (const e of i) {
      const r = e.id, s = this._roadLabelDataSource.userData;
      for (let a = s.length - 1; a >= 0; a--)
        if (s[a].id === r) {
          this._roadLabelDataSource.remove(s[a]);
          break;
        }
    }
  }
  dispose() {
    this._rendering.collision.remove(this._fixText, "poi"), this._rendering.collision.remove(this._labelText, "poi"), this._rendering.collision.remove(this._flatText, "poi"), this._rendering.remove(this._fixText), this._rendering.remove(this._flatText), this._rendering.remove(this._labelText), this._roadLabel && (this._rendering.collision.remove(this._roadLabel, "poi"), this._rendering.remove(this._roadLabel));
  }
}
const _tempMatrix4$4 = new Matrix4(), _tempPosition = new Vector3$1(), _tempOffset = new Vector4(), _tempCharPosition = new Vector4(), vec4 = new Vector4(), getPixelSize$3 = (o, i, e) => 0.2 * Math.tan(i / 2) * o / e * 10;
class RenderingCollision {
  constructor(i) {
    _(this, "_groupObjectMap", {});
    _(this, "_groupDataMap", {});
    _(this, "_groupOptions", {});
    _(this, "_objectDataMap", /* @__PURE__ */ new Map());
    _(this, "_needsUpdate", !1);
    _(this, "_restrictCount", 1e4);
    _(this, "_cacheBucketKeys", {});
    _(this, "_lastUpdateTime", 0);
    _(this, "_delayUpdateTime", 200);
    _(this, "_delayUpdateTimeHandler", null);
    _(this, "_margin", [0, 0]);
    _(this, "_maxRenderDepth", 1);
    _(this, "_lastZoom", 0);
    _(this, "_viewMatrixWorld", new Matrix4());
    _(this, "_projectionMatrix", new Matrix4());
    _(this, "_viewChanged", !0);
    this._rendering = i;
  }
  add(i, e = {}, r = "_default") {
    if (!(i instanceof GeoObject)) {
      console.error("Collison Test only work with GeoObject.");
      return;
    }
    if (!i.dataSource) {
      console.error("Object must have DataSource before it added to Collision!");
      return;
    }
    this._groupObjectMap[r] || (this._groupObjectMap[r] = [], this._groupDataMap[r] = []), this._groupObjectMap[r].push(i), e.margin !== void 0 && typeof e.margin == "number" && (e.margin = [e.margin, e.margin]), i._enableCollision = !0, i._collisionOptions = e, i.dataSource.defineAttribute("rank", "rank"), i.dataSource.defineAttribute("bucket", "bucket"), i.dataSource.defineAttribute("distance", "distance");
  }
  setGroupOption(i, e) {
    this._groupOptions[i] = e;
  }
  remove(i, e = "_default") {
    if (!(i instanceof GeoObject)) {
      console.error("Collison Test only work with GeoObject.");
      return;
    }
    let r = this._groupObjectMap[e].indexOf(i);
    r > -1 ? (this._groupObjectMap[e].splice(r, 1), delete i._enableCollision, delete i._collisionOptions, delete i._collisionData, delete i._collisionUpdated, i.dataSource.undefineAttribute("rank", "rank")) : console.error("remove error: cannot find object in this group.");
  }
  sortBucket(i) {
    i && i.length > 0 && i.sort((e, r) => r.rank - e.rank || r.position[0] - e.position[0] || r.position[1] - e.position[1]);
  }
  sortBuckets(i, e) {
    const r = this._groupOptions[e] || {}, s = r.bucketSort, a = r.enabledBucketCache;
    let c = Object.keys(i);
    if (s && (c = s(c)), a) {
      this._cacheBucketKeys[e] || (this._cacheBucketKeys[e] = []);
      const h = this._cacheBucketKeys[e];
      if (h && h.length > 0) {
        const d = [], f = [];
        for (let p = 0; p < h.length; p++) {
          const m = h[p];
          c.includes(m) && d.push(m);
        }
        for (let p = 0; p < c.length; p++) {
          const m = c[p];
          if (!h.includes(m)) {
            const x = i[m][0] || {};
            f.push({
              key: m,
              distance: x.distance || Number.POSITIVE_INFINITY
            });
          }
        }
        f.sort((p, m) => p.distance - m.distance), c = d.concat(f.map((p) => p.key));
      }
      this._cacheBucketKeys[e] = c;
    }
    const l = [];
    for (let h = 0; h < c.length; h++) {
      const d = c[h], f = i[d];
      this.sortBucket(f), l.push(...f);
    }
    return this.sortBucket(l), l;
  }
  sortData() {
    let i = Object.keys(this._groupObjectMap);
    for (let e = 0; e < i.length; e++) {
      const r = i[e], s = this._groupObjectMap[r];
      for (let l = 0; l < s.length; l++) {
        const h = s[l];
        h._collisionData = [], h._collisionUpdated = !0;
        let d = h.dataSource.userData;
        for (let f = 0; f < d.length; f++)
          d[f]._objects = h.dataSource.objects;
      }
      let a = [];
      for (let l = 0; l < s.length; l++) {
        const h = s[l];
        a = a.concat(h.dataSource.userData);
      }
      const c = {};
      a.forEach((l) => {
        const h = l.bucket || "default";
        c[h] || (c[h] = []), c[h].push(l);
      }), this._groupDataMap[r] = this.sortBuckets(c, r);
    }
    this._needsUpdate = !1;
  }
  update(i) {
    if (!Object.keys(this._groupDataMap).length || this._delayUpdateTimeHandler)
      return;
    const r = Date.now(), s = r - this._lastUpdateTime;
    if (s < this._delayUpdateTime) {
      this._delayUpdateTimeHandler = setTimeout(() => {
        clearTimeout(this._delayUpdateTimeHandler), this._delayUpdateTimeHandler = null, this._rendering.requestRender();
      }, this._delayUpdateTime - s + 1);
      return;
    }
    this.needsUpdate ? (this.sortData(), this._collisionTest()) : (this._viewChanged = !i.viewMatrixWorld.equals(this._viewMatrixWorld) || !i.projectionMatrix.equals(this._projectionMatrix), this._viewChanged && (this._collisionTest(), this._viewMatrixWorld.copy(i.viewMatrixWorld), this._projectionMatrix.copy(i.projectionMatrix))), this._lastUpdateTime = r;
  }
  _calculatePixelSize(i, e) {
    const s = this._rendering.renderState.cameraOffset;
    e.sub(s);
    const a = i.position.distanceTo(e), c = i.fov * Math.PI / 180, l = this._rendering.resolution.y;
    return getPixelSize$3(a, c, l);
  }
  _collisionTest() {
    var f, p, m;
    const i = Object.keys(this._groupDataMap), e = this._rendering.camera, r = this._rendering.renderState.viewMatrixWorldInverse, s = this._rendering.resolution ? this._rendering.resolution.toArray() : [0, 0], [a, c] = s;
    if (isNaN(a) || a <= 0 || isNaN(c) || c <= 0)
      return console.warn("resolution is invalid"), !1;
    _tempMatrix4$4.multiplyMatrices(e.projectionMatrix, r);
    const l = this._rendering.stats, h = this._rendering.renderState.cameraOffset, d = this._objectDataMap;
    d.clear(), l.beginTimeStatsItem("labelCollision");
    for (const y of i) {
      const x = this._groupDataMap[y];
      if (!x)
        continue;
      const v = new RBush(), S = this._groupOptions[y] || {}, E = defined$2(S.requireClip) ? S.requireClip : !0;
      for (const b of x) {
        const w = b._objects;
        for (const N of w)
          d.has(N) || d.set(N, []);
        const M = w.find((N) => N._enableCollision);
        if (!M)
          continue;
        const [P, D, L] = this._getScreenPosition(
          b.position,
          _tempMatrix4$4,
          a,
          c
        );
        if (L > this._maxRenderDepth)
          continue;
        const O = M.collisionTest(b);
        if (!O)
          continue;
        const F = Array.isArray(O) ? O : [O], k = [];
        for (const N of F) {
          const U = N.tolerance || 0, z = ((f = M._collisionOptions) == null ? void 0 : f.margin) || this.margin;
          let $ = [];
          if (N.chars)
            if (N.isProjected)
              $ = this._computeProjectedCharBoundingBoxes(
                N.chars,
                z,
                U,
                a,
                c
              );
            else {
              const G = _tempPosition.fromArray(b.position), j = this._calculatePixelSize(e, G);
              $ = this._computeCharBoundingBoxes(
                N.chars,
                j,
                N.rotationMatrix,
                b.position,
                e,
                h,
                _tempMatrix4$4,
                z,
                U,
                a,
                c
              );
            }
          else {
            const G = this._computeObjectBoundingBox(N, P, D, z, U);
            if (!G || E && (G.maxX < 0 || G.maxY < 0 || G.minX > a || G.minY > c))
              continue;
            $.push(G);
          }
          k.push(...$);
        }
        if (!this._insertAndCheckCollision(v, k))
          continue;
        for (const N of k)
          v.insert(N);
        const V = {
          ...b,
          w: ((p = F[0]) == null ? void 0 : p.width) || 0,
          h: ((m = F[0]) == null ? void 0 : m.height) || 0
        };
        for (const N of w)
          d.get(N).push(V);
      }
    }
    this._updateCollisionDataForObjects(d), l.endTimeStatsItem("labelCollision");
  }
  _getScreenPosition(i, e, r, s) {
    vec4.set(i[0], i[1], i[2], 1), vec4.applyMatrix4(e), vec4.divideScalar(vec4.w);
    const a = (vec4.x + 1) / 2 * r, c = (-vec4.y + 1) / 2 * s;
    return [a, c, vec4.z];
  }
  _computeProjectedCharBoundingBoxes(i, e, r, s, a) {
    const c = [];
    for (let l = 0; l < i.length; l++) {
      const h = i[l], { x: d, y: f, size: p, width: m, height: y, rotation: x } = h;
      let v = m || p || 16, S = y || p || 16;
      if (x && x !== 0) {
        const w = v / 2, M = S / 2, P = Math.cos(x), D = Math.sin(x), O = [
          { x: -w, y: -M },
          { x: w, y: -M },
          { x: w, y: M },
          { x: -w, y: M }
        ].map((V) => ({
          x: V.x * P - V.y * D,
          y: V.x * D + V.y * P
        })), F = O.map((V) => V.x), k = O.map((V) => V.y);
        v = Math.max(...F) - Math.min(...F), S = Math.max(...k) - Math.min(...k);
      }
      const E = e[0] + r, b = e[1] + r;
      c.push({
        minX: d - (v + Math.max(E, 0) * 2) / 2,
        minY: f - (S + Math.max(b, 0) * 2) / 2,
        maxX: d + (v + Math.max(E, 0) * 2) / 2,
        maxY: f + (S + Math.max(b, 0) * 2) / 2
      });
    }
    return c;
  }
  _computeCharBoundingBoxes(i, e, r, s, a, c, l, h, d, f, p) {
    const m = [];
    for (let y = 0; y < i.length; y++) {
      const { width: x, height: v, offsetX: S, offsetY: E } = i[y];
      if (!x || !v)
        continue;
      const w = _tempOffset.set(S * e, E * e, 0, 0).applyMatrix4(r), M = _tempCharPosition.set(
        s[0] + w.x,
        s[1] + w.y,
        s[2] + w.z,
        1
      );
      _tempPosition.copy(M).sub(c).sub(a.position);
      const P = _tempPosition.applyMatrix4(r).normalize(), D = Math.max(Math.abs(P.z), 0.1);
      M.applyMatrix4(l), M.divideScalar(M.w);
      const L = (M.x + 1) / 2 * f, O = (-M.y + 1) / 2 * p, F = Math.hypot(x, v), k = h[0] + d, V = h[1] + d;
      m.push({
        minX: L - (F + Math.max(k, 0) * 2) / 2,
        minY: O - (F * D + Math.max(V, 0) * 2) / 2,
        maxX: L + (F + Math.max(k, 0) * 2) / 2,
        maxY: O + (F * D + Math.max(V, 0) * 2) / 2
      });
    }
    return m;
  }
  _computeObjectBoundingBox(i, e, r, s, a) {
    let { width: c, height: l, offsetX: h = 0, offsetY: d = 0 } = i;
    if (!c || !l)
      return null;
    const f = s[0] + a, p = s[1] + a;
    return c += Math.max(f, 0) * 2, l += Math.max(p, 0) * 2, {
      minX: e - c / 2 + h,
      minY: r - l / 2 + d,
      maxX: e + c / 2 + h,
      maxY: r + l / 2 + d
    };
  }
  _insertAndCheckCollision(i, e) {
    for (const r of e)
      if (i.collides(r))
        return !1;
    for (const r of e)
      i.insert(r);
    return !0;
  }
  _updateCollisionDataForObjects(i) {
    for (const [e, r] of i.entries())
      (!e._collisionData || e._collisionData.length !== r.length) && (e._collisionData = r, e._collisionUpdated = !0);
  }
  set margin(i) {
    typeof i == "number" ? this._margin = [i, i] : i instanceof Array && (this._margin = i);
  }
  get margin() {
    return this._margin;
  }
  set maxRenderDepth(i) {
    this._maxRenderDepth = i;
  }
  set restrictCount(i) {
    this._restrictCount = i;
  }
  get restrictCount() {
    return this._restrictCount;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(i) {
    this._needsUpdate = i;
  }
}
class RenderingAnimation {
  constructor(i) {
    _(this, "_rendering", null);
    _(this, "_mixer", null);
    _(this, "_customMixers", []);
    this._rendering = i;
  }
  update(i) {
    this._mixer && this._mixer.update(i.deltaSeconds);
    for (const e of this._customMixers)
      e.update(i.deltaSeconds);
  }
  addMixer(i) {
    this._customMixers.indexOf(i) === -1 && this._customMixers.push(i);
  }
  removeMixer(i) {
    let e = this._customMixers.indexOf(i);
    e !== -1 && this._customMixers.splice(e, 1);
  }
  get mixer() {
    return this._mixer || (this._mixer = new AnimationMixer(this._rendering.scene)), this._mixer;
  }
}
class VRButton {
  static createButton(i, e = {}) {
    const r = document.createElement("button");
    function s() {
      let d = null;
      async function f(y) {
        y.addEventListener("end", p), await i.xr.setSession(y), r.textContent = "EXIT VR", d = y;
      }
      function p() {
        d.removeEventListener("end", p), r.textContent = "ENTER VR", d = null;
      }
      r.style.display = "", r.style.cursor = "pointer", r.style.left = "calc(50% - 50px)", r.style.width = "100px", r.textContent = "ENTER VR";
      const m = {
        ...e,
        optionalFeatures: [
          "local-floor",
          "bounded-floor",
          "layers",
          ...e.optionalFeatures || []
        ]
      };
      r.onmouseenter = function() {
        r.style.opacity = "1.0";
      }, r.onmouseleave = function() {
        r.style.opacity = "0.5";
      }, r.onclick = function() {
        d === null ? navigator.xr.requestSession("immersive-vr", m).then(f) : (d.end(), navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-vr", m).then(f).catch((y) => {
          console.warn(y);
        }));
      }, navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-vr", m).then(f).catch((y) => {
        console.warn(y);
      });
    }
    function a() {
      r.style.display = "", r.style.cursor = "auto", r.style.left = "calc(50% - 75px)", r.style.width = "150px", r.onmouseenter = null, r.onmouseleave = null, r.onclick = null;
    }
    function c() {
      a(), r.textContent = "VR NOT SUPPORTED";
    }
    function l(d) {
      a(), console.warn("Exception when trying to call xr.isSessionSupported", d), r.textContent = "VR NOT ALLOWED";
    }
    function h(d) {
      d.style.position = "absolute", d.style.bottom = "20px", d.style.padding = "12px 6px", d.style.border = "1px solid #fff", d.style.borderRadius = "4px", d.style.background = "rgba(0,0,0,0.1)", d.style.color = "#fff", d.style.font = "normal 13px sans-serif", d.style.textAlign = "center", d.style.opacity = "0.5", d.style.outline = "none", d.style.zIndex = "999";
    }
    if ("xr" in navigator)
      return r.id = "VRButton", r.style.display = "none", h(r), navigator.xr.isSessionSupported("immersive-vr").then(function(d) {
        d ? s() : c(), d && VRButton.xrSessionIsGranted && r.click();
      }).catch(l), r;
    {
      const d = document.createElement("a");
      return window.isSecureContext === !1 ? (d.href = document.location.href.replace(/^http:/, "https:"), d.innerHTML = "WEBXR NEEDS HTTPS") : (d.href = "https://immersiveweb.dev/", d.innerHTML = "WEBXR NOT AVAILABLE"), d.style.left = "calc(50% - 90px)", d.style.width = "180px", d.style.textDecoration = "none", h(d), d;
    }
  }
  static registerSessionGrantedListener() {
    if (typeof navigator < "u" && "xr" in navigator) {
      if (/WebXRViewer\//i.test(navigator.userAgent))
        return;
      navigator.xr.addEventListener("sessiongranted", () => {
        VRButton.xrSessionIsGranted = !0;
      });
    }
  }
}
VRButton.xrSessionIsGranted = !1;
VRButton.registerSessionGrantedListener();
class RenderingXr {
  constructor(i) {
    _(this, "onSessionStart", () => {
    });
    _(this, "onSessionEnd", () => {
    });
    this._rendering = i;
  }
  init() {
    const i = this._rendering, e = i._renderer;
    if (i._useXR) {
      i.useMrt = !1, i.enableAnimationLoop = !0, i.animationLoopFrameTime = 16, i.autoOffsetRelativeCenter = !1;
      const r = i._camera, s = this.camera = r.clone();
      s.far = 2e3, s.name = "xrCamera";
      const a = this.xrCamera = new Group();
      a.name = "xrCameraGroup", a.add(s), i._engine.add(a), a.rotation.set(Math.PI / 2, 0, 0), document.body.appendChild(VRButton.createButton(e)), e.setAnimationLoop(i.render), e.xr.enabled = !0, e.xr.addEventListener("sessionstart", this.onSessionStart), e.xr.addEventListener("sessionend", this.onSessionEnd);
    }
  }
  dispose() {
    const i = this._rendering._renderer;
    i.xr.removeEventListener("sessionstart", this.onSessionStart), i.xr.removeEventListener("sessionend", this.onSessionEnd);
  }
}
class TimeStatsItem {
  constructor(i) {
    _(this, "_lastValue", 0);
    _(this, "_count", 0);
    _(this, "_total", 0);
    _(this, "_beginTime", 0);
    _(this, "_name");
    this._name = i;
  }
  begin(i) {
    this._beginTime = i;
  }
  end(i) {
    this._lastValue = i - this._beginTime, this._total = this._total + this._lastValue, this._count++;
  }
  add(i) {
    this._total += i, this._lastValue = i, this._count++;
  }
  get total() {
    return this._total;
  }
  get count() {
    return this._count;
  }
  get average() {
    return this._count === 0 ? 0 : this._total / this._count;
  }
  get lastValue() {
    return this._lastValue;
  }
  get name() {
    return this._name;
  }
  get beginTime() {
    return this._beginTime;
  }
}
class Stats {
  constructor() {
    _(this, "_timeStatsItem", {});
  }
  addTimeStatsItem(i) {
    const e = new TimeStatsItem(i);
    this._timeStatsItem[i] = e;
  }
  removeTimeStatsItem(i) {
    delete this._timeStatsItem[i];
  }
  beginTimeStatsItem(i, e) {
    this._timeStatsItem[i] || this.addTimeStatsItem(i), e == null && (e = performance.now()), this._timeStatsItem[i].begin(e);
  }
  endTimeStatsItem(i, e) {
    this._timeStatsItem[i] || this.addTimeStatsItem(i), e == null && (e = performance.now()), this._timeStatsItem[i].end(e);
  }
  addTimeStatsItemValue(i, e) {
    this._timeStatsItem[i] || this.addTimeStatsItem(i), this._timeStatsItem[i].add(e);
  }
  getSortedTimeStatsItems() {
    let i = Object.values(this._timeStatsItem);
    const e = performance.now();
    return i = i.filter((r) => e - r.beginTime < 5e3), i.sort((r, s) => s.average - r.average), i;
  }
  printString() {
    let i = `Stas:
`;
    const e = this.getSortedTimeStatsItems();
    for (const r of e)
      i += `${r.name}:
${r.average.toFixed(2)}	 ${r.lastValue.toFixed(2)}	 ${r.count}	 ${r.total.toFixed(2)}
`;
    return i;
  }
}
const CHECK_EVENT = 1, CHECK_VISIBLE = 2, _ascSort = (o, i) => o.distance - i.distance, _hasEventListener = (o, i) => {
  const e = o._listeners;
  if (e === void 0)
    return !1;
  let r = null;
  for (let s = 0, a = i.length; s < a; s++)
    if (r = e[i[s]], r && r.length > 0)
      return !0;
  return !1;
}, _intersectFlagObject = (o, i, e, r, s, a, c, l) => {
  let h = !0, d = !0;
  if (e & CHECK_EVENT && (c = c || _hasEventListener(o, a), c || (d = !1)), !(e & CHECK_VISIBLE && !o.visible) && (r && !r(o, i, s) && (d = !1), d && o.layers.test(i.layers) && o.raycast(i, s) === !1 && (h = !1), h === !0 && l === !0)) {
    const f = o.children;
    for (let p = 0, m = f.length; p < m; p++)
      _intersectFlagObject(f[p], i, e, r, s, a, c, !0);
  }
};
class CustomRaycaster extends Raycaster {
  constructor() {
    super(), this.mouse = new Vector2$1();
  }
  intersectFlagObjects(i, e, r, s = !0, a, c = []) {
    for (let l = 0, h = i.length; l < h; l++)
      _intersectFlagObject(i[l], this, e, a, c, r, !1, s);
    return c.sort(_ascSort), c;
  }
}
_(CustomRaycaster, "CHECK_EVENT", CHECK_EVENT), _(CustomRaycaster, "CHECK_VISIBLE", CHECK_VISIBLE);
class FlowEvent {
  constructor() {
    _(this, "isFlowEvent", !0);
  }
  execute() {
  }
}
class MultipleToggleEvent extends FlowEvent {
  constructor(e, r = 0) {
    super();
    _(this, "_currentIndex", 0);
    _(this, "_callbacks", []);
    r > e.length - 1 && (r = e.length - 1), r < 0 && (r = 0), this._currentIndex = r, Array.isArray(e) ? this._callbacks = e : console.warn("callbacks must be an array");
  }
  execute(e) {
    const r = this._callbacks[this._currentIndex];
    r && r(e, this._currentIndex), this._currentIndex++, this._currentIndex > this._callbacks.length - 1 && (this._currentIndex = 0);
  }
}
class EventParams {
  constructor(i, e, r) {
    _(this, "_engine", null);
    _(this, "_originalEvent", null);
    _(this, "_isPropagationStopped", !1);
    _(this, "_entityProxy", null);
    _(this, "_position");
    _(this, "_point");
    _(this, "target", null);
    _(this, "currentTarget", null);
    _(this, "intersection", null);
    this._engine = i, this._originalEvent = e, this.pixel = e && e.pixel, this.event = e && e.event, this._entityProxy = r;
  }
  get originalEvent() {
    return this._originalEvent;
  }
  stopPropagation() {
    this._isPropagationStopped = !0;
  }
  get isPropagationStopped() {
    return this._isPropagationStopped;
  }
  get entity() {
    return this._entityProxy ? this._entityProxy.entity : null;
  }
  get object() {
    return console.warn("EventParams.object is deprecated, use EventParams.currentTarget instead"), this.currentTarget;
  }
  get directObject() {
    return console.warn("EventParams.directObject is deprecated, use EventParams.target instead"), this.target;
  }
  get position() {
    if (this._position !== void 0)
      return this._position;
    if (this.intersection && this.intersection.point) {
      const i = this.intersection.point;
      this._position = [i.x, i.y, i.z];
    } else
      this._position = null;
    return this._position;
  }
  set position(i) {
    if (this._position !== void 0) {
      console.warn("EventParams.position is readonly after initialized");
      return;
    }
    if (i == null) {
      this._position = null;
      return;
    }
    if (i.isVector3) {
      this._position = [i.x, i.y, i.z];
      return;
    }
    this._position = i;
  }
  get point() {
    if (this._point !== void 0)
      return this._point;
    const i = this.position;
    return i === null ? this._point = null : this._point = this._engine.map.unprojectArrayCoordinate(i), this._point;
  }
}
class EntityProxy {
  constructor(i, e) {
    _(this, "_hasComputed", !1);
    this._object = i, this._intersection = e;
  }
  _computeEntity() {
    const i = this._object, e = this._intersection;
    if (i.getEntityByIntersection)
      return i.getEntityByIntersection(e);
    let r = -1;
    if (e.instanceId !== void 0 ? r = e.instanceId : e.face !== void 0 && e.face !== null ? i.getEntityIndexByFace && (r = i.getEntityIndexByFace(e.faceIndex, e.face.a)) : e.index !== void 0 && (r = e.index), r < 0)
      return null;
    const s = i.getEntityByIndex(r);
    return s && s.pairs && this._addPointProperty(s, i), s;
  }
  _addPointProperty(i) {
    Object.defineProperty(i.pairs, "point", {
      get: () => i.value.coordinates
    });
  }
  get entity() {
    return this._hasComputed || (this._entity = this._computeEntity(), this._hasComputed = !0), this._entity;
  }
  get intersection() {
    return this._intersection;
  }
}
class EventThrottle {
  constructor() {
    this._eventToTriggerMap = {}, this._isBusy = !1, this._isEmpty = !0;
  }
  restart() {
    this._eventToTriggerMap = {};
  }
  putEvent(i, e) {
    this._eventToTriggerMap[i] || (this._eventToTriggerMap[i] = e, this._isEmpty = !1);
  }
  async triggerEvents(i) {
    if (this._isBusy)
      return;
    this._isBusy = !0;
    const e = this._eventToTriggerMap;
    this._eventToTriggerMap = {}, this._isEmpty = !0;
    try {
      await i(e);
    } catch (r) {
      console.error("error occurs when triggering event", r);
    } finally {
      this._isBusy = !1;
    }
  }
  get isEmpty() {
    return this._isEmpty;
  }
  get isBusy() {
    return this._isBusy;
  }
}
const xe = class {
  constructor(i) {
    _(this, "_mouse", new Vector2$1());
    _(this, "_mousePosition", new Vector2$1());
    _(this, "_intersections");
    _(this, "_engine", null);
    _(this, "_currentMouseEnterLeaveObjects");
    _(this, "_handleTriggerEvents", async (i) => {
      await this._triggerEventOfObjects(i) && this._triggerMouseLeaveEvents(i), this._lastMouseEnterLeaveObjects = this._currentMouseEnterLeaveObjects, this._engine.requestRender();
    });
    _(this, "_triggerEventOfObjects", async (i) => {
      const e = this._engine, r = Object.keys(i), s = i[r[0]];
      this._updateMouse(s);
      const a = this._currentMouseEnterLeaveObjects, c = a && a.keys();
      let l = !1;
      c.forEach((S) => {
        l = l || _hasEventListener(S, r);
      }), this._intersections = await e.rendering.picking.pickIntersectionsOfEventObjects(this._mousePosition, r);
      const h = this._currentMouseEnterLeaveObjects = /* @__PURE__ */ new Map();
      if (this._intersections.length === 0)
        return await this._triggerRootObjectEvents(i, null), l;
      const d = this._intersections[0];
      let p = d.object;
      const m = p, y = {};
      let x = null, v = null;
      for (; p; ) {
        let S = !1;
        v = [];
        const E = p._listeners;
        for (const D of r)
          !E || !E[D] || E[D].length === 0 || v.push(D);
        const b = E && Object.keys(E) || [];
        (b.includes(xe.EVENT_NAME_MOUSE_ENTER) || b.includes(xe.EVENT_NAME_MOUSE_LEAVE)) && (S = !0), p.isEventEntitySupported ? x = new EntityProxy(p, d) : x = null;
        let w = !1, M = !1, P = null;
        if (S)
          if (h.set(p, x), !this._lastMouseEnterLeaveObjects.has(p))
            w = !0;
          else {
            const D = this._lastMouseEnterLeaveObjects.get(p);
            p.isEventEntitySupported && !this._isSameEntity(x, D) && (w = !0, M = !0, P = D);
          }
        for (const D of v) {
          if (y[D] || D === xe.EVENT_NAME_MOUSE_ENTER && !w)
            continue;
          if (D === xe.EVENT_NAME_MOUSE_LEAVE) {
            if (!M)
              continue;
            P && (x = P);
          }
          const L = i[D], F = p._listeners[D], k = new EventParams(this._engine, L, x);
          k.target = m, k.currentTarget = p, k.intersection = d, this._executeCallbacks(F, k), k.isPropagationStopped && (y[D] = !0);
        }
        p = p.parent;
      }
      return await this._triggerRootObjectEvents(i, d, y), l;
    });
    _(this, "_isSameEntity", (i, e) => {
      var a, c;
      const r = (a = i == null ? void 0 : i.entity) == null ? void 0 : a.index, s = (c = e == null ? void 0 : e.entity) == null ? void 0 : c.index;
      return r !== void 0 && r === s;
    });
    _(this, "_handlePointerDown", (i) => {
      this._eventThrottle.putEvent(xe.EVENT_NAME_POINTER_DOWN, i), this._engine.requestRender();
    });
    _(this, "_handlePointerUp", (i) => {
      this._eventThrottle.putEvent(xe.EVENT_NAME_POINTER_UP, i), this._engine.requestRender();
    });
    _(this, "_handleClick", (i) => {
      this._eventThrottle.putEvent(xe.EVENT_NAME_CLICK, i), this._engine.requestRender();
    });
    _(this, "_handleDblClick", (i) => {
      this._eventThrottle.putEvent(xe.EVENT_NAME_DOUBLE_CLICK, i), this._engine.requestRender();
    });
    _(this, "_handleRightClick", (i) => {
      this._eventThrottle.putEvent(xe.EVENT_NAME_RIGHT_CLICK, i), this._engine.requestRender();
    });
    _(this, "_handleRightDblClick", (i) => {
      this._eventThrottle.putEvent(xe.EVENT_NAME_RIGHT_DOUBLE_CLICK, i), this._engine.requestRender();
    });
    _(this, "_handleMouseMove", (i) => {
      this._eventThrottle.putEvent(xe.EVENT_NAME_MOUSE_MOVE, i), this._eventThrottle.putEvent(xe.EVENT_NAME_MOUSE_ENTER, i), this._eventThrottle.putEvent(xe.EVENT_NAME_MOUSE_LEAVE, i), this._engine.requestRender();
    });
    _(this, "_updateMouse", (i) => {
      const e = this._engine, r = e.map.getResolution();
      let s = i.pixel[0], a = i.pixel[1];
      const c = e.map.map.control;
      c && (s = s / (c.startScaleX || 1), a = a / (c.startScaleY || 1));
      const l = s / r.x, h = a / r.y;
      this._mouse.set(l * 2 - 1, 1 - h * 2), this._mousePosition.set(s, a);
    });
    this._engine = i, this._eventThrottle = new EventThrottle(), this._isEventHandleBusy = !1, this._currentMouseEnterLeaveObjects = /* @__PURE__ */ new Map(), this._lastMouseEnterLeaveObjects = /* @__PURE__ */ new Map();
  }
  beginFrame() {
  }
  endFrame() {
    const i = this._eventThrottle;
    i.isBusy || i.isEmpty || i.triggerEvents(this._handleTriggerEvents);
  }
  _triggerMouseLeaveEvents(i) {
    const e = this._currentMouseEnterLeaveObjects, r = this._lastMouseEnterLeaveObjects;
    for (const [s, a] of r)
      if (!e.has(s)) {
        const c = s._listeners;
        if (!c || !c[xe.EVENT_NAME_MOUSE_LEAVE] || c[xe.EVENT_NAME_MOUSE_LEAVE].length === 0)
          continue;
        const l = i[xe.EVENT_NAME_MOUSE_MOVE], h = c[xe.EVENT_NAME_MOUSE_LEAVE], d = new EventParams(this._engine, l, a);
        d.target = s, d.currentTarget = s, d.intersection = a && a.intersection, this._executeCallbacks(h, d);
      }
  }
  async _triggerRootObjectEvents(i, e, r) {
    const s = this._engine.map, a = s._listeners;
    if (!a || Object.keys(a).length === 0)
      return;
    const c = Object.keys(i);
    let l = null;
    e && (l = e.point);
    let h = !0;
    for (const d of c) {
      if (r && r[d])
        continue;
      const f = a[d];
      if (!f || f.length === 0)
        continue;
      !l && h && (h = !1, l = await this._engine.rendering.picking.pickWorldPosition(this._mousePosition));
      const p = i[d], m = new EventParams(this._engine, p, null);
      m.target = e && e.object, m.currentTarget = s, m.intersection = e, m.position = l, this._executeCallbacks(f, m);
    }
  }
  _executeCallbacks(i, e) {
    for (const r of i) {
      if (!r)
        continue;
      const s = e.event;
      if (s && (s.defaultPrevented || s.domEvent && s.domEvent.defaultPrevented))
        return;
      try {
        r.isFlowEvent ? r.execute(e) : r(e);
      } catch (a) {
        console.error("error occurs when triggering callback", a);
      }
    }
  }
  bind(i, e, r) {
    typeof i == "string" && (r = e, e = i, i = this._engine.map), console.warn("bind is deprecated, use object.addEventListener instead"), i.addEventListener(e, r);
  }
  unbind(i, e, r) {
    typeof i == "string" && (r = e, e = i, i = this._engine.map), console.warn("unbind is deprecated, use object.removeEventListener instead"), i.removeEventListener(e, r);
  }
  markEventProxy(i, e) {
    console.warn("markEventProxy is deprecated, no need to call this method");
  }
  createMultipleToggleEvent(i, e = 0) {
    return new MultipleToggleEvent(i, e);
  }
  dispose() {
  }
};
let EngineEvent = xe;
_(EngineEvent, "EVENT_NAME_CLICK", "click"), _(EngineEvent, "EVENT_NAME_DOUBLE_CLICK", "dblclick"), _(EngineEvent, "EVENT_NAME_RIGHT_CLICK", "rightclick"), _(EngineEvent, "EVENT_NAME_RIGHT_DOUBLE_CLICK", "rightdblclick"), _(EngineEvent, "EVENT_NAME_MOUSE_MOVE", "mousemove"), _(EngineEvent, "EVENT_NAME_MOUSE_ENTER", "mouseenter"), _(EngineEvent, "EVENT_NAME_MOUSE_LEAVE", "mouseleave"), _(EngineEvent, "EVENT_NAME_POINTER_DOWN", "pointerdown"), _(EngineEvent, "EVENT_NAME_POINTER_UP", "pointerup");
const _raycaster$6 = new CustomRaycaster(), _defaultPickEventNames = [
  EngineEvent.EVENT_NAME_CLICK,
  EngineEvent.EVENT_NAME_DOUBLE_CLICK,
  EngineEvent.EVENT_NAME_MOUSE_MOVE,
  EngineEvent.EVENT_NAME_POINTER_DOWN,
  EngineEvent.EVENT_NAME_POINTER_UP,
  EngineEvent.EVENT_NAME_MOUSE_ENTER,
  EngineEvent.EVENT_NAME_MOUSE_LEAVE
], De = class {
  constructor(i) {
    _(this, "_useDepthPicking", !1);
    _(this, "_positionCache", {});
    _(this, "_seaLevelPositionCache", {});
    _(this, "_intersectionCache", {});
    _(this, "pixelToNdc", (i) => {
      const r = this._rendering.resolution;
      return new Vector2$1(i.x / r.x * 2 - 1, 1 - i.y / r.y * 2);
    });
    _(this, "ndcToPixel", (i) => {
      const r = this._rendering.resolution;
      return new Vector2$1((i.x + 1) / 2 * r.x, (1 - i.y) / 2 * r.y);
    });
    this._rendering = i;
  }
  init() {
  }
  dispose() {
  }
  beginFrame() {
    this._positionCache = {}, this._seaLevelPositionCache = {}, this._intersectionCache = {
      [De.PICK_INTERSECTION_TYPE_ALL]: {},
      [De.PICK_INTERSECTION_TYPE_VISIBLE]: {},
      [De.PICK_INTERSECTION_TYPE_EVENT]: {}
    }, this._rendering.features.depthPicking.enabled = this._useDepthPicking;
  }
  endFrame() {
  }
  async pickWorldPosition(i) {
    let e = await this.pickSceneWorldPosition(i);
    return e || (e = this.pickSeaLevelWorldPosition(i)), e;
  }
  async pickWorldPositionFromNdc(i) {
    const e = this.ndcToPixel(i);
    return await this.pickWorldPosition(e);
  }
  async pickSceneWorldPosition(i) {
    const e = `${Math.round(i.x)}_${Math.round(i.y)}`;
    if (this._positionCache[e] !== void 0)
      return this._positionCache[e];
    let r = await this._pickSceneWorldPosition(i);
    return this._positionCache[e] = r, r;
  }
  async pickSceneWorldPositionFromNdc(i) {
    const e = this.ndcToPixel(i);
    return await this.pickSceneWorldPosition(e);
  }
  async _pickSceneWorldPosition(i) {
    if (this._useDepthPicking)
      return await this._pickSceneWorldPositionFromDepth(i);
    const e = await this.pickIntersectionsOfVisibleObjects(i);
    let r = null;
    for (let a = 0, c = e.length; a < c; a++)
      if (!(e[a].object.isPoints || e[a].object.isLine || e[a].object.collisionDisabled || e[a].object.visible === !1)) {
        r = e[a];
        break;
      }
    if (r === null || !r.point)
      return null;
    let s = new Vector3$1();
    return s.copy(r.point), s;
  }
  async _pickSceneWorldPositionFromDepth(i) {
    const e = this._rendering, r = e.features.depthPicking, s = this.pixelToNdc(i), a = await r.pickDepth(i.x, (s.y + 1) * 0.5 * e.resolution.y);
    if (a === null || a > 0.999999)
      return null;
    const c = new Vector3$1(s.x, s.y, 2 * a - 1), l = e.camera;
    return c.unproject(l), c;
  }
  pickIntersections(i) {
    return this._pickIntersectionByRayRasting(
      De.PICK_INTERSECTION_TYPE_ALL,
      i
    );
  }
  async pickIntersectionsOfVisibleObjects(i) {
    return this._pickIntersectionByRayRasting(
      De.PICK_INTERSECTION_TYPE_VISIBLE,
      i,
      null
    );
  }
  async pickIntersectionsOfEventObjects(i, e = _defaultPickEventNames) {
    return this._pickIntersectionByRayRasting(
      De.PICK_INTERSECTION_TYPE_EVENT,
      i,
      e
    );
  }
  async _pickIntersectionByRayRasting(i, e, r = _defaultPickEventNames) {
    const s = `${Math.round(e.x)}_${Math.round(e.y)}`, a = this._intersectionCache[i];
    if (a[s] !== void 0)
      return a[s];
    const c = this._rendering.camera, l = this.pixelToNdc(e);
    _raycaster$6.setFromCamera(l, c), _raycaster$6.mouse.copy(l);
    let h = null;
    if (i === De.PICK_INTERSECTION_TYPE_ALL)
      h = _raycaster$6.intersectObjects(this._rendering.objectsScene.children, !0);
    else if (i === De.PICK_INTERSECTION_TYPE_VISIBLE) {
      const d = CustomRaycaster.CHECK_VISIBLE;
      h = _raycaster$6.intersectFlagObjects(
        this._rendering.objectsScene.children,
        d,
        null,
        !0
      );
    } else if (i === De.PICK_INTERSECTION_TYPE_EVENT) {
      const d = CustomRaycaster.CHECK_EVENT | CustomRaycaster.CHECK_VISIBLE;
      h = _raycaster$6.intersectFlagObjects(
        this._rendering.objectsScene.children,
        d,
        r,
        !0
      );
    }
    return a[s] = h, h;
  }
  pickTerrainWorldPosition(i) {
    const e = this._pickIntersectionsWithCheckCallback(i, (r, s) => r.isMesh && r.isTerrainTile);
    return e.length > 0 ? e[0].point : null;
  }
  _pickIntersectionsWithCheckCallback(i, e) {
    return _raycaster$6.set(i.origin, i.direction), _raycaster$6.intersectFlagObjects(
      this._rendering.objectsScene.children,
      0,
      null,
      !0,
      e
    );
  }
  pickSeaLevelWorldPositionFromNdc(i) {
    const e = this.ndcToPixel(i);
    return this.pickSeaLevelWorldPosition(e);
  }
  pickSeaLevelWorldPosition(i) {
    const e = `${Math.round(i.x)}_${Math.round(i.y)}`;
    if (this._seaLevelPositionCache[e] !== void 0)
      return this._seaLevelPositionCache[e];
    let r = this._rendering._engine.map.pickSeaLevelWorldPosition(i);
    return this._seaLevelPositionCache[e] = r, r;
  }
  get useDepthPicking() {
    return this._useDepthPicking;
  }
  set useDepthPicking(i) {
    this._useDepthPicking = i;
  }
};
let Picking = De;
_(Picking, "PICK_INTERSECTION_TYPE_ALL", 1), _(Picking, "PICK_INTERSECTION_TYPE_VISIBLE", 2), _(Picking, "PICK_INTERSECTION_TYPE_EVENT", 3);
function matrix4EqualsEpsilon(o, i, e = 1e-10) {
  e = defaultValue$1(e, 0);
  const r = o.elements, s = i.elements;
  return r === s || defined$2(r) && defined$2(s) && Math.abs(r[0] - s[0]) <= e && Math.abs(r[1] - s[1]) <= e && Math.abs(r[2] - s[2]) <= e && Math.abs(r[3] - s[3]) <= e && Math.abs(r[4] - s[4]) <= e && Math.abs(r[5] - s[5]) <= e && Math.abs(r[6] - s[6]) <= e && Math.abs(r[7] - s[7]) <= e && Math.abs(r[8] - s[8]) <= e && Math.abs(r[9] - s[9]) <= e && Math.abs(r[10] - s[10]) <= e && Math.abs(r[11] - s[11]) <= e && Math.abs(r[12] - s[12]) <= e && Math.abs(r[13] - s[13]) <= e && Math.abs(r[14] - s[14]) <= e && Math.abs(r[15] - s[15]) <= e;
}
class RenderState {
  constructor(i) {
    _(this, "_stage", null);
    _(this, "_time", 0);
    _(this, "_startTime", 0);
    _(this, "_elapsedTime", 0);
    _(this, "_viewChanged", !1);
    _(this, "_viewMatrixWorld", new Matrix4());
    _(this, "_viewMatrixWorldInverse", new Matrix4());
    _(this, "_projectionMatrix", new Matrix4());
    _(this, "_cameraMatrix", new Matrix4());
    _(this, "_cameraMatrixInverse", new Matrix4());
    _(this, "_cameraOffsetX", 0);
    _(this, "_cameraOffsetY", 0);
    _(this, "_cameraOffset", new Vector3$1());
    _(this, "_frameCount", 0);
    _(this, "_viewStableFrameCount", 0);
    _(this, "_isRendererRecreated", !1);
    _(this, "_cameraLocation", new Vector3$1());
    _(this, "_resolution", new Vector2$1());
    _(this, "_pixelRatio", 1);
    _(this, "_isResolutionChanged", !1);
    _(this, "_isPixelRatioChanged", !1);
    _(this, "_isResolutionOrPixelRatioChanged", !1);
    _(this, "_inRenderVideoMode", !1);
    this._rendering = i, this._startTime = new Date().getTime(), this._time = this._startTime;
  }
  beginFrame(i, e) {
    this._deltaTime = e - this._time, this._deltaSeconds = this._deltaTime / 1e3, this._time = e, this._elapsedTime = e - this._startTime;
    const r = i.renderer.info.render.frame;
    r < this._frameCount && (this._isRendererRecreated = !0), this._frameCount = r;
    const s = i.camera, a = s.matrixWorld, c = s.projectionMatrix;
    !matrix4EqualsEpsilon(a, this._viewMatrixWorld, 1e-8) || !matrix4EqualsEpsilon(c, this._projectionMatrix, 1e-8) ? (this._viewChanged = !0, this._viewStableFrameCount = 0, i.requestRender()) : (this._viewChanged = !1, this._viewStableFrameCount++), this._viewMatrixWorld.copy(s.matrixWorld), this._viewMatrixWorldInverse.copy(s.matrixWorldInverse), this._projectionMatrix.copy(s.projectionMatrix);
    const l = i.resolution;
    l.x !== this._resolution.x || l.y !== this._resolution.y ? (this._isResolutionChanged = !0, this._resolution.set(l.x, l.y)) : this._isResolutionChanged = !1;
    const h = i.pixelRatio;
    h !== this._pixelRatio ? (this._isPixelRatioChanged = !0, this._pixelRatio = h) : this._isPixelRatioChanged = !1, this._isResolutionOrPixelRatioChanged = this._isResolutionChanged || this._isPixelRatioChanged, this._inRenderVideoMode = !!i._videoConfig;
  }
  endFrame() {
    this._isRendererRecreated = !1;
  }
  updateCameraOffsetState(i, e, r, s) {
    this._cameraMatrix.copy(i.matrixWorld), this._cameraMatrixInverse.copy(i.matrixWorldInverse), this._cameraOffsetX = e, this._cameraOffsetY = r, this._cameraOffset.set(e, r, s);
  }
  getDepthByDistance(i) {
    const e = this._rendering.camera, r = e.far, s = e.near;
    return e.isPerspectiveCamera ? this._rendering.renderer.capabilities.logarithmicDepthBuffer ? Math.log(i + 1) / Math.log(r + 1) : r * (i - s) / (i * (r - s)) : (r - i) / (r - s);
  }
  get time() {
    return this._time;
  }
  get viewChanged() {
    return this._viewChanged;
  }
  get viewMatrixWorld() {
    return this._viewMatrixWorld;
  }
  get viewMatrixWorldInverse() {
    return this._viewMatrixWorldInverse;
  }
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  get cameraMatrix() {
    return this._cameraMatrix;
  }
  get cameraMatrixInverse() {
    return this._cameraMatrixInverse;
  }
  get cameraOffsetX() {
    return this._cameraOffsetX;
  }
  get cameraOffsetY() {
    return this._cameraOffsetY;
  }
  get deltaTime() {
    return this._deltaTime;
  }
  get elapsedTime() {
    return this._elapsedTime;
  }
  get deltaSeconds() {
    return this._deltaSeconds;
  }
  get frameCount() {
    return this._frameCount;
  }
  get viewStableFrameCount() {
    return this._viewStableFrameCount;
  }
  get cameraOffset() {
    return this._cameraOffset;
  }
  get isRendererRecreated() {
    return this._isRendererRecreated;
  }
  set stage(i) {
    this._stage = i;
  }
  get stage() {
    return this._stage;
  }
  get isResolutionOrPixelRatioChanged() {
    return this._isResolutionOrPixelRatioChanged;
  }
  get isResolutionChanged() {
    return this._isResolutionChanged;
  }
  get isPixelRatioChanged() {
    return this._isPixelRatioChanged;
  }
}
class MicroTask {
  constructor(i, e = 0) {
    this.taskFunc = i, this.priority = e, this._isCancelled = !1, this._isStart = !1, this._promise = new Promise((r, s) => {
      this._resolve = r, this._reject = s;
    });
  }
  execute() {
    if (this._isStart = !0, this.isCancelled()) {
      console.warn("MicroTask: Task was cancelled");
      return;
    }
    try {
      const i = this.taskFunc();
      Promise.resolve(i).then(this._resolve).catch(this._reject);
    } catch (i) {
      this._reject(new Error("Task failed:", i));
    }
  }
  cancel() {
    this._isCancelled = !0;
  }
  isCancelled() {
    return this._isCancelled;
  }
  isStart() {
    return this._isStart;
  }
  get promise() {
    return this._promise;
  }
}
class RenderingMicroTaskScheduler {
  constructor(i) {
    _(this, "_frameDurationList", []);
    _(this, "_maxTaskCount", 1e3);
    _(this, "_taskQueue", []);
    this._rendering = i;
  }
  beginFrame() {
    if (this._frameStartTime = performance.now(), this._lastFrameStartTime) {
      const i = this._frameStartTime - this._lastFrameStartTime;
      this._frameDurationList.push(i), this._frameDurationList.length > 5 && this._frameDurationList.shift();
    }
    this._lastFrameStartTime = this._frameStartTime;
  }
  endFrame() {
    if (this._frameDurationList.length < 5)
      return;
    const i = performance.now(), e = i - this._frameStartTime, r = this._frameDurationList.reduce((c, l) => c + l, 0) / this._frameDurationList.length;
    let s = Math.min(16, r) - e;
    const a = this._taskQueue;
    for (; a.length > 0; ) {
      const { task: c } = this._taskQueue.shift();
      if (c.execute(), performance.now() - i >= s && a.length <= this._maxTaskCount)
        break;
    }
  }
  executeAllTasks() {
    for (; this._taskQueue.length > 0; ) {
      const { task: i } = this._taskQueue.shift();
      i.execute();
    }
  }
  addTask(i, e = 0) {
    const r = new MicroTask(i, e);
    return this._taskQueue.push({ task: r, priority: e }), this._taskQueue.sort((s, a) => a.priority - s.priority), r;
  }
  get maxTaskCount() {
    return this._maxTaskCount;
  }
  set maxTaskCount(i) {
    this._maxTaskCount = i;
  }
  get taskCount() {
    return this._taskQueue.length;
  }
}
const _warnCache = {};
function warnOnce(o) {
  o in _warnCache || (_warnCache[o] = !0, console.warn(o));
}
const _errorCache = {};
function errorOnce(o) {
  o in _errorCache || (_errorCache[o] = !0, console.error(o));
}
const _tempMatrix4$3 = new Matrix4(), _tempSphere = new Sphere(), _tempFrustum = new Frustum(), _opaqueSort = (o, i) => o.groupOrder !== i.groupOrder ? o.groupOrder - i.groupOrder : o.renderOrder !== i.renderOrder ? o.renderOrder - i.renderOrder : o.material.name !== i.material.name ? o.material.name > i.material.name ? 1 : -1 : o.material.type !== i.material.type ? o.material.type - i.material.type : o.material.id !== i.material.id ? o.material.id - i.material.id : o.z !== i.z ? o.z - i.z : o.id - i.id, _transparentSort = (o, i) => o.groupOrder !== i.groupOrder ? o.groupOrder - i.groupOrder : o.renderOrder !== i.renderOrder ? o.renderOrder - i.renderOrder : o.z !== i.z ? i.z - o.z : o.id - i.id, debugVertexShader = `
    #include <common>
    #include <logdepthbuf_pars_vertex>
    void main() {
        #include <begin_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
    }
`, debugFragmentShader = `
    #include <common>
    #include <logdepthbuf_pars_fragment>
    uniform vec3 color;
    void main() {
        gl_FragColor = vec4( color, 1.0 );
        #include <logdepthbuf_fragment>
    }
`, debugColors = [
  4886754,
  5289385,
  7184241,
  12888157,
  14191694,
  12017001,
  10189749
], DEBUG_MODE_NONE = 0, DEBUG_MODE_MESH = 1, DEBUG_MODE_MATERIAL = 2, DEBUG_MODE_OBJECT = 3;
let __debugObjectId = 1;
class EngineRendering {
  constructor(i, e = {}) {
    _(this, "_engine");
    _(this, "_outputEncoding");
    _(this, "_enableAnimationLoop");
    _(this, "_animationLoopFrameTime");
    _(this, "_uniforms");
    _(this, "_main");
    _(this, "_bloom");
    _(this, "_ssr");
    _(this, "_composition");
    _(this, "_label");
    _(this, "_renderState");
    _(this, "_camera");
    _(this, "_canvas");
    _(this, "_context");
    _(this, "_renderer");
    _(this, "_scene");
    _(this, "_weather");
    _(this, "_rawCamera");
    _(this, "_useMRT", !1);
    _(this, "_isUseMRTChanged", !1);
    _(this, "_freezeUpdate", !1);
    _(this, "_isRunning", !1);
    _(this, "_needsRenderImmediately", !1);
    _(this, "_needsRenderNext", !1);
    _(this, "_beforeRenderListeners", []);
    _(this, "_prepareRenderListeners", []);
    _(this, "_startTime", 0);
    _(this, "_pixelRatio", window.devicePixelRatio);
    _(this, "_resolution", new Vector2$1());
    _(this, "_sky", null);
    _(this, "_debugShaderType", 0);
    _(this, "_beforeScenePrepareRenderObjects", /* @__PURE__ */ new Set());
    _(this, "_beforeSceneRenderObjects", /* @__PURE__ */ new Set());
    _(this, "_onRenderModeChangedObjects", /* @__PURE__ */ new Set());
    _(this, "_onRenderPassChangedObjects", /* @__PURE__ */ new Set());
    _(this, "_useClip");
    _(this, "_wireframe", !0);
    _(this, "_debugMaterial", null);
    _(this, "_debugMode", DEBUG_MODE_NONE);
    _(this, "_autoOffsetRelativeCenter", !0);
    _(this, "_clampCameraNearFar", !1);
    _(this, "_options", {});
    _(this, "lastRenderTime", 0);
    _(this, "_lastClockTime", 0);
    _(this, "_contextParameters", {
      alpha: !0,
      stencil: !0,
      antialias: !1,
      powerPreference: "high-performance",
      preserveDrawingBuffer: !1,
      premultipliedAlpha: !1
    });
    _(this, "_needsReCreateRenderer", !1);
    _(this, "_frameDuration", 100);
    _(this, "_useHighPrecisionBuffer", !0);
    _(this, "handleShaderBeforeResolve", (i, e, r) => {
      if (this._useMRT) {
        const s = this._renderer.getRenderTarget();
        s && s.isWebGLMultipleRenderTargets && (e = this.convertMrtSupportedFragment(e));
      } else
        e = this.convertNMrtSupportedFragment(e, r.shaderID);
      return r.shaderID === "basic" && (e = `#define BASIC
uniform vec3 emissive;
` + e), i = addClipableToVertexShader(i), e = addClipableToFragmentShader(e), {
        vertexShader: i,
        fragmentShader: e
      };
    });
    _(this, "handleShaderBeforeCompile", (i, e, r) => {
      if (i = addEditableToVertexShader(i), this._useMRT) {
        const s = this._renderer.getRenderTarget();
        s && s.isWebGLMultipleRenderTargets && r.isRawShaderMaterial && r.glslVersion !== GLSL3 && (i = [
          "#version 300 es",
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture"
        ].join(`
`) + `
` + i, e = [
          "#version 300 es",
          "#define varying in",
          "layout(location = 0) out highp vec4 pc_fragColor;",
          "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + e);
      }
      return {
        vertexShader: i,
        fragmentShader: e
      };
    });
    _(this, "handleMaterialBeforeCompile", (i, e) => {
      i.handleMaterialBeforeCompile && i.handleMaterialBeforeCompile(this._engine, this), this.shadow.enabled && this.shadow.method === "csm" && this.shadow.updateCSMShadow(i, e);
    });
    _(this, "convertMrtSupportedFragment", (i) => i = this._main.sceneRendering.modifyFragmentShader(i));
    _(this, "convertNMrtSupportedFragment", (i, e) => i = addNMrtSupportFragmentShader(i));
    _(this, "_renderVideoFrame", async () => {
      const i = this._videoConfig, e = i.frameCount, r = this._videoFrameIndex;
      if (r >= e) {
        this.startRenderLoop(), this._renderVideoResolve();
        const c = this._videoSavedState;
        this._resolution.copy(this._engine.map.getResolution()), this._pixelRatio = c.pixelRatio, this.features.antialias.enabled = c.aaEnabled, this.features.antialias.method = c.aaMethod, this._videoConfig = null;
        return;
      }
      const s = this._startTime + r / e * i.duration * 1e3;
      this.renderScene(s);
      let a = !0;
      if (this._taskScheduler.taskCount > 0 && (this._taskScheduler.executeAllTasks(), a = !1), a && this._scene.traverse((l) => {
        l.isRenderAsyncObject && (l.isInStableRenderState() || (a = !1));
      }), a && (a = this._main.isInStableRenderState()), a) {
        const c = await new Promise(
          (f) => this._canvas.toBlob(f, "image/png")
        ), l = `frame_${String(r).padStart(5, "0")}.png`, d = await (await i.directoryHandle.getFileHandle(l, { create: !0 })).createWritable();
        await d.write(c), await d.close(), this._videoFrameIndex++, i.onProgress && i.onProgress({ frameIndex: r, frameCount: e }), requestAnimationFrame(this._renderVideoFrame);
      } else
        requestAnimationFrame(this._renderVideoFrame);
    });
    _(this, "render", () => {
      if (!this._isRunning)
        return;
      const i = new Date().valueOf();
      if (this._engine.clock.tick(i - this._lastClockTime), this._lastClockTime = i, this._beginFrame(), this._useXR || requestAnimationFrame(this.render), (this._needsRenderNext || this._enableAnimationLoop) && this._animationLoopFrameTime < 17 && (this._needsRenderImmediately = !0), !(this._needsRenderImmediately || (this._needsRenderNext || this._enableAnimationLoop) && i - this.lastRenderTime >= this._animationLoopFrameTime)) {
        this._endFrame();
        return;
      }
      let e = this._needsRenderImmediately ? 0 : i - this.lastRenderTime - this._animationLoopFrameTime;
      e > this._animationLoopFrameTime - 16 && (e = this._animationLoopFrameTime - 16), this.lastRenderTime = i - e, this._needsRenderImmediately = !1, this._needsRenderNext = !1;
      const r = this._stats;
      r.beginTimeStatsItem("renderAll");
      try {
        this.renderScene(i);
      } catch (s) {
        console.error("renderScene error", s);
      } finally {
        r.endTimeStatsItem("renderAll"), this._endFrame();
      }
    });
    _(this, "scaleZAtCurrentPosition", () => {
      const i = this._engine.map, e = i.getScaleAt(i.getCenter());
      this.scene.scale.z = e;
    });
    _(this, "showCurrentViewFrustum", () => {
      this._currentViewCamera ? this._currentViewCamera.copy(this._camera) : this._currentViewCamera = this._camera.clone();
      const i = this._currentViewCameraHelper = new CameraHelper(this._currentViewCamera);
      i.matrixAutoUpdate = !1, this.add(i);
    });
    _(this, "removeCurrentViewFrustum", () => {
      !this._currentViewCameraHelper || (this.remove(this._currentViewCameraHelper), this._currentViewCameraHelper = null, this._currentViewCamera = null);
    });
    this._engine = i;
    const r = this._options = this.getInitialConfig(e);
    Object.assign(this._contextParameters, r.contextParameters), r.preserveDrawingBuffer && (this._contextParameters.preserveDrawingBuffer = !0);
    const s = r.features.antialias;
    this._contextParameters.antialias = s.enabled && s.method === "msaa", this._enableAnimationLoop = r.enableAnimationLoop || !1, this._animationLoopFrameTime = r.animationLoopFrameTime || 16, this._useMRT = r.useMRT || !1, this._useXR = r.useXR || !1, this._pixelRatio = r.pixelRatio || window.devicePixelRatio, this._resolution.set(e.resolution.x, e.resolution.y), this._uniforms = {
      time: {
        value: 0
      },
      elapsedTime: {
        value: 0
      },
      pixelRatio: {
        value: this._pixelRatio
      },
      zoomUnits: {
        value: 1
      },
      resolution: {
        value: this._resolution.clone()
      }
    }, Object.freeze(this._uniforms), this._stats = new Stats(this), this._main = new RenderingMainNew(this, r), this._picking = new Picking(this), this._label = new RenderingLabel(this), this._collision = new RenderingCollision(this), this._animation = new RenderingAnimation(this), this._xr = new RenderingXr(this), this._renderState = new RenderState(this), this._taskScheduler = new RenderingMicroTaskScheduler(this);
  }
  getInitialConfig(i) {
    const e = {
      useMRT: !1,
      enableAnimationLoop: !1,
      animationLoopFrameTime: 16,
      useXR: !1,
      pixelRatio: window.devicePixelRatio,
      features: {
        antialias: {
          enabled: !0,
          method: "smaa"
        },
        bloom: {
          enabled: !1,
          strength: 0.1,
          threshold: 1,
          radius: 0
        },
        ao: {
          enabled: !1,
          method: "ssao"
        },
        reflection: {
          enabled: !1,
          method: "ssr"
        },
        shadow: {
          enabled: !1,
          method: "default"
        },
        depthPicking: {
          enabled: !1
        },
        colorAdjustment: {
          enabled: !1
        },
        hdr: {
          enabled: !1
        }
      }
    };
    return deepMerge(e, i);
  }
  init() {
    const i = this._resolution;
    this._options.isOrthographicCamera ? this._camera = new OrthographicCamera(
      -i.x / 2,
      i.x / 2,
      i.y / 2,
      -i.y / 2,
      0.1,
      1e6
    ) : this._camera = new PerspectiveCamera(35, i.x / i.y, 1, 100), this._camera.matrixAutoUpdate = !1, this._rawCamera = this._camera.clone();
    const e = this._scene = new Scene(), r = this.uiScene = new Group(), s = this.objectsScene = new Group(), a = this.environmentScene = new Group();
    s.add(r), e.add(s), e.add(a), e.matrixAutoUpdate = !1, this._createRenderer(), this._uniforms.resolution.value[0] = i.x, this._uniforms.resolution.value[1] = i.y, this._picking.init(), this._xr.init();
    let c = this._options.sky;
    c === void 0 && (c = new DefaultSky()), c && this.add(c);
  }
  _createRenderer() {
    const i = this._resolution, e = this._engine;
    let r = !!this._renderer, s = 1;
    r && (s = this._renderer.envMapIntensity, e.map.releaseCanvas(), this._renderer.forceContextLoss(), this._renderer.dispose());
    const a = this._canvas = document.createElement("canvas");
    addClass(a, `${CSS_NAMESPACE}-canvas`), a.style.position = "absolute", a.style.top = "0", a.style.left = "0", a.style.zIndex = "2";
    const c = this._context = a.getContext("webgl2", this._contextParameters), l = this._renderer = new WebGLRenderer({
      canvas: a,
      context: c,
      logarithmicDepthBuffer: !0
    });
    l.setClearColor(16777215, 0), l.setPixelRatio(this._pixelRatio), l.setSize(i.x, i.y), l.setOpaqueSort(_opaqueSort), l.setTransparentSort(_transparentSort), l.info.autoReset = !1, this._renderer.extraProgramCacheKey = "0", this._renderer.envMapIntensity = s, l.onShaderBeforeResolve = this.handleShaderBeforeResolve, l.onShaderBeforeCompile = this.handleShaderBeforeCompile, l.onMaterialBeforeCompile = this.handleMaterialBeforeCompile, r && (e.map._map.canvas = a, e.map.bindCanvas());
  }
  addBeforeRenderListener(i) {
    this._beforeRenderListeners.indexOf(i) === -1 && this._beforeRenderListeners.push(i);
  }
  removeBeforeRenderListener(i) {
    const e = this._beforeRenderListeners.indexOf(i);
    e > -1 && this._beforeRenderListeners.splice(e, 1);
  }
  addPrepareRenderListener(i) {
    this._prepareRenderListeners.indexOf(i) === -1 && this._prepareRenderListeners.push(i);
  }
  removePrepareRenderListener(i) {
    const e = this._prepareRenderListeners.indexOf(i);
    e > -1 && this._prepareRenderListeners.splice(e, 1);
  }
  add(i) {
    return i.traverse((e) => {
      e.afterAddToEngine && !e.__initInEngine && (e.__initInEngine = !0, e.afterAddToEngine(this._engine)), e instanceof EmptySky ? this.sky = e : e instanceof DynamicWeather && (this.weather = e), this.addBeforePrepareRenderObject(e), this.addBeforeRenderObject(e), this.addOnRenderModeChangeObject(e);
    }), i.__isEnvironment ? this.environmentScene.add(i) : i.isRenderInPostprocess ? this.uiScene.add(i) : this.objectsScene.add(i), i.supportRenderPassCallbacks && this._onRenderPassChangedObjects.add(i), this._needsRenderImmediately = !0, i.userData.__debugObjectId || (i.userData.__debugObjectId = __debugObjectId++), i;
  }
  remove(i) {
    !i || (i.traverse((e) => {
      e.beforeRemoveFromEngine && (e.__initInEngine = void 0, e.beforeRemoveFromEngine(this._engine)), e instanceof EmptySky ? this._sky = null : e instanceof DynamicWeather && (this._weather = null), this.removeBeforeRenderObject(e), this.removeBeforePrepareRenderObject(e), this.removeOnRenderModeChangeObject(e);
    }), i.__isEnvironment ? this.environmentScene.remove(i) : i.isRenderInPostprocess ? this.uiScene.remove(i) : this.objectsScene.remove(i), i.supportRenderPassCallbacks && this._onRenderPassChangedObjects.delete(i), this._needsRenderImmediately = !0);
  }
  addBeforePrepareRenderObject(i) {
    i.onBeforeScenePrepareRender && this._beforeScenePrepareRenderObjects.add(i);
  }
  removeBeforePrepareRenderObject(i) {
    this._beforeScenePrepareRenderObjects.delete(i);
  }
  addBeforeRenderObject(i) {
    i.onBeforeSceneRender && this._beforeSceneRenderObjects.add(i);
  }
  removeBeforeRenderObject(i) {
    this._beforeSceneRenderObjects.delete(i);
  }
  addOnRenderModeChangeObject(i) {
    i.onRenderModeChanged && this._onRenderModeChangedObjects.add(i);
  }
  removeOnRenderModeChangeObject(i) {
    i.onRenderModeChanged && this._onRenderModeChangedObjects.delete(i);
  }
  startRenderLoop() {
    this._isRunning = !0, this._needsRenderImmediately = !0, this._startTime = new Date().valueOf(), this._lastClockTime = this._startTime, this.render();
  }
  stopRenderLoop() {
    this._isRunning = !1;
  }
  updateCamera() {
    this._engine.map.updateCamera();
  }
  requestRender() {
    this._needsRenderImmediately = !0;
  }
  _copyRawCamera() {
    this._rawCamera || (this._rawCamera = this._camera.clone()), this._rawCamera.copy(this._camera);
  }
  renderScene(i) {
    const e = this._engine, r = e.event, s = this._stats;
    i || (i = new Date().valueOf()), this._uniforms.time.value = i, this._uniforms.elapsedTime.value = i - this._startTime, this._uniforms.zoomUnits.value = this._engine.map.getZoomUnits(), this._uniforms.resolution.value.copy(this._resolution), this.camera._isLocked || this.updateCamera(), this._copyRawCamera();
    const a = this._camera, c = this._scene, l = this._renderer;
    this.environmentScene.visible = !1;
    const h = this._renderState;
    r.beginFrame(), h.beginFrame(this, i), h.isResolutionOrPixelRatioChanged && this._main.setSize(this._resolution.x, this._resolution.y, this._pixelRatio), this._picking.beginFrame(), this._main.beginFrame(), this._needsReCreateRenderer ? (this._needsReCreateRenderer = !1, this._createRenderer()) : h.isResolutionOrPixelRatioChanged && (this._renderer.setSize(this._resolution.x, this._resolution.y), this._renderer.setPixelRatio(this._pixelRatio)), h._viewChanged && a.dispatchEvent({
      type: "viewchanged"
    }), s.beginTimeStatsItem("updateAnimation"), this._animation.update(h), s.endTimeStatsItem("updateAnimation");
    for (let b of this._prepareRenderListeners)
      b(this._engine, h);
    this._beforeScenePrepareRenderObjects.forEach((b) => {
      b.onBeforeScenePrepareRender(e, c, a, h);
    });
    const f = a.position.clone();
    let p = 0, m = 0, y = 0;
    const x = 1e3, v = Math.floor(f.x / x) * x, S = Math.floor(f.y / x) * x, E = Math.floor(f.z / x) * x;
    p = f.x - v, m = f.y - S, y = f.z - E, this._autoOffsetRelativeCenter ? (l.xr.isPresenting && this._xr.xrCamera.position.set(v + p, S + m, E + y), a.position.set(p, m, y), a.updateMatrix(), a.updateMatrixWorld(), c.position.set(-v, -S, -E), h.updateCameraOffsetState(a, v, S, E)) : (l.xr.isPresenting && this._xr.xrCamera.position.copy(f), h.updateCameraOffsetState(a, 0, 0, 0)), c.updateMatrix(), c.updateMatrixWorld(), this._clampCameraNearFar && this._computeCameraNearFar(), l.info.reset(), s.beginTimeStatsItem("updateCollision"), this._collision.update(h), s.endTimeStatsItem("updateCollision"), this._beforeSceneRenderObjects.forEach((b) => {
      b.onBeforeSceneRender(e, c, a, h);
    });
    for (let b of this._beforeRenderListeners)
      b(this._engine, h);
    s.beginTimeStatsItem("updateNodeMaterials"), s.endTimeStatsItem("updateNodeMaterials"), s.beginTimeStatsItem("renderMain"), this._main.render(this._onRenderPassChangedObjects), s.endTimeStatsItem("renderMain"), this._autoOffsetRelativeCenter && (l.xr.isPresenting && this._xr.xrCamera.position.copy(f), a.position.copy(f), a.updateMatrix(), a.updateMatrixWorld(), c.position.set(0, 0, 0), c.updateMatrix(), c.updateMatrixWorld()), this._main.endFrame(), this._picking.endFrame(), h.endFrame(this), r.endFrame(), this._useMRTChanged = !1;
  }
  async renderVideo(i) {
    let e = null;
    try {
      e = await window.showDirectoryPicker();
    } catch (l) {
      console.error("\u8BF7\u68C0\u67E5\u5F53\u524D\u9875\u9762\u662F\u5426\u4E3Ahttps\u534F\u8BAE\uFF0CshowDirectoryPicker error:", l);
      return;
    }
    i.directoryHandle = e, i.outputPath = e.name, this._videoConfig = i, this.stopRenderLoop();
    const r = i.duration, s = i.fps, a = r * s;
    this._startTime = new Date().valueOf(), this._videoFrameCount = a, this._videoFrameIndex = 0, this._resolution.set(i.width, i.height), this._videoSavedState = {
      pixelRatio: this._pixelRatio,
      aaEnabled: this.features.antialias.enabled,
      aaMethod: this.features.antialias.method
    }, this._pixelRatio = i.pixelRatio || 1, this._resolution.set(i.width, i.height), this.features.antialias.enabled = !1, this.features.antialias.method = "msaa";
    const c = i.tracker;
    return c && c.start({
      duration: r * 1e3,
      ...i.trackerOptions
    }), this._renderVideoFrame(), new Promise((l, h) => {
      this._renderVideoResolve = l, this._renderVideoReject = h;
    });
  }
  _computeCameraNearFar() {
    const i = this._camera, e = this._scene;
    _tempMatrix4$3.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), _tempFrustum.setFromProjectionMatrix(_tempMatrix4$3);
    const r = new Vector2$1(1 / 0, 0), s = [null, null];
    this._computeObjectNearFar(e, i, _tempFrustum, r, s), r.x < 0.1 && (r.x = 0.1), i.near = r.x, i.far = r.y, i.updateProjectionMatrix();
  }
  _computeObjectNearFar(i, e, r, s, a) {
    if (i.visible === !1)
      return;
    if (i.layers.test(e.layers) && (i.isMesh || i.isLine || i.isPoints || i.isSprite)) {
      if (i.isFSQuad)
        return;
      if (!i.frustumCulled || r.intersectsObject(i)) {
        const h = i.geometry;
        if (h.boundingSphere || h.computeBoundingSphere(), !h.boundingSphere)
          return;
        if (_tempSphere.copy(h.boundingSphere), _tempSphere.applyMatrix4(i.matrixWorld), _tempSphere.radius > 0) {
          const d = _tempSphere.center.distanceTo(e.position), f = d - _tempSphere.radius, p = d + _tempSphere.radius;
          s.x > f && (s.x = f, a[0] = i), s.y < p && (s.y = p, a[1] = i);
        }
      }
    }
    const l = i.children;
    if (l)
      for (let h = 0, d = l.length; h < d; h++)
        this._computeObjectNearFar(l[h], e, r, s, a);
  }
  _beginFrame() {
    this._taskScheduler.beginFrame();
  }
  _endFrame() {
    this._taskScheduler.endFrame();
  }
  updateContextParameters(i) {
    const e = this._contextParameters;
    for (const r of Object.keys(i))
      e[r] !== i[r] && (e[r] = i[r], this._needsReCreateRenderer = !0);
  }
  dispose() {
    this.stopRenderLoop(), this._debugMaterial && this._debugMaterial.dispose();
    const i = Array.from(this.objectsScene.children), e = Array.from(this.environmentScene.children);
    for (let s = i.length - 1; s >= 0; s--) {
      const a = i[s];
      this.remove(a), a.dispose && a.dispose();
    }
    for (let s = e.length - 1; s >= 0; s--) {
      const a = e[s];
      this.remove(a), a.dispose && a.dispose();
    }
    this._picking.dispose(), this._renderer.dispose();
    let r = this._context.getExtension("WEBGL_lose_context");
    r && r.loseContext();
  }
  get engine() {
    return this._engine;
  }
  get contextParameters() {
    return this._contextParameters;
  }
  get sky() {
    return this._sky;
  }
  set sky(i) {
    this._sky && console.warn("you are trying to set sky, but it has already been set.Please use `engine.remove(oldSky)` before setting a new sky."), this._sky = i;
  }
  get weather() {
    return this._weather;
  }
  set weather(i) {
    this._weather && console.warn("you are trying to set weather, but it has already been set.Please use `engine.remove(oldWeather)` before setting a new weather."), this._weather = i;
  }
  get debugShaderType() {
    return this._debugShaderType;
  }
  set debugShaderType(i) {
    if (this._debugShaderType = i, !this._useMRT)
      return;
    i = parseInt(i, 10);
    const e = this._composition;
    if (!i || i === 0)
      e.debugTextures = null;
    else if (i === 1)
      e.debugTextures = this._main.getTextures();
    else if (i === 2) {
      const r = [];
      this.objectsScene.traverse((s) => {
        s.isLight && s.shadow && s.shadow.map && r.push(s.shadow.map.texture);
      }), e.debugTextures = r;
    } else
      i === 3 ? e.debugTextures = this._bloom.getTextures() : i === 4 ? e.debugTextures = this._ssr.getTextures() : i === 5 && this._sky && this._sky.getTextures && (e.debugTextures = this._sky.getTextures());
  }
  get isUseMRTChanged() {
    return this._useMRTChanged;
  }
  get useMrt() {
    return this.useMRT;
  }
  set useMrt(i) {
    this.useMRT = i;
  }
  get useMRT() {
    return this._useMRT;
  }
  set useMRT(i) {
    this._useMRT !== i && (this._useMRT = i, this._useMRTChanged = !0);
  }
  get main() {
    return this._main;
  }
  get shadow() {
    return this._main.features.shadow;
  }
  get bloom() {
    return this._main.features.bloom;
  }
  get ssr() {
    return warnOnce("deprecated, ssr has been removed"), {};
  }
  get composition() {
    return warnOnce("deprecated, composition has been removed"), {};
  }
  get fog() {
    return warnOnce("deprecated, fog has been removed"), {};
  }
  get postprocessing() {
    return warnOnce("deprecated, postprocessing has been removed"), {};
  }
  get label() {
    return this._label;
  }
  get colorAdjustment() {
    return this._main.features.colorAdjustment;
  }
  get renderState() {
    return this._renderState;
  }
  get pick() {
    return warnOnce("`rendering.pick` is deprecated, use `.picking` instead"), this._picking;
  }
  get picking() {
    return this._picking;
  }
  get stats() {
    return this._stats;
  }
  get collision() {
    return this._collision;
  }
  get animation() {
    return this._animation;
  }
  get xr() {
    return this._xr;
  }
  get taskScheduler() {
    return this._taskScheduler;
  }
  get enableAnimationLoop() {
    return this._enableAnimationLoop;
  }
  set enableAnimationLoop(i) {
    this._enableAnimationLoop = i;
  }
  get animationLoopFrameTime() {
    return this._animationLoopFrameTime;
  }
  set animationLoopFrameTime(i) {
    this._animationLoopFrameTime = i;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(i) {
    this._resolution = i;
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  set pixelRatio(i) {
    this._pixelRatio = i;
  }
  get outputEncoding() {
    return this._outputEncoding;
  }
  set outputEncoding(i) {
    this._outputEncoding = i;
  }
  get canvas() {
    return this._canvas;
  }
  get renderer() {
    return this._renderer;
  }
  get camera() {
    return this._camera;
  }
  get scene() {
    return this._scene;
  }
  get uniforms() {
    return this._uniforms;
  }
  set wireframe(i) {
    this._wireframe = i, this._debugMaterial && (this._debugMaterial.wireframe = i);
  }
  get wireframe() {
    return this._wireframe;
  }
  set debugMode(i) {
    i = parseInt(i, 10), i !== this._debugMode && (this._debugMode = i, i !== DEBUG_MODE_NONE ? (this._debugMaterial || (this._debugMaterial = new ShaderMaterial({
      uniforms: {
        color: {
          value: new Color(35071)
        }
      },
      vertexShader: debugVertexShader,
      fragmentShader: debugFragmentShader,
      wireframe: this._wireframe
    }), this._debugMaterial.onBeforeRender = (e, r, s, a, c, l) => {
      let h = 0;
      const d = this._debugMode;
      if (d === DEBUG_MODE_MESH)
        h = c.id;
      else if (d === DEBUG_MODE_MATERIAL)
        h = c.material.id;
      else if (d === DEBUG_MODE_OBJECT) {
        let p = c;
        do
          if (p.userData.__debugObjectId) {
            h = p.userData.__debugObjectId;
            break;
          }
        while (p.parent && (p = p.parent));
      }
      let f = null;
      h ? f = debugColors[h % debugColors.length] : f = 13750737, this._debugMaterial.uniforms.color.value.set(f), this._debugMaterial.uniformsNeedUpdate = !0;
    }), this._scene.overrideMaterial = this._debugMaterial) : (this._scene.overrideMaterial = null, this._debugMaterial.dispose(), this._debugMaterial = null));
  }
  get debugMode() {
    return this._debugMode;
  }
  get autoOffsetRelativeCenter() {
    return this._autoOffsetRelativeCenter;
  }
  set autoOffsetRelativeCenter(i) {
    this._autoOffsetRelativeCenter = i;
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(i) {
    !!i !== this._freezeUpdate && (this._freezeUpdate = !!i, i ? this.stopRenderLoop() : this.startRenderLoop());
  }
  get useHighPrecisionBuffer() {
    return this._useHighPrecisionBuffer;
  }
  set useHighPrecisionBuffer(i) {
    this._useHighPrecisionBuffer = i;
  }
  get clampCameraNearFar() {
    return this._clampCameraNearFar;
  }
  set clampCameraNearFar(i) {
    this._clampCameraNearFar = i;
  }
  get hasWater() {
    return this._waterReference > 0;
  }
  get rawCamera() {
    return this._rawCamera;
  }
}
const _raycaster$5 = new Raycaster(), _seaLevelPlane$1 = new Plane(new Vector3$1(0, 0, 1), 0), _pointIn$1 = new Vector3$1(), _pointOut$1 = new Vector3$1();
class BaseMap {
  constructor(i, e) {
    this._engine = i, this._options = e;
  }
  init() {
  }
  parsePointToArr(i) {
    if (!i)
      return null;
    let e = [];
    if (Array.isArray(i))
      for (let r of i)
        e.push(parseFloat(r));
    else if (typeof i == "string") {
      const r = i.split(",");
      for (let s = 0; s < r.length; s++)
        e[s] = parseFloat(r[s]);
    } else
      typeof i == "object" && i.isVector3 && (e = [i.x, i.y, i.z]);
    return e;
  }
  projectArrayCoordinate(i, e) {
    return _pointIn$1.set(i[0], i[1], i[2] || 0), this.projection.projectCoordinate(_pointIn$1, _pointOut$1), e || (e = [0, 0, 0]), e[0] = _pointOut$1.x, e[1] = _pointOut$1.y, e[2] = _pointOut$1.z, e;
  }
  unprojectArrayCoordinate(i, e) {
    return _pointIn$1.set(i[0], i[1], i[2] || 0), this.projection.unprojectCoordinate(_pointIn$1, _pointOut$1), e || (e = [0, 0, 0]), e[0] = _pointOut$1.x, e[1] = _pointOut$1.y, e[2] = _pointOut$1.z, e;
  }
  getViewHeight() {
    return this.camera.position.z;
  }
  bindCanvas() {
    console.warn("bindCanvas must be implemented in subclass");
  }
  releaseCanvas() {
    console.warn("releaseCanvas must be implemented in subclass");
  }
  pickSeaLevelWorldPosition(i) {
    const e = this._engine.camera, r = this._engine.rendering.picking.pixelToNdc(i);
    _raycaster$5.setFromCamera(r, e);
    const s = new Vector3$1();
    return _raycaster$5.ray.intersectPlane(_seaLevelPlane$1, s), s;
  }
  dispose() {
  }
}
const isSupportPointerEvent = !!window.PointerEvent, isMobile = /ipod|ipad|iphone|android/.test(navigator.userAgent.toLowerCase()), isPointerTouch = (o) => o && o.pointerType === "touch", isTouchEvent = (o) => o.type.includes("touch"), EVENTS = (() => {
  let o;
  return isSupportPointerEvent ? o = {
    DOWN: "pointerdown",
    MOVE: "pointermove",
    UP: "pointerup",
    CANCEL: "pointercancel"
  } : isMobile ? o = {
    DOWN: "touchstart",
    MOVE: "touchmove",
    UP: "touchend",
    CANCEL: "touchcancel"
  } : o = {
    DOWN: "mousedown",
    MOVE: "mousemove",
    UP: "mouseup",
    CANCEL: "mousecancel"
  }, o;
})(), EventAction$1 = {
  NONE: 0,
  PAN: 1,
  ROTATE: 2,
  ZOOM: 3
}, _mouse$1 = new Vector2$1(), _raycaster$4 = new Raycaster(), _mapPlane$2 = new Plane(new Vector3$1(0, 0, 1), 0);
new Vector3$1();
const _mapCenter = new Vector3$1(), _mapMcCoord0$1 = new Vector3$1(), _mapMcCoord$1 = new Vector3$1(), _tempCamera$1 = new PerspectiveCamera();
_tempCamera$1.fov = 35;
new Vector2$1();
class MapControl {
  constructor(i) {
    _(this, "map");
    _(this, "currentAction");
    _(this, "startX");
    _(this, "startY");
    _(this, "startCenterX");
    _(this, "startCenterY");
    _(this, "startPitch");
    _(this, "startHeading");
    _(this, "startZoom");
    _(this, "startZoomUnits");
    _(this, "startAtTop");
    _(this, "mapWidth");
    _(this, "mapHeight");
    _(this, "startCamera", new PerspectiveCamera());
    _(this, "startCenter", new Vector3$1());
    _(this, "startNdc", new Vector2$1());
    _(this, "startPoint", new Vector3$1());
    _(this, "startScaleX", 1);
    _(this, "startScaleY", 1);
    _(this, "startBoundX");
    _(this, "startBoundY");
    _(this, "_enabled", !1);
    _(this, "minPitch", 0);
    _(this, "maxPitch", 89);
    _(this, "zoomSpeed", 5e-3);
    _(this, "headingSpeed", 0.4);
    _(this, "pitchSpeed", 0.3);
    _(this, "doubleClickTimer", null);
    _(this, "clickInterval", 200);
    _(this, "init", () => {
      const i = this.map.domContainer;
      i.addEventListener(EVENTS.DOWN, this.handleMouseDown), i.addEventListener("wheel", this.handleWheel), i.addEventListener("contextmenu", this.handleContextMenu), i.addEventListener(EVENTS.MOVE, this.handleMouseMove);
    });
    _(this, "handleResize", (i) => {
      const [e, r] = this.map.getContainerSize();
      this.mapWidth = e, this.mapHeight = r;
      const s = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = s.left, this.startBoundY = s.top, this.startScaleX = s.width / e, this.startScaleY = s.height / r;
    });
    _(this, "handleMouseMove", (i) => {
      this.currentAction === EventAction$1.NONE && this.onEventMouseMove && this.onEventMouseMove(i);
    });
    _(this, "handleMouseDown", (i) => {
      let e = this.mapHeight, r = this.mapWidth;
      const s = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = s.left, this.startBoundY = s.top, this.startScaleX = s.width / r, this.startScaleY = s.height / e;
      const a = (i.clientX - this.startBoundX) / this.startScaleX, c = (i.clientY - this.startBoundY) / this.startScaleY;
      if (i.button === 0 ? (this.startZoomUnits = this.map.getZoomUnitsByZoom(this.map.zoom), this.setPanStartState(a, c), this.currentAction = EventAction$1.PAN) : i.button === 2 ? this.currentAction = EventAction$1.ROTATE : this.currentAction = EventAction$1.NONE, this.currentAction === EventAction$1.NONE)
        return;
      i && this.onEventPointerDown && (this.hasMoved || this.onEventPointerDown(i)), this.startX = a, this.startY = c;
      const l = this.map;
      this.startCenterX = l.center[0], this.startCenterY = l.center[1], this.startPitch = l.pitch, this.startHeading = l.heading, this.startZoom = l.zoom, this.startAtTop = c < e / 2, document.addEventListener(EVENTS.MOVE, this.handleMouseDragging), document.addEventListener(EVENTS.UP, this.handleMouseUp);
    });
    _(this, "handleMouseDragging", (i) => {
      if (this.currentAction === EventAction$1.NONE)
        return;
      this.hasMoved = !0;
      const e = this.currentPixelX = (i.clientX - this.startBoundX) / this.startScaleX, r = this.currentPixelY = (i.clientY - this.startBoundY) / this.startScaleY;
      this.currentAction === EventAction$1.PAN ? this.handlePan(e, r) : this.currentAction === EventAction$1.ROTATE && this.handleRotate(e, r);
    });
    _(this, "handleMouseUp", (i) => {
      this.currentAction = EventAction$1.NONE, document.removeEventListener(EVENTS.MOVE, this.handleMouseDragging), document.removeEventListener(EVENTS.UP, this.handleMouseUp), i && this.onEventPointerUp && this.onEventPointerUp(i), i && this.onEventClick && (this.hasMoved || this.onEventClick(i)), i && this.onEventDblClick && (!this.hasMoved && this.waitSecondClick ? (this.onEventDblClick(i), this.clearDoubleClickTimer()) : this.waitSecondClick = !0), clearTimeout(this.doubleClickTimer), this.doubleClickTimer = setTimeout(() => {
        this.clearDoubleClickTimer();
      }, this.clickInterval), this.hasMoved = !1;
    });
    _(this, "clearDoubleClickTimer", () => {
      this.doubleClickTimer && clearTimeout(this.doubleClickTimer), this.waitSecondClick = !1, this.doubleClickTimer = null;
    });
    _(this, "handleContextMenu", (i) => {
      i.preventDefault();
    });
    _(this, "handleWheel", (i) => {
      i.preventDefault(), i.stopPropagation();
      const e = (i.clientX - this.startBoundX) / this.startScaleX, r = (i.clientY - this.startBoundY) / this.startScaleY;
      this.handleZoom({
        deltaX: i.deltaX,
        deltaY: i.deltaY,
        pixelX: e,
        pixelY: r
      });
    });
    _(this, "handlePan", (i, e) => {
      const r = this.map;
      if (this.getNdc(i, e, _mouse$1), this.ndcToPoint(_mouse$1, this.startCamera, _mapMcCoord$1), _mapMcCoord$1.distanceTo(this.startCamera.position) > r.zoomUnits * 6e3) {
        this.handleMouseUp();
        return;
      }
      _mapCenter.subVectors(this.startCenter, _mapMcCoord$1.sub(this.startPoint)), r.center = [_mapCenter.x, _mapCenter.y], r.updateView();
    });
    _(this, "setPanStartState", (i, e) => {
      const r = this.map;
      this.startCamera.copy(r.camera), this.startCamera.updateMatrixWorld(), this.startCenter.set(r.center[0], r.center[1], 0), this.getNdc(i, e, this.startNdc), this.ndcToPoint(this.startNdc, r.camera, this.startPoint);
    });
    _(this, "handleRotate", (i, e) => {
      const r = this.map;
      let s = i - this.startX;
      const a = e - this.startY;
      this.startAtTop || (s *= -1);
      let c = this.startHeading + s * this.headingSpeed;
      c = this.makeHeadingSafe(c), r.heading = c;
      let l = this.startPitch + a * this.pitchSpeed;
      l = this.makePitchSafe(l), r.pitch = l, r.updateView();
    });
    _(this, "handleZoom", (i) => {
      const e = this.map;
      let r = e.zoom, s = r + i.deltaY * this.zoomSpeed * -1;
      if (r === s)
        return;
      if (s = this.makeZoomSafe(s), s < e.earthViewZoomMax) {
        this.map.zoom = s, this.map.updateView();
        return;
      }
      let a = this.mapWidth, c = this.mapHeight;
      const l = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = l.left, this.startBoundY = l.top, this.startScaleX = l.width / a, this.startScaleY = l.height / c;
      let h = e.center, d = e.pitch, f = e.heading;
      this.getNdc(i.pixelX, i.pixelY, _mouse$1), _mapCenter.set(h[0], h[1], 0), this.ndcToPoint(_mouse$1, e.camera, _mapMcCoord0$1), !(_mapMcCoord0$1.distanceTo(e.camera.position) > e.zoomUnits * 6e3) && (e.computeMapCameraMatrix(_tempCamera$1, h, s, d, f), this.ndcToPoint(_mouse$1, _tempCamera$1, _mapMcCoord$1), _mapCenter.sub(_mapMcCoord$1.sub(_mapMcCoord0$1)), this.map.center[0] = _mapCenter.x, this.map.center[1] = _mapCenter.y, this.map.zoom = s, this.map.updateView());
    });
    _(this, "makeZoomSafe", (i) => i > this.map.maxZoom ? this.map.maxZoom : i < this.map.minZoom ? this.map.minZoom : i);
    _(this, "makeHeadingSafe", (i) => (i %= 360, i < 0 && (i += 360), i));
    _(this, "makePitchSafe", (i) => i < this.minPitch ? this.minPitch : i > this.maxPitch ? this.maxPitch : i);
    _(this, "dispose", () => {
      const i = this.map.domContainer;
      i.removeEventListener(EVENTS.DOWN, this.handleMouseDown), i.removeEventListener("wheel", this.handleWheel), i.removeEventListener("contextmenu", this.handleContextMenu), document.removeEventListener(EVENTS.MOVE, this.handleMouseDragging), document.removeEventListener(EVENTS.UP, this.handleMouseUp), i.removeEventListener(EVENTS.MOVE, this.handleMouseMove), this.clearDoubleClickTimer();
    });
    this.map = i, this.enabled = !0, this.currentAction = EventAction$1.NONE;
  }
  set enabled(i) {
    i !== this._enabled && (i ? this.init() : this.dispose(), this._enabled = i);
  }
  ndcToPoint(i, e, r) {
    _raycaster$4.setFromCamera(i, e), _raycaster$4.ray.intersectPlane(_mapPlane$2, r);
  }
  getNdc(i, e, r) {
    r.x = i / this.mapWidth * 2 - 1, r.y = 1 - e / this.mapHeight * 2;
  }
}
const _tempQuaternion1 = new Quaternion$1(), _tempQuaternion2$1 = new Quaternion$1(), _raycaster$3 = new Raycaster(), _mapPlane$1 = new Plane(new Vector3$1(0, 0, 1), 0), _tempVector2$3 = new Vector2$1();
new Vector3$1();
new Matrix4();
new Vector4();
const _leftBottomPixel$1 = new Vector2$1(-1, -1);
new Vector2$1(-1, 1);
new Vector2$1(1, 1);
const _rightBottomPixel$1 = new Vector2$1(1, -1);
new Vector3$1();
new Vector3$1();
new Vector3$1();
new Vector3$1();
const _tempPoint = new Vector3$1(), pt = class extends BaseMap {
  constructor(e, r, s = {}) {
    super(e, s);
    _(this, "isBlankMap", !0);
    _(this, "MERCATOR_LENGTH", 200375083427892e-7);
    _(this, "projectionName", "_web_mercator");
    _(this, "origin", [0, 0]);
    _(this, "center", [0, 0]);
    _(this, "zoom", 0);
    _(this, "pitch", 0);
    _(this, "heading", 0);
    _(this, "bounds", [[-this.MERCATOR_LENGTH, -this.MERCATOR_LENGTH], [this.MERCATOR_LENGTH, this.MERCATOR_LENGTH]]);
    _(this, "near", 100);
    _(this, "_far", 38e3);
    _(this, "fov", 35);
    _(this, "_cameraLocation", new Vector3$1());
    _(this, "handleViewChange", () => {
      this.onViewChanged && this.onViewChanged();
    });
    _(this, "handleMapResize", () => {
      this.control && this.control.handleResize(this.getResolution()), this.onResolutionChanged && this.onResolutionChanged(this.getResolution());
    });
    _(this, "handleEventClick", (e) => {
      const s = this._engine.event, a = this._getPixelFromEvent(e);
      e.button === 2 ? s._handleRightClick({
        pixel: a,
        event: e
      }) : s._handleClick({
        pixel: a,
        event: e
      });
    });
    _(this, "handleEventDblClick", (e) => {
      const s = this._engine.event, a = this._getPixelFromEvent(e);
      e.button === 2 ? s._handleRightDblClick({
        pixel: a,
        event: e
      }) : s._handleDblClick({
        pixel: a,
        event: e
      });
    });
    _(this, "handleEventPointerDown", (e) => {
      const s = this._engine.event, a = this._getPixelFromEvent(e);
      s._handlePointerDown({
        pixel: a,
        event: e
      });
    });
    _(this, "handleEventPointerUp", (e) => {
      const s = this._engine.event, a = this._getPixelFromEvent(e);
      s._handlePointerUp({
        pixel: a,
        event: e
      });
    });
    _(this, "handleEventMouseMove", (e) => {
      const s = this._engine.event, a = this._getPixelFromEvent(e);
      s._handleMouseMove({
        pixel: a,
        event: e
      });
    });
    _(this, "_getPixelFromEvent", (e) => {
      const r = this._engine.rendering.canvas.getBoundingClientRect(), s = e.clientX - r.left, a = e.clientY - r.top;
      return [s, a];
    });
    this._engine = e, this.domContainer = r;
  }
  afterInit() {
    this.camera.matrixAutoUpdate = !1, this.bindCanvas(), this.handleMapResize(), bind(this.domContainer, this.handleMapResize), this.initControl(), this.resetHome();
  }
  resetHome() {
    this.lookAt(pt.DEFAULT_CENTER, {
      zoom: 4.5,
      pitch: 0,
      heading: 0
    });
  }
  initControl() {
    this.control = new MapControl(this), this.control.onEventPointerDown = this.handleEventPointerDown, this.control.onEventPointerUp = this.handleEventPointerUp, this.control.onEventClick = this.handleEventClick, this.control.onEventDblClick = this.handleEventDblClick, this.control.onEventMouseMove = this.handleEventMouseMove;
  }
  bindCanvas() {
    this.domContainer.appendChild(this.canvas);
  }
  releaseCanvas() {
    this.domContainer.removeChild(this.canvas);
  }
  getContainerSize() {
    return [
      this.domContainer.clientWidth,
      this.domContainer.clientHeight
    ];
  }
  getResolution() {
    return new Vector2$1(this.domContainer.clientWidth, this.domContainer.clientHeight);
  }
  getCenter() {
    return this.unprojectArrayCoordinate(this.center);
  }
  getZoom() {
    return this.zoom;
  }
  getPitch() {
    return this.pitch;
  }
  getZoomUnitsByZoom(e) {
    return this.MERCATOR_LENGTH / 128 / Math.pow(2, e);
  }
  getCameraLocation(e) {
    return e || (e = new Vector3$1()), e.copy(this._cameraLocation), e;
  }
  getZoomByZoomUnits(e) {
    return Math.log2(this.MERCATOR_LENGTH / 128 / e);
  }
  getZoomUnits() {
    return this.getZoomUnitsByZoom(this.zoom);
  }
  getHeading() {
    return this.heading;
  }
  enableControl() {
    this.control.enabled = !0;
  }
  disableControl() {
    this.control.enabled = !1;
  }
  setCameraMatrix() {
    this.handleViewChange();
  }
  _updateCameraLocation() {
    this.projection.unprojectCoordinate(this.camera.position, this._cameraLocation);
  }
  updateCamera() {
    this.computeMapCameraMatrix(this.camera, this.center, this.zoom, this.pitch, this.heading), this._updateCameraLocation();
  }
  computeMapCameraMatrix(e, r, s, a, c) {
    const [l, h] = this.getContainerSize();
    let d = this.zoomUnits = this.getZoomUnitsByZoom(s);
    if (l * d > this.bounds[1][0] - this.bounds[0][0]) {
      let m = (this.bounds[1][0] - this.bounds[0][0]) / l;
      d = this.zoomUnits = m, this.zoom = this.getZoomByZoomUnits(m);
    }
    if (h * d > this.bounds[1][1] - this.bounds[0][1]) {
      let m = (this.bounds[1][1] - this.bounds[0][1]) / h;
      d = this.zoomUnits = m, this.zoom = this.getZoomByZoomUnits(m);
    }
    r[0] - l / 2 * d < this.bounds[0][0] && (r[0] = this.bounds[0][0] + l / 2 * d), r[0] + l / 2 * d > this.bounds[1][0] && (r[0] = this.bounds[1][0] - l / 2 * d), r[1] - h / 2 * d < this.bounds[0][1] && (r[1] = this.bounds[0][1] + h / 2 * d), r[1] + h / 2 * d > this.bounds[1][1] && (r[1] = this.bounds[1][1] - h / 2 * d), this.center = r;
    const f = h / 2 / Math.tan(this.fov / 2 * Math.PI / 180) * d;
    this.cameraDistance = f, e.position.set(0, 0, 0), e.quaternion.set(0, 0, 0, 1), e.up.set(0, 0, 1), e.translateX(r[0]), e.translateY(r[1]), r[2] && e.translateZ(r[2]), e.rotateOnAxis(new Vector3$1(0, 0, 1), c * Math.PI / 180), e.rotateOnAxis(new Vector3$1(1, 0, 0), a * Math.PI / 180), e.translateZ(f), e.updateMatrix(), e.updateMatrixWorld(), e.aspect = l / h;
    let p = d;
    p < 1 && (p = 1), e.near = Math.min(Math.max(e.position.z / 1e4, 0.1), 10), e.far = this._far * p, e.fov = this.fov, e.updateProjectionMatrix();
  }
  setCenter(e) {
    const r = this.projectArrayCoordinate(e);
    r && (this.center = r), this.setCameraMatrix();
  }
  setProjectionCenter(e) {
    const r = this.unprojectArrayCoordinate(e);
    this.setCenter(r);
  }
  setZoom(e) {
    isNaN(e) || (this.zoom = e), this.setCameraMatrix();
  }
  zoomIn() {
    this.setZoom(this.zoom + 1);
  }
  zoomOut() {
    this.setZoom(this.zoom - 1);
  }
  setHeading(e) {
    this.heading = e, this.setCameraMatrix();
  }
  setPitch(e) {
    this.pitch = e, this.setCameraMatrix();
  }
  setMaxRange(e) {
    console.warn(`setMaxRange is only compatible with 3DMap Control,
            please set options 'map: {is3DControl: true}' when Engine is created`);
  }
  lookAt(e, r = {}) {
    let s = [];
    e.isVector3 ? e.toArray(s) : s = e;
    let a = this.projectArrayCoordinate(s);
    a && (this.center = a), r.heading !== void 0 && (this.heading = r.heading), r.pitch !== void 0 && (this.pitch = r.pitch), r.zoom !== void 0 && (this.zoom = r.zoom), this.updateCamera(), this.setCameraMatrix();
  }
  _getCameraQuaternion(e, r) {
    _tempQuaternion1.setFromAxisAngle(new Vector3$1(0, 0, 1), e * Math.PI / 180), _tempQuaternion2$1.setFromAxisAngle(new Vector3$1(1, 0, 0), r * Math.PI / 180);
    const s = new Quaternion$1();
    return s.multiplyQuaternions(_tempQuaternion1, _tempQuaternion2$1), s;
  }
  flyTo(e, r) {
    this.cancelFlight();
    let s = [];
    e.isVector3 ? s = e.toArray() : e.isVector2 ? s = [e.x, e.y, 0] : e instanceof Array && (s = [e[0], e[1], e[2] || 0]), this.projectArrayCoordinate(s, s);
    const a = this._engine, c = a.map, l = this, h = defaultValue$1(r.heading, a.map.getHeading()), d = defaultValue$1(r.pitch, a.map.getPitch()), f = this._getCameraQuaternion(h, d), p = new Vector3$1(0, 0, -1).applyQuaternion(f).negate(), m = new Vector3$1().fromArray(s), y = r.range;
    isNaN(y) || m.add(p.multiplyScalar(y));
    const x = {
      destination: m,
      heading: MathUtils.degToRad(h),
      pitch: MathUtils.degToRad(d),
      duration: r.duration,
      complete: function() {
        l._currentFlight = void 0, r.complete && r.complete();
      },
      cancel: r.cancel
    }, v = CameraFlightPath.createTween(c, x);
    if (v.duration === 0) {
      typeof v.complete == "function" && v.complete(), this.updateView();
      return;
    }
    const S = performance.now();
    function E() {
      const w = performance.now() - S, {
        duration: M,
        complete: P,
        update: D,
        easingFunction: L
      } = v;
      if (w >= M) {
        D({
          time: M,
          easingFunction: L
        }), a.removePrepareRenderListener(E), P();
        return;
      }
      D({
        time: w,
        easingFunction: L
      }), a.requestRender();
    }
    a.addPrepareRenderListener(E), v.listener = E, this._currentFlight = v, this.updateView();
  }
  cancelFlight() {
    if (this._currentFlight) {
      const e = this._currentFlight.listener;
      this._engine.removePrepareRenderListener(e), this._currentFlight = void 0;
    }
  }
  setBounds(e) {
    this.bounds = [this.projectArrayCoordinate(e[0]), this.projectArrayCoordinate(e[1])];
  }
  getNdcYFactor() {
    const e = this.getPitch(), r = 45;
    if (e < r)
      return 1;
    const s = 0.5, a = (e - r) / (90 - r), c = 1 - Math.tan(a * Math.PI / 2) * s;
    return Math.max(-0.1, Math.min(c, 1));
  }
  getProjectionBounds() {
    const e = [], r = this.getNdcYFactor();
    _raycaster$3.setFromCamera(_leftBottomPixel$1, this.camera), _raycaster$3.ray.intersectPlane(_mapPlane$1, _tempPoint);
    const s = _tempPoint.x, a = _tempPoint.y;
    _raycaster$3.setFromCamera(_rightBottomPixel$1, this.camera), _raycaster$3.ray.intersectPlane(_mapPlane$1, _tempPoint);
    const c = _tempPoint.x, l = _tempPoint.y;
    _tempVector2$3.set(-1, r), _raycaster$3.setFromCamera(_tempVector2$3, this.camera), _raycaster$3.ray.intersectPlane(_mapPlane$1, _tempPoint);
    const h = _tempPoint.x, d = _tempPoint.y;
    _tempVector2$3.set(1, r), _raycaster$3.setFromCamera(_tempVector2$3, this.camera), _raycaster$3.ray.intersectPlane(_mapPlane$1, _tempPoint);
    const f = _tempPoint.x, p = _tempPoint.y;
    return e[0] = Math.min(s, c, h, f), e[1] = Math.min(a, l, d, p), e[2] = Math.max(s, c, h, f), e[3] = Math.max(a, l, d, p), new Box3(new Vector3$1(e[0], e[1], 0), new Vector3$1(e[2], e[3], 0));
  }
  getBounds() {
    const e = this.getProjectionBounds(), r = this.unprojectArrayCoordinate([e.min.x, e.min.y]), s = this.unprojectArrayCoordinate([e.max.x, e.max.y]);
    return new Box3(new Vector3$1(r[0], r[1], 0), new Vector3$1(s[0], s[1], 0));
  }
  updateView() {
    this.setCameraMatrix();
  }
  getCameraDistance() {
    return this.cameraDistance;
  }
  getProjectionCenter() {
    return [this.center[0], this.center[1]];
  }
  dispose() {
    this.releaseCanvas(), clear(this.domContainer), this._engine.event, this.control.dispose(), super.dispose();
  }
  get far() {
    return this._far;
  }
  set far(e) {
    this._far = e;
  }
};
let BlankMap = pt;
_(BlankMap, "EARTH_RADIUS", 637e4), _(BlankMap, "DEFAULT_CENTER", [107.9, 35.8]);
const _postionVector = new Vector2$1(), _velocityVector = new Vector2$1();
class PointerMovementAggregator {
  constructor(i = {}) {
    _(this, "_lastTime", 0);
    _(this, "_lastPosition", new Vector2$1());
    _(this, "_velocity", new Vector2$1());
    _(this, "_acceleration", new Vector2$1());
    _(this, "_resistance", 3e-3);
    _(this, "_inertiaSpeed", 0);
    _(this, "_inertiaDirection", new Vector2$1());
    _(this, "_scale", 1);
    i.resistance !== void 0 && (this._resistance = i.resistance);
  }
  start(i, e, r) {
    this._lastPosition.set(i, e), this._velocity.set(0, 0), this._acceleration.set(0, 0), r === void 0 ? this._lastTime = performance.now() : this._lastTime = r;
  }
  update(i, e, r) {
    r === void 0 && (r = performance.now());
    const s = r - this._lastTime;
    _postionVector.set(i, e);
    const a = _postionVector.sub(this._lastPosition);
    _velocityVector.copy(a).divideScalar(s), this._acceleration.copy(_velocityVector).sub(this._velocity), this._lastPosition.set(i, e), this._velocity.copy(_velocityVector), this._lastTime = r;
  }
  setInertiaState(i, e, r) {
    this._inertiaSpeed = i, this._inertiaDirection.copy(e), this._lastTime = r;
  }
  startInertia() {
    this._inertiaSpeed = this._velocity.length(), this._inertiaDirection.copy(this._velocity).normalize();
  }
  getInertiaPosition(i) {
    i === void 0 && (i = performance.now());
    const e = i - this._lastTime, r = this._inertiaSpeed;
    let s = r - this._resistance * r * e;
    s < 0 && (s = 0);
    const a = this._inertiaDirection.clone().multiplyScalar(r * e).add(this._lastPosition);
    return this._inertiaSpeed = s * this._scale, this._lastPosition.copy(a), this._lastTime = i, [a, r];
  }
  get inertiaDirection() {
    return this._inertiaDirection;
  }
  get scale() {
    return this._scale;
  }
  set scale(i) {
    this._scale = i;
  }
}
class DraggingMovementAggregator {
  constructor(i = {}) {
    _(this, "_lastTime", 0);
    _(this, "_dragEndTime", 0);
    _(this, "_inertiaPosition", new Vector2$1());
    _(this, "_diffX", 0);
    _(this, "_diffY", 0);
    _(this, "_dir", new Vector2$1());
    _(this, "_dragPoint", new Vector2$1());
    _(this, "_lastDragPoint", new Vector2$1());
    _(this, "_velocity", 0);
    _(this, "_lastDiffDistance", 0);
    _(this, "_amplitudeX", 0);
    _(this, "_amplitudeY", 0);
    _(this, "_targetX", 0);
    _(this, "_targetY", 0);
    _(this, "_scale", 1);
  }
  start(i, e, r) {
    r === void 0 ? this._lastTime = performance.now() : this._lastTime = r, this._lastDiffDistance = Math.sqrt(Math.pow(i, 2) + Math.pow(e, 2));
  }
  update(i, e, r) {
    r === void 0 && (r = performance.now());
    const s = r - this._lastTime;
    if (s === 0)
      return;
    this._diffX = i, this._diffY = e, this._dragPoint.set(i, e), this._dragPoint.x === this._lastDragPoint.x && this._dragPoint.y === this._lastDragPoint.y ? this._dir.set(this._diffX, this._diffY) : this._dir.set(
      this._dragPoint.x - this._lastDragPoint.x,
      this._dragPoint.y - this._lastDragPoint.y
    );
    let a = Math.sqrt(Math.pow(this._diffX, 2) + Math.pow(this._diffY, 2)), l = 500 * Math.abs(a - this._lastDiffDistance) / s;
    l = Math.min(l, 2e3), this._velocity = 0.6 * l + 0.4 * this._velocity, this._lastTime = r, this._lastDiffDistance = a, this._lastDragPoint.copy(this._dragPoint);
  }
  startInertia(i = !1) {
    this._dragEndTime = performance.now(), this._dragEndTime - this._lastTime > 30 && (this._velocity = 0);
    let e = 0.5 * this._velocity * this._scale;
    i && (e = 0.1 * this._velocity * this._scale);
    let r = 0, s = 0;
    if (this._dir.y === 0)
      r = e;
    else {
      let a = Math.abs(this._dir.x / this._dir.y);
      s = Math.round(Math.sqrt(e * e / (1 + a * a))), r = Math.round(a * s);
    }
    this._dir.x < 0 && (r = -r), this._dir.y < 0 && (s = -s), this._targetX = this._diffX + r, this._targetY = this._diffY + s, this._amplitudeX = r, this._amplitudeY = s, this._velocity = 0, this._lastDiffDistance = 0, this._lastTime = 0;
  }
  getInertiaPosition(i) {
    i === void 0 && (i = performance.now());
    let e = i - this._dragEndTime, r = Math.exp(-e / 200), s = this._targetX - this._amplitudeX * r, a = this._targetY - this._amplitudeY * r, c = Math.abs(this._amplitudeX * r) > 5 || Math.abs(this._amplitudeY * r) > 5;
    return this._inertiaPosition.set(s, a), [this._inertiaPosition, c];
  }
  get scale() {
    return this._scale;
  }
  set scale(i) {
    this._scale = i;
  }
}
const EventAction = {
  NONE: 0,
  PAN: 1,
  ROTATE: 2,
  PITCH: 3,
  ZOOM: 4
}, MouseButton$1 = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
}, EVENT_WHEEL = "wheel", EVENT_CONTEXTMENU = "contextmenu", EVENT_DRAGGING = "dragging";
new Vector2$1();
const _mouse = new Vector2$1(), _raycaster$2 = new Raycaster(), _mapPlane = new Plane(new Vector3$1(0, 0, 1), 0), _bottomCenterNdc = new Vector2$1(0, -1), _bottomCenterMcCoord = new Vector3$1();
new Vector3$1();
new Vector3$1();
const _mapMcCoord = new Vector3$1(), _mapMcCoord0 = new Vector3$1(), _mapMcCoord1 = new Vector3$1(), _tempCamera = new PerspectiveCamera();
new PerspectiveCamera();
_tempCamera.fov = 35;
const _tempPixel = new Vector2$1();
class MapControl3D {
  constructor(i) {
    _(this, "map");
    _(this, "currentAction");
    _(this, "isPointerDown", !1);
    _(this, "startX");
    _(this, "startY");
    _(this, "startCenterX");
    _(this, "startCenterY");
    _(this, "startPitch");
    _(this, "startHeading");
    _(this, "startZoom");
    _(this, "startZoomUnits");
    _(this, "startAtTop");
    _(this, "mapWidth");
    _(this, "mapHeight");
    _(this, "startCamera", new PerspectiveCamera());
    _(this, "startCenter", new Vector3$1());
    _(this, "startNdc", new Vector2$1());
    _(this, "startPoint", new Vector3$1());
    _(this, "startScaleX", 1);
    _(this, "startScaleY", 1);
    _(this, "startBoundX");
    _(this, "startBoundY");
    _(this, "startProjectionCenter", new Vector3$1());
    _(this, "_enabled", !1);
    _(this, "_enableRotate", !0);
    _(this, "_enableZoom", !0);
    _(this, "_enablePan", !0);
    _(this, "_enableTilt", !0);
    _(this, "enableInertia", !0);
    _(this, "minPitch", 0);
    _(this, "maxPitch", 88);
    _(this, "zoomSpeed", 5e-3);
    _(this, "headingSpeed", 0.4);
    _(this, "pitchSpeed", 0.3);
    _(this, "doubleClickTimer", null);
    _(this, "clickInterval", 200);
    _(this, "_rotationMode", 1);
    _(this, "_buttonDown", {
      LEFT: !1,
      MIDDLE: !1,
      RIGHT: !1
    });
    _(this, "_primaryStartPosition", new Vector2$1());
    _(this, "_primaryPosition", new Vector2$1());
    _(this, "_primaryPreviousPosition", new Vector2$1());
    _(this, "_positions", /* @__PURE__ */ new Map());
    _(this, "_previousPositions", /* @__PURE__ */ new Map());
    _(this, "_isPinching", !1);
    _(this, "_isTouchHolding", !1);
    _(this, "_lastPinchDist", 0);
    _(this, "_lastSeenTouchEvent", -800);
    _(this, "_whichKindOfPinch");
    _(this, "_pinchConnectPosition", {
      position1: new Vector2$1(),
      position2: new Vector2$1()
    });
    _(this, "_pinchActionPosition", {
      position1: new Vector2$1(),
      position2: new Vector2$1()
    });
    _(this, "_pinchActionTimer");
    _(this, "_touchHoldTimer");
    _(this, "_clickPixelTolerance", 5);
    _(this, "_holdPixelTolerance", 25);
    _(this, "lastMoveDistance", 0);
    _(this, "init", () => {
      const i = this.map.domContainer;
      i.addEventListener(EVENTS.DOWN, this.handlePointerDownWithThrottle), i.addEventListener(EVENT_WHEEL, this.handleWheelWithThrottle), i.addEventListener(EVENT_CONTEXTMENU, this.handleContextMenu), i.addEventListener(EVENTS.MOVE, this.handlePointerMoveWithThrottle), this.initCursorAnchor();
    });
    _(this, "handlePointerDownWithThrottle", (i) => {
      this._eventThrottle.putEvent(EVENTS.DOWN, i), this._tryToTriggerEvents();
    });
    _(this, "handleWheelWithThrottle", (i) => {
      this._eventThrottle.putEvent(EVENT_WHEEL, i), this._tryToTriggerEvents();
    });
    _(this, "handlePointerMoveWithThrottle", (i) => {
      this._eventThrottle.putEvent(EVENTS.MOVE, i), this._tryToTriggerEvents();
    });
    _(this, "handleMouseDraggingWithThrottle", (i) => {
      this._eventThrottle.putEvent(EVENT_DRAGGING, i), this._tryToTriggerEvents();
    });
    _(this, "handlePointerUpWithThrottle", (i) => {
      this._eventThrottle.putEvent(EVENTS.UP, i), this._tryToTriggerEvents();
    });
    _(this, "_tryToTriggerEvents", async () => {
      this._eventThrottle.isEmpty || this._eventThrottle.isBusy || await this._eventThrottle.triggerEvents(this._triggerEvents);
    });
    _(this, "_triggerEvents", async (i) => {
      i[EVENTS.DOWN] && await this.handlePointerDown(i[EVENTS.DOWN]), i[EVENT_WHEEL] && await this.handleWheel(i[EVENT_WHEEL]), i[EVENTS.MOVE] && await this.handlePointerMove(i[EVENTS.MOVE]), i[EVENT_DRAGGING] && await this.handleMouseDragging(i[EVENT_DRAGGING]), i[EVENTS.UP] && await this.handlePointerUp(i[EVENTS.UP]), this._tryToTriggerEvents();
    });
    _(this, "initCursorAnchor", () => {
      const i = this.cursorAnchor = document.createElement("div");
      i.style.position = "absolute", i.style.width = "40px", i.style.height = "40px", i.style.backgroundColor = "rgba(255, 255, 255, 0.5)", i.style.zIndex = 100, i.style.pointerEvents = "none", i.style.display = "none", this.map.domContainer.appendChild(i);
    });
    _(this, "showCursorAnchor", (i, e) => {
      this._rotationMode <= 1 || (this.cursorAnchor.style.left = i - 20 + "px", this.cursorAnchor.style.top = e - 20 + "px", this.cursorAnchor.style.display = "block");
    });
    _(this, "hideCursorAnchor", () => {
      this.cursorAnchor.style.display = "none";
    });
    _(this, "handleResize", (i) => {
      const [e, r] = this.map.getContainerSize();
      this.mapWidth = e, this.mapHeight = r;
      const s = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = s.left, this.startBoundY = s.top, this.startScaleX = s.width / e, this.startScaleY = s.height / r;
    });
    _(this, "fireTouchEvents", async (i) => {
      const e = this.map;
      let r = this.mapWidth, s = this.mapHeight;
      const a = this._positions, c = a.size, l = this._isPinching;
      if (c !== 1 && this._buttonDown[MouseButton$1.LEFT]) {
        if (this._buttonDown[MouseButton$1.LEFT] = !1, this._touchHoldTimer && (clearTimeout(this._touchHoldTimer), this._touchHoldTimer = void 0), i && this.onEventPointerUp && this.onEventPointerUp(i), c === 0 && !this._isTouchHolding && i && this.onEventClick && !this.hasMoved) {
          const h = this._primaryStartPosition, d = Array.from(this._previousPositions.values())[0];
          checkPixelTolerance$1(h, d, this._clickPixelTolerance) && this.onEventClick(i);
        }
        this._isTouchHolding = !1, this.hasMoved = !1, this.currentAction, EventAction.NONE;
      }
      if (c <= 1 && l && (this._pinchActionTimer && (clearTimeout(this._pinchActionTimer), this._pinchActionTimer = void 0), this._isPinching = !1, this._whichKindOfPinch = void 0, this._lastPinchDist = 0, this.currentAction, EventAction.NONE), c === 1 && !l) {
        const h = Array.from(a.values())[0];
        this._primaryPosition.copy(h), this._primaryStartPosition.copy(h), this._primaryPreviousPosition.copy(h), this._buttonDown[MouseButton$1.LEFT] = !0;
        const d = this.map.domContainer.getBoundingClientRect();
        this.startBoundX = d.left, this.startBoundY = d.top, this.startScaleX = d.width / r, this.startScaleY = d.height / s;
        const f = h.x, p = h.y;
        this.startProjectionCenter.fromArray(e.getProjectionCenter());
        const m = new Vector2$1(f / r * 2 - 1, 1 - 2 * p / s), y = await this._pickPosition(m);
        this.startCamera.copy(e.camera), this.startCamera.updateMatrixWorld(), _mapPlane.constant = -y.z, this.startPoint.copy(y), this.currentAction = EventAction.PAN, i && this.onEventPointerDown && this.onEventPointerDown(i), this.startX = f, this.startY = p, this.startAtTop = p < s / 2, document.addEventListener(EVENTS.UP, this.handlePointerUpWithThrottle), this._touchHoldTimer = setTimeout(function() {
          if (this._enabled && (this._touchHoldTimer = void 0, this._isTouchHolding = !0, i && this.onEventClick)) {
            const x = this._primaryStartPosition, v = Array.from(this._previousPositions.values())[0];
            checkPixelTolerance$1(x, v, this._clickPixelTolerance) && this.onEventClick(i);
          }
        }, this.touchHoldDelayMilliseconds), i.preventDefault();
      }
      if (c === 2 && !l) {
        const h = Array.from(a.values())[0], d = Array.from(a.values())[1];
        this._isPinching = !0;
        const f = e.getProjectionCenter();
        this.startPoint.set(f[0], f[1], f[2]);
        const p = e.decomposeRotation();
        this.startHeading = p.heading, this.startPitch = p.pitch, this.startDistance = e.camera.position.distanceTo(this.startPoint);
        const m = h.x, y = h.y;
        this.showCursorAnchor(m, y), this.currentAction = EventAction.ROTATE, this.startX = d.x, this.startY = d.y, this._lastPinchDist = h.distanceTo(d), this._pinchConnectPosition.position1.copy(h), this._pinchConnectPosition.position2.copy(d), this._pinchActionTimer = setTimeout(() => {
          this._enabled && (clearTimeout(this._pinchActionTimer), this._pinchActionTimer = void 0);
        }, 150), i.preventDefault();
      }
    });
    _(this, "fireTouchMoveEvents", async (i) => {
      const e = this.map, r = this._positions;
      this._previousPositions;
      const s = r.size;
      if (this.currentAction !== EventAction.NONE && (this.hasMoved = !0, !(this.onMouseDragging && !this.onMouseDragging()))) {
        if (this.map.domContainer.style.cursor = "grabbing", s === 1 && this._buttonDown[MouseButton$1.LEFT] && this._enablePan) {
          const a = Array.from(r.values())[0], c = a.x, l = a.y;
          this._primaryPosition.copy(a);
          const h = this._primaryPreviousPosition;
          if (this.getNdc(c, l, _mouse), !this.ndcToPoint(_mouse, this.startCamera, _mapMcCoord) || _mapMcCoord.distanceTo(e.camera.position) > e.camera.far * 0.8) {
            await this.handlePointerUp();
            return;
          }
          _mapMcCoord.sub(this.startPoint), _mapMcCoord.subVectors(this.startCamera.position, _mapMcCoord), e.camera.position.copy(_mapMcCoord), e.center = [_mapMcCoord.x, _mapMcCoord.y], i && this.onEventMouseMove && this.onEventMouseMove(i), h.copy(a), i.preventDefault();
        } else if (s === 2 && this._isPinching) {
          const a = e.camera, c = Array.from(r.values())[0], l = Array.from(r.values())[1];
          if (this._pinchActionTimer) {
            this._pinchActionPosition.position1.copy(c), this._pinchActionPosition.position2.copy(l);
            return;
          }
          if (this._whichKindOfPinch === void 0) {
            const h = new Vector2$1(), d = new Vector2$1(), f = new Vector2$1();
            h.subVectors(this._pinchConnectPosition.position1, this._pinchConnectPosition.position2), h.normalize(), d.subVectors(this._pinchActionPosition.position1, this._pinchConnectPosition.position1), d.normalize(), f.subVectors(this._pinchActionPosition.position2, this._pinchConnectPosition.position2), f.normalize();
            const p = d.dot(f), m = h.dot(f);
            p > 0.8 ? this._whichKindOfPinch = EventAction.PITCH : Math.abs(m) < 0.7 ? this._whichKindOfPinch = EventAction.ROTATE : this._whichKindOfPinch = EventAction.ZOOM;
          }
          if (this._whichKindOfPinch === EventAction.PITCH && this._enableTilt) {
            const d = l.y - this.startY;
            let f = this.startPitch + d * this.pitchSpeed;
            if (f = this.makePitchSafe(f), this._rotationMode <= 1)
              e._cameraLookAt(a, this.startPoint, {
                heading: this.startHeading,
                pitch: f,
                range: this.startDistance
              });
            else {
              e._cameraLookAt(_tempCamera, this.startPoint, {
                heading: this.startHeading,
                pitch: f,
                range: 0.2
              }), this.getNdc(this.startX, this.startY, _mouse), _raycaster$2.setFromCamera(_mouse, _tempCamera);
              const p = _raycaster$2.ray.direction.clone();
              _mouse.set(0, 0), _raycaster$2.setFromCamera(_mouse, _tempCamera);
              const m = _raycaster$2.ray.direction.clone();
              p.angleTo(m);
              const y = new Vector3$1();
              y.copy(p), y.normalize(), y.multiplyScalar(this.startDistance), a.position.copy(_mapMcCoord.copy(this.startPoint).sub(y)), a.quaternion.copy(_tempCamera.quaternion);
            }
            e.pitch = f;
          } else if (this._whichKindOfPinch === EventAction.ZOOM && this._enableZoom) {
            const h = c.distanceTo(l), d = (this._lastPinchDist - h) * 2, f = MathUtils.clamp(d * this.zoomSpeed * -1, -0.5, 0.5);
            this.getNdc((c.x + l.x) / 2, (c.y + l.y) / 2, _mouse);
            const p = await this._pickPosition(_mouse), m = a.position.distanceTo(p);
            if (m > a.far * 0.95)
              return;
            let y = f * MathUtils.clamp(m, 0.5, 1e7);
            y + 0.2 > m ? (y = m - 0.2, e.range = 0.2) : e.range = m - y, e.maxRange && e.maxRange < m && f < 0 && (y = 0);
            const x = new Vector3$1();
            x.subVectors(p, a.position), x.normalize();
            const v = new Vector3$1();
            v.copy(x).multiplyScalar(y).add(a.position), a.position.copy(v), e.center = [v.x, v.y], this._lastPinchDist = h;
          } else if (this._whichKindOfPinch === EventAction.ROTATE && this._enableRotate) {
            const h = new Vector2$1();
            h.subVectors(this._pinchConnectPosition.position2, this._pinchConnectPosition.position1), h.normalize();
            const d = new Vector2$1();
            d.subVectors(l, c), d.normalize();
            let f = vector2RotateTo(d, h), p = this.startHeading - f / Math.PI * 180;
            p = this.makeHeadingSafe(p), e._cameraLookAt(a, this.startPoint, {
              heading: p,
              pitch: this.startPitch,
              range: this.startDistance
            });
          }
        }
        this.handleCameraBeforeRender(), this.map.updateView();
      }
    });
    _(this, "handlePointerMove", async (i) => {
      if (isPointerTouch(i)) {
        const e = this._positions, r = i.pointerId;
        let s = e.get(r);
        if (!s)
          return;
        let a = this.getPixelPosition(i);
        s.set(a[0], a[1]), await this.fireTouchMoveEvents(i), this._previousPositions.get(r).copy(e.get(r));
      } else
        await this.handleMouseMove(i);
    });
    _(this, "handleMouseMove", async (i) => {
      this.onEventMouseMove && this.onEventMouseMove(i);
    });
    _(this, "handlePointerDown", async (i) => {
      if (isPointerTouch(i)) {
        const e = i.pointerId;
        let r = this.getPixelPosition(i);
        this._positions.set(e, new Vector2$1(r[0], r[1])), await this.fireTouchEvents(i), this._previousPositions.set(e, this._positions.get(e).clone());
      } else
        await this.handleMouseDown(i);
    });
    _(this, "handleMouseDown", async (i) => {
      const e = this.map;
      let r = this.mapWidth, s = this.mapHeight;
      const a = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = a.left, this.startBoundY = a.top, this.startScaleX = a.width / r, this.startScaleY = a.height / s;
      const [c, l] = this.getPixelPosition(i);
      this.startProjectionCenter.fromArray(e.getProjectionCenter()), this.lastMoveDistance = 0;
      const h = new Vector2$1(c / r * 2 - 1, 1 - 2 * l / s);
      if (cancelAnimationFrame(this._inertiaAnimationHanlder), this._draggingMovementAggregator.start(c, l), i.button === 0) {
        const d = await this._pickPosition(h);
        this.startCamera.copy(e.camera), this.startCamera.updateMatrixWorld(), _mapPlane.constant = -d.z, this.startPoint.copy(d), this.currentAction = EventAction.PAN;
      } else if (i.button === 2) {
        if (this._rotationMode === 0) {
          _tempPixel.set(0, 0), _raycaster$2.setFromCamera(_tempPixel, e.camera), _raycaster$2.ray.intersectPlane(_mapPlane, _mapMcCoord0), this.startPoint.copy(_mapMcCoord0);
          const d = e.decomposeRotation();
          this.startHeading = d.heading, this.startPitch = d.pitch;
        } else if (this._rotationMode === 1) {
          const d = await this._pickPosition(new Vector2$1());
          this.startPoint.copy(d);
          const f = e.decomposeRotation();
          this.startHeading = f.heading, this.startPitch = f.pitch;
        } else {
          const d = await this._pickPosition(h);
          this.startCamera.copy(e.camera), this.startCamera.updateMatrixWorld();
          const f = new Vector3$1();
          f.subVectors(d, this.startCamera.position), f.normalize(), this.startPoint.copy(d);
          const p = e.decomposeRotationFromDirection(f);
          this.startHeading = p.heading, this.startPitch = p.pitch;
        }
        this.startDistance = e.camera.position.distanceTo(this.startPoint), this.currentAction = EventAction.ROTATE, this.showCursorAnchor(c, l);
      } else
        this.currentAction = EventAction.NONE;
      this.currentAction !== EventAction.NONE && (i && this.onEventPointerDown && (this.hasMoved || this.onEventPointerDown(i)), this.startX = c, this.startY = l, this.startAtTop = l < s / 2, this.isPointerDown = !0, document.addEventListener(EVENTS.MOVE, this.handleMouseDraggingWithThrottle), document.addEventListener(EVENTS.UP, this.handlePointerUpWithThrottle));
    });
    _(this, "_reactDragging", async (i, e) => {
      this.currentAction === EventAction.PAN ? (this.map.domContainer.style.cursor = "grabbing", await this.handlePan(i, e)) : this.currentAction === EventAction.ROTATE && (this.map.domContainer.style.cursor = "grabbing", await this.handleRotate(i, e)), this.handleCameraBeforeRender(), this.map.updateView();
    });
    _(this, "handleMouseDragging", async (i) => {
      if (this.currentAction === EventAction.NONE)
        return;
      this.hasMoved = !0;
      const [e, r] = this.getPixelPosition(i);
      this._draggingMovementAggregator.update(e, r), !(this.onMouseDragging && !this.onMouseDragging()) && await this._reactDragging(e, r);
    });
    _(this, "handlePointerUp", async (i) => {
      if (isPointerTouch(i)) {
        const e = i.pointerId;
        this._positions.delete(e), this.fireTouchEvents(i), this._previousPositions.delete(e);
      } else
        await this.handleMouseUp(i);
    });
    _(this, "_startInertiaAnimation", () => {
      const [i, e] = this._draggingMovementAggregator.getInertiaPosition();
      e ? (this._inInertia = !0, this._reactDragging(i.x, i.y), this._inertiaAnimationHanlder = requestAnimationFrame(this._startInertiaAnimation)) : (this._inInertia = !1, this.currentAction = EventAction.NONE);
    });
    _(this, "handleMouseUp", async (i) => {
      this.enableInertia && this.currentAction !== EventAction.NONE ? (this._draggingMovementAggregator.startInertia(this.currentAction === EventAction.ROTATE), this._startInertiaAnimation()) : this.currentAction = EventAction.NONE, this.map.domContainer.style.cursor = "default", this.hideCursorAnchor(), document.removeEventListener(EVENTS.MOVE, this.handleMouseDraggingWithThrottle), document.removeEventListener(EVENTS.UP, this.handlePointerUpWithThrottle), i && this.onEventPointerUp && this.onEventPointerUp(i), i && this.onEventClick && (this.hasMoved || this.onEventClick(i)), i && this.onEventDblClick && (!this.hasMoved && this.waitSecondClick ? (this.onEventDblClick(i), this.clearDoubleClickTimer()) : this.waitSecondClick = !0), clearTimeout(this.doubleClickTimer), this.doubleClickTimer = setTimeout(() => {
        this.clearDoubleClickTimer();
      }, this.clickInterval), this.hasMoved = !1, this.isPointerDown = !1;
    });
    _(this, "clearDoubleClickTimer", () => {
      this.doubleClickTimer && clearTimeout(this.doubleClickTimer), this.waitSecondClick = !1, this.doubleClickTimer = null;
    });
    _(this, "handleContextMenu", (i) => {
      i.preventDefault();
    });
    _(this, "_reactZoom", async (i, e, r, s) => {
      await this.handleZoom({
        deltaX: i,
        deltaY: e,
        pixelX: r,
        pixelY: s
      }), this.handleCameraBeforeRender(), this.map.updateView();
    });
    _(this, "_startZoomInertiaAnimation", (i, e) => {
      this._zoomInertiaAnimationHandler = requestAnimationFrame(() => {
        const [r, s] = this._zoomMovementAggregator.getInertiaPosition();
        if (s > 0.1) {
          const a = this._zoomMovementAggregator.inertiaDirection.y < 0;
          this._reactZoom(0, a ? s * -1 : s, i, e), this._startZoomInertiaAnimation(i, e);
        }
      });
    });
    _(this, "handleWheel", async (i) => {
      i.preventDefault(), i.stopPropagation();
      const [e, r] = this.getPixelPosition(i);
      if (cancelAnimationFrame(this._inertiaAnimationHanlder), cancelAnimationFrame(this._zoomInertiaAnimationHandler), this.enableInertia) {
        const s = performance.now(), a = i.deltaY < 0;
        let c = Math.abs(i.deltaY);
        c > 20 && (c = 20), this._zoomMovementAggregator.setInertiaState(c, new Vector2$1(0, a ? -1 : 1), s), this._startZoomInertiaAnimation(e, r);
      } else
        this._reactZoom(0, i.deltaY, e, r);
    });
    _(this, "_calculateViewDistance", (i, e, r) => {
      const s = r / 2, a = e * Math.PI / 180, c = s * Math.PI / 180, l = Math.min(a + c, this.maxPitch * Math.PI / 180);
      _raycaster$2.setFromCamera(_bottomCenterNdc, this.startCamera), _raycaster$2.ray.intersectPlane(_mapPlane, _bottomCenterMcCoord);
      const h = _bottomCenterMcCoord.distanceTo(this.startProjectionCenter), d = i * (Math.tan(l) - Math.tan(a)), f = i / Math.cos(l);
      return {
        centerToNearDistance: h,
        centerToFarDistance: d,
        cameraToFarDistance: f,
        overPitch: e + s > this.maxPitch
      };
    });
    _(this, "handlePan", async (i, e) => {
      if (!this._enablePan)
        return;
      const r = this.map, s = this.startCamera;
      this.getNdc(i, e, _mouse);
      let a = this.ndcToPoint(_mouse, s, _mapMcCoord);
      const c = r.getViewHeight(), l = r.getPitch(), h = r.camera.fov, {
        centerToNearDistance: d,
        centerToFarDistance: f,
        cameraToFarDistance: p,
        overPitch: m
      } = this._calculateViewDistance(c, l, h), y = m ? 18 : f / d, x = p / y * 15;
      if (!a) {
        this.currentAction = EventAction.NONE, this._inInertia = !1, this.isPointerDown && (this.isPointerDown = !1, await this.handlePointerUp());
        return;
      }
      const v = _mapMcCoord.distanceTo(s.position);
      if (this.isPointerDown && v > x) {
        this.isPointerDown = !1, await this.handlePointerUp();
        return;
      }
      _mapMcCoord1.subVectors(_mapMcCoord, this.startPoint);
      let S = _mapMcCoord1.length(), E = this._getElasticValue(S, 0, x / 2, 0.9);
      S > x && (E = this.lastMoveDistance + Math.min(E - this.lastMoveDistance, c) / 50), this.lastMoveDistance = E, _mapMcCoord1.normalize().multiplyScalar(E), _mapMcCoord.subVectors(this.startCamera.position, _mapMcCoord1), r.camera.position.copy(_mapMcCoord), r.center = [_mapMcCoord.x, _mapMcCoord.y];
    });
    _(this, "handleRotate", async (i, e) => {
      if (!this._enableRotate && !this._enableTilt)
        return;
      const r = this.map, s = r.camera;
      let a = i - this.startX;
      const c = e - this.startY;
      this.startAtTop || (a *= -1);
      let l = this.startHeading;
      this._enableRotate && (l = this.startHeading + a * this.headingSpeed, l = this.makeHeadingSafe(l));
      let h = this.startPitch;
      if (this._enableTilt && (h = this.getElasticPitch(c), h = this.makePitchSafe(h)), this._rotationMode <= 1)
        r._cameraLookAt(s, this.startPoint, {
          heading: l,
          pitch: h,
          range: this.startDistance
        });
      else {
        r._cameraLookAt(_tempCamera, this.startPoint, {
          heading: l,
          pitch: h,
          range: 0.2
        }), this.getNdc(this.startX, this.startY, _mouse), _raycaster$2.setFromCamera(_mouse, _tempCamera);
        const d = _raycaster$2.ray.direction.clone();
        _mouse.set(0, 0), _raycaster$2.setFromCamera(_mouse, _tempCamera);
        const f = _raycaster$2.ray.direction.clone();
        d.angleTo(f);
        const p = new Vector3$1();
        p.copy(d), p.normalize(), p.multiplyScalar(this.startDistance), s.position.copy(_mapMcCoord.copy(this.startPoint).sub(p)), s.quaternion.copy(_tempCamera.quaternion);
      }
      r.pitch = h, r.heading = l;
    });
    _(this, "handleZoom", async (i) => {
      if (!this._enableZoom)
        return;
      const e = this.map, r = e.range;
      if (i.deltaY < 0 && r < e.minRange || i.deltaY > 0 && r > e.maxRange)
        return;
      let s = this.mapWidth, a = this.mapHeight;
      const c = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = c.left, this.startBoundY = c.top, this.startScaleX = c.width / s, this.startScaleY = c.height / a;
      const l = e.camera, h = MathUtils.clamp(i.deltaY * this.zoomSpeed * -1, -0.5, 0.5);
      this.getNdc(i.pixelX, i.pixelY, _mouse);
      const d = await this._pickPosition(_mouse), f = l.position.distanceTo(d);
      if (f > l.far * 0.95)
        return;
      let p = h * MathUtils.clamp(f, 0.5, 1e7);
      p + 0.2 > f ? (p = f - 0.2, e.range = 0.2) : e.range = f - p, e.maxRange && e.maxRange < f && h < 0 && (p = 0);
      const m = new Vector3$1();
      m.subVectors(d, l.position), m.normalize();
      const y = new Vector3$1();
      y.copy(m).multiplyScalar(p).add(l.position), l.position.copy(y), e.center = [y.x, y.y];
    });
    _(this, "makeHeadingSafe", (i) => (i %= 360, i < 0 && (i += 360), i));
    _(this, "makePitchSafe", (i) => i < this.minPitch ? this.minPitch : i > this.maxPitch ? this.maxPitch : i);
    _(this, "getElasticPitch", (i) => {
      const e = this.maxPitch - 8, r = (this.minPitch - this.startPitch) / this.pitchSpeed, s = Math.max(0, e - this.startPitch) / this.pitchSpeed, a = this._inInertia ? 0.3 : 0.4;
      return i = this._getElasticValue(i, r, s, a), this.startPitch + i * this.pitchSpeed;
    });
    _(this, "_getElasticValue", (i, e, r, s = 0.4) => (i > r ? i = Math.pow(i - r + 1, s) + r - 1 : i < e && (i = e - Math.pow(e - i + 1, s) + 1), i));
    _(this, "_tiltBounceBack", () => {
      const i = this.map;
      let e = i.getPitch();
      e < this.minPitch && this._rotationMode <= 1 && (i._cameraLookAt(i.camera, this.startPoint, {
        heading: i.getHeading(),
        pitch: this.minPitch,
        range: this.startDistance
      }), i.pitch = this.minPitch), e > this.maxPitch && this._rotationMode <= 1 && (i._cameraLookAt(i.camera, this.startPoint, {
        heading: i.getHeading(),
        pitch: this.maxPitch,
        range: this.startDistance
      }), i.pitch = this.maxPitch);
    });
    _(this, "dispose", () => {
      const i = this.map.domContainer;
      i.removeEventListener(EVENTS.DOWN, this.handlePointerDownWithThrottle), i.removeEventListener(EVENT_WHEEL, this.handleWheelWithThrottle), i.removeEventListener(EVENT_CONTEXTMENU, this.handleContextMenu), document.removeEventListener(EVENTS.MOVE, this.handleMouseDraggingWithThrottle), document.removeEventListener(EVENTS.UP, this.handlePointerUpWithThrottle), i.removeEventListener(EVENTS.MOVE, this.handlePointerMoveWithThrottle), this.clearDoubleClickTimer(), this.cursorAnchor.remove();
    });
    this.map = i, this.enabled = !0, this.currentAction = EventAction.NONE, this._eventThrottle = new EventThrottle(), this._draggingMovementAggregator = new DraggingMovementAggregator(), this._zoomMovementAggregator = new PointerMovementAggregator({
      resistance: 5e-3
    });
  }
  handleCameraBeforeRender() {
    this.map.camera.updateMatrix(), this.map.camera.updateMatrixWorld();
    let i = !0;
    this.onEventCameraChange && (i = this.onEventCameraChange()), i ? (this.originCamera = this.map.camera.clone(), this.originMap = {
      center: this.map.center,
      pitch: this.map.pitch,
      heading: this.map.heading
    }) : (this.map.camera.copy(this.originCamera, !0), this.map._engine.camera.copy(this.originCamera, !0), this.map.camera.updateMatrix(), this.map.camera.updateMatrixWorld(), this.map.camera.updateProjectionMatrix(), this.map.pitch = this.originMap.pitch, this.map.center = this.originMap.center, this.map.heading = this.originMap.heading);
  }
  getPixelPosition(i) {
    let e = i.clientX, r = i.clientY;
    isTouchEvent(i) && (e = i.changedTouches[0].clientX, r = i.changedTouches[0].clientY);
    const s = this.currentPixelX = (e - this.startBoundX) / this.startScaleX, a = this.currentPixelY = (r - this.startBoundY) / this.startScaleY;
    return [s, a];
  }
  ndcToPoint(i, e, r) {
    return _raycaster$2.setFromCamera(i, e), _raycaster$2.ray.intersectsPlane(_mapPlane) ? (_raycaster$2.ray.intersectPlane(_mapPlane, r), !0) : !1;
  }
  getNdc(i, e, r) {
    r.x = i / this.mapWidth * 2 - 1, r.y = 1 - e / this.mapHeight * 2;
  }
  async _pickPosition(i) {
    return await this.map._engine.rendering.picking.pickWorldPositionFromNdc(i);
  }
  set enabled(i) {
    i !== this._enabled && (i ? this.init() : this.dispose(), this._enabled = i);
  }
  set enableRotate(i) {
    this._enableRotate = i;
  }
  set enableZoom(i) {
    this._enableZoom = i;
  }
  set enablePan(i) {
    this._enablePan = i;
  }
  set enableTilt(i) {
    this._enableTilt = i;
  }
  get inertiaDragging() {
    return this._draggingMovementAggregator.scale;
  }
  set inertiaDragging(i) {
    this._draggingMovementAggregator.scale = i;
  }
  get inertiaZoom() {
    return this._zoomMovementAggregator.scale;
  }
  set inertiaZoom(i) {
    this._zoomMovementAggregator.scale = i;
  }
}
function checkPixelTolerance$1(o, i, e) {
  const r = o.x - i.x, s = o.y - i.y;
  return Math.sqrt(r * r + s * s) < e;
}
const DEFAULT_DIRECTION = new Vector3$1(0, 0, -1), UP_DIRECTION = new Vector3$1(0, 1, 0), _raycaster$1 = new Raycaster();
_raycaster$1.mouse = new Vector2$1();
const _seaLevelPlane = new Plane(new Vector3$1(0, 0, 1), 0), _tempVector3$7 = new Vector3$1();
new Matrix4();
class BlankMap3DControl extends BlankMap {
  constructor() {
    super(...arguments);
    _(this, "isBlankMap3D", !0);
    _(this, "_viewStateDirty", !0);
    _(this, "maxRange", 1 / 0);
    _(this, "minRange", 1e-6);
    _(this, "range");
    _(this, "bounds", []);
    _(this, "getPixelSize", (e) => {
      const [r, s] = this.getContainerSize();
      return Math.tan(MathUtils.degToRad(this.fov / 2)) * e / s * 2;
    });
    _(this, "handleEventCameraChange", () => {
      const [e, r] = this.bounds;
      if (e && r) {
        const [s, a] = e, [c, l] = r, [h, d, f] = this.projectArrayCoordinate(this.getCenter());
        let p = !1;
        return Math.ceil(h) < s && (p = !0), Math.ceil(d) < a && (p = !0), Math.floor(h) > c && (p = !0), Math.floor(d) > l && (p = !0), !p;
      }
      return !0;
    });
  }
  resetHome() {
    this.lookAt(BlankMap.DEFAULT_CENTER, {
      range: 1e7,
      pitch: 0,
      heading: 0
    });
  }
  initControl() {
    this.control = new MapControl3D(this), this.control.onEventPointerDown = this.handleEventPointerDown, this.control.onEventPointerUp = this.handleEventPointerUp, this.control.onEventClick = this.handleEventClick, this.control.onEventDblClick = this.handleEventDblClick, this.control.onEventMouseMove = this.handleEventMouseMove, this.control.onEventCameraChange = this.handleEventCameraChange;
  }
  updateView() {
    this.handleViewChange();
  }
  getCenter() {
    return this.unprojectArrayCoordinate(this.getProjectionCenter());
  }
  getProjectionCenter() {
    return _raycaster$1.setFromCamera(new Vector2$1(), this.camera), _raycaster$1.ray.intersectPlane(_seaLevelPlane, _tempVector3$7), [_tempVector3$7.x, _tempVector3$7.y, _tempVector3$7.z];
  }
  getPitch() {
    return this.pitch;
  }
  getHeading() {
    return this.heading;
  }
  getRange() {
    return this.getCalcRange();
  }
  getCalcRange() {
    const e = this.getProjectionCenter();
    if (typeof this.camera.position.z == "string")
      throw new Error("camera.position.z is string");
    return this.camera.position.distanceTo(_tempVector3$7.set(e[0], e[1], e[2]));
  }
  getZoom() {
    return this.getZoomByZoomUnits(this.getZoomUnits());
  }
  getZoomUnits() {
    const e = this.getRange();
    return this.getPixelSize(e);
  }
  getCameraDistance(e) {
    if (this.range && !e)
      return this.range;
    if (e) {
      const r = this.getProjectionCenter(), s = this.camera.position.distanceTo(new Vector3$1(r[0], r[1], r[2]));
      return this.range = s, this.range;
    }
    return _raycaster$1.setFromCamera(new Vector2$1(), this.camera), _raycaster$1.ray.intersectPlane(_seaLevelPlane, _tempVector3$7), this.range = this.camera.position.distanceTo(_tempVector3$7), this.range;
  }
  setCenter(e) {
    this.setProjectionCenter(this.projectArrayCoordinate(e));
  }
  setProjectionCenter(e) {
    const r = this.decomposeRotation();
    this._cameraLookAt(this.camera, e, {
      ...r,
      height: this.camera.position.z
    }), this.center = e, this.updateView();
  }
  setZoom(e) {
    const r = this.decomposeRotation(), s = this.getProjectionCenter(), a = this.getZoomUnitsByZoom(e), [c, l] = this.getContainerSize(), h = l / 2 * a / Math.tan(MathUtils.degToRad(this.fov / 2));
    this._cameraLookAt(this.camera, s, {
      ...r,
      range: h * 0.1,
      height: h
    }), this.range = h * 0.1, this.updateView();
  }
  setPitch(e) {
    const r = this.decomposeRotation(), s = this.getProjectionCenter(), a = this.camera.position.distanceTo(_tempVector3$7.set(s[0], s[1], s[2]));
    this._cameraLookAt(this.camera, s, {
      heading: r.heading,
      pitch: e,
      range: a
    }), this.pitch = e, this.updateView();
  }
  setHeading(e) {
    const r = this.decomposeRotation(), s = this.getProjectionCenter(), a = this.camera.position.distanceTo(_tempVector3$7.set(s[0], s[1], s[2]));
    this._cameraLookAt(this.camera, s, {
      heading: e,
      pitch: r.pitch,
      range: a
    }), this.heading = e, this.updateView();
  }
  setRange(e) {
    const r = this.decomposeRotation(), s = this.getProjectionCenter();
    this._cameraLookAt(this.camera, s, {
      ...r,
      range: e
    }), this.range = e, this.updateView();
  }
  setMaxRange(e) {
    this.maxRange = e;
  }
  setMinRange(e) {
    this.minRange = e;
  }
  zoomIn() {
    const e = this.decomposeRotation(), r = this.getProjectionCenter();
    let s = this.camera.position.distanceTo(_tempVector3$7.set(r[0], r[1], r[2])), c = 0.5 * MathUtils.clamp(s, 0.5, 1e7);
    c + 0.2 > s ? (c = s - 0.2, s = 0.2) : s = s - c, this._cameraLookAt(this.camera, r, {
      ...e,
      range: s
    }), this.range = s, this.updateView();
  }
  zoomOut() {
    const e = this.decomposeRotation(), r = this.getProjectionCenter();
    let s = this.camera.position.distanceTo(_tempVector3$7.set(r[0], r[1], r[2])), c = -0.5 * MathUtils.clamp(s, 0.5, 1e7);
    c + 0.2 > s ? (c = s - 0.2, s = 0.2) : s = s - c, this._cameraLookAt(this.camera, r, {
      ...e,
      range: s
    }), this.range = s, this.updateView();
  }
  lookAt(e, r = {}) {
    let s = [];
    e.isVector3 ? e.toArray(s) : s = e;
    let a = this.projectArrayCoordinate(s);
    const {
      heading: c,
      pitch: l,
      range: h
    } = r;
    isNaN(c) || (this.heading = c), isNaN(l) || (this.pitch = l), isNaN(h) || (this.range = h), this._cameraLookAt(this.camera, a, r), this.updateView();
  }
  _cameraLookAt(e, r, s) {
    const {
      heading: a = this.heading,
      pitch: c = this.pitch,
      range: l = this.range,
      height: h
    } = s, d = this._getCameraQuaternion(a, c), f = new Vector3$1(0, 0, -1);
    f.applyQuaternion(d), f.negate();
    const p = _tempVector3$7;
    Array.isArray(r) ? p.set(r[0], r[1], r[2] || 0) : r.isVector3 && p.copy(r), isNaN(l) || p.add(f.multiplyScalar(MathUtils.clamp(l, this.minRange, this.maxRange))), e.position.copy(p), e.quaternion.copy(d), e.updateMatrix(), e.updateMatrixWorld();
  }
  offsetFromHeadingPitchRange(e = 0, r = 0, s = 0) {
    const a = new Quaternion$1();
    a.setFromAxisAngle(new Vector3$1(0, 0, 1), e * Math.PI / 180);
    const c = new Quaternion$1();
    c.setFromAxisAngle(new Vector3$1(1, 0, 0), r * Math.PI / 180);
    const l = new Quaternion$1();
    l.multiplyQuaternions(a, c);
    const h = new Vector3$1(0, 0, -1);
    h.applyQuaternion(l), h.negate();
    const d = new Vector3$1();
    return d.copy(h).multiplyScalar(s), d;
  }
  decomposeRotation() {
    const e = this.camera.quaternion, r = DEFAULT_DIRECTION.clone(), s = UP_DIRECTION.clone();
    return r.applyQuaternion(e), r.clampScalar(-1, 1), s.applyQuaternion(e), this.decomposeRotationFromDirection(r, s);
  }
  decomposeRotationFromDirection(e, r) {
    const s = 180 - MathUtils.radToDeg(Math.acos(e.z));
    let a = MathUtils.radToDeg(Math.atan2(e.y, e.x));
    return e.x === 0 && e.y === 0 && (a = MathUtils.radToDeg(Math.atan2(r.y, r.x))), a = (a - 90) % 360, {
      heading: a,
      pitch: s
    };
  }
  setBounds(e) {
    this.bounds = [
      this.projectArrayCoordinate(e[0]).map((r) => Math.ceil(r)),
      this.projectArrayCoordinate(e[1]).map((r) => Math.ceil(r))
    ];
  }
  lockDrag(e) {
    e ? this.control.onMouseDragging = () => !1 : this.control.onMouseDragging = null;
  }
  updateCamera() {
    const e = this.camera;
    e.updateMatrix(), e.updateMatrixWorld();
    const [r, s] = this.getContainerSize();
    e.aspect = r / s;
    const a = e.position.z;
    let c = this.pitch + this.fov / 2, l = 1e6;
    l = a / Math.cos(MathUtils.degToRad(Math.min(c, 89))) * 1.25, e.near = Math.min(Math.max(a / 1e4, 0.1), 10), l < 2e4 && (l = 2e4), e.far = l, e.fov = this.fov, e.updateProjectionMatrix(), this._updateCameraLocation();
  }
  get controller() {
    return this.control;
  }
}
new Vector3$1();
class Globe extends Object3D {
  constructor(i, e) {
    super(), this._ellipsoid = i, this._engine = e;
  }
  onBeforeScenePrepareRender(i, e, r, s) {
  }
  get ellipsoid() {
    return this._ellipsoid;
  }
}
const CameraEventType = {
  LEFT_DRAG: 0,
  RIGHT_DRAG: 1,
  MIDDLE_DRAG: 2,
  WHEEL: 3,
  PINCH: 4
};
Object.freeze(CameraEventType);
function returnTrue() {
  return !0;
}
function destroyObject(o, i) {
  i = defaultValue(
    i,
    "This object was destroyed, i.e., destroy() was called."
  );
  function e() {
    throw new DeveloperError(i);
  }
  for (const r in o)
    typeof o[r] == "function" && (o[r] = e);
  o.isDestroyed = returnTrue;
}
const KeyboardEventModifier = {
  SHIFT: 0,
  CTRL: 1,
  ALT: 2
};
Object.freeze(KeyboardEventModifier);
function AssociativeArray() {
  this._array = [], this._hash = {};
}
Object.defineProperties(AssociativeArray.prototype, {
  length: {
    get: function() {
      return this._array.length;
    }
  },
  values: {
    get: function() {
      return this._array;
    }
  }
});
AssociativeArray.prototype.contains = function(o) {
  if (typeof o != "string" && typeof o != "number")
    throw new DeveloperError("key is required to be a string or number.");
  return defined$1(this._hash[o]);
};
AssociativeArray.prototype.set = function(o, i) {
  if (typeof o != "string" && typeof o != "number")
    throw new DeveloperError("key is required to be a string or number.");
  var e = this._hash[o];
  i !== e && (this.remove(o), this._hash[o] = i, this._array.push(i));
};
AssociativeArray.prototype.get = function(o) {
  if (typeof o != "string" && typeof o != "number")
    throw new DeveloperError("key is required to be a string or number.");
  return this._hash[o];
};
AssociativeArray.prototype.remove = function(o) {
  if (defined$1(o) && typeof o != "string" && typeof o != "number")
    throw new DeveloperError("key is required to be a string or number.");
  var i = this._hash[o], e = defined$1(i);
  if (e) {
    var r = this._array;
    r.splice(r.indexOf(i), 1), delete this._hash[o];
  }
  return e;
};
AssociativeArray.prototype.removeAll = function() {
  var o = this._array;
  o.length > 0 && (this._hash = {}, o.length = 0);
};
const ScreenSpaceEventType = {
  LEFT_DOWN: 0,
  LEFT_UP: 1,
  LEFT_CLICK: 2,
  LEFT_DOUBLE_CLICK: 3,
  RIGHT_DOWN: 5,
  RIGHT_UP: 6,
  RIGHT_CLICK: 7,
  MIDDLE_DOWN: 10,
  MIDDLE_UP: 11,
  MIDDLE_CLICK: 12,
  MOUSE_MOVE: 15,
  WHEEL: 16,
  PINCH_START: 17,
  PINCH_END: 18,
  PINCH_MOVE: 19
};
Object.freeze(ScreenSpaceEventType);
function getPosition(o, i, e) {
  var r = o._element;
  if (r === document)
    return e.x = i.clientX, e.y = i.clientY, e;
  var s = r.getBoundingClientRect();
  return e.x = i.clientX - s.left, e.y = i.clientY - s.top, e;
}
function getInputEventKey(o, i) {
  var e = o;
  return defined$1(i) && (e += "+" + i), e;
}
function getModifier(o) {
  if (o.shiftKey)
    return KeyboardEventModifier.SHIFT;
  if (o.ctrlKey)
    return KeyboardEventModifier.CTRL;
  if (o.altKey)
    return KeyboardEventModifier.ALT;
}
const MouseButton = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
function registerListener(o, i, e, r) {
  function s(a) {
    r(o, a);
  }
  e.addEventListener(i, s, {
    capture: !1,
    passive: !1
  }), o._removalFunctions.push(function() {
    e.removeEventListener(i, s, !1);
  });
}
function registerListeners(o) {
  var i = o._element, e = defined$1(i.disableRootEvents) ? i : document;
  typeof PointerEvent < "u" ? (registerListener(
    o,
    "pointerdown",
    i,
    handlePointerDown
  ), registerListener(
    o,
    "pointerup",
    i,
    handlePointerUp
  ), registerListener(
    o,
    "pointermove",
    i,
    handlePointerMove
  ), registerListener(
    o,
    "pointercancel",
    i,
    handlePointerUp
  )) : (registerListener(
    o,
    "mousedown",
    i,
    handleMouseDown
  ), registerListener(
    o,
    "mouseup",
    e,
    handleMouseUp
  ), registerListener(
    o,
    "mousemove",
    e,
    handleMouseMove
  ), registerListener(
    o,
    "touchstart",
    i,
    handleTouchStart
  ), registerListener(
    o,
    "touchend",
    e,
    handleTouchEnd
  ), registerListener(
    o,
    "touchmove",
    e,
    handleTouchMove
  ), registerListener(
    o,
    "touchcancel",
    e,
    handleTouchEnd
  )), registerListener(
    o,
    "dblclick",
    i,
    handleDblClick
  );
  var r;
  "onwheel" in i ? r = "wheel" : document.onmousewheel !== void 0 ? r = "mousewheel" : r = "DOMMouseScroll", registerListener(o, r, i, handleWheel);
}
function unregisterListeners(o) {
  for (var i = o._removalFunctions, e = 0; e < i.length; ++e)
    i[e]();
}
var mouseDownEvent = {
  position: new Vector2$1()
};
function gotTouchEvent(o) {
  o._lastSeenTouchEvent = Date.now();
}
function canProcessMouseEvent(o) {
  return Date.now() - o._lastSeenTouchEvent > ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;
}
function checkPixelTolerance(o, i, e) {
  var r = o.x - i.x, s = o.y - i.y, a = Math.sqrt(r * r + s * s);
  return a < e;
}
function handleMouseDown(o, i) {
  if (!!canProcessMouseEvent(o)) {
    var e = i.button;
    o._buttonDown[e] = !0;
    var r;
    if (e === MouseButton.LEFT)
      r = ScreenSpaceEventType.LEFT_DOWN;
    else if (e === MouseButton.MIDDLE)
      r = ScreenSpaceEventType.MIDDLE_DOWN;
    else if (e === MouseButton.RIGHT)
      r = ScreenSpaceEventType.RIGHT_DOWN;
    else
      return;
    var s = getPosition(
      o,
      i,
      o._primaryPosition
    );
    Cartesian2.clone(s, o._primaryStartPosition), Cartesian2.clone(s, o._primaryPreviousPosition);
    var a = getModifier(i), c = o.getInputAction(
      r,
      a
    );
    defined$1(c) && (Cartesian2.clone(s, mouseDownEvent.position), mouseDownEvent.event = i, c(mouseDownEvent), i.preventDefault());
  }
}
var mouseUpEvent = {
  position: new Vector2$1()
}, mouseClickEvent = {
  position: new Vector2$1()
};
function cancelMouseEvent(o, i, e, r) {
  var s = getModifier(r), a = o.getInputAction(
    i,
    s
  ), c = o.getInputAction(
    e,
    s
  );
  if (defined$1(a) || defined$1(c)) {
    var l = getPosition(
      o,
      r,
      o._primaryPosition
    );
    if (defined$1(a) && (Cartesian2.clone(l, mouseUpEvent.position), mouseUpEvent.event = r, a(mouseUpEvent)), defined$1(c)) {
      var h = o._primaryStartPosition;
      checkPixelTolerance(
        h,
        l,
        o._clickPixelTolerance
      ) && (Cartesian2.clone(l, mouseClickEvent.position), mouseClickEvent.event = r, c(mouseClickEvent));
    }
  }
}
function handleMouseUp(o, i) {
  if (!!canProcessMouseEvent(o)) {
    var e = i.button;
    e !== MouseButton.LEFT && e !== MouseButton.MIDDLE && e !== MouseButton.RIGHT || (o._buttonDown[MouseButton.LEFT] && (cancelMouseEvent(
      o,
      ScreenSpaceEventType.LEFT_UP,
      ScreenSpaceEventType.LEFT_CLICK,
      i
    ), o._buttonDown[MouseButton.LEFT] = !1), o._buttonDown[MouseButton.MIDDLE] && (cancelMouseEvent(
      o,
      ScreenSpaceEventType.MIDDLE_UP,
      ScreenSpaceEventType.MIDDLE_CLICK,
      i
    ), o._buttonDown[MouseButton.MIDDLE] = !1), o._buttonDown[MouseButton.RIGHT] && (cancelMouseEvent(
      o,
      ScreenSpaceEventType.RIGHT_UP,
      ScreenSpaceEventType.RIGHT_CLICK,
      i
    ), o._buttonDown[MouseButton.RIGHT] = !1));
  }
}
var mouseMoveEvent = {
  startPosition: new Vector2$1(),
  endPosition: new Vector2$1()
};
function handleMouseMove(o, i) {
  if (!!canProcessMouseEvent(o)) {
    var e = getModifier(i), r = getPosition(
      o,
      i,
      o._primaryPosition
    ), s = o._primaryPreviousPosition, a = o.getInputAction(
      ScreenSpaceEventType.MOUSE_MOVE,
      e
    );
    defined$1(a) && (Cartesian2.clone(s, mouseMoveEvent.startPosition), Cartesian2.clone(r, mouseMoveEvent.endPosition), mouseMoveEvent.event = i, a(mouseMoveEvent)), Cartesian2.clone(r, s), (o._buttonDown[MouseButton.LEFT] || o._buttonDown[MouseButton.MIDDLE] || o._buttonDown[MouseButton.RIGHT]) && i.preventDefault();
  }
}
var mouseDblClickEvent = {
  position: new Vector2$1()
};
function handleDblClick(o, i) {
  var e = i.button, r;
  if (e === MouseButton.LEFT)
    r = ScreenSpaceEventType.LEFT_DOUBLE_CLICK;
  else
    return;
  var s = getModifier(i), a = o.getInputAction(
    r,
    s
  );
  defined$1(a) && (getPosition(o, i, mouseDblClickEvent.position), mouseDblClickEvent.event = i, a(mouseDblClickEvent));
}
function handleWheel(o, i) {
  var e;
  if (defined$1(i.deltaY)) {
    var r = i.deltaMode;
    r === i.DOM_DELTA_PIXEL ? e = -i.deltaY : r === i.DOM_DELTA_LINE ? e = -i.deltaY * 40 : e = -i.deltaY * 120;
  } else
    i.detail > 0 ? e = i.detail * -120 : e = i.wheelDelta;
  if (!!defined$1(e)) {
    var s = getModifier(i), a = o.getInputAction(
      ScreenSpaceEventType.WHEEL,
      s
    );
    defined$1(a) && (a(e), i.preventDefault());
  }
}
function handleTouchStart(o, i) {
  gotTouchEvent(o);
  var e = i.changedTouches, r, s = e.length, a, c, l = o._positions;
  for (r = 0; r < s; ++r)
    a = e[r], c = a.identifier, l.set(
      c,
      getPosition(o, a, new Vector2$1())
    );
  fireTouchEvents(o, i);
  var h = o._previousPositions;
  for (r = 0; r < s; ++r)
    a = e[r], c = a.identifier, h.set(
      c,
      Cartesian2.clone(l.get(c))
    );
}
function handleTouchEnd(o, i) {
  gotTouchEvent(o);
  var e = i.changedTouches, r, s = e.length, a, c, l = o._positions;
  for (r = 0; r < s; ++r)
    a = e[r], c = a.identifier, l.remove(c);
  fireTouchEvents(o, i);
  var h = o._previousPositions;
  for (r = 0; r < s; ++r)
    a = e[r], c = a.identifier, h.remove(c);
}
var touchStartEvent = {
  position: new Vector2$1()
}, touch2StartEvent = {
  position1: new Vector2$1(),
  position2: new Vector2$1()
}, touchEndEvent = {
  position: new Vector2$1()
}, touchClickEvent = {
  position: new Vector2$1()
}, touchHoldEvent = {
  position: new Vector2$1()
};
function fireTouchEvents(o, i) {
  var e = getModifier(i), r = o._positions, s = r.length, a, c, l = o._isPinching;
  if (s !== 1 && o._buttonDown[MouseButton.LEFT]) {
    if (o._buttonDown[MouseButton.LEFT] = !1, defined$1(o._touchHoldTimer) && (clearTimeout(o._touchHoldTimer), o._touchHoldTimer = void 0), a = o.getInputAction(
      ScreenSpaceEventType.LEFT_UP,
      e
    ), defined$1(a) && (Cartesian2.clone(
      o._primaryPosition,
      touchEndEvent.position
    ), touchEndEvent.event = i, a(touchEndEvent)), s === 0 && !o._isTouchHolding && (c = o.getInputAction(
      ScreenSpaceEventType.LEFT_CLICK,
      e
    ), defined$1(c))) {
      var h = o._primaryStartPosition, d = o._previousPositions.values[0];
      checkPixelTolerance(
        h,
        d,
        o._clickPixelTolerance
      ) && (Cartesian2.clone(
        o._primaryPosition,
        touchClickEvent.position
      ), touchClickEvent.event = i, c(touchClickEvent));
    }
    o._isTouchHolding = !1;
  }
  if (s === 0 && l && (o._isPinching = !1, a = o.getInputAction(
    ScreenSpaceEventType.PINCH_END,
    e
  ), defined$1(a) && a()), s === 1 && !l) {
    var f = r.values[0];
    Cartesian2.clone(f, o._primaryPosition), Cartesian2.clone(f, o._primaryStartPosition), Cartesian2.clone(
      f,
      o._primaryPreviousPosition
    ), o._buttonDown[MouseButton.LEFT] = !0, a = o.getInputAction(
      ScreenSpaceEventType.LEFT_DOWN,
      e
    ), defined$1(a) && (Cartesian2.clone(f, touchStartEvent.position), touchStartEvent.event = i, a(touchStartEvent)), o._touchHoldTimer = setTimeout(function() {
      if (!o.isDestroyed() && (o._touchHoldTimer = void 0, o._isTouchHolding = !0, c = o.getInputAction(
        ScreenSpaceEventType.RIGHT_CLICK,
        e
      ), defined$1(c))) {
        var p = o._primaryStartPosition, m = o._previousPositions.values[0];
        checkPixelTolerance(
          p,
          m,
          o._holdPixelTolerance
        ) && (Cartesian2.clone(
          o._primaryPosition,
          touchHoldEvent.position
        ), touchHoldEvent.event = i, c(touchHoldEvent));
      }
    }, ScreenSpaceEventHandler.touchHoldDelayMilliseconds), i.preventDefault();
  }
  s === 2 && !l && (o._isPinching = !0, a = o.getInputAction(
    ScreenSpaceEventType.PINCH_START,
    e
  ), defined$1(a) && (Cartesian2.clone(r.values[0], touch2StartEvent.position1), Cartesian2.clone(r.values[1], touch2StartEvent.position2), touch2StartEvent.event = i, a(touch2StartEvent), i.preventDefault()));
}
function handleTouchMove(o, i) {
  gotTouchEvent(o);
  var e = i.changedTouches, r, s = e.length, a, c, l = o._positions;
  for (r = 0; r < s; ++r) {
    a = e[r], c = a.identifier;
    var h = l.get(c);
    defined$1(h) && getPosition(o, a, h);
  }
  fireTouchMoveEvents(o, i);
  var d = o._previousPositions;
  for (r = 0; r < s; ++r)
    a = e[r], c = a.identifier, Cartesian2.clone(
      l.get(c),
      d.get(c)
    );
}
var touchMoveEvent = {
  startPosition: new Vector2$1(),
  endPosition: new Vector2$1()
}, touchPinchMovementEvent = {
  distance: {
    startPosition: new Vector2$1(),
    endPosition: new Vector2$1()
  },
  angleAndHeight: {
    startPosition: new Vector2$1(),
    endPosition: new Vector2$1()
  }
};
function fireTouchMoveEvents(o, i) {
  var e = getModifier(i), r = o._positions, s = o._previousPositions, a = r.length, c;
  if (a === 1 && o._buttonDown[MouseButton.LEFT]) {
    var l = r.values[0];
    Cartesian2.clone(l, o._primaryPosition);
    var h = o._primaryPreviousPosition;
    c = o.getInputAction(
      ScreenSpaceEventType.MOUSE_MOVE,
      e
    ), defined$1(c) && (Cartesian2.clone(h, touchMoveEvent.startPosition), Cartesian2.clone(l, touchMoveEvent.endPosition), touchMoveEvent.event = i, c(touchMoveEvent)), Cartesian2.clone(l, h), i.preventDefault();
  } else if (a === 2 && o._isPinching && (c = o.getInputAction(
    ScreenSpaceEventType.PINCH_MOVE,
    e
  ), defined$1(c))) {
    var d = r.values[0], f = r.values[1], p = s.values[0], m = s.values[1], y = f.x - d.x, x = f.y - d.y, v = Math.sqrt(y * y + x * x) * 0.25, S = m.x - p.x, E = m.y - p.y, b = Math.sqrt(S * S + E * E) * 0.25, w = (f.y + d.y) * 0.125, M = (m.y + p.y) * 0.125, P = Math.atan2(x, y), D = Math.atan2(E, S);
    Cartesian2.fromElements(
      0,
      b,
      touchPinchMovementEvent.distance.startPosition
    ), Cartesian2.fromElements(
      0,
      v,
      touchPinchMovementEvent.distance.endPosition
    ), Cartesian2.fromElements(
      D,
      M,
      touchPinchMovementEvent.angleAndHeight.startPosition
    ), Cartesian2.fromElements(
      P,
      w,
      touchPinchMovementEvent.angleAndHeight.endPosition
    ), touchPinchMovementEvent.event = i, c(touchPinchMovementEvent);
  }
}
function handlePointerDown(o, i) {
  if (i.target.setPointerCapture(i.pointerId), i.pointerType === "touch") {
    var e = o._positions, r = i.pointerId;
    e.set(
      r,
      getPosition(o, i, new Vector2$1())
    ), fireTouchEvents(o, i);
    var s = o._previousPositions;
    s.set(
      r,
      Cartesian2.clone(e.get(r))
    );
  } else
    handleMouseDown(o, i);
}
function handlePointerUp(o, i) {
  if (i.pointerType === "touch") {
    var e = o._positions, r = i.pointerId;
    e.remove(r), fireTouchEvents(o, i);
    var s = o._previousPositions;
    s.remove(r);
  } else
    handleMouseUp(o, i);
}
function handlePointerMove(o, i) {
  if (i.pointerType === "touch") {
    var e = o._positions, r = i.pointerId, s = e.get(r);
    if (!defined$1(s))
      return;
    getPosition(o, i, s), fireTouchMoveEvents(o, i);
    var a = o._previousPositions;
    Cartesian2.clone(
      e.get(r),
      a.get(r)
    );
  } else
    handleMouseMove(o, i);
}
function ScreenSpaceEventHandler(o) {
  this._inputEvents = {}, this._buttonDown = {
    LEFT: !1,
    MIDDLE: !1,
    RIGHT: !1
  }, this._isPinching = !1, this._isTouchHolding = !1, this._lastSeenTouchEvent = -ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds, this._primaryStartPosition = new Vector2$1(), this._primaryPosition = new Vector2$1(), this._primaryPreviousPosition = new Vector2$1(), this._positions = new AssociativeArray(), this._previousPositions = new AssociativeArray(), this._removalFunctions = [], this._touchHoldTimer = void 0, this._clickPixelTolerance = 5, this._holdPixelTolerance = 25, this._element = defaultValue(o, document), registerListeners(this);
}
ScreenSpaceEventHandler.prototype.setInputAction = function(o, i, e) {
  if (!defined$1(o))
    throw new DeveloperError("action is required.");
  if (!defined$1(i))
    throw new DeveloperError("type is required.");
  var r = getInputEventKey(i, e);
  this._inputEvents[r] = o;
};
ScreenSpaceEventHandler.prototype.getInputAction = function(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("type is required.");
  var e = getInputEventKey(o, i);
  return this._inputEvents[e];
};
ScreenSpaceEventHandler.prototype.removeInputAction = function(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("type is required.");
  var e = getInputEventKey(o, i);
  delete this._inputEvents[e];
};
ScreenSpaceEventHandler.prototype.isDestroyed = function() {
  return !1;
};
ScreenSpaceEventHandler.prototype.destroy = function() {
  return unregisterListeners(this), destroyObject(this);
};
ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds = 800;
ScreenSpaceEventHandler.touchHoldDelayMilliseconds = 1500;
function getKey(o, i) {
  let e = o;
  return defined$1(i) && (e += "+" + i), e;
}
function clonePinchMovement(o, i) {
  Cartesian2.clone(
    o.distance.startPosition,
    i.distance.startPosition
  ), Cartesian2.clone(
    o.distance.endPosition,
    i.distance.endPosition
  ), Cartesian2.clone(
    o.angleAndHeight.startPosition,
    i.angleAndHeight.startPosition
  ), Cartesian2.clone(
    o.angleAndHeight.endPosition,
    i.angleAndHeight.endPosition
  );
}
function listenToPinch(o, i, e) {
  const r = getKey(CameraEventType.PINCH, i), s = o._update, a = o._isDown, c = o._eventStartPosition, l = o._pressTime, h = o._releaseTime;
  s[r] = !0, a[r] = !1, c[r] = new Vector2$1();
  let d = o._movement[r];
  defined$1(d) || (d = o._movement[r] = {}), d.distance = {
    startPosition: new Vector2$1(),
    endPosition: new Vector2$1()
  }, d.angleAndHeight = {
    startPosition: new Vector2$1(),
    endPosition: new Vector2$1()
  }, d.prevAngle = 0, o._eventHandler.setInputAction(
    function(f) {
      o._buttonsDown++, a[r] = !0, l[r] = new Date(), Cartesian2.lerp(
        f.position1,
        f.position2,
        0.5,
        c[r]
      ), o._rendering.requestRender();
    },
    ScreenSpaceEventType.PINCH_START,
    i
  ), o._eventHandler.setInputAction(
    function() {
      o._buttonsDown = Math.max(o._buttonsDown - 1, 0), a[r] = !1, h[r] = new Date(), o._rendering.requestRender();
    },
    ScreenSpaceEventType.PINCH_END,
    i
  ), o._eventHandler.setInputAction(
    function(f) {
      if (a[r]) {
        s[r] ? (clonePinchMovement(f, d), s[r] = !1, d.prevAngle = d.angleAndHeight.startPosition.x) : (Cartesian2.clone(
          f.distance.endPosition,
          d.distance.endPosition
        ), Cartesian2.clone(
          f.angleAndHeight.endPosition,
          d.angleAndHeight.endPosition
        ));
        let p = d.angleAndHeight.endPosition.x;
        const m = d.prevAngle, y = Math.PI * 2;
        for (; p >= m + Math.PI; )
          p -= y;
        for (; p < m - Math.PI; )
          p += y;
        d.angleAndHeight.endPosition.x = -p * e.clientWidth / 12, d.angleAndHeight.startPosition.x = -m * e.clientWidth / 12, o._rendering.requestRender();
      }
    },
    ScreenSpaceEventType.PINCH_MOVE,
    i
  );
}
function listenToWheel(o, i) {
  const e = getKey(CameraEventType.WHEEL, i), r = o._pressTime, s = o._releaseTime, a = o._update;
  a[e] = !0;
  let c = o._movement[e];
  defined$1(c) || (c = o._movement[e] = {});
  let l = o._lastMovement[e];
  defined$1(l) || (l = o._lastMovement[e] = {
    startPosition: new Vector2$1(),
    endPosition: new Vector2$1(),
    valid: !1
  }), c.startPosition = new Vector2$1(), Cartesian2.clone(Cartesian2.ZERO, c.startPosition), c.endPosition = new Vector2$1(), o._eventHandler.setInputAction(
    function(h) {
      const d = 7.5 * CesiumMath.toRadians(h);
      r[e] = s[e] = new Date(), c.endPosition.x = 0, c.endPosition.y = d, Cartesian2.clone(c.endPosition, l.endPosition), l.valid = !0, a[e] = !1, o._rendering.requestRender();
    },
    ScreenSpaceEventType.WHEEL,
    i
  );
}
function listenMouseButtonDownUp(o, i, e) {
  const r = getKey(e, i), s = o._isDown, a = o._eventStartPosition, c = o._pressTime, l = o._releaseTime;
  s[r] = !1, a[r] = new Vector2$1();
  let h = o._lastMovement[r];
  defined$1(h) || (h = o._lastMovement[r] = {
    startPosition: new Vector2$1(),
    endPosition: new Vector2$1(),
    valid: !1
  });
  let d, f;
  e === CameraEventType.LEFT_DRAG ? (d = ScreenSpaceEventType.LEFT_DOWN, f = ScreenSpaceEventType.LEFT_UP) : e === CameraEventType.RIGHT_DRAG ? (d = ScreenSpaceEventType.RIGHT_DOWN, f = ScreenSpaceEventType.RIGHT_UP) : e === CameraEventType.MIDDLE_DRAG && (d = ScreenSpaceEventType.MIDDLE_DOWN, f = ScreenSpaceEventType.MIDDLE_UP), o._eventHandler.setInputAction(
    function(p) {
      o._buttonsDown++, h.valid = !1, s[r] = !0, c[r] = new Date(), Cartesian2.clone(p.position, a[r]), p && o.onEventPointerDown && o.onEventPointerDown(p);
    },
    d,
    i
  ), o._eventHandler.setInputAction(
    function(p) {
      o._buttonsDown = Math.max(o._buttonsDown - 1, 0), s[r] = !1, l[r] = new Date(), p && o.onEventPointerUp && o.onEventPointerUp(p), o._rendering.requestRender();
    },
    f,
    i
  );
}
function cloneMouseMovement(o, i) {
  Cartesian2.clone(o.startPosition, i.startPosition), Cartesian2.clone(o.endPosition, i.endPosition);
}
function listenMouseMove(o, i) {
  const e = o._update, r = o._movement, s = o._lastMovement, a = o._isDown;
  for (const c in CameraEventType)
    if (CameraEventType.hasOwnProperty(c)) {
      const l = CameraEventType[c];
      if (defined$1(l)) {
        const h = getKey(l, i);
        e[h] = !0, defined$1(o._lastMovement[h]) || (o._lastMovement[h] = {
          startPosition: new Vector2$1(),
          endPosition: new Vector2$1(),
          valid: !1
        }), defined$1(o._movement[h]) || (o._movement[h] = {
          startPosition: new Vector2$1(),
          endPosition: new Vector2$1()
        });
      }
    }
  o._eventHandler.setInputAction(
    function(c) {
      for (const l in CameraEventType)
        if (CameraEventType.hasOwnProperty(l)) {
          const h = CameraEventType[l];
          if (defined$1(h)) {
            const d = getKey(h, i);
            a[d] ? (e[d] ? (cloneMouseMovement(r[d], s[d]), s[d].valid = !0, cloneMouseMovement(c, r[d]), e[d] = !1) : Cartesian2.clone(
              c.endPosition,
              r[d].endPosition
            ), o._rendering.requestRender()) : o.onEventMouseMove && o.onEventMouseMove(c);
          }
        }
      Cartesian2.clone(
        c.endPosition,
        o._currentMousePosition
      );
    },
    ScreenSpaceEventType.MOUSE_MOVE,
    i
  );
}
function listenMouseClick(o, i) {
  o._eventHandler.setInputAction(
    function(e) {
      e && o.onEventClick && o.onEventClick(e), o._rendering.requestRender();
    },
    ScreenSpaceEventType.LEFT_CLICK,
    i
  ), o._eventHandler.setInputAction(
    function(e) {
      e && o.onEventClick && o.onEventClick(e), o._rendering.requestRender();
    },
    ScreenSpaceEventType.RIGHT_CLICK,
    i
  ), o._eventHandler.setInputAction(
    function(e) {
      e && o.onEventDblClick && o.onEventDblClick(e), o._rendering.requestRender();
    },
    ScreenSpaceEventType.LEFT_DOUBLE_CLICK,
    i
  );
}
function CameraEventAggregator(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("canvas is required.");
  this._eventHandler = new ScreenSpaceEventHandler(o), this._rendering = i, this._update = {}, this._movement = {}, this._lastMovement = {}, this._isDown = {}, this._eventStartPosition = {}, this._pressTime = {}, this._releaseTime = {}, this._buttonsDown = 0, this._currentMousePosition = new Vector2$1(), listenToWheel(this, void 0), listenToPinch(this, void 0, o), listenMouseButtonDownUp(this, void 0, CameraEventType.LEFT_DRAG), listenMouseButtonDownUp(this, void 0, CameraEventType.RIGHT_DRAG), listenMouseButtonDownUp(this, void 0, CameraEventType.MIDDLE_DRAG), listenMouseMove(this, void 0), listenMouseClick(this, void 0);
  for (const e in KeyboardEventModifier)
    if (KeyboardEventModifier.hasOwnProperty(e)) {
      const r = KeyboardEventModifier[e];
      defined$1(r) && (listenToWheel(this, r), listenToPinch(this, r, o), listenMouseButtonDownUp(this, r, CameraEventType.LEFT_DRAG), listenMouseButtonDownUp(this, r, CameraEventType.RIGHT_DRAG), listenMouseButtonDownUp(this, r, CameraEventType.MIDDLE_DRAG), listenMouseMove(this, r), listenMouseClick(this, r));
    }
}
Object.defineProperties(CameraEventAggregator.prototype, {
  currentMousePosition: {
    get: function() {
      return this._currentMousePosition;
    }
  },
  anyButtonDown: {
    get: function() {
      const o = !this._update[getKey(CameraEventType.WHEEL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.SHIFT)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.CTRL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.ALT)];
      return this._buttonsDown > 0 || o;
    }
  }
});
CameraEventAggregator.prototype.isMoving = function(o, i) {
  const e = getKey(o, i);
  return !this._update[e];
};
CameraEventAggregator.prototype.getMovement = function(o, i) {
  const e = getKey(o, i);
  return this._movement[e];
};
CameraEventAggregator.prototype.getLastMovement = function(o, i) {
  const e = getKey(o, i), r = this._lastMovement[e];
  if (r.valid)
    return r;
};
CameraEventAggregator.prototype.isButtonDown = function(o, i) {
  const e = getKey(o, i);
  return this._isDown[e];
};
CameraEventAggregator.prototype.getStartMousePosition = function(o, i) {
  if (o === CameraEventType.WHEEL)
    return this._currentMousePosition;
  const e = getKey(o, i);
  return this._eventStartPosition[e];
};
CameraEventAggregator.prototype.getButtonPressTime = function(o, i) {
  const e = getKey(o, i);
  return this._pressTime[e];
};
CameraEventAggregator.prototype.getButtonReleaseTime = function(o, i) {
  const e = getKey(o, i);
  return this._releaseTime[e];
};
CameraEventAggregator.prototype.reset = function() {
  for (const o in this._update)
    this._update.hasOwnProperty(o) && (this._update[o] = !0);
};
CameraEventAggregator.prototype.isDestroyed = function() {
  return !1;
};
CameraEventAggregator.prototype.destroy = function() {
  return this._eventHandler = this._eventHandler && this._eventHandler.destroy(), destroyObject(this);
};
var TerrainExaggeration = {};
TerrainExaggeration.getHeight = function(o, i, e) {
  return (o - e) * i + e;
};
function HeadingPitchRoll(o, i, e) {
  this.heading = defaultValue(o, 0), this.pitch = defaultValue(i, 0), this.roll = defaultValue(e, 0);
}
HeadingPitchRoll.fromQuaternion = function(o, i) {
  if (!defined$1(o))
    throw new DeveloperError("quaternion is required");
  defined$1(i) || (i = new HeadingPitchRoll());
  const e = 2 * (o.w * o.y - o.z * o.x), r = 1 - 2 * (o.x * o.x + o.y * o.y), s = 2 * (o.w * o.x + o.y * o.z), a = 1 - 2 * (o.y * o.y + o.z * o.z), c = 2 * (o.w * o.z + o.x * o.y);
  return i.heading = -Math.atan2(c, a), i.roll = Math.atan2(s, r), i.pitch = -CesiumMath.asinClamped(e), i;
};
HeadingPitchRoll.fromDegrees = function(o, i, e, r) {
  if (!defined$1(o))
    throw new DeveloperError("heading is required");
  if (!defined$1(i))
    throw new DeveloperError("pitch is required");
  if (!defined$1(e))
    throw new DeveloperError("roll is required");
  return defined$1(r) || (r = new HeadingPitchRoll()), r.heading = o * CesiumMath.RADIANS_PER_DEGREE, r.pitch = i * CesiumMath.RADIANS_PER_DEGREE, r.roll = e * CesiumMath.RADIANS_PER_DEGREE, r;
};
HeadingPitchRoll.clone = function(o, i) {
  if (!!defined$1(o))
    return defined$1(i) ? (i.heading = o.heading, i.pitch = o.pitch, i.roll = o.roll, i) : new HeadingPitchRoll(
      o.heading,
      o.pitch,
      o.roll
    );
};
HeadingPitchRoll.equals = function(o, i) {
  return o === i || defined$1(o) && defined$1(i) && o.heading === i.heading && o.pitch === i.pitch && o.roll === i.roll;
};
HeadingPitchRoll.equalsEpsilon = function(o, i, e, r) {
  return o === i || defined$1(o) && defined$1(i) && CesiumMath.equalsEpsilon(
    o.heading,
    i.heading,
    e,
    r
  ) && CesiumMath.equalsEpsilon(
    o.pitch,
    i.pitch,
    e,
    r
  ) && CesiumMath.equalsEpsilon(
    o.roll,
    i.roll,
    e,
    r
  );
};
HeadingPitchRoll.prototype.clone = function(o) {
  return HeadingPitchRoll.clone(this, o);
};
HeadingPitchRoll.prototype.equals = function(o) {
  return HeadingPitchRoll.equals(this, o);
};
HeadingPitchRoll.prototype.equalsEpsilon = function(o, i, e) {
  return HeadingPitchRoll.equalsEpsilon(
    this,
    o,
    i,
    e
  );
};
HeadingPitchRoll.prototype.toString = function() {
  return `(${this.heading}, ${this.pitch}, ${this.roll})`;
};
const SceneTransforms = {}, actualPositionScratch = new Vector4(0, 0, 0, 1), scratchViewport = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
new Vector3$1(
  Math.PI,
  CesiumMath.PI_OVER_TWO
);
let positionCC = new Vector4(0, 0, 0, 0);
new Vector3$1();
const scratchCartesian4 = new Vector4(0, 0, 0, 0), scratchEyeOffset = new Vector3$1();
function worldToClip(o, i, e, r) {
  const s = e.viewMatrix, a = StaticMatrix4.multiplyByVector(
    s,
    Cartesian4.fromElements(
      o.x,
      o.y,
      o.z,
      1,
      scratchCartesian4
    ),
    scratchCartesian4
  ), c = Cartesian3.multiplyComponents(
    i,
    Cartesian3.normalize(a, scratchEyeOffset),
    scratchEyeOffset
  );
  return a.x += i.x + c.x, a.y += i.y + c.y, a.z += c.z, StaticMatrix4.multiplyByVector(
    e.frustum.projectionMatrix,
    a,
    r
  );
}
SceneTransforms.computeActualEllipsoidPosition = function(o, i, e) {
  if (o.mode === SceneMode$1.SCENE3D)
    return Cartesian3.clone(i, e);
};
SceneTransforms.worldToWindowCoordinates = function(o, i, e) {
  return SceneTransforms.worldWithEyeOffsetToWindowCoordinates(
    o,
    i,
    Cartesian3.ZERO,
    e
  );
};
SceneTransforms.worldWithEyeOffsetToWindowCoordinates = function(o, i, e, r) {
  if (!defined$1(o))
    throw new DeveloperError("scene is required.");
  if (!defined$1(i))
    throw new DeveloperError("position is required.");
  const s = SceneTransforms.computeActualEllipsoidPosition(
    o,
    i,
    actualPositionScratch
  );
  if (!defined$1(s))
    return;
  const a = o.canvas, c = scratchViewport;
  c.x = 0, c.y = 0, c.width = a.clientWidth, c.height = a.clientHeight;
  const l = o.camera;
  let h = !1;
  if (o.mode, SceneMode$1.SCENE2D, o.mode !== SceneMode$1.SCENE2D || h) {
    if (positionCC = worldToClip(s, e, l, positionCC), positionCC.z < 0)
      return;
    r = SceneTransforms.clipToGLWindowCoordinates(
      c,
      positionCC,
      r
    );
  }
  return r.y = a.clientHeight - r.y, r;
};
const positionNDC = new Vector3$1(), positionWC = new Vector3$1(), viewportTransform = new Matrix4();
SceneTransforms.clipToGLWindowCoordinates = function(o, i, e) {
  return Cartesian3.divideByScalar(i, i.w, positionNDC), StaticMatrix4.computeViewportTransformation(o, 0, 1, viewportTransform), StaticMatrix4.multiplyByPoint(viewportTransform, positionNDC, positionWC), Cartesian2.fromCartesian3(positionWC, e);
};
function ScreenSpaceCameraController(o) {
  if (!defined$1(o))
    throw new DeveloperError("scene is required.");
  this.enableInputs = !0, this.enableTranslate = !0, this.enableZoom = !0, this.enableRotate = !0, this.enableTilt = !0, this.enableLook = !0, this.enableFixCenter = !1, this.enableTerrainCollision = !1, this.inertiaSpin = 0.9, this.inertiaTranslate = 0.9, this.inertiaZoom = 0.8, this.maximumMovementRatio = 0.1, this.bounceAnimationTime = 3, this.minimumZoomDistance = 1, this.maximumZoomDistance = Number.POSITIVE_INFINITY, this.translateEventTypes = CameraEventType.LEFT_DRAG, this.zoomEventTypes = [
    CameraEventType.MIDDLE_DRAG,
    CameraEventType.WHEEL,
    CameraEventType.PINCH
  ], this.rotateEventTypes = CameraEventType.LEFT_DRAG, this.tiltEventTypes = [
    CameraEventType.RIGHT_DRAG,
    CameraEventType.PINCH,
    {
      eventType: CameraEventType.LEFT_DRAG,
      modifier: KeyboardEventModifier.CTRL
    },
    {
      eventType: CameraEventType.RIGHT_DRAG,
      modifier: KeyboardEventModifier.CTRL
    }
  ], this.lookEventTypes = {
    eventType: CameraEventType.LEFT_DRAG,
    modifier: KeyboardEventModifier.SHIFT
  }, this.minimumPickingTerrainHeight = 15e4, this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight, this.minimumPickingTerrainDistanceWithInertia = 4e3, this.minimumCollisionTerrainHeight = 15e3, this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight, this.minimumTrackBallHeight = 75e5, this._minimumTrackBallHeight = this.minimumTrackBallHeight, this.enableCollisionDetection = !0, this._scene = o, this._globe = void 0, this._ellipsoid = void 0, this._lastGlobeHeight = 0, this._aggregator = new CameraEventAggregator(o.canvas, o.rendering), this._lastInertiaSpinMovement = void 0, this._lastInertiaZoomMovement = void 0, this._lastInertiaTranslateMovement = void 0, this._lastInertiaTiltMovement = void 0, this._inertiaDisablers = {
    _lastInertiaZoomMovement: [
      "_lastInertiaSpinMovement",
      "_lastInertiaTranslateMovement",
      "_lastInertiaTiltMovement"
    ],
    _lastInertiaTiltMovement: [
      "_lastInertiaSpinMovement",
      "_lastInertiaTranslateMovement"
    ]
  }, this._horizontalRotationAxis = void 0, this._tiltCenterMousePosition = new Vector2$1(-1, -1), this._tiltCenter = new Vector3$1(), this._translateMousePosition = new Vector2$1(), this._rotateMousePosition = new Vector2$1(-1, -1), this._rotateStartPosition = new Vector3$1(), this._strafeStartPosition = new Vector3$1(), this._strafeMousePosition = new Vector2$1(), this._strafeEndMousePosition = new Vector2$1(), this._zoomMouseStart = new Vector2$1(-1, -1), this._zoomWorldPosition = new Vector3$1(), this._useZoomWorldPosition = !1, this._panLastMousePosition = new Vector2$1(), this._panLastWorldPosition = new Vector3$1(), this._tiltCVOffMap = !1, this._looking = !1, this._rotating = !1, this._strafing = !1, this._zoomingOnVector = !1, this._zoomingUnderground = !1, this._rotatingZoom = !1, this._adjustedHeightForTerrain = !1, this._cameraUnderground = !1;
  const i = o.mapProjection;
  this._maxCoord = i.project(
    new Vector3$1(Math.PI, CesiumMath.PI_OVER_TWO)
  ), this._zoomFactor = 5, this._rotateFactor = void 0, this._rotateRateRangeAdjustment = void 0, this._maximumRotateRate = 1.77, this._minimumRotateRate = 1 / 5e3, this._minimumZoomRate = 20, this._maximumZoomRate = 5906376272e3, this._minimumUndergroundPickDistance = 2e3, this._maximumUndergroundPickDistance = 1e4, Object.defineProperties(this, {
    enabled: {
      get: function() {
        return this.enableInputs;
      },
      set: function(e) {
        this.enableInputs = e;
      }
    },
    enablePan: {
      get: function() {
        return this.enableTranslate;
      },
      set: function(e) {
        this.enableTranslate = e;
      }
    },
    inertiaDragging: {
      get: function() {
        return this.inertiaSpin;
      },
      set: function(e) {
        this.inertiaSpin = e;
      }
    }
  });
}
function decay(o, i) {
  if (o < 0)
    return 0;
  const e = (1 - i) * 25;
  return Math.exp(-e * o);
}
function sameMousePosition(o) {
  return Cartesian2.equalsEpsilon(
    o.startPosition,
    o.endPosition,
    CesiumMath.EPSILON14
  );
}
const inertiaMaxClickTimeThreshold = 0.4;
function maintainInertia(o, i, e, r, s, a, c) {
  let l = a[c];
  defined$1(l) || (l = a[c] = {
    startPosition: new Vector2$1(),
    endPosition: new Vector2$1(),
    motion: new Vector2$1(),
    inertiaEnabled: !0
  });
  const h = o.getButtonPressTime(i, e), d = o.getButtonReleaseTime(i, e), f = h && d && (d.getTime() - h.getTime()) / 1e3, p = new Date(), m = d && (p.getTime() - d.getTime()) / 1e3;
  if (h && d && f < inertiaMaxClickTimeThreshold) {
    const y = decay(m, r), x = o.getLastMovement(i, e);
    if (!defined$1(x) || sameMousePosition(x) || !l.inertiaEnabled || (l.motion.x = (x.endPosition.x - x.startPosition.x) * 0.5, l.motion.y = (x.endPosition.y - x.startPosition.y) * 0.5, l.startPosition = Cartesian2.clone(
      x.startPosition,
      l.startPosition
    ), l.endPosition = Cartesian2.multiplyByScalar(
      l.motion,
      y,
      l.endPosition
    ), l.endPosition = Cartesian2.add(
      l.startPosition,
      l.endPosition,
      l.endPosition
    ), isNaN(l.endPosition.x) || isNaN(l.endPosition.y) || Cartesian2.distance(
      l.startPosition,
      l.endPosition
    ) < 0.5))
      return;
    if (!o.isButtonDown(i, e)) {
      const v = o.getStartMousePosition(i, e);
      s(a, v, l);
    }
  }
}
function activateInertia(o, i) {
  if (defined$1(i)) {
    let e = o[i];
    defined$1(e) && (e.inertiaEnabled = !0);
    const r = o._inertiaDisablers[i];
    if (defined$1(r)) {
      const s = r.length;
      for (let a = 0; a < s; ++a)
        e = o[r[a]], defined$1(e) && (e.inertiaEnabled = !1);
    }
  }
}
const scratchEventTypeArray = [];
function reactToInput(o, i, e, r, s, a) {
  if (!defined$1(e))
    return;
  const c = o._aggregator;
  Array.isArray(e) || (scratchEventTypeArray[0] = e, e = scratchEventTypeArray);
  const l = e.length;
  for (let h = 0; h < l; ++h) {
    const d = e[h], f = defined$1(d.eventType) ? d.eventType : d, p = d.modifier, m = c.isMoving(f, p) && c.getMovement(f, p), y = c.getStartMousePosition(f, p);
    o.enableInputs && i && (m ? (r(o, y, m), activateInertia(o, a)) : s < 1 && maintainInertia(
      c,
      f,
      p,
      s,
      r,
      o,
      a
    ));
  }
}
const scratchZoomPickRay = new Ray(), scratchPickCartesian = new Vector3$1(), scratchZoomOffset = new Vector2$1(), scratchZoomDirection = new Vector3$1(), scratchCenterPixel = new Vector2$1(), scratchCenterPosition = new Vector3$1(), scratchPositionNormal$1 = new Vector3$1(), scratchPickNormal = new Vector3$1(), scratchZoomAxis = new Vector3$1(), scratchCameraPositionNormal = new Vector3$1(), scratchTargetNormal = new Vector3$1(), scratchCameraPosition = new Vector3$1(), scratchCameraUpNormal = new Vector3$1(), scratchCameraRightNormal = new Vector3$1(), scratchForwardNormal = new Vector3$1(), scratchPositionToTarget = new Vector3$1(), scratchPositionToTargetNormal = new Vector3$1(), scratchPan = new Vector3$1(), scratchCenterMovement = new Vector3$1(), scratchCenter$2 = new Vector3$1(), scratchCartesian$3 = new Vector3$1(), scratchCartesianTwo = new Vector3$1(), scratchCartesianThree = new Vector3$1(), scratchZoomViewOptions = {
  orientation: new HeadingPitchRoll()
}, scratchPosition$1 = new Vector3$1();
function zoomPitchDown(o, i, e) {
  if (!i.enableFixCenter)
    return;
  const r = o.position.length(), s = CesiumMath.asinClamped(Ellipsoid.WGS84.maximumRadius / r), a = Math.cos(s) * r, c = o.position.clone().normalize().negate().angleTo(o.directionWC), l = s - c, h = Math.tan(l) * a, d = Math.cos(l) * h, f = Math.sin(l) * h, m = a / Math.cos(l) - f, x = MathUtils.degToRad(i._scene.rendering.camera.fov) / 2 - Math.atan(d / m);
  if (x < 0)
    return;
  let v = r - i._minimumTrackBallHeight * 0.85;
  if (v < 0)
    return;
  const S = 5e6;
  v = MathUtils.clamp(v, 0, S);
  const E = 0.1 + 0.3 * (1 - v / S);
  let b = Math.max(e, 0.1);
  Cartesian3.negate(o.position, scratchPosition$1);
  const w = scratchPosition$1.normalize(), M = Cartesian3.dot(w, o.directionWC);
  let P = CesiumMath.acosClamped(M);
  P > 0.1 && (P = x - E / 3), P *= b, !(P < 0) && (o.rotateAroundPoint(i._zoomWorldPosition, o.right, P), scratchZoomViewOptions.orientation.pitch -= P);
}
async function handleZoom(o, i, e, r, s, a) {
  let c = 1;
  defined$1(a) && (c = CesiumMath.clamp(
    Math.abs(a),
    0.25,
    1
  ));
  const l = e.endPosition.y - e.startPosition.y, d = l > 0 ? o.minimumZoomDistance * c : 0, f = o.maximumZoomDistance, p = s - d;
  let m = r * p;
  m = CesiumMath.clamp(
    m,
    o._minimumZoomRate,
    o._maximumZoomRate
  );
  let y = l / o._scene.canvas.clientHeight;
  y = Math.min(y, o.maximumMovementRatio);
  let x = m * y;
  if (o.enableCollisionDetection || o.minimumZoomDistance === 0 || !defined$1(o._globe)) {
    if (x > 0 && Math.abs(s - d) < 1 || x < 0 && Math.abs(s - f) < 1)
      return;
    s - x < d ? x = s - d - 1 : s - x > f && (x = s - f);
  }
  const v = o._scene, S = v.camera, E = v.mode;
  if (o.enableFixCenter && S.positionWC.length() > 6317e4 && l < 0)
    return;
  const b = scratchZoomViewOptions.orientation;
  b.heading = S.heading, b.pitch = S.pitch, b.roll = S.roll;
  const w = defaultValue(
    e.inertiaEnabled,
    Cartesian2.equals(i, o._zoomMouseStart)
  );
  let M = o._zoomingOnVector, P = o._rotatingZoom, D;
  if (w || (o._zoomMouseStart = Cartesian2.clone(
    i,
    o._zoomMouseStart
  ), defined$1(o._globe) && E === SceneMode.SCENE2D ? (D = S.getPickRay(i, scratchZoomPickRay).origin, D = Cartesian3.fromElements(
    D.y,
    D.z,
    D.x
  )) : defined$1(o._globe) && (D = await pickPosition(
    o,
    i,
    scratchPickCartesian
  )), defined$1(D) ? (o._useZoomWorldPosition = !0, o._zoomWorldPosition = Cartesian3.clone(
    D,
    o._zoomWorldPosition
  )) : o._useZoomWorldPosition = !1, M = o._zoomingOnVector = !1, P = o._rotatingZoom = !1, o._zoomingUnderground = o._cameraUnderground), !o._useZoomWorldPosition) {
    E === SceneMode.SCENE3D && x < 0 && zoomPitchDown(S, o, x), S.zoomIn(x);
    return;
  }
  let L = E === SceneMode.COLUMBUS_VIEW;
  if (S.positionCartographic.z < 2e6 && (P = !0), !w || P) {
    if (E === SceneMode.SCENE2D) {
      const O = o._zoomWorldPosition, F = S.position;
      if (!Cartesian3.equals(O, F) && S.positionCartographic.z < o._maxCoord.x * 2) {
        const k = S.position.x, V = Cartesian3.subtract(
          O,
          F,
          scratchZoomDirection
        );
        Cartesian3.normalize(V, V);
        const N = Cartesian3.distance(O, F) * x / (S.getMagnitude() * 0.5);
        S.move(V, N * 0.5), (S.position.x < 0 && k > 0 || S.position.x > 0 && k < 0) && (D = S.getPickRay(i, scratchZoomPickRay).origin, D = Cartesian3.fromElements(
          D.y,
          D.z,
          D.x
        ), o._zoomWorldPosition = Cartesian3.clone(
          D,
          o._zoomWorldPosition
        ));
      }
    } else if (E === SceneMode.SCENE3D) {
      const O = Cartesian3.normalize(
        S.position,
        scratchCameraPositionNormal
      );
      if (o._cameraUnderground || o._zoomingUnderground || S.positionCartographic.z < 3e3 && Math.abs(Cartesian3.dot(S.direction, O)) < 0.6)
        L = !0;
      else {
        const F = v.canvas, k = scratchCenterPixel;
        k.x = F.clientWidth / 2, k.y = F.clientHeight / 2;
        const V = await pickPosition(
          o,
          k,
          scratchCenterPosition
        );
        if (!defined$1(V))
          L = !0;
        else if (S.positionCartographic.z < 1e6)
          if (Cartesian3.dot(S.direction, O) >= -0.5)
            L = !0;
          else {
            const N = scratchCameraPosition;
            Cartesian3.clone(S.position, N);
            const U = o._zoomWorldPosition;
            let z = scratchTargetNormal;
            if (z = Cartesian3.normalize(U, z), Cartesian3.dot(z, O) < 0)
              return;
            const $ = scratchCenter$2, G = scratchForwardNormal;
            Cartesian3.clone(S.direction, G), Cartesian3.add(
              N,
              Cartesian3.multiplyByScalar(G, 1e3, scratchCartesian$3),
              $
            );
            const j = scratchPositionToTarget, Y = scratchPositionToTargetNormal;
            Cartesian3.subtract(U, N, j), Cartesian3.normalize(j, Y);
            const H = Cartesian3.dot(
              O,
              Y
            );
            if (H >= 0) {
              o._zoomMouseStart.x = -1;
              return;
            }
            const W = Math.acos(-H), q = Cartesian3.magnitude(N), Z = Cartesian3.magnitude(U), X = q - x, K = Cartesian3.magnitude(
              j
            ), ee = Math.asin(
              CesiumMath.clamp(
                K / Z * Math.sin(W),
                -1,
                1
              )
            ), ie = Math.asin(
              CesiumMath.clamp(
                X / Z * Math.sin(W),
                -1,
                1
              )
            ), re = ee - ie + W, ne = scratchCameraUpNormal;
            Cartesian3.normalize(N, ne);
            let J = scratchCameraRightNormal;
            J = Cartesian3.cross(Y, ne, J), J = Cartesian3.normalize(J, J), Cartesian3.normalize(
              Cartesian3.cross(ne, J, scratchCartesian$3),
              G
            ), Cartesian3.multiplyByScalar(
              Cartesian3.normalize($, scratchCartesian$3),
              Cartesian3.magnitude($) - x,
              $
            ), Cartesian3.normalize(N, N), Cartesian3.multiplyByScalar(
              N,
              X,
              N
            );
            const oe = scratchPan;
            Cartesian3.multiplyByScalar(
              Cartesian3.add(
                Cartesian3.multiplyByScalar(
                  ne,
                  Math.cos(re) - 1,
                  scratchCartesianTwo
                ),
                Cartesian3.multiplyByScalar(
                  G,
                  Math.sin(re),
                  scratchCartesianThree
                ),
                scratchCartesian$3
              ),
              X,
              oe
            ), Cartesian3.add(N, oe, N), Cartesian3.normalize($, ne), Cartesian3.normalize(
              Cartesian3.cross(ne, J, scratchCartesian$3),
              G
            );
            const _e = scratchCenterMovement;
            Cartesian3.multiplyByScalar(
              Cartesian3.add(
                Cartesian3.multiplyByScalar(
                  ne,
                  Math.cos(re) - 1,
                  scratchCartesianTwo
                ),
                Cartesian3.multiplyByScalar(
                  G,
                  Math.sin(re),
                  scratchCartesianThree
                ),
                scratchCartesian$3
              ),
              Cartesian3.magnitude($),
              _e
            ), Cartesian3.add($, _e, $), Cartesian3.clone(N, S.position), Cartesian3.normalize(
              Cartesian3.subtract($, N, scratchCartesian$3),
              S.direction
            ), Cartesian3.clone(S.direction, S.direction), Cartesian3.cross(S.direction, S.up, S.right), Cartesian3.cross(S.right, S.direction, S.up), E === SceneMode.SCENE3D && x < 0 && zoomPitchDown(S, o, x), S.setView(scratchZoomViewOptions);
            return;
          }
        else {
          const N = Cartesian3.normalize(
            V,
            scratchPositionNormal$1
          ), U = Cartesian3.normalize(
            o._zoomWorldPosition,
            scratchPickNormal
          ), z = Cartesian3.dot(U, N);
          if (z > 0 && z < 1) {
            const $ = CesiumMath.acosClamped(z), G = Cartesian3.cross(
              U,
              N,
              scratchZoomAxis
            ), j = (Math.abs($) > CesiumMath.toRadians(20) ? S.positionCartographic.z * 0.75 : S.positionCartographic.z - x) * 2, Y = x / j;
            S.rotate(G, $ * Y);
          }
        }
      }
    }
    o._rotatingZoom = !L;
  }
  if (!w && L || M) {
    let O;
    const F = SceneTransforms.worldToWindowCoordinates(
      v,
      o._zoomWorldPosition,
      scratchZoomOffset
    );
    E !== SceneMode.COLUMBUS_VIEW && Cartesian2.equals(i, o._zoomMouseStart) && defined$1(F) ? O = S.getPickRay(F, scratchZoomPickRay) : O = S.getPickRay(i, scratchZoomPickRay);
    const k = O.direction;
    (E === SceneMode.COLUMBUS_VIEW || E === SceneMode.SCENE2D) && Cartesian3.fromElements(
      k.y,
      k.z,
      k.x,
      k
    ), S.move(k, x), o._zoomingOnVector = !0;
  } else
    S.zoomIn(x);
  E === SceneMode.SCENE3D && x < 0 && zoomPitchDown(S, o, x), o._cameraUnderground || S.setView(scratchZoomViewOptions);
}
const translate2DStart = new Ray(), translate2DEnd = new Ray(), scratchTranslateP0 = new Vector3$1();
function translate2D(o, i, e) {
  const s = o._scene.camera;
  let a = s.getPickRay(e.startPosition, translate2DStart).origin, c = s.getPickRay(e.endPosition, translate2DEnd).origin;
  a = Cartesian3.fromElements(a.y, a.z, a.x, a), c = Cartesian3.fromElements(c.y, c.z, c.x, c);
  const l = Cartesian3.subtract(a, c, scratchTranslateP0), h = Cartesian3.magnitude(l);
  h > 0 && (Cartesian3.normalize(l, l), s.move(l, h));
}
async function zoom2D(o, i, e) {
  defined$1(e.distance) && (e = e.distance);
  const s = o._scene.camera;
  await handleZoom(
    o,
    i,
    e,
    o._zoomFactor,
    s.getMagnitude()
  );
}
new Vector2$1();
new Vector2$1();
function update2D(o) {
  StaticMatrix4.equals(StaticMatrix4.IDENTITY, o._scene.camera.transform) && reactToInput(
    o,
    o.enableTranslate,
    o.translateEventTypes,
    translate2D,
    o.inertiaTranslate,
    "_lastInertiaTranslateMovement"
  ), reactToInput(
    o,
    o.enableZoom,
    o.zoomEventTypes,
    zoom2D,
    o.inertiaZoom,
    "_lastInertiaZoomMovement"
  );
}
const pickGlobeScratchRay = new Ray();
new Vector3$1();
new Vector3$1();
async function pickPosition(o, i, e) {
  let s = await o._scene.rendering.picking.pickWorldPosition(i);
  return s ? (Cartesian3.clone(s, e), e) : null;
}
const scratchDistanceCartographic = new Vector3$1();
function getDistanceFromSurface(o) {
  const i = o._ellipsoid, e = o._scene, r = e.camera, s = e.mode;
  let a = 0;
  if (s === SceneMode.SCENE3D) {
    const h = i.cartesianToCartographic(
      r.position,
      scratchDistanceCartographic
    );
    defined$1(h) && (a = h.z);
  } else
    a = r.position.z;
  const c = defaultValue(o._scene.globeHeight, 0);
  return Math.abs(c - a);
}
const scratchSurfaceNormal = new Vector3$1();
function getZoomDistanceUnderground(o, i) {
  const e = i.origin, r = i.direction, s = getDistanceFromSurface(o), a = Cartesian3.normalize(e, scratchSurfaceNormal);
  let c = Math.abs(Cartesian3.dot(a, r));
  return c = Math.max(c, 0.5) * 2, s * c;
}
function getTiltCenterUnderground(o, i, e, r) {
  let s = Cartesian3.distance(i.origin, e);
  const a = getDistanceFromSurface(o), c = CesiumMath.clamp(
    a * 5,
    o._minimumUndergroundPickDistance,
    o._maximumUndergroundPickDistance
  );
  return s > c && (s = Math.min(s, a / 5), s = Math.max(s, 100)), StaticRay.getPoint(i, s, r);
}
function getStrafeStartPositionUnderground(o, i, e, r) {
  let s;
  return defined$1(e) ? (s = Cartesian3.distance(i.origin, e), s > o._maximumUndergroundPickDistance && (s = getDistanceFromSurface(o))) : s = getDistanceFromSurface(o), StaticRay.getPoint(i, s, r);
}
const scratchInertialDelta = new Vector2$1();
function continueStrafing(o, i) {
  const e = i.endPosition, r = Cartesian2.subtract(
    i.endPosition,
    i.startPosition,
    scratchInertialDelta
  ), s = o._strafeEndMousePosition;
  Cartesian2.add(s, r, s), i.endPosition = s, strafe(o, i, o._strafeStartPosition), i.endPosition = e;
}
const translateCVStartRay = new Ray(), translateCVEndRay = new Ray(), translateCVStartPos = new Vector3$1(), translateCVEndPos = new Vector3$1(), translateCVDifference = new Vector3$1(), translateCVOrigin = new Vector3$1(), translateCVPlane = new Plane(new Vector3$1(1, 0, 0), 0), translateCVStartMouse = new Vector2$1(), translateCVEndMouse = new Vector2$1();
async function translateCV(o, i, e) {
  if (Cartesian3.equals(i, o._translateMousePosition) || (o._looking = !1), Cartesian3.equals(i, o._strafeMousePosition) || (o._strafing = !1), o._looking) {
    look3D(o, i, e);
    return;
  }
  if (o._strafing) {
    continueStrafing(o, e);
    return;
  }
  const s = o._scene.camera, a = o._cameraUnderground, c = Cartesian2.clone(
    e.startPosition,
    translateCVStartMouse
  ), l = Cartesian2.clone(e.endPosition, translateCVEndMouse);
  let h = s.getPickRay(c, translateCVStartRay);
  const d = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin), f = Cartesian3.UNIT_X;
  let p;
  if (s.position.z < o._minimumPickingTerrainHeight && (p = await pickPosition(o, c, translateCVStartPos), defined$1(p) && (d.x = p.x)), a || d.x > s.position.z && defined$1(p)) {
    let w = p;
    a && (w = getStrafeStartPositionUnderground(
      o,
      h,
      p,
      translateCVStartPos
    )), Cartesian2.clone(i, o._strafeMousePosition), Cartesian2.clone(i, o._strafeEndMousePosition), Cartesian3.clone(w, o._strafeStartPosition), o._strafing = !0, strafe(o, e, o._strafeStartPosition);
    return;
  }
  const m = StaticPlane.fromPointNormal(d, f, translateCVPlane);
  h = s.getPickRay(c, translateCVStartRay);
  const y = IntersectionTests.rayPlane(
    h,
    m,
    translateCVStartPos
  ), x = s.getPickRay(l, translateCVEndRay), v = IntersectionTests.rayPlane(
    x,
    m,
    translateCVEndPos
  );
  if (!defined$1(y) || !defined$1(v)) {
    o._looking = !0, look3D(o, i, e), Cartesian2.clone(i, o._translateMousePosition);
    return;
  }
  const S = Cartesian3.subtract(
    y,
    v,
    translateCVDifference
  ), E = S.x;
  S.x = S.y, S.y = S.z, S.z = E;
  const b = Cartesian3.magnitude(S);
  b > CesiumMath.EPSILON6 && (Cartesian3.normalize(S, S), s.move(S, b));
}
const rotateCVWindowPos = new Vector2$1(), rotateCVWindowRay = new Ray(), rotateCVCenter = new Vector3$1(), rotateCVVerticalCenter = new Vector3$1(), rotateCVTransform = new Matrix4(), rotateCVVerticalTransform = new Matrix4(), rotateCVOrigin = new Vector3$1(), rotateCVPlane = new Plane(new Vector3$1(1, 0, 0), 0), rotateCVCartesian3 = new Vector3$1(), rotateCVCart = new Vector3$1(), rotateCVOldTransform = new Matrix4(), rotateCVQuaternion = new Quaternion$1(), rotateCVMatrix = new Matrix3(), tilt3DCartesian3 = new Vector3$1();
async function rotateCV(o, i, e) {
  if (defined$1(e.angleAndHeight) && (e = e.angleAndHeight), Cartesian2.equals(i, o._tiltCenterMousePosition) || (o._tiltCVOffMap = !1, o._looking = !1), o._looking) {
    look3D(o, i, e);
    return;
  }
  const s = o._scene.camera;
  o._tiltCVOffMap || !o.onMap() || Math.abs(s.position.z) > o._minimumPickingTerrainHeight ? (o._tiltCVOffMap = !0, rotateCVOnPlane(o, i, e)) : await rotateCVOnTerrain(o, i, e);
}
function rotateCVOnPlane(o, i, e) {
  const r = o._scene, s = r.camera, a = r.canvas, c = rotateCVWindowPos;
  c.x = a.clientWidth / 2, c.y = a.clientHeight / 2;
  const l = s.getPickRay(c, rotateCVWindowRay), h = Cartesian3.UNIT_X, d = l.origin, f = l.direction;
  let p;
  const m = Cartesian3.dot(h, f);
  if (Math.abs(m) > CesiumMath.EPSILON6 && (p = -Cartesian3.dot(h, d) / m), !defined$1(p) || p <= 0) {
    o._looking = !0, look3D(o, i, e), Cartesian2.clone(i, o._tiltCenterMousePosition);
    return;
  }
  const y = Cartesian3.multiplyByScalar(f, p, rotateCVCenter);
  Cartesian3.add(d, y, y);
  const x = r.mapProjection, v = x.ellipsoid;
  Cartesian3.fromElements(y.y, y.z, y.x, y);
  const S = x.unproject(y, rotateCVCart);
  v.cartographicToCartesian(S, y);
  const E = Transforms.eastNorthUpToFixedFrame(
    y,
    v,
    rotateCVTransform
  ), b = o._globe, w = o._ellipsoid;
  o._globe = void 0, o._ellipsoid = Ellipsoid.UNIT_SPHERE, o._rotateFactor = 1, o._rotateRateRangeAdjustment = 1;
  const M = StaticMatrix4.clone(s.transform, rotateCVOldTransform);
  s._setTransform(E), rotate3D(o, i, e, Cartesian3.UNIT_Z), s._setTransform(M), o._globe = b, o._ellipsoid = w;
  const P = w.maximumRadius;
  o._rotateFactor = 1 / P, o._rotateRateRangeAdjustment = P;
}
async function rotateCVOnTerrain(o, i, e) {
  const r = o._scene, s = r.camera, a = o._cameraUnderground, c = r.mapProjection;
  let l, h;
  const d = Cartesian3.UNIT_X;
  if (Cartesian2.equals(i, o._tiltCenterMousePosition))
    l = Cartesian3.clone(o._tiltCenter, rotateCVCenter);
  else {
    if (s.position.z < o._minimumPickingTerrainHeight && (l = await pickPosition(o, i, rotateCVCenter)), !defined$1(l)) {
      h = s.getPickRay(i, rotateCVWindowRay);
      const V = h.origin, N = h.direction;
      let U;
      const z = Cartesian3.dot(d, N);
      if (Math.abs(z) > CesiumMath.EPSILON6 && (U = -Cartesian3.dot(d, V) / z), !defined$1(U) || U <= 0) {
        o._looking = !0, look3D(o, i, e), Cartesian2.clone(i, o._tiltCenterMousePosition);
        return;
      }
      l = Cartesian3.multiplyByScalar(N, U, rotateCVCenter), Cartesian3.add(V, l, l);
    }
    a && (defined$1(h) || (h = s.getPickRay(i, rotateCVWindowRay)), getTiltCenterUnderground(o, h, l, l)), Cartesian2.clone(i, o._tiltCenterMousePosition), Cartesian3.clone(l, o._tiltCenter);
  }
  const f = r.canvas, p = rotateCVWindowPos;
  p.x = f.clientWidth / 2, p.y = o._tiltCenterMousePosition.y, h = s.getPickRay(p, rotateCVWindowRay);
  const m = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);
  m.x = l.x;
  const y = StaticPlane.fromPointNormal(m, d, rotateCVPlane), x = IntersectionTests.rayPlane(
    h,
    y,
    rotateCVVerticalCenter
  ), v = c.ellipsoid;
  Cartesian3.fromElements(l.y, l.z, l.x, l);
  let S = c.unproject(l, rotateCVCart);
  v.cartographicToCartesian(S, l);
  const E = Transforms.eastNorthUpToFixedFrame(
    l,
    v,
    rotateCVTransform
  );
  let b;
  defined$1(x) ? (Cartesian3.fromElements(
    x.y,
    x.z,
    x.x,
    x
  ), S = c.unproject(x, rotateCVCart), v.cartographicToCartesian(S, x), b = Transforms.eastNorthUpToFixedFrame(
    x,
    v,
    rotateCVVerticalTransform
  )) : b = E;
  const w = o._globe, M = o._ellipsoid;
  o._globe = void 0, o._ellipsoid = Ellipsoid.UNIT_SPHERE, o._rotateFactor = 1, o._rotateRateRangeAdjustment = 1;
  let P = Cartesian3.UNIT_Z;
  const D = StaticMatrix4.clone(s.transform, rotateCVOldTransform);
  s._setTransform(E);
  const L = Cartesian3.cross(
    Cartesian3.UNIT_Z,
    Cartesian3.normalize(s.position, rotateCVCartesian3),
    rotateCVCartesian3
  ), O = Cartesian3.dot(s.right, L);
  if (rotate3D(o, i, e, P, !1, !0), s._setTransform(b), O < 0) {
    const V = e.startPosition.y - e.endPosition.y;
    (a && V < 0 || !a && V > 0) && (P = void 0);
    const N = s.constrainedAxis;
    s.constrainedAxis = void 0, rotate3D(o, i, e, P, !0, !1), s.constrainedAxis = N;
  } else
    rotate3D(o, i, e, P, !0, !1);
  if (defined$1(s.constrainedAxis)) {
    const V = Cartesian3.cross(
      s.direction,
      s.constrainedAxis,
      tilt3DCartesian3
    );
    Cartesian3.equalsEpsilon(V, Cartesian3.ZERO, CesiumMath.EPSILON6) || (Cartesian3.dot(V, s.right) < 0 && Cartesian3.negate(V, V), Cartesian3.cross(V, s.direction, s.up), Cartesian3.cross(s.direction, s.up, s.right), Cartesian3.normalize(s.up, s.up), Cartesian3.normalize(s.right, s.right));
  }
  s._setTransform(D), o._globe = w, o._ellipsoid = M;
  const F = M.maximumRadius;
  o._rotateFactor = 1 / F, o._rotateRateRangeAdjustment = F;
  const k = Cartesian3.clone(
    s.positionWC,
    rotateCVCartesian3
  );
  if (o.enableCollisionDetection && adjustHeightForTerrain(o, !0), !Cartesian3.equals(s.positionWC, k)) {
    s._setTransform(b), s.worldToCameraCoordinatesPoint(k, k);
    const V = Cartesian3.magnitudeSquared(k);
    Cartesian3.magnitudeSquared(s.position) > V && (Cartesian3.normalize(s.position, s.position), Cartesian3.multiplyByScalar(
      s.position,
      Math.sqrt(V),
      s.position
    ));
    const N = Cartesian3.angleBetween(k, s.position), U = Cartesian3.cross(
      k,
      s.position,
      k
    );
    Cartesian3.normalize(U, U);
    const z = StaticQuaternion.fromAxisAngle(
      U,
      N,
      rotateCVQuaternion
    ), $ = StaticMatrix3.fromQuaternion(z, rotateCVMatrix);
    StaticMatrix3.multiplyByVector($, s.direction, s.direction), StaticMatrix3.multiplyByVector($, s.up, s.up), Cartesian3.cross(s.direction, s.up, s.right), Cartesian3.cross(s.right, s.direction, s.up), s._setTransform(D);
  }
}
const zoomCVWindowPos = new Vector2$1(), zoomCVWindowRay = new Ray(), zoomCVIntersection = new Vector3$1();
async function zoomCV(o, i, e) {
  defined$1(e.distance) && (e = e.distance);
  const r = o._scene, s = r.camera, a = r.canvas, c = o._cameraUnderground;
  let l;
  c ? l = i : (l = zoomCVWindowPos, l.x = a.clientWidth / 2, l.y = a.clientHeight / 2);
  const h = s.getPickRay(l, zoomCVWindowRay), d = h.origin, f = h.direction, p = s.position.z;
  let m;
  p < o._minimumPickingTerrainHeight && (m = await pickPosition(o, l, zoomCVIntersection));
  let y;
  if (defined$1(m) && (y = Cartesian3.distance(d, m)), c) {
    const x = getZoomDistanceUnderground(
      o,
      h
    );
    defined$1(y) ? y = Math.min(y, x) : y = x;
  }
  if (!defined$1(y)) {
    const x = Cartesian3.UNIT_X;
    y = -Cartesian3.dot(x, d) / Cartesian3.dot(x, f);
  }
  await handleZoom(
    o,
    i,
    e,
    o._zoomFactor,
    y
  );
}
function updateCV(o) {
  const e = o._scene.camera;
  StaticMatrix4.equals(StaticMatrix4.IDENTITY, e.transform) ? (reactToInput(
    o,
    o.enableTilt,
    o.tiltEventTypes,
    rotateCV,
    o.inertiaSpin,
    "_lastInertiaTiltMovement"
  ), reactToInput(
    o,
    o.enableTranslate,
    o.translateEventTypes,
    translateCV,
    o.inertiaTranslate,
    "_lastInertiaTranslateMovement"
  ), reactToInput(
    o,
    o.enableZoom,
    o.zoomEventTypes,
    zoomCV,
    o.inertiaZoom,
    "_lastInertiaZoomMovement"
  ), reactToInput(
    o,
    o.enableLook,
    o.lookEventTypes,
    look3D
  )) : (reactToInput(
    o,
    o.enableRotate,
    o.rotateEventTypes,
    rotate3D,
    o.inertiaSpin,
    "_lastInertiaSpinMovement"
  ), reactToInput(
    o,
    o.enableZoom,
    o.zoomEventTypes,
    zoom3D,
    o.inertiaZoom,
    "_lastInertiaZoomMovement"
  ));
}
const scratchStrafeRay = new Ray(), scratchStrafePlane = new Plane(new Vector3$1(1, 0, 0), 0), scratchStrafeIntersection = new Vector3$1(), scratchStrafeDirection = new Vector3$1();
function strafe(o, i, e) {
  const r = o._scene, s = r.camera, a = s.getPickRay(i.endPosition, scratchStrafeRay);
  let c = Cartesian3.clone(s.direction, scratchStrafeDirection);
  r.mode === SceneMode.COLUMBUS_VIEW && Cartesian3.fromElements(c.z, c.x, c.y, c);
  const l = StaticPlane.fromPointNormal(
    e,
    c,
    scratchStrafePlane
  ), h = IntersectionTests.rayPlane(
    a,
    l,
    scratchStrafeIntersection
  );
  !defined$1(h) || (c = Cartesian3.subtract(e, h, c), r.mode === SceneMode.COLUMBUS_VIEW && Cartesian3.fromElements(c.y, c.z, c.x, c), Cartesian3.add(s.position, c, s.position));
}
const spin3DPick = new Vector3$1(), scratchCartographic$2 = new Vector3$1(), scratchRadii = new Vector3$1(), scratchEllipsoid = new Ellipsoid(), scratchLookUp = new Vector3$1(), scratchNormal = new Vector3$1(), scratchMousePosition = new Vector3$1();
async function spin3D(o, i, e) {
  const s = o._scene.camera, a = o._cameraUnderground;
  let c = o._ellipsoid;
  if (!StaticMatrix4.equals(s.transform, StaticMatrix4.IDENTITY)) {
    rotate3D(o, i, e);
    return;
  }
  let l, h;
  const d = c.geodeticSurfaceNormal(s.position, scratchLookUp);
  if (Cartesian2.equals(i, o._rotateMousePosition)) {
    if (o._looking)
      look3D(o, i, e, d);
    else if (o._rotating)
      rotate3D(o, i, e);
    else if (o._strafing)
      continueStrafing(o, e);
    else {
      if (Cartesian3.magnitude(s.position) < Cartesian3.magnitude(o._rotateStartPosition))
        return;
      l = Cartesian3.magnitude(o._rotateStartPosition), h = scratchRadii, h.x = h.y = h.z = l, c = Ellipsoid.fromCartesian3(h, scratchEllipsoid), await pan3D(o, i, e, c);
    }
    return;
  }
  o._looking = !1, o._rotating = !1, o._strafing = !1;
  const f = c.cartesianToCartographic(
    s.positionWC,
    scratchCartographic$2
  ).z, p = o._globe;
  if (defined$1(p) && f < o._minimumPickingTerrainHeight) {
    const m = await pickPosition(
      o,
      e.startPosition,
      scratchMousePosition
    );
    if (defined$1(m)) {
      let y = !1;
      const x = s.getPickRay(
        e.startPosition,
        pickGlobeScratchRay
      );
      if (a)
        y = !0, getStrafeStartPositionUnderground(o, x, m, m);
      else {
        const v = c.geodeticSurfaceNormal(m, scratchNormal);
        Math.abs(Cartesian3.dot(x.direction, v)) < 0.05 ? y = !0 : y = Cartesian3.magnitude(s.position) < Cartesian3.magnitude(m);
      }
      y ? (Cartesian2.clone(i, o._strafeEndMousePosition), Cartesian3.clone(m, o._strafeStartPosition), o._strafing = !0, strafe(o, e, o._strafeStartPosition)) : (l = Cartesian3.magnitude(m), h = scratchRadii, h.x = h.y = h.z = l, c = Ellipsoid.fromCartesian3(h, scratchEllipsoid), await pan3D(o, i, e, c), Cartesian3.clone(m, o._rotateStartPosition));
    } else
      o._looking = !0, look3D(o, i, e, d);
  } else
    defined$1(
      s.pickEllipsoid(
        e.startPosition,
        o._ellipsoid,
        spin3DPick
      )
    ) ? (await pan3D(o, i, e, o._ellipsoid), Cartesian3.clone(spin3DPick, o._rotateStartPosition)) : f > o._minimumTrackBallHeight ? (o._rotating = !0, rotate3D(o, i, e)) : (o._looking = !0, look3D(o, i, e, d));
  Cartesian2.clone(i, o._rotateMousePosition);
}
function rotate3D(o, i, e, r, s, a) {
  if (!o.enableRotate && !o.enableTilt)
    return;
  s = defaultValue(s, !1), a = defaultValue(a, !1), o.enableRotate || (s = !0), o.enableTilt || (a = !0);
  const c = o._scene, l = c.camera, h = c.canvas, d = l.constrainedAxis;
  defined$1(r) && (l.constrainedAxis = r);
  const f = Cartesian3.magnitude(l.position);
  let p = o._rotateFactor * (f - o._rotateRateRangeAdjustment);
  p > o._maximumRotateRate && (p = o._maximumRotateRate), p < o._minimumRotateRate && (p = o._minimumRotateRate);
  let m = (e.startPosition.x - e.endPosition.x) / h.clientWidth, y = (e.startPosition.y - e.endPosition.y) / h.clientHeight;
  m = Math.min(m, o.maximumMovementRatio), y = Math.min(
    y,
    o.maximumMovementRatio
  );
  const x = p * m * Math.PI * 2, v = p * y * Math.PI;
  s || l.rotateRight(x), a || l.rotateUp(v), l.constrainedAxis = d;
}
const pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W), pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W), pan3DP03 = new Vector3$1(), pan3DP13 = new Vector3$1(), pan3DTemp0 = new Vector3$1(), pan3DTemp1 = new Vector3$1(), pan3DTemp2 = new Vector3$1(), pan3DTemp3 = new Vector3$1(), pan3DStartMousePosition = new Vector2$1(), pan3DEndMousePosition = new Vector2$1(), pan3DDiffMousePosition = new Vector2$1(), pan3DPixelDimensions = new Vector2$1(), panRay = new Ray();
async function pan3D(o, i, e, r) {
  if (!o.enableTranslate)
    return;
  const s = o._scene, a = s.camera, c = Cartesian2.clone(
    e.startPosition,
    pan3DStartMousePosition
  ), l = Cartesian2.clone(
    e.endPosition,
    pan3DEndMousePosition
  ), h = r.cartesianToCartographic(
    a.positionWC,
    scratchCartographic$2
  ).z;
  let d, f;
  if (!e.inertiaEnabled && h < o._minimumPickingTerrainHeight && (d = Cartesian3.clone(o._panLastWorldPosition, pan3DP0), !defined$1(o._globe) && !Cartesian2.equalsEpsilon(
    c,
    o._panLastMousePosition
  ) && (d = await pickPosition(o, c, pan3DP0)), !defined$1(o._globe) && defined$1(d))) {
    const p = Cartesian3.subtract(d, a.positionWC, pan3DTemp1), m = Cartesian3.multiplyByScalar(
      a.directionWC,
      Cartesian3.dot(a.directionWC, p),
      pan3DTemp1
    ), y = Cartesian3.magnitude(m), x = a.frustum.getPixelDimensions(
      s.drawingBufferWidth,
      s.drawingBufferHeight,
      y,
      s.pixelRatio,
      pan3DPixelDimensions
    ), v = Cartesian2.subtract(
      l,
      c,
      pan3DDiffMousePosition
    ), S = Cartesian3.multiplyByScalar(
      a.rightWC,
      v.x * x.x,
      pan3DTemp1
    ), E = Cartesian3.normalize(
      a.positionWC,
      scratchCameraPositionNormal
    ), b = a.getPickRay(l, panRay).direction, w = Cartesian3.subtract(
      b,
      Cartesian3.projectVector(b, a.rightWC, pan3DTemp2),
      pan3DTemp2
    ), M = Cartesian3.angleBetween(w, a.directionWC);
    let P = 1;
    defined$1(a.frustum.fov) && (P = Math.max(Math.tan(M), 0.1));
    let D = Math.abs(
      Cartesian3.dot(a.directionWC, E)
    );
    const L = -v.y * x.y * 2 / Math.sqrt(P) * (1 - D), O = Cartesian3.multiplyByScalar(
      b,
      L,
      pan3DTemp2
    );
    D = Math.abs(Cartesian3.dot(a.upWC, E));
    const F = Cartesian3.multiplyByScalar(
      a.upWC,
      -v.y * (1 - D) * x.y,
      pan3DTemp3
    );
    f = Cartesian3.add(d, S, pan3DP1), f = Cartesian3.add(f, O, f), f = Cartesian3.add(f, F, f), Cartesian3.clone(f, o._panLastWorldPosition), Cartesian2.clone(l, o._panLastMousePosition);
  }
  if ((!defined$1(d) || !defined$1(f)) && (d = a.pickEllipsoid(c, r, pan3DP0), f = a.pickEllipsoid(l, r, pan3DP1)), d && (d.w = 1), f && (f.w = 1), !defined$1(d) || !defined$1(f)) {
    o._rotating = !0, rotate3D(o, i, e);
    return;
  }
  if (d = a.worldToCameraCoordinates(d, d), f = a.worldToCameraCoordinates(f, f), d = Cartesian3.fromCartesian4(d, pan3DP03), f = Cartesian3.fromCartesian4(f, pan3DP13), defined$1(a.constrainedAxis)) {
    const p = a.constrainedAxis, m = Cartesian3.mostOrthogonalAxis(p, pan3DTemp0);
    Cartesian3.cross(m, p, m), Cartesian3.normalize(m, m);
    const y = Cartesian3.cross(p, m, pan3DTemp1), x = Cartesian3.magnitude(d), v = Cartesian3.dot(p, d), S = Math.acos(v / x), E = Cartesian3.multiplyByScalar(p, v, pan3DTemp2);
    Cartesian3.subtract(d, E, E), Cartesian3.normalize(E, E);
    const b = Cartesian3.magnitude(f), w = Cartesian3.dot(p, f), M = Math.acos(w / b), P = Cartesian3.multiplyByScalar(p, w, pan3DTemp3);
    Cartesian3.subtract(f, P, P), Cartesian3.normalize(P, P);
    let D = Math.acos(Cartesian3.dot(E, m));
    Cartesian3.dot(E, y) < 0 && (D = CesiumMath.TWO_PI - D);
    let L = Math.acos(Cartesian3.dot(P, m));
    Cartesian3.dot(P, y) < 0 && (L = CesiumMath.TWO_PI - L);
    const O = D - L;
    let F;
    Cartesian3.equalsEpsilon(p, a.position, CesiumMath.EPSILON2) ? F = a.right : F = Cartesian3.cross(p, a.position, pan3DTemp0);
    const k = Cartesian3.cross(p, F, pan3DTemp0), V = Cartesian3.dot(
      k,
      Cartesian3.subtract(d, p, pan3DTemp1)
    ), N = Cartesian3.dot(
      k,
      Cartesian3.subtract(f, p, pan3DTemp1)
    );
    let U;
    V > 0 && N > 0 ? U = M - S : V > 0 && N <= 0 ? Cartesian3.dot(a.position, p) > 0 ? U = -S - M : U = S + M : U = S - M, a.rotateRight(O), a.rotateUp(U);
  } else {
    Cartesian3.normalize(d, d), Cartesian3.normalize(f, f);
    const p = Cartesian3.dot(d, f), m = Cartesian3.cross(d, f, pan3DTemp0);
    if (p < 1 && !Cartesian3.equalsEpsilon(m, Cartesian3.ZERO, CesiumMath.EPSILON14)) {
      const y = Math.acos(p);
      a.rotate(m, y);
    }
  }
}
const zoom3DUnitPosition = new Vector3$1(), zoom3DCartographic = new Vector3$1();
let preIntersectionDistance = 0;
async function zoom3D(o, i, e) {
  defined$1(e.distance) && (e = e.distance);
  const r = e.inertiaEnabled, s = o._ellipsoid, a = o._scene, c = a.camera, l = a.canvas, h = o._cameraUnderground;
  let d;
  h ? d = i : (d = zoomCVWindowPos, d.x = l.clientWidth / 2, d.y = l.clientHeight / 2);
  const f = c.getPickRay(d, zoomCVWindowRay);
  let p;
  const m = s.cartesianToCartographic(
    c.position,
    zoom3DCartographic
  ).z, y = Math.abs(preIntersectionDistance) < o.minimumPickingTerrainDistanceWithInertia;
  (r ? y : m < o._minimumPickingTerrainHeight) && (p = await pickPosition(o, d, zoomCVIntersection));
  let v;
  if (defined$1(p) && (v = Cartesian3.distance(f.origin, p), preIntersectionDistance = v), h) {
    const E = getZoomDistanceUnderground(
      o,
      f
    );
    defined$1(v) ? v = Math.min(v, E) : v = E;
  }
  defined$1(v) || (v = m);
  const S = Cartesian3.normalize(
    c.position,
    zoom3DUnitPosition
  );
  await handleZoom(
    o,
    i,
    e,
    o._zoomFactor,
    v,
    Cartesian3.dot(S, c.direction)
  );
}
const tilt3DWindowPos = new Vector2$1(), tilt3DRay = new Ray(), tilt3DCenter = new Vector3$1(), tilt3DVerticalCenter = new Vector3$1(), tilt3DTransform = new Matrix4(), tilt3DVerticalTransform = new Matrix4(), tilt3DOldTransform = new Matrix4(), tilt3DQuaternion = new Quaternion$1(), tilt3DMatrix = new Matrix3(), tilt3DCart = new Vector3$1(), tilt3DLookUp = new Vector3$1();
async function tilt3D(o, i, e) {
  const s = o._scene.camera;
  if (!StaticMatrix4.equals(s.transform, StaticMatrix4.IDENTITY))
    return;
  if (defined$1(e.angleAndHeight) && (e = e.angleAndHeight), Cartesian2.equals(i, o._tiltCenterMousePosition) || (o._tiltOnEllipsoid = !1, o._looking = !1), o._looking) {
    const l = o._ellipsoid.geodeticSurfaceNormal(
      s.position,
      tilt3DLookUp
    );
    look3D(o, i, e, l);
    return;
  }
  const c = o._ellipsoid.cartesianToCartographic(
    s.position,
    tilt3DCart
  );
  o._tiltOnEllipsoid || c.z > o._minimumCollisionTerrainHeight ? (o._tiltOnEllipsoid = !0, tilt3DOnEllipsoid(o, i, e)) : await tilt3DOnTerrain(o, i, e);
}
const tilt3DOnEllipsoidCartographic = new Vector3$1();
function tilt3DOnEllipsoid(o, i, e) {
  const r = o._ellipsoid, s = o._scene, a = s.camera, c = o.minimumZoomDistance * 0.25, l = r.cartesianToCartographic(
    a.positionWC,
    tilt3DOnEllipsoidCartographic
  ).z;
  if (l - c - 1 < CesiumMath.EPSILON3 && e.endPosition.y - e.startPosition.y < 0)
    return;
  const h = s.canvas, d = tilt3DWindowPos;
  d.x = h.clientWidth / 2, d.y = h.clientHeight / 2;
  const f = a.getPickRay(d, tilt3DRay);
  let p;
  const m = IntersectionTests.rayEllipsoid(f, r);
  if (defined$1(m))
    p = StaticRay.getPoint(f, m.start, tilt3DCenter);
  else if (l > o._minimumTrackBallHeight) {
    const b = IntersectionTests.grazingAltitudeLocation(
      f,
      r
    );
    if (!defined$1(b))
      return;
    const w = r.cartesianToCartographic(
      b,
      tilt3DCart
    );
    w.z = 0, p = r.cartographicToCartesian(
      w,
      tilt3DCenter
    );
  } else {
    o._looking = !0;
    const b = o._ellipsoid.geodeticSurfaceNormal(
      a.position,
      tilt3DLookUp
    );
    look3D(o, i, e, b), Cartesian2.clone(i, o._tiltCenterMousePosition);
    return;
  }
  const y = Transforms.eastNorthUpToFixedFrame(
    p,
    r,
    tilt3DTransform
  ), x = o._globe, v = o._ellipsoid;
  o._globe = void 0, o._ellipsoid = Ellipsoid.UNIT_SPHERE, o._rotateFactor = 1, o._rotateRateRangeAdjustment = 1;
  const S = StaticMatrix4.clone(a.transform, tilt3DOldTransform);
  a._setTransform(y), rotate3D(o, i, e, Cartesian3.UNIT_Z), a._setTransform(S), o._globe = x, o._ellipsoid = v;
  const E = v.maximumRadius;
  o._rotateFactor = 1 / E, o._rotateRateRangeAdjustment = E;
}
async function tilt3DOnTerrain(o, i, e) {
  const r = o._ellipsoid, s = o._scene, a = s.camera, c = o._cameraUnderground;
  let l, h, d;
  if (Cartesian2.equals(i, o._tiltCenterMousePosition))
    l = Cartesian3.clone(o._tiltCenter, tilt3DCenter);
  else {
    if (l = await pickPosition(o, i, tilt3DCenter), !defined$1(l)) {
      if (h = a.getPickRay(i, tilt3DRay), d = IntersectionTests.rayEllipsoid(h, r), !defined$1(d)) {
        if (r.cartesianToCartographic(
          a.position,
          tilt3DCart
        ).z <= o._minimumTrackBallHeight) {
          o._looking = !0;
          const N = o._ellipsoid.geodeticSurfaceNormal(
            a.position,
            tilt3DLookUp
          );
          look3D(o, i, e, N), Cartesian2.clone(i, o._tiltCenterMousePosition);
        }
        return;
      }
      l = StaticRay.getPoint(h, d.start, tilt3DCenter);
    }
    c && (defined$1(h) || (h = a.getPickRay(i, tilt3DRay)), getTiltCenterUnderground(o, h, l, l)), Cartesian2.clone(i, o._tiltCenterMousePosition), Cartesian3.clone(l, o._tiltCenter);
  }
  const f = s.canvas, p = tilt3DWindowPos;
  p.x = f.clientWidth / 2, p.y = o._tiltCenterMousePosition.y, h = a.getPickRay(p, tilt3DRay);
  const m = Cartesian3.magnitude(l), y = Cartesian3.fromElements(m, m, m, scratchRadii), x = Ellipsoid.fromCartesian3(y, scratchEllipsoid);
  if (d = IntersectionTests.rayEllipsoid(h, x), !defined$1(d))
    return;
  const v = Cartesian3.magnitude(h.origin) > m ? d.start : d.stop, S = StaticRay.getPoint(h, v, tilt3DVerticalCenter), E = Transforms.eastNorthUpToFixedFrame(
    l,
    r,
    tilt3DTransform
  ), b = Transforms.eastNorthUpToFixedFrame(
    S,
    x,
    tilt3DVerticalTransform
  ), w = o._globe, M = o._ellipsoid;
  o._globe = void 0, o._ellipsoid = Ellipsoid.UNIT_SPHERE, o._rotateFactor = 1, o._rotateRateRangeAdjustment = 1;
  let P = Cartesian3.UNIT_Z;
  const D = StaticMatrix4.clone(a.transform, tilt3DOldTransform);
  a._setTransform(b);
  const L = Cartesian3.cross(
    S,
    a.positionWC,
    tilt3DCartesian3
  );
  if (Cartesian3.dot(a.rightWC, L) < 0) {
    const V = e.startPosition.y - e.endPosition.y;
    (c && V < 0 || !c && V > 0) && (P = void 0);
    const N = a.constrainedAxis;
    a.constrainedAxis = void 0, rotate3D(o, i, e, P, !0, !1), a.constrainedAxis = N;
  } else
    rotate3D(o, i, e, P, !0, !1);
  if (a._setTransform(E), rotate3D(o, i, e, P, !1, !0), defined$1(a.constrainedAxis)) {
    const V = Cartesian3.cross(
      a.direction,
      a.constrainedAxis,
      tilt3DCartesian3
    );
    Cartesian3.equalsEpsilon(V, Cartesian3.ZERO, CesiumMath.EPSILON6) || (Cartesian3.dot(V, a.right) < 0 && Cartesian3.negate(V, V), Cartesian3.cross(V, a.direction, a.up), Cartesian3.cross(a.direction, a.up, a.right), Cartesian3.normalize(a.up, a.up), Cartesian3.normalize(a.right, a.right));
  }
  a._setTransform(D), o._globe = w, o._ellipsoid = M;
  const F = M.maximumRadius;
  o._rotateFactor = 1 / F, o._rotateRateRangeAdjustment = F;
  const k = Cartesian3.clone(
    a.positionWC,
    tilt3DCartesian3
  );
  if (o.enableCollisionDetection && adjustHeightForTerrain(o, !0), !Cartesian3.equals(a.positionWC, k)) {
    a._setTransform(b), a.worldToCameraCoordinatesPoint(k, k);
    const V = Cartesian3.magnitudeSquared(k);
    Cartesian3.magnitudeSquared(a.position) > V && (Cartesian3.normalize(a.position, a.position), Cartesian3.multiplyByScalar(
      a.position,
      Math.sqrt(V),
      a.position
    ));
    const N = Cartesian3.angleBetween(k, a.position), U = Cartesian3.cross(
      k,
      a.position,
      k
    );
    Cartesian3.normalize(U, U);
    const z = StaticQuaternion.fromAxisAngle(U, N, tilt3DQuaternion), $ = StaticMatrix3.fromQuaternion(z, tilt3DMatrix);
    StaticMatrix3.multiplyByVector($, a.direction, a.direction), StaticMatrix3.multiplyByVector($, a.up, a.up), Cartesian3.cross(a.direction, a.up, a.right), Cartesian3.cross(a.right, a.direction, a.up), a._setTransform(D);
  }
}
const look3DStartPos = new Vector2$1(), look3DEndPos = new Vector2$1(), look3DStartRay = new Ray(), look3DEndRay = new Ray(), look3DNegativeRot = new Vector3$1(), look3DTan = new Vector3$1();
function look3D(o, i, e, r) {
  const a = o._scene.camera, c = look3DStartPos;
  c.x = e.startPosition.x, c.y = 0;
  const l = look3DEndPos;
  l.x = e.endPosition.x, l.y = 0;
  let h = a.getPickRay(c, look3DStartRay), d = a.getPickRay(l, look3DEndRay), f = 0, p, m;
  p = h.direction, m = d.direction;
  let y = Cartesian3.dot(p, m);
  y < 1 && (f = Math.acos(y)), f = e.startPosition.x > e.endPosition.x ? -f : f;
  const x = o._horizontalRotationAxis;
  if (defined$1(r) ? a.look(r, -f) : defined$1(x) ? a.look(x, -f) : a.lookLeft(f), c.x = 0, c.y = e.startPosition.y, l.x = 0, l.y = e.endPosition.y, h = a.getPickRay(c, look3DStartRay), d = a.getPickRay(l, look3DEndRay), f = 0, p = h.direction, m = d.direction, y = Cartesian3.dot(p, m), y < 1 && (f = Math.acos(y)), f = e.startPosition.y > e.endPosition.y ? -f : f, r = defaultValue(r, x), defined$1(r)) {
    const v = a.direction, S = Cartesian3.negate(
      r,
      look3DNegativeRot
    ), E = Cartesian3.equalsEpsilon(
      v,
      r,
      CesiumMath.EPSILON2
    ), b = Cartesian3.equalsEpsilon(
      v,
      S,
      CesiumMath.EPSILON2
    );
    if (!E && !b) {
      y = Cartesian3.dot(v, r);
      let w = CesiumMath.acosClamped(y);
      f > 0 && f > w && (f = w - CesiumMath.EPSILON4), y = Cartesian3.dot(v, S), w = CesiumMath.acosClamped(y), f < 0 && -f > w && (f = -w + CesiumMath.EPSILON4);
      const M = Cartesian3.cross(r, v, look3DTan);
      a.look(M, f);
    } else
      (E && f < 0 || b && f > 0) && a.look(a.right, -f);
  } else
    a.lookUp(f);
}
function update3D(o) {
  reactToInput(
    o,
    o.enableRotate || o.enableTranslate,
    o.rotateEventTypes,
    spin3D,
    o.inertiaSpin,
    "_lastInertiaSpinMovement"
  ), reactToInput(
    o,
    o.enableZoom,
    o.zoomEventTypes,
    zoom3D,
    o.inertiaZoom,
    "_lastInertiaZoomMovement"
  ), reactToInput(
    o,
    o.enableTilt || o.enableRotate,
    o.tiltEventTypes,
    tilt3D,
    o.inertiaSpin,
    "_lastInertiaTiltMovement"
  ), reactToInput(
    o,
    o.enableLook,
    o.lookEventTypes,
    look3D
  );
}
const scratchAdjustHeightTransform = new Matrix4(), scratchAdjustHeightCartographic = new Vector3$1();
function adjustHeightForTerrain(o, i) {
  o._adjustedHeightForTerrain = !0;
  const e = o._scene, r = e.mode, s = e.globe;
  if (!defined$1(s) || r === SceneMode.SCENE2D || r === SceneMode.MORPHING)
    return;
  const a = e.camera, c = s.ellipsoid, l = e.mapProjection;
  let h, d;
  StaticMatrix4.equals(a.transform, StaticMatrix4.IDENTITY) || (h = StaticMatrix4.clone(a.transform, scratchAdjustHeightTransform), d = Cartesian3.magnitude(a.position), a._setTransform(StaticMatrix4.IDENTITY));
  const f = scratchAdjustHeightCartographic;
  r === SceneMode.SCENE3D ? c.cartesianToCartographic(a.position, f) : l.unproject(a.position, f);
  let p = !1;
  if (f.z < o._minimumCollisionTerrainHeight) {
    const m = defaultValue(o._scene.globeHeight, 0);
    if (defined$1(m)) {
      const y = m + o.minimumZoomDistance, x = m - o._lastGlobeHeight, v = x / o._lastGlobeHeight;
      f.z < y && (i || Math.abs(v) <= 0.1) && (f.z = y, r === SceneMode.SCENE3D ? c.cartographicToCartesian(f, a.position) : l.project(f, a.position), p = !0), i || Math.abs(v) <= 0.1 ? o._lastGlobeHeight = m : o._lastGlobeHeight += x * 0.1;
    }
  }
  defined$1(h) && (a._setTransform(h), p && (Cartesian3.normalize(a.position, a.position), Cartesian3.negate(a.position, a.direction), Cartesian3.multiplyByScalar(
    a.position,
    Math.max(d, o.minimumZoomDistance),
    a.position
  ), Cartesian3.normalize(a.direction, a.direction), Cartesian3.cross(a.direction, a.up, a.right), Cartesian3.cross(a.right, a.direction, a.up)));
}
function isCameraUnderground(o) {
  const i = o._scene, e = i.camera, r = i.mode, s = e.positionCartographic;
  if (!defined$1(s))
    return !1;
  if (!o.onMap() && s.z < 0)
    return !0;
  if (r === SceneMode.SCENE2D || r === SceneMode.MORPHING)
    return !1;
  const a = defaultValue(i.globeHeight, 0);
  return defined$1(a) && s.z < a;
}
const scratchGetHeightCartesian = new Vector3$1(), scratchGetHeightIntersection = new Vector3$1(), scratchGetHeightCartographic = new Vector3$1(), scratchGetHeightRay = new Ray();
function getGlobeHeight(o) {
  const i = o._scene;
  if (i.mode === SceneMode.MORPHING)
    return;
  const r = i.camera.positionCartographic;
  if (!defined$1(r))
    return;
  let s = Number.NEGATIVE_INFINITY;
  const a = i.globe;
  if (defined$1(a)) {
    const l = i.mapProjection.ellipsoid, h = Cartesian3.fromRadians(
      r.x,
      r.y,
      0,
      l,
      scratchGetHeightCartesian
    ), d = scratchGetHeightRay;
    l.geodeticSurfaceNormal(
      h,
      d.direction
    ), l.getSurfaceNormalIntersectionWithZAxis(
      h,
      111500,
      d.origin
    );
    const f = 7e6;
    d.origin.add(d.direction.clone().multiplyScalar(f)), d.direction.negate(), o._cameraUnderground;
    let p = i.rendering.picking.pickTerrainWorldPosition(d);
    if (!defined$1(p)) {
      let m = IntersectionTests.rayEllipsoid(d, l);
      if (defined$1(m)) {
        let y = m.start > 0 ? m.start : m.stop;
        p = StaticRay.getPoint(d, y, scratchGetHeightIntersection);
      }
    }
    defined$1(p) && (s = l.cartesianToCartographic(
      p,
      scratchGetHeightCartographic
    ).z);
  }
  if (s > Number.NEGATIVE_INFINITY)
    return s;
}
function sceneInitializeFrame(o) {
  const i = o._scene;
  o.enableTerrainCollision && (i.globeHeight = getGlobeHeight(o)), i.cameraUnderground = isCameraUnderground(o);
}
ScreenSpaceCameraController.prototype.onMap = function() {
  const o = this._scene, i = o.mode, e = o.camera;
  return i === SceneMode.COLUMBUS_VIEW ? Math.abs(e.position.x) - this._maxCoord.x < 0 && Math.abs(e.position.y) - this._maxCoord.y < 0 : !0;
};
const scratchPreviousPosition = new Vector3$1(), scratchPreviousDirection = new Vector3$1();
ScreenSpaceCameraController.prototype.update = function() {
  const o = this._scene, i = o.camera, e = o.globe, r = o.mode;
  sceneInitializeFrame(this), StaticMatrix4.equals(i.transform, StaticMatrix4.IDENTITY) ? (this._globe = e, this._ellipsoid = defined$1(this._globe) ? this._globe.ellipsoid : o.mapProjection.ellipsoid) : (this._globe = void 0, this._ellipsoid = Ellipsoid.UNIT_SPHERE);
  const s = defined$1(this._globe) && defined$1(this._globe.terrainExaggeration) ? this._globe.terrainExaggeration : 1, a = defined$1(this._globe) && defined$1(this._globe.terrainExaggerationRelativeHeight) ? this._globe.terrainExaggerationRelativeHeight : 0;
  if (this._minimumCollisionTerrainHeight = TerrainExaggeration.getHeight(
    this.minimumCollisionTerrainHeight,
    s,
    a
  ), this._minimumPickingTerrainHeight = TerrainExaggeration.getHeight(
    this.minimumPickingTerrainHeight,
    s,
    a
  ), this._minimumTrackBallHeight = TerrainExaggeration.getHeight(
    this.minimumTrackBallHeight,
    s,
    a
  ), this._cameraUnderground = o.cameraUnderground && defined$1(this._globe), this._ellipsoid) {
    const h = this._ellipsoid.maximumRadius;
    this._rotateFactor = 1 / h, this._rotateRateRangeAdjustment = h;
  }
  this._adjustedHeightForTerrain = !1;
  const c = Cartesian3.clone(
    i.positionWC,
    scratchPreviousPosition
  ), l = Cartesian3.clone(
    i.directionWC,
    scratchPreviousDirection
  );
  if (r === SceneMode.SCENE2D ? update2D(this) : r === SceneMode.COLUMBUS_VIEW ? (this._horizontalRotationAxis = Cartesian3.UNIT_Z, updateCV(this)) : r === SceneMode.SCENE3D && (this._horizontalRotationAxis = void 0, update3D(this)), this.enableCollisionDetection && !this._adjustedHeightForTerrain) {
    const h = !Cartesian3.equals(c, i.positionWC) || !Cartesian3.equals(l, i.directionWC);
    adjustHeightForTerrain(this, h);
  }
  this._aggregator.reset();
};
ScreenSpaceCameraController.prototype.isDestroyed = function() {
  return !1;
};
ScreenSpaceCameraController.prototype.destroy = function() {
  return this._aggregator = this._aggregator && this._aggregator.destroy(), destroyObject(this);
};
function EllipsoidalOccluder(o, i) {
  this._ellipsoid = o, this._cameraPosition = new Vector3$1(), this._cameraPositionInScaledSpace = new Vector3$1(), this._distanceToLimbInScaledSpaceSquared = 0, defined$1(i) && (this.cameraPosition = i);
}
Object.defineProperties(EllipsoidalOccluder.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  },
  cameraPosition: {
    get: function() {
      return this._cameraPosition;
    },
    set: function(o) {
      const e = this._ellipsoid.transformPositionToScaledSpace(
        o,
        this._cameraPositionInScaledSpace
      ), r = Cartesian3.magnitudeSquared(e) - 1;
      Cartesian3.clone(o, this._cameraPosition), this._cameraPositionInScaledSpace = e, this._distanceToLimbInScaledSpaceSquared = r;
    }
  }
});
const scratchCartesian$2 = new Vector3$1();
EllipsoidalOccluder.prototype.isPointVisible = function(o) {
  const e = this._ellipsoid.transformPositionToScaledSpace(
    o,
    scratchCartesian$2
  );
  return isScaledSpacePointVisible(
    e,
    this._cameraPositionInScaledSpace,
    this._distanceToLimbInScaledSpaceSquared
  );
};
EllipsoidalOccluder.prototype.isScaledSpacePointVisible = function(o) {
  return isScaledSpacePointVisible(
    o,
    this._cameraPositionInScaledSpace,
    this._distanceToLimbInScaledSpaceSquared
  );
};
const scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();
EllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function(o, i) {
  const e = this._ellipsoid;
  let r, s;
  return defined$1(i) && i < 0 && e.minimumRadius > -i ? (s = scratchCameraPositionInScaledSpaceShrunk, s.x = this._cameraPosition.x / (e.radii.x + i), s.y = this._cameraPosition.y / (e.radii.y + i), s.z = this._cameraPosition.z / (e.radii.z + i), r = s.x * s.x + s.y * s.y + s.z * s.z - 1) : (s = this._cameraPositionInScaledSpace, r = this._distanceToLimbInScaledSpaceSquared), isScaledSpacePointVisible(
    o,
    s,
    r
  );
};
EllipsoidalOccluder.prototype.computeHorizonCullingPoint = function(o, i, e) {
  return computeHorizonCullingPointFromPositions(
    this._ellipsoid,
    o,
    i,
    e
  );
};
const scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
EllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function(o, i, e, r) {
  const s = getPossiblyShrunkEllipsoid(
    this._ellipsoid,
    e,
    scratchEllipsoidShrunk
  );
  return computeHorizonCullingPointFromPositions(
    s,
    o,
    i,
    r
  );
};
EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function(o, i, e, r, s) {
  return computeHorizonCullingPointFromVertices(
    this._ellipsoid,
    o,
    i,
    e,
    r,
    s
  );
};
EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function(o, i, e, r, s, a) {
  const c = getPossiblyShrunkEllipsoid(
    this._ellipsoid,
    s,
    scratchEllipsoidShrunk
  );
  return computeHorizonCullingPointFromVertices(
    c,
    o,
    i,
    e,
    r,
    a
  );
};
const subsampleScratch = [];
EllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function(o, i, e) {
  const r = Rectangle.subsample(
    o,
    i,
    0,
    subsampleScratch
  ), s = new Sphere();
  if (s.setFromPoints(r), !(Cartesian3.magnitude(s.center) < 0.1 * i.minimumRadius))
    return this.computeHorizonCullingPoint(s.center, r, e);
};
const scratchEllipsoidShrunkRadii = new Vector3$1();
function getPossiblyShrunkEllipsoid(o, i, e) {
  if (defined$1(i) && i < 0 && o.minimumRadius > -i) {
    const r = Cartesian3.fromElements(
      o.radii.x + i,
      o.radii.y + i,
      o.radii.z + i,
      scratchEllipsoidShrunkRadii
    );
    o = Ellipsoid.fromCartesian3(r, e);
  }
  return o;
}
function computeHorizonCullingPointFromPositions(o, i, e, r) {
  defined$1(r) || (r = new Vector3$1());
  const s = computeScaledSpaceDirectionToPoint(
    o,
    i
  );
  let a = 0;
  for (let c = 0, l = e.length; c < l; ++c) {
    const h = e[c], d = computeMagnitude(
      o,
      h,
      s
    );
    if (d < 0)
      return;
    a = Math.max(a, d);
  }
  return magnitudeToPoint(s, a, r);
}
const positionScratch$5 = new Vector3$1();
function computeHorizonCullingPointFromVertices(o, i, e, r, s, a) {
  defined$1(a) || (a = new Vector3$1()), r = defaultValue(r, 3), s = defaultValue(s, Cartesian3.ZERO);
  const c = computeScaledSpaceDirectionToPoint(
    o,
    i
  );
  let l = 0;
  for (let h = 0, d = e.length; h < d; h += r) {
    positionScratch$5.x = e[h] + s.x, positionScratch$5.y = e[h + 1] + s.y, positionScratch$5.z = e[h + 2] + s.z;
    const f = computeMagnitude(
      o,
      positionScratch$5,
      c
    );
    if (f < 0)
      return;
    l = Math.max(l, f);
  }
  return magnitudeToPoint(c, l, a);
}
function isScaledSpacePointVisible(o, i, e) {
  const r = i, s = e, a = Cartesian3.subtract(
    o,
    r,
    scratchCartesian$2
  ), c = -Cartesian3.dot(a, r);
  return !(s < 0 ? c > 0 : c > s && c * c / Cartesian3.magnitudeSquared(a) > s);
}
const scaledSpaceScratch = new Vector3$1(), directionScratch$3 = new Vector3$1();
function computeMagnitude(o, i, e) {
  const r = o.transformPositionToScaledSpace(
    i,
    scaledSpaceScratch
  );
  let s = Cartesian3.magnitudeSquared(r), a = Math.sqrt(s);
  const c = Cartesian3.divideByScalar(
    r,
    a,
    directionScratch$3
  );
  s = Math.max(1, s), a = Math.max(1, a);
  const l = Cartesian3.dot(c, e), h = Cartesian3.magnitude(
    Cartesian3.cross(c, e, c)
  ), d = 1 / a, f = Math.sqrt(s - 1) * d;
  return 1 / (l * d - h * f);
}
function magnitudeToPoint(o, i, e) {
  if (!(i <= 0 || i === 1 / 0 || isNaN(i)))
    return Cartesian3.multiplyByScalar(
      o,
      i,
      e
    );
}
const directionToPointScratch = new Vector3$1();
function computeScaledSpaceDirectionToPoint(o, i) {
  return Cartesian3.equals(i, Cartesian3.ZERO) ? i : (o.transformPositionToScaledSpace(
    i,
    directionToPointScratch
  ), Cartesian3.normalize(directionToPointScratch, directionToPointScratch));
}
new Vector3$1();
const _tempVector3$6 = new Vector3$1(), _outputDegreeScratch = new Vector3$1();
new Vector3$1();
const directionScratch$2 = new Vector3$1(), positionScratch$4 = new Vector3$1(), upScratch$1 = new Vector3$1(), rightScratch$1 = new Vector3$1(), rotationMatrixScratch$2 = new Matrix4(), xAxisScratch = new Vector3$1(), yAxisScratch = new Vector3$1();
class Earth extends BaseMap {
  constructor(e, r, s) {
    super(e, s);
    _(this, "MERCATOR_LENGTH", 200375083427892e-7);
    _(this, "projectionName", "ecef");
    _(this, "near", 0.1);
    _(this, "fov", 35);
    _(this, "_farScale", 1.2);
    _(this, "handleContextMenu", (e) => {
      e.preventDefault();
    });
    _(this, "handleEventPointerDown", (e) => {
      const s = this._engine.event, a = e.position.x, c = e.position.y;
      s._handlePointerDown({
        pixel: [a, c],
        event: e.event
      });
    });
    _(this, "handleEventPointerUp", (e) => {
      const s = this._engine.event, a = e.position.x, c = e.position.y;
      s._handlePointerUp({
        pixel: [a, c],
        event: e.event
      });
    });
    _(this, "handleEventClick", (e) => {
      const s = this._engine.event, a = e.position.x, c = e.position.y;
      e.event.button === 2 ? s._handleRightClick({
        pixel: [a, c],
        event: e.event
      }) : s._handleClick({
        pixel: [a, c],
        event: e.event
      });
    });
    _(this, "handleEventDblClick", (e) => {
      const s = this._engine.event, a = e.position.x, c = e.position.y;
      e.event.button === 2 ? s._handleRightDblClick({
        pixel: [a, c],
        event: e.event
      }) : s._handleDblClick({
        pixel: [a, c],
        event: e.event
      });
    });
    _(this, "handleEventMouseMove", (e) => {
      const s = this._engine.event, a = e.startPosition.x, c = e.startPosition.y;
      s._handleMouseMove({
        pixel: [a, c],
        event: e
      });
    });
    _(this, "handleViewChange", () => {
      this.onViewChanged && this.onViewChanged();
    });
    _(this, "handleMapResize", () => {
      this.onResolutionChanged && this.onResolutionChanged(this.getResolution());
    });
    this._engine = e, this.domContainer = r, this._ellipsoid = Ellipsoid.WGS84, this.mode = SceneMode.SCENE3D, this.mapProjection = new GeographicProjection(this._ellipsoid);
  }
  afterInit() {
    this.bindCanvas(), this.camera.matrixAutoUpdate = !1, this.handleMapResize(), bind(this.domContainer, this.handleMapResize);
    const e = this._ellipsoidCamera = new EllipsoidCamera(this);
    e.frustum = this.camera, e.constrainedAxis = Cartesian3.UNIT_Z, this._globe = new Globe(this._ellipsoid, this._engine), this._occluder = new EllipsoidalOccluder(this._ellipsoid, this.camera.position), this._initControl();
  }
  bindCanvas() {
    this.domContainer.appendChild(this.canvas);
  }
  releaseCanvas() {
    this.domContainer.removeChild(this.canvas);
  }
  _initControl() {
    const e = this._controllerScene = {
      camera: this._ellipsoidCamera,
      canvas: this.canvas,
      globe: this._globe,
      mode: this.mode,
      globeHeight: 0,
      mapProjection: this.mapProjection,
      rendering: this._engine.rendering
    };
    this._controller = new ScreenSpaceCameraController(e), this.canvas.addEventListener("contextmenu", this.handleContextMenu), this._bindEvents();
  }
  _bindEvents() {
    this._controller._aggregator.onEventPointerDown = this.handleEventPointerDown, this._controller._aggregator.onEventPointerUp = this.handleEventPointerUp, this._controller._aggregator.onEventClick = this.handleEventClick, this._controller._aggregator.onEventDblClick = this.handleEventDblClick, this._controller._aggregator.onEventMouseMove = this.handleEventMouseMove;
  }
  getContainerSize() {
    return [
      this.domContainer.clientWidth,
      this.domContainer.clientHeight
    ];
  }
  getResolution() {
    return new Vector2$1(this.domContainer.clientWidth, this.domContainer.clientHeight);
  }
  getCenter() {
    let e = this.unprojectArrayCoordinate(this.getProjectionCenter());
    return isLngLatArrValid(e) ? e : _outputDegreeScratch.toArray();
  }
  getProjectionCenter() {
    const [e, r] = this.getContainerSize(), s = new Vector2$1(e / 2, r / 2), a = this._ellipsoidCamera.pickEllipsoid(s);
    return a ? [a.x, a.y, a.z] : [0, 0, 0];
  }
  getPitch() {
    return MathUtils.radToDeg(this._ellipsoidCamera.pitch) + 90;
  }
  getHeading() {
    return 360 - MathUtils.radToDeg(this._ellipsoidCamera.heading);
  }
  getRoll() {
    return MathUtils.radToDeg(this._ellipsoidCamera.roll);
  }
  getRange() {
    const e = this.getProjectionCenter();
    return this._ellipsoidCamera.position.distanceTo(_tempVector3$6.set(e[0], e[1], e[2]));
  }
  getZoom() {
    return this.getZoomByZoomUnits(this.getZoomUnits());
  }
  getZoomUnits() {
    const [e, r] = this.getContainerSize();
    return this.getViewHeight() * Math.tan(MathUtils.degToRad(this.fov / 2)) * 2 / r;
  }
  getCameraDistance() {
    return this.getRange();
  }
  getZoomUnitsByZoom(e) {
    return this.MERCATOR_LENGTH / 128 / Math.pow(2, e);
  }
  getZoomByZoomUnits(e) {
    return Math.log2(this.MERCATOR_LENGTH / 128 / e);
  }
  getProjectionBounds() {
    const e = this.getProjectionCenter(), r = this._ellipsoidCamera.position.distanceTo(_tempVector3$6.set(e[0], e[1], e[2])), [s, a] = this.getContainerSize(), c = s / a, l = MathUtils.degToRad(this.getHeading()), h = MathUtils.degToRad(Math.max(this.getPitch(), 80)), d = Math.cos(h);
    let f = 2 * r * Math.tan(MathUtils.degToRad(this.fov / 2)), p = f * c;
    p = Math.abs(Math.cos(l)) * p + Math.abs(Math.sin(l)) * f, f = Math.abs(Math.cos(l)) * f + Math.abs(Math.sin(l)) * p, p /= d, f /= d;
    const m = Transforms.eastNorthUpToFixedFrame(_tempVector3$6.fromArray(e)), y = rotationMatrixScratch$2.extractRotation(m);
    xAxisScratch.setFromMatrixColumn(y, 0), yAxisScratch.setFromMatrixColumn(y, 1);
    const x = xAxisScratch.multiplyScalar(p).add(yAxisScratch.multiplyScalar(f)), v = new Vector3$1(), S = new Vector3$1();
    return v.fromArray(e).sub(x), S.fromArray(e).add(x), new Box3(v, S);
  }
  getBounds() {
    const e = this.getProjectionBounds(), r = this.unprojectArrayCoordinate([e.min.x, e.min.y, e.min.z]), s = this.unprojectArrayCoordinate([e.max.x, e.max.y, e.max.z]);
    return new Box3(new Vector3$1(r[0], r[1], r[2]), new Vector3$1(s[0], s[1], s[2]));
  }
  setCenter(e) {
    this.setProjectionCenter(e);
  }
  setProjectionCenter(e) {
    this.setView(e, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll()
    });
  }
  setHeading(e) {
    const r = this.getProjectionCenter(), s = this._ellipsoidCamera.position.distanceTo(_tempVector3$6.set(r[0], r[1], r[2]));
    this.unprojectArrayCoordinate(r, r), _tempVector3$6.fromArray(r), this.lookAt(_tempVector3$6, {
      heading: e,
      pitch: this.getPitch(),
      roll: this.getRoll(),
      range: s
    });
  }
  setPitch(e) {
    const r = this.getProjectionCenter(), s = this._ellipsoidCamera.position.distanceTo(_tempVector3$6.set(r[0], r[1], r[2]));
    this.unprojectArrayCoordinate(r, r), _tempVector3$6.fromArray(r), this.lookAt(_tempVector3$6, {
      heading: this.getHeading(),
      pitch: e,
      roll: this.getRoll(),
      range: s
    });
  }
  setZoom(e) {
    const r = this.getProjectionCenter(), s = this._ellipsoidCamera.directionWC, a = this.getZoomUnitsByZoom(e), [c, l] = this.getContainerSize(), h = l / 2 * a / Math.tan(MathUtils.degToRad(this.fov / 2));
    _tempVector3$6.set(r[0], r[1], r[2]).add(s.clone().normalize().negate().multiplyScalar(h * 0.1)), this.unprojectArrayCoordinate(_tempVector3$6.toArray(), r), _tempVector3$6.fromArray(r), this.setView(_tempVector3$6, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll()
    });
  }
  setRange(e) {
    const r = this.getProjectionCenter();
    this.unprojectArrayCoordinate(r, r), _tempVector3$6.fromArray(r), this.lookAt(_tempVector3$6, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll(),
      range: e
    });
  }
  zoomIn() {
    const e = directionScratch$2.set(
      this._ellipsoidCamera.directionWC.x,
      this._ellipsoidCamera.directionWC.y,
      this._ellipsoidCamera.directionWC.z
    );
    let r = this.getRange(), a = 0.5 * MathUtils.clamp(r, 0.5, 1e7);
    a + 0.2 > r && (a = r - 0.2);
    const c = this._ellipsoidCamera.positionWC;
    _tempVector3$6.set(c.x, c.y, c.z).add(e.normalize().multiplyScalar(a)), this.setView(_tempVector3$6, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll()
    });
  }
  zoomOut() {
    const e = directionScratch$2.set(
      this._ellipsoidCamera.directionWC.x,
      this._ellipsoidCamera.directionWC.y,
      this._ellipsoidCamera.directionWC.z
    );
    let r = this.getRange(), a = 0.5 * MathUtils.clamp(r, 0.5, 1e7);
    a + 0.2 > r && (a = r - 0.2);
    const c = this._ellipsoidCamera.positionWC;
    _tempVector3$6.set(c.x, c.y, c.z).add(e.normalize().multiplyScalar(-a)), this.setView(_tempVector3$6, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll()
    });
  }
  updateView() {
    this.handleViewChange();
  }
  flyTo(e, r = {}) {
    const s = this._ellipsoidCamera;
    directionScratch$2.copy(s.direction), positionScratch$4.copy(s.position), upScratch$1.copy(s.up), rightScratch$1.copy(s.right);
    const a = new Vector3$1();
    e instanceof Array ? a.set(e[0], e[1], e[2] || 0) : a.copy(e), a.z = a.z || 0, this._ellipsoid.cartographicDegreeToCartesian(a, a), r.heading = defaultValue$1(r.heading, this.getHeading()), r.pitch = defaultValue$1(r.pitch, this.getPitch()), r.heading !== void 0 && (r.heading = MathUtils.degToRad(360 - r.heading)), r.pitch !== void 0 && (r.pitch = MathUtils.degToRad(r.pitch - 90)), s.lookAt(a, r);
    const l = {
      destination: s.position.clone(),
      orientation: {
        heading: r.heading,
        pitch: r.pitch,
        roll: r.roll
      },
      duration: r.duration,
      complete: r.complete
    };
    s.position.copy(positionScratch$4), s.direction.copy(directionScratch$2), s.up.copy(upScratch$1), s.right.copy(rightScratch$1), s.flyTo(l), this.updateView();
  }
  lookAt(e, r = {}) {
    const s = this._ellipsoidCamera, a = new Vector3$1();
    e instanceof Array ? a.set(e[0], e[1], e[2] || 0) : a.copy(e), a.z = a.z || 0, this._ellipsoid.cartographicDegreeToCartesian(a, a), r.heading !== void 0 && (r.heading = MathUtils.degToRad(360 - r.heading)), r.pitch = r.pitch || 1e-3, r.pitch = MathUtils.degToRad(r.pitch - 90), s.lookAt(a, r), this._syncFromEllipsoidCamera(), this.updateView();
  }
  setView(e, r = {}) {
    const s = this._ellipsoidCamera, a = new Vector3$1();
    e instanceof Array ? a.set(e[0], e[1], e[2] || 100) : a.copy(e), a.z = a.z || 0, a.x > -180 && a.x < 180 && a.y > -90 && a.y < 90 && this._ellipsoid.cartographicDegreeToCartesian(a, a);
    const c = {
      destination: a,
      orientation: r
    };
    r.heading !== void 0 && (r.heading = MathUtils.degToRad(360 - r.heading)), r.pitch !== void 0 && (r.pitch = MathUtils.degToRad(r.pitch - 90)), r.roll !== void 0 && (r.roll = MathUtils.degToRad(r.roll)), s.setView(c), this._syncFromEllipsoidCamera(), this.updateView();
  }
  _syncFromEllipsoidCamera() {
    const e = this.camera, r = this._ellipsoidCamera, s = r.viewMatrix, a = r.inverseViewMatrix;
    e.matrixWorld.copy(a), e.matrixWorldInverse.copy(s), e.matrixWorld.decompose(e.position, e.quaternion, e.scale);
  }
  updateCamera() {
    this._controller.update();
    const e = this.camera, r = this._ellipsoidCamera, s = r.viewMatrix, a = r.inverseViewMatrix;
    e.matrixWorld.copy(a), e.matrixWorldInverse.copy(s), e.matrixWorld.decompose(e.position, e.quaternion, e.scale);
    const c = e.position.length(), l = c - this._ellipsoid._maximumRadius;
    let h = c;
    c < 20228866 ? h = c : h = c * this._farScale;
    const [d, f] = this.getContainerSize();
    e.aspect = d / f, this.near = e.near = Math.min(Math.max(l / 1e4, 0.1), 1e3), e.near = this.near, e.far = h, e.fov = this.fov, e.updateProjectionMatrix();
  }
  enableControl() {
    this._controller.enableInputs = !0;
  }
  disableControl() {
    this._controller.enableInputs = !1;
  }
  getViewHeight() {
    return this._ellipsoidCamera.positionCartographic.z;
  }
  getCameraLocation(e) {
    e || (e = new Vector3$1());
    const r = this._ellipsoidCamera.positionCartographic.x * 180 / Math.PI, s = this._ellipsoidCamera.positionCartographic.y * 180 / Math.PI, a = this._ellipsoidCamera.positionCartographic.z;
    return e.set(r, s, a), e;
  }
  pickSeaLevelWorldPosition(e) {
    return this._ellipsoidCamera.pickEllipsoid(e);
  }
  dispose() {
    this.releaseCanvas(), clear(this.domContainer, this.handleMapResize), this.canvas.removeEventListener("contextmenu", this.handleContextMenu);
  }
  setInputAction(e, r) {
    this.eventHandler.setInputAction(e, r);
  }
  getInputAction(e) {
    return this.eventHandler.getInputAction(e);
  }
  removeInputAction(e) {
    this.eventHandler.removeInputAction(e);
  }
  get occluder() {
    return this._occluder;
  }
  set canvas(e) {
    this._canvas !== e && (this._canvas = e, this._controller && (this._controller.destroy(), this._initControl()));
  }
  get canvas() {
    return this._canvas;
  }
  get farScale() {
    return this._farScale;
  }
  set farScale(e) {
    this._farScale = e;
  }
  get controller() {
    return this._controller;
  }
}
class TileQuadtree {
  constructor(i) {
    this._grid = i, this._root = null, this._tiles = {}, this._reusedTiles = {}, this._tilesCount = 0;
  }
  getTileByKey(i) {
    if (this._tiles[i])
      return this._tiles[i];
    const [e, r, s] = i.split("-");
    return this._getOrCreateTile(parseInt(e, 10), parseInt(r, 10), parseInt(s, 10));
  }
  getTile(i, e, r, s = !1) {
    const a = i + "-" + e + "-" + r;
    if (this._tiles[a])
      return this._tiles[a];
    let c = this._getOrCreateTile(i, e, r);
    if (!c && s && this._grid.supportLevelReuse) {
      if (c = this._reusedTiles[a], c === void 0) {
        const l = this._grid.getResuedTileConfig(i, e, r);
        if (l) {
          const [h, d, f, p, m, y, x] = l, v = this._getOrCreateTile(h, d, f);
          c = this._grid.createSubTile(v, p, m, y, x), this._reusedTiles[a] = c;
        } else
          this._reusedTiles[a] = null;
      }
      return c;
    }
    return c;
  }
  getTileChildren(i) {
    if (i.children)
      return i.children;
    if (i.z >= this._grid.maxLevel)
      return null;
    const e = this._grid.createTileChildren(i);
    return this._invokeTileCreateHook(e), i.children = e, e;
  }
  _getOrCreateTile(i, e, r) {
    return i > this._grid.maxLevel ? null : this._selectOrCreateAncestralTiles(i, e, r, this.root);
  }
  isAncestralTile(i, e, r, s) {
    const a = this._grid.getQuadTreeLevelGap(s.z, i);
    return e >> a === s.x && r >> a === s.y;
  }
  _selectOrCreateAncestralTiles(i, e, r, s) {
    for (const a of s) {
      if (a.z === i) {
        if (a.x === e && a.y === r)
          return a;
      } else if (a.z > i)
        return null;
      if (this.isAncestralTile(i, e, r, a)) {
        const c = this.getTileChildren(a);
        for (const l of c)
          this._tiles[l.key] = l, this._tilesCount++;
        return this._selectOrCreateAncestralTiles(i, e, r, c);
      }
    }
    return null;
  }
  _invokeTileCreateHook(i) {
    if (!!this.onTileCreated)
      for (const e of i)
        this.onTileCreated(e);
  }
  get root() {
    if (!this._root) {
      this._root = this._grid.getAvailableRootTiles();
      for (const i of this._root)
        this._tiles[i.key] = i, this._tilesCount++;
      this._invokeTileCreateHook(this._root);
    }
    return this._root;
  }
}
function TileBoundingRegion(o) {
  this.rectangle = Rectangle.clone(o.rectangle), this.minimumHeight = defaultValue(o.minimumHeight, 0), this.maximumHeight = defaultValue(o.maximumHeight, 0), this.southwestCornerCartesian = new Vector3$1(), this.northeastCornerCartesian = new Vector3$1(), this.westNormal = new Vector3$1(), this.southNormal = new Vector3$1(), this.eastNormal = new Vector3$1(), this.northNormal = new Vector3$1();
  const i = defaultValue(o.ellipsoid, Ellipsoid.WGS84);
  computeBox(this, o.rectangle, i), this._orientedBoundingBox = void 0, this._boundingSphere = void 0, defaultValue(o.computeBoundingVolumes, !0) && this.computeBoundingVolumes(i);
}
Object.defineProperties(TileBoundingRegion.prototype, {
  boundingVolume: {
    get: function() {
      return this._orientedBoundingBox;
    }
  },
  boundingSphere: {
    get: function() {
      return this._boundingSphere;
    }
  }
});
TileBoundingRegion.prototype.computeBoundingVolumes = function(o) {
  this._orientedBoundingBox = OrientedBoundingBox.fromRectangle(
    this.rectangle,
    this.minimumHeight,
    this.maximumHeight,
    o
  );
};
const cartesian3Scratch = new Vector3$1(), cartesian3Scratch2 = new Vector3$1(), cartesian3Scratch3 = new Vector3$1(), westNormalScratch = new Vector3$1(), eastWestNormalScratch = new Vector3$1(), westernMidpointScratch = new Vector3$1(), easternMidpointScratch = new Vector3$1(), cartographicScratch = new Vector3$1(), planeScratch = new Plane(new Vector3$1(1, 0, 0), 0), rayScratch = new Ray();
function computeBox(o, i, e) {
  e.cartographicToCartesian(
    Rectangle.southwest(i),
    o.southwestCornerCartesian
  ), e.cartographicToCartesian(
    Rectangle.northeast(i),
    o.northeastCornerCartesian
  ), cartographicScratch.x = i.west, cartographicScratch.y = (i.south + i.north) * 0.5, cartographicScratch.z = 0;
  const r = e.cartographicToCartesian(
    cartographicScratch,
    westernMidpointScratch
  ), s = Cartesian3.cross(
    r,
    Cartesian3.UNIT_Z,
    westNormalScratch
  );
  Cartesian3.normalize(s, o.westNormal), cartographicScratch.x = i.east;
  const a = e.cartographicToCartesian(
    cartographicScratch,
    easternMidpointScratch
  ), c = Cartesian3.cross(
    Cartesian3.UNIT_Z,
    a,
    cartesian3Scratch
  );
  Cartesian3.normalize(c, o.eastNormal);
  let l = Cartesian3.subtract(
    r,
    a,
    cartesian3Scratch
  );
  Cartesian3.magnitude(l) === 0 && (l = Cartesian3.clone(s, l));
  const h = Cartesian3.normalize(
    l,
    eastWestNormalScratch
  ), d = i.south;
  let f;
  if (d > 0) {
    cartographicScratch.x = (i.west + i.east) * 0.5, cartographicScratch.y = d;
    const v = e.cartographicToCartesian(
      cartographicScratch,
      rayScratch.origin
    );
    Cartesian3.clone(h, rayScratch.direction);
    const S = StaticPlane.fromPointNormal(
      o.southwestCornerCartesian,
      o.westNormal,
      planeScratch
    );
    IntersectionTests.rayPlane(
      rayScratch,
      S,
      o.southwestCornerCartesian
    ), f = e.geodeticSurfaceNormal(
      v,
      cartesian3Scratch2
    );
  } else
    f = e.geodeticSurfaceNormalCartographic(
      Rectangle.southeast(i),
      cartesian3Scratch2
    );
  const p = Cartesian3.cross(
    f,
    l,
    cartesian3Scratch3
  );
  Cartesian3.normalize(p, o.southNormal);
  const m = i.north;
  let y;
  if (m < 0) {
    cartographicScratch.x = (i.west + i.east) * 0.5, cartographicScratch.y = m;
    const v = e.cartographicToCartesian(
      cartographicScratch,
      rayScratch.origin
    );
    Cartesian3.negate(h, rayScratch.direction);
    const S = StaticPlane.fromPointNormal(
      o.northeastCornerCartesian,
      o.eastNormal,
      planeScratch
    );
    IntersectionTests.rayPlane(
      rayScratch,
      S,
      o.northeastCornerCartesian
    ), y = e.geodeticSurfaceNormal(
      v,
      cartesian3Scratch2
    );
  } else
    y = e.geodeticSurfaceNormalCartographic(
      Rectangle.northwest(i),
      cartesian3Scratch2
    );
  const x = Cartesian3.cross(
    l,
    y,
    cartesian3Scratch3
  );
  Cartesian3.normalize(x, o.northNormal);
}
const southwestCornerScratch = new Vector3$1(), northeastCornerScratch = new Vector3$1(), negativeUnitY = new Vector3$1(0, -1, 0), negativeUnitZ = new Vector3$1(0, 0, -1), vectorScratch = new Vector3$1();
function distanceToCameraRegion(o, i, e, r, s) {
  s = defaultValue(s, Ellipsoid.WGS84);
  const a = i, c = s.cartesianToCartographic(i);
  let l = 0;
  if (!Rectangle.contains(o.rectangle, c)) {
    let p = o.southwestCornerCartesian, m = o.northeastCornerCartesian, y = o.westNormal, x = o.southNormal, v = o.eastNormal, S = o.northNormal;
    e !== SceneMode.SCENE3D && (p = r.project(
      Rectangle.southwest(o.rectangle),
      southwestCornerScratch
    ), p.z = p.y, p.y = p.x, p.x = 0, m = r.project(
      Rectangle.northeast(o.rectangle),
      northeastCornerScratch
    ), m.z = m.y, m.y = m.x, m.x = 0, y = negativeUnitY, v = Cartesian3.UNIT_Y, x = negativeUnitZ, S = Cartesian3.UNIT_Z);
    const E = Cartesian3.subtract(
      a,
      p,
      vectorScratch
    ), b = Cartesian3.dot(
      E,
      y
    ), w = Cartesian3.dot(
      E,
      x
    ), M = Cartesian3.subtract(
      a,
      m,
      vectorScratch
    ), P = Cartesian3.dot(
      M,
      v
    ), D = Cartesian3.dot(
      M,
      S
    );
    b > 0 ? l += b * b : P > 0 && (l += P * P), w > 0 ? l += w * w : D > 0 && (l += D * D);
  }
  let h, d, f;
  if (e === SceneMode.SCENE3D ? (h = c.z, d = o.minimumHeight, f = o.maximumHeight) : (h = a.x, d = 0, f = 0), h > f) {
    const p = h - f;
    l += p * p;
  } else if (h < d) {
    const p = d - h;
    l += p * p;
  }
  return Math.sqrt(l);
}
TileBoundingRegion.prototype.distanceToCamera = function(o, i, e, r) {
  return distanceToCameraRegion(this, o, i, e, r);
};
TileBoundingRegion.prototype.intersectPlane = function(o) {
  return this._orientedBoundingBox.intersectPlane(o);
};
class GroundSceneRenderer {
  constructor() {
    _(this, "_renderTarget", null);
    _(this, "_multipleRenderTarget", null);
    _(this, "_currentRenderTarget", null);
    this._copyMesh = null;
  }
  _prepareRenderTarget(i, e) {
    const r = i.rendering.resolution, s = i.rendering.pixelRatio, a = i.rendering.features.antialias.samples;
    this._renderTarget && this._renderTarget.samples !== a && (this._renderTarget.dispose(), this._renderTarget = null), this._renderTarget ? e.isResolutionOrPixelRatioChanged && this._renderTarget.setSize(r.x * s, r.y * s) : (this._renderTarget = new WebGLRenderTarget(
      r.x * s,
      r.y * s,
      {
        depthBuffer: !0,
        stencilBuffer: !1,
        samples: a
      }
    ), this._fakeDepthTexture = new DataTexture(new Float32Array(4), 1, 1, FloatType));
    const c = this._copyMesh.material.uniforms;
    c.tDiffuse.value = this._renderTarget.texture, c.tDepth.value = this._fakeDepthTexture, this._currentRenderTarget = this._renderTarget;
  }
  _prepareMultipleRenderTarget(i, e) {
    const r = i.rendering.resolution, s = i.rendering.pixelRatio, a = i.rendering.features.antialias.samples;
    this._multipleRenderTarget && this._multipleRenderTarget.samples !== a && (this._multipleRenderTarget.dispose(), this._multipleRenderTarget = null), this._multipleRenderTarget ? e.isResolutionOrPixelRatioChanged && this._multipleRenderTarget.setSize(r.x * s, r.y * s) : this._multipleRenderTarget = new WebGLRenderTarget(
      r.x * s,
      r.y * s,
      {
        depthBuffer: !0,
        stencilBuffer: !1,
        samples: a,
        count: 2
      }
    );
    const c = this._copyMesh.material.uniforms;
    c.tDiffuse.value = this._multipleRenderTarget.textures[0], c.tDepth.value = this._multipleRenderTarget.textures[1], this._currentRenderTarget = this._multipleRenderTarget;
  }
  render(i, e, r, s, a) {
    r.overrideMaterial ? this._prepareRenderTarget(e, a) : this._prepareMultipleRenderTarget(e, a);
    const c = e.renderer, l = c.getRenderTarget(), h = c.autoClear;
    c.autoClear = !1, c.setRenderTarget(this._currentRenderTarget), c.clear();
    const d = a.cameraOffset;
    i.position.set(-d.x, -d.y, -d.z), i.updateMatrix(), i.updateMatrixWorld(), i.overrideMaterial = r.overrideMaterial, c.render(i, s), i.position.set(0, 0, 0), i.updateMatrix(), i.updateMatrixWorld(), c.setRenderTarget(l), c.autoClear = h;
    const f = this._copyMesh.material.uniforms;
    f.viewMatrix.value.copy(s.matrixWorldInverse), f.projectionMatrix.value.copy(s.projectionMatrix);
  }
  get copyMesh() {
    if (!this._copyMesh) {
      const i = new BufferGeometry();
      i.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), i.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
      const e = new ShaderMaterial({
        name: "GroundSceneCopyShader",
        vertexShader: `
                    varying vec2 vUv;
                    #include <color_pars_vertex>
                    void main() {
                        vUv = uv;
                        gl_Position = vec4(position, 1.0);
                    }
                `,
        fragmentShader: `
                    #include <packing>
                    #include <color_pars_fragment>
                    uniform sampler2D tDiffuse;
                    uniform sampler2D tDepth;
                    uniform mat4 projectionMatrix;
                    uniform float logDepthBufFC;
                    varying vec2 vUv;

                    void main() {
                        gl_FragColor = texelFetch(tDiffuse, ivec2(gl_FragCoord.xy), 0);
                        vec4 depthValue = texelFetch(tDepth, ivec2(gl_FragCoord.xy), 0);
                        gl_FragDepthEXT = unpackRGBAToDepth(depthValue);
                        // \u534A\u900F\u660E\u533A\u57DF\u4E0D\u5199\u5165\u6DF1\u5EA6\uFF0C\u8FB9\u7F18\u7531\u4E8E\u6297\u952F\u9F7F\u4F1A\u4EA7\u751F\u4E00\u4E9B\u534A\u900F\u660E\u533A\u57DF\uFF0C\u6DF1\u5EA6\u503C\u4F1A\u88AB\u5199\u5165\u9519\u8BEF\u503C
                        if (gl_FragColor.a < 0.99) {
                            gl_FragDepthEXT = 1.0;
                        }

                        #include <tonemapping_fragment>
                        #include <colorspace_fragment>
                    }
                `,
        uniforms: {
          tDiffuse: { value: null },
          tDepth: { value: null },
          viewMatrix: { value: new Matrix4() },
          projectionMatrix: { value: new Matrix4() }
        }
      });
      this._copyMesh = new Mesh(i, e), this._copyMesh.isFSQuad = !0, this._copyMesh.frustumCulled = !1, this._copyMesh.renderOrder = -1e6;
    }
    return this._copyMesh;
  }
}
class Strategy {
  constructor(i = {}) {
    _(this, "_logLoadInCurrentFrame", !1);
    _(this, "_loadSiblings", !0);
  }
  beginFrame() {
  }
  endFrame() {
    this._logLoadInCurrentFrame = !1;
  }
  computeTiles(i, e, r, s, a) {
    return {
      selectedTiles: [],
      requestTilesQueue: []
    };
  }
  _pushSelectedTile(i, e, r = !1) {
    e.isMeetSSE !== r ? e.isMeetSSEChanged = !0 : e.isMeetSSEChanged = !1, e.isMeetSSE = r, e.tile._horizonFactor < 0.05 && (e.isMeetSSE = !1), i.push(e);
  }
  get surface() {
    return this._surface;
  }
}
const me = class {
  constructor() {
    _(this, "state", 0);
  }
  setInFrustum() {
    this.state |= me.STATE_IN_FRUSTUM;
  }
  setNotReady() {
    this.state |= me.STATE_NOT_READY;
  }
  setRendered() {
    this.state |= me.STATE_RENDERED;
  }
  setChildRendered() {
    this.state |= me.STATE_CHILD_RENDERED;
  }
  setForceKeep() {
    this.state |= me.STATE_FORCE_KEEP;
  }
  setRenderReady() {
    this.state |= me.STATE_RENDER_READY;
  }
  clearInFrustum() {
    this.state &= ~me.STATE_IN_FRUSTUM;
  }
  clearNotReady() {
    this.state &= ~me.STATE_NOT_READY;
  }
  clearRendered() {
    this.state &= ~me.STATE_RENDERED;
  }
  clearChildRendered() {
    this.state &= ~me.STATE_CHILD_RENDERED;
  }
  clearForceKeep() {
    this.state &= ~me.STATE_FORCE_KEEP;
  }
  clearRenderReady() {
    this.state &= ~me.STATE_RENDER_READY;
  }
  isInFrustum() {
    return (this.state & me.STATE_IN_FRUSTUM) !== 0;
  }
  isNotReady() {
    return (this.state & me.STATE_NOT_READY) !== 0;
  }
  isRendered() {
    return (this.state & me.STATE_RENDERED) !== 0;
  }
  isChildRendered() {
    return (this.state & me.STATE_CHILD_RENDERED) !== 0;
  }
  isForceKeep() {
    return (this.state & me.STATE_FORCE_KEEP) !== 0;
  }
  isRenderReady() {
    return (this.state & me.STATE_RENDER_READY) !== 0;
  }
};
let MapTileRenderState = me;
_(MapTileRenderState, "STATE_IN_FRUSTUM", 1), _(MapTileRenderState, "STATE_NOT_READY", 2), _(MapTileRenderState, "STATE_RENDERED", 4), _(MapTileRenderState, "STATE_CHILD_RENDERED", 8), _(MapTileRenderState, "STATE_FORCE_KEEP", 16), _(MapTileRenderState, "STATE_RENDER_READY", 32);
function boxIntersectsBox(o, i) {
  let e = !1;
  return o.isOrientedBoundingBox && i.isOrientedBoundingBox ? e = o.intersectsObb(i) || i.intersectsObb(o) : o.isOrientedBoundingBox && i.isBox3 ? e = _orientedBoundingBoxIntersectsBox3(o, i) : o.isBox3 && i.isOrientedBoundingBox ? e = _orientedBoundingBoxIntersectsBox3(i, o) : o.isBox3 && i.isBox3 && (e = o.intersectsBox(i)), e;
}
function _orientedBoundingBoxIntersectsBox3(o, i) {
  const r = o.computeCorners().map((h) => ({
    x: h.x,
    y: h.y,
    z: h.z
  }));
  for (const h of r)
    if (h.x >= i.min.x && h.x <= i.max.x && h.y >= i.min.y && h.y <= i.max.y && h.z >= i.min.z && h.z <= i.max.z)
      return !0;
  const s = [
    new Vector3$1(i.min.x, i.min.y, i.min.z),
    new Vector3$1(i.max.x, i.min.y, i.min.z),
    new Vector3$1(i.min.x, i.max.y, i.min.z),
    new Vector3$1(i.max.x, i.max.y, i.min.z),
    new Vector3$1(i.min.x, i.min.y, i.max.z),
    new Vector3$1(i.max.x, i.min.y, i.max.z),
    new Vector3$1(i.min.x, i.max.y, i.max.z),
    new Vector3$1(i.max.x, i.max.y, i.max.z)
  ];
  for (const h of s)
    if (o.distanceSquaredTo(h) === 0)
      return !0;
  const a = [
    new Vector3$1(1, 0, 0),
    new Vector3$1(0, 1, 0),
    new Vector3$1(0, 0, 1)
  ], c = a, l = [...a, ...c];
  for (const h of l) {
    const d = _projectBoundingBox(o, h), f = _projectBox3(i, h);
    if (!_rangesOverlap(d, f))
      return !1;
  }
  return !0;
}
function _projectBoundingBox(o, i) {
  const e = o.computeCorners();
  let r = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
  for (const a of e) {
    const c = a.dot(i);
    r = Math.min(r, c), s = Math.max(s, c);
  }
  return { min: r, max: s };
}
function _projectBox3(o, i) {
  const e = [
    new Vector3$1(o.min.x, o.min.y, o.min.z),
    new Vector3$1(o.max.x, o.min.y, o.min.z),
    new Vector3$1(o.min.x, o.max.y, o.min.z),
    new Vector3$1(o.max.x, o.max.y, o.min.z),
    new Vector3$1(o.min.x, o.min.y, o.max.z),
    new Vector3$1(o.max.x, o.min.y, o.max.z),
    new Vector3$1(o.min.x, o.max.y, o.max.z),
    new Vector3$1(o.max.x, o.max.y, o.max.z)
  ];
  let r = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
  for (const a of e) {
    const c = a.dot(i);
    r = Math.min(r, c), s = Math.max(s, c);
  }
  return { min: r, max: s };
}
function _rangesOverlap(o, i) {
  return !(o.max < i.min || i.max < o.min);
}
new Raycaster();
new Plane(new Vector3$1(0, 0, 1), 0);
new Vector2$1();
const _positionScratch = new Vector3$1(), _leftBottomPixel = new Vector2$1(-1, -1), _rightBottomPixel = new Vector2$1(1, -1);
new Vector2$1(-0.5, -0.5);
new Vector2$1(0.5, -0.5);
new Vector3$1();
const _tempVector2$2 = new Vector2$1();
let _leftBottomPosition = new Vector3$1(), _leftTopPosition = new Vector3$1(), _rightBottomPosition = new Vector3$1(), _rightTopPosition = new Vector3$1();
const _chinaGeoBBox3 = new Box3(
  new Vector3$1(74, 3, -100),
  new Vector3$1(135, 53, 100)
);
class FastTileLoaderStrategy extends Strategy {
  constructor(e = {}) {
    super(e);
    _(this, "isFastTileLoaderStrategy", !0);
    _(this, "_renderedTiles", []);
    _(this, "_renderedTilesMap", /* @__PURE__ */ new Map());
    _(this, "_viewportTilesMap", /* @__PURE__ */ new Map());
    _(this, "_lastViewportZLevel", 0);
    _(this, "_hysteresis", null);
    _(this, "_showDebug", !1);
    _(this, "_isAncestorTile", (e, r) => e.z <= r.z ? !1 : this.surface._quadtree.isAncestralTile(e.z, e.x, e.y, r));
    _(this, "_preserveLastFrameChildrenTiles", (e, r, s) => {
      const a = this._renderedTiles;
      let c = 0;
      for (const l of a)
        if (this._isAncestorTile(l.dataTile, e)) {
          const h = this._surfaceTileManager.getSurfaceTile(l.tile, s);
          h && (this._pushSelectedTile(r, h, !1), c++);
        }
      return c;
    });
    _(this, "_isTileRenderedInLastFrame", (e) => this._renderedTilesMap.has(e.key));
    _(this, "_isTileAncestorRenderedInLastFrame", (e) => {
      for (; e.parent; )
        if (e = e.parent, this._renderedTilesMap.has(e.key))
          return !0;
    });
    _(this, "_hideChildrenTiles", (e, r, s) => {
      let a = 0, c, l;
      for (l = e.length - 1; l >= 0; l--)
        c = e[l].dataTile, this._isAncestorTile(c, s) && (e.splice(l, 1), a++);
      for (l = r.length - 1; l >= 0; l--)
        c = r[l], this._isAncestorTile(c, s) && r.splice(l, 1);
      return a;
    });
    _(this, "_traverseViewportTiles", (e, r, s, a, c, l) => {
      if (!e)
        return;
      const h = this.surface, d = h.engine, { mode: f, mapProjection: p, _ellipsoid: m } = d.map.map, y = d.map.isGlobe;
      for (const x of a) {
        if (f === SceneMode$1.SCENE3D && (h.updateTileBoundingRegion(x, l), h._enableHorizonCulling && h._currentOccluder && (x._occludeePointInScaledSpace || (x._occludeePointInScaledSpace = h._computeOccludeePoint(
          x,
          h._currentOccluder
        )), x._occludeePointInScaledSpace && !h._currentOccluder.isScaledSpacePointVisiblePossiblyUnderEllipsoid(x._occludeePointInScaledSpace, 0))) || !h._computeTileVisibility(r, x))
          continue;
        let v = !1;
        if (y ? x.boundingRegion && x.boundingRegion.boundingVolume && (v = boxIntersectsBox(e, x.boundingRegion.boundingVolume)) : v = boxIntersectsBox(e, x.targetBoundingBox), v) {
          const S = h.computeDistanceToTile(
            x,
            s,
            l,
            f,
            p,
            m,
            !1
          );
          x._distance = S;
          const E = h.screenSpaceError(x) < 2, b = x.z >= h._maxLevel;
          if (x.z >= h._minLevel && (E || b)) {
            c.push(x);
            continue;
          }
          const w = h._quadtree.getTileChildren(x);
          w.length > 0 && this._traverseViewportTiles(
            e,
            r,
            s,
            w,
            c,
            l
          );
        }
      }
    });
    this._restrictViewportLevel = defaultValue$1(e.restrictViewportLevel, !0);
  }
  beginFrame() {
    super.beginFrame();
  }
  initDebugMeshes() {
    if (!this.mesh) {
      const e = new SphereGeometry(1, 32, 32), r = new MeshBasicMaterial({
        color: new Color(16711680),
        transparent: !0,
        opacity: 0.9
      });
      (this.mesh = new Mesh(e, r)).scale.set(50, 50, 50);
      const a = new MeshBasicMaterial({
        color: new Color(255),
        transparent: !0,
        opacity: 0.9
      }), c = new MeshBasicMaterial({
        color: new Color(65280),
        transparent: !0,
        opacity: 0.9
      }), l = this.mesh1 = new Mesh(e, a), h = this.mesh2 = new Mesh(e, c);
      l.scale.set(50, 50, 50), h.scale.set(50, 50, 50);
    }
  }
  getViewportBounds(e) {
    const r = [], s = e.map.getPitch();
    let a = this.getNdcYFactor(s);
    return _leftBottomPosition = e.rendering.picking.pickSeaLevelWorldPositionFromNdc(_leftBottomPixel), _rightBottomPosition = e.rendering.picking.pickSeaLevelWorldPositionFromNdc(_rightBottomPixel), _tempVector2$2.set(-1, a), _leftTopPosition = e.rendering.picking.pickSeaLevelWorldPositionFromNdc(_tempVector2$2), _tempVector2$2.set(1, a), _rightTopPosition = e.rendering.picking.pickSeaLevelWorldPositionFromNdc(_tempVector2$2), _leftBottomPosition && _rightBottomPosition && _leftTopPosition && _rightTopPosition ? (this._showDebug && (this.mesh1.position.copy(_leftTopPosition), this.mesh2.position.copy(_rightTopPosition), this.mesh.scale.setScalar(e.map.getCameraDistance() / 100), this.mesh1.scale.setScalar(e.map.getCameraDistance() / 100), this.mesh2.scale.setScalar(e.map.getCameraDistance() / 100)), r[0] = Math.min(_leftBottomPosition.x, _rightBottomPosition.x, _leftTopPosition.x, _rightTopPosition.x), r[1] = Math.min(_leftBottomPosition.y, _rightBottomPosition.y, _leftTopPosition.y, _rightTopPosition.y), r[2] = Math.min(_leftBottomPosition.z, _rightBottomPosition.z, _leftTopPosition.z, _rightTopPosition.z), r[3] = Math.max(_leftBottomPosition.x, _rightBottomPosition.x, _leftTopPosition.x, _rightTopPosition.x), r[4] = Math.max(_leftBottomPosition.y, _rightBottomPosition.y, _leftTopPosition.y, _rightTopPosition.y), r[5] = Math.max(_leftBottomPosition.z, _rightBottomPosition.z, _leftTopPosition.z, _rightTopPosition.z), new Box3(new Vector3$1(r[0], r[1], r[2]), new Vector3$1(r[3], r[4], r[5]))) : null;
  }
  getNdcYFactor(e, r = 30, s = 0.3) {
    if (e < r)
      return 1;
    const a = (e - r) / (90 - r), c = 1 - Math.tan(a * Math.PI / 2) * s;
    return Math.max(-0.2, Math.min(c, 1));
  }
  computeTiles(e, r, s, a) {
    const c = this.surface, l = [], h = [], d = [], f = [], p = this._viewportTilesMap;
    p.clear();
    const m = e.map.getProjectionCenter();
    _positionScratch.set(m[0], m[1], m[2]), this._showDebug && this.mesh.position.copy(_positionScratch);
    let y = 0;
    if (this._restrictViewportLevel) {
      let x = this.getViewportBounds(e), v = e.map.getViewHeight() > 1e6;
      if (!x && v && (x = e.map.projection.projectedBoundingBox), this._traverseViewportTiles(
        x,
        s,
        r,
        c._quadtree.root,
        f,
        a
      ), y = this.calcViewportWeightedZLevel(f, p), v && c.tileProvider.isBaiduProvider) {
        let w = e.map.projection.geoBoxToProjectedBox(_chinaGeoBBox3);
        f.forEach((M) => {
          if (!M.inStrictBounds) {
            let P = !1;
            e.map.isGlobe ? M.boundingRegion && M.boundingRegion.boundingVolume && (P = boxIntersectsBox(
              w,
              M.boundingRegion.boundingVolume
            )) : P = boxIntersectsBox(w, M.targetBoundingBox), M.inStrictBounds = P;
          }
        });
      }
      const S = 0.5;
      let E = defaultValue$1(this._hysteresis, S);
      Math.abs(y - this._lastViewportZLevel) > E ? this._lastViewportZLevel = y : y = this._lastViewportZLevel, y = Math.round(y);
      let b;
      for (let w = 0; w < f.length; w++)
        b = f[w], b.z < y && b.inStrictBounds ? b._shouldSplit = !0 : b.z === y - 1 && (b._shouldSplitOnce = !0);
    }
    for (const x of c._quadtree.root)
      this._computeIntersectTiles(
        s,
        r,
        x,
        h,
        l,
        d,
        y,
        a
      );
    return this._logLoadInCurrentFrame, this._renderedTiles = h, this._renderedTilesMap = new Map(
      h.map((x) => [x.dataTile.key, x.dataTile])
    ), {
      selectedTiles: h,
      requestTilesQueue: [[], l],
      placeholderTiles: d
    };
  }
  calcViewportWeightedZLevel(e, r) {
    const s = this.surface, a = [];
    let c = 0;
    s.engine.map.isGlobe;
    let l;
    for (let d = 0; d < e.length; d++) {
      l = e[d];
      const f = s.projectBoundingBoxToNdc(l), p = s.reverseScreenSpaceErrorZ(l), m = this.clipPolygonToViewport(f);
      if (!m || m.length < 3)
        continue;
      let y = this.getPolygonArea(m);
      a.push(y), r.set(l, { z: p, area: y });
    }
    const h = a.reduce((d, f) => d + f, 0);
    return h <= 0 || (r.values().forEach((d) => {
      const f = d.area / h;
      d.areaProportion = f, d.ratio = f * d.z;
    }), c = r.values().reduce((d, f) => d + f.ratio, 0)), c;
  }
  _computeIntersectTiles(e, r, s, a, c, l, h, d) {
    const f = this.surface, p = f.engine, m = f._currentStatistics;
    m.visited += 1, this._logLoadInCurrentFrame;
    const y = new MapTileRenderState(), { mode: x, mapProjection: v, _ellipsoid: S } = p.map.map;
    if (x === SceneMode$1.SCENE3D && f.updateTileBoundingRegion(s, d), !f._computeTileVisibility(e, s))
      return this._logLoadInCurrentFrame, y;
    y.setInFrustum(), this._surfaceTileManager.markTileUsed(s), m.used++;
    let E = f.computeDistanceToTile(s, r, d, x, v, S, !1);
    s._distance = E;
    const b = this._surfaceTileManager.isTileRenderable(s, d);
    let w = f.screenSpaceError(s) < 2 && !s._shouldSplit && !s._shouldSplitOnce, M = s.z >= f._maxLevel || s.z >= h && h > 0;
    if (s.z >= f._minLevel && (M || w)) {
      const L = this._surfaceTileManager.getSurfaceTile(s, d);
      if (b)
        return this._logLoadInCurrentFrame, this._pushSelectedTile(a, L, !s.overMeetSse), delete s.overMeetSse, m.rendered += 1, y.setRendered(), y.setRenderReady(), y;
      this._logLoadInCurrentFrame, c.push(s), l.push(s), m.request += 1, y.setNotReady();
      const O = this._preserveLastFrameChildrenTiles(s, a, d);
      return O > 0 && (this._logLoadInCurrentFrame, m.rendered += O, y.setForceKeep(), y.setRenderReady()), y;
    }
    const P = f._quadtree.getTileChildren(s);
    if (s.z === f._minLevel - 1 && w)
      for (const L of P)
        L.overMeetSse = !0;
    if (delete s._shouldSplitOnce, s._shouldSplit) {
      delete s._shouldSplit;
      for (const L of P)
        L.z < h ? L._shouldSplit = !0 : delete L._shouldSplit;
    }
    s.childrenInFrustum = [];
    let D = !0;
    for (const L of P) {
      L.parent = s;
      let O = this._computeIntersectTiles(
        e,
        r,
        L,
        a,
        c,
        l,
        h,
        d
      );
      !O.isInFrustum() || (s.childrenInFrustum.push(L), O.isForceKeep() && y.setForceKeep(), O.isRenderReady() ? y.setRenderReady() : D = !1, O.isRendered());
    }
    if (y.isForceKeep())
      return y;
    if (!D) {
      let L = !1;
      if (this._isTileRenderedInLastFrame(s) ? (L = !0, b && (this._logLoadInCurrentFrame, this._pushSelectedTile(a, this._surfaceTileManager.getSurfaceTile(s, d), !1), m.rendered += 1, y.setRenderReady(), y.setRendered())) : this._isTileAncestorRenderedInLastFrame(s) && (L = !0, y.clearRenderReady()), L) {
        const O = this._hideChildrenTiles(a, l, s);
        m.rendered -= O;
      }
    }
    return y;
  }
  clipPolygonToViewport(e) {
    if (!e || e.length < 3)
      return null;
    const r = [
      { x: -1, y: 0, isVertical: !0 },
      { x: 1, y: 0, isVertical: !0 },
      { x: 0, y: -1, isVertical: !1 },
      { x: 0, y: 1, isVertical: !1 }
    ];
    let s = e.slice();
    for (let a = 0; a < r.length; a++) {
      const c = r[a], l = s;
      if (s = [], l.length === 0)
        return null;
      for (let h = 0; h < l.length; h++) {
        const d = l[h], f = l[(h + 1) % l.length], p = this._isInsideEdge(d, c), m = this._isInsideEdge(f, c);
        if (p && m)
          s.push(f);
        else if (p && !m) {
          const y = this._computeIntersection(d, f, c);
          y && s.push(y);
        } else if (!p && m) {
          const y = this._computeIntersection(d, f, c);
          y && s.push(y), s.push(f);
        }
      }
    }
    return s.length >= 3 ? s : null;
  }
  _isInsideEdge(e, r) {
    const [s, a] = e;
    return r.isVertical ? r.x < 0 ? s >= r.x : s <= r.x : r.y < 0 ? a >= r.y : a <= r.y;
  }
  _computeIntersection(e, r, s) {
    const [a, c] = e, [l, h] = r;
    if (s.isVertical) {
      if (Math.abs(l - a) < 1e-10)
        return null;
      const f = (s.x - a) / (l - a);
      return f < 0 || f > 1 ? null : [s.x, c + f * (h - c)];
    }
    if (Math.abs(h - c) < 1e-10)
      return null;
    const d = (s.y - c) / (h - c);
    return d < 0 || d > 1 ? null : [a + d * (l - a), s.y];
  }
  getPolygonArea(e) {
    let r = 0;
    const s = e.length;
    for (let a = 0; a < s; a++) {
      const [c, l] = e[a], [h, d] = e[(a + 1) % s];
      r += c * d - h * l;
    }
    return Math.abs(r) / 2;
  }
  set showDebug(e) {
    if (!this.surface.engine)
      return;
    const r = this.surface.engine;
    this.initDebugMeshes(), e ? (r.add(this.mesh1), r.add(this.mesh2), r.add(this.mesh)) : (r.remove(this.mesh1), r.remove(this.mesh2), r.remove(this.mesh)), this._showDebug = e;
  }
  get showDebug() {
    return this._showDebug;
  }
  set restrictViewportLevel(e) {
    this._restrictViewportLevel = e;
  }
  get restrictViewportLevel() {
    return this._restrictViewportLevel;
  }
}
class HierarchicalTileLoaderStrategy extends Strategy {
  constructor() {
    super(...arguments);
    _(this, "isHierarchicalTileLoaderStrategy", !0);
    _(this, "_computeHierarchicalIntersectTiles", (e, r, s, a, c, l, h, d, f) => {
      const p = this.surface, m = p.engine, y = p._currentStatistics;
      y.visited += 1, this._logLoadInCurrentFrame;
      const { mode: x, mapProjection: v, _ellipsoid: S } = m.map.map;
      let E = p.computeDistanceToTile(
        s,
        e,
        f,
        x,
        v,
        S
      );
      if (s._distance = E, !this._surfaceTileManager.isTileComputable(s, f))
        return this._logLoadInCurrentFrame, d.push(s), !1;
      const w = this._surfaceTileManager.isTileRenderable(s, f), M = this._surfaceTileManager.isTileStable(s, f);
      if (!w)
        return this._logLoadInCurrentFrame, c.push(s), !1;
      y.used += 1, this._surfaceTileManager.markTileUsed(s);
      let P = p.screenSpaceError(s) < 2;
      if (s.z >= p._minLevel && (P || s.z >= p._maxLevel)) {
        M || (c.push(s), y.request += 1, this._logLoadInCurrentFrame);
        const F = this._surfaceTileManager.getSurfaceTile(s, f);
        return a.push(F), this._logLoadInCurrentFrame, y.rendered += 1, !0;
      }
      M || (this._logLoadInCurrentFrame, h.push(s));
      const D = p._quadtree.getTileChildren(s);
      if (!D || D.length === 0) {
        const F = this._surfaceTileManager.getSurfaceTile(s, f);
        return a.push(F), this._logLoadInCurrentFrame, y.rendered += 1, !0;
      }
      let L = !0;
      const O = [];
      for (const F of D) {
        if (x === SceneMode$1.SCENE3D && p.updateTileBoundingRegion(F, f), !p._computeTileVisibility(r, F)) {
          if (this._logLoadInCurrentFrame, !this._loadSiblings)
            continue;
          this._surfaceTileManager.markTileUsed(F), y.used++, this._surfaceTileManager.isTileComputable(F, f) || (l.push(F), this._logLoadInCurrentFrame);
          continue;
        }
        this._surfaceTileManager.isTileComputable(F, f) || (L = !1, this._logLoadInCurrentFrame), this._logLoadInCurrentFrame, O.push(F), this._surfaceTileManager.markTileUsed(F);
      }
      if (L) {
        for (const F of O)
          this._computeHierarchicalIntersectTiles(
            e,
            r,
            F,
            a,
            c,
            l,
            h,
            d,
            f
          );
        this._logLoadInCurrentFrame;
      } else {
        this._logLoadInCurrentFrame;
        let F;
        x === SceneMode$1.SCENE3D ? F = m.map.map._ellipsoidCamera.positionCartographic : F = m.map.unprojectArrayCoordinate(m.camera.position.toArray());
        let k = D;
        D.length === 4 && (k = p._naturalOrderChildTiles(D, F)), this._logLoadInCurrentFrame, k = k.filter((N) => O.includes(N)), k.forEach((N) => {
          this._surfaceTileManager.isTileComputable(N, f) || (this._logLoadInCurrentFrame, d.push(N), y.visited += 1, y.request += 1, this._logLoadInCurrentFrame);
        });
        const V = this._surfaceTileManager.getSurfaceTile(s, f);
        a.push(V), y.rendered += 1, y.unstable += 1, this._logLoadInCurrentFrame;
      }
      return !0;
    });
  }
  computeTiles(e, r, s, a) {
    const c = this.surface, l = [], h = [], d = [], f = [], p = [];
    for (const m of c._quadtree.root)
      this._surfaceTileManager.isTileRenderable(m, a) ? this._computeHierarchicalIntersectTiles(
        r,
        s,
        m,
        l,
        d,
        p,
        f,
        h,
        a
      ) : d.push(m);
    return this._logLoadInCurrentFrame, {
      selectedTiles: l,
      requestTilesQueue: [h, d, f, p],
      placeholderTiles: []
    };
  }
}
const vertexShader$o = `#define GLSLIFY 1
#include <common>
#include <logdepthbuf_pars_vertex>

varying vec2 vUv;
#if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)
attribute float layerIndex;
varying float vLayerIndex;
#endif

void main() {

	vUv = uv;

    #include <begin_vertex>
    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);

    #if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)
        vLayerIndex = layerIndex;
    #endif

    vec4 mvPosition = viewMatrix * worldPosition;
    gl_Position = projectionMatrix * mvPosition;

    #include <logdepthbuf_vertex>
}

`, fragmentShader$m = `#define GLSLIFY 1
#include <common>
#include <packing>

varying vec2 vUv;
uniform vec3 color;
uniform vec3 borderColor;
uniform sampler2D map;

#include <logdepthbuf_pars_fragment>
#include <mvt_depth_range_pars_fragment>

void main() {

    vec4 diffuseColor = vec4(color, 1.0);
    vec4 diffuseMap = texture2D(map, vUv);
    if (diffuseMap.a > 0.1) {
        diffuseMap.rgb = borderColor;
    }

    gl_FragColor.rgb = mix(diffuseColor, diffuseMap, diffuseMap.a).rgb;
    gl_FragColor.a = 1.0;

    // if (gl_FragColor.a <= 0.) {
    //     discard;
    // }

    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
    #include <mvt_depth_range_fragment>
}

`, uniforms$n = UniformsUtils.merge([
  {
    color: { value: [0.95, 0.95, 0.95] },
    borderColor: { value: [0.5, 0.5, 0.5] },
    vertexZIndexLegacy: { value: !1 },
    isEmissive: { value: !1 },
    depthRange: { value: new Vector2$1(0, 1) },
    map: { value: null }
  }
]);
class PlaceholderMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "PlaceholderMaterial", this.type = "PlaceholderMaterial", this.isPlaceholderMaterial = !0, this.transparent = !1, this.fragmentShader = fragmentShader$m, this.vertexShader = vertexShader$o, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$n)), defineMaterialNormalProperties(this, [
      "isEmissive",
      "map",
      "depthRange"
    ]), defineMaterialColorProperties(this, [
      "color",
      "borderColor"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexZIndexLegacy", "MVT_USE_VERTEX_ZINDEX_LEGACY"],
      ["enableDepthRange", "MVT_USE_DEPTH_RANGE"]
    ]), this.setValues(i);
  }
}
const scratchCartographic$1 = new Vector3$1(), scratchCartesian$1 = new Vector3$1(), scratchProjectPointOntoPlaneRay = new Ray(), scratchProjectPointOntoPlaneRayDirection = new Vector3$1(), scratchProjectPointOntoPlaneCartesian3 = new Vector3$1(), be = class {
  constructor(i, e) {
    this.position = i, this.position || (i = new Vector2$1()), this.tangentPlane = e, this.tangentPlane || (this.tangentPlane = be.NORTH_POLE_TANGENT_PLANE);
  }
  getLatitude(i) {
    i || (i = Ellipsoid.WGS84), scratchCartographic$1.x = this.longitude, scratchCartographic$1.y = this.conformalLatitude, scratchCartographic$1.z = 0;
    const e = this.ellipsoid.cartographicToCartesian(
      scratchCartographic$1,
      scratchCartesian$1
    );
    return i.cartesianToCartographic(e, scratchCartographic$1), scratchCartographic$1.y;
  }
  static fromCartesian(i, e) {
    const r = i.z < 0 ? -1 : 1;
    let s = be.NORTH_POLE_TANGENT_PLANE, a = be.SOUTH_POLE;
    r < 0 && (s = be.SOUTH_POLE_TANGENT_PLANE, a = be.NORTH_POLE);
    const c = scratchProjectPointOntoPlaneRay;
    c.origin = s.ellipsoid.scaleToGeocentricSurface(
      i,
      c.origin
    ), c.direction = Cartesian3.subtract(
      c.origin,
      a,
      scratchProjectPointOntoPlaneRayDirection
    ), Cartesian3.normalize(c.direction, c.direction);
    const l = IntersectionTests.rayPlane(
      c,
      s.plane,
      scratchProjectPointOntoPlaneCartesian3
    ), h = Cartesian3.subtract(l, a, l), d = Cartesian3.dot(s.xAxis, h), f = r * Cartesian3.dot(s.yAxis, h);
    return e ? (e.position = new Vector2$1(d, f), e.tangentPlane = s, e) : new be(new Vector2$1(d, f), s);
  }
  clone(i) {
    return be.clone(this, i);
  }
  static clone(i, e) {
    if (!!i)
      return e ? (e.position = i.position, e.tangentPlane = i.tangentPlane, e) : new be(
        i.position,
        i.tangentPlane
      );
  }
  get ellipsoid() {
    return this.tangentPlane.ellipsoid;
  }
  get x() {
    return this.position.x;
  }
  get y() {
    return this.position.y;
  }
  get conformalLatitude() {
    const i = this.position.length(), e = 2 * this.ellipsoid.maximumRadius;
    return this.tangentPlane.plane.normal.z * (CesiumMath.PI_OVER_TWO - 2 * Math.atan2(i, e));
  }
  get longitude() {
    let i = CesiumMath.PI_OVER_TWO + Math.atan2(this.y, this.x);
    return i > Math.PI && (i -= CesiumMath.TWO_PI), i;
  }
};
let Stereographic = be;
_(Stereographic, "HALF_UNIT_SPHERE", Object.freeze(new Ellipsoid(0.5, 0.5, 0.5))), _(Stereographic, "NORTH_POLE", Object.freeze(new Vector3$1(0, 0, 0.5))), _(Stereographic, "SOUTH_POLE", Object.freeze(new Vector3$1(0, 0, -0.5))), _(Stereographic, "NORTH_POLE_TANGENT_PLANE", Object.freeze(new EllipsoidTangentPlane(be.NORTH_POLE, be.HALF_UNIT_SPHERE))), _(Stereographic, "SOUTH_POLE_TANGENT_PLANE", Object.freeze(new EllipsoidTangentPlane(be.SOUTH_POLE, be.HALF_UNIT_SPHERE)));
const scratchPolar = new Stereographic(), scratchPolarPrevious = new Stereographic(), polygon = {
  northAngle: 0,
  southAngle: 0,
  westOverIdl: 0,
  eastOverIdl: 0
}, scratchCartesian0 = new Vector2$1(), scratchCartesian1 = new Vector2$1(), scratchPolarClosest = new Stereographic();
new Vector2$1();
const expandRectangle = (o, i, e, r, s) => {
  const a = o.longitude, c = a >= 0 ? a : a + CesiumMath.TWO_PI;
  r.westOverIdl = Math.min(r.westOverIdl, c), r.eastOverIdl = Math.max(r.eastOverIdl, c), s.west = Math.min(s.west, a), s.east = Math.max(s.east, a);
  const l = o.getLatitude(e);
  let h = l;
  s.south = Math.min(s.south, l), s.north = Math.max(s.north, l);
  const d = Cartesian2.subtract(
    i.position,
    o.position,
    scratchCartesian0
  ), f = Cartesian2.dot(i.position, d) / Cartesian2.dot(d, d);
  if (f > 0 && f < 1) {
    const y = Cartesian2.add(
      i.position,
      Cartesian2.multiplyByScalar(d, -f, d),
      scratchCartesian1
    ), x = Stereographic.clone(i, scratchPolarClosest);
    x.position = y;
    const v = x.getLatitude(e);
    s.south = Math.min(s.south, v), s.north = Math.max(s.north, v), Math.abs(l) > Math.abs(v) && (h = v);
  }
  const p = i.x * o.y - o.x * i.y;
  let m = Math.sign(p);
  m !== 0 && (m *= Cartesian2.angleBetween(i.position, o.position)), h >= 0 && (r.northAngle += m), h <= 0 && (r.southAngle += m);
}, computeRectangleFromPositions = (o, i, e) => {
  if (e || (e = new Rectangle()), o.length < 3)
    return e;
  e.west = Number.POSITIVE_INFINITY, e.east = Number.NEGATIVE_INFINITY, e.south = Number.POSITIVE_INFINITY, e.north = Number.NEGATIVE_INFINITY, polygon.northAngle = 0, polygon.southAngle = 0, polygon.westOverIdl = Number.POSITIVE_INFINITY, polygon.eastOverIdl = Number.NEGATIVE_INFINITY;
  const r = o.length;
  let s = Stereographic.fromCartesian(
    new Vector3$1(...o[0]),
    scratchPolarPrevious
  );
  for (let a = 1; a < r; a++) {
    const c = Stereographic.fromCartesian(
      new Vector3$1(...o[a]),
      scratchPolar
    );
    expandRectangle(
      c,
      s,
      i,
      polygon,
      e
    ), s = Stereographic.clone(c, s);
  }
  return expandRectangle(
    Stereographic.fromCartesian(
      new Vector3$1(...o[0]),
      scratchPolar
    ),
    s,
    i,
    polygon,
    e
  ), e.east - e.west > polygon.eastOverIdl - polygon.westOverIdl && (e.west = polygon.westOverIdl, e.east = polygon.eastOverIdl, e.east > CesiumMath.PI && (e.east = e.east - CesiumMath.TWO_PI), e.west < CesiumMath.PI && (e.west = e.west + CesiumMath.TWO_PI)), CesiumMath.equalsEpsilon(
    Math.abs(polygon.northAngle),
    CesiumMath.TWO_PI,
    CesiumMath.EPSILON10
  ) && (e.north = CesiumMath.PI_OVER_TWO, e.east = CesiumMath.PI, e.west = -CesiumMath.PI), CesiumMath.equalsEpsilon(
    Math.abs(polygon.southAngle),
    CesiumMath.TWO_PI,
    CesiumMath.EPSILON10
  ) && (e.south = -CesiumMath.PI_OVER_TWO, e.east = CesiumMath.PI, e.west = -CesiumMath.PI), e;
}, createTangentPlane = (o, i) => {
  let e = o[0][0], r = o[0][1], s = o[0][2], a = o[0][0], c = o[0][1], l = o[0][2];
  const h = o.length;
  for (let p = 0; p < h; p++) {
    const m = o[p], y = m[0], x = m[1], v = m[2];
    e = Math.min(y, e), r = Math.min(x, r), s = Math.min(v, s), a = Math.max(y, a), c = Math.max(x, c), l = Math.max(v, l);
  }
  const d = new Vector3$1(
    (e + a) / 2,
    (r + c) / 2,
    (s + l) / 2
  );
  return new EllipsoidTangentPlane(d, i);
}, createProjectTo2D = (o, i, e) => {
  if (o.height >= CesiumMath.PI || o.width >= CesiumMath.PI)
    return;
  const r = i.map((a) => new Vector3$1(...a));
  return createTangentPlane(i, e).projectPointsOntoPlane(r);
};
function sortPolygonPoints(o) {
  if (o.length < 3)
    throw new Error("\u70B9\u7684\u6570\u91CF\u5FC5\u987B\u5927\u4E8E\u7B49\u4E8E3\u4E2A\u624D\u80FD\u5F62\u6210\u591A\u8FB9\u5F62");
  const i = calculateCentroid(o), e = o.map((r, s) => {
    const a = Math.atan2(r.y - i.y, r.x - i.x);
    return { index: s, angle: a };
  });
  return e.sort((r, s) => r.angle - s.angle), e.map((r) => r.index);
}
function calculateCentroid(o, i) {
  i || (i = new Vector2$1());
  const e = o.length;
  let r = 0, s = 0;
  return o.forEach((a) => {
    r += a.x, s += a.y;
  }), i.set(r / e, s / e);
}
function getLineIntersection(o, i, e, r, s, a) {
  const c = o.x, l = o.y, h = i.x, d = i.y, f = e.x, p = e.y, m = r.x, y = r.y, x = (c - h) * (p - y) - (l - d) * (f - m);
  if (Math.abs(x) < 1e-4)
    return null;
  const v = ((c - f) * (p - y) - (l - p) * (f - m)) / x, S = -((c - h) * (l - p) - (l - d) * (c - f)) / x;
  return v >= 0 && v <= 1 && S >= 0 && S <= 1 ? {
    point: o.clone().lerp(i, v),
    uv: s.clone().lerp(a, v)
  } : null;
}
function isPointInTriangle(o, i, e, r) {
  const s = e.x - i.x, a = e.y - i.y, c = r.x - i.x, l = r.y - i.y, h = o.x - i.x, d = o.y - i.y, f = s * l - a * c, p = (h * l - d * c) / f, m = (s * d - a * h) / f;
  return p >= 0 && m >= 0 && p + m <= 1;
}
function isPointInRectangle(o, i, e, r, s) {
  return o.x >= i && o.x <= e && o.y >= r && o.y <= s;
}
function getRectanglePoints(o, i, e, r) {
  return [
    new Vector3$1(o, e, 0),
    new Vector3$1(i, e, 0),
    new Vector3$1(i, r, 0),
    new Vector3$1(o, r, 0)
  ];
}
function getRectangleEdges(o) {
  return [
    [o[0], o[1]],
    [o[1], o[2]],
    [o[2], o[3]],
    [o[3], o[0]]
  ];
}
function calculateIntersection(o, i, e) {
  const r = [];
  o.forEach((b, w) => {
    if (isPointInRectangle(
      b,
      e[0].x,
      e[2].x,
      e[0].y,
      e[2].y
    )) {
      const P = b.x + "," + b.y + "," + b.z;
      r[P] || (r[P] = {
        point: b,
        uv: i[w]
      });
    }
  });
  const s = Math.min(o[0].x, Math.min(o[1].x, o[2].x)), a = Math.max(o[0].x, Math.max(o[1].x, o[2].x)), c = Math.min(o[0].y, Math.min(o[1].y, o[2].y)), l = Math.max(o[0].y, Math.max(o[1].y, o[2].y)), h = Math.min(i[0].x, Math.min(i[1].x, i[2].x)), d = Math.max(i[0].x, Math.max(i[1].x, i[2].x)), f = Math.min(i[0].y, Math.min(i[1].y, i[2].y)), p = Math.max(i[0].y, Math.max(i[1].y, i[2].y)), m = a - s, y = l - c, x = d - h, v = p - f;
  e.forEach((b) => {
    if (isPointInTriangle(b, ...o)) {
      const M = b.x + "," + b.y + "," + b.z;
      if (!r[M]) {
        const P = h + x * (b.x - s) / m, D = f + v * (b.y - c) / y;
        r[M] = {
          point: b,
          uv: new Vector2$1(P, D)
        };
      }
    }
  });
  const S = [
    [0, 1],
    [1, 2],
    [2, 0]
  ], E = getRectangleEdges(e);
  return S.forEach(([b, w]) => {
    E.forEach(([M, P]) => {
      const D = o[b], L = o[w], O = i[b], F = i[w], k = getLineIntersection(D, L, M, P, O, F);
      if (k) {
        const { point: V } = k, N = V.x + "," + V.y + "," + V.z;
        r[N] || (r[N] = k);
      }
    });
  }), Object.values(r);
}
const subdivisionV0Scratch$1 = new Vector3$1(), subdivisionV1Scratch$1 = new Vector3$1(), subdivisionV2Scratch$1 = new Vector3$1();
new Vector3$1();
new Vector3$1();
new Vector3$1();
const subdivisionMidScratch$1 = new Vector3$1(), subdivisionT0Scratch$1 = new Vector2$1(), subdivisionT1Scratch$1 = new Vector2$1(), subdivisionT2Scratch$1 = new Vector2$1(), subdivideWithRange = (o, i, e, r, s, a, c, l, h) => {
  const d = [];
  for (let E = 0; E < o.length; E++) {
    const b = o[E];
    let w = `${b.x},${b.y},${b.z}`;
    h[w] = e[E], isPointInRectangle(b, l[0], l[1], l[0], l[1]) && d.push(E);
  }
  if (d.length === 3)
    return !1;
  const p = getRectanglePoints(l[0], l[1], l[0], l[1]), m = [o[0], o[1], o[2]], y = calculateIntersection(m, i, p), x = y.map((E) => E.point), v = y.map((E) => E.uv);
  if (x.length > 2) {
    const E = sortPolygonPoints(x), b = [];
    for (let w = 0, M = E.length; w < M; w++) {
      const P = E[w], D = x[P], L = v[P], O = `${D.x},${D.y},${D.z}`;
      defined$2(h[O]) || (s.push(D.x, D.y, D.z), r && a.push(L.x, L.y), h[O] = s.length / 3 - 1);
      const F = h[O];
      b.push(F);
    }
    x.length === 3 ? c.push(
      b[1],
      b[2],
      b[0]
    ) : x.length === 4 ? c.push(
      b[2],
      b[3],
      b[0],
      b[0],
      b[1],
      b[2]
    ) : x.length === 5 && c.push(
      b[3],
      b[4],
      b[0],
      b[0],
      b[1],
      b[2],
      b[2],
      b[3],
      b[0]
    );
  }
  return !0;
}, subdivideMesh = (o, i, e, r, s = 0, a = [-0.501, 0.501]) => {
  const c = !!e, l = Array.from(i);
  let h = 0;
  const d = o.length;
  let f = null, p = null;
  if (Array.isArray(o[0])) {
    f = [];
    let E = 0;
    for (h = 0; h < d; h++) {
      const b = o[h];
      f[E++] = b[0], f[E++] = b[1], f[E++] = b[2];
    }
  } else
    f = o.slice(0);
  if (c)
    if (Array.isArray(e[0])) {
      p = [];
      let b = 0;
      for (h = 0; h < e.length; h++) {
        const w = e[h];
        p[b++] = w[0], p[b++] = w[1];
      }
    } else
      p = e.slice(0);
  const y = [], x = {}, v = {}, S = r * r;
  for (; l.length > 0; ) {
    const E = l.pop(), b = l.pop(), w = l.pop(), M = subdivisionV0Scratch$1.fromArray(f, w * 3), P = subdivisionV1Scratch$1.fromArray(f, b * 3), D = subdivisionV2Scratch$1.fromArray(f, E * 3);
    let L, O, F;
    c && (L = subdivisionT0Scratch$1.fromArray(p, w * 2), O = subdivisionT1Scratch$1.fromArray(p, b * 2), F = subdivisionT2Scratch$1.fromArray(p, E * 2));
    const k = Cartesian3.magnitudeSquared(Cartesian3.subtract(M, P, subdivisionMidScratch$1)), V = Cartesian3.magnitudeSquared(Cartesian3.subtract(P, D, subdivisionMidScratch$1)), N = Cartesian3.magnitudeSquared(Cartesian3.subtract(D, M, subdivisionMidScratch$1)), U = Math.max(k, V, N);
    let z, $, G;
    if (U > S)
      k === U ? (z = `${Math.min(w, b)} ${Math.max(w, b)}`, h = x[z], h == null && ($ = Cartesian3.add(M, P, subdivisionMidScratch$1), Cartesian3.multiplyByScalar($, 0.5, $), f.push($.x, $.y, $.z), h = f.length / 3 - 1, x[z] = h, c && (G = Cartesian2.add(L, O, subdivisionMidScratch$1), Cartesian2.multiplyByScalar(G, 0.5, G), p.push(G.x, G.y))), l.push(w, h, E), l.push(h, b, E)) : V === U ? (z = `${Math.min(b, E)} ${Math.max(b, E)}`, h = x[z], h || ($ = Cartesian3.add(P, D, subdivisionMidScratch$1), Cartesian3.multiplyByScalar($, 0.5, $), f.push($.x, $.y, $.z), h = f.length / 3 - 1, x[z] = h, c && (G = Cartesian2.add(O, F, subdivisionMidScratch$1), Cartesian2.multiplyByScalar(G, 0.5, G), p.push(G.x, G.y))), l.push(b, h, w), l.push(h, E, w)) : N === U && (z = `${Math.min(E, w)} ${Math.max(E, w)}`, h = x[z], h || ($ = Cartesian3.add(D, M, subdivisionMidScratch$1), Cartesian3.multiplyByScalar($, 0.5, $), f.push($.x, $.y, $.z), h = f.length / 3 - 1, x[z] = h, c && (G = Cartesian2.add(F, L, subdivisionMidScratch$1), Cartesian2.multiplyByScalar(G, 0.5, G), p.push(G.x, G.y))), l.push(E, h, b), l.push(h, w, b));
    else {
      if (subdivideWithRange(
        [M, P, D],
        [L, O, F],
        [w, b, E],
        c,
        f,
        p,
        l,
        a,
        v
      ))
        continue;
      y.push(w + s), y.push(b + s), y.push(E + s);
    }
  }
  return {
    vertices: f,
    uvs: p,
    indices: y
  };
}, _pointIn = new Vector3$1(), _pointOut = new Vector3$1(), reprojectCoordinate = (o, i, e, r, s, a) => {
  let c = CoordTransformer.canTransform(o, i);
  return (e === r || !e || !r) && !c ? (a.copy(s), a) : (e.unprojectCoordinate(s, _pointOut), c ? CoordTransformer.transform(o, i, _pointOut, _pointIn) : _pointIn.copy(_pointOut), r.projectCoordinate(_pointIn, a), a);
}, projectVertices = (o, i, e = !0, r = !0, s = !1) => {
  if (!(i.forceProjectCoordinates || s) && i.targetProjectionName === i.sourceProjectionName)
    return;
  const a = i.sourceProjection, c = i.targetProjection, l = i.sourceCoordType, h = i.targetCoordType, [d, f, p] = i.targetCenter, m = i.forceUseGeoBoundingBox || a.isGeo, y = m ? i.geoBoundingBox : i.projectedBoundingBox;
  let x, v, S, E;
  if (y.isBox3) {
    const M = y.min, P = y.max;
    x = M.x, v = M.y, S = P.x, E = P.y;
  } else
    [x, v, , S, E] = y;
  const b = S - x, w = E - v;
  if (e)
    for (let M = 0, P = o.length - 2; M < P; M += 3) {
      const D = o[M], L = o[M + 1], O = o[M + 2];
      _pointIn.set(x + (D + 0.5) * b, v + (L + 0.5) * w, O), m ? (l !== h && CoordTransformer.transform(l, h, _pointIn, _pointIn), c.projectCoordinate(_pointIn, _pointOut)) : reprojectCoordinate(
        l,
        h,
        a,
        c,
        _pointIn,
        _pointOut
      ), o[M] = _pointOut.x, o[M + 1] = _pointOut.y, o[M + 2] = _pointOut.z, r && (o[M] -= d, o[M + 1] -= f, o[M + 2] -= p);
    }
  else
    for (let M = 0, P = o.length; M < P; M += 1) {
      const D = o[M], L = D[0], O = D[1], F = D[2];
      _pointIn.set(x + (L + 0.5) * b, v + (O + 0.5) * w, F), m ? (l !== h && CoordTransformer.transform(l, h, _pointIn, _pointIn), c.projectCoordinate(_pointIn, _pointOut)) : reprojectCoordinate(
        l,
        h,
        a,
        c,
        _pointIn,
        _pointOut
      ), D[0] = _pointOut.x, D[1] = _pointOut.y, D[2] = _pointOut.z, r && (D[0] -= d, D[1] -= f, D[2] -= p);
    }
}, subdivideVertices = (o, i, e, r) => {
  if (r.sourceProjectionName === r.targetProjectionName)
    return {
      vertices: o,
      indices: i,
      uvs: e
    };
  let a = 1 / Math.max(2, 16 - r.z);
  return subdivideMesh(o, i, e, a);
}, computeNormals = (o, i = 3, e = 0) => {
  const {
    vertices: r,
    indices: s
  } = o, a = r.length / i, c = new Array(a * 3).fill(0), l = new Array(a).fill(0);
  for (let h = 0; h < s.length; h += 3) {
    const d = s[h], f = s[h + 1], p = s[h + 2], m = r[d * i + e], y = r[d * i + e + 1], x = r[d * i + e + 2], v = r[f * i + e], S = r[f * i + e + 1], E = r[f * i + e + 2], b = r[p * i + e], w = r[p * i + e + 1], M = r[p * i + e + 2], P = v - m, D = S - y, L = E - x, O = b - m, F = w - y, k = M - x, V = D * k - L * F, N = L * O - P * k, U = P * F - D * O;
    c[d * 3] += V, c[d * 3 + 1] += N, c[d * 3 + 2] += U, l[d]++, c[f * 3] += V, c[f * 3 + 1] += N, c[f * 3 + 2] += U, l[f]++, c[p * 3] += V, c[p * 3 + 1] += N, c[p * 3 + 2] += U, l[p]++;
  }
  for (let h = 0; h < a; h++) {
    const d = l[h];
    if (d > 0) {
      let f = c[h * 3] / d, p = c[h * 3 + 1] / d, m = c[h * 3 + 2] / d;
      const y = Math.sqrt(f * f + p * p + m * m);
      if (y > 0) {
        const x = 1 / y;
        f *= x, p *= x, m *= x;
      } else
        f = 0, p = 0, m = 1;
      c[h * 3] = f, c[h * 3 + 1] = p, c[h * 3 + 2] = m;
    }
  }
  o.normals = c;
}, createGroundTileMesh = (o, i, e = !0) => {
  const r = [
    -0.5,
    -0.5,
    0,
    -0.5,
    0.5,
    0,
    0.5,
    0.5,
    0,
    0.5,
    -0.5,
    0
  ], s = [
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0
  ], a = [0, 2, 1, 0, 3, 2], {
    vertices: c,
    uvs: l,
    indices: h
  } = subdivideVertices(r, a, s, o);
  projectVertices(c, o);
  const d = {
    vertices: c,
    uvs: l,
    indices: h
  };
  if (i) {
    const f = c.length / 3;
    for (const p of Object.keys(i)) {
      const m = i[p], y = Array.isArray(m), x = y ? m.length : 1, v = [];
      if (y)
        for (let S = 0; S < f; S++)
          for (let E = 0; E < x; E++)
            v.push(m[E]);
      else
        for (let S = 0; S < f; S++)
          v.push(m);
      d[p] = v;
    }
  }
  return e && computeNormals(d), d;
}, textureLoader$7 = new TextureLoader();
let textureUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAUdJREFUeNrs2sENwyAQRcE4ckf0RBv04Z7ck30wFXBi/4wU5bScXhQk9hhj9B+xzu/7WjijvZ/b/Jbz/e83kE0AAkAACAABIAAEgAAQAAJAAAgAAVDYfA5ui+eY33R+BuA9PXO++QtwB0AACAABIAAEgAAQAAJAAAgAASAAqrIPED5vH8A+AO4ACAABIAAEgAAQAAJAAAgAASAABEBJ9gHC5+0D2AfAHQABIAAEgAAQAAJAAAgAASAABIAAKMk+QPi8fQD7ALgDIAAEgAAQAAJAAAgAASAABIAAEAAl2QcIn7cPYB8AdwAEgAAQAAJAAAgAASAABIAAEAACoCT7AOHz9gHsA+AOgAAQAAJAAAgAASAABIAAEAACQACUZB8gfN4+gH0A3AEQAAJAAAgAASAABIAAEAACQABUNV8D++I5nmM3nX8EGADa0U/2xPbBVwAAAABJRU5ErkJggg==", texture$1 = null;
class Placeholder {
  constructor(i = {}, e) {
    _(this, "_maxCacheSize", 1e3);
    _(this, "handleRemove", (i, e) => {
      i.geometry.dispose();
    });
    if (this._cache = new LRUCache$1({
      max: this._maxCacheSize,
      onRemove: this.handleRemove
    }), !texture$1) {
      const r = defaultValue$1(i.backgroundColor, defaultValue$1(e, 16382457)), s = defaultValue$1(i.borderColor, 13224393);
      texture$1 = textureLoader$7.load(textureUrl);
      let a;
      r instanceof Color ? a = new Color(r.r, r.g, r.b) : a = new Color(r), this._material = new PlaceholderMaterial({
        color: a,
        borderColor: new Color(s),
        map: texture$1,
        enableDepthRange: !0,
        depthRange: new Vector2$1(1, 1)
      });
    }
  }
  createMesh(i) {
    let e = null;
    const r = i.grid.targetProjection;
    if (r.isAxisAligned)
      return this._geometry || (this._geometry = new PlaneGeometry(1, 1)), e = new Mesh(this._geometry, this._material), e.position.copy(i.targetCenter), i.targetBoundingBox.getSize(e.scale), e;
    const s = {
      x: i.x,
      y: i.y,
      z: i.z,
      targetProjection: r,
      sourceProjection: i.grid.sourceProjection,
      targetProjectionName: r.name,
      sourceProjectionName: i.grid.sourceProjection.name,
      targetCenter: i.targetCenter.toArray(),
      geoBoundingBox: i.availableGeoBoundingBox,
      forceUseGeoBoundingBox: !0,
      forceProjectCoordinates: !0,
      projectedBoundingBox: i.projectedBoundingBox.isBox3 ? i.projectedBoundingBox : []
    }, a = createGroundTileMesh(s, {
      layerIndices: 0
    }), c = new BufferGeometry();
    return c.setIndex(a.indices), c.setAttribute("position", new BufferAttribute(new Float32Array(a.vertices), 3)), c.setAttribute("layerIndex", new BufferAttribute(new Float32Array(a.layerIndices), 1)), c.setAttribute("uv", new BufferAttribute(new Float32Array(a.uvs), 2)), e = new Mesh(c, this._material), e.position.copy(i.targetCenter), e;
  }
  get(i) {
    let e = this._cache.get(i.key);
    return e || (e = this.createMesh(i), this._cache.set(i.key, e), e);
  }
  clear() {
    this._cache.clear();
  }
  get maxCacheSize() {
    return this._maxCacheSize;
  }
  set maxCacheSize(i) {
    this._maxCacheSize = i;
  }
  get backgroundColor() {
    return this._material.color;
  }
  set backgroundColor(i) {
    i instanceof Color ? this._material.color.copy(i) : this._material.color.set(i);
  }
  get borderColor() {
    return this._material.borderColor;
  }
  set borderColor(i) {
    i instanceof Color ? this._material.borderColor.copy(i) : this._material.borderColor.set(i);
  }
}
const TILELOADER_STRATEGY_FAST = "fast", TILELOADER_STRATEGY_HIERARCHICAL = "hierarchical", MAP_GRID_NAME_GEO = "geo", MAP_GRID_NAME_WEB_MERCATOR = "web_mercator", MAP_GRID_NAME_BD_VECTOR_ONLINE = "bd_vector_online", MAP_GRID_NAME_BD_VECTOR_OFFLINE = "bd_vector_offline", MAP_GRID_NAME_BD_LANE_VECTOR = "bd_lane_vector", BING_MAP_STYLE_AERIAL = "Aerial", BING_MAP_STYLE_AERIAL_WITH_LABELS = "AerialWithLabels", BING_MAP_STYLE_ROAD = "Road", STADIA_MAP_STYLE_STAMEN_WATERCOLOR = "StamenWatercolor", STADIA_MAP_STYLE_STAMEN_TONER = "StamenToner", STADIA_MAP_STYLE_ALIDE_SMOOTH = "AlidadeSmooth", STADIA_MAP_STYLE_ALIDE_SMOOTH_DARK = "AlidadeSmoothDark", STADIA_MAP_STYLE_OUTDOORS = "Outdoors", constants = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TILELOADER_STRATEGY_FAST,
  TILELOADER_STRATEGY_HIERARCHICAL,
  MAP_GRID_NAME_GEO,
  MAP_GRID_NAME_WEB_MERCATOR,
  MAP_GRID_NAME_BD_VECTOR_ONLINE,
  MAP_GRID_NAME_BD_VECTOR_OFFLINE,
  MAP_GRID_NAME_BD_LANE_VECTOR,
  BING_MAP_STYLE_AERIAL,
  BING_MAP_STYLE_AERIAL_WITH_LABELS,
  BING_MAP_STYLE_ROAD,
  STADIA_MAP_STYLE_STAMEN_WATERCOLOR,
  STADIA_MAP_STYLE_STAMEN_TONER,
  STADIA_MAP_STYLE_ALIDE_SMOOTH,
  STADIA_MAP_STYLE_ALIDE_SMOOTH_DARK,
  STADIA_MAP_STYLE_OUTDOORS
}, Symbol.toStringTag, { value: "Module" })), scratchPlane = new Plane(new Vector3$1(1, 0, 0), 0), cornerPositionsScratch = [
  new Vector3$1(),
  new Vector3$1(),
  new Vector3$1(),
  new Vector3$1()
], vertexScratch = new Vector4(), directionScratch$1 = new Vector3$1(), fixedTransformScratch = new Matrix4(), projectionMatrixScratch = new Matrix4(), viewMatrixScratch = new Matrix4(), mvpMatrixScratch = new Matrix4();
let globalId = 0;
class MapSurface extends Object3D {
  constructor(e = {}) {
    super(e);
    _(this, "name", "MapSurface");
    _(this, "_lodScaleFactor", 1);
    _(this, "_sseFactor", 0.8);
    _(this, "_minLevel", 0);
    _(this, "_maxLevel", 21);
    _(this, "_surfaceTileManager", null);
    _(this, "_showTileBoundingBox", !1);
    _(this, "_showTileDebugLabel", !1);
    _(this, "_debugLabelIds", {});
    _(this, "_placeholderMeshesLastFrame", []);
    _(this, "_freezeUpdate", !1);
    _(this, "_maxRequestTilesPerFrame", 20);
    _(this, "_enableHorizonCulling", !0);
    _(this, "_selectedTilesMapLastFrame", {});
    _(this, "_selectedTilesLastFrame", []);
    _(this, "_showGroundWireframe", !1);
    _(this, "_pendingRequests", /* @__PURE__ */ new Map());
    _(this, "onAfterColorPass", (e) => {
      this.add(this._groundObjectGroup);
    });
    _(this, "onAfterMainPass", (e) => {
      this.remove(this._groundObjectGroup);
    });
    this._id = globalId++, this._quadtree = null, this._placeholder = null, this._options = e, this.statistics = {
      visited: 0,
      used: 0,
      rendered: 0,
      request: 0,
      unstable: 0
    }, this._currentStatistics = Object.assign({}, this.statistics), this._objectGroup = new Group(), this.add(this._objectGroup), this._boundingBoxGroup = new Group(), this.add(this._boundingBoxGroup), this._groundObjectGroup = new Scene(), e.strategy === TILELOADER_STRATEGY_FAST ? this.strategy = new FastTileLoaderStrategy(e) : e.strategy === TILELOADER_STRATEGY_HIERARCHICAL && (this.strategy = new HierarchicalTileLoaderStrategy(e));
  }
  _getCurrentGrid() {
  }
  computeDistanceToTile(e, r, s, a, c, l, h = !0) {
    let d;
    if (a === SceneMode$1.SCENE3D) {
      if (this.updateTileBoundingRegion(e, s), !e.boundingVolumeSourceTile && e.z >= this._minLevel)
        return h ? 9999999999 : e.boundingRegion.distanceToCamera(r, a, c, l);
      const m = e.boundingRegion, y = m.minimumHeight, x = m.maximumHeight;
      if (e.boundingVolumeSourceTile && e.boundingVolumeSourceTile.tile !== e) {
        const v = this.engine.map.map._ellipsoidCamera.positionCartographic.z, S = Math.abs(v - y), E = Math.abs(v - x);
        S > E ? (m.minimumHeight = y, m.maximumHeight = y) : (m.minimumHeight = x, m.maximumHeight = x);
      }
      return d = m.distanceToCamera(r, a, c, l), d;
    }
    return d = e.targetBoundingBox.distanceToPoint(r), d;
  }
  refresh() {
    for (const e of this._selectedTilesLastFrame)
      this.onSurfaceTileRefresh(e);
  }
  clearTilesInView() {
    this._groundObjectGroup.clear(), this._boundingBoxGroup.clear();
    const e = this._objectGroup;
    for (const r of this._selectedTilesLastFrame)
      e.remove(r.object), this.onSurfaceTileRemoved(r);
    this._selectedTilesLastFrame = [], this._selectedTilesMapLastFrame = {};
  }
  updateView(e, r, s, a) {
    if (this._freezeUpdate || this.beginFrame(a) === !1)
      return;
    const c = this._getCurrentGrid();
    if (!c)
      return;
    this._quadtree || (this._quadtree = new TileQuadtree(c), this._quadtree.onTileCreated = this._onTileCreated);
    const l = this._currentOccluder = e.map._map.occluder;
    l && (l.cameraPosition = r);
    let h = this._strategy;
    h._surfaceTileManager || (h._surfaceTileManager = this._surfaceTileManager);
    let { selectedTiles: d, requestTilesQueue: f, placeholderTiles: p } = h.computeTiles(
      e,
      r,
      s,
      a
    );
    const m = this._collectionCancelTiles(f);
    m.length > 0 && this._cancelTileInArray(m);
    let y = [];
    p.length > 0 && this._shouldRenderPlaceholder && (this._placeholder || (this._placeholder = new Placeholder(this._options, this._placeholderColor), this._placeholder.engine = e), y = p.map((L) => this._placeholder.get(L)));
    let x = this._maxRequestTilesPerFrame;
    const v = Math.min(2, this._currentStatistics.unstable);
    x -= v;
    const S = x;
    for (let L = 0; L < f.length; L++) {
      const O = f[L], F = Math.min(x, O.length);
      this._requestTilesInArray(O, F, L === 0), x -= F;
    }
    S > x && this._quadMap._engine.requestRender();
    const E = this._selectedTilesLastFrame, b = this._selectedTilesMapLastFrame, w = {};
    for (const L of d)
      w[L.tile.key] = L;
    const M = this._objectGroup;
    let P = this._groundObjectGroup;
    e.scene.overrideMaterial;
    const D = this._boundingBoxGroup;
    D.clear();
    for (const L of E)
      if (!w[L.tile.key] && (M.remove(L.object), P.remove(L.groundObject), this.onSurfaceTileRemoved(L), this._showTileDebugLabel)) {
        const O = this._getDebugLabelId(L);
        this._debugLabelIds[O] && (delete this._debugLabelIds[O], e.rendering.label.removeLabel({
          id: O,
          type: "text_flat"
        }));
      }
    for (const L of this._placeholderMeshesLastFrame)
      P.remove(L);
    for (const L of y)
      P.add(L);
    for (const L of d)
      if (!!L) {
        if (this._showTileBoundingBox && D.add(L.boxHelper), this._showTileDebugLabel) {
          const O = this._getDebugLabelId(L);
          if (!this._debugLabelIds[O]) {
            this._debugLabelIds[O] = !0;
            const F = {
              crs: e.map.projectionName,
              id: O,
              position: L.tile.targetCenter,
              text: L.tile.key,
              textSize: 24,
              textFillStyle: [255, 0, 0, 1],
              textStrokeStyle: [255, 255, 255, 1],
              textStrokeWidth: 2,
              type: "text_flat",
              rank: 1e7
            };
            e.rendering.label.addLabel(F);
          }
        }
        b[L.tile.key] ? L.isMeetSSEChanged && this.onSurfaceTileSSEChanged(L) : (L.object && this._objectGroup.add(L.object), L.groundObject && P.add(L.groundObject), this.onSurfaceTileAdded(L));
      }
    this._placeholderMeshesLastFrame = y, this._selectedTilesLastFrame = d, this._selectedTilesMapLastFrame = w, this.endFrame(a);
  }
  isInStableRenderState() {
    return this.statistics.unstable === 0 && this.statistics.request === 0;
  }
  _getDebugLabelId(e) {
    return "mapsurface-" + this._id + "-debuglabel-" + e.tile.key;
  }
  _onBeforeSceneRender(e, r, s, a) {
    if (r.overrideMaterial) {
      this.add(this._groundObjectGroup), this.remove(this._groundSceneRenderer.copyMesh);
      return;
    }
    if (this._groundObjectGroup.children.length === 0) {
      this._groundSceneRenderer && this.remove(this._groundSceneRenderer.copyMesh);
      return;
    }
    this._groundSceneRenderer || (this._groundSceneRenderer = new GroundSceneRenderer()), this.add(this._groundSceneRenderer.copyMesh), this._groundSceneRenderer.render(this._groundObjectGroup, e, r, s, a);
  }
  _cancelTileInArray(e) {
    this._surfaceTileManager.cancelSurfaceTiles(e);
  }
  _requestTilesInArray(e, r, s = !1) {
    if (r <= 0)
      return;
    let a = e.slice(0, r);
    for (const c of a)
      this._pendingRequests.set(c.key, c), this._surfaceTileManager.requestSurfaceTile(c, s);
  }
  _collectionCancelTiles(e) {
    const r = e.flat(), s = [];
    for (const [a, c] of this._pendingRequests.entries())
      r.includes(c) || (s.push(c), this._pendingRequests.delete(a));
    return s;
  }
  _selectCurrentFrameRequestTiles(e, r) {
    return e.length < r ? e : (e.sort((s, a) => s.z !== a.z ? a.z - s.z : s._distance - a._distance), e.slice(0, r));
  }
  beginFrame(e) {
    this._currentStatistics.visited = 0, this._currentStatistics.used = 0, this._currentStatistics.rendered = 0, this._currentStatistics.request = 0, this._currentStatistics.unstable = 0, this.updatePendingRequest(e), this._strategy.beginFrame(), this._surfaceTileManager.beginFrame(e);
  }
  updatePendingRequest(e) {
    const r = this._surfaceTileManager, s = [];
    for (const [a, c] of this._pendingRequests.entries())
      r.getSurfaceTile(c, e) && s.push(a);
    for (const a of s)
      this._pendingRequests.delete(a);
  }
  endFrame(e) {
    this.statistics.visited = this._currentStatistics.visited, this.statistics.used = this._currentStatistics.used, this.statistics.rendered = this._currentStatistics.rendered, this.statistics.request = this._currentStatistics.request, this.statistics.unstable = this._currentStatistics.unstable, this._strategy.endFrame(), this._surfaceTileManager.endFrame(e);
  }
  _computeOccludeePoint(e, r) {
    const a = e.boundingRegion.boundingVolume.center, c = e.geoBoundingBox, l = Rectangle.fromBox(c), h = this.engine.map.map._ellipsoid, d = cornerPositionsScratch;
    return Cartesian3.fromRadians(
      l.west,
      l.south,
      0,
      h,
      d[0]
    ), Cartesian3.fromRadians(
      l.east,
      l.south,
      0,
      h,
      d[1]
    ), Cartesian3.fromRadians(
      l.west,
      l.north,
      0,
      h,
      d[2]
    ), Cartesian3.fromRadians(
      l.east,
      l.north,
      0,
      h,
      d[3]
    ), r.computeHorizonCullingPointPossiblyUnderEllipsoid(
      a,
      d,
      0
    );
  }
  _computeOccludeePoint2(e, r) {
    const s = e.boundingBox, a = e.center, c = s.min, l = s.max, h = [
      c,
      l,
      new Vector3$1(c.x, c.y, l.z),
      new Vector3$1(c.x, l.y, c.z)
    ];
    return r.computeHorizonCullingPointPossiblyUnderEllipsoid(
      a,
      h,
      0
    );
  }
  updateTileBoundingRegion(e, r) {
    const s = this.engine.map.map._ellipsoid;
    if (!e.boundingRegion) {
      const y = Rectangle.fromBox(e.geoBoundingBox, new Rectangle(), !0);
      e.boundingRegion = new TileBoundingRegion({
        computeBoundingVolumes: !1,
        rectangle: y,
        ellipsoid: s,
        minimumHeight: e.geoBoundingBox.min.z,
        maximumHeight: e.geoBoundingBox.max.z
      });
    }
    let c = this._surfaceTileManager.getSurfaceTile(e, r);
    const l = c && c.object, h = e._heights, d = e.boundingRegion, f = d.minimumHeight, p = d.maximumHeight;
    let m = !1;
    if (l)
      h && (d.minimumHeight = h[0], d.maximumHeight = h[1]), m = !0;
    else {
      let y = e.parent;
      for (; y !== void 0; ) {
        const x = y._heights, v = this._surfaceTileManager.getSurfaceTile(y, r);
        if (v) {
          const S = v.object, E = y._heights !== void 0;
          if (S) {
            E && (d.minimumHeight = x[0], d.maximumHeight = x[1]);
            break;
          }
        }
        y = y.parent;
      }
      c = y;
    }
    if (c !== void 0) {
      const y = d._orientedBoundingBox === void 0;
      (d.minimumHeight !== f || d.maximumHeight !== p || y) && d.computeBoundingVolumes(s), e.boundingVolumeSourceTile = c, e.boundingVolumeIsFromMesh = m;
    } else
      d._orientedBoundingBox === void 0 && d.computeBoundingVolumes(s), e.boundingVolumeSourceTile = void 0, e.boundingVolumeIsFromMesh = !1;
  }
  screenSpaceError(e) {
    const r = this.quadMap;
    let s = e.z;
    const a = this.engine.map;
    let c = a.isGlobe, l = 1, h = 2e3, d = !0;
    if (c && (d = e.targetCenter.length() > a.map._ellipsoid.minimumRadius), d) {
      directionScratch$1.copy(this.engine.camera.position), c ? (Transforms.eastNorthUpToFixedFrame(
        e.targetCenter,
        null,
        fixedTransformScratch
      ), fixedTransformScratch.invert(), directionScratch$1.applyMatrix4(fixedTransformScratch).normalize()) : directionScratch$1.sub(e.targetCenter).normalize(), l = Math.exp(-this._sseFactor * (1 - MathUtils.clamp(directionScratch$1.z, 0, 1)));
      let v = MathUtils.clamp(directionScratch$1.z, 0, 1);
      e._distance < h && (l = 1, v = 1), e._horizonFactor = v;
    }
    const f = e.grid.getPixelSizeByLevel(s), p = e._distance, m = this.engine.rendering.resolution.y, y = r._sseDenominator;
    let x = f * m / (p * y) * this.computedLodScaleFactor * l;
    return x *= e.targetLODScaleRatio, x;
  }
  reverseScreenSpaceErrorZ(e) {
    const r = this.quadMap, s = this.engine.map;
    let a = s.isGlobe, c = 1, l = 2e3, h = !0, d = 2;
    a && (h = e.targetCenter.length() > s.map._ellipsoid.minimumRadius), h && (directionScratch$1.copy(this.engine.camera.position), a ? (Transforms.eastNorthUpToFixedFrame(
      e.targetCenter,
      null,
      fixedTransformScratch
    ), fixedTransformScratch.invert(), directionScratch$1.applyMatrix4(fixedTransformScratch).normalize()) : directionScratch$1.sub(e.targetCenter).normalize(), c = Math.exp(-this._sseFactor * (1 - MathUtils.clamp(directionScratch$1.z, 0, 1))), e._distance < l && (c = 1));
    const f = e._distance, p = this.engine.rendering.resolution.y, m = r._sseDenominator;
    let y = d * f * m / (p * this.computedLodScaleFactor * c);
    y /= e.targetLODScaleRatio;
    const x = Math.log2(e.grid.zeroLevelPixelSize * 2 / y);
    return isNaN(x) ? 0 : isFinite(x) ? Math.max(x, 0) : 30;
  }
  projectBoundingBoxToNdc(e) {
    const r = this.engine.camera;
    viewMatrixScratch.copy(r.matrixWorldInverse), projectionMatrixScratch.copy(r.projectionMatrix), mvpMatrixScratch.multiplyMatrices(projectionMatrixScratch, viewMatrixScratch);
    const s = this.engine.map.isGlobe;
    let a;
    if (s) {
      const c = e.boundingRegion;
      if (!c || !c.boundingVolume)
        return [[0, 0], [0, 0], [0, 0], [0, 0]];
      const l = c.boundingVolume.computeCorners();
      a = [
        l[0],
        l[2],
        l[6],
        l[4]
      ];
    } else {
      const c = e.targetBoundingBox;
      a = [
        new Vector3$1(c.min.x, c.min.y, 0),
        new Vector3$1(c.min.x, c.max.y, 0),
        new Vector3$1(c.max.x, c.max.y, 0),
        new Vector3$1(c.max.x, c.min.y, 0)
      ];
    }
    return a.map((c) => (vertexScratch.set(c.x, c.y, c.z, 1), vertexScratch.applyMatrix4(mvpMatrixScratch), vertexScratch.divideScalar(vertexScratch.w), [vertexScratch.x, vertexScratch.y]));
  }
  _computeTileVisibility(e, r) {
    const { mode: s } = this.engine.map.map;
    if (s === SceneMode$1.SCENE3D) {
      const l = r.boundingRegion.boundingVolume;
      return !(!(this._computeTileVisibility3D(e, l) !== Intersect$1.OUTSIDE) || this._enableHorizonCulling && this._currentOccluder && (r._occludeePointInScaledSpace || (r._occludeePointInScaledSpace = this._computeOccludeePoint(r, this._currentOccluder)), r._occludeePointInScaledSpace && !this._currentOccluder.isScaledSpacePointVisiblePossiblyUnderEllipsoid(r._occludeePointInScaledSpace, 0)));
    }
    const a = r.targetBoundingBox;
    return e.intersectsBox(a);
  }
  _computeTileVisibility3D(e, r) {
    if (!defined$1(r))
      throw new DeveloperError("boundingVolume is required.");
    const s = e.planes;
    let a = !1;
    for (let c = 0, l = s.length; c < l; ++c) {
      const h = s[c], d = h.normal.clone().normalize(), f = h.constant, p = new Vector4(...d.toArray(), f), m = r.intersectPlane(
        StaticPlane.fromCartesian4(p, scratchPlane)
      );
      if (m === Intersect$1.OUTSIDE)
        return Intersect$1.OUTSIDE;
      m === Intersect$1.INTERSECTING && (a = !0);
    }
    return a ? Intersect$1.INTERSECTING : Intersect$1.INSIDE;
  }
  _naturalOrderChildTiles(e, r) {
    const s = e[0], a = e[1], c = e[2], l = e[3], h = r.x / Math.PI * 180, d = r.y / Math.PI * 180;
    return h < s.geoBoundingBox.max.x ? d < s.geoBoundingBox.max.y ? [
      s,
      c,
      a,
      l
    ] : [
      a,
      s,
      l,
      c
    ] : d < s.geoBoundingBox.max.y ? [
      c,
      s,
      l,
      a
    ] : [
      l,
      a,
      c,
      s
    ];
  }
  showLoadLogInOneFrame() {
    this._strategy._logLoadInCurrentFrame = !0;
  }
  onSurfaceTileAdded(e) {
  }
  onSurfaceTileRemoved(e) {
  }
  onSurfaceTileRefresh(e) {
  }
  onSurfaceTileSSEChanged(e) {
  }
  dispose() {
    this._quadtree = null, this._surfaceTileManager.dispose(), this._surfaceTileManager = null;
  }
  set quadMap(e) {
    this._quadMap = e;
  }
  get quadMap() {
    return this._quadMap;
  }
  get showTileBoundingBox() {
    return this._showTileBoundingBox;
  }
  set showTileBoundingBox(e) {
    this._showTileBoundingBox = e, this._quadMap._engine.requestRender();
  }
  get showTileDebugLabel() {
    return this._showTileDebugLabel;
  }
  set showTileDebugLabel(e) {
    if (this._showTileDebugLabel = e, e === !1) {
      const r = this._quadMap._engine.rendering.label;
      for (const s of Object.keys(this._debugLabelIds))
        r.removeLabel({
          id: s,
          type: "text_flat"
        });
      this._debugLabelIds = {};
    }
    this._quadMap._engine.requestRender();
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(e) {
    this._freezeUpdate = e;
  }
  get enableHorizonCulling() {
    return this._enableHorizonCulling;
  }
  set enableHorizonCulling(e) {
    this._enableHorizonCulling = e;
  }
  get tileManager() {
    return this._surfaceTileManager;
  }
  get loadSiblings() {
    return this._strategy._loadSiblings;
  }
  set loadSiblings(e) {
    this._strategy._loadSiblings = e;
  }
  get sseFactor() {
    return this._sseFactor;
  }
  set sseFactor(e) {
    this._sseFactor = e;
  }
  get lodScaleFactor() {
    return this._lodScaleFactor;
  }
  set lodScaleFactor(e) {
    this._lodScaleFactor = e;
  }
  get computedLodScaleFactor() {
    let e = this._lodScaleFactor;
    const r = this._tileProvider;
    if (r) {
      const s = defaultValue(r._lodScaleFactor, 1);
      e *= s;
    }
    return e;
  }
  get showGroundWireframe() {
    return this._showGroundWireframe;
  }
  set showGroundWireframe(e) {
    this._showGroundWireframe = e, e ? (this._groundWireframeMaterial || (this._groundWireframeMaterial = new MeshBasicMaterial({
      wireframe: !0,
      color: 16746496
    })), this._groundObjectGroup.overrideMaterial = this._groundWireframeMaterial) : (this._groundObjectGroup.overrideMaterial = null, this._groundWireframeMaterial && (this._groundWireframeMaterial.dispose(), this._groundWireframeMaterial = null));
  }
  set strategy(e) {
    this._strategy = e, this._strategy._surface = this, this._strategy._surfaceTileManager = this._surfaceTileManager;
  }
  get strategy() {
    return this._strategy;
  }
  get placeholder() {
    return this._placeholder || (this._placeholder = new Placeholder(this._options, this._placeholderColor), this._placeholder.engine = this._quadMap._engine), this._placeholder;
  }
}
class SurfaceTileManager {
  constructor(i) {
    _(this, "_surface", null);
    this._surface = i, this._pendingCount = 0;
  }
  beginFrame(i) {
  }
  endFrame(i) {
  }
  getSurfaceTile(i, e) {
  }
  requestSurfaceTile(i) {
  }
  cancelSurfaceTiles(i) {
  }
  dispose() {
    console.warn("SurfaceTileManager.dispose not implemented");
  }
  get pendingCount() {
    return this._pendingCount;
  }
}
const TILE_STATE_CREATED = 1, TILE_STATE_LOADING = 2, TILE_STATE_COMPLETED = 3, TILE_STATE_FAILED = 4, TILE_STATE_DISPOSED = 5, _tempVector3$5 = new Vector3$1();
class MapTile {
  constructor(i, e, r, s) {
    _(this, "x");
    _(this, "y");
    _(this, "z");
    _(this, "compeleted", !1);
    _(this, "siblingIndex", 0);
    _(this, "_grid");
    _(this, "_geoBoundingBox");
    _(this, "_projectedCenter");
    _(this, "_projectedBoundingBox");
    _(this, "_targetCenter");
    _(this, "_targetBoundingBox");
    _(this, "_targetLODScaleRatio");
    _(this, "_targetSSESize");
    this._grid = i, this.z = e, this.x = r, this.y = s, this.key = e + "-" + r + "-" + s, this.state = TILE_STATE_CREATED, this.epoch = 0, this.childrenKeys = [], i.getTileLoaderConfig && (this.loaderConfig = i.getTileLoaderConfig(this));
  }
  updateBoundingBoxZ(i, e) {
    const r = this._projectedBoundingBox;
    r.min.z = i, r.max.z = e, r.getCenter(this._projectedCenter);
  }
  get boundingBox() {
    return console.warn("boundingBox is renamed to projectedBoundingBox"), this.projectedBoundingBox;
  }
  set boundingBox(i) {
    console.warn("boundingBox is renamed to projectedBoundingBox"), this.projectedBoundingBox = i;
  }
  get projectedBoundingBox() {
    return this._projectedBoundingBox;
  }
  set projectedBoundingBox(i) {
    if (!i) {
      console.warn("Invalid bounding", i);
      return;
    }
    this._projectedBoundingBox = i, this._projectedCenter || (this._projectedCenter = new Vector3$1()), i.getCenter(this._projectedCenter);
  }
  get geoBoundingBox() {
    return this._geoBoundingBox;
  }
  set geoBoundingBox(i) {
    this._geoBoundingBox = i;
  }
  get reverseY() {
    return this._reverseY === void 0 && (this._reverseY = this._grid.getTileReverseY(this)), this._reverseY;
  }
  set grid(i) {
    this._grid = i;
  }
  get grid() {
    return this._grid;
  }
  get center() {
    return console.warn("center is renamed to projectedCenter"), this.projectedCenter;
  }
  set center(i) {
    console.warn("center is renamed to projectedCenter"), this.projectedCenter = i;
  }
  get projectedCenter() {
    return this._projectedCenter;
  }
  set projectedCenter(i) {
    this._projectedCenter = i;
  }
  set targetBoundingBox(i) {
    console.warn("targetBoundingBox is readonly");
  }
  get targetGeoBoundingBox() {
    return this._targetGeoBoundingBox || (this._grid.shouldConvertCoord ? (this._targetGeoBoundingBox = new Box3(), CoordTransformer.transform(
      this._grid.sourceCoordType,
      this._grid.targetCoordType,
      this.geoBoundingBox.min,
      this._targetGeoBoundingBox.min
    ), CoordTransformer.transform(
      this._grid.sourceCoordType,
      this._grid.targetCoordType,
      this.geoBoundingBox.max,
      this._targetGeoBoundingBox.max
    )) : this._targetGeoBoundingBox = this.geoBoundingBox), this._targetGeoBoundingBox;
  }
  get targetBoundingBox() {
    return this._targetBoundingBox || (this._grid.targetProjection.name === this._grid.sourceProjection.name && !this._grid.shouldConvertCoord ? (this._targetBoundingBox = new Box3(), this._targetBoundingBox.copy(this.projectedBoundingBox)) : this._targetBoundingBox = this._grid.targetProjection.geoBoxToProjectedBox(
      this.targetGeoBoundingBox,
      null,
      this._grid.useExtendTargetBoundingBox
    )), this._targetBoundingBox;
  }
  get targetCenter() {
    return this._targetCenter || (this._targetCenter = new Vector3$1(), this._grid.targetProjection.name !== this._grid.sourceProjection.name ? this.targetBoundingBox.getCenter(this._targetCenter) : this._projectedBoundingBox.getCenter(this._targetCenter)), this._targetCenter;
  }
  get geoIntersectionOfTargetProjection() {
    const i = this._grid.targetProjection.geoBoundingBox;
    if (!i || i.isDefault)
      return Intersect$1.INSIDE;
    const {
      x: e,
      y: r
    } = this.geoBoundingBox.min, {
      x: s,
      y: a
    } = this.geoBoundingBox.max, {
      x: c,
      y: l
    } = i.min, {
      x: h,
      y: d
    } = i.max;
    return s < c || e > h || a < l || r > d ? Intersect$1.OUTSIDE : e >= c && s <= h && r >= l && a <= d ? Intersect$1.INSIDE : Intersect$1.INTERSECT;
  }
  _computeAvailableGeoBoundingBox() {
    const i = this._grid.targetProjection.geoBoundingBox;
    let {
      x: e,
      y: r,
      z: s
    } = this.geoBoundingBox.min, {
      x: a,
      y: c,
      z: l
    } = this.geoBoundingBox.max;
    const {
      x: h,
      y: d
    } = i.min, {
      x: f,
      y: p
    } = i.max;
    e < h && (e = h), a > f && (a = f), r < d && (r = d), c > p && (c = p), this._availableGeoBoundingBox = new Box3(new Vector3$1(e, r, s), new Vector3$1(a, c, l));
  }
  get availableGeoBoundingBox() {
    return this.geoIntersectionOfTargetProjection === Intersect$1.OUTSIDE ? null : this.geoIntersectionOfTargetProjection === Intersect$1.INTERSECT ? (this._availableGeoBoundingBox || this._computeAvailableGeoBoundingBox(), this._availableGeoBoundingBox) : this.geoBoundingBox;
  }
  _computeTargetLODScaleRatio() {
    let i;
    if (this._grid.targetProjection.getLODSacleOfGeoBoundingBox && (i = this._grid.targetProjection.getLODSacleOfGeoBoundingBox(this.geoBoundingBox), i !== void 0))
      return i;
    const e = this.projectedBoundingBox;
    let r = e.max.x - e.min.x, s = e.max.y - e.min.y;
    const a = this.targetBoundingBox;
    let c, l;
    a.isOrientedBoundingBox ? (_tempVector3$5.fromArray(a.halfAxes.elements, 0), c = _tempVector3$5.length() * 2, _tempVector3$5.fromArray(a.halfAxes.elements, 3), l = _tempVector3$5.length() * 2) : (c = a.max.x - a.min.x, l = a.max.y - a.min.y);
    let h = c / r, d = l / s;
    return i = Math.min(h, d), i;
  }
  get targetLODScaleRatio() {
    return this._targetLODScaleRatio === void 0 && (this._grid.sourceProjection.equals(this._grid.targetProjection) ? this._targetLODScaleRatio = 1 : this._targetLODScaleRatio = this._computeTargetLODScaleRatio()), this._targetLODScaleRatio;
  }
}
function enqueueMicrotask(o) {
  Promise.resolve().then(o);
}
class LRUCache {
  constructor(i) {
    this.maxSize = i || 800, this.minSize = Math.round(this.maxSize * 0.75), this.unloadPercent = 0.05, this.itemSet = /* @__PURE__ */ new Map(), this.itemList = [], this.usedSet = /* @__PURE__ */ new Set(), this.callbacks = /* @__PURE__ */ new Map(), this.unloadPriorityCallback = null;
    const e = this.itemSet;
    this.defaultPriorityCallback = (r) => e.get(r);
  }
  setMaxSize(i) {
    this.maxSize = i, this.minSize = Math.round(this.maxSize * 0.75);
  }
  isFull() {
    return this.itemSet.size >= this.maxSize;
  }
  add(i, e) {
    const r = this.itemSet;
    if (r.has(i) || this.isFull())
      return !1;
    const s = this.usedSet, a = this.itemList, c = this.callbacks;
    return a.push(i), s.add(i), r.set(i, Date.now()), c.set(i, e), !0;
  }
  remove(i) {
    const e = this.usedSet, r = this.itemSet, s = this.itemList, a = this.callbacks;
    if (r.has(i)) {
      a.get(i)(i);
      const c = s.indexOf(i);
      return s.splice(c, 1), e.delete(i), r.delete(i), a.delete(i), !0;
    }
    return !1;
  }
  clear() {
    const i = this.usedSet, e = this.itemSet, r = this.itemList, s = this.callbacks;
    for (let a = 0; a < r.length; a++) {
      const c = r[a];
      s.get(c)(c);
    }
    this.itemList = [], i.clear(), e.clear(), s.clear();
  }
  foreachItem(i) {
    for (const e of this.itemList)
      i(e);
  }
  markUsed(i) {
    const e = this.itemSet, r = this.usedSet;
    e.has(i) && !r.has(i) && (e.set(i, Date.now()), r.add(i));
  }
  markAllUnused() {
    this.usedSet.clear();
  }
  unloadUnusedContent() {
    const i = this.unloadPercent, e = this.minSize, r = this.itemList, s = this.itemSet, a = this.usedSet, c = this.callbacks, l = r.length - a.size, h = r.length - e, d = this.unloadPriorityCallback || this.defaultPriorityCallback;
    if (h > 0 && l > 0) {
      r.sort((x, v) => {
        const S = a.has(x), E = a.has(v);
        return S && E ? 0 : !S && !E ? d(v) - d(x) : S ? 1 : -1;
      });
      const f = Math.min(h, l), p = Math.max(e * i, f * i);
      let m = Math.min(p, l);
      m = Math.ceil(m);
      const y = r.splice(0, m);
      for (let x = 0, v = y.length; x < v; x++) {
        const S = y[x];
        c.get(S)(S), s.delete(S), c.delete(S);
      }
    }
  }
  scheduleUnload(i = !0) {
    this.scheduled || (this.scheduled = !0, enqueueMicrotask(() => {
      this.scheduled = !1, this.unloadUnusedContent(), i && this.markAllUnused();
    }));
  }
}
const EPISLON6 = 1e-6;
class Grid {
  constructor(i, e, r) {
    _(this, "_minLevel", 0);
    _(this, "_maxLevel", 18);
    _(this, "_useGeoSubdivision", !1);
    _(this, "_projectBoxWithFourConrner", !1);
    _(this, "_unprojectBoxWithFourConrner", !1);
    _(this, "_shouldCheckTileBoundingRange", !1);
    _(this, "_pixelSizes", []);
    this._engine = i, this._sourceProjection = e, this._targetProjection = r;
  }
  initFromTileProvider(i) {
    this._sourceProjection = i.sourceProjection, this._targetProjection = i.targetProjection, this._sourceCoordType = i.sourceCoordType, this._targetCoordType = i.targetCoordType, this._sourceCoordType && this._targetCoordType && this._sourceCoordType !== this._targetCoordType ? (this._shouldConvertCoord = CoordTransformer.canTransform(this._sourceCoordType, this._targetCoordType), this._shouldConvertCoord || console.warn(`can not convert coord from ${this._sourceCoordType} to ${this._targetCoordType}`)) : this._shouldConvertCoord = !1, this.useExtendTargetBoundingBox = i.useExtendTargetBoundingBox || !1;
  }
  getRootTiles() {
    return console.warn("getRootTiles is not implemented"), [];
  }
  getAvailableRootTiles() {
    return this.getRootTiles().filter((e) => e.geoIntersectionOfTargetProjection !== Intersect$1.OUTSIDE);
  }
  getRootBoundingBox() {
    return console.warn("getRootBoundingBox is not implemented"), null;
  }
  getPixelSizeByLevel(i) {
    return this._pixelSizes[i];
  }
  getNextLevel(i) {
    return i + 1;
  }
  shouldCreateChildren(i) {
    return !0;
  }
  getNextLevelTileCount(i, e) {
    return Math.pow(2, e - i);
  }
  getQuadTreeLevelGap(i, e) {
    return e - i;
  }
  createTileChildren(i) {
    const e = [];
    i.childrenKeys = [];
    const r = this.getNextLevel(i.z);
    if (!this.shouldCreateChildren(i))
      return [];
    let s = null, a = null;
    if (this._useGeoSubdivision) {
      const y = i.geoBoundingBox;
      s = y.min, a = y.max;
    } else {
      const y = i.projectedBoundingBox;
      s = y.min, a = y.max;
    }
    const c = this.getQuadTreeLevelGap(i.z, r), l = Math.pow(2, c), h = (a.x - s.x) / l, d = (a.y - s.y) / l;
    let f = i.x * l, p = i.y * l, m = null;
    for (let y = 0; y < l; y++)
      for (let x = 0; x < l; x++) {
        const v = new MapTile(this, r, f + y, p + x);
        m = new Box3(
          new Vector3$1(
            s.x + y * h,
            s.y + x * d,
            s.z
          ),
          new Vector3$1(
            s.x + (y + 1) * h,
            s.y + (x + 1) * d,
            a.z
          )
        ), this._useGeoSubdivision ? (v.geoBoundingBox = m, v.projectedBoundingBox = this._sourceProjection.geoBoxToProjectedBox(m)) : (v.projectedBoundingBox = m, v.geoBoundingBox = this._sourceProjection.projectedBoxToGeoBox(m)), !(this._shouldCheckTileBoundingRange && !this.isTileInBoundingRange(v)) && v.geoIntersectionOfTargetProjection !== Intersect$1.OUTSIDE && (v.siblingIndex = y * l + x, v.parentKey = i.key, v.parent = i, e.push(v), i.childrenKeys.push(v.key));
      }
    return e;
  }
  createSubTile(i, e, r, s, a) {
    const c = new MapTile(this, i.z, i.x, i.y);
    let l = null, h = null;
    if (this._useGeoSubdivision) {
      const S = i.geoBoundingBox;
      l = S.min, h = S.max;
    } else {
      const S = i.projectedBoundingBox;
      l = S.min, h = S.max;
    }
    const d = h.x - l.x, f = h.y - l.y, p = l.x + e * d, m = l.y + r * f, y = p + s * d, x = m + a * f, v = new Box3(
      new Vector3$1(
        p,
        m,
        l.z
      ),
      new Vector3$1(
        y,
        x,
        h.z
      )
    );
    return this._useGeoSubdivision ? (c.geoBoundingBox = v, c.projectedBoundingBox = this._sourceProjection.geoBoxToProjectedBox(v)) : (c.projectedBoundingBox = v, c.geoBoundingBox = this._sourceProjection.projectedBoxToGeoBox(v)), c._rect = [e, r, s, a], c.key = i.key + "-" + Math.random().toFixed(5), c.parent = i, c._sourceTile = i, c;
  }
  isTileInBoundingRange(i) {
    const e = i.geoBoundingBox, r = e.min, s = e.max;
    return !(r.x > 180 || s.x < -180 || r.y > 90 || s.y < -90);
  }
  getTileSizeAtLevel(i) {
    console.warn("getTileSizeXAtLevel is not implemented");
  }
  getTileCoordX(i, e, r = !1) {
    console.warn("getTileCoordX is not implemented");
  }
  getTileCoordY(i, e, r = !1) {
    console.warn("getTileCoordY is not implemented");
  }
  _alignTileCoord(i) {
    let e = Math.round(i);
    return Math.abs(i - e) < EPISLON6 ? e : i;
  }
  computeCoverageTilesCoord(i, e = 0, r = 100) {
    const s = [], a = i.grid;
    let c = null;
    if (a.useGeoSubdivision)
      this._useGeoSubdivision ? c = i.geoBoundingBox : c = this._sourceProjection.geoBoxToProjectedBox(i.geoBoundingBox);
    else if (this._useGeoSubdivision)
      c = i.projectedBoundingBox;
    else {
      let b = a.targetProjection.projectedBoxToGeoBox(i.projectedBoundingBox);
      c = this._sourceProjection.geoBoxToProjectedBox(b);
    }
    let l = this.zeroLevelPixelSize, h = a.zeroLevelPixelSize;
    const d = l / h;
    let f = Math.round(i.z + d - 1);
    const p = Math.max(this._minLevel, e), m = Math.min(this._maxLevel, r);
    f < p && (f = p), f > m && (f = m);
    let y = 0, x = 0, v = 0, S = 0, E = 0;
    for (; f >= p; ) {
      const b = this.getTileSizeAtLevel(f);
      if (x = this._alignTileCoord(this.getTileCoordX(c.min.x, b, !0)), v = this._alignTileCoord(this.getTileCoordY(c.min.y, b, !0)), S = this._alignTileCoord(this.getTileCoordX(c.max.x, b, !0)), E = this._alignTileCoord(this.getTileCoordY(c.max.y, b, !0)), x = Math.floor(x), v = Math.floor(v), S = Math.ceil(S), E = Math.ceil(E), y = (S - x) * (E - v), y < 8)
        break;
      if (f === p)
        return console.warn(`tile count ${y} is too large for one mapped target tile ${i.key}`), [];
      f--;
    }
    for (let b = x; b < S; b++)
      for (let w = v; w < E; w++)
        s.push([
          f,
          b,
          w
        ]);
    return s;
  }
  computeTileCoverageRect(i, e) {
    if (i.z === e.z && i.x === e.x && i.y === e.y)
      return [-1, -1, -1, -1];
    let r = null, s = null;
    i.grid.useGeoSubdivision ? (r = i.geoBoundingBox, s = e.geoBoundingBox) : (r = i.projectedBoundingBox, s = e.projectedBoundingBox);
    const a = r.min, c = r.max, l = s.min, h = s.max, d = (l.x - a.x) / (c.x - a.x), f = (l.y - a.y) / (c.y - a.y), p = (h.x - a.x) / (c.x - a.x), m = (h.y - a.y) / (c.y - a.y);
    return [d, f, p, m];
  }
  updateTileHeights(i, e) {
    i._heights = e, !(i.z < 2) && (this.useGeoSubdivision ? (i.geoBoundingBox.min.z = e[0], i.geoBoundingBox.max.z = e[1], i.projectedBoundingBox = this._sourceProjection.geoBoxToProjectedBox(
      i.geoBoundingBox
    )) : (i.projectedBoundingBox.min.z = e[0], i.projectedBoundingBox.max.z = e[1], i.center.z = (e[0] + e[1]) / 2, i.geoBoundingBox = this.projectionBoxToGeoBox(
      i.projectedBoundingBox,
      this._unprojectBoxWithFourConrner
    )));
  }
  getTileReverseY(i) {
    return Math.pow(2, i.z) - i.y - 1;
  }
  _updateLODConfig() {
    const i = [];
    let e = this.zeroLevelPixelSize;
    for (let r = 0; r <= this._maxLevel; r++)
      i.push(e), e /= 2;
    this._pixelSizes = i;
  }
  update() {
    this._updateLODConfig();
  }
  set engine(i) {
    this._engine = i;
  }
  get engine() {
    return this._engine;
  }
  set maxLevel(i) {
    this._maxLevel = i;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  set minLevel(i) {
    this._minLevel = i;
  }
  get minLevel() {
    return this._minLevel;
  }
  get useGeoSubdivision() {
    return this._useGeoSubdivision;
  }
  get sourceProjection() {
    return this._sourceProjection;
  }
  get targetProjection() {
    return this._targetProjection;
  }
  get sourceCoordType() {
    return this._sourceCoordType;
  }
  get targetCoordType() {
    return this._targetCoordType;
  }
  get shouldConvertCoord() {
    return this._shouldConvertCoord;
  }
  get zeroLevelPixelSize() {
    return this._zeroLevelPixelSize || (this._zeroLevelPixelSize = 200375083427892e-7 * 2 / 256), this._zeroLevelPixelSize;
  }
}
const EARTH_RADIUS$1 = 200375083427892e-7;
class WebMercatorGrid extends Grid {
  constructor() {
    super(...arguments);
    _(this, "name", MAP_GRID_NAME_WEB_MERCATOR);
    _(this, "_maxLevel", 21);
    _(this, "_rootBoundingBox", new Box3(
      new Vector3$1(-EARTH_RADIUS$1, -EARTH_RADIUS$1, -0.1),
      new Vector3$1(EARTH_RADIUS$1, EARTH_RADIUS$1, 0.1)
    ));
  }
  getRootTiles() {
    const e = new MapTile(this, 0, 0, 0);
    return e.projectedBoundingBox = this._rootBoundingBox, e.geoBoundingBox = new Box3(new Vector3$1(-180, -90, -0.1), new Vector3$1(180, 90, 0.1)), [e];
  }
  getRootBoundingBox() {
    return this._rootBoundingBox;
  }
  getTileSizeAtLevel(e) {
    return EARTH_RADIUS$1 / Math.pow(2, e - 1);
  }
  getTileCoordX(e, r, s) {
    return s && (e < -EARTH_RADIUS$1 ? e = -EARTH_RADIUS$1 : e > EARTH_RADIUS$1 && (e = EARTH_RADIUS$1)), (e + EARTH_RADIUS$1) / r;
  }
  getTileCoordY(e, r, s) {
    return this.getTileCoordX(e, r, s);
  }
  get textureMaxLevel() {
    return this._textureMaxLevel;
  }
  set textureMaxLevel(e) {
    this._textureMaxLevel = e;
  }
}
const INIT_STATE_UNINITIALIZED = 0, INIT_STATE_INITIALIZING = 1, INIT_STATE_INITIALIZED = 2, INIT_STATE_FAILED = 3;
let _globalId$1 = 1;
class TileProvider {
  constructor(i = {}) {
    _(this, "name", "TileProvider");
    _(this, "visible", !0);
    _(this, "_sourceProjection");
    _(this, "_targetProjection");
    _(this, "_quadtree");
    _(this, "_cache");
    _(this, "_grid");
    _(this, "_supportedTargetProjectionNames", []);
    _(this, "_supportAllProjections", !1);
    _(this, "_compatible", !1);
    _(this, "_initState", INIT_STATE_UNINITIALIZED);
    _(this, "_desiredUpperSampleLevel", 100);
    _(this, "_loadingUpperSampleLevel", 1);
    _(this, "_maxCacheSize", 1e3);
    _(this, "_maxLevel");
    _(this, "_minLevel");
    _(this, "_startLevel");
    _(this, "_shouldCheckTileAvailable", !1);
    _(this, "ignoreLoadingState", !1);
    _(this, "_requestingCount", 0);
    _(this, "_maxParallelRequestNum", 6);
    _(this, "enablePeriodRequestLog", !1);
    _(this, "_periodRequestLogCount", 0);
    _(this, "_periodRequestLogStartTime", 0);
    _(this, "_canUpsample", !1);
    _(this, "_useWebMeractorProjectionAndGrid", !1);
    _(this, "_requestDataVersion", 0);
    _(this, "_needsClearCache", !1);
    _(this, "_needsIncreTilesEpoch", !1);
    _(this, "handleRemove", (i, e) => {
      this.onTileDispose(i), i.state = TILE_STATE_DISPOSED, i.data = null, i.epoch++;
    });
    _(this, "_logRequestStart", () => {
      this.enablePeriodRequestLog && (this._requestingCount === 0 && (this._periodRequestLogCount = 0, this._periodRequestLogStartTime = performance.now()), this._periodRequestLogCount++);
    });
    _(this, "_logRequestEnd", () => {
      this.enablePeriodRequestLog && this._requestingCount === 0 && performance.now() - this._periodRequestLogStartTime;
    });
    _(this, "_markTileStateListenersNeedsUpdate", (i) => {
      for (const e of i._stateListenerObjects)
        e.needsUpdate = !0;
    });
    _(this, "_initOrUpdateTileStateListeners", (i, e) => {
      i._stateListenerObjects || (i._stateListenerObjects = []), i._stateListenerObjects.indexOf(e) < 0 && i._stateListenerObjects.push(e);
    });
    this._id = _globalId$1++, i.targetProjection && (this._targetProjection = i.targetProjection), i.minLevel !== void 0 && (this._minLevel = i.minLevel), i.maxLevel !== void 0 && (this._maxLevel = i.maxLevel), i.startLevel !== void 0 && (this._startLevel = i.startLevel), this._maxCacheSize = i.maxCacheSize || 800, this._needFallback = defaultValue$1(i.needFallback, !0), this.statistics = {
      loading: 0,
      cached: 0
    };
  }
  _init() {
    if (this._initState === INIT_STATE_UNINITIALIZED) {
      if (this._minLevel === void 0 && (this._minLevel = this._defaultMinLevel || 0), this._startLevel === void 0 && (this._startLevel = this._defaultStartLevel || 0), this._maxLevel === void 0 && (this._maxLevel = this._defaultMaxLevel || 1 / 0), this._initState = INIT_STATE_INITIALIZING, this._supportAllProjections || this._supportedTargetProjectionNames.indexOf(this._targetProjection.name) >= 0)
        this._compatible = !0;
      else {
        this._compatible = !1, console.warn(`${this.name}: not supported target projection ${this._targetProjection.name}, supported target projections: ${this._supportedTargetProjectionNames.join(",")}`), this._inited = !0, this._initState = INIT_STATE_FAILED;
        return;
      }
      this._cache = new LRUCache(this._maxCacheSize), this._asyncInit ? this._asyncInit().then(() => {
        this._inited = !0, this._initState = INIT_STATE_INITIALIZED, this._useWebMeractorProjectionAndGrid ? this._initWebMercatorProjectionAndGrid() : this.initProjectionAndGrid(), this._grid.initFromTileProvider(this), this._grid.update(), this._quadtree = new TileQuadtree(this._grid), this._engine.requestRender();
      }).catch((i) => {
        console.error(i), this._inited = !0, this._initState = INIT_STATE_FAILED;
      }) : (this._inited = !0, this._initState = INIT_STATE_INITIALIZED, this._useWebMeractorProjectionAndGrid ? this._initWebMercatorProjectionAndGrid() : this.initProjectionAndGrid(), this._grid.initFromTileProvider(this), this._grid.update(), this._quadtree = new TileQuadtree(this._grid));
    }
  }
  _initWebMercatorProjectionAndGrid() {
    this._sourceProjection = getProjection(PROJECTION_WEB_MERCATOR), this._grid = new WebMercatorGrid(this._engine, this._sourceProjection, this._targetProjection);
  }
  initProjectionAndGrid() {
    throw new Error(this.name + ": initProjectionAndGrid should be overriden in subclass or set _useWebMeractorProjectionAndGrid to true");
  }
  _freeResources() {
    this._cache = null, this._grid = null, this._quadtree = null;
  }
  beginFrame(i) {
    this._usedTilesNum = 0, this._usedTiles = {}, this._init(), this._needsClearCache && (this._clearCache(), this._needsClearCache = !1), this._needsIncreTilesEpoch && (this._increTilesEpoch(), this._needsIncreTilesEpoch = !1);
  }
  endFrame(i) {
    this._cache && (this._cache.scheduleUnload(), this.statistics.cached = this._cache.itemList.length);
  }
  isReady() {
    return this._initState === INIT_STATE_INITIALIZED;
  }
  onTileDispose(i) {
    console.warn("onTileDispose should be overriden in subclass");
  }
  async requestTileData(i, e) {
    if (!(i.z < this._minLevel) && this._initState === INIT_STATE_INITIALIZED) {
      if (!i) {
        window.__debug && console.warn("tile not found"), console.warn("tile not found");
        return;
      }
      if (e && this._initOrUpdateTileStateListeners(i, e), i.state !== TILE_STATE_LOADING) {
        if (i.state === TILE_STATE_COMPLETED) {
          this._markTileStateListenersNeedsUpdate(i);
          return;
        }
        if (i.geoIntersectionOfTargetProjection === Intersect$1.OUTSIDE) {
          i.state = TILE_STATE_COMPLETED, this._markTileStateListenersNeedsUpdate(i);
          return;
        } else
          i.geoIntersectionOfTargetProjection, Intersect$1.INTERSECT;
        if (i.state === TILE_STATE_FAILED)
          if (Date.now() - i._lastFailTime < 9e5) {
            if (i._failTimes > 2)
              return;
          } else
            i._failTimes = 0;
        if (!(this._requestingCount >= this._maxParallelRequestNum)) {
          this._logRequestStart(), this._requestingCount++;
          try {
            i.requestDataVersion = this._requestDataVersion, i.state = TILE_STATE_LOADING, this.statistics.loading++, this._markTileStateListenersNeedsUpdate(i), window.__debug;
            const r = await this.doRequestTileData(i, e);
            i.requestDataVersion === this._requestDataVersion && (i.data = r, i.state = TILE_STATE_COMPLETED, this._cache.add(i, this.handleRemove));
          } catch (r) {
            if (r && r.name === "AbortError") {
              i.state = TILE_STATE_CREATED;
              return;
            }
            i.state = TILE_STATE_FAILED, i._failTimes || (i._failTimes = 0), i._failTimes++, i._lastFailTime = Date.now(), console.warn(`tile ${i.key} load error in ${this.name}`, r);
          } finally {
            this._markTileStateListenersNeedsUpdate(i), this.statistics.loading--, this._requestingCount--, this._logRequestEnd();
          }
        }
      }
    }
  }
  getGroundTileData(i) {
    return null;
  }
  getTile(i, e, r, s, a) {
    if (!this._compatible)
      return null;
    let c = i, l = e, h = r, d = c - this._maxLevel;
    if (d > 0 && (c = this._maxLevel, l = e >> d, h = r >> d), this._shouldCheckTileAvailable) {
      for (; !this.isTileAvailable(c, l, h); )
        if (d++, c--, l = l >> 1, h = h >> 1, c < 0)
          return null;
    }
    this._canUpsample || (e = l, r = h, i = c);
    const f = this._quadtree.getTile(i, e, r, a.isRasterSurfaceTile);
    return this._canUpsample && i !== c | e !== l && r !== h && (f.needUpSample = !0), f ? (this._initOrUpdateTileStateListeners(f, a), f) : null;
  }
  markTileUsed(i) {
    this._usedTilesNum++, this._usedTiles[i.key] = !0, this._cache.markUsed(i);
  }
  _tileLevelInRange(i) {
    return i >= this._startLevel && i <= this._maxLevel;
  }
  computeCoverageTilesCoord(i) {
    const e = this._grid, r = i.grid, s = this._sourceProjection, a = r.targetProjection;
    return e.name === r.name && s.name === a.name && this._tileLevelInRange(i.z) ? [[i.z, i.x, i.y]] : this.grid.computeCoverageTilesCoord(
      i,
      Math.max(this._startLevel, this._minLevel),
      this.grid.maxLevel
    );
  }
  _clearCache() {
    this._cache && this._cache.clear(), this._requestDataVersion++;
  }
  _increTilesEpoch() {
    this._cache.foreachItem((i) => {
      i.epoch++;
    });
  }
  get id() {
    return this._id;
  }
  get maxCacheSize() {
    return this._maxCacheSize;
  }
  set maxCacheSize(i) {
    this._maxCacheSize = i;
  }
  get desiredUpperSampleLevel() {
    return this._desiredUpperSampleLevel;
  }
  set desiredUpperSampleLevel(i) {
    this._desiredUpperSampleLevel = i;
  }
  get loadingUpperSampleLevel() {
    return this._loadingUpperSampleLevel;
  }
  set loadingUpperSampleLevel(i) {
    this._loadingUpperSampleLevel = i;
  }
  get grid() {
    return this._grid;
  }
  get compatible() {
    return this._compatible;
  }
  get projection() {
    return this._sourceProjection;
  }
  get sourceProjection() {
    return this._sourceProjection;
  }
  get targetProjection() {
    return this._targetProjection;
  }
  set targetProjection(i) {
    this._targetProjection = i;
  }
  get initState() {
    return this._initState;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  set maxLevel(i) {
    this._maxLevel = i;
  }
  get minLevel() {
    return this._minLevel;
  }
  set minLevel(i) {
    this._minLevel = i;
  }
  get maxParallelRequestNum() {
    return this._maxParallelRequestNum;
  }
  set maxParallelRequestNum(i) {
    this._maxParallelRequestNum = i;
  }
  get cacheMaxSize() {
    return this._cache && this._cache.maxSize || 0;
  }
  set cacheMaxSize(i) {
    this._cache && this._cache.setMaxSize(i);
  }
}
const vertexShader$n = `#define GLSLIFY 1
#include <common>
varying vec2 vUv;

#include <logdepthbuf_pars_vertex>

void main() {

    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    #include <logdepthbuf_vertex>

}

`, fragmentShader$l = `#define GLSLIFY 1
#include <common>

varying vec2 vUv;

uniform float opacity;

#include <logdepthbuf_pars_fragment>

#if NUM_TEXTURES > 0
    uniform sampler2D diffuseTextures[NUM_TEXTURES];
    uniform vec4 textureTranslationAndScales[NUM_TEXTURES];
    uniform vec4 colorAdjustments[NUM_TEXTURES];
    uniform vec4 boundingRect;
#endif

vec4 sampleAndBlendColor(vec4 oldColor, sampler2D sampleTexture, vec4 translationAndScale, vec4 colorAdjustment) {
    vec2 transformedUv = clamp(vUv, vec2(0.0), vec2(1.0));
    transformedUv *= translationAndScale.zw;
    transformedUv -= translationAndScale.xy;
    if (transformedUv.x < 0.0 || transformedUv.y < 0.0 || transformedUv.x > 1.0 || transformedUv.y > 1.0) {
        return oldColor;
    }
    vec4 sampleColor = texture2D(sampleTexture, transformedUv);
    sampleColor *= colorAdjustment;
    // sampleColor.a *= colorAdjustment.a;
    vec3 mixColor = mix(oldColor.rgb, sampleColor.rgb, sampleColor.a);
    return vec4(mixColor, oldColor.a + sampleColor.a);
}
void main() {

    // gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);
    // return;
    #if NUM_TEXTURES > 0
        if (boundingRect.x > -0.5 && (vUv.x < boundingRect.x || vUv.y < boundingRect.y || vUv.x > boundingRect.z || vUv.y > boundingRect.w)) {
            discard;
        }

    #endif
   
    vec4 color = vec4(0);

    #if NUM_TEXTURES > 0
        color = sampleAndBlendColor(color, diffuseTextures[0], textureTranslationAndScales[0], colorAdjustments[0]);
    #endif
    #if NUM_TEXTURES > 1
        color = sampleAndBlendColor(color, diffuseTextures[1], textureTranslationAndScales[1], colorAdjustments[1]);
    #endif
    #if NUM_TEXTURES > 2
        color = sampleAndBlendColor(color, diffuseTextures[2], textureTranslationAndScales[2], colorAdjustments[2]);
    #endif
    #if NUM_TEXTURES > 3
        color = sampleAndBlendColor(color, diffuseTextures[3], textureTranslationAndScales[3], colorAdjustments[3]);
    #endif
    #if NUM_TEXTURES > 4
        color = sampleAndBlendColor(color, diffuseTextures[4], textureTranslationAndScales[4], colorAdjustments[4]);
    #endif
    #if NUM_TEXTURES > 5
        color = sampleAndBlendColor(color, diffuseTextures[5], textureTranslationAndScales[5], colorAdjustments[5]);
    #endif
    #if NUM_TEXTURES > 6
        color = sampleAndBlendColor(color, diffuseTextures[6], textureTranslationAndScales[6], colorAdjustments[6]);
    #endif
    #if NUM_TEXTURES > 7
        color = sampleAndBlendColor(color, diffuseTextures[7], textureTranslationAndScales[7], colorAdjustments[7]);
    #endif
    #if NUM_TEXTURES > 8
        color = sampleAndBlendColor(color, diffuseTextures[8], textureTranslationAndScales[8], colorAdjustments[8]);
    #endif
    #if NUM_TEXTURES > 9
        color = sampleAndBlendColor(color, diffuseTextures[9], textureTranslationAndScales[9], colorAdjustments[9]);
    #endif
    #if NUM_TEXTURES > 10
        color = sampleAndBlendColor(color, diffuseTextures[10], textureTranslationAndScales[10], colorAdjustments[10]);
    #endif
    #if NUM_TEXTURES > 11
        color = sampleAndBlendColor(color, diffuseTextures[11], textureTranslationAndScales[11], colorAdjustments[11]);
    #endif
    #if NUM_TEXTURES > 12
        color = sampleAndBlendColor(color, diffuseTextures[12], textureTranslationAndScales[12], colorAdjustments[12]);
    #endif
    #if NUM_TEXTURES > 13
        color = sampleAndBlendColor(color, diffuseTextures[13], textureTranslationAndScales[13], colorAdjustments[13]);
    #endif
    #if NUM_TEXTURES > 14
        color = sampleAndBlendColor(color, diffuseTextures[14], textureTranslationAndScales[14], colorAdjustments[14]);
    #endif
    #if NUM_TEXTURES > 15
        color = sampleAndBlendColor(color, diffuseTextures[15], textureTranslationAndScales[15], colorAdjustments[15]);
    #endif
    #if NUM_TEXTURES > 16
        color = sampleAndBlendColor(color, diffuseTextures[16], textureTranslationAndScales[16], colorAdjustments[16]);
    #endif

    gl_FragColor = color;
    // gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);

    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}

`, uniforms$m = UniformsUtils.merge([
  {
    opacity: { value: 1 },
    diffuseTextures: { value: null },
    textureTranslationAndScales: { value: null },
    colorAdjustments: { value: null },
    boundingRect: { value: new Vector4() }
  }
]);
class RasterSurfaceMaterial extends ShaderMaterial {
  constructor(e = {}) {
    super();
    _(this, "updateTextures", (e, r) => {
      let s = [], a = [], c = [];
      for (const l of e) {
        s.push(l.texture), a.push(new Vector4(
          l.offsetX,
          l.offsetY,
          l.scaleX,
          l.scaleY
        ));
        const h = l.colorTint;
        c.push(new Vector4(h[0], h[1], h[2], l.opacity));
      }
      this.uniforms.boundingRect.value.fromArray(r), this.uniforms.diffuseTextures.value = s, this.uniforms.textureTranslationAndScales.value = a, this.uniforms.colorAdjustments.value = c, this.defines.NUM_TEXTURES !== e.length && (this.defines.NUM_TEXTURES = e.length, this.needsUpdate = !0);
    });
    _(this, "forceUpdateTextureCount", (e) => {
      this.defines.NUM_TEXTURES = e, this.needsUpdate = !0;
    });
    this.name = "RasterSurfaceMaterial", this.fragmentShader = fragmentShader$l, this.vertexShader = vertexShader$n, this.defines = {
      NUM_TEXTURES: 0
    }, this.uniforms = UniformsUtils.clone(uniforms$m), e.textures && this.updateTextures(e.textures, e.boundRect);
  }
  get textureCount() {
    return this.defines.NUM_TEXTURES;
  }
  dispose() {
    super.dispose();
  }
}
const sharedRasterMaterials = {}, getSharedRasterMaterial = (o) => {
  if (!sharedRasterMaterials[o]) {
    const i = new RasterSurfaceMaterial();
    i.name = "RasterSurfaceMaterial_" + o, i.forceUpdateTextureCount(o), i.onBeforeRender = function(e, r, s, a, c, l) {
      c.userData._boundingRect && (i.uniforms.boundingRect.value = c.userData._boundingRect, i.uniforms.diffuseTextures.value = c.userData._diffuseTextures, i.uniforms.textureTranslationAndScales.value = c.userData._textureTranslationAndScales, i.uniforms.colorAdjustments.value = c.userData._colorAdjustments, i.uniformsNeedUpdate = !0);
    }, sharedRasterMaterials[o] = i;
  }
  return sharedRasterMaterials[o];
}, bindMaterialInfoToMesh = (o, i, e) => {
  let r = [], s = [], a = [];
  for (const c of i) {
    r.push(c.texture), s.push(new Vector4(
      c.offsetX,
      c.offsetY,
      c.scaleX,
      c.scaleY
    ));
    const l = c.colorTint;
    a.push(new Vector4(l[0], l[1], l[2], c.opacity));
  }
  o.userData._boundingRect = new Vector4().fromArray(e), o.userData._diffuseTextures = r, o.userData._textureTranslationAndScales = s, o.userData._colorAdjustments = a;
};
class OrientedBoundingBoxHelper extends LineSegments {
  constructor(i, e = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), s = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], a = new BufferGeometry();
    a.setIndex(new BufferAttribute(r, 1)), a.setAttribute("position", new Float32BufferAttribute(s, 3)), super(a, new LineBasicMaterial({ color: e, toneMapped: !1 })), this.obb = i, this.type = "OrientedBoundingBoxHelper", this.needsUpdateOBB = !0;
  }
  setOBB(i, e) {
    this.obb.center.copy(i), this.obb.halfAxes.copy(e), this.needsUpdateOBB = !0;
  }
  updateMatrixWorld(i) {
    if (this.needsUpdateOBB || i) {
      this.needsUpdateOBB = !1;
      const e = this.obb.center, r = this.obb.halfAxes;
      this.position.copy(e);
      const s = new Vector3$1(), a = new Matrix4();
      for (let c = 0; c < 3; c++) {
        let l = c * 3;
        const h = new Vector3$1(
          r.elements[l],
          r.elements[l + 1],
          r.elements[l + 2]
        );
        s.setComponent(c, h.length()), h.normalize(), l = c * 4, a.elements[l] = h.x, a.elements[l + 1] = h.y, a.elements[l + 2] = h.z;
      }
      this.scale.copy(s), this.quaternion.setFromRotationMatrix(a);
    }
    super.updateMatrixWorld(i);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class SurfaceTile {
  constructor(i) {
    this.tile = i;
  }
  get boxHelper() {
    return this._boxHelper || (this.tile.boundingRegion ? this._boxHelper = new OrientedBoundingBoxHelper(
      this.tile.boundingRegion._orientedBoundingBox,
      16711680
    ) : this.tile.targetBoundingBox ? this._boxHelper = new Box3Helper(this.tile.targetBoundingBox, 16711680) : console.warn("No bounding box")), this._boxHelper;
  }
}
const DATA_STATE_UNRENDERABLE$1 = 0, DATA_STATE_CAN_RENDER = 1, DATA_STATE_STABLE$1 = 2;
class RasterSurfaceTileManager extends SurfaceTileManager {
  constructor() {
    super(...arguments);
    _(this, "_tiles", /* @__PURE__ */ new WeakMap());
    _(this, "_layersKey", "");
  }
  beginFrame(e) {
    const r = this._surface.terrainProvider, s = this._surface.imageryProviders, a = [];
    a.push(r.id + "#" + r.visible);
    for (const l of s)
      a.push(l.id + "#" + l.visible);
    const c = a.join("|");
    c !== this._layersKey && (this.clear(), this._layersKey = c);
  }
  endFrame(e) {
  }
  forceUpdateTileState(e) {
    const r = this._tiles.get(e);
    !r || (r.needsUpdate = !0, this._updateSurfaceTileData(r));
  }
  isTileComputable(e, r) {
    const s = this._tiles.get(e);
    return s ? (s.frameCount !== r.frameCount && (this._updateSurfaceTileData(s), s.frameCount = r.frameCount), s.terrainTile && s.terrainTile.state === TILE_STATE_COMPLETED) : !1;
  }
  isTileRenderable(e, r) {
    const s = this._tiles.get(e);
    return s ? (s.frameCount !== r.frameCount && (this._updateSurfaceTileData(s), s.frameCount = r.frameCount), s.state !== DATA_STATE_UNRENDERABLE$1) : !1;
  }
  isTileStable(e, r) {
    const s = this._tiles.get(e);
    return s ? (s.frameCount !== r.frameCount && (this._updateSurfaceTileData(s), s.frameCount = r.frameCount), s.state === DATA_STATE_STABLE$1) : !1;
  }
  markTileUsed(e) {
    const r = this._tiles.get(e);
    if (!r)
      return null;
    const s = this._surface.terrainProvider, a = r.terrainTile;
    a && s.markTileUsed(a);
    const c = r.imageryTiles, l = this._surface.imageryProviders;
    for (let h = 0; h < c.length; ++h) {
      const d = c[h];
      if (!d)
        continue;
      const f = l[h];
      if (!!f.visible)
        for (let p = 0; p < d.length; ++p) {
          const m = d[p];
          !m || f.markTileUsed(m);
        }
    }
  }
  getSurfaceTile(e, r) {
    const s = this._tiles.get(e);
    if (!s)
      return null;
    if (s.frameCount !== r.frameCount && (this._updateSurfaceTileData(s), s.frameCount = r.frameCount), s.state !== DATA_STATE_UNRENDERABLE$1)
      return s;
  }
  _updateSurfaceTileData(e) {
    e.needsUpdate = !1, e.state;
    const r = e.terrainTile;
    if (!r) {
      console.error("terrainTile is undefined", e);
      return;
    }
    if (r.state !== TILE_STATE_COMPLETED) {
      e.state = DATA_STATE_UNRENDERABLE$1, this._surface.quadMap._engine.requestRender();
      return;
    }
    const s = e.imageryTiles, a = this._surface.imageryProviders;
    let c = 0, l = 0, h = 0;
    const d = [], f = [];
    for (let y = 0; y < s.length; ++y) {
      const x = s[y], v = a[y];
      if (v.ignoreLoadingState && h++, !x || !v.compatible) {
        d.push(""), c++;
        continue;
      }
      let S = !1, E = !1;
      for (let b = 0; b < x.length; ++b) {
        const w = x[b];
        if (!!w)
          if (w.state === TILE_STATE_COMPLETED) {
            v.markTileUsed(w);
            const M = this._getTileCoordConfig(r, w);
            f.push({
              texture: w.data,
              opacity: v.opacity,
              colorTint: v.randomColorTint ? [Math.random(), Math.random(), Math.random()] : v.colorTint,
              ...M
            }), d.push(w.key + "#" + w.epoch);
          } else {
            let M = this._getUpperSampleReadyTile(w, v);
            if (M) {
              v.markTileUsed(M);
              const P = this._getTileCoordConfig(r, M);
              f.push({
                texture: M.data,
                opacity: v.opacity,
                colorTint: v.randomColorTint ? [Math.random(), Math.random(), Math.random()] : v.colorTint,
                ...P
              }), d.push(M.key + "#" + M.epoch), S = !0;
            } else
              d.push(""), E = !0;
          }
      }
      E && f.length === 0 ? l++ : S || c++;
    }
    const p = d.join("|");
    let m = DATA_STATE_CAN_RENDER;
    if (s.length === 0 || c > 0 && c === a.length ? m = DATA_STATE_STABLE$1 : l + h === a.length && (m = DATA_STATE_UNRENDERABLE$1), m === DATA_STATE_UNRENDERABLE$1) {
      e.state = m, e.loadStateKey = p;
      return;
    }
    if (e.object === void 0) {
      const y = r.data;
      if (y) {
        const x = getSharedRasterMaterial(f.length), v = new Mesh(y, x);
        bindMaterialInfoToMesh(v, f, e.terrainBoundRect), v.position.copy(r.targetCenter), y._heights && !e.tile._heights && e.tile.grid.updateTileHeights(e.tile, y._heights), v.frustumCulled = !1, v.isTerrainTile = !0, e.object = v;
      } else
        e.object = null;
    } else if (p !== e.loadStateKey) {
      const y = e.object;
      if (y) {
        const x = getSharedRasterMaterial(f.length);
        y.material = x, bindMaterialInfoToMesh(y, f, e.terrainBoundRect);
      }
    }
    e.state = m, e.loadStateKey = p;
  }
  _getTileCoordConfig(e, r) {
    const s = e.grid, a = r.grid, c = s.rasterProjection, l = a.sourceProjection;
    if (c.name === l.name && s.name === a.name && e.z === r.z && e.x === r.x && e.y === r.y)
      return {
        offsetX: 0,
        offsetY: 0,
        scaleX: 1,
        scaleY: 1
      };
    let h = null, d = null;
    c.isGeo ? (h = r.geoBoundingBox, d = e.geoBoundingBox) : (h = r.targetBoundingBox, d = e.targetBoundingBox);
    const f = (d.max.x - d.min.x) / (h.max.x - h.min.x), p = (d.max.y - d.min.y) / (h.max.y - h.min.y), m = (h.min.x - d.min.x) / (h.max.x - h.min.x), y = (h.min.y - d.min.y) / (h.max.y - h.min.y);
    return {
      offsetX: m,
      offsetY: y,
      scaleX: f,
      scaleY: p
    };
  }
  _getUpperSampleReadyTile(e, r) {
    let s = r.loadingUpperSampleLevel;
    if (s === 0)
      return null;
    for (e = e.parent; s > 0 && e; ) {
      if (e.state === TILE_STATE_COMPLETED)
        return e;
      e = e.parent, s--;
    }
    return null;
  }
  _getCoverageTilesFromProvider(e, r) {
    return r.computeCoverageTilesCoord(e);
  }
  _onlyRequestTileContents(e, r = !1) {
    const s = e.terrainTile, a = e.imageryTiles, c = this._surface.terrainProvider, l = this._surface.imageryProviders;
    if (s && c.requestTileData(s, e), !r)
      for (let h = 0; h < a.length; ++h) {
        const d = a[h];
        if (!d)
          continue;
        const f = l[h];
        for (let p = 0; p < d.length; ++p) {
          const m = d[p];
          m && f.requestTileData(m, e);
        }
      }
  }
  requestSurfaceTile(e, r = !1) {
    if (this._tiles.has(e)) {
      const f = this._tiles.get(e);
      if (f.needsUpdate && this._updateSurfaceTileData(f), r) {
        f.state !== DATA_STATE_CAN_RENDER && f.state !== DATA_STATE_STABLE$1 && this._onlyRequestTileContents(f, !0);
        return;
      }
      f.state !== DATA_STATE_STABLE$1 && this._onlyRequestTileContents(f);
      return;
    }
    const s = this._surface, a = s.terrainProvider;
    if (a.initState !== INIT_STATE_INITIALIZED)
      return;
    const c = s.imageryProviders;
    for (const f of c)
      if (f.initState !== INIT_STATE_INITIALIZED && f.initState !== INIT_STATE_FAILED)
        return;
    const l = new SurfaceTile(e);
    l.isRasterSurfaceTile = !0, l.state = DATA_STATE_UNRENDERABLE$1;
    const h = a.getTile(e.z, e.x, e.y, e, l);
    l.terrainBoundRect = a.grid.computeTileCoverageRect(h, e), a.requestTileData(h, l), l.terrainTile = h;
    const d = [];
    for (const f of c) {
      if (!f.compatible || !f.visible) {
        d.push(null);
        continue;
      }
      const p = this._getCoverageTilesFromProvider(e, f), m = [];
      for (const y of p) {
        const x = f.getTile(y[0], y[1], y[2], e, l);
        !x || (m.push(x), r || f.requestTileData(x, l));
      }
      d.push(m);
    }
    l.imageryTiles = d, r && (l.needsUpdate = !0), this._tiles.set(e, l);
  }
  clear() {
    this._tiles = /* @__PURE__ */ new WeakMap();
  }
  dispose() {
  }
}
class RasterSurface extends MapSurface {
  constructor(e, r, s = {}) {
    super(s);
    _(this, "name", "RasterSurface");
    _(this, "isMapRasterSurface", !0);
    this._terrainProvider = e, this._imageryProviders = r || [], this._surfaceTileManager = new RasterSurfaceTileManager(this), this.strategy || (this.strategy = new HierarchicalTileLoaderStrategy(s));
  }
  addImageryLayer(e) {
    this._imageryProviders.push(e);
  }
  removeImageryLayer(e) {
    const r = this._imageryProviders.indexOf(e);
    r > -1 && this._imageryProviders.splice(r, 1);
  }
  _getCurrentGrid() {
    return this._terrainProvider.grid;
  }
  _updateMaxLevel() {
    let e = 0;
    this._terrainProvider && this._terrainProvider.maxLevel !== 1 / 0 && (e = Math.max(e, this._terrainProvider.maxLevel));
    for (let r = 0; r < this._imageryProviders.length; ++r)
      this._imageryProviders[r].ignoreLevelLimit || this._imageryProviders[r].maxLevel !== 1 / 0 && (e = Math.max(e, this._imageryProviders[r].maxLevel));
    this._maxLevel = e, this._minLevel = this._terrainProvider.minLevel;
  }
  beginFrame(e) {
    if (super.beginFrame(e), !this._terrainProvider)
      return !1;
    const r = this._quadMap._engine, s = r.map.projection, a = r.map.coordType;
    let c = null;
    if (this._terrainProvider && (this._terrainProvider._engine = r, this._terrainProvider.targetProjection = s, this._terrainProvider.targetCoordType = a, this._terrainProvider.beginFrame(e), c = this._terrainProvider.rasterProjection, this._terrainProvider.isReady()))
      for (let l = 0; l < this._imageryProviders.length; ++l)
        this._imageryProviders[l]._engine = r, this._imageryProviders[l].targetProjection = c, this._imageryProviders[l].targetCoordType = a, this._imageryProviders[l].beginFrame(e);
    this._updateMaxLevel();
  }
  endFrame(e) {
    this._terrainProvider && this._terrainProvider.endFrame(e);
    for (let r = 0; r < this._imageryProviders.length; ++r)
      this._imageryProviders[r].endFrame(e);
    super.endFrame(e);
  }
  get terrainProvider() {
    return this._terrainProvider;
  }
  set terrainProvider(e) {
    this._terrainProvider !== e && (this._terrainProvider && this.clearTilesInView(), this._terrainProvider = e, this._surfaceTileManager.clear(), this._quadMap._engine.requestRender());
  }
  get imageryProviders() {
    return this._imageryProviders;
  }
  set imageryProviders(e) {
    this._imageryProviders = e, this._surfaceTileManager.clear(), this._quadMap._engine.requestRender();
  }
}
const DATA_STATE_UNRENDERABLE = 0, DATA_STATE_STABLE = 2;
class VectorSurfaceTileManager extends SurfaceTileManager {
  constructor() {
    super(...arguments);
    _(this, "_tiles", /* @__PURE__ */ new WeakMap());
  }
  isTileRenderable(e, r) {
    const s = this._tiles.get(e);
    return s ? (s.frameCount !== r.frameCount && (this._updateSurfaceTileData(s), s.frameCount = r.frameCount), s.state !== DATA_STATE_UNRENDERABLE) : !1;
  }
  markTileUsed(e) {
    const r = this._tiles.get(e);
    if (!r)
      return null;
    const s = this._surface.tileProvider, a = r.dataTile;
    a && s.markTileUsed(a);
  }
  isTileComputable(e, r) {
    const s = this._tiles.get(e);
    return s ? (s.frameCount !== r.frameCount && (this._updateSurfaceTileData(s), s.frameCount = r.frameCount), s.dataTile && s.dataTile.state === TILE_STATE_COMPLETED) : !1;
  }
  isTileStable(e, r) {
    const s = this._tiles.get(e);
    return s ? (s.frameCount !== r.frameCount && (this._updateSurfaceTileData(s), s.frameCount = r.frameCount), s.state === DATA_STATE_STABLE) : !1;
  }
  _updateSurfaceTileData(e) {
    e.needsUpdate = !1;
    const r = e.dataTile, s = this._surface.quadMap._engine;
    if (r.state !== TILE_STATE_COMPLETED) {
      e.state = DATA_STATE_UNRENDERABLE, s.requestRender();
      return;
    }
    e.state = DATA_STATE_STABLE;
    const a = r.data;
    if (a && a[0]) {
      const c = a[0];
      e.object = c;
    }
    if (a && a[1]) {
      const c = a[1];
      e.groundObject = c;
    }
  }
  getSurfaceTile(e, r) {
    const s = this._tiles.get(e);
    if (!s)
      return null;
    if (s.frameCount !== r.frameCount && (this._updateSurfaceTileData(s), s.frameCount = r.frameCount), s.state !== DATA_STATE_UNRENDERABLE)
      return s;
  }
  _onlyRequestTileContents(e) {
    const r = e.dataTile, s = this._surface.tileProvider;
    r && s.requestTileData(r, e);
  }
  cancelSurfaceTiles(e) {
    const r = [];
    for (let a = 0; a < e.length; a++) {
      const c = e[a], l = this._tiles.get(c);
      !l || l.dataTile && r.push(c);
    }
    const s = this._surface.tileProvider;
    s.cancelTiles && s.cancelTiles(r);
  }
  requestSurfaceTile(e) {
    if (this._tiles.has(e)) {
      const l = this._tiles.get(e);
      l.needsUpdate && this._updateSurfaceTileData(l), l.state !== DATA_STATE_STABLE && this._onlyRequestTileContents(l);
      return;
    }
    const s = this._surface.tileProvider;
    if (s.initState !== INIT_STATE_INITIALIZED)
      return;
    const a = new SurfaceTile(e);
    a.state = DATA_STATE_UNRENDERABLE;
    const c = s.getTile(e.z, e.x, e.y, null, a);
    s.requestTileData(c, a), a.dataTile = c, this._tiles.set(e, a);
  }
  clear() {
    this._tiles = /* @__PURE__ */ new WeakMap();
  }
  dispose() {
  }
}
class VectorSurface extends MapSurface {
  constructor(e, r = {}) {
    super(r);
    _(this, "name", "VectorSurface");
    _(this, "isMapVectorSurface", !0);
    _(this, "_useTargetProjectionBoundingBox", !0);
    _(this, "_onTileCreated", (e) => {
    });
    this._tileProvider = e, this._surfaceTileManager = new VectorSurfaceTileManager(this), this.strategy || (this.strategy = new FastTileLoaderStrategy(r));
  }
  _getCurrentGrid() {
    return this._tileProvider.grid;
  }
  beginFrame(e) {
    if (super.beginFrame(e), !this._tileProvider)
      return !1;
    const r = this._quadMap._engine, s = r.map.projection, a = r.map.coordType;
    this._tileProvider && (this._shouldRenderPlaceholder = this._tileProvider._shouldRenderPlaceholder, this._placeholderColor = this._tileProvider._placeholderColor, this._tileProvider._engine = r, this._tileProvider.targetProjection = s, this._tileProvider.targetCoordType = a, this._tileProvider.beginFrame(e)), this._maxLevel = this._tileProvider.maxLevel, this._minLevel = this._tileProvider.minLevel;
  }
  endFrame(e) {
    super.endFrame(e);
  }
  onSurfaceTileAdded(e) {
    this._tileProvider.onSurfaceTileAdded && this._tileProvider.onSurfaceTileAdded(e, this.engine);
  }
  onSurfaceTileRemoved(e) {
    this._tileProvider.onSurfaceTileRemoved && this._tileProvider.onSurfaceTileRemoved(e, this.engine);
  }
  onSurfaceTileRefresh(e) {
    this._tileProvider.onSurfaceTileRefresh && this._tileProvider.onSurfaceTileRefresh(e, this.engine);
  }
  onSurfaceTileSSEChanged(e) {
    this._tileProvider.onSurfaceTileSSEChanged && this._tileProvider.onSurfaceTileSSEChanged(e, this.engine);
  }
  dispose() {
    super.dispose();
  }
  get tileProvider() {
    return this._tileProvider;
  }
  set tileProvider(e) {
    this._tileProvider !== e && (this._tileProvider && this.clearTilesInView(), this._tileProvider = e, this._surfaceTileManager.clear(), this._quadMap._engine.requestRender());
  }
}
class TerrainTileProvider extends TileProvider {
  async doRequestTileData(i) {
  }
  onTileDispose(i) {
    const e = i.data;
    e && e.dispose();
  }
}
TerrainTileProvider.heightmapTerrainQuality = 0.25;
TerrainTileProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function(o, i, e) {
  return o.maximumRadius * 2 * Math.PI * TerrainTileProvider.heightmapTerrainQuality / (i * e);
};
class GeoGrid extends Grid {
  constructor() {
    super(...arguments);
    _(this, "name", MAP_GRID_NAME_GEO);
    _(this, "_useGeoSubdivision", !0);
    _(this, "_minLevel", 1);
  }
  getRootTiles() {
    const e = new MapTile(this, 1, 0, 0);
    e.geoBoundingBox = new Box3(new Vector3$1(-180, -90, -0.1), new Vector3$1(0, 90, 0.1)), e.projectedBoundingBox = new Box3(
      new Vector3$1(-180, -90, 0),
      new Vector3$1(0, 90, 0)
    );
    const r = new MapTile(this, 1, 1, 0);
    return r.geoBoundingBox = new Box3(new Vector3$1(0, -90, -0.1), new Vector3$1(180, 90, 0.1)), r.projectedBoundingBox = new Box3(
      new Vector3$1(0, -90, 0),
      new Vector3$1(180, 90, 0)
    ), [e, r];
  }
  getTileReverseY(e) {
    return Math.pow(2, e.z - 1) - e.y - 1;
  }
  getTileSizeAtLevel(e) {
    return 360 / Math.pow(2, e);
  }
  getTileCoordX(e, r) {
    return (e + 180) / r;
  }
  getTileCoordY(e, r) {
    return (e + 90) / r;
  }
}
new Vector3$1();
new Vector3$1();
class PlaneTerrainTileProvider extends TerrainTileProvider {
  constructor() {
    super(...arguments);
    _(this, "name", "PlaneTerrainTileProvider");
    _(this, "_supportedTargetProjectionNames", [
      PROJECTION_WEB_MERCATOR,
      PROJECTION_ECEF,
      PROJECTION_GEO
    ]);
    _(this, "_supportAllProjections", !0);
    _(this, "_levelZeroMaximumGeometricError", TerrainTileProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(
      Ellipsoid.WGS84,
      64,
      2
    ));
  }
  initProjectionAndGrid() {
    this._targetProjection.name === PROJECTION_WEB_MERCATOR ? (this._sourceProjection = this._targetProjection, this._grid = new WebMercatorGrid(this._engine, this._sourceProjection, this._targetProjection)) : (this._sourceProjection = getProjection(PROJECTION_GEO), this._grid = new GeoGrid(this._engine, this._sourceProjection, this._targetProjection));
    const e = this._targetProjection.name;
    let r = null;
    e === PROJECTION_WEB_MERCATOR ? r = getProjection(PROJECTION_WEB_MERCATOR) : r = getProjection(PROJECTION_GEO), this.rasterProjection = r, this._grid.rasterProjection = r;
  }
  doRequestTileData(e) {
    const r = {
      x: e.x,
      y: e.y,
      z: e.z,
      targetProjection: this._targetProjection,
      sourceProjection: this._sourceProjection,
      targetProjectionName: this._targetProjection.name,
      sourceProjectionName: this._sourceProjection.name,
      targetCenter: this._vectorToArray(e.targetCenter),
      geoBoundingBox: this._boxToArray(e.geoBoundingBox),
      forceProjectCoordinates: !0,
      projectedBoundingBox: e.projectedBoundingBox.isBox3 ? this._boxToArray(e.projectedBoundingBox) : []
    }, s = createGroundTileMesh(r, {}), a = new BufferGeometry();
    return a.setIndex(s.indices), a.setAttribute("position", new Float32BufferAttribute(s.vertices, 3)), a.setAttribute("normal", new Float32BufferAttribute(s.normals, 3)), a.setAttribute("uv", new Float32BufferAttribute(s.uvs, 2)), a;
  }
  _vectorToArray(e) {
    return [e.x, e.y, e.z];
  }
  _boxToArray(e) {
    return [e.min.x, e.min.y, e.min.z, e.max.x, e.max.y, e.max.z];
  }
}
const _copyVector = new Vector2$1(), _currentClearColor$1 = new Color(0);
let _currentClearAlpha$1 = 1, _currentAutoClear$1 = !0;
const vertexShader$m = `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`, fragmentShader$k = `
    uniform sampler2D baseMap;
    uniform sampler2D labelMap;
    uniform float labelIndex;
    varying vec2 vUv;
    void main() {
        if (vUv.x < 0.004 || vUv.x > 0.996 || vUv.y < 0.004 || vUv.y > 0.996) {
            gl_FragColor = vec4(0, 0.7, 0, 1.0);
        }
        else {
            vec4 baseColor = texture2D(baseMap, vUv);
            vec2 labelUv = vec2(vUv.x, vUv.y * 10.0 - labelIndex);
            if (labelUv.y >= 0.0 && labelUv.y <= 1.0) {
                vec4 labelColor = texture2D(labelMap, labelUv);
                baseColor = mix(baseColor, labelColor, labelColor.a);
            }
            gl_FragColor = baseColor;
            // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
    }
`;
class ImageTileLabelRenderer {
  static _initResource() {
    this._renderTarget = new WebGLRenderTarget(512, 512), this._renderTarget.name = "ImageTileLabelRenderer", this._renderTarget.texture.name = "ImageTileLabelRenderer", this._camera = new OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0, 1);
    const i = new PlaneGeometry(1, 1, 1), e = new ShaderMaterial({
      vertexShader: vertexShader$m,
      fragmentShader: fragmentShader$k,
      uniforms: {
        baseMap: { value: null },
        labelMap: { value: null },
        labelIndex: { value: 0 }
      },
      transparent: !0
    });
    this._mesh = new Mesh(i, e);
    const r = this._canvas = document.createElement("canvas");
    r.width = 256, r.height = 32;
    const s = this._ctx = r.getContext("2d");
    s.fillStyle = "rgba(0, 180, 0, 1)", s.font = "16px arial", s.textBaseline = "bottom", s.shadowColor = "rgba(255, 255, 255, 1)", s.shadowBlur = 0, s.shadowOffsetX = 1, s.shadowOffsetY = 1;
    const a = this._canvasTexture = new CanvasTexture(r);
    e.uniforms.labelMap.value = a;
  }
  static render(i, e, r) {
    this._renderTarget || this._initResource();
    const s = i.getRenderTarget();
    i.getClearColor(_currentClearColor$1), _currentClearAlpha$1 = i.getClearAlpha(), _currentAutoClear$1 = i.autoClear;
    const a = this._camera;
    let c = 256, l = 256;
    e.image && (c = e.image.width, l = e.image.height);
    const h = this._renderTarget;
    (h.width !== c || h.height !== l) && h.setSize(c, l);
    const d = this._canvas, f = this._ctx;
    f.clearRect(0, 0, d.width, d.height), f.fillText(r.key, 0, 32), this._canvasTexture.needsUpdate = !0, i.setRenderTarget(h), i.autoClear = !1, i.clear();
    const p = this._mesh.material;
    p.uniforms.baseMap.value = e, i.render(this._mesh, a);
    const m = new FramebufferTexture(c, l);
    return m.minFilter = LinearFilter, m.magFilter = LinearFilter, i.copyFramebufferToTexture(m, _copyVector), i.setRenderTarget(s), i.setClearColor(_currentClearColor$1, _currentClearAlpha$1), i.autoClear = _currentAutoClear$1, m;
  }
}
class BaseImageryTileProvider extends TileProvider {
  constructor(e = {}) {
    super(e);
    _(this, "_loadingUpperSampleLevel", 100);
    _(this, "isBaseImageryTileProvider", !0);
    _(this, "name", "BaseImageryTileProvider");
    _(this, "_opacity", 1);
    _(this, "_colorTint", [1, 1, 1]);
    _(this, "_randomColorTint", !1);
    _(this, "_addDebugLabel", !1);
    this._opacity = e.opacity, this._colorTint = e.colorTint || [1, 1, 1], this._randomColorTint = e.randomColorTint || !1, this._placeholderColor = e.placeholderColor, this._opacity === void 0 && (this._opacity = 1);
  }
  async doRequestTileData(e, r) {
    const s = await this.doRequestImageTileData(e, r);
    return this._addDebugLabel ? ImageTileLabelRenderer.render(this._engine.renderer, s, e) : s;
  }
  set opacity(e) {
    this._opacity = e, this._needsIncreTilesEpoch = !0;
  }
  get opacity() {
    return this._opacity;
  }
  set colorTint(e) {
    this._colorTint = e, this._needsIncreTilesEpoch = !0;
  }
  get colorTint() {
    return this._colorTint;
  }
  set randomColorTint(e) {
    this._randomColorTint !== e && (this._randomColorTint = e, this._needsClearCache = !0);
  }
  get randomColorTint() {
    return this._randomColorTint;
  }
  set addDebugLabel(e) {
    this._addDebugLabel !== e && (this._addDebugLabel = e, this._needsClearCache = !0);
  }
  get addDebugLabel() {
    return this._addDebugLabel;
  }
}
const vertexShader$l = `
// attribute vec3 position;
// attribute vec2 uv;
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`, fragmentShader$j = `
uniform sampler2D map;
uniform vec3 color;
varying vec2 vUv;
void main() {
    gl_FragColor = texture2D(map, vUv);
    // gl_FragColor = vec4(color, 1.0);
}
`;
class ImageryReprojectMaterial extends ShaderMaterial {
  constructor(i = {}) {
    super(), this.name = "ImageryReprojectMaterial", this.fragmentShader = fragmentShader$j, this.vertexShader = vertexShader$l, this.uniforms = {
      map: {
        value: null
      },
      color: {
        value: new Vector3$1(1, 1, 1)
      }
    };
  }
  dispose() {
    super.dispose();
  }
}
const _camera = new OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0, 1), _vector$4 = new Vector2$1(), _tempInput = new Vector3$1(), _tempOutput = new Vector3$1();
class ImageryReprojector {
  _initResource() {
    this._renderTarget = new WebGLRenderTarget(256, 256), this._renderTarget.name = "ImageryReprojector", this._renderTarget.texture.name = "ImageryReprojector";
    const i = this._geometry = new PlaneGeometry(1, 1, 1, 63);
    this._material = new ImageryReprojectMaterial(), this._mesh = new Mesh(i, this._material);
  }
  reprojectImagery(i, e, r, s, a, c) {
    this._mesh || this._initResource(), this._material.uniforms.map.value = r;
    const l = this._geometry.attributes.uv.array;
    let h = e.projectedBoundingBox.min.y, d = e.projectedBoundingBox.max.y;
    const f = e.geoBoundingBox.min.y, p = e.geoBoundingBox.max.y;
    if (a.name, c.name, a.isGeo) {
      if (c.isGeo)
        throw new Error("Not implemented");
      {
        const x = 1 / (p - f);
        let v = e.targetBoundingBox.min.y, S = e.targetBoundingBox.max.y;
        for (let E = 0; E < 64; ++E) {
          let b = 1 - E / 63, w = MathUtils.lerp(v, S, b);
          _tempInput.set(0, w, 0), a.unprojectCoordinate(_tempInput, _tempOutput);
          let M = (_tempOutput.y - f) * x;
          l[E * 4 + 1] = M, l[E * 4 + 3] = M;
        }
        throw new Error("Need double check");
      }
    } else {
      const x = 1 / (d - h);
      if (c.isGeo)
        for (let v = 0; v < 64; ++v) {
          let S = 1 - v / 63, E = MathUtils.lerp(f, p, S);
          _tempInput.set(0, E, 0), a.projectCoordinate(_tempInput, _tempOutput);
          let b = (_tempOutput.y - h) * x;
          l[v * 4 + 1] = b, l[v * 4 + 3] = b;
        }
      else
        for (let v = 0; v < 64; ++v) {
          let S = 1 - v / 63, E = MathUtils.lerp(h, d, S);
          _tempInput.set(0, E, 0), c.unprojectCoordinate(_tempInput, _tempOutput), _tempInput.copy(_tempOutput), a.projectCoordinate(_tempInput, _tempOutput), l[v * 4 + 1] = S, l[v * 4 + 3] = S;
        }
    }
    this._geometry.attributes.uv.needsUpdate = !0;
    const m = this._renderTarget;
    let y = i.getRenderTarget();
    return (m.width !== s.image.width || m.height !== s.image.height) && m.setSize(s.image.width, s.image.height), i.setRenderTarget(m), i.clear(), i.render(this._mesh, _camera), i.copyFramebufferToTexture(s, _vector$4), i.setRenderTarget(y), m;
  }
  dispose() {
    this._renderTarget.dispose(), this._mesh.geometry.dispose(), this._mesh.material.dispose();
  }
}
ImageryReprojector.DEFAULT = new ImageryReprojector();
let fallbackTexture;
function getFallbackTexture() {
  if (!fallbackTexture) {
    const i = new Uint8Array(4);
    for (let e = 0; e < i.length; ++e)
      i[e] = 0;
    fallbackTexture = new DataTexture(i, 1, 1, RGBAFormat), fallbackTexture.needsUpdate = !0;
  }
  return fallbackTexture;
}
const _tempInputCoord = new Vector3$1(), _tempOutputCoord = new Vector3$1(), textureLoader$6 = new TextureLoader();
class ImageryTileProvider extends BaseImageryTileProvider {
  constructor() {
    super(...arguments);
    _(this, "name", "ImageryTileProvider");
    _(this, "isImageryTileProvider", !0);
    _(this, "useExtendTargetBoundingBox", !0);
  }
  getTileURL(e, r, s, a) {
  }
  shouldReproject(e, r, s, a) {
    const c = e.name, l = r.name, h = a.grid.useGeoSubdivision;
    if (s.grid.useGeoSubdivision === h && c === l)
      return !1;
    if (e.isGeo) {
      if (r.isGeo)
        return !1;
      throw new Error("Not implemented");
    } else if (r.isGeo) {
      const f = (s.geoBoundingBox.min.y + s.geoBoundingBox.max.y) / 2, p = (s.projectedBoundingBox.min.y + s.projectedBoundingBox.max.y) / 2;
      return _tempInputCoord.set(0, f, 0), e.projectCoordinate(_tempInputCoord, _tempOutputCoord), Math.abs(_tempOutputCoord.y - p) / s.grid.getPixelSizeByLevel(s.z) > 0.1;
    } else {
      const f = (s.projectedBoundingBox.min.y + s.projectedBoundingBox.max.y) / 2;
      return _tempInputCoord.set(0, f, 0), e.unprojectCoordinate(_tempInputCoord, _tempOutputCoord), _tempInputCoord.copy(_tempOutputCoord), r.projectCoordinate(_tempInputCoord, _tempOutputCoord), Math.abs(_tempOutputCoord.y - f) / s.grid.getPixelSizeByLevel(s.z) > 0.1;
    }
  }
  doRequestImageTileData(e, r) {
    const s = r.terrainTile, a = this.getTileURL(e.z, e.x, e.y, e);
    return e._url = a, new Promise((c, l) => {
      textureLoader$6.load(a, (h) => {
        h.colorSpace = SRGBColorSpace, h.generateMipmaps = !1;
        let d = 256, f = 256;
        if (h.image && (d = h.image.width, f = h.image.height), this.shouldReproject(this._sourceProjection, this._targetProjection, e, s)) {
          const p = new FramebufferTexture(d, f);
          p.minFilter = LinearFilter, p.magFilter = LinearFilter, ImageryReprojector.DEFAULT.reprojectImagery(
            this._engine.renderer,
            e,
            h,
            p,
            this._sourceProjection,
            this._targetProjection
          ), p.colorSpace = SRGBColorSpace, c(p), h.dispose();
        } else
          c(h);
      }, null, l);
    });
  }
  errorFallback() {
    return getFallbackTexture();
  }
  onTileDispose(e) {
    const r = e.data;
    r && r.dispose();
  }
}
const http$b = "https:", createUrlGenerator = (o) => {
  switch (o) {
    case BING_MAP_STYLE_AERIAL:
      return (i) => `${http$b}//ecn.t${i % 4}.tiles.virtualearth.net/tiles/a${i}.jpeg?g=13651`;
    case BING_MAP_STYLE_AERIAL_WITH_LABELS:
      return (i) => `${http$b}//t${i % 4}.ssl.ak.dynamic.tiles.virtualearth.net/comp/ch/${i}?mkt=en-US&it=A,G,L&og=2697&n=z`;
    case BING_MAP_STYLE_ROAD:
      return (i) => `${http$b}//t${i % 4}.ssl.ak.dynamic.tiles.virtualearth.net/comp/ch/${i}?mkt=en-US&it=G,L&shading=hill&og=2697&n=z`;
    default:
      return (i) => `${http$b}//ecn.t${i % 4}.tiles.virtualearth.net/tiles/a${i}.jpeg?g=13651`;
  }
}, urlGeneratorCache = /* @__PURE__ */ new Map();
class BingImageryTileProvider extends ImageryTileProvider {
  constructor(e = {}) {
    super({
      ...e,
      projection: PROJECTION_WEB_MERCATOR
    });
    _(this, "name", "BingImageryTileProvider");
    _(this, "_supportedTargetProjectionNames", [PROJECTION_WEB_MERCATOR, PROJECTION_GEO]);
    _(this, "_defaultStartLevel", 1);
    _(this, "_defaultMaxLevel", 18);
    _(this, "_maxParallelRequestNum", 24);
    _(this, "_useWebMeractorProjectionAndGrid", !0);
    _(this, "_urlGenerator", null);
    this._style = e.style || BING_MAP_STYLE_AERIAL, urlGeneratorCache.has(this._style) || urlGeneratorCache.set(this._style, createUrlGenerator(this._style)), this._urlGenerator = urlGeneratorCache.get(this._style);
  }
  get style() {
    return this._style;
  }
  set style(e) {
    this._style !== e && (this._style = e, urlGeneratorCache.has(this._style) || urlGeneratorCache.set(this._style, createUrlGenerator(this._style)), this._urlGenerator = urlGeneratorCache.get(this._style), this._needsClearCache = !0);
  }
  getTileURL(e, r, s, a) {
    if (e === 0)
      return !1;
    const c = this.quadKey(e, r, a.reverseY);
    return this._urlGenerator(c);
  }
  quadKey(e, r, s) {
    let a = "";
    for (let c = e; c > 0; c--) {
      const l = 1 << c - 1;
      let h = 0;
      (r & l) !== 0 && h++, (s & l) !== 0 && (h += 2), a += h;
    }
    return a;
  }
}
const _projection = new Matrix4(), _frustum = new Frustum(), _vector$3 = new Vector3$1(), _vector2 = new Vector3$1();
class MapView extends Object3D {
  constructor(e = {}) {
    super();
    _(this, "isRenderAsyncObject", !0);
    _(this, "isQuadMap", !0);
    _(this, "supportRenderPassCallbacks", !0);
    _(this, "_freezeUpdate", !1);
    _(this, "_lodScaleFactor", 2);
    _(this, "_cameraFarRatio", 1);
    _(this, "_camera", null);
    _(this, "_lastUpdateTime", 0);
    _(this, "_delayUpdateTime", 15);
    _(this, "_delayUpdateTimeHandler", null);
    _(this, "_restrictedBounds", []);
    _(this, "_engine");
    _(this, "_grid");
    _(this, "_options");
    _(this, "_surfaces", []);
    _(this, "onAfterColorPass", (e) => {
      for (let r = 0; r < this._surfaces.length; r++) {
        const s = this._surfaces[r];
        s.onAfterColorPass && s.onAfterColorPass(e);
      }
    });
    _(this, "onAfterMainPass", (e) => {
      for (let r = 0; r < this._surfaces.length; r++) {
        const s = this._surfaces[r];
        s.onAfterMainPass && s.onAfterMainPass(e);
      }
    });
    _(this, "_updateCameraInfo", (e, r) => {
      e.rendering.resolution, r.projectionMatrix.elements;
      const s = r.matrixWorldInverse.elements;
      this._sseDenominator = 2 * Math.tan(0.5 * r.fov / 180 * Math.PI), _vector$3.set(s[2], s[6], s[10]).normalize().negate(), e.map.isGlobe ? _vector2.copy(r.position).normalize() : _vector2.set(0, 0, 1), this._pitchRatio = _vector$3.dot(_vector2);
    });
    _(this, "getKeyByValue", (e, r) => {
      for (let s in e)
        if (e.hasOwnProperty(s) && e[s].includes(r))
          return s === String(r) ? null : s;
      return null;
    });
    _(this, "addRestrictedBoundingBox", (e, r) => {
      const s = this._engine.map;
      let a = s.projectArrayCoordinate(e), c = s.projectArrayCoordinate(r);
      const l = new Box3();
      return l.min.set(a[0], a[1], a[2] || -100), l.max.set(c[0], c[1], a[2] || 100), this._restrictedBounds.push(l), l;
    });
    _(this, "removeRestrictedBounds", (e) => {
      this._restrictedBounds.includes(e) && this._restrictedBounds.splice(e, 1);
    });
    this._options = e;
  }
  addSurface(e) {
    e.quadMap = this, e.engine = this._engine, this._surfaces.push(e), this.add(e);
  }
  addRasterSurface(e, r, s) {
    const a = new RasterSurface(e, r, s);
    return this.addSurface(a), a;
  }
  addVectorSurface(e, r) {
    const s = new VectorSurface(e, r);
    return this.addSurface(s), s;
  }
  removeSurface(e) {
    const r = this._surfaces.indexOf(e);
    if (r > -1) {
      const s = this._surfaces.splice(r, 1)[0];
      s.clearTilesInView(), this.remove(s), s.quadMap = null;
    }
  }
  setTerrainProvider(e) {
    if (!this._rasterSurface) {
      console.warn("No raster surface");
      return;
    }
    this._rasterSurface.terrainProvider = e;
  }
  setImageryProviders(e) {
    if (!this._rasterSurface) {
      console.warn("No raster surface");
      return;
    }
    this._rasterSurface.imageryProviders = e;
  }
  setImageryProvider(e) {
    this.setImageryProviders([e]);
  }
  setVectorProvider(e, r) {
    if (!this._vectorSurface) {
      if (!e)
        return;
      this._vectorSurface = this.addVectorSurface(e, r);
      return;
    }
    this._vectorSurface.tileProvider = e;
  }
  getImageryProviders() {
    return this._rasterSurface ? this._rasterSurface.imageryProviders : null;
  }
  createTileLoader() {
  }
  createGrid(e) {
  }
  afterAddToEngine(e) {
    this._projection = e.map.projection, this._engine = e, this._initDefaultSurfaces();
  }
  _initDefaultSurfaces() {
    const e = this._options;
    if (e.rasterSurface)
      this._rasterSurface = e.rasterSurface, this.addSurface(e.rasterSurface);
    else {
      let r = e.terrainProvider;
      r === void 0 && (r = new PlaneTerrainTileProvider({}));
      let s = e.imageryProviders;
      s === void 0 && (e.imageryProvider ? s = [e.imageryProvider] : e.imageryProvider === void 0 && (s = [
        new BingImageryTileProvider({})
      ])), r && (this._rasterSurface = this.addRasterSurface(r, s));
    }
    e.vectorSurface ? (this._vectorSurface = e.vectorSurface, this.addSurface(e.vectorSurface)) : e.vectorProvider && (this._vectorSurface = this.addVectorSurface(e.vectorProvider, e.vectorSurfaceOptions));
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  onBeforeScenePrepareRender(e, r, s, a) {
    if (this._freezeUpdate || !this.visible) {
      clearTimeout(this._delayUpdateTimeHandler), this._delayUpdateTimeHandler = null;
      return;
    }
    if (this._delayUpdateTimeHandler)
      return;
    const c = Date.now(), l = c - this._lastUpdateTime;
    if (l < this._delayUpdateTime) {
      this._delayUpdateTimeHandler = setTimeout(() => {
        this._delayUpdateTimeHandler = null, e.requestRender();
      }, this._delayUpdateTime - l + 1);
      return;
    }
    let h = s;
    this._cameraFarRatio < 1 && (this._camera || (this._camera = s.clone()), h = this._camera, h.copy(s), h.far = s.far * this._cameraFarRatio, h.updateProjectionMatrix()), this._updateCameraInfo(e, s), this._updateSurfaces(e, r, h, a), this._lastUpdateTime = c;
  }
  onBeforeSceneRender(e, r, s, a) {
    for (let c = 0; c < this._surfaces.length; c++) {
      const l = this._surfaces[c];
      l._onBeforeSceneRender && l._onBeforeSceneRender(e, r, s, a);
    }
  }
  _updateSurfaces(e, r, s, a) {
    _projection.multiplyMatrices(s.projectionMatrix, s.matrixWorldInverse), _frustum.setFromProjectionMatrix(_projection), _vector$3.copy(s.position);
    for (let c = 0; c < this._surfaces.length; c++)
      this._surfaces[c].updateView(e, _vector$3, _frustum, a);
  }
  refresh() {
    for (let e = 0; e < this._surfaces.length; e++) {
      const r = this._surfaces[e];
      r.refresh && r.refresh();
    }
  }
  onTileAdded(e) {
  }
  onTileRemoved(e) {
  }
  onTileDisposed(e) {
  }
  getTileProvidersByName(e) {
    const r = [];
    for (let s = 0; s < this._surfaces.length; s++) {
      const a = this._surfaces[s];
      a.tileProvider.name === e && r.push(a.tileProvider);
    }
    return r;
  }
  dispose() {
    this._vectorSurface && this.removeSurface(this._vectorSurface);
  }
  printSurfacesStatistics() {
    for (let e = 0; e < this._surfaces.length; e++)
      this._surfaces[e];
  }
  _getCurrentCamera() {
    return this._cameraFarRatio < 1 ? this._camera || this._engine.camera : this._engine.camera;
  }
  showCameraFrustum() {
    const e = this._engine;
    this.destroyCameraHelper();
    const r = this._getCurrentCamera(), s = this._lockedCamera = r.clone(), a = this._cameraHelper = new CameraHelper(s);
    e.add(a);
  }
  destroyCameraHelper() {
    const e = this._engine;
    this._cameraHelper && (e.remove(this._cameraHelper), this._cameraHelper.dispose(), this._cameraHelper = null);
  }
  isInStableRenderState() {
    for (let e = 0; e < this._surfaces.length; e++)
      if (!this._surfaces[e].isInStableRenderState())
        return !1;
    return !0;
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(e) {
    this._freezeUpdate = e;
  }
  get lodScaleFactor() {
    return this._lodScaleFactor;
  }
  set lodScaleFactor(e) {
    this._lodScaleFactor = e, this._engine.requestRender();
  }
  get cameraFarRatio() {
    return this._cameraFarRatio;
  }
  set cameraFarRatio(e) {
    this._cameraFarRatio = e;
  }
  get rasterSurface() {
    return this._rasterSurface;
  }
  get vectorSurface() {
    return this._vectorSurface;
  }
  get surfaces() {
    return this._surfaces;
  }
}
const _tempVector3$4 = new Vector3$1(), _tempVector2$1 = new Vector2$1(), _currentClearColor = new Color(0);
let _currentClearAlpha = 1, _currentAutoClear = !0;
class VectorTileImageRenderer {
  static _initResource() {
    this._renderTarget = new WebGLRenderTarget(512, 512), this._renderTarget.name = "VectorTileImageRenderer", this._renderTarget.texture.name = "VectorTileImageRenderer", this._camera = new OrthographicCamera(-1, 1, 1, -1, 0.1, 1e3), this._testMesh = new Mesh(new BoxGeometry(100, 100, 100), [
      new MeshBasicMaterial({ color: 65280, side: DoubleSide }),
      new MeshBasicMaterial({ color: 255, side: DoubleSide }),
      new MeshBasicMaterial({ color: 16711680, side: DoubleSide }),
      new MeshBasicMaterial({ color: 16776960, side: DoubleSide }),
      new MeshBasicMaterial({ color: 65535, side: DoubleSide }),
      new MeshBasicMaterial({ color: 16711935, side: DoubleSide })
    ]);
  }
  static render(i, e, r, s) {
    this._renderTarget || this._initResource();
    const a = i.getRenderTarget();
    i.getClearColor(_currentClearColor), _currentClearAlpha = i.getClearAlpha(), _currentAutoClear = i.autoClear;
    const c = this._camera;
    r.targetBoundingBox.getSize(_tempVector3$4);
    const l = _tempVector3$4.x / 2, h = _tempVector3$4.y / 2, d = _tempVector3$4.z / 2;
    c.left = -l, c.right = l, c.top = h, c.bottom = -h, c.near = 0.1, c.far = _tempVector3$4.z + 1e3, c.updateProjectionMatrix(), _tempVector3$4.copy(r.targetCenter), _tempVector3$4.z += d + 10, c.position.copy(_tempVector3$4), c.lookAt(r.targetCenter), c.updateMatrix(), c.updateMatrixWorld(), i.setRenderTarget(this._renderTarget), i.autoClear = !1, i.clear();
    const f = r.grid.getPixelSizeByLevel(r.z);
    if (e[1] && e[1].children.length > 0) {
      for (const m of e[1].children) {
        if (!m || !m.material)
          continue;
        const y = m.material;
        y.isShaderMaterial && y.uniforms.zoomUnits && (y.uniforms.zoomUnits.value = f);
      }
      i.render(e[1], c);
    }
    if (e[0] && e[0].children.length > 0) {
      for (const m of e[0].children) {
        const y = m.material;
        y.isShaderMaterial && y.uniforms.zoomUnits && (y.uniforms.zoomUnits.value = f);
      }
      i.render(e[0], c);
    }
    const p = new FramebufferTexture(s * 2, s * 2);
    return p.minFilter = LinearFilter, p.magFilter = LinearFilter, i.copyFramebufferToTexture(p, _tempVector2$1), i.setRenderTarget(a), i.setClearColor(_currentClearColor, _currentClearAlpha), i.autoClear = _currentAutoClear, p;
  }
}
let fallbackMesh;
function getFallbackMesh() {
  if (!fallbackMesh) {
    fallbackMesh = new Group();
    const o = new Mesh(new BufferGeometry(), new MeshBasicMaterial());
    fallbackMesh.add(o);
  }
  return [fallbackMesh, fallbackMesh];
}
class VectorTileProvider extends BaseImageryTileProvider {
  constructor() {
    super(...arguments);
    _(this, "isVectorTileProvider", !0);
    _(this, "name", "VectorTileProvider");
    _(this, "_imageryTileSize", 256);
  }
  errorFallback() {
    return getFallbackMesh();
  }
  async doRequestImageTileData(e, r) {
    let s = e;
    r.isRasterSurfaceTile && this._grid.supportLevelReuse && e._sourceTile && (s = e._sourceTile);
    const a = await this.doRequestVectorTileData(s);
    return !r || !r.isRasterSurfaceTile ? a : VectorTileImageRenderer.render(this._engine.renderer, a, e, this._imageryTileSize);
  }
  getGroundTileData(e) {
    const r = {
      x: e.x,
      y: e.y,
      z: e.z,
      targetProjection: e.grid.targetProjection,
      sourceProjection: e.grid.sourceProjection,
      targetProjectionName: e.grid.targetProjection.name,
      sourceProjectionName: e.grid.sourceProjection.name,
      targetCenter: e.targetCenter.toArray(),
      geoBoundingBox: e.availableGeoBoundingBox,
      forceUseGeoBoundingBox: !0,
      forceProjectCoordinates: !0,
      projectedBoundingBox: e.projectedBoundingBox.isBox3 ? e.projectedBoundingBox : []
    }, s = createGroundTileMesh(r, {
      layerIndices: 0
    }), a = new BufferGeometry();
    a.setIndex(s.indices), a.setAttribute("position", new BufferAttribute(new Float32Array(s.vertices), 3)), a.setAttribute("layerIndex", new BufferAttribute(new Float32Array(s.layerIndices), 1)), a.setAttribute("uv", new BufferAttribute(new Float32Array(s.uvs), 2)), a.setAttribute("normal", new BufferAttribute(new Float32Array(s.normals), 3)), this._groundTileMaterial || (this._groundTileMaterial = new MeshBasicMaterial({
      color: 8947848
    }));
    const c = new Mesh(a, this._groundTileMaterial);
    return c.position.copy(e.targetCenter), [null, c];
  }
}
class WorkerTaskScheduler {
  constructor(i, e) {
    _(this, "_size", 1);
    _(this, "_workerClass", null);
    _(this, "_workers", []);
    _(this, "_currentRequestId", 1);
    _(this, "_requestMap", {});
    _(this, "_handleWorkerMessage", async (i) => {
      const e = i.data, r = this.getResponseMessageId(e, i);
      if (r == null) {
        console.warn("no valid id in response message", i);
        return;
      }
      const s = this._requestMap[r];
      if (!s) {
        console.warn(`id ${r} not found in pending request`);
        return;
      }
      this.onMessageReceived && this.onMessageReceived(e, i);
      const a = this.isMessageCompleted(e, i), c = this.isMessageRefreshed(e, i);
      if (!a && !c)
        return;
      delete this._requestMap[r];
      const l = s[3];
      this._workers[l].use--;
      const h = await this.onMessageCompleted(e, i, s[2]);
      s[0](h);
    });
    this._workerClass = i, this._size = e;
  }
  getRequestMessageId(i) {
    return this._currentRequestId++;
  }
  getResponseMessageId(i, e) {
    return i.id;
  }
  _getAvailableWorker() {
    if (this._size === 1)
      return this._workers[0].instance;
    let i = -1, e = 1 / 0;
    for (let r = 0; r < this._size; r++) {
      const s = this._workers[r];
      s.use < e && (i = r, e = s.use);
    }
    return [i, this._workers[i].instance];
  }
  initWorkers() {
    if (this._workers.length === 0)
      for (let i = 0; i < this._size; i++) {
        const e = new this._workerClass();
        e.addEventListener("message", this._handleWorkerMessage), e.addEventListener("error", this.onWorkerError), this._workers.push({
          instance: e,
          use: 0
        });
      }
  }
  async postMessage(i, e, r) {
    r == null && (r = this.getRequestMessageId(i)), this.initWorkers();
    const [
      s,
      a
    ] = this._getAvailableWorker();
    return (i.id === void 0 || i.id === null) && (i.id = r), a.postMessage(i, e), this._workers[s].use++, new Promise((c, l) => {
      this._requestMap[r] = [c, l, i, s];
    });
  }
  async onMessageCompleted(i, e) {
    return i;
  }
  isMessageCompleted(i, e) {
    return !0;
  }
  isMessageRefreshed(i, e) {
    return !1;
  }
  postMessageToAll(i, e) {
    this.initWorkers();
    for (const r of this._workers)
      r.instance.postMessage(i, e);
  }
  get size() {
    return this._size;
  }
}
const ResponseMessageType = {
  RESPONSE_TILE: "responseTile",
  REFRESH_TILE: "refreshTile"
};
class AsyncDataTileLoader {
  constructor(i, e, r) {
    this.provider = i, this._workerTaskScheduler = new WorkerTaskScheduler(e, r), this._workerTaskScheduler.getResponseMessageId = this.getResponseMessageId, this._workerTaskScheduler.isMessageCompleted = this.isMessageCompleted, this._workerTaskScheduler.isMessageRefreshed = this.isMessageRefreshed;
    const s = {
      type: "initCoordTransformer",
      data: CoordTransformer.serialize()
    };
    if (i.getWorkerOptions) {
      const a = i.getWorkerOptions();
      s.workerOptions = a;
    }
    this._workerTaskScheduler.postMessageToAll(s);
  }
  isMessageCompleted(i, e) {
    return i.type === ResponseMessageType.RESPONSE_TILE;
  }
  isMessageRefreshed(i, e) {
    return i.type === ResponseMessageType.REFRESH_TILE;
  }
  getResponseMessageId(i, e) {
    const r = e.data;
    return r && r.id ? r.id : i.tileKey;
  }
  _vectorToArray(i) {
    return [i.x, i.y, i.z];
  }
  _boxToArray(i) {
    return [i.min.x, i.min.y, i.min.z, i.max.x, i.max.y, i.max.z];
  }
  async requestTile(i) {
    const e = this.provider;
    let r = e.getTileURL(i.z, i.x, i.y, i);
    const s = {
      type: "requestTile",
      tileKey: i.key,
      sourceProjectionName: e.sourceProjection.name,
      targetProjectionName: e.targetProjection.name,
      projectedBoundingBox: this._boxToArray(i.projectedBoundingBox),
      geoBoundingBox: this._boxToArray(i.geoBoundingBox),
      projectedCenter: this._vectorToArray(i.projectedCenter),
      targetCenter: this._vectorToArray(i.targetCenter),
      x: i.x,
      y: i.y,
      z: i.z,
      reverseY: i.reverseY,
      url: r,
      timeStart: performance.now(),
      sourceCoordType: e.sourceCoordType || void 0,
      targetCoordType: e.targetCoordType || void 0
    };
    if (e.getFetchOptions) {
      const c = e.getFetchOptions(i);
      s.fetchOptions = c;
    }
    if (e.getWorkerOptions) {
      const c = e.getWorkerOptions(i);
      s.workerOptions = c;
    }
    const a = await this._workerTaskScheduler.postMessage(s, []);
    if (a.isCancelled) {
      const c = new Error("Tile request cancelled");
      throw c.name = "AbortError", c;
    }
    return a;
  }
  async refreshTile(i) {
    const e = this.provider, r = e.getTileURL(i.z, i.x, i.y, i), s = {
      type: "refreshTile",
      tileKey: i.key,
      sourceProjectionName: e.sourceProjection.name,
      targetProjectionName: e.targetProjection.name,
      projectedBoundingBox: this._boxToArray(i.projectedBoundingBox),
      geoBoundingBox: this._boxToArray(i.geoBoundingBox),
      projectedCenter: this._vectorToArray(i.projectedCenter),
      targetCenter: this._vectorToArray(i.targetCenter),
      x: i.x,
      y: i.y,
      z: i.z,
      reverseY: i.reverseY,
      url: r,
      timeStart: performance.now()
    };
    if (e.getFetchOptions) {
      const a = e.getFetchOptions(i);
      s.fetchOptions = a;
    }
    if (e.getWorkerOptions) {
      const a = e.getWorkerOptions(i);
      s.workerOptions = a;
    }
    return await this._workerTaskScheduler.postMessage(s, []);
  }
  cancelTiles(i) {
    const e = [];
    for (let r = 0; r < i.length; r++) {
      const s = i[r];
      e.push(s.key);
    }
    this.postMessageToAll({
      type: "cancelTiles",
      tileKeys: e
    });
  }
  postMessageToAll(i, e) {
    this._workerTaskScheduler.postMessageToAll(i, e);
  }
}
function WorkerWrapper$2() {
  return new Worker(getAssetUrl('assets/workers/BaiduVectorParser.worker-486240e8.js'), { type: "module" });
}
function reFetch(o = "", i = {}, e = 3) {
  function r(s, a) {
    return e--, fetch(s, a).then((c) => {
      if (c.status === 200)
        return c;
      if (c.status === 404)
        throw new Error("404");
    }).catch((c) => {
      if (a.signal && c.name === "AbortError")
        throw c;
      if (e > 0)
        return r(s, a);
      throw c;
    });
  }
  return r(o, i);
}
function jsonp(o, i, e = {}) {
  let r, s, a, c = "";
  e = Object.assign({}, {
    autoCallback: !0,
    jsonp: "callback",
    timeout: 5e4
  }, e);
  const h = [];
  let f = "jsonp" + Math.ceil(Math.random() * 1e5);
  if (e.callbackName && !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(e.callbackName))
    throw new Error("Invalid callback name");
  e.callbackName && (f = e.callbackName);
  const p = o.indexOf("?") > 0 ? "&" : "?";
  for (let y in i)
    ({}).hasOwnProperty.call(i, y) && (typeof i[y] == "object" ? c = y + "=" + JSON.stringify(i[y]) : c = y + "=" + i[y], h.push(c));
  h.length > 0 && (o += p + h.join("&")), a = document.getElementsByTagName("script")[0] || document.head, e.autoCallback && (o = o + "&" + e.jsonp + "=" + f), s = document.createElement("script"), s.src = o, s.type = "text/javascript", a.parentNode.appendChild(s, a);
  function m() {
    s.parentNode && s.parentNode.removeChild(s), r && clearTimeout(r), window[f] = null;
  }
  return new Promise((y, x) => {
    window[f] = (v) => {
      if (v && typeof v == "string")
        try {
          v = JSON.parse(v);
        } catch {
          v = {}, console.error("[ERROR] Parse Error.");
        }
      y(v), m();
    }, s.onerror = (v) => {
      m(), x({
        errno: -2,
        errmsg: `[ERROR] Load Error: ${v}`,
        data: {}
      });
    }, e.timeout && (r = setTimeout(() => {
      m(), x({
        errno: -3,
        errmsg: "[ERROR] Time out.",
        data: {}
      });
    }, e.timeout));
  });
}
const request = (o, i) => fetch(o, Object.assign(i, { credentials: "include" })).then((e) => {
  if (e.ok)
    return e.json();
  throw Error("");
}).then((e) => e).catch(() => {
}), get$1 = (o) => request(o, { method: "GET" }), post = (o, i) => request(o, {
  method: "POST",
  body: i
});
function defer() {
  let o, i;
  const e = new Promise(function(r, s) {
    o = r, i = s;
  });
  return {
    resolve: o,
    reject: i,
    promise: e
  };
}
const request$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  reFetch,
  jsonp,
  request,
  get: get$1,
  post,
  defer
}, Symbol.toStringTag, { value: "Module" })), vertexShader$k = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif

#include <normal_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>

#if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)
    attribute float layerIndex;
    varying float vLayerIndex;
#endif

#ifdef USE_AO
    attribute vec2 heightAndConcave;
    varying float v_concave;
    varying float v_h;
    varying float v_ground;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    #ifdef MVT_USE_COLOR4
        attribute vec4 aColor;
    #endif
#endif

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        #ifdef MVT_USE_COLOR4
            vColor = aColor;
        #else 
            vColor = vec4(color, 1.0);
        #endif
    #endif

    #include <begin_vertex>
    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);

    #if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)
        vLayerIndex = layerIndex;
    #endif

    #ifdef USE_AO
        v_h = heightAndConcave.x;
        float encodeConcave = heightAndConcave.y;
        v_ground = mod(encodeConcave, 2.0);
        float concave = mod(floor(encodeConcave * 0.5), 2.0);
        float start = mod(floor(encodeConcave * 0.25), 2.0);
        concave = pow(concave, 2.2);
        v_concave = mix(concave, -concave, start);
    #endif

    vec4 mvPosition = viewMatrix * worldPosition;
    gl_Position = projectionMatrix * mvPosition;

    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <fog_vertex>
    #include <logdepthbuf_vertex>

}

`, fragmentShader$i = `#define GLSLIFY 1
#include <common>
#include <packing>
#include <fog_pars_fragment>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif
uniform float opacity;

#ifdef USE_AO
    uniform float concaveIntensity;
    uniform float heightIntensity;

    varying float v_concave;
    varying float v_ground;
    varying float v_h;
#endif

#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <logdepthbuf_pars_fragment>

#include <mvt_depth_range_pars_fragment>

void main() {

    vec4 diffuseColor = vec4(0.0);
    #ifdef MVT_USE_VERTEX_COLOR
        diffuseColor = vColor;
    #else
        diffuseColor = vec4(color, 1.0);
    #endif

    diffuseColor.a *= opacity;
    if (diffuseColor.a <= 0.) {
        discard;
    }

    #if ( NUM_DIR_LIGHTS > 0 )
        // \u6839\u636E\u65B9\u5411\u5149\u7684\u65B9\u5411\u4E0E\u6CD5\u5411\uFF0C\u6765\u8BA1\u7B97\u989C\u8272\u8870\u51CF\u7A0B\u5EA6\uFF0C\u503C\u8303\u56F4\u4E3A-1~1\uFF0C\u7ED9\u91CD\u6620\u5C04\u52300.8~1\u7684\u8303\u56F4
        float normalLightIntensity = dot(vNormal, directionalLights[0].direction);
        gl_FragColor = vec4(diffuseColor.rgb * (normalLightIntensity / 10.0 + 0.9), diffuseColor.a);
    #else 
        gl_FragColor = diffuseColor;
    #endif

    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #ifdef USE_AO
        float ao_shade = 1.0;
        float concave = v_concave * v_concave;
        float intensity = concaveIntensity;
        float x_shade = mix(1.0, mix(0.6, 0.75, min(0.01, 1.0)), intensity) + 0.1 * intensity;
        ao_shade *= mix(1.0, x_shade * x_shade * x_shade, concave);

        intensity = heightIntensity;
        float h_floors = v_h / 3.0;
        float y_shade = 1.0 - 0.9 * intensity * min(v_ground, 1.0);
        ao_shade *= (1.0 - 0.08 * intensity) * (y_shade + (1.0 - y_shade) * (1.0 - pow(1.0 - min(h_floors / 16.0, 1.0), 16.0))) + 0.08 * intensity * min(h_floors / 160.0, 1.0);

        gl_FragColor.rgb *= ao_shade;
    #endif

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
    #include <mvt_depth_range_fragment>
}

`, uniforms$l = UniformsUtils.merge([
  UniformsLib.fog,
  UniformsLib.lights,
  {
    opacity: { value: 1 },
    uColor: { value: [0, 1, 1] },
    vertexColors: { value: !1 },
    vertexZIndexLegacy: { value: !1 },
    vertexZIndex: { value: !1 },
    isEmissive: { value: !1 },
    depthRange: { value: new Vector2$1(0, 1) },
    concaveIntensity: { value: 0.2 },
    heightIntensity: { value: 0.4 }
  }
]);
class BaiduVectorMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "BaiduVectorMaterial", this.type = "BaiduVectorMaterial", this.isBaiduVectorMaterial = !0, this.lights = !0, this.fog = !0, this.fragmentShader = fragmentShader$i, this.vertexShader = vertexShader$k, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$l)), defineMaterialNormalProperties(this, [
      "opacity",
      "isEmissive",
      "concaveIntensity",
      "heightIntensity",
      "depthRange"
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexZIndexLegacy", "MVT_USE_VERTEX_ZINDEX_LEGACY"],
      ["vertexZIndex", "MVT_USE_VERTEX_ZINDEX"],
      ["enableDepthRange", "MVT_USE_DEPTH_RANGE"],
      ["isColor4", "MVT_USE_COLOR4"],
      ["useAO", "USE_AO"]
    ]), this.setValues(i);
  }
}
const vertexShader$j = `#define GLSLIFY 1
#include <common>

attribute vec3 a_diff;
attribute vec3 a_normal;
attribute vec2 a_uv;

varying vec2 vUv;

// uniform float u_scale;
// uniform bool u_flat;

#ifdef MVT_USE_VERTEX_ZINDEX_LEGACY
attribute float layerIndex;
#endif

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>
void main() {
    #include <mvt_selective_vertex>
    
    vec3 currentPosition = position;

    vec4 worldPosition = modelMatrix * vec4(currentPosition, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz) * 1.0;

    float scale = 1.4;
    currentPosition.xyz = currentPosition.xyz + (a_diff * scale * pixelSize) + a_normal * scale * pixelSize;

    worldPosition = modelMatrix * vec4(currentPosition, 1.0);

    gl_Position = projectionMatrix * modelViewMatrix * vec4(currentPosition, 1.0);

    vUv = a_uv;

    #include <logdepthbuf_vertex>
    // gl_PointSize = 10000000000.0; // \u8BBE\u7F6E\u70B9\u7684\u5927\u5C0F
}`, fragmentShader$h = `#define GLSLIFY 1
#include <common>

uniform sampler2D u_image;
uniform int u_draw_part;

varying vec2 vUv;
// varying float v_z;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {
    // if (u_draw_part == 1) {
    //     if (v_z > 0.0) {
    //         discard;
    //     }
    // } else if (u_draw_part == 2) {
    //     if (v_z == 0.0) {
    //        discard;
    //     }
    // }

    gl_FragColor = texture2D(u_image, vUv);
    gl_FragColor.rgb *= (1.0 - max(0.6, 1.0 - gl_FragColor.a));

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`, texture = new TextureLoader().load(
  "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ5JREFUeNrsllEKgCAMhp14rsqT1X08Q6VdbDmYLxGUoO5lg72J+9i/3wmIaCTDGuFQAAVQANfyshCCSkBx5pwlAZackUEmSQkIJH2BjJiBAnK8gQBtwzy9I1cidWTLeUm5wHNHduqIlXagEyhMDlmLBNDyR8QvIf4pPNIFkZ3gn8V7SxB52tOwZVRTuCeArzkM+i1XAAVQAGmAW4ABAOOjKXrLR4xWAAAAAElFTkSuQmCC"
);
texture.anisotropy = 8;
let uniforms$k = UniformsUtils.merge([
  {
    u_draw_part: { value: 0 },
    u_image: { value: texture },
    color: { value: new Color(16711680) },
    vertexZIndexLegacy: { value: !1 },
    vertexZIndex: { value: !1 },
    u_scale: { value: 1 },
    isGlobe: { value: !1 }
  }
]);
class ArrowMaterial extends CommonShaderMaterial {
  constructor(e) {
    super();
    _(this, "name", "ArrowMaterial");
    _(this, "isArrowMaterial", !0);
    this.vertexShader = vertexShader$j, this.fragmentShader = fragmentShader$h, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$k)), defineMaterialColorProperties([
      "color"
    ]), defineMaterialNormalProperties(this, [
      "u_draw_part",
      "u_image"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexZIndexLegacy", "MVT_USE_VERTEX_ZINDEX_LEGACY"],
      ["vertexZIndex", "MVT_USE_VERTEX_ZINDEX"],
      ["isGlobe", "IS_GLOBE"]
    ]), this.setValues(e);
  }
  set color(e) {
    this.uniforms.color.value = e;
  }
}
const halfZeroLevelSize = Math.pow(2, 18) * 256 / 2, halfEarthSize = 2003772416e-2, exceedRatio = halfZeroLevelSize / halfEarthSize;
class BaiduImageryGrid extends Grid {
  constructor(e, r, s) {
    super(e, r, s);
    _(this, "_maxLevel", 19);
    _(this, "_shouldCheckTileBoundingRange", !0);
    this._coordLevelTileCounts = [1];
    let a = 1;
    for (let c = 1; c <= 19; ++c)
      this._coordLevelTileCounts[c] = a, a *= 2;
  }
  getRootTiles() {
    const e = new MapTile(this, 0, 0, 0);
    return e.projectedBoundingBox = new Box3(
      new Vector3$1(-halfZeroLevelSize, -halfZeroLevelSize, -0.1),
      new Vector3$1(halfZeroLevelSize, halfZeroLevelSize, 0.1)
    ), e.geoBoundingBox = new Box3(
      new Vector3$1(-180 * exceedRatio, -90 * exceedRatio, -0.1),
      new Vector3$1(180 * exceedRatio, 90 * exceedRatio, 0.1)
    ), [e];
  }
  getRootBoundingBox() {
    return this._rootBoundingBox;
  }
  getTileReverseY(e) {
    return Math.pow(2, e.z - 1) - e.y - 1;
  }
  getTileSizeAtLevel(e) {
    return Math.pow(2, 18 - e) * 256;
  }
  getTileCoordX(e, r, s) {
    return (e + halfZeroLevelSize) / r;
  }
  getTileCoordY(e, r, s) {
    return (e + halfZeroLevelSize) / r;
  }
  _quadCoordToTileCoord(e, r) {
    return e >= r ? e - r : "M" + (r - e);
  }
  getRasterTileCoord(e, r, s) {
    const a = this._coordLevelTileCounts[e];
    return [e, this._quadCoordToTileCoord(r, a), this._quadCoordToTileCoord(s, a)];
  }
  get zeroLevelPixelSize() {
    return this._zeroLevelPixelSize || (this._zeroLevelPixelSize = 200375083427892e-7 * 2 / 0.597 / 256), this._zeroLevelPixelSize;
  }
}
class BaiduVectorOnlineGrid extends BaiduImageryGrid {
  constructor() {
    super(...arguments);
    _(this, "name", MAP_GRID_NAME_BD_VECTOR_ONLINE);
    _(this, "_maxLevel", 21);
    _(this, "_levels", [0, 1, 2, 3, 5, 7, 9, 10, 12, 15, 17, 19]);
    _(this, "_tileCountMap", {
      3: 2,
      5: 4,
      7: 4,
      9: 4,
      10: 2,
      12: 8,
      15: 2,
      17: 4
    });
    _(this, "_zLevelToQuadTreeLevelMap", {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      5: 4,
      7: 6,
      9: 8,
      10: 10,
      12: 11,
      15: 14,
      17: 15,
      19: 17
    });
    _(this, "_zoomBaseMap", {
      0: { start: 0, base: 0 },
      1: { start: 0, base: 1 },
      2: { start: 2, base: 2 },
      3: { start: 3, base: 3 },
      4: { start: 4, base: 5 },
      5: { start: 4, base: 5 },
      6: { start: 6, base: 7 },
      7: { start: 6, base: 7 },
      8: { start: 8, base: 9 },
      9: { start: 8, base: 9 },
      10: { start: 10, base: 10 },
      11: { start: 11, base: 12 },
      12: { start: 11, base: 12 },
      13: { start: 11, base: 12 },
      14: { start: 14, base: 15 },
      15: { start: 14, base: 15 },
      16: { start: 16, base: 17 },
      17: { start: 16, base: 17 },
      18: { start: 18, base: 19 },
      19: { start: 18, base: 19 },
      20: { start: 18, base: 19 },
      21: { start: 18, base: 19 }
    });
    _(this, "_defaultCoordLevelTileCounts", {
      0: 1,
      1: 1
    });
    _(this, "supportLevelReuse", !0);
  }
  _quadCoordToTileCoord(e, r, s) {
    let a = 1, c = e - r;
    return Math.floor(c / a);
  }
  getRasterTileCoord(e, r, s) {
    let a = this._coordLevelTileCounts[e];
    return [e, this._quadCoordToTileCoord(r, a, e), this._quadCoordToTileCoord(s, a, e)];
  }
  getNextLevelTileCount(e) {
    return this._tileCountMap[e] || 2;
  }
  getQuadTreeLevelGap(e, r) {
    const s = this._zoomBaseMap[e].base, a = this._zoomBaseMap[r].base, c = this._zLevelToQuadTreeLevelMap[s];
    return this._zLevelToQuadTreeLevelMap[a] - c;
  }
  getTileLoaderConfig(e) {
    const r = this._zoomBaseMap[e.z];
    return {
      baseZ: r.base,
      startZ: r.start
    };
  }
  getResuedTileConfig(e, r, s) {
    const a = this._zoomBaseMap[e].base, c = this._zLevelToQuadTreeLevelMap[a];
    if (!c >= e)
      return console.warn(`${e}-${r}-${s} is a node of quadtree`), null;
    const l = e - c, h = r >> l, d = s >> l, f = r - (h << l), p = s - (d << l), m = Math.pow(2, l);
    return [e, h, d, f / m, p / m, 1 / m, 1 / m];
  }
  update() {
    super.update(), this._updateCoordLevelTileCounts();
  }
  _updateCoordLevelTileCounts() {
    let e = 1;
    this._coordLevelTileCounts = Object.assign({}, this._defaultCoordLevelTileCounts);
    for (let r = 1; r < this._levels.length; r++) {
      const s = this._levels[r], a = this._levels[r - 1];
      r < 2 || (this._tileCountMap[a] !== void 0 ? e *= this._tileCountMap[a] : e *= 2, this._coordLevelTileCounts[s] = e);
    }
  }
}
const zoomBaseMap = {
  0: { start: 0, end: 0, base: 0 },
  1: { start: 1, end: 1, base: 1 },
  2: { start: 2, end: 2, base: 2 },
  3: { start: 3, end: 4, base: 3 },
  4: { start: 3, end: 4, base: 3 },
  5: { start: 5, end: 6, base: 5 },
  6: { start: 5, end: 6, base: 5 },
  7: { start: 7, end: 8, base: 7 },
  8: { start: 7, end: 8, base: 7 },
  9: { start: 9, end: 9, base: 9 },
  10: { start: 10, end: 12, base: 10 },
  11: { start: 10, end: 12, base: 10 },
  12: { start: 10, end: 12, base: 10 },
  13: { start: 13, end: 14, base: 13 },
  14: { start: 13, end: 14, base: 13 },
  15: { start: 15, end: 16, base: 14 },
  16: { start: 15, end: 16, base: 14 },
  17: { start: 17, end: 23, base: 16 },
  18: { start: 17, end: 23, base: 16 },
  19: { start: 17, end: 23, base: 16 },
  20: { start: 17, end: 23, base: 16 },
  21: { start: 17, end: 23, base: 16 },
  22: { start: 17, end: 23, base: 16 },
  23: { start: 17, end: 23, base: 16 }
}, EARTH_RADIUS = 200375083427892e-7;
Object.freeze(zoomBaseMap);
class BaiduVectorOfflineGrid extends Grid {
  constructor() {
    super(...arguments);
    _(this, "name", MAP_GRID_NAME_BD_VECTOR_OFFLINE);
    _(this, "_maxLevel", 21);
    _(this, "supportLevelReuse", !0);
    _(this, "_rootBoundingBox", new Box3(
      new Vector3$1(-200375083427892e-7, -200375083427892e-7, -0.1),
      new Vector3$1(200375083427892e-7, 200375083427892e-7, 0.1)
    ));
  }
  getRootTiles() {
    const e = new MapTile(this, 0, 0, 0);
    return e.projectedBoundingBox = this._rootBoundingBox, e.geoBoundingBox = new Box3(new Vector3$1(-180, -90, -0.1), new Vector3$1(180, 90, 0.1)), [e];
  }
  getRootBoundingBox() {
    return this._rootBoundingBox;
  }
  getTileSizeAtLevel(e) {
    return EARTH_RADIUS / Math.pow(2, e - 1);
  }
  getTileCoordX(e, r, s) {
    return s && (e < -EARTH_RADIUS ? e = -EARTH_RADIUS : e > EARTH_RADIUS && (e = EARTH_RADIUS)), (e + EARTH_RADIUS) / r;
  }
  getTileCoordY(e, r, s) {
    return this.getTileCoordX(e, r, s);
  }
  getQuadTreeLevelGap(e, r) {
    const s = zoomBaseMap[e].base;
    return zoomBaseMap[r].base - s;
  }
  getResuedTileConfig(e, r, s) {
    const c = zoomBaseMap[e].base, l = e - c, h = r >> l, d = s >> l, f = r - (h << l), p = s - (d << l), m = Math.pow(2, l);
    return [e, h, d, f / m, p / m, 1 / m, 1 / m];
  }
  getTileLoaderConfig(e) {
    const r = zoomBaseMap[e.z];
    return {
      baseZ: r.base,
      startZ: r.start
    };
  }
}
const loadScript = (o) => new Promise((i, e) => {
  const r = document.createElement("script");
  r.src = o, r.async = !0, r.onload = i, r.onerror = () => e(new Error(`failed to load script: ${o}`)), document.head.appendChild(r);
});
class PromisedSingleton {
  constructor() {
    _(this, "_retryTimes", 3);
    _(this, "_queued", {});
    _(this, "_cached", {});
  }
  async generate(i) {
    return {};
  }
  async get(i) {
    if (this._cached[i])
      return this._cached[i];
    let e = !1;
    this._queued[i] || (this._queued[i] = [], e = !0);
    const r = new Promise((a, c) => {
      this._queued[i].push([a, c]);
    }), s = this._queued[i];
    if (e) {
      for (let a = 0; a < this._retryTimes; a++)
        try {
          const c = await this.generate(i);
          this._cached[i] = c;
          for (const l of s)
            l[0](c);
          break;
        } catch (c) {
          console.warn(c);
        }
      for (const a of s)
        a[1]();
    }
    return r;
  }
  get keys() {
    return Object.keys(this._cached);
  }
  delete(i) {
    delete this._cached[i], delete this._queued[i];
  }
  clear() {
    this._cached = {}, this._queued = {};
  }
}
class BaiduMapConfig {
  static get ak() {
    return this._ak;
  }
  static set ak(i) {
    !i || i === this._ak || (this._ak = i, fetch(`https://api.map.baidu.com/api?type=three&v=1.4.1&ak=${i}`, {
      method: "GET",
      mode: "no-cors"
    }));
  }
}
_(BaiduMapConfig, "_ak", null);
class CesiumConfig {
}
_(CesiumConfig, "accessToken", null);
class MapboxConfig {
}
_(MapboxConfig, "accessToken", null);
class TiandituConfig {
}
_(TiandituConfig, "tk", null);
var b0f = function(o, i) {
  var e = { lxaxx: "xea", aeemx: "aeai", ddaxm: function(w, M) {
    return w(M);
  }, hmaea: "dae", xedec: "mda", caaxa: function(w, M) {
    return w + M;
  }, caahi: function(w, M) {
    return w(M);
  }, laexm: function(w, M, P) {
    return w(M, P);
  }, xiaac: function(w, M) {
    return w(M);
  }, emlie: function(w, M) {
    return w(M);
  }, hleaa: function(w, M) {
    return w + M;
  }, dcaah: function(w, M) {
    return w(M);
  }, iamlm: function(w, M) {
    return w < M;
  } };
  function r(w, M) {
    for (var P = e.lxaxx; P !== e.aeemx; )
      switch (P) {
        case "ail":
          return F;
        case "mda":
          for (var D = 0; D < O; D++) {
            var L = e.ddaxm(M, w[D]);
            F.push(L);
          }
          P = "ail";
          break;
        case "xea":
          var O = w.length;
          P = e.hmaea;
          break;
        case e.hmaea:
          var F = [];
          P = e.xedec;
          break;
      }
  }
  var s, a, c, l, h, d = decodeURIComponent, f = "Char", p = "";
  s = "de", a = "fr", c = "o", h = e.caaxa(a + c, "m"), l = e.hleaa("Co", s);
  var m = function(w) {
    return e.caaxa(w, p).constructor[h + f + l](w);
  }, y = function(w) {
    var M = { ealhi: function(P, D) {
      return e.caahi(P, D);
    } };
    return e.laexm(r, w, function(P) {
      return M.ealhi(m, P);
    });
  }, x = y.call(m, [39, 34, 37, 96, 60, 120, 97, 65, 98, 66, 99, 67, 100, 68, 101, 69, 102, 70, 103, 110, 109, 111, 112, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57]), v = r([28782, 27702, 26416, 25167, 24183], function(w) {
    return e.xiaac(d, w);
  }), S = y.call(v, [22354, 22749, 24415, 23346, 22257, 22688, 24306, 25174, 23595, 25547, 22984, 25690, 22212, 27547, 21594, 27210, 23090, 29193, 22394, 29368, 29532, 29459, 29530, 24146, 24500, 26352, 27441, 28788, 29370, 27673, 26925, 25249, 24430]), E = {};
  v = e.dcaah(y, v);
  for (var b = new RegExp(v.join("|")), s = 0; e.iamlm(s, x.length); s++)
    E[S[s]] = x[s];
  return i = e.laexm(r, i.split(p), function(w) {
    return E[w] || w;
  }).join(p), r(i.split(b), function(w) {
    return e.emlie(d, w);
  });
}(globalThis, "l\u545A\u72B8\u577Ath\u624F\u545A\u735C\u5EF2\u735C\u545A\u6C36i\u5EF2\u545A\u545A\u58A0\u5E77\u56C4\u58A0\u59C8li\u6C36\u545A\u56C4\u58A0\u59C8\u545A\u6C36\u56C4\u56C4\u545A\u545A\u59C8\u5E77su\u5C2Bstr\u624F\u59C8\u58A0\u56C4\u5EF2\u735C\u624Fi\u72B8\u56C4\u545A\u58A0O\u5A32\u6C36h\u58A0\u545A\u545A\u735C\u5E77\u58A0l\u545All\u5E77h\u5EF2\u5EF2\u6C36\u735C\u545A\u735C\u6730H\u5E52\u6256\u5F6EP\u62A1P\u692DY\u6C19\u6256\u63CBQO\u5E52\u706E\u59C8il\u6C36l\u58A0\u59C8\u706E\u545A\u5EF2\u5EF2\u624F\u7209\u72BAL\u66F0O\u6C19R\u6C19\u6256\u6B9B\u62A1\u5F6E\u5F6E\u5E52O\u5E77\u56C4l\u545A\u56C4i\u6730\u59C8\u545A\u545A\u545A\u706E\u545A\u58A0l\u5EF2\u735C\u6730\u5F5F\u66F0\u6C19si\u577A\u72B8\u5F5F\u6B31\u6B9B\u6730su\u5C2Bstri\u72B8\u577A\u706E\u5EF2\u58A0\u545Al\u56C4");
(function(o, i) {
  var e = function(r) {
    for (; --r; )
      o.push(o.shift());
  };
  e(++i);
})(b0f, 491);
var b0h = function(o, i) {
  o = o - 0;
  var e = b0f[o];
  return e;
};
function appendSign(o) {
  for (var i = { dledi: function(l, h) {
    return l !== h;
  }, exlam: b0h("0x0"), axeld: function(l, h) {
    return l - h;
  }, emame: b0h("0x1"), iaeex: b0h("0x2"), dxcli: b0h("0x3"), edxce: b0h("0x4"), dhcmh: function(l, h) {
    return l(h);
  }, ddeec: function(l, h) {
    return l(h);
  }, cxdam: function(l, h) {
    return l + h;
  }, hxeem: b0h("0x5"), xlell: b0h("0x6") }, e = b0h("0x5"); i[b0h("0x7")](e, b0h("0x8")); )
    switch (e) {
      case i[b0h("0x9")]:
        return b0h("0xa") + s[b0h("0xb")](i[b0h("0xc")](s[b0h("0xd")], 12));
      case i[b0h("0xe")]:
        var r = i[b0h("0xf")];
        e = i[b0h("0x10")];
        break;
      case i[b0h("0x11")]:
        var s = i.dhcmh(md5, i[b0h("0x12")](md5, a + c) + r);
        e = i[b0h("0x9")];
        break;
      case i[b0h("0x10")]:
        var a = o[b0h("0x13")](i[b0h("0x14")](o[b0h("0x15")]("?"), 1));
        e = b0h("0x4");
        break;
      case i[b0h("0x16")]:
        var c = i[b0h("0x17")];
        e = i.emame;
        break;
    }
}
let urlProtocol$1 = window.location.protocol === "http:" ? "http:" : "https:";
const apiHost$1 = urlProtocol$1 + "//api.map.baidu.com", mapStyleHelper = {
  ak: "",
  getStyleJson: async function(o) {
    if (o.styleJson)
      return o.styleJson;
    if (o.styleId) {
      let i = o.styleId, e = `${apiHost$1}/?qt=custom_map&v=3.0&style_id=${i}&type=publish&ak=${this.ak}`, r = await jsonp(e), s = [];
      return r.result && r.result.error === 0 && r.content && r.content.status === 0 ? (s = this.parseJson(r.content.data.json), s) : null;
    }
    return null;
  },
  parseJson: function(o) {
    if (o === null || o === "")
      return [];
    let i = {
      t: "featureType",
      e: "elementType",
      v: "visibility",
      c: "color",
      o: "opacity",
      l: "lightness",
      s: "saturation",
      w: "weight",
      z: "level",
      h: "hue",
      f: "fontsize",
      zri: "curZoomRegionId",
      zr: "curZoomRegion",
      i: "image"
    }, e = {
      all: "all",
      g: "geometry",
      "g.f": "geometry.fill",
      "g.s": "geometry.stroke",
      l: "labels",
      "l.t.f": "labels.text.fill",
      "l.t.s": "labels.text.stroke",
      "l.t": "labels.text",
      "l.i": "labels.icon",
      "g.tf": "geometry.topfill",
      "g.sf": "geometry.sidefill",
      t: "texture"
    };
    return o.split(",").map(function(a) {
      let c = a.split("|").map(function(f) {
        let p = i[f.split(":")[0]], m = e[f.split(":")[1]] ? e[f.split(":")[1]] : f.slice(f.indexOf(":") + 1, f.length);
        switch (m) {
          case "poi":
            m = "poilabel";
            break;
          case "districtlabel":
            m = "districtlabel";
            break;
        }
        let y = {};
        return y[p] = m, y;
      }), l = c[0], h = 1;
      c[1].elementType && (h = 2, Object.assign(l, c[1]));
      let d = {};
      for (let f = h; f < c.length; f++)
        Object.assign(d, c[f]);
      return Object.assign(l, {
        stylers: d
      });
    });
  },
  getStyleUrl: function(o, i) {
    let e = apiHost$1 + "/custom/v2/mapstyle?version=" + 4 + "&ak=" + this.ak + "&qt=custom_v2&is_all=true&is_new=1&", r = this.styleJson2styleStringV2(o, i);
    e += "styles=" + encodeURIComponent(r);
    let s = new Date().getTime();
    return e += "&timeStamp=" + s, e += appendSign(e), e;
  },
  styleJson2styleStringV2: function(o, i) {
    let e = {
      featureType: "t",
      elementType: "e",
      visibility: "v",
      color: "c",
      opacity: "o",
      lightness: "l",
      saturation: "s",
      weight: "w",
      level: "z",
      hue: "h",
      fontsize: "f",
      image: "i"
    }, r = {
      all: "all",
      geometry: "g",
      "geometry.fill": "g.f",
      "geometry.stroke": "g.s",
      labels: "l",
      "labels.text.fill": "l.t.f",
      "labels.text.stroke": "l.t.s",
      "labels.text": "l.t",
      "labels.icon": "l.i",
      "geometry.topfill": "g.tf",
      "geometry.sidefill": "g.sf",
      texture: "t"
    }, s = [];
    for (let c = 0; c <= 23; c++)
      i.zoomFrontStyle[c] = {};
    i.zoomFrontStyle.main = {};
    let a = !1;
    for (let c = 0; o[c]; c++) {
      let l = o[c];
      if (this.isOnlyZoomStyler(l))
        continue;
      let h = this.getFrontZoom(l);
      if ((l.featureType === "land" || l.featureType === "all" || l.featureType === "background") && typeof l.elementType == "string" && (l.elementType === "geometry" || l.elementType === "texture" || l.elementType === "geometry.fill" || l.elementType === "all") && l.stylers && !a && (l.stylers.color && (i.bmapLandColor = l.stylers.color), l.stylers.image && (i.bmapLandFillTexture = l.stylers.image), l.stylers.opacity && (i.bmapLandColor = l.stylers.opacity), l.stylers.visibility && l.stylers.visibility === "off" && (i.bmapLandColor = "#00000000"), l.featureType === "land" && (a = !0)), l.featureType === "building" && typeof l.elementType == "string" && l.elementType === "geometry.fill" && (i.buildingFill = !0), l.featureType === "roadarrow" && l.elementType === "labels.icon" && l.stylers) {
        let m = l.stylers.visibility;
        i.zoomFrontStyle[h].bmapRoadarrowVisibility = m;
      }
      let d = {};
      Object.assign(d, l);
      let f = d.stylers;
      delete d.stylers, Object.assign(d, f);
      let p = [];
      for (let m in e)
        if (d[m]) {
          if (this.isEditorZoomKeys(m))
            continue;
          if (m === "elementType")
            p.push(e[m] + ":" + r[d[m]]);
          else if (m === "image")
            p.push(e[m] + ":" + encodeURIComponent(encodeURIComponent(d[m])));
          else {
            switch (d[m]) {
              case "poilabel":
                d[m] = "poi";
                break;
              case "districtlabel":
                d[m] = "label";
                break;
            }
            p.push(e[m] + ":" + d[m]);
          }
        }
      p.length > 2 && s.push(p.join("|"));
    }
    return s.join(",");
  },
  getFrontZoom: function(o) {
    let i = o.stylers.level;
    return i === void 0 ? "main" : parseInt(i, 10);
  },
  isOnlyZoomStyler: function(o) {
    let i = {};
    return Object.assign(i, o.stylers), delete i.curZoomRegionId, delete i.curZoomRegion, delete i.level, Object.keys(i).length === 0;
  },
  isEditorZoomKeys: function(o) {
    return !!{
      curZoomRegionId: !0,
      curZoomRegion: !0
    }[o];
  },
  getFeatureStyles: async function(o) {
    let i = await this.getStyleJson(o);
    const e = {
      zoomRegion: {},
      zoomStyleBody: [],
      zoomFrontStyle: {}
    }, r = this.getStyleUrl(i, e);
    let s = r.split("?")[0], a = r.split("?")[1], c = null;
    if (s.indexOf("jsonp") > -1)
      c = await jsonp(s);
    else {
      let l = new FormData();
      a.split("&").forEach((d) => {
        const [f, p] = d.split("=");
        l.append(decodeURIComponent(f), decodeURIComponent(p || ""));
      }), c = await fetch(s, {
        method: "POST",
        body: l
      }).then((d) => {
        if (d.ok)
          return d.json();
      });
    }
    return c;
  }
}, urlProtocol = window.location.protocol === "http:" ? "http:" : "https:", apiHost = urlProtocol + "//api.map.baidu.com";
class FetchTrack {
  constructor() {
    _(this, "sendMessage", (i) => {
    });
    this.device = { PC: 0, NA: 1 }, this.config = {
      mask: ["FFFFFFFF"],
      open: !1,
      reset: 60 * 60 * 1e3
    }, this.url = apiHost + "?qt=jsapi_log", this.startTime = Date.now(), this.mark = {}, this.records = {}, this.ak = "";
  }
  init(i, e) {
    this.kill();
    let r = this;
    this.config.open = !!i, e = e || {}, e.reset && (this.config.reset = e.reset), this.sendMessage = function(s) {
      let a = s || 1e3;
      return r._idleWorkerTicker = function(c) {
        return function() {
          c.runJob();
        };
      }(r), function(c) {
        if (window.navigator && !navigator.onLine)
          return;
        Date.now() - r.startTime > r.config.reset && (r.startTime = Date.now(), r.mark = {}, r.records = {});
        const l = c.join("-");
        r.mark[l] || (r.mark[l] = !0, r.records[l] = c), r.checkJob(a);
      };
    }(e.timers);
  }
  runJob() {
    if (Object.keys(this.records).length === 0) {
      clearInterval(this.idleWork), this.idleWork = null;
      return;
    }
    let e = Object.keys(this.records)[0], r = new Date().getTime();
    if (this.config.open)
      try {
        const s = this.ak || BaiduMapConfig.ak;
        jsonp(this.url, {
          ak: s,
          mapvthree: 1,
          device: 0,
          module: this.records[e][0] || "",
          func: this.records[e][1] || "",
          subfunc: this.records[e][2] || "",
          t: r
        }).then((a) => {
          delete this.records[e];
        });
      } catch {
      }
    Object.keys(this.records).length === 0 && (clearInterval(this.idleWork), this.idleWork = null);
  }
  checkJob(i) {
    !this.idleWork && this._idleWorkerTicker && (this.idleWork = setInterval(this._idleWorkerTicker, i));
  }
  kill() {
    this.idleWork && (clearInterval(this.idleWork), this.idleWork = null), this._idleWorkerTicker = null, this.mark = {}, this.records = {};
  }
}
const tongjiTrack = new FetchTrack();
tongjiTrack.init(!0, {
  reset: 20 * 60 * 1e3
});
new Vector3$1();
new Vector3$1();
const http$a = window.location.protocol === "http:" ? "http:" : "https:", onlineHosts = [
  `${http$a}//apimaponline0.bdimg.com`,
  `${http$a}//apimaponline1.bdimg.com`,
  `${http$a}//apimaponline2.bdimg.com`,
  `${http$a}//apimaponline3.bdimg.com`
], getPixelSize$2 = (o, i, e) => 0.2 * Math.tan(i / 2) * o / e, textureLoader$5 = new TextureLoader(), dashTextureSingleton = new PromisedSingleton();
dashTextureSingleton.generate = async (o) => new Promise((i, e) => {
  textureLoader$5.load(o, (r) => {
    i(r);
  }, null, e);
});
let globalDefaultStyleConfig = null;
function encodeTileUrl(o) {
  let i = "", e, r;
  for (e = 0; e < o.length; e++) {
    r = o.charCodeAt(e) << 1;
    let l = r.toString(2), h = l.length, d = l;
    h < 8 && (d = "00000000" + l, d = d.substr(l.length, 8)), i += d;
  }
  let s = 5 - i.length % 5, a = [];
  for (e = 0; e < s; e++)
    a[e] = "0";
  i = a.join("") + i;
  let c = [];
  for (e = 0; e < i.length / 5; e++) {
    r = i.substr(e * 5, 5);
    let l = parseInt(r, 2) + 50;
    c.push(String.fromCharCode(l));
  }
  return c.join("") + s.toString();
}
const mapStyleNameIdPair = {
  default: 0,
  "grayed-out": 1
}, defaultStyleConfig = {
  fontRgba: [0, 0, 0, 0],
  fontSize: 16,
  fontWeight: "400",
  haloRgba: [0, 0, 0, 0],
  haloSize: 0
};
async function loadIconSet(o) {
  try {
    const i = document.createElement("script");
    return i.src = o, document.head.appendChild(i), new Promise((e, r) => {
      i.onload = () => {
        e(window.iconSetInfo_high);
      }, i.onerror = () => {
        r(new Error(`Failed to load script: ${o}`));
      };
    });
  } catch (i) {
    throw console.error("Error loading icon set:", i), i;
  }
}
const direction = {
  0: "top",
  1: "left",
  2: "bottom",
  3: "right"
};
class BaiduVectorTileProvider extends VectorTileProvider {
  constructor(e = {}) {
    super(e);
    _(this, "name", "BaiduVectorTileProvider");
    _(this, "isBaiduProvider", !0);
    _(this, "_shouldRenderPlaceholder", !0);
    _(this, "_isAttach", !0);
    _(this, "_supportAllProjections", !0);
    _(this, "_defaultStartLevel", 2);
    _(this, "_defaultMaxLevel", 16);
    _(this, "_labels", {});
    _(this, "_ak", null);
    _(this, "_loadStyle", async () => {
      let e = null;
      if (this._isOffline) {
        let r = this._styleUrl || getAssetUrl("assets/map/style/default.json");
        e = await reFetch(r).then((s) => s.json()), e.data && e.data.style && (e = e.data.style);
      } else
        this._styleId || this._styleJson ? (e = await mapStyleHelper.getFeatureStyles({
          styleId: this._styleId,
          styleJson: this._styleJson
        }), e.data && e.data.style ? e = e.data.style : e.status !== 0 && console.error(
          "An error occurred when setMapStyle in BaiduVectorProvider: ",
          e.message
        )) : (globalDefaultStyleConfig || (await loadScript("https://maponline0.bdimg.com/sty/fs.js"), globalDefaultStyleConfig = window.FeatureStyle), e = globalDefaultStyleConfig);
      this._dataLoader.postMessageToAll({
        type: "changeStyle",
        featureStyles: e
      });
    });
    _(this, "_getIconStyleFile", async (e) => {
      const r = this._getMapStyleFiles(e), s = await loadIconSet(r[0]);
      this._dataLoader.postMessageToAll({
        type: "changeIconSetInfo",
        iconSetInfo: s
      });
    });
    const r = e.ak || BaiduMapConfig.ak, s = e.offlineAk || "USER_AK";
    if (this._displayOptions = e.displayOptions, this._url = e.url, this._styleUrl = e.styleUrl, this._styleId = e.styleId, this._styleJson = e.styleJson, this._isOffline = e.isOffline, this._isOffline)
      this._staticUrl = e.staticUrl, this._sourceProjectionName = defaultValue$1(e.projection, PROJECTION_WEB_MERCATOR), this._isWebMercator = this._sourceProjectionName === PROJECTION_WEB_MERCATOR, this._offlineAk = s, this._customid = window.BMAPGL_TILE_DIR_TYPE || "vector-tile";
    else {
      if (!r)
        throw new Error("\u6CA1\u6709\u6709\u6548\u767E\u5EA6\u5730\u56FEAK\uFF0C\u8BF7\u8BBE\u7F6EBaiduMapConfig.ak\u6216options.ak");
      this._staticUrl = "https://maponline0.bdimg.com", this._sourceProjectionName = PROJECTION_BD_MERCATOR, this._isWebMercator = !1, this.sourceCoordType = "BD09", mapStyleHelper.ak = r, tongjiTrack.ak = r, tongjiTrack.sendMessage(["layer", "vector", "normal"]), this._ak = r;
    }
    this._isWebMercator ? (this._isAttach = defaultValue$1(e.isAttach, !0), this._defaultMinLevel = 2, this._defaultMaxLevel = 20) : (this._isAttach = !1, this._defaultMinLevel = 3, this._defaultMaxLevel = 21);
  }
  initProjectionAndGrid() {
    this._sourceProjection = getProjection(this._sourceProjectionName), this._sourceProjectionName === PROJECTION_BD_MERCATOR ? this._grid = new BaiduVectorOnlineGrid(this._engine, this._sourceProjection, this._targetProjection) : this._grid = new BaiduVectorOfflineGrid(this._engine, this._sourceProjection, this._targetProjection);
  }
  async setMapStyle(e) {
    if (!e || !(e.styleId || e.styleJson) || e.styleId && e.styleId === this._styleId || e.styleJson && e.styleJson === this._styleJson)
      return;
    this._styleId = e.styleId, this._styleJson = e.styleJson;
    let r = await mapStyleHelper.getFeatureStyles(e);
    !r || (r.data && r.data.style ? r = r.data.style : r.status !== 0 && console.error(
      "An error occurred when setMapStyle in BaiduVectorProvider: ",
      r.message
    ), this._dataLoader && (this._dataLoader.postMessageToAll({
      type: "changeStyle",
      featureStyles: r
    }), this._needsClearCache = !0, this._engine.requestRender()));
  }
  async _asyncInit() {
    this._dataLoader || (this._dataLoader = new AsyncDataTileLoader(this, WorkerWrapper$2, 2)), await this._loadStyle(), await this._getIconStyleFile("default");
  }
  _getMapStyleFiles(e) {
    let r = !0;
    typeof e == "string" && e !== "default" && (r = !1);
    const s = r ? "" : "_" + (mapStyleNameIdPair[e] - 1);
    if (!this._vctMapStyleDomain) {
      let c = "http://10.27.57.8:8837/dugis-demo-3d";
      this._staticUrl ? c = this._staticUrl : window.BMAPGL_STATIC_URL ? c = window.BMAPGL_STATIC_URL : this._url && (c = this._url), this._vctMapStyleDomain = `${c}/sty/`;
    }
    const a = this._vctMapStyleDomain;
    return [
      a + "icons_2x" + s + ".js?",
      a + "fs" + s + ".js?",
      a + "indoor_fs.js?"
    ];
  }
  getTileURL(e, r, s, a) {
    return a.loaderConfig && (e = a.loaderConfig.baseZ), this._isOffline ? this._getOfflineTileURL(e, r, s, a) : this._getOnlineTileURL(e, r, s, a);
  }
  _getOnlineTileURL(e, r, s, a) {
    const [c, l, h] = a.grid.getRasterTileCoord(e, r, s);
    let d = `${onlineHosts[Math.abs(r + s) % 4]}/pvd/?qt=vtile&v=three&ak=${this._ak}&param=`;
    const f = `x=${l}&y=${h}&z=${c}&styles=pl&textimg=0&v=088&udt=20190618&json=0`;
    return d + window.encodeURIComponent(encodeTileUrl(f));
  }
  _getOfflineTileURL(e, r, s, a) {
    let c = e, l = r, h = s;
    this._isWebMercator || ([c, l, h] = a.grid.getRasterTileCoord(e, r, s));
    let d = `http://10.27.57.8:8837/maptile/v1/pvd/?qt=vtile&x=${l}&y=${h}&z=${c}&styles=pl&textimg=0&v=088&udt=20190618&json=0&ApiAuthorization=${this._offlineAk}`;
    return this._url ? d = `${this._url}/pvd?qt=vtile&x=${l}&y=${h}&z=${c}&styles=pl&textimg=0&v=088&udt=20190618&json=0&ApiAuthorization=${this._offlineAk}` : window.BMAPGL_URL && (d = `${window.BMAPGL_URL}/pvd?qt=vtile&x=${l}&y=${h}&z=${c}&styles=pl&textimg=0&v=088&udt=20190618&json=0&ApiAuthorization=${this._offlineAk}`), d += `&customid=${this._customid}`, d;
  }
  getWorkerOptions() {
    return {
      isAttach: this._isAttach,
      displayOptions: this._displayOptions,
      styleZoomOffset: this._isWebMercator ? 0 : -1
    };
  }
  getFetchOptions(e) {
    return {
      ...e.loaderConfig
    };
  }
  async doRequestVectorTileData(e) {
    const r = await this._dataLoader.requestTile(e), {
      polygon: s,
      polygonOpacity: a,
      line: c,
      dashLine: l,
      textureLine: h,
      gaoqingLine: d,
      polygon3d: f,
      building3d: p,
      poi: m,
      arrow: y
    } = r.content, x = r.isNormalized, v = this._engine.rendering.features.antialias.samples > 0, S = new Group(), E = new Group();
    if (s && s.indices) {
      const b = new BufferGeometry(), w = new InterleavedBuffer(s.attributes, 10);
      b.setAttribute("position", new InterleavedBufferAttribute(w, 3, 0)), b.setAttribute("normal", new InterleavedBufferAttribute(w, 3, 3)), b.setAttribute("color", new InterleavedBufferAttribute(w, 3, 6)), b.setAttribute("layerIndex", new InterleavedBufferAttribute(w, 1, 9)), b.setIndex(new BufferAttribute(s.indices, 1));
      const M = new BaiduVectorMaterial({
        depthTest: !0,
        vertexColors: !0,
        vertexZIndexLegacy: !0,
        enableDepthRange: !0
      });
      M.setCommonUniforms(this._engine.rendering.uniforms);
      const P = new Mesh(b, M);
      P.name = "Polygons", E.add(P);
    }
    if (a && a.indices) {
      const b = new BufferGeometry(), w = new InterleavedBuffer(a.attributes, 11);
      b.setAttribute("position", new InterleavedBufferAttribute(w, 3, 0)), b.setAttribute("normal", new InterleavedBufferAttribute(w, 3, 3)), b.setAttribute("aColor", new InterleavedBufferAttribute(w, 4, 6)), b.setAttribute("layerIndex", new InterleavedBufferAttribute(w, 1, 10)), b.setIndex(new BufferAttribute(a.indices, 1));
      const M = new BaiduVectorMaterial({
        depthTest: !0,
        transparent: !0,
        isColor4: !0,
        vertexColors: !0,
        vertexZIndexLegacy: !0,
        enableDepthRange: !0
      });
      M.setCommonUniforms(this._engine.rendering.uniforms);
      const P = new Mesh(b, M);
      P.name = "Polygons", E.add(P);
    }
    if (c && c.indices) {
      const b = new BufferGeometry(), w = new InterleavedBuffer(c.attributes, 12);
      b.setAttribute("position", new InterleavedBufferAttribute(w, 3, 0)), b.setAttribute("normal", new InterleavedBufferAttribute(w, 3, 3)), b.setAttribute("aColor", new InterleavedBufferAttribute(w, 4, 6)), b.setAttribute("layerIndex", new InterleavedBufferAttribute(w, 1, 10)), b.setAttribute("aWidth", new InterleavedBufferAttribute(w, 1, 11)), b.setIndex(new BufferAttribute(c.indices, 1));
      const M = new FatLineMaterial({
        keepSize: !0,
        depthTest: !0,
        transparent: !v,
        antialias: !v,
        lineWidth: 1,
        vertexColors: !0,
        vertexZIndexLegacy: !0,
        enableDepthRange: !0
      });
      M.setCommonUniforms(this._engine.rendering.uniforms);
      const P = new Mesh(b, M);
      P.name = "Links", E.add(P);
    }
    if (l) {
      const b = Object.keys(l);
      for (let w = 0; w < b.length; w++) {
        const M = b[w], P = l[M], D = this._vctMapStyleDomain + "map_icons2x/" + M + ".png", L = new BufferGeometry(), O = new InterleavedBuffer(P.attributes, 14);
        L.setAttribute("position", new InterleavedBufferAttribute(O, 3, 0)), L.setAttribute("normal", new InterleavedBufferAttribute(O, 3, 3)), L.setAttribute("aColor", new InterleavedBufferAttribute(O, 4, 6)), L.setAttribute("layerIndex", new InterleavedBufferAttribute(O, 1, 10)), L.setAttribute("aWidth", new InterleavedBufferAttribute(O, 1, 11)), L.setAttribute("uv", new InterleavedBufferAttribute(O, 2, 12)), L.setIndex(new BufferAttribute(P.indices, 1));
        const F = new FatLineMaterial({
          keepSize: !0,
          antialias: !0,
          depthTest: !0,
          transparent: !0,
          lineWidth: 100,
          mapGap: 0,
          vertexColors: !0,
          vertexZIndexLegacy: !0,
          enableDepthRange: !0
        });
        F.flipUv = !0, F.setCommonUniforms(this._engine.rendering.uniforms);
        const k = new Mesh(L, F);
        k.onBeforeRender = () => {
          const V = e.targetCenter, N = this._engine.camera, U = this._engine.rendering.renderState, z = N.position, $ = V.clone();
          $.x -= U.cameraOffset.x, $.y -= U.cameraOffset.y, $.z -= U.cameraOffset.z;
          const G = z.distanceTo($), j = getPixelSize$2(
            G,
            N.fov * Math.PI / 180,
            this._engine.container.clientHeight
          );
          F.zoomUnits = j;
        }, k.name = "Links", dashTextureSingleton.get(D).then((V) => {
          V.wrapS = V.wrapT = RepeatWrapping, V.generateMipmaps = !1, V.colorSpace = SRGBColorSpace, F.useMap = !0, F.map = V, E.add(k);
        });
      }
    }
    if (h) {
      const b = Object.keys(h);
      for (let w = 0; w < b.length; w++) {
        const M = b[w], P = h[M], D = this._vctMapStyleDomain + "map_icons2x/" + M + ".png", L = new BufferGeometry(), O = new InterleavedBuffer(P.attributes, 15);
        L.setAttribute("position", new InterleavedBufferAttribute(O, 3, 0)), L.setAttribute("normal", new InterleavedBufferAttribute(O, 3, 3)), L.setAttribute("aColor", new InterleavedBufferAttribute(O, 4, 6)), L.setAttribute("layerIndex", new InterleavedBufferAttribute(O, 1, 10)), L.setAttribute("aWidth", new InterleavedBufferAttribute(O, 1, 11)), L.setAttribute("uv", new InterleavedBufferAttribute(O, 2, 12)), L.setAttribute("totalLength", new InterleavedBufferAttribute(O, 1, 14)), L.setIndex(new BufferAttribute(P.indices, 1));
        const F = new FatLineMaterial({
          keepSize: !1,
          depthTest: !0,
          transparent: !0,
          mapGap: 0,
          lineWidth: 100,
          vertexColors: !0,
          vertexZIndexLegacy: !0,
          enableDepthRange: !0
        });
        F.isSingle = !0, F.flipUv = !0, F.setCommonUniforms(this._engine.rendering.uniforms);
        const k = new Mesh(L, F);
        k.name = "Links", dashTextureSingleton.get(D).then((V) => {
          V.wrapS = V.wrapT = RepeatWrapping, V.generateMipmaps = !1, V.colorSpace = SRGBColorSpace, F.useMap = !0, F.map = V, E.add(k);
        });
      }
    }
    if (d) {
      const b = Object.keys(d);
      for (let w = 0; w < b.length; w++) {
        const M = b[w], P = d[M], D = this._vctMapStyleDomain + "map_icons2x/" + M + ".png", L = new BufferGeometry(), O = new InterleavedBuffer(P.attributes, 14);
        L.setAttribute("position", new InterleavedBufferAttribute(O, 3, 0)), L.setAttribute("normal", new InterleavedBufferAttribute(O, 3, 3)), L.setAttribute("aColor", new InterleavedBufferAttribute(O, 4, 6)), L.setAttribute("layerIndex", new InterleavedBufferAttribute(O, 1, 10)), L.setAttribute("aWidth", new InterleavedBufferAttribute(O, 1, 11)), L.setAttribute("uv", new InterleavedBufferAttribute(O, 2, 12)), L.setIndex(new BufferAttribute(P.indices, 1));
        const F = new FatLineMaterial({
          keepSize: !1,
          antialias: !0,
          depthTest: !0,
          transparent: !0,
          lineWidth: 1,
          mapGap: 0,
          vertexColors: !0,
          vertexZIndexLegacy: !0,
          enableDepthRange: !0
        });
        F.flipUv = !0, F.setCommonUniforms(this._engine.rendering.uniforms);
        const k = new Mesh(L, F);
        k.name = "Links", dashTextureSingleton.get(D).then((V) => {
          V.wrapS = V.wrapT = RepeatWrapping, V.generateMipmaps = !1, V.colorSpace = SRGBColorSpace, F.useMap = !0, F.map = V, E.add(k);
        });
      }
    }
    if (f && f.indices) {
      const b = new BufferGeometry(), w = new InterleavedBuffer(f.attributes, 10);
      b.setAttribute("position", new InterleavedBufferAttribute(w, 3, 0)), b.setAttribute("normal", new InterleavedBufferAttribute(w, 3, 3)), b.setAttribute("color", new InterleavedBufferAttribute(w, 3, 6)), b.setAttribute("layerIndex", new InterleavedBufferAttribute(w, 1, 9)), b.setIndex(new BufferAttribute(f.indices, 1));
      const M = new BaiduVectorMaterial({
        depthTest: !0,
        vertexColors: !0,
        vertexZIndexLegacy: !0,
        enableDepthRange: !0
      });
      M.setCommonUniforms(this._engine.rendering.uniforms);
      const P = new Mesh(b, M);
      P.name = "Polygons3D", E.add(P);
    }
    if (p && p.indices) {
      const b = new BufferGeometry(), w = new InterleavedBuffer(p.attributes, 11);
      b.setAttribute("position", new InterleavedBufferAttribute(w, 3, 0)), b.setAttribute("normal", new InterleavedBufferAttribute(w, 3, 3)), b.setAttribute("color", new InterleavedBufferAttribute(w, 3, 6)), b.setAttribute("heightAndConcave", new InterleavedBufferAttribute(w, 2, 9)), b.setIndex(new BufferAttribute(p.indices, 1));
      const M = new BaiduVectorMaterial({
        depthTest: !0,
        vertexColors: !0
      });
      M.useAO = !0, M.setCommonUniforms(this._engine.rendering.uniforms);
      const P = new Mesh(b, M);
      P.name = "Building3D", S.add(P);
    }
    if (y && y.indices) {
      const b = new BufferGeometry(), w = new InterleavedBuffer(y.attributes, 12);
      b.setAttribute("position", new InterleavedBufferAttribute(w, 3, 0)), b.setAttribute("a_normal", new InterleavedBufferAttribute(w, 3, 3)), b.setAttribute("a_uv", new InterleavedBufferAttribute(w, 2, 6)), b.setAttribute("a_diff", new InterleavedBufferAttribute(w, 3, 8)), b.setAttribute("layerIndex", new InterleavedBufferAttribute(w, 1, 11)), b.setIndex(new BufferAttribute(y.indices, 1));
      const M = new ArrowMaterial({
        transparent: !0,
        vertexZIndexLegacy: !0,
        isGlobe: !!this._engine.map.isGlobe
      });
      M.setCommonUniforms(this._engine.rendering.uniforms);
      const P = new Mesh(b, M);
      P.name = "Arrow", S.add(P);
    }
    if (m && m.length) {
      let b = [];
      const w = this._engine.map.projectionName, M = `${e.x}-${e.y}-${e.z}`;
      for (let P = 0; P < m.length; P++) {
        const D = m[P].position, L = `${D[0]}-${D[1]}-${D[2]}`;
        let O = m[P].uid ? `${m[P].uid}_${M}` : `${m[P].name}-${L}`;
        const F = m[P].hasText ? m[P].styleConfig : defaultStyleConfig, k = defaultValue$1(m[P].iconConfig, {}), V = k.icon ? this._vctMapStyleDomain + "map_icons2x/" + k.icon + ".png" : "", N = defaultValue$1(k.size, [0, 0]), U = defaultValue$1(direction[m[P].direction], "center"), z = k.textDrawOnIcon, $ = m[P].hasText;
        let G = "text_fix";
        V && (G = "icon", $ && (G = "icon_text")), !($ && !m[P].text) && b.push({
          crs: w,
          id: O,
          forceProjected: w === PROJECTION_GEO,
          type: m[P].type ? m[P].type : G,
          rotateZ: "rotateZ" in m[P] ? m[P].rotateZ : void 0,
          position: D,
          text: m[P].text,
          rank: m[P].rank,
          textFillStyle: F.fontRgba,
          textSize: F.fontSize / 2,
          textStrokeStyle: F.haloRgba,
          textStrokeWidth: Math.min(F.haloSize / 2, 4),
          textAnchor: U,
          styleId: m[P].styleId,
          icon: V,
          iconSize: N,
          hasText: m[P].hasText,
          textDrawOnIcon: z
        });
      }
      S.poiLabels = b;
    }
    return x ? (e.projectedBoundingBox.getSize(S.scale), S.scale.z = 1, E.scale.copy(S.scale), S.position.copy(e.targetCenter), E.position.copy(e.targetCenter)) : (S.position.copy(e.targetCenter), E.position.copy(e.targetCenter)), [S, E];
  }
  updateDisplayOptions(e) {
    Object.assign(this._displayOptions, e), this._needsClearCache = !0, this._engine.requestRender();
  }
  _calculateTolerance(e, r, s) {
    const a = e.tile.z;
    let c = 0;
    return a === 5 && s.text === "\u4E2D\u534E\u4EBA\u6C11\u5171\u548C\u56FD" && (c = -3), a === 6 && s.text === "\u5E7F\u5DDE" && (c = -4), a === 7 ? (c = 4, (s.text === "\u4E09\u6C99" || s.text === "\u4E09\u4E9A" || s.text === "\u510B\u5DDE") && (c = -1)) : a > 7 && (c = 12), (s.text === "\u9999\u6E2F" || s.text === "\u6FB3\u95E8" || s.text === "\u53F0\u5317") && (c = -3), c;
  }
  _addTilePOI(e, r) {
    if (e.object && e.object.poiLabels) {
      const s = e.dataTile.key, a = e.tile._distance, c = e.tile.z < 10, l = [];
      for (let d = 0; d < e.object.poiLabels.length; d++) {
        const f = e.object.poiLabels[d];
        this._labels[f.id] || (this._labels[f.id] = f, f.bucket = s, f.distance = a, f.checkVisible = c, f.tolerance = this._calculateTolerance(e, r, f), l.push(f));
      }
      const h = e.dataTile.key;
      r.rendering.label.addLabels(l, h);
    }
  }
  _removeTilePOI(e, r) {
    if (e.object && e.object.poiLabels) {
      const s = [], a = e.dataTile.key;
      for (let c = 0; c < e.object.poiLabels.length; c++) {
        const l = e.object.poiLabels[c];
        this._labels[l.id] && (delete this._labels[l.id], s.push(l));
      }
      r.rendering.label.removeLabels(s, a);
    }
  }
  onTileDispose(e) {
  }
  onSurfaceTileAdded(e, r) {
    e.isMeetSSE && this._addTilePOI(e, r);
  }
  onSurfaceTileRemoved(e, r) {
    this._removeTilePOI(e, r);
  }
  onSurfaceTileSSEChanged(e, r) {
    e.isMeetSSE ? this._addTilePOI(e, r) : this._removeTilePOI(e, r);
  }
  addAllSymbols() {
    Object.keys(this._labels).forEach((e) => {
      const r = this._labels[e];
      r.isHidden && (r.isHidden = !1, this._engine.rendering.label.addLabel(r));
    });
  }
  removeAllSymbols() {
    Object.keys(this._labels).forEach((e) => {
      const r = this._labels[e];
      r.isHidden || (r.isHidden = !0, this._engine.rendering.label.removeLabel(r));
    });
  }
}
class EngineMap extends EventDispatcher {
  constructor(e, r = {}) {
    super();
    _(this, "_engine");
    _(this, "_map");
    _(this, "_container");
    _(this, "_mapType");
    _(this, "handleViewChange", () => {
      this._engine.rendering.requestRender();
    });
    _(this, "handleResolutionChange", (e) => {
      this._engine.rendering.resolution = e;
    });
    this._engine = e, this._options = r;
    const s = e.container;
    let a = null;
    r.projection && r.projection.isProjection ? a = r.projection : a = getProjection(r.projection || PROJECTION_WEB_MERCATOR);
    let c = a.name;
    if (s instanceof HTMLElement)
      if (r.customMap) {
        const l = r.customMap;
        this._map = new l(e, s, r), this._container = s, this._mapType = "custom", a = getProjection(this._map.projectionName || PROJECTION_WEB_MERCATOR);
      } else
        c === PROJECTION_ECEF ? (this._map = new Earth(e, s, r), this._container = s, this._mapType = "earth", this.isGlobe = !0) : r.is3DControl === !1 ? (this._map = new BlankMap(e, s, r), this._container = s, this._mapType = "blank") : (this._map = new BlankMap3DControl(e, s, r), this._container = s, this._mapType = "blank_3dcontrol");
    if (!this._map)
      throw new Error("map is invalid");
    this._projection = a, this._map.projection = a, this._map.projectionName = a.name, this._coordType = r.coordType || void 0;
  }
  init() {
    this._map.init(), this._map.onViewChanged = this.handleViewChange, this._map.onResolutionChanged = this.handleResolutionChange;
  }
  afterInit() {
    const e = this._engine, r = this._map;
    r.canvas = e.rendering.canvas, r.camera = e.rendering.camera, addClass(this._container, `${CSS_NAMESPACE}-container`), r.afterInit();
    const s = this._options;
    defined$2(s.center) ? r.lookAt(s.center, {
      range: s.range,
      heading: s.heading,
      pitch: s.pitch
    }) : (defined$2(s.heading) && r.setHeading(s.heading), defined$2(s.pitch) && r.setPitch(s.pitch), defined$2(s.range) && r.setRange(s.range));
    let a = s.provider;
    if (a === null || (a || (a = new BaiduVectorTileProvider()), !a))
      return;
    let c = null, l = null, h;
    if (a.isVectorTileProvider)
      l = a, h = null;
    else if (a.isImageryTileProvider)
      c = a;
    else
      throw new Error("invalid tile provider");
    this._mapView = this._engine.add(new MapView({
      vectorProvider: l,
      imageryProvider: c,
      terrainProvider: h
    }));
  }
  setCenter(e) {
    this._map.setCenter(e);
  }
  setZoom(e) {
    this._map.setZoom(e);
  }
  setHeading(e) {
    this._map.setHeading(e);
  }
  setPitch(e) {
    this._map.setPitch(e);
  }
  setRange(e) {
    this._map.setRange(e);
  }
  setBounds(e) {
    this._map.setBounds(e);
  }
  lockDrag(e) {
    this._map.lockDrag(e);
  }
  setMaxRange(e) {
    this._map.setMaxRange(e);
  }
  setMinRange(e) {
    this._map.setMinRange(e);
  }
  lookAt(e, r = {}) {
    if (!e) {
      console.error("engine.map.lookAt: target is required");
      return;
    }
    this._map.lookAt(e, r);
  }
  getBoundingBox() {
    return this._map.getBounds();
  }
  getCenter() {
    return this._map.getCenter();
  }
  getRange() {
    return this._map.getRange();
  }
  getZoom() {
    return this._map.getZoom();
  }
  getZoomUnits() {
    return this._map.getZoomUnits();
  }
  getZoomByZoomUnits(e) {
    return this._map.getZoomByZoomUnits(e);
  }
  getZoomUnitsByZoom(e) {
    return this._map.getZoomUnitsByZoom(e);
  }
  getHeading() {
    return this._map.getHeading();
  }
  flyTo(e, r = {}) {
    if (this._map.flyTo)
      return this._map.flyTo(e, r);
    errorOnce("flyTo is not supported by this map");
  }
  getPitch() {
    return this._map.getPitch();
  }
  getProjectionCenter() {
    return this._map.getProjectionCenter();
  }
  getCameraDistance(e) {
    return this._map.getCameraDistance(e);
  }
  getBounds() {
    return this._map.getBounds();
  }
  getProjectionBounds() {
    return this._map.getProjectionBounds();
  }
  getResolution() {
    return this._map.getResolution();
  }
  projectArrayCoordinate(e, r) {
    return this._map.projectArrayCoordinate(e, r);
  }
  unprojectArrayCoordinate(e, r) {
    return this._map.unprojectArrayCoordinate(e, r);
  }
  projectPointArr(e, r) {
    return console.warn("projectPointArr is deprecated, use projectArrayCoordinate instead"), this.projectArrayCoordinate(e, r);
  }
  unprojectPointArr(e, r) {
    return console.warn("unprojectPointArr is deprecated, use unprojectArrayCoordinate instead"), this.unprojectArrayCoordinate(e, r);
  }
  projectCoordinate(e, r) {
    return this._projection.projectCoordinate(e, r);
  }
  unprojectCoordinate(e, r) {
    return this._projection.unprojectCoordinate(e, r);
  }
  projectArrayCoordinates(e) {
    if (Array.isArray(e[0])) {
      const r = [];
      for (let s of e)
        r.push(this.projectArrayCoordinates(s));
      return r;
    } else if (typeof e[0] == "number" || typeof e[0] == "string")
      return this.projectArrayCoordinate(e);
  }
  enableControl() {
    console.warn("enableControl is deprecated, use engine.controller.enabled = true instead"), this._map.enableControl();
  }
  disableControl() {
    console.warn("disableControl is deprecated, use engine.controller.enabled = false instead"), this._map.disableControl();
  }
  updateCamera() {
    this._map.updateCamera();
  }
  getScaleAt(e) {
    return 1 / Math.cos(Math.PI * e[1] / 180);
  }
  zoomIn() {
    this._map.zoomIn();
  }
  zoomOut() {
    this._map.zoomOut();
  }
  zoomTo(e, r = { range: 0, zoom: 0 }) {
    let s = null;
    if (e.is3DTiles)
      s = e.getBounds();
    else if (e.isInstancedMesh)
      e.computeBoundingBox(), s = e.boundingBox, s = s.clone(), s.applyMatrix4(e.matrixWorld);
    else if (e.isMesh || e.isPoints) {
      const p = e.geometry;
      s = p.boundingBox, s || (p.computeBoundingBox(), s = p.boundingBox), s = s.clone(), s.applyMatrix4(e.matrixWorld);
    } else
      e.boundingBox && (s = e.boundingBox, s = s.clone(), s.applyMatrix4(e.matrixWorld));
    if (!s)
      return;
    const a = this.getResolution(), c = (s.max.x - s.min.x) / a.x, l = (s.max.y - s.min.y) / a.y, h = Math.max(c, l), d = this._map.getZoomByZoomUnits(h), f = [
      (s.max.x + s.min.x) / 2,
      (s.max.y + s.min.y) / 2,
      (s.max.z + s.min.z) / 2
    ];
    if (this._map.isBlankMap3D || this.isGlobe) {
      let m = Math.max(s.max.x - s.min.x, s.max.y - s.min.y) / Math.tan(this.fov / 2 * Math.PI / 180);
      const y = this._map.unprojectArrayCoordinate(f);
      this.lookAt(y, {
        range: m + r.range
      }), this._map.range = m + r.range;
    } else
      this._map.setProjectionCenter(f), this._map.setZoom(d + r.zoom);
    this._engine.requestRender();
  }
  getViewHeight() {
    return this._map.getViewHeight();
  }
  getCameraLocation(e) {
    return this._map.getCameraLocation(e);
  }
  setViewport(e, r = { range: 0, zoom: 0 }) {
    if (!e || e.length < 2) {
      console.warn("setViewport: points require Array with at least 2 points");
      return;
    }
    let s = new Box3(), a = e.map((m) => {
      if (m.isVector3 || m.isVector2)
        return this.projectCoordinate(m);
      let y = this.projectArrayCoordinate(m);
      return new Vector3$1(y[0], y[1], y[2] || 0);
    });
    s.setFromPoints(a);
    const c = this.getResolution(), l = (s.max.x - s.min.x) / c.x, h = (s.max.y - s.min.y) / c.y, d = Math.max(l, h), f = Math.min(30, this._map.getZoomByZoomUnits(d)), p = [
      (s.max.x + s.min.x) / 2,
      (s.max.y + s.min.y) / 2,
      (s.max.z + s.min.z) / 2
    ];
    if (this._map.isBlankMap3D || this.isGlobe) {
      let y = Math.max(s.max.x - s.min.x, s.max.y - s.min.y) / Math.tan(this.fov / 2 * Math.PI / 180), x = this.unprojectArrayCoordinate(p);
      this.lookAt(x, {
        range: y + r.range
      }), this._map.range = y + r.range;
    } else
      this._map.setProjectionCenter(p), this._map.setZoom(f + r.zoom);
    this._engine.requestRender();
  }
  bindCanvas() {
    this._map.bindCanvas();
  }
  releaseCanvas() {
    this._map.releaseCanvas();
  }
  pickSeaLevelWorldPosition(e) {
    return this._map.pickSeaLevelWorldPosition(e);
  }
  dispose() {
    this._map.dispose();
  }
  set onResolutionChanged(e) {
    this._map.onResolutionChanged = e;
  }
  get projectionName() {
    return this._projection.name;
  }
  get map() {
    return this._map;
  }
  get mapType() {
    return this._mapType;
  }
  get container() {
    return console.warn("container is deprecated, use engine.container instead"), this._container;
  }
  get fov() {
    return this._map.fov;
  }
  set fov(e) {
    this._map.fov = e, this._engine.camera.fov = e;
  }
  get near() {
    return this._map.near;
  }
  get far() {
    return this._map.far;
  }
  get projection() {
    return this._projection;
  }
  set projection(e) {
    this._projection = e;
  }
  get mapView() {
    return this._mapView;
  }
  get coordType() {
    return this._coordType;
  }
}
class BoundingBoxHelper extends Object3D {
  constructor() {
    super();
    _(this, "_boxGeometry");
    _(this, "_boxMesh");
    this._boxMaterial = new MeshBasicMaterial({
      transparent: !0,
      color: 16711680,
      opacity: 0.3
    });
  }
  attach(e) {
    this._object = e;
    const r = e.geometry;
    r.boundingBox || r.computeBoundingBox(), this._boxGeometry && this._boxGeometry.dispose();
    const s = r.boundingBox;
    if (this._boxGeometry = new BoxGeometry(
      s.max.x - s.min.x,
      s.max.y - s.min.y,
      s.max.z - s.min.z
    ), this._boxMesh)
      this._boxMesh.geometry = this._boxGeometry;
    else {
      const a = this._boxMesh = new Mesh(this._boxGeometry, this._boxMaterial);
      this.add(a);
    }
  }
  detach() {
    this._object = null, this.remove(this._boxMesh), this._boxMesh = null;
  }
  onBeforeScenePrepareRender() {
    if (this._object) {
      this._object.updateMatrixWorld();
      const e = this._boxMesh;
      this._object.matrixWorld.decompose(e.position, e.rotation, e.scale);
    }
  }
}
const _raycaster = new Raycaster(), _tempVector = new Vector3$1(), _tempVector2 = new Vector3$1(), _tempQuaternion = new Quaternion$1(), _unit = {
  X: new Vector3$1(1, 0, 0),
  Y: new Vector3$1(0, 1, 0),
  Z: new Vector3$1(0, 0, 1)
}, _changeEvent$1 = { type: "change" }, _mouseDownEvent = { type: "pointerdown" }, _mouseUpEvent = { type: "pointerup", mode: null }, _mouseMoveEvent = { type: "pointermove", mode: null }, _objectChangeEvent = { type: "objectChange" };
class TransformControls extends Object3D {
  constructor(e, r) {
    super();
    _(this, "_cameraScale");
    _(this, "_endNorm");
    _(this, "_gizmo");
    _(this, "_getPointer");
    _(this, "_onPointerDown");
    _(this, "_onPointerHover");
    _(this, "_onPointerMove");
    _(this, "_onPointerUp");
    _(this, "_parentPosition");
    _(this, "_parentQuaternion");
    _(this, "_parentQuaternionInv");
    _(this, "_parentScale");
    _(this, "_plane");
    _(this, "_positionStart");
    _(this, "_quaternionStart");
    _(this, "_scaleStart");
    _(this, "_startNorm");
    _(this, "_worldQuaternionInv");
    _(this, "_worldScale");
    _(this, "_worldScaleStart");
    _(this, "_offset");
    _(this, "isTransformControls");
    r === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), r = document), this.visible = !1, this.domElement = r, this.domElement.style.touchAction = "none";
    const s = new TransformControlsGizmo();
    this._gizmo = s, this.add(s);
    const a = new TransformControlsPlane();
    this._plane = a, this.add(a);
    const c = this;
    function l(w, M) {
      let P = M;
      Object.defineProperty(c, w, {
        get: function() {
          return P !== void 0 ? P : M;
        },
        set: function(D) {
          P !== D && (P = D, a[w] = D, s[w] = D, c.dispatchEvent({ type: w + "-changed", value: D }), c.dispatchEvent(_changeEvent$1));
        }
      }), c[w] = M, a[w] = M, s[w] = M;
    }
    l("camera", e), l("object", void 0), l("enabled", !0), l("axis", null), l("mode", "translate"), l("translationSnap", null), l("rotationSnap", null), l("scaleSnap", null), l("space", "local"), l("size", 0.7), l("dragging", !1), l("showX", !0), l("showY", !0), l("showZ", !0);
    const h = new Vector3$1(), d = new Vector3$1(), f = new Quaternion$1(), p = new Quaternion$1(), m = new Vector3$1(), y = new Quaternion$1(), x = new Vector3$1(), v = new Vector3$1(), S = new Vector3$1(), E = 0, b = new Vector3$1();
    l("worldPosition", h), l("worldPositionStart", d), l("worldQuaternion", f), l("worldQuaternionStart", p), l("cameraPosition", m), l("cameraQuaternion", y), l("pointStart", x), l("pointEnd", v), l("rotationAxis", S), l("rotationAngle", E), l("eye", b), this._offset = new Vector3$1(), this._startNorm = new Vector3$1(), this._endNorm = new Vector3$1(), this._cameraScale = new Vector3$1(), this._parentPosition = new Vector3$1(), this._parentQuaternion = new Quaternion$1(), this._parentQuaternionInv = new Quaternion$1(), this._parentScale = new Vector3$1(), this._worldScaleStart = new Vector3$1(), this._worldQuaternionInv = new Quaternion$1(), this._worldScale = new Vector3$1(), this._positionStart = new Vector3$1(), this._quaternionStart = new Quaternion$1(), this._scaleStart = new Vector3$1(), this._getPointer = getPointer.bind(this), this._onPointerDown = onPointerDown.bind(this), this._onPointerHover = onPointerHover.bind(this), this._onPointerMove = onPointerMove.bind(this), this._onPointerUp = onPointerUp.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    _raycaster.setFromCamera(e, this.camera);
    const r = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    r ? this.axis = r.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e.button !== 0) && this.axis !== null) {
      _raycaster.setFromCamera(e, this.camera);
      const r = intersectObjectWithRay(this._plane, _raycaster, !0);
      r && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(r.point).sub(this.worldPositionStart)), this.dragging = !0, _mouseDownEvent.mode = this.mode, this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(e) {
    const r = this.axis, s = this.mode, a = this.object;
    let c = this.space;
    if (s === "scale" ? c = "local" : (r === "E" || r === "XYZE" || r === "XYZ") && (c = "world"), a === void 0 || r === null || this.dragging === !1 || e.button !== -1)
      return;
    _raycaster.setFromCamera(e, this.camera);
    const l = intersectObjectWithRay(this._plane, _raycaster, !0);
    if (!!l) {
      if (this.pointEnd.copy(l.point).sub(this.worldPositionStart), s === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), c === "local" && r !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), r.indexOf("X") === -1 && (this._offset.x = 0), r.indexOf("Y") === -1 && (this._offset.y = 0), r.indexOf("Z") === -1 && (this._offset.z = 0), c === "local" && r !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), a.position.copy(this._offset).add(this._positionStart), this.translationSnap && (c === "local" && (a.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert()), r.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), r.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), r.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.position.applyQuaternion(this._quaternionStart)), c === "world" && (a.parent && a.position.add(_tempVector.setFromMatrixPosition(a.parent.matrixWorld)), r.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), r.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), r.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.parent && a.position.sub(_tempVector.setFromMatrixPosition(a.parent.matrixWorld))));
      else if (s === "scale") {
        if (r.search("XYZ") !== -1) {
          let h = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (h *= -1), _tempVector2.set(h, h, h);
        } else
          _tempVector.copy(this.pointStart), _tempVector2.copy(this.pointEnd), _tempVector.applyQuaternion(this._worldQuaternionInv), _tempVector2.applyQuaternion(this._worldQuaternionInv), _tempVector2.divide(_tempVector), r.search("X") === -1 && (_tempVector2.x = 1), r.search("Y") === -1 && (_tempVector2.y = 1), r.search("Z") === -1 && (_tempVector2.z = 1);
        a.scale.copy(this._scaleStart).multiply(_tempVector2), this.scaleSnap && (r.search("X") !== -1 && (a.scale.x = Math.round(a.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), r.search("Y") !== -1 && (a.scale.y = Math.round(a.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), r.search("Z") !== -1 && (a.scale.z = Math.round(a.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (s === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const h = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
        r === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : r === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * h) : (r === "X" || r === "Y" || r === "Z") && (this.rotationAxis.copy(_unit[r]), _tempVector.copy(_unit[r]), c === "local" && _tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(_tempVector.cross(this.eye).normalize()) * h), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), c === "local" && r !== "E" && r !== "XYZE" ? (a.quaternion.copy(this._quaternionStart), a.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), a.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), a.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(_changeEvent$1), this.dispatchEvent(_objectChangeEvent), _mouseMoveEvent.mode = this.mode, this.dispatchEvent(_mouseMoveEvent);
    }
  }
  pointerUp(e) {
    e.button === 0 && (this.dragging && this.axis !== null && (_mouseUpEvent.mode = this.mode, this.dispatchEvent(_mouseUpEvent)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    !this.enabled || this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(_changeEvent$1), this.dispatchEvent(_objectChangeEvent), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return _raycaster;
  }
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
  update() {
    console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.");
  }
}
TransformControls.prototype.isTransformControls = !0;
function getPointer(o) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: o.button
    };
  {
    const i = this.domElement.getBoundingClientRect();
    return {
      x: (o.clientX - i.left) / i.width * 2 - 1,
      y: -(o.clientY - i.top) / i.height * 2 + 1,
      button: o.button
    };
  }
}
function onPointerHover(o) {
  if (!!this.enabled)
    switch (o.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(o));
        break;
    }
}
function onPointerDown(o) {
  !this.enabled || (this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(o)), this.pointerDown(this._getPointer(o)));
}
function onPointerMove(o) {
  !this.enabled || this.pointerMove(this._getPointer(o));
}
function onPointerUp(o) {
  !this.enabled || (this.domElement.releasePointerCapture(o.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(o)));
}
function intersectObjectWithRay(o, i, e) {
  const r = i.intersectObject(o, !0);
  for (let s = 0; s < r.length; s++)
    if (r[s].object.visible || e)
      return r[s];
  return !1;
}
const _tempEuler = new Euler(), _alignVector = new Vector3$1(0, 1, 0), _zeroVector = new Vector3$1(0, 0, 0), _lookAtMatrix = new Matrix4(), _tempQuaternion2 = new Quaternion$1(), _identityQuaternion = new Quaternion$1(), _dirVector = new Vector3$1(), _tempMatrix$1 = new Matrix4(), _unitX = new Vector3$1(1, 0, 0), _unitY = new Vector3$1(0, 1, 0), _unitZ = new Vector3$1(0, 0, 1), _v1 = new Vector3$1(), _v2 = new Vector3$1(), _v3 = new Vector3$1();
class TransformControlsGizmo extends Object3D {
  constructor() {
    super(), this.type = "TransformControlsGizmo";
    const i = new MeshBasicMaterial({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), e = new LineBasicMaterial({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), r = i.clone();
    r.opacity = 0.15;
    const s = e.clone();
    s.opacity = 0.5;
    const a = i.clone();
    a.color.setHex(16711680);
    const c = i.clone();
    c.color.setHex(65280);
    const l = i.clone();
    l.color.setHex(255);
    const h = i.clone();
    h.color.setHex(16711680), h.opacity = 0.5;
    const d = i.clone();
    d.color.setHex(65280), d.opacity = 0.5;
    const f = i.clone();
    f.color.setHex(255), f.opacity = 0.5;
    const p = i.clone();
    p.opacity = 0.25;
    const m = i.clone();
    m.color.setHex(16776960), m.opacity = 0.25, i.clone().color.setHex(16776960);
    const x = i.clone();
    x.color.setHex(7895160);
    const v = new CylinderGeometry(0, 0.04, 0.1, 12);
    v.translate(0, 0.05, 0);
    const S = new BoxGeometry(0.08, 0.08, 0.08);
    S.translate(0, 0.04, 0);
    const E = new BufferGeometry();
    E.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const b = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    b.translate(0, 0.25, 0);
    function w($, G) {
      const j = new TorusGeometry($, 75e-4, 3, 64, G * Math.PI * 2);
      return j.rotateY(Math.PI / 2), j.rotateX(Math.PI / 2), j;
    }
    function M() {
      const $ = new BufferGeometry();
      return $.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), $;
    }
    const P = {
      X: [
        [new Mesh(v, a), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(v, a), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(b, a), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(v, c), [0, 0.5, 0]],
        [new Mesh(v, c), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(b, c)]
      ],
      Z: [
        [new Mesh(v, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(v, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(b, l), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), p.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), f.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), d.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, D = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), r)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), r), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), r), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), r), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, L = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), s), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), s), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(M(), s), null, null, null, "helper"]
      ],
      X: [
        [new Line(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(E, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(E, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, O = {
      XYZE: [
        [new Mesh(w(0.5, 1), x), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(w(0.5, 0.5), a)]
      ],
      Y: [
        [new Mesh(w(0.5, 0.5), c), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(w(0.5, 0.5), l), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(w(0.75, 1), m), null, [0, Math.PI / 2, 0]]
      ]
    }, F = {
      AXIS: [
        [new Line(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, k = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), r)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), r), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), r), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), r), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), r)]
      ]
    }, V = {
      X: [
        [new Mesh(S, a), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(b, a), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(S, a), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(S, c), [0, 0.5, 0]],
        [new Mesh(b, c)],
        [new Mesh(S, c), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(S, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(b, l), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(S, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), f), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), d), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), p.clone())]
      ]
    }, N = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), r), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), r), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), r), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), r), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), r), [0, 0, 0]]
      ]
    }, U = {
      X: [
        [new Line(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(E, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(E, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function z($) {
      const G = new Object3D();
      for (const j in $)
        for (let Y = $[j].length; Y--; ) {
          const H = $[j][Y][0].clone(), W = $[j][Y][1], q = $[j][Y][2], Z = $[j][Y][3], X = $[j][Y][4];
          H.name = j, H.tag = X, W && H.position.set(W[0], W[1], W[2]), q && H.rotation.set(q[0], q[1], q[2]), Z && H.scale.set(Z[0], Z[1], Z[2]), H.updateMatrix();
          const K = H.geometry.clone();
          K.applyMatrix4(H.matrix), H.geometry = K, H.renderOrder = 1 / 0, H.position.set(0, 0, 0), H.rotation.set(0, 0, 0), H.scale.set(1, 1, 1), G.add(H);
        }
      return G;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = z(P)), this.add(this.gizmo.rotate = z(O)), this.add(this.gizmo.scale = z(V)), this.add(this.picker.translate = z(D)), this.add(this.picker.rotate = z(k)), this.add(this.picker.scale = z(N)), this.add(this.helper.translate = z(L)), this.add(this.helper.rotate = z(F)), this.add(this.helper.scale = z(U)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  onBeforeScenePrepareRender() {
    const e = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let r = [];
    r = r.concat(this.picker[this.mode].children), r = r.concat(this.gizmo[this.mode].children), r = r.concat(this.helper[this.mode].children);
    for (let s = 0; s < r.length; s++) {
      const a = r[s];
      a.visible = !0, a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
      let c;
      if (this.camera.isOrthographicCamera ? c = (this.camera.top - this.camera.bottom) / this.camera.zoom : c = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), a.scale.set(1, 1, 1).multiplyScalar(c * this.size / 4), a.tag === "helper") {
        a.visible = !1, a.name === "AXIS" ? (a.position.copy(this.worldPositionStart), a.visible = !!this.axis, this.axis === "X" && (_tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0)), a.quaternion.copy(e).multiply(_tempQuaternion), Math.abs(_alignVector.copy(_unitX).applyQuaternion(e).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Y" && (_tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2)), a.quaternion.copy(e).multiply(_tempQuaternion), Math.abs(_alignVector.copy(_unitY).applyQuaternion(e).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Z" && (_tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0)), a.quaternion.copy(e).multiply(_tempQuaternion), Math.abs(_alignVector.copy(_unitZ).applyQuaternion(e).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "XYZE" && (_tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0)), _alignVector.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY)), a.quaternion.multiply(_tempQuaternion), a.visible = this.dragging), this.axis === "E" && (a.visible = !1)) : a.name === "START" ? (a.position.copy(this.worldPositionStart), a.visible = this.dragging) : a.name === "END" ? (a.position.copy(this.worldPosition), a.visible = this.dragging) : a.name === "DELTA" ? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(_tempVector), a.visible = this.dragging) : (a.quaternion.copy(e), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(e), this.mode === "translate" || this.mode === "scale" ? (a.name === "X" && Math.abs(_alignVector.copy(_unitX).applyQuaternion(e).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Y" && Math.abs(_alignVector.copy(_unitY).applyQuaternion(e).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Z" && Math.abs(_alignVector.copy(_unitZ).applyQuaternion(e).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XY" && Math.abs(_alignVector.copy(_unitZ).applyQuaternion(e).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "YZ" && Math.abs(_alignVector.copy(_unitX).applyQuaternion(e).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XZ" && Math.abs(_alignVector.copy(_unitY).applyQuaternion(e).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1)) : this.mode === "rotate" && (_tempQuaternion2.copy(e), _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(e).invert()), a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY)), a.name === "X" && (_tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z)), _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion), a.quaternion.copy(_tempQuaternion)), a.name === "Y" && (_tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z)), _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion), a.quaternion.copy(_tempQuaternion)), a.name === "Z" && (_tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x)), _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion), a.quaternion.copy(_tempQuaternion))), a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX), a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY), a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ), a.visible = a.visible && (a.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), a.material._color = a.material._color || a.material.color.clone(), a.material._opacity = a.material._opacity || a.material.opacity, a.material.color.copy(a.material._color), a.material.opacity = a.material._opacity, this.enabled && this.axis && (a.name === this.axis || this.axis.split("").some(function(l) {
        return a.name === l;
      })) && (a.material.color.setHex(16776960), a.material.opacity = 1);
    }
  }
}
TransformControlsGizmo.prototype.isTransformControlsGizmo = !0;
class TransformControlsPlane extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: !1, wireframe: !0, side: DoubleSide, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(i) {
    let e = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), _v1.copy(_unitX).applyQuaternion(e === "local" ? this.worldQuaternion : _identityQuaternion), _v2.copy(_unitY).applyQuaternion(e === "local" ? this.worldQuaternion : _identityQuaternion), _v3.copy(_unitZ).applyQuaternion(e === "local" ? this.worldQuaternion : _identityQuaternion), _alignVector.copy(_v2), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1), _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2), _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3), _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3), _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    _dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (_tempMatrix$1.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector), this.quaternion.setFromRotationMatrix(_tempMatrix$1)), super.updateMatrixWorld(i);
  }
  raycast(i, e) {
    e.length || super.raycast(i, e);
  }
}
TransformControlsPlane.prototype.isTransformControlsPlane = !0;
class TransformControl extends TransformControls {
  constructor(e) {
    super(e.camera, e.map.container);
    _(this, "_enableKeyboardEvent", !1);
    _(this, "handleKeyboardEvent", (e) => {
      switch (e.keyCode) {
        case 81:
          this.setSpace(this.space === "local" ? "world" : "local");
          break;
        case 87:
          this.setMode("translate");
          break;
        case 69:
          this.setMode("rotate");
          break;
        case 82:
          this.setMode("scale");
          break;
        case 187:
        case 107:
          this.setSize(this.size + 0.1);
          break;
        case 189:
        case 109:
          this.setSize(Math.max(this.size - 0.1, 0.1));
          break;
        case 88:
          this.showX = !this.showX;
          break;
        case 89:
          this.showY = !this.showY;
          break;
        case 90:
          this.showZ = !this.showZ;
          break;
        case 32:
          this.enabled = !this.enabled;
          break;
        case 27:
          this.reset();
          break;
      }
    });
    this.engine = e, this.addEventListener("change", (r) => {
      e.requestRender();
    }), this.addEventListener("objectChange", (r) => {
      e.requestRender();
    }), this.addEventListener("dragging-changed", (r) => {
      r.value ? e.map.disableControl() : e.map.enableControl();
    });
  }
  dispose() {
    super.dispose(), this.enableKeyboardEvent = !1;
  }
  set enableKeyboardEvent(e) {
    e !== this._enableKeyboardEvent && (this._enableKeyboardEvent = e, e ? window.addEventListener("keydown", this.handleKeyboardEvent) : window.removeEventListener("keydown", this.handleKeyboardEvent));
  }
}
class EngineSelection extends EventDispatcher {
  constructor(e, r = {}) {
    super();
    _(this, "_engine");
    _(this, "_boundingBoxHelper");
    _(this, "_selectedObject");
    _(this, "_transformControl");
    this._engine = e;
  }
  isSelected(e) {
    return e === this._selectedObject;
  }
  select(e) {
    e.__engine_selected || (this._selectedObject && (this._selectedObject.__engine_selected = !1), this._boundingBoxHelper || (this._boundingBoxHelper = new BoundingBoxHelper(), this._engine.add(this._boundingBoxHelper)), this._boundingBoxHelper.attach(e), this._selectedObject = e, e.__engine_selected = !0, this._engine.requestRender());
  }
  deselect(e) {
    !this.isSelected(e) || (this._boundingBoxHelper.detach(), this._selectedObject = null, e.__engine_selected = !1, this._engine.requestRender());
  }
  get transformControl() {
    return this._transformControl || (this._transformControl = new TransformControl(this._engine), this._transformControl.enableKeyboardEvent = !0), this._transformControl;
  }
  attachTransform(e) {
    const r = this._engine, s = this.transformControl;
    r.add(s), s.attach(e), s.updateMatrixWorld(), r.requestRender();
  }
  detachTransform() {
    const e = this._engine, r = this.transformControl;
    e.remove(r), r.detach();
  }
  dispose() {
  }
}
class BaseWidgets {
  constructor(i, e, r = null) {
    _(this, "_container");
    _(this, "_enabled");
    _(this, "_options", {});
    _(this, "_element");
    _(this, "_engine");
    this._container = i, this._engine = r, e && typeof e == "object" ? (this._options = e, this._enabled = e.enabled) : this._enabled = !1, this._element = null, this._enabled && this.init();
  }
  init() {
    let i = this._element = this.createDom();
    this._container.appendChild(i), this.afterInit();
  }
  afterInit() {
  }
  createDom() {
    return null;
  }
  dispose() {
    this._element && (this.onDispose(), this._element.remove());
  }
  onDispose() {
  }
  get container() {
    return this._container;
  }
  get element() {
    return this._element;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(i) {
    const e = !!i;
    if (this._enabled !== e) {
      const r = e ? "visible" : "hidden";
      this._element ? (this._element.style.visibility = r, this.onDispose()) : r && this.init(), this._enabled = e;
    }
  }
}
class Logo extends BaseWidgets {
  afterInit() {
    this._options && this._options.url && (this.url = this._options.url);
  }
  createDom() {
    return this._element = document.createElement("img"), addClass(this._element, "logo"), this._url = this._url || getAssetUrl("assets/images/bdImg.png"), this._element.src = this._url, this._element;
  }
  set url(i) {
    this._element && (this._element.src = i), this._url = i;
  }
  get url() {
    return this._url;
  }
}
class Zoom extends BaseWidgets {
  createDom() {
    this.handleZoomIn = this.handleZoomIn.bind(this), this.handleZoomOut = this.handleZoomOut.bind(this), this._element = document.createElement("div"), addClass(this._element, "zoom");
    const i = this._zoomAdd = document.createElement("div");
    addClass(i, "zoom-add");
    const e = document.createElement("div");
    addClass(e, "zoom-add-tag"), e.setAttribute("style", `background-image: url(${getAssetUrl("assets/images/mapZoom2x.png")});`), i.addEventListener(EVENTS.DOWN, this.handleZoomIn), i.appendChild(e);
    const r = this._zoomSub = document.createElement("div");
    addClass(r, "zoom-sub");
    const s = document.createElement("div");
    return addClass(s, "zoom-sub-tag"), s.setAttribute("style", `background-image: url(${getAssetUrl("assets/images/mapZoom2x.png")});`), r.addEventListener(EVENTS.DOWN, this.handleZoomOut), r.appendChild(s), this._element.appendChild(i), this._element.appendChild(r), this._element;
  }
  handleZoomIn() {
    this._engine.map.zoomIn();
  }
  handleZoomOut() {
    this._engine.map.zoomOut();
  }
  onDispose() {
    this._zoomAdd.removeEventListener(EVENTS.DOWN, this.handleZoomIn), this._zoomSub.removeEventListener(EVENTS.DOWN, this.handleZoomOut);
  }
}
class Scale extends BaseWidgets {
  createDom() {
    this._element = document.createElement("div"), addClass(this._element, "scale"), this._text = document.createElement("div"), addClass(this._text, "scale-text"), this._text.innerText = "20km";
    const i = document.createElement("div");
    addClass(i, "scale-line");
    const e = document.createElement("div");
    addClass(e, "scale-line-mid");
    const r = document.createElement("div");
    addClass(r, "scale-line-left");
    const s = document.createElement("div");
    return addClass(s, "scale-line-right"), i.appendChild(e), i.appendChild(r), i.appendChild(s), this._element.appendChild(this._text), this._element.appendChild(i), this.calculateScale = this.calculateScale.bind(this), this._engine.rendering.addPrepareRenderListener(this.calculateScale), this._element;
  }
  calculateScale() {
    const i = this._engine.map.getZoomUnitsByZoom(this._engine.map.getZoom());
    let e = 0;
    const r = [0.05, 0.1, 0.2];
    for (let s = 0; s < 3 && e < 7; s++) {
      const a = r[s] * Math.pow(10, e), c = a / i;
      if (c >= 50 && c <= 150) {
        if (this._element.style.width = c + "px", e < 1)
          this._text.innerText = (a < 0.1 ? 5 : a * 100) + "cm";
        else if (e < 2)
          this._text.innerText = (a < 1 ? 5 : a * 10) + "dm";
        else {
          const l = a / 1e3, h = l < 1;
          this._text.innerText = h ? a + "m" : l + "km";
        }
        break;
      } else
        s < 1 && e < 1 && c > 150 && (this._element.style.width = "150px", this._text.innerText = "< 5cm");
      s > 1 && (e++, s = 0);
    }
  }
  onDispose() {
    this._engine.rendering.removePrepareRenderListener(this.calculateScale);
  }
}
const full = "M358.4 768H426.666667v85.333333H213.333333v-213.333333h85.333334v68.266667l128-128 59.733333 59.733333-128 128z m345.6 0l-128-128 59.733333-59.733333 132.266667 132.266666V640h85.333333v213.333333h-213.333333v-85.333333h64zM358.4 298.666667l128 128-59.733333 59.733333-128-128V426.666667H213.333333V213.333333h213.333334v85.333334H358.4z m345.6 0H640V213.333333h213.333333v213.333334h-85.333333V354.133333l-132.266667 132.266667-59.733333-59.733333 128-128z", exit = "M298.666667 631.466667H226.133333v-81.066667h217.6v204.8h-85.333333v-68.266667l-128 128L170.666667 759.466667l128-128z m422.4 0l128 128-59.733334 59.733333-128-128v68.266667h-85.333333V554.666667h217.6v81.066666h-72.533333zM298.666667 341.333333L187.733333 230.4 243.2 170.666667l115.2 115.2V217.6h85.333333v204.8H226.133333V341.333333H298.666667z m430.933333 0h64v81.066667h-217.6V217.6h85.333333v72.533333L780.8 170.666667l59.733333 59.733333L729.6 341.333333z";
class Fullscreen extends BaseWidgets {
  createDom() {
    this.handleClick = this.handleClick.bind(this), this.handleFullscreenChange = this.handleFullscreenChange.bind(this), this._element = document.createElement("div"), addClass(this._element, "fullscreen");
    const i = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    return i.setAttribute("class", "widgets-group-svg fullscreen-svg"), i.setAttribute("viewBox", "0 0 1024 1024"), i.setAttribute("version", "1.1"), this._path = document.createElementNS("http://www.w3.org/2000/svg", "path"), this._path.setAttribute("d", full), this._path.setAttribute("class", "fullscreen-path"), i.appendChild(this._path), this._flag = !0, this._element.addEventListener(EVENTS.DOWN, this.handleClick), document.addEventListener("fullscreenchange", this.handleFullscreenChange), this._element.appendChild(i), this._element;
  }
  handleClick() {
    const i = this._engine.container, r = i instanceof HTMLElement || i && typeof i == "object" && i.nodeType === 1 && typeof i.nodeName == "string" ? i : i.container || i._container;
    this._flag ? r.requestFullscreen ? r.requestFullscreen() : r.msRequestFullscreen ? r.msRequestFullscreen() : r.mozRequestFullScreen ? r.mozRequestFullScreen() : r.webkitRequestFullScreen && r.webkitRequestFullScreen() : document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen();
  }
  handleFullscreenChange() {
    this._flag = !this._flag, this._flag ? this._path.setAttribute("d", full) : this._path.setAttribute("d", exit);
  }
  onDispose() {
    this._element.removeEventListener(EVENTS.DOWN, this.handleClick), document.removeEventListener("fullscreenchange", this.handleFullscreenChange);
  }
}
class GeoLocate extends BaseWidgets {
  createDom() {
    this.locate = this.locate.bind(this), this._element = document.createElement("div"), addClass(this._element, "geo-locate");
    const i = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    i.setAttribute("class", "widgets-group-svg geo-locate-svg"), i.setAttribute("viewBox", "0 0 1024 1024"), i.setAttribute("version", "1.1");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return e.setAttribute("d", "M87.424 469.312A426.816 426.816 0 0 1 469.312 87.424V0h85.376v87.424a426.816 426.816 0 0 1 381.888 381.888H1024v85.376h-87.424a426.816 426.816 0 0 1-381.888 381.888V1024h-85.376v-87.424A426.816 426.816 0 0 1 87.424 554.688H0v-85.376h87.424z m424.576 384a341.312 341.312 0 1 0 0-682.624 341.312 341.312 0 0 0 0 682.624z m0-170.624a170.688 170.688 0 1 0 0-341.376 170.688 170.688 0 0 0 0 341.376z"), e.setAttribute("class", "geo-locate-path"), i.appendChild(e), this._element.addEventListener(EVENTS.DOWN, this.locate), this._element.appendChild(i), this._element;
  }
  locate() {
    window.navigator.geolocation.getCurrentPosition((i) => {
      var s;
      const { longitude: e, latitude: r } = (s = i.coords) != null ? s : {};
      !isNaN(e) && !isNaN(r) ? (this._engine.map.setCenter([e, r]), this._engine.map.setZoom(18)) : console.error("\u5B9A\u4F4D\u51FA\u9519\uFF0C\u8BF7\u91CD\u65B0\u5B9A\u4F4D\uFF01");
    }, (i) => {
      console.error("\u5B9A\u4F4D\u672A\u5F00\u542F");
    });
  }
  onDispose() {
    this._element.removeEventListener(EVENTS.DOWN, this.locate);
  }
}
class ExportImage extends BaseWidgets {
  constructor() {
    super(...arguments);
    _(this, "screenshot", (e, r) => {
      const s = this._engine.rendering.canvas, a = this._engine.map.mapType, c = document.createElement("canvas"), l = c.getContext("2d");
      if (c.width = s.width, c.height = s.height, a === "bmapgl") {
        const d = this._engine.container._webglPainter._canvas;
        l.drawImage(d, 0, 0, d.width, d.height);
      } else if (a === "mapbox") {
        const d = this._engine.container._canvas;
        l.drawImage(d, 0, 0, d.width, d.height);
      }
      l.drawImage(s, 0, 0, s.width, s.height);
      let h = c.toDataURL();
      if (r) {
        e = e || "download.png";
        const d = document.createElement("a");
        d.href = h, d.download = e, d.click();
      }
      return h;
    });
  }
  createDom() {
    this.handleClick = this.handleClick.bind(this), this._element = document.createElement("div"), addClass(this._element, "export-image");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    e.setAttribute("class", "widgets-group-svg export-image-svg"), e.setAttribute("viewBox", "0 0 1024 1024"), e.setAttribute("version", "1.1");
    const r = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return r.setAttribute("d", "M867.90864 574.538232V257.779543a50.844091 50.844091 0 0 0-50.844092-50.844091h-610.129096a50.844091 50.844091 0 0 0-50.844092 50.844091v499.797418l430.141013-257.779543a152.532274 152.532274 0 0 1 157.108243 0z m0 118.466733l-177.445879-106.264151a50.844091 50.844091 0 0 0-50.844092 0L254.220457 817.064548h562.844091a50.844091 50.844091 0 0 0 50.844092-50.844091z m-660.973188-587.757696h610.129096a152.532274 152.532274 0 0 1 152.532274 152.532274v508.440914a152.532274 152.532274 0 0 1-152.532274 152.532274h-610.129096a152.532274 152.532274 0 0 1-152.532274-152.532274v-508.440914a152.532274 152.532274 0 0 1 152.532274-152.532274z m127.110228 355.90864a76.266137 76.266137 0 1 1 76.266137-76.266137 76.266137 76.266137 0 0 1-76.266137 76.266137z"), e.appendChild(r), this._element.addEventListener(EVENTS.DOWN, this.handleClick), this._element.appendChild(e), this._element;
  }
  handleClick() {
    this.screenshot("download.png", !0);
  }
  onDispose() {
    this._element.removeEventListener(EVENTS.DOWN, this.handleClick);
  }
}
class MapInfo extends BaseWidgets {
  constructor() {
    super(...arguments);
    _(this, "_mapInfo", {
      pitch: 0,
      heading: 0,
      zoom: 0,
      range: 0,
      center: [0, 0],
      mousePoint: [0, 0]
    });
    _(this, "_prefix", {
      M: "\u6307\u9488\u4F4D\u7F6E",
      C: "\u4E2D\u5FC3\u70B9",
      Z: "\u7EA7\u522B",
      H: "\u65CB\u8F6C\u89D2",
      P: "\u503E\u89D2",
      R: "\u89C6\u91CE\u8DDD\u79BB"
    });
    _(this, "_separator", " | ");
    _(this, "_template", "CR");
  }
  afterInit() {
    this._options && this._options.template && (this.template = this._options.template), this._options && this._options.prefix && (this.prefix = this._options.prefix), this._options && this._options.separator && (this.separator = this._options.separator);
  }
  createDom() {
    return this._element = document.createElement("div"), addClass(this._element, "mouse-location"), this._enableMousePositionTracking = !1, this._eventName = "pointerdown", this.eventCallback = this.update.bind(this), this._engine.map.addEventListener(this._eventName, this.eventCallback), this._viewChangedCallback = () => {
      if (this._engine.rendering.renderState.viewChanged) {
        const r = this._engine.map, s = r.getCenter();
        this._mapInfo.pitch = toFixed(r.getPitch()), this._mapInfo.heading = toFixed(r.getHeading()), this._mapInfo.zoom = toFixed(r.getZoom()), this._mapInfo.center = [s[0].toFixed(6), s[1].toFixed(6)], this._mapInfo.range = toFixed(r.getRange()), this.updateInfoText();
      }
    }, this._engine.rendering.addPrepareRenderListener(this._viewChangedCallback), this._element;
  }
  update(e) {
    const r = e.point;
    !r || !/M/gi.test(this._template) || (this._mapInfo.mousePoint = [r[0].toFixed(6), r[1].toFixed(6)], this.updateInfoText());
  }
  updateInfoText() {
    const {
      center: e,
      heading: r,
      pitch: s,
      zoom: a,
      range: c,
      mousePoint: l
    } = this._mapInfo, h = {
      M: l,
      C: e,
      Z: a,
      H: r,
      P: s,
      R: c
    }, d = this.template.replace(
      /[MCZHPR]/gi,
      (f) => `${this.prefix[f.toUpperCase()]}: ${h[f.toUpperCase()]}${this.separator}`
    ).slice(0, -this.separator.length);
    this._element.innerText = d;
  }
  get enableMousePositionTracking() {
    return this._enableMousePositionTracking;
  }
  set enableMousePositionTracking(e) {
    this._enableMousePositionTracking !== e && (this._enableMousePositionTracking = e, this._engine.map.removeEventListener(this._eventName, this.eventCallback), this._eventName = e ? "mousemove" : "pointerdown", this._engine.map.addEventListener(this._eventName, this.eventCallback));
  }
  get template() {
    return this._template;
  }
  set template(e) {
    this._template = e, this.updateInfoText();
  }
  get separator() {
    return this._separator;
  }
  set separator(e) {
    this._separator = e, this.updateInfoText();
  }
  get prefix() {
    return this._prefix;
  }
  set prefix(e) {
    this._prefix = e, this.updateInfoText();
  }
  onDispose() {
    this._engine.map.removeEventListener(this._eventName, this.eventCallback), this._engine.rendering.removePrepareRenderListener(this._viewChangedCallback);
  }
}
function toFixed(o, i) {
  if (!i)
    return Math.round(o);
  const e = 10 * i;
  return Math.round(o * e) / e;
}
class Drawer extends BaseWidgets {
  afterInit() {
    if (this._options && this._options.draws) {
      const i = this._options.draws, e = i && i.length > 0 ? i.length : 0, r = document.getElementById(`${CSS_NAMESPACE}-drawer-content`);
      if (this._drawerCheckboxs = [], e > 0) {
        const s = this.addChangeListener.bind(this);
        for (let a = 0; a < e; a++) {
          const c = i[a], l = document.createElement("div");
          addClass(l, "drawer-item");
          const h = document.createElement("input");
          addClass(h, "drawer-item-check"), s(h, (f) => {
            f.stopPropagation();
            const p = f.target.checked;
            c.onChange && c.onChange(p, c.data, this._engine);
          }), h.setAttribute("type", "checkbox"), c.defaultChecked && (h.setAttribute("checked", c.defaultChecked), c.onChange && c.onChange(!0, c.data, this._engine)), this._drawerCheckboxs.push(h);
          const d = document.createElement("span");
          addClass(d, "drawer-item-name"), d.innerText = c.name, d.onclick = () => {
            h.click();
          }, l.appendChild(h), l.appendChild(d), r.appendChild(l);
        }
      }
    }
  }
  createDom() {
    this._element = document.createElement("div"), addClass(this._element, "drawer");
    const i = this._drawerBtn = document.createElement("div");
    addClass(i, "drawer-btn");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    e.setAttribute("class", "drawer-icon"), e.setAttribute("viewBox", "0 0 1024 1024"), e.setAttribute("version", "1.1");
    const r = document.createElementNS("http://www.w3.org/2000/svg", "path");
    r.setAttribute("d", "M512 821.504l-416-208-96 48 512 256 512-256-96-48-416 208z m0-181.173333l-416-208-96 48 512 256 512-256-96-48-416 208zM1024 298.666667L512 42.666667 0 298.666667l512 256 512-256zM512 138.058667L833.184 298.666667 512 459.274667 190.816 298.666667 512 138.058667z"), e.appendChild(r), i.addEventListener(EVENTS.DOWN, this.openDrawer.bind(this)), i.appendChild(e);
    const s = this._drawerList = document.createElement("div");
    addClass(s, "drawer-list"), s.setAttribute("id", `${CSS_NAMESPACE}-drawer-list`), s.style.display = "none";
    const a = document.createElement("div");
    addClass(a, "drawer-content"), a.setAttribute("id", `${CSS_NAMESPACE}-drawer-content`);
    const c = document.createElement("div");
    return addClass(c, "drawer-arrow"), s.appendChild(a), s.appendChild(c), this._element.appendChild(i), this._element.appendChild(s), this._element;
  }
  addChangeListener(i, e) {
    this._eventMap || (this._eventMap = /* @__PURE__ */ new WeakMap()), i.addEventListener("change", e), this._eventMap.set(i, e);
  }
  removeChangeListener(i) {
    const e = this._eventMap.get(i);
    i.removeEventListener("change", e), this._eventMap.delete(i);
  }
  openDrawer() {
    const i = this._drawerList;
    i.style.display = i.style.display === "none" ? "block" : "none";
  }
  onDispose() {
    this._drawerBtn.removeEventListener(EVENTS.DOWN, this.openDrawer.bind(this));
    for (let i = 0; i < this._drawerCheckboxs.length; i++)
      this.removeChangeListener(this._drawerCheckboxs[i]);
  }
}
class Compass extends BaseWidgets {
  createDom() {
    this.handleUpBtnClick = this.handleUpBtnClick.bind(this), this.handleDownBtnClick = this.handleDownBtnClick.bind(this), this.handleLeftBtnClick = this.handleLeftBtnClick.bind(this), this.handleRightBtnClick = this.handleRightBtnClick.bind(this), this.handleCenterBtnClick = this.handleCenterBtnClick.bind(this), this._element = document.createElement("div"), addClass(this._element, "compass"), this._element.setAttribute("style", `background-image: url(${getAssetUrl("assets/images/mapCompass.png")});`), this._up = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._up.setAttribute("class", "compass-up"), this._up.setAttribute("viewBox", "0 0 1024 1024"), this._up.setAttribute("version", "1.1");
    const i = document.createElementNS("http://www.w3.org/2000/svg", "path");
    i.setAttribute("d", "M910.222222 796.444444c-17.066667 0-34.133333-5.688889-45.511111-17.066666L551.822222 409.6c-11.377778-5.688889-17.066667-11.377778-34.133333-11.377778-5.688889 0-22.755556 5.688889-28.444445 11.377778l-329.955555 364.088889c-22.755556 22.755556-56.888889 22.755556-79.644445 5.688889-22.755556-22.755556-22.755556-56.888889-5.688888-79.644445l329.955555-364.088889c28.444444-34.133333 73.955556-51.2 119.466667-51.2s85.333333 22.755556 119.466666 56.888889l312.888889 364.088889c22.755556 22.755556 17.066667 56.888889-5.688889 79.644445-11.377778 5.688889-28.444444 11.377778-39.822222 11.377777z"), this._up.addEventListener(EVENTS.DOWN, this.handleUpBtnClick), this._up.appendChild(i), this._down = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._down.setAttribute("class", "compass-down"), this._down.setAttribute("viewBox", "0 0 1024 1024"), this._down.setAttribute("version", "1.1");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return e.setAttribute("d", "M517.688889 796.444444c-45.511111 0-85.333333-17.066667-119.466667-51.2L73.955556 381.155556c-22.755556-22.755556-17.066667-56.888889 5.688888-79.644445 22.755556-22.755556 56.888889-17.066667 79.644445 5.688889l329.955555 364.088889c5.688889 5.688889 17.066667 11.377778 28.444445 11.377778s22.755556-5.688889 34.133333-17.066667l312.888889-364.088889c22.755556-22.755556 56.888889-28.444444 79.644445-5.688889 22.755556 22.755556 28.444444 56.888889 5.688888 79.644445L637.155556 739.555556c-28.444444 39.822222-68.266667 56.888889-119.466667 56.888888 5.688889 0 0 0 0 0z"), this._down.addEventListener(EVENTS.DOWN, this.handleDownBtnClick), this._down.appendChild(e), this._left = document.createElement("div"), addClass(this._left, "compass-left"), this._left.setAttribute("style", `background-image: url(${getAssetUrl("assets/images/mapCompass.png")});`), this._left.addEventListener(EVENTS.DOWN, this.handleLeftBtnClick), this._right = document.createElement("div"), addClass(this._right, "compass-right"), this._right.setAttribute("style", `background-image: url(${getAssetUrl("assets/images/mapCompass.png")});`), this._right.addEventListener(EVENTS.DOWN, this.handleRightBtnClick), this._compass = document.createElement("div"), addClass(this._compass, "compass-center"), this._compass.setAttribute("style", `background-image: url(${getAssetUrl("assets/images/mapCompass.png")});`), this._compass.addEventListener(EVENTS.DOWN, this.handleCenterBtnClick), this._element.appendChild(this._up), this._element.appendChild(this._down), this._element.appendChild(this._left), this._element.appendChild(this._right), this._element.appendChild(this._compass), this._engine.rendering.addPrepareRenderListener(() => {
      this._compass.style.transform = `rotate(-${this._engine.map.getHeading()}deg)`;
    }), this._element;
  }
  handleUpBtnClick() {
    const i = this._engine.map.getPitch();
    let e = i + 2;
    e = e > 89 ? 89 : e < 0 ? 0 : e, i !== e && this._engine.map.setPitch(e);
  }
  handleDownBtnClick() {
    const i = this._engine.map.getPitch();
    let e = i - 2;
    e = e > 89 ? 89 : e < 0 ? 0 : e, i !== e && this._engine.map.setPitch(e);
  }
  handleLeftBtnClick() {
    let e = this._engine.map.getHeading() - 2;
    this._engine.map.setHeading((e + 360) % 360);
  }
  handleRightBtnClick() {
    let e = this._engine.map.getHeading() + 2;
    this._engine.map.setHeading(e % 360);
  }
  handleCenterBtnClick() {
    this._engine.map.setHeading(0);
  }
  onDispose() {
    this._up.removeEventListener(EVENTS.DOWN, this.handleUpBtnClick), this._down.removeEventListener(EVENTS.DOWN, this.handleDownBtnClick), this._left.removeEventListener(EVENTS.DOWN, this.handleLeftBtnClick), this._right.removeEventListener(EVENTS.DOWN, this.handleRightBtnClick), this._compass.removeEventListener(EVENTS.DOWN, this.handleCenterBtnClick);
  }
}
class EngineWidgets {
  constructor(i, e = {}) {
    _(this, "_container");
    _(this, "_engine");
    _(this, "_logo");
    _(this, "_zoom");
    _(this, "_scale");
    _(this, "_fullscreen");
    _(this, "_geoLocate");
    _(this, "_exportImage");
    _(this, "_mapInfo");
    _(this, "_compass");
    _(this, "_drawer");
    const r = i.container, s = r instanceof HTMLElement || r && typeof r == "object" && r.nodeType === 1 && typeof r.nodeName == "string";
    this._container = s ? r : r.container || r._container;
    const a = this._control = document.createElement("div");
    a.id = `${CSS_NAMESPACE}-widgets-${i.id}`, addClass(a, `${CSS_NAMESPACE}-widgets-pane`), this._container.appendChild(a);
    const c = document.createElement("div");
    addClass(c, "bottom-right-anchor"), this._zoom = new Zoom(c, e.zoom, i), this._compass = new Compass(c, e.compass, i), a.appendChild(c);
    const l = document.createElement("div");
    addClass(l, "bottom-left-anchor"), a.appendChild(l), this._fullscreen = new Fullscreen(l, e.fullscreen, i), this._exportImage = new ExportImage(l, e.exportImage, i), this._geoLocate = new GeoLocate(l, e.geoLocate, i), this._logo = new Logo(a, e.logo, i), this._scale = new Scale(a, e.scale, i), this._mapInfo = new MapInfo(a, e.mapInfo, i), this._drawer = new Drawer(a, e.drawer, i);
  }
  dispose() {
    this._logo.dispose(), this._zoom.dispose(), this._scale.dispose(), this._fullscreen.dispose(), this._geoLocate.dispose(), this._exportImage.dispose(), this._mapInfo.dispose(), this._compass.dispose(), this._drawer.dispose(), this._control.remove();
  }
  get container() {
    return this._container;
  }
  get engine() {
    return this._engine;
  }
  get compass() {
    return this._compass;
  }
  get logo() {
    return this._logo;
  }
  get zoom() {
    return this._zoom;
  }
  get scale() {
    return this._scale;
  }
  get fullscreen() {
    return this._fullscreen;
  }
  get geoLocate() {
    return this._geoLocate;
  }
  get exportImage() {
    return this._exportImage;
  }
  get mapInfo() {
    return this._mapInfo;
  }
  get drawer() {
    return this._drawer;
  }
}
const tt = class {
  constructor(i = {}) {
    this._timeZoneOffset = i.timeZoneOffset !== void 0 ? i.timeZoneOffset : 8;
    const e = this._tzMs = this._timeZoneOffset * 3600 * 1e3;
    let r = 0, s = 0, a = 0;
    if (i.currentTime)
      r = i.currentTime.getTime() - e;
    else {
      const c = new Date();
      c.setHours(10, 0, 0, 0), r = c.getTime() - e;
    }
    i.startTime ? s = i.startTime.getTime() - e : s = r, i.stopTime ? a = i.stopTime.getTime() - e : a = r, this._currentTimeUTC = new Date(r), this._startMs = s, this._stopMs = a, this._currentTime = new Date(this._currentTimeUTC.getTime() + e), this._speed = i.speed || 1, this._tickMode = i.tickMode !== void 0 ? i.tickMode : tt.TICK_NONE;
  }
  tick(i) {
    if (this._tickMode === tt.TICK_NONE)
      return;
    const e = i * this.speed;
    let r = this._currentTimeUTC.getTime() + e;
    if (this._tickMode === tt.TICK_CLAMP)
      r < this._startMs && (r = this._startMs), r > this._stopMs && (r = this._stopMs);
    else if (this._tickMode === tt.TICK_LOOP) {
      const s = this._stopMs - this._startMs, a = (r - this._startMs) % s;
      r = this._startMs + a;
    }
    this._setTimeValueUTC(r);
  }
  _setTimeLegacy(i) {
    const e = Math.floor(i / 3600), r = Math.floor(i % 3600 / 60), s = i % 60, a = this._currentTime;
    a.setHours(e, r, s, 0), this._setTimeValue(a.getTime());
  }
  _setTimeValue(i) {
    this._currentTimeUTC.setTime(i - this._tzMs), this._currentTime.setTime(i);
  }
  _setTimeValueUTC(i) {
    this._currentTimeUTC.setTime(i), this._currentTime.setTime(i + this._tzMs);
  }
  reset() {
    this._setTimeValue(this._startMs);
  }
  get currentTime() {
    return this._currentTime;
  }
  set currentTime(i) {
    this._setTimeValue(i.getTime());
  }
  get currentTimeUTC() {
    return this._currentTimeUTC;
  }
  set currentTimeUTC(i) {
    this._setTimeValueUTC(i.getTime());
  }
  get startTime() {
    return new Date(this._startMs + this._tzMs);
  }
  set startTime(i) {
    this._startMs = i.getTime() - this._tzMs;
  }
  get stopTime() {
    return new Date(this._stopMs + this._tzMs);
  }
  set stopTime(i) {
    this._stopMs = i.getTime() - this._tzMs;
  }
  set timeZoneOffset(i) {
    this._timeZoneOffset = i, this._tzMs = i * 3600 * 1e3, this._currentTime.setTime(this._currentTimeUTC.getTime() + this._tzMs);
  }
  get timeZoneOffset() {
    return this._timeZoneOffset;
  }
  get speed() {
    return this._speed;
  }
  set speed(i) {
    this._speed = i;
  }
  get tickMode() {
    return this._tickMode;
  }
  set tickMode(i) {
    this._tickMode = i;
  }
};
let EngineClock = tt;
_(EngineClock, "TICK_NONE", 0), _(EngineClock, "TICK_NORMAL", 1), _(EngineClock, "TICK_LOOP", 2), _(EngineClock, "TICK_CLAMP", 3);
class EngineController {
  constructor(i, e = {}) {
    _(this, "_engine");
    _(this, "_enabled", !0);
    _(this, "_enableRotate", !0);
    _(this, "_enableZoom", !0);
    _(this, "_enablePan", !0);
    _(this, "_enableTilt", !0);
    _(this, "_enableFixCenter", !1);
    _(this, "_enableTerrainCollision", !1);
    _(this, "_inertiaDragging", 0.9);
    _(this, "_inertiaZoom", 0.8);
    _(this, "_maximumMovementRatio", 0.1);
    _(this, "_bounceAnimationTime", 3);
    _(this, "_minimumZoomDistance", 1);
    _(this, "_maximumZoomDistance", Number.POSITIVE_INFINITY);
    this._engine = i, this.enabled = defaultValue$1(e.enabled, !0), this.enableRotate = defaultValue$1(e.enableRotate, !0), this.enableZoom = defaultValue$1(e.enableZoom, !0), this.enablePan = defaultValue$1(e.enablePan, !0), this.enableTilt = defaultValue$1(e.enableTilt, !0), this.enableFixCenter = defaultValue$1(e.enableFixCenter, !1), this.enableTerrainCollision = defaultValue$1(e.enableTerrainCollision, !1), this.inertiaTranslate = defaultValue$1(e.inertiaTranslate, 0.9), this.inertiaZoom = defaultValue$1(e.inertiaZoom, 0.8), this.maximumMovementRatio = defaultValue$1(e.maximumMovementRatio, 0.1), this.bounceAnimationTime = defaultValue$1(e.bounceAnimationTime, 3), this.minimumZoomDistance = defaultValue$1(e.minimumZoomDistance, 1), this.maximumZoomDistance = defaultValue$1(e.maximumZoomDistance, Number.POSITIVE_INFINITY);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(i) {
    this._enabled = i, this._engine.map._map.controller.enabled = i;
  }
  get enableRotate() {
    return this._enableRotate;
  }
  set enableRotate(i) {
    this._enableRotate = i, this._engine.map._map.controller.enableRotate = i;
  }
  get enableZoom() {
    return this._enableZoom;
  }
  set enableZoom(i) {
    this._enableZoom = i, this._engine.map._map.controller.enableZoom = i;
  }
  get enablePan() {
    return this._enablePan;
  }
  set enablePan(i) {
    this._enablePan = i, this._engine.map._map.controller.enablePan = i;
  }
  get enableTilt() {
    return this._enableTilt;
  }
  set enableTilt(i) {
    this._enableTilt = i, this._engine.map._map.controller.enableTilt = i;
  }
  get enableFixCenter() {
    return this._enableFixCenter;
  }
  set enableFixCenter(i) {
    this._enableFixCenter = i;
  }
  get enableTerrainCollision() {
    return this._enableTerrainCollision;
  }
  set enableTerrainCollision(i) {
    this._enableTerrainCollision = i;
  }
  get inertiaDragging() {
    return this._inertiaDragging;
  }
  set inertiaDragging(i) {
    this._inertiaDragging = i, this._engine.map._map.controller.inertiaDragging = i;
  }
  get inertiaZoom() {
    return this._inertiaZoom;
  }
  set inertiaZoom(i) {
    this._inertiaZoom = i, this._engine.map._map.controller.inertiaZoom = i;
  }
  get maximumMovementRatio() {
    return this._maximumMovementRatio;
  }
  set maximumMovementRatio(i) {
    this._maximumMovementRatio = i;
  }
  get bounceAnimationTime() {
    return this._bounceAnimationTime;
  }
  set bounceAnimationTime(i) {
    this._bounceAnimationTime = i;
  }
  get minimumZoomDistance() {
    return this._minimumZoomDistance;
  }
  set minimumZoomDistance(i) {
    this._minimumZoomDistance = i;
  }
  get maximumZoomDistance() {
    return this._maximumZoomDistance;
  }
  set maximumZoomDistance(i) {
    this._maximumZoomDistance = i;
  }
}
overrideShaders();
let _globalId = 0;
class Engine {
  constructor(i, e = {}) {
    _(this, "_container");
    _(this, "_event");
    _(this, "_map");
    _(this, "_rendering");
    _(this, "_selection");
    _(this, "_widgets");
    _(this, "_clock");
    _(this, "_controller");
    _(this, "isEngine", !0);
    if (this._id = ++_globalId, typeof i == "string" || i instanceof String)
      this._container = document.getElementById(i);
    else if (i instanceof HTMLElement)
      this._container = i;
    else
      throw new Error("container is not a valid container");
    const r = window.getComputedStyle(this._container).position;
    (r === "static" || !r) && (this._container.style.position = "relative"), this._clock = new EngineClock(e.clock), this._event = new EngineEvent(this, e.event), this._map = new EngineMap(this, e.map), this._map.init();
    const s = this.map.getResolution();
    this._rendering = new EngineRendering(this, {
      resolution: s,
      ...e.rendering
    }), this._rendering.init(), this._map.afterInit(), this._controller = new EngineController(this, e.controller), this._rendering.startRenderLoop(), this._selection = new EngineSelection(this, e.selection), this._widgets = new EngineWidgets(this, e.widgets), this.trackingRequest();
  }
  add(i) {
    return this._rendering.add(i);
  }
  remove(i) {
    this._rendering.remove(i);
  }
  requestRender() {
    this._rendering.requestRender();
  }
  addPrepareRenderListener(i) {
    this._rendering.addPrepareRenderListener(i);
  }
  addBeforeRenderListener(i) {
    this._rendering.addBeforeRenderListener(i);
  }
  removeBeforeRenderListener(i) {
    this._rendering.removeBeforeRenderListener(i);
  }
  removePrepareRenderListener(i) {
    this._rendering.removePrepareRenderListener(i);
  }
  addBeforePrepareRenderObject(i) {
    this._rendering.addBeforePrepareRenderObject(i);
  }
  removeBeforePrepareRenderObject(i) {
    this._rendering.removeBeforePrepareRenderObject(i);
  }
  addBeforeRenderObject(i) {
    this._rendering.addBeforeRenderObject(i);
  }
  removeBeforeRenderObject(i) {
    this._rendering.removeBeforeRenderObject(i);
  }
  lockCamera() {
    this.camera._isLocked = !0;
  }
  unlockCamera() {
    this.camera._isLocked = !1;
  }
  async renderVideo(i) {
    await this._rendering.renderVideo(i);
  }
  get container() {
    return this._container;
  }
  get map() {
    return this._map;
  }
  get rendering() {
    return this._rendering;
  }
  get widgets() {
    return this._widgets;
  }
  get renderer() {
    return this._rendering.renderer;
  }
  get scene() {
    return this._rendering.scene;
  }
  get camera() {
    return this._rendering.camera;
  }
  get event() {
    return this._event;
  }
  get selection() {
    return this._selection;
  }
  get clock() {
    return this._clock;
  }
  get controller() {
    return this._controller;
  }
  get id() {
    return this._id;
  }
  dispose() {
    this._widgets.dispose(), this._event.dispose(), this._selection.dispose(), this._rendering.dispose(), this._map.dispose();
  }
  trackingRequest() {
    var i, e;
    (e = (i = this._map._map) == null ? void 0 : i.map) == null || e._printLog("mapvthree");
  }
}
class SkyAtmosphere extends Mesh {
  constructor() {
    super();
    _(this, "_fsQuad");
    _(this, "_hasPaintedScatterBuffer");
    _(this, "_scatteringMaterial");
    _(this, "_scatteringRenderTarget");
    _(this, "_transmittanceMaterial");
    _(this, "_transmittanceRenderTarget");
    _(this, "_viewMaterial");
    _(this, "_viewRenderTarget");
    this.geometry = new SphereGeometry(1, 32, 32), this.frustumCulled = !1;
    const e = [256, 64], r = [32, 32], s = [400, 400], a = this._transmittanceRenderTarget = new WebGLRenderTarget(e[0], e[1], {
      type: HalfFloatType,
      depthBuffer: !1
    });
    a.texture.name = "SkyAtmosphere.transmittance", this._transmittanceMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(SkyAtmosphereTransmittanceShader.uniforms),
      vertexShader: SkyAtmosphereTransmittanceShader.vertexShader,
      fragmentShader: SkyAtmosphereTransmittanceShader.fragmentShader
    });
    const c = this._scatteringRenderTarget = new WebGLRenderTarget(r[0], r[1], {
      type: HalfFloatType,
      depthBuffer: !1
    });
    c.texture.name = "SkyAtmosphere.scattering", this._scatteringMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(SkyAtmosphereScatteringShader.uniforms),
      vertexShader: SkyAtmosphereScatteringShader.vertexShader,
      fragmentShader: SkyAtmosphereScatteringShader.fragmentShader
    }), this._scatteringMaterial.uniforms.transmittanceTexture.value = a.texture, this._scatteringMaterial.uniforms.transmittanceResolution.value = [e[0], e[1]], this._fsQuad = new FullScreenQuad(null);
    const l = this._viewRenderTarget = new WebGLRenderTarget(s[0], s[1], {
      type: HalfFloatType,
      depthBuffer: !1
    });
    l.texture.name = "SkyAtmosphere.view";
    const h = this._viewMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(SkyAtmosphereViewShader.uniforms),
      vertexShader: SkyAtmosphereViewShader.vertexShader,
      fragmentShader: SkyAtmosphereViewShader.fragmentShader
    });
    h.uniforms.transmittanceTexture.value = a.texture, h.uniforms.transmittanceResolution.value = [e[0], e[1]], h.uniforms.scatteringTexture.value = c.texture, h.uniforms.scatteringResolution.value = [r[0], r[1]];
    const d = this.material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(SkyAtmosphereShader.uniforms),
      vertexShader: SkyAtmosphereShader.vertexShader,
      fragmentShader: SkyAtmosphereShader.fragmentShader,
      side: DoubleSide
    });
    d.uniforms.transmittanceTexture.value = a.texture, d.uniforms.transmittanceResolution.value = [e[0], e[1]], d.uniforms.scatteringTexture.value = c.texture, d.uniforms.scatteringResolution.value = [r[0], r[1]], d.uniforms.viewTexture.value = l.texture, d.uniforms.viewResolution.value = [s[0], s[1]], Object.defineProperties(this.material, {
      isEmissive: {
        get: function() {
          return this.uniforms.isEmissive.value;
        },
        set: function(f) {
          this.uniforms.isEmissive.value = f;
        }
      },
      uTime: {
        get: function() {
          return this.uniforms.uTime.value;
        },
        set: function(f) {
          this.uniforms.uTime.value = f;
        }
      },
      uStarVisible: {
        get: function() {
          return this.uniforms.uStarVisible.value;
        },
        set: function(f) {
          this.uniforms.uStarVisible.value = f;
        }
      },
      uMoonMap: {
        get: function() {
          return this.uniforms.uMoonMap.value;
        },
        set: function(f) {
          this.uniforms.uMoonMap.value = f;
        }
      }
    }), this._fsQuad = new FullScreenQuad(null), this.scale.multiplyScalar(1e4), this.altitude = 0;
  }
  onBeforeRender(e, r, s) {
  }
  updateRenderTargets(e, r) {
    const s = this._fsQuad;
    this._hasPaintedScatterBuffer || (s.material = this._transmittanceMaterial, e.setRenderTarget(this._transmittanceRenderTarget), e.clear(), s.render(e), s.material = this._scatteringMaterial, e.setRenderTarget(this._scatteringRenderTarget), e.clear(), s.render(e), this._hasPaintedScatterBuffer = !0), s.material = this._viewMaterial, e.setRenderTarget(this._viewRenderTarget), e.clear(), s.render(e), e.setRenderTarget(null);
  }
  dispose() {
    this.geometry.dispose(), this._transmittanceRenderTarget.dispose(), this._scatteringRenderTarget.dispose(), this._viewRenderTarget.dispose(), this._transmittanceMaterial.dispose(), this._scatteringMaterial.dispose(), this._viewMaterial.dispose(), this.material.dispose(), this._fsQuad.dispose();
  }
  get altitude() {
    return this.material.uniforms.altitude.value;
  }
  set altitude(e) {
    this._transmittanceMaterial.uniforms.altitude.value = e, this._scatteringMaterial.uniforms.altitude.value = e, this._viewMaterial.uniforms.altitude.value = e, this.material.uniforms.altitude.value = e;
  }
  get viewHeight() {
    return this.material.uniforms.viewHeight.value;
  }
  set viewHeight(e) {
    this._transmittanceMaterial.uniforms.viewHeight.value = e, this._scatteringMaterial.uniforms.viewHeight.value = e, this._viewMaterial.uniforms.viewHeight.value = e, this.material.uniforms.viewHeight.value = e;
  }
  get mixGrayFactor() {
    return this._viewMaterial.uniforms.mixGrayFactor.value;
  }
  set mixGrayFactor(e) {
    this._viewMaterial.uniforms.mixGrayFactor.value = e;
  }
}
const _vector3$3 = new Vector3$1(), _up = new Vector3$1(0, 0, 1);
class SkyAtmospherePass extends Pass {
  constructor() {
    super(), this.uniforms = UniformsUtils.clone(SkyAtmospherePostprocessingShader.uniforms), this.material = new ShaderMaterial({
      defines: {
        MVT_USE_NORMAL_TEXTURE: !1
      },
      uniforms: this.uniforms,
      vertexShader: CopyShader.vertexShader,
      fragmentShader: SkyAtmospherePostprocessingShader.fragmentShader,
      depthTest: !1,
      depthWrite: !1,
      name: "SkyAtmospherePass"
    }), this.needsSwap = !0, this.fsQuad = new FullScreenQuad(null), this.needsDepthTexture = !0, this.needsNormalTextureWhenMRT = !0;
  }
  _consoleIfBigDiff(i, e, r) {
    const s = i.pitch, a = i.roll, c = i.heading;
    this[e] && (Math.abs(s - this[e].pitch), Math.abs(a - this[e].roll), Math.abs(c - this[e].heading)), this[e] = {
      pitch: s,
      roll: a,
      heading: c
    };
  }
  render(i, e, r) {
    const s = this.sky;
    if (!s)
      return;
    const a = this.rendering, c = a.camera, l = s.skyAtmosphere, h = this.uniforms;
    h.altitude.value = l.altitude, h.tDiffuse.value = r.texture, h.tDepth.value = a.main.sceneRendering.depthTexture, h.tAtmosphere.value = l.material.uniforms.viewTexture.value, h.isGlobe.value = l.material.uniforms.isGlobe.value, h.projectionInverseMatrix.value.copy(c.projectionMatrixInverse), h.viewInverseMatrix.value.copy(c.matrixWorld), h.cameraNear.value = c.near, h.cameraFar.value = c.far, h.cameraPosition.value.copy(c.position), h.viewHeight.value = l.material.uniforms.viewHeight.value, h.transmittanceTexture.value = l.material.uniforms.transmittanceTexture.value, h.transmittanceResolution.value = l.material.uniforms.transmittanceResolution.value, h.scatteringTexture.value = l.material.uniforms.scatteringTexture.value, h.scatteringResolution.value = l.material.uniforms.scatteringResolution.value, h.viewTexture.value = l.material.uniforms.viewTexture.value, h.viewResolution.value = l.material.uniforms.viewResolution.value, h.mvt_viewMatrix.value.copy(c.matrixWorldInverse), h.resolution = a.uniforms.resolution, h.sunDirection.value.copy(s.localSunDirection);
    const d = a.main.sceneRendering.normalTexture;
    h.tNormal.value = d;
    const f = !!d;
    f !== this.material.defines.MVT_USE_NORMAL_TEXTURE && (this.material.defines.MVT_USE_NORMAL_TEXTURE = f, this.material.needsUpdate = !0);
    let p = 0, m = 1;
    if (a._engine.map.mapType === "earth") {
      let S = a._engine.map._map._ellipsoidCamera;
      if (S.positionCartographic.z, !this._sphereCamera) {
        const L = new Ellipsoid(6371e3, 6371e3, 6371e3);
        this._sphereCamera = new EllipsoidCamera({
          _ellipsoid: L,
          mapProjection: new GeographicProjection(L),
          camera: c
        });
      }
      const E = this._sphereCamera;
      E.position.copy(S.position), E.direction.copy(S.direction), E.up.copy(S.up), E.right.copy(S.right), l._transformChanged = !0, S = E, h.viewInverseMatrix.value.copy(S.getLocalTransform());
      const b = h.viewInverseMatrix.value.elements;
      _vector3$3.set(b[8], b[9], b[10]);
      const w = MathUtils.clamp(_vector3$3.dot(_up), 0.1, 1), M = h.viewHeight.value * 1e6 / w, P = MathUtils.mapLinear(Math.sqrt(h.viewHeight.value * 10), 0, 1, 20, 2), D = Math.max(M + 100, M * P);
      p = a.renderState.getDepthByDistance(M), m = a.renderState.getDepthByDistance(D);
    }
    h.fogDepthRange.value.set(p, m);
    const y = i.autoClear, x = i.getRenderTarget();
    i.autoClear = !1, this.fsQuad.material = this.material, i.setRenderTarget(this.renderToScreen ? null : e), i.clear(!0, !1, !1), this.fsQuad.render(i), i.autoClear = y, i.setRenderTarget(x);
  }
  getCurrentUsedTextures() {
    const i = [];
    return this.sky && this.sky._precomputedTexturesGenerator && (i.push(this.sky._precomputedTexturesGenerator.textures.transmittanceTexture), i.push(this.sky._precomputedTexturesGenerator.textures.irradianceTexture)), i;
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const commonFragShader = `#define GLSLIFY 1
// Himalayas. Created by Reinder Nijhoff 2018
// @reindernijhoff
//
// https://www.shadertoy.com/view/MdGfzh
//
// This is my first attempt to render volumetric clouds in a fragment shader.
//
// 1 unit correspondents to SCENE_SCALE meter.

#define SCENE_SCALE (1.)
#define INV_SCENE_SCALE (1.)

// #define MOUNTAIN_HEIGHT (5000.)
// #define MOUNTAIN_HW_RATIO (0.00016)

// #define SUN_DIR normalize(vec3(-.1,.4,.15))
// #define SUN_COLOR (vec3(1.,.9,.85)*1.4)

#define FLAG_POSITION (vec3(3900.5,720.,-2516.)*INV_SCENE_SCALE)
#define HUMANOID_SCALE (2.)

// #define CAMERA_RO (vec3(3980.,730.,-2650.)*INV_SCENE_SCALE)
// #define CAMERA_FL 2.

#define HEIGHT_BASED_FOG_B 0.02
#define HEIGHT_BASED_FOG_C 0.05

// mat3 getCamera( in float time, in vec4 mouse, inout vec3 ro, inout vec3 ta ) {
//     ro = CAMERA_RO;
//     vec3 cw;
//     if (mouse.z > 0.) {
//         vec2 m = (mouse.xy - .5) * 2.3;
//         float my = -sin(m.y);
//         cw = normalize(vec3(-sin(-m.x), my+.15, cos(-m.x)));
//     } else {
//     	ro.x += -cos(time*.13)*5.*INV_SCENE_SCALE;
//     	ro.z += (-cos(time*.1)*100.+20.)*INV_SCENE_SCALE;
//     	cw = normalize(vec3(-.1,.18,1.));
//     }   
//     ta = ro + cw*(200.*INV_SCENE_SCALE);
// 	vec3 cp = vec3(0.0,1.0, 0.0);
// 	vec3 cu = normalize( cross(cw,cp) );
// 	vec3 cv = normalize( cross(cu,cw) );
//     return mat3( cu, cv, cw );
// }

// void getRay( in float time, in vec2 fragCoord, in vec2 resolution, in vec4 mouse, inout vec3 ro, inout vec3 rd) {
// 	vec3 ta;
// 	mat3 cam = getCamera( time, mouse, ro, ta );
//     vec2 p = (-resolution.xy + 2.0*(fragCoord))/resolution.y;
//     rd = cam * normalize(vec3(p,CAMERA_FL));     
// }

//
// To reduce noise I use temporal reprojection (both for clouds (Buffer D) and the terrain 
// (Buffer C) seperatly. The temporal repojection code is based on code from the shader
// "Rain Forest" (again by \xCD\xF1igo Qu\xEDlez):
//
// https://www.shadertoy.com/view/4ttSWf
// 
// vec4 saveCamera( in float time, in vec2 fragCoord, in vec4 mouse ) {   
//     vec3 ro, ta;
//     mat3 cam = getCamera( time, mouse, ro, ta );
//     vec4 fragColor;
    
//     if( abs(fragCoord.x-4.5)<0.5 ) fragColor = vec4( cam[2], -dot(cam[2],ro) );
//     if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( cam[1], -dot(cam[1],ro) );
//     if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( cam[0], -dot(cam[0],ro) );
    
//     return fragColor;
// }

// vec2 reprojectPos( in vec3 pos, in vec2 resolution, in sampler2D storage ) {
//     mat4 oldCam = mat4( texelFetch(storage,ivec2(2,0),0),
//                         texelFetch(storage,ivec2(3,0),0),
//                         texelFetch(storage,ivec2(4,0),0),
//                         0.0, 0.0, 0.0, 1.0 );

//     vec4 wpos = vec4(pos,1.0);
//     vec3 cpos = (wpos*oldCam).xyz; 
//     vec2 npos = CAMERA_FL * cpos.xy / cpos.z;
//     return 0.5 + 0.5*npos*vec2(resolution.y/resolution.x,1.0);
// }

//
// Fast skycolor function by \xCD\xF1igo Qu\xEDlez
// https://www.shadertoy.com/view/MdX3Rr
//
// vec3 getSkyColor(vec3 rd) {
//     float sundot = clamp(dot(rd,SUN_DIR),0.0,1.0);
// 	vec3 col = vec3(0.2,0.5,0.85)*1.1 - max(rd.y,0.01)*max(rd.y,0.01)*0.5;
//     col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow(1.0-max(rd.y,0.0), 6.0) );

//     col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );
//     col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );
//     col += 0.20*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );
    
//     col += clamp((0.1-rd.y)*10., 0., 1.) * vec3(.0,.1,.2);
//     col += 0.2*vec3(1.0,0.8,0.6)*pow( sundot, 8.0 );
//     return col;
// }

// bool letterBox(vec2 fragCoord, const vec2 resolution, const float aspect) { 
//     if( fragCoord.x < 0. || fragCoord.x > resolution.x ||
//         abs(2.*fragCoord.y-resolution.y) > resolution.x * (1./aspect) ) {
//         return true;
//     } else {
//         return false;
//     }
// }

//
// Noise functions
//
// Hash without Sine by DaveHoskins 
//
// https://www.shadertoy.com/view/4djSRW
//
float hash12( vec2 p ) {
    p  = 50.0*fract( p*0.3183099 );
    return fract( p.x*p.y*(p.x+p.y) );
}

float hash13(vec3 p3) {
    p3  = fract(p3 * 1031.1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

vec3 hash33(vec3 p3) {
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+19.19);
    return fract((p3.xxy + p3.yxx)*p3.zyx);
}

float valueHash(vec3 p3) {
    p3  = fract(p3 * 0.1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

//
// Noise functions used for cloud shapes
//
float valueNoise( in vec3 x, float tile ) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
	
    return mix(mix(mix( valueHash(mod(p+vec3(0,0,0),tile)), 
                        valueHash(mod(p+vec3(1,0,0),tile)),f.x),
                   mix( valueHash(mod(p+vec3(0,1,0),tile)), 
                        valueHash(mod(p+vec3(1,1,0),tile)),f.x),f.y),
               mix(mix( valueHash(mod(p+vec3(0,0,1),tile)), 
                        valueHash(mod(p+vec3(1,0,1),tile)),f.x),
                   mix( valueHash(mod(p+vec3(0,1,1),tile)), 
                        valueHash(mod(p+vec3(1,1,1),tile)),f.x),f.y),f.z);
}

float voronoi( vec3 x, float tile ) {
    vec3 p = floor(x);
    vec3 f = fract(x);

    float res = 100.;
    for(int k=-1; k<=1; k++){
        for(int j=-1; j<=1; j++) {
            for(int i=-1; i<=1; i++) {
                vec3 b = vec3(i, j, k);
                vec3 c = p + b;

                if( tile > 0. ) {
                    c = mod( c, vec3(tile) );
                }

                vec3 r = vec3(b) - f + hash13( c );
                float d = dot(r, r);

                if(d < res) {
                    res = d;
                }
            }
        }
    }

    return 1.-res;
}

float tilableVoronoi( vec3 p, const int octaves, float tile ) {
    float f = 1.;
    float a = 1.;
    float c = 0.;
    float w = 0.;

    if( tile > 0. ) f = tile;

    for (int i = 0; i < 100; i++) {
        if (i >= octaves) break;
        c += a*voronoi( p * f, f );
        f *= 2.0;
        w += a;
        a *= 0.5;
    }

    return c / w;
}

float tilableFbm( vec3 p, const int octaves, float tile ) {
    float f = 1.;
    float a = 1.;
    float c = 0.;
    float w = 0.;

    if( tile > 0. ) f = tile;

    for (int i = 0; i < 100; i++) {
        if (i >= octaves) break;
        c += a*valueNoise( p * f, f );
        f *= 2.0;
        w += a;
        a *= 0.5;
    }

    return c / w;
}

`, mainVertShader = `#define GLSLIFY 1
varying vec3 vWorldPosition;
varying vec2 vUv;
void main() {
    vUv = uv;
    vWorldPosition = normalize(vec3(position.x, position.y, position.z));
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    // gl_Position.z = gl_Position.w;
}
`, mainFragShader = `#define GLSLIFY 1
// Himalayas. Created by Reinder Nijhoff 2018
// @reindernijhoff
//
// https://www.shadertoy.com/view/MdGfzh
//
// This is my first attempt to render volumetric clouds in a fragment shader.
//
// I started this shader by trying to implement the clouds of Horizon Zero Dawn, as
// described in "The real-time volumetric cloudscapes of Horizon Zero Dawn" by 
// Andrew Schneider and Nathan Vos.[1] To model the shape of the clouds, two look-up
// textures are created with different frequencies of (Perlin -) Worley noise:
//
// Buffer A: The main look-up texture for the cloud shapes. 
// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details 
//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.
//           
// Because it is not possible (yet) to create buffers with fixed size, or 3D buffers, the
// look-up texture in Buffer A is 2D, and a slice of the volume that is described in the 
// article. Therefore, and because I didn't have any slots left (in Buffer C) to use a 
// cloud type/cloud coverage texture, the modelling of the cloud shapes in this shader is 
// in the end mostly based on trial and error, and is probably far from the code used in 
// Horizon Zero Dawn.
//
// Buffer D: Rendering of the clouds.
//
// I render the clouds using the improved integration method of volumetric media, as described 
// in "Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite" by 
// S\xE9bastien Hillaire.[2]
//
// You can find the (excellent) example shaders of S\xE9bastien Hillaire (SebH) here:
//
// https://www.shadertoy.com/view/XlBSRz
// https://www.shadertoy.com/view/MdlyDs
//
// #define MVT_CLOUD_MARCH_STEPS 8
// #define MVT_CLOUD_SELF_SHADOW_STEPS 3

#define EARTH_RADIUS    (637100.) // (6371000.)
#define CLOUDS_BOTTOM   (1350.)
#define CLOUDS_TOP      (2350.)

#define CLOUDS_LAYER_BOTTOM   (-150.)
#define CLOUDS_LAYER_TOP      (-70.)

#define CLOUDS_LAYER_COVERAGE (.41)

#define CLOUDS_DETAIL_STRENGTH (.225)
#define CLOUDS_BASE_EDGE_SOFTNESS (.1)
#define CLOUDS_BOTTOM_SOFTNESS (.25)
#define CLOUDS_SHADOW_MARGE_STEP_SIZE (10.)
#define CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE (4.)
#define CLOUDS_SHADOW_MARGE_STEP_MULTIPLY (1.3)
#define CLOUDS_FORWARD_SCATTERING_G (.8)
#define CLOUDS_BACKWARD_SCATTERING_G (-.2)
#define CLOUDS_SCATTERING_LERP (.5)

#define CLOUDS_AMBIENT_COLOR_TOP (vec3(149., 167., 200.)*(1.5/255.))
// #define ambientColorBottom (vec3(39., 67., 87.)*(1.5/255.))
// #define ambientColorBottom (vec3(20., 20., 20.)*(1.5/255.))
#define CLOUDS_MIN_TRANSMITTANCE .1

// #define shapeScale 5.51
#define CLOUDS_DETAIL_SCALE 50.

#ifdef MVT_USE_VOULEMTRIC
uniform sampler2D tShape; // cloud shape
uniform sampler2D tPrevious; // previous frame
uniform sampler2D tDetail; // cloud detail
#else
uniform sampler2D tWeather; // cloud shape
uniform sampler2D tNoise; // cloud detail
#endif
uniform sampler2D tDepth; // depth buffer
uniform sampler2D tDiffuse;
uniform sampler2D tBlueNoise;
uniform vec2 resolution;
uniform float iTime;
uniform vec3 cameraDirection;
uniform mat4 mvt_viewMatrixInverse;
uniform mat4 mvt_projectionMatrixInverse;
uniform vec3 mvt_cameraPosition;
uniform mat4 uCameraMatrix;
uniform mat4 uLastCameraMatrix;
uniform vec3 sunColor;
uniform vec3 sunDirection;
uniform float coverage;
uniform float density;
uniform float speed;
uniform bool cameraChanged;
uniform vec3 ambientColorBottom;
uniform float previousRatio;
// .x baseScale .y detailScale
uniform vec4 shapeScale;
//
// Cloud shape modelling and rendering 
//

float HenyeyGreenstein( float sundotrd, float g) {
	float gg = g * g;
	return (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);
}

// float interectCloudSphere( vec3 rd, float r ) {
//     float b = EARTH_RADIUS * rd.y;
//     float d = b * b + r * r + 2. * EARTH_RADIUS * r;
//     return -b + sqrt( d );
// }

float interectCloudSphere(vec3 ro, vec3 rd, float rad) {
    rad += EARTH_RADIUS;
    float b = dot(ro, rd);
    float c = dot(ro, ro) - rad*rad;
    if (c > 0.0 && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    // Special case: inside sphere, use far discriminant
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}

float linearstep( const float s, const float e, float v ) {
    return clamp( (v-s)*(1./(e-s)), 0., 1. );
}

float linearstep0( const float e, float v ) {
    return min( v*(1./e), 1. );
}

float remap(float v, float s, float e) {
	return (v - s) / (e - s);
}

float remap2(float v, float l0, float h0, float ln, float hn) {
    return ln + (v - l0) * (hn - ln) / (h0 - l0);
}
#ifdef MVT_USE_VOULEMTRIC
float cloudMapBase(vec3 p, float norY) {
	vec3 uv = p * (0.00005 * shapeScale.x);
    vec3 cloud = texture2D(tShape, uv.xz * 2.5 + iTime * 0.002 * speed).rgb;
   
    float n = norY*norY;
    n *= cloud.b ;
        n+= pow(1.-norY, 16.); 
	return remap( cloud.r - n, cloud.g, 1.);
}

float cloudMapDetail(vec3 p) { 
    // 3d lookup in 2d texture :(
    p = abs(p) * (0.0016 * shapeScale.x * shapeScale.y);
    p += iTime * 0.02 * speed;
    float yi = mod(p.y,32.);
    ivec2 offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;
    float a = texture2D(tDetail, (mod(p.xz,32.)+vec2(offset.xy)+1.)/resolution.xy).r;
    
    yi = mod(p.y+1.,32.);
    offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;
    float b = texture2D(tDetail, (mod(p.xz,32.)+vec2(offset.xy)+1.)/resolution.xy).r;
    
    return mix(a,b,fract(p.y));
}

float cloudGradient( float norY ) {
    return linearstep( 0., .05, norY ) - linearstep( .8, 1.2, norY);
}

float cloudMap(vec3 pos, vec3 rd, float norY) {
    vec3 ps = pos;
    
    float m = cloudMapBase(ps, norY);
	m *= cloudGradient( norY );

	float dstrength = smoothstep(1., 0.5, m);
    
    // erode with detail
    if(dstrength > 0.) {
		m -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;
    }

	m = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(coverage-1.) );
    m *= linearstep0(CLOUDS_BOTTOM_SOFTNESS, norY);

    return clamp(m * density * (1.+max((ps.x-100000.)*0.005,0.)), 0., 1.);
}

float volumetricShadow(in vec3 from, in float sundotrd ) {
    float dd = CLOUDS_SHADOW_MARGE_STEP_SIZE;
    vec3 rd = sunDirection;
    float d = dd * .5;
    float shadow = 1.0;

    for(int s=0; s<MVT_CLOUD_SELF_SHADOW_STEPS; s++) {
        vec3 pos = from + rd * d;
        float norY = (length(pos) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM));

        if(norY > 1.) return shadow;

        float muE = cloudMap( pos, rd, norY );
        shadow *= exp(-muE * dd);

        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;
        d += dd;
    }
    return shadow;
}

vec4 renderClouds( vec3 ro, vec3 rd, inout float dist ) {
    if( rd.y < 0. ) {
        return vec4(0,0,0,1);
    }

    // ro.x += -cos(iTime * 0.13) * 0.5;
    // ro.z += (-cos(iTime * 0.1) * 100. + 20.) * 0.1;
    // ro += rand();
    // ro.xz *= SCENE_SCALE;
    // \u4F4D\u7F6E
    // ro.x += iTime * 0.;
    ro.y += EARTH_RADIUS;
    // ro.y = sqrt(EARTH_RADIUS*EARTH_RADIUS-dot(ro.xz,ro.xz));

    float start = interectCloudSphere(ro, rd, CLOUDS_BOTTOM );
    float end  = interectCloudSphere(ro,  rd, CLOUDS_TOP );
    
    if (start > dist) {
        return vec4(0,0,0,1);
    }
    
    end = min(end, dist);
    
    float sundotrd = dot( rd, -sunDirection);

    // raymarch
    float d = start;
    float dD = (end-start) / float(MVT_CLOUD_MARCH_STEPS);

    float h = hash13(rd + fract(iTime) );
    d -= dD * h;

    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),
        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );

    float transmittance = 1.0;
    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);

    dist = EARTH_RADIUS;

    for(int s=0; s<MVT_CLOUD_MARCH_STEPS; s++) {
        vec3 p = ro + d * rd;

        float norY = clamp( (length(p) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM)), 0., 1.);

        float alpha = cloudMap( p, rd, norY );

        if( alpha > 0. ) {
            dist = min( dist, d);
            vec3 ambientLight = mix( ambientColorBottom, CLOUDS_AMBIENT_COLOR_TOP, norY );

            vec3 S = (ambientLight + sunColor * (scattering * volumetricShadow(p, sundotrd))) * alpha;
            float dTrans = exp(-alpha * dD);
            vec3 Sint = (S - S * dTrans) * (1. / alpha);
            scatteredLight += transmittance * Sint; 
            transmittance *= dTrans;
        }

        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;

        d += dD;
    }

    return vec4(scatteredLight, transmittance);
}
//
//
// !Because I wanted a second cloud layer (below the horizon), I copy-pasted 
// almost all of the code above:
//

float cloudMapLayer(vec3 pos, vec3 rd, float norY) {
    vec3 ps = pos;

    float m = cloudMapBase(ps, norY);
	// m *= cloudGradient( norY );
	float dstrength = smoothstep(1., 0.5, m);
    
    // erode with detail
    if (dstrength > 0.) {
		m -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;
    }

	m = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(CLOUDS_LAYER_COVERAGE-1.) );

    return clamp(m * density, 0., 1.);
}

float volumetricShadowLayer(in vec3 from, in float sundotrd ) {
    float dd = CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE;
    vec3 rd = sunDirection;
    float d = dd * .5;
    float shadow = 1.0;

    for(int s=0; s<MVT_CLOUD_SELF_SHADOW_STEPS; s++) {
        vec3 pos = from + rd * d;
        float norY = clamp( (pos.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);

        if(norY > 1.) return shadow;

        float muE = cloudMapLayer( pos, rd, norY );
        shadow *= exp(-muE * dd);

        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;
        d += dd;
    }
    return shadow;
}

vec4 renderCloudLayer( vec3 ro, vec3 rd, inout float dist ) {
    if( rd.y > 0. ) {
        return vec4(0,0,0,10);
    }

    ro.xz *= SCENE_SCALE;
    ro.y += EARTH_RADIUS;
    // ro.y = 0.;

    float start = CLOUDS_LAYER_TOP/rd.y;
    float end  = CLOUDS_LAYER_BOTTOM/rd.y;
    
    if (start > dist) {
        return vec4(0,0,0,10);
    }
    
    end = min(end, dist);
    
    float sundotrd = dot( rd, -sunDirection);

    // raymarch
    float d = start;
    float dD = (end-start) / float(MVT_CLOUD_MARCH_STEPS);

    float h = hash13(rd + fract(iTime) );
    d -= dD * h;

    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),
        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );

    float transmittance = 1.0;
    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);

    dist = EARTH_RADIUS;

    for(int s=0; s<MVT_CLOUD_MARCH_STEPS; s++) {
        vec3 p = ro + d * rd;

        float norY = clamp( (p.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);

        float alpha = cloudMapLayer( p, rd, norY );

        if( alpha > 0. ) {
            dist = min( dist, d);
            vec3 ambientLight = mix( ambientColorBottom, CLOUDS_AMBIENT_COLOR_TOP, norY );

            vec3 S = .7 * (ambientLight +  sunColor * (scattering * volumetricShadowLayer(p, sundotrd))) * alpha;
            float dTrans = exp(-alpha * dD);
            vec3 Sint = (S - S * dTrans) * (1. / alpha);
            scatteredLight += transmittance * Sint; 
            transmittance *= dTrans;
        }

        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;

        d += dD;
    }

    return vec4(scatteredLight, transmittance);
}

vec2 reprojectPos( in vec3 pos, in vec2 resolution, in sampler2D storage ) {
    vec4 wpos = vec4(pos.xyz,1.0);
    vec3 cpos = (wpos*uLastCameraMatrix).xzy; 
    vec2 npos = 2. * cpos.xy / cpos.z;
    return 0.5 + 0.5*npos*vec2(resolution.y/resolution.x,1.0);
}
#else
/**
* simple cloud
*/
vec4 renderClouds( vec3 ro, vec3 rd, inout float dist ) {
    if( rd.y < 0. ) {
        return vec4(0,0,0,1);
    }
    ro.y += EARTH_RADIUS;

    vec3 p = ro + rd * 60000.;
    vec4 col = vec4(1.0);

    // vec2 cloudUV = p.xz * 0.1;
    float r = sqrt(2.0 * (1.0 - rd.y));
    float theta = atan(rd.x, rd.z);

    vec2 cloudUV = vec2(r * cos(theta) * 0.5 + 0.5, r * sin(theta) * 0.5 + 0.5) * 10000.0;
    float uvOffset = iTime / 1000.0 * speed;
    vec4 weatherColor = texture2D(tWeather, cloudUV * 0.00003 + uvOffset);
    float wmc = max(weatherColor.x, clamp(coverage * 1.0 - 0.5, 0.0, 1.0) * weatherColor.y * 2.0);
    // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);
    // SNsample = R(snr, (sng \xD70.625+snb \xD70.25+sna \xD70.125)\u22121, 1, 0, 1)
    vec4 noiseColor = texture2D(tNoise, (cloudUV + uvOffset) * 1.0);
    float sn_sample = remap2(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);
    float sn = clamp(remap2(sn_sample, 1.0 - coverage * 1.0 * wmc, 1.0, 0.0, 1.0), 0.0, 1.0);
 
    float thickness = clamp(sn * 1.0 + 0.1, 0.0, 1.0);
    float cloudAlpha = clamp(thickness, 0.0, 1.0); // remap2(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);
    // vec3 cloudColor = vec3(remap2(clamp(cloudAlpha, 0.0, 1.0), 0.0, 1.0, 1.0, 0.6));
    vec3 cloudColor = vec3(cloudAlpha);
    // \u592A\u9633\u6563\u5C04\uFF0C\u6839\u636E\u539A\u5EA6\u53D1\u751F\u53D8\u5316
    // vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;
    // if (mixGrayFactor > 0.0) {
    //     vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);
    //     sunLightColor = mix(sunLightColor, gray, mixGrayFactor);
    // }
    // cloudColor = sunLightColor;
    // cloudColor = sunLightColor * (remap(thickness, 0.0, 1.0, 1.5, 0.5));
    
    // // \u5929\u7A7A\u5927\u6C14\u989C\u8272
    // vec3 sunDir = getSunDir();
    // vec3 rayDir = normalize(vWorldPosition.xzy);

    // cloudColor *= clamp(remap(dot(rayDir, sunDir), -1.0, 1.0, 0.75, 2.0), 0.75, 2.0);

    // vec3 atmosphereColor = getValFromSkyLUT(rayDir, sunDir);
    // atmosphereColor *= 100.0;
    // atmosphereColor = jodieReinhardTonemap(atmosphereColor);
    // atmosphereColor = pow(atmosphereColor, vec3(1.0/2.2));
    // atmosphereColor = toLinear(vec4(atmosphereColor, 1.0)).xyz;

    // float atmosphereColorFactor = remap(clamp(thickness, 0.5, 1.0), 0.5, 1.0, 0.0, 1.0);
    // atmosphereColorFactor = 0.5 - abs(0.5 - atmosphereColorFactor);
    // cloudColor = mix(cloudColor, atmosphereColor, atmosphereColorFactor);

    // // \u548C\u5929\u7A7A\u5927\u6C14\u6DF7\u5408
    // cloudColor = mix(cloudColor, atmosphereColor, 1.0 - clamp((vWorldPosition.z + 0.02) * 10.0, 0.0, 1.0));

    // cloudColor = atmosphereColor; // lum;
    // vec3 cloudColor = texture2D(skyMap, cloudUV * 2.0).xyz * 10.0;
    return vec4(cloudColor, 1.0 - cloudAlpha);
    // return vec4(cloudUV, 0.0, 1.0);
    // return col;
}
#endif
float getDepthValue(sampler2D depthTexture, vec2 uv) {
    return texture2D(depthTexture, uv).r;
}

vec3 ReinhardToneMapping( vec3 color ) {
	return clamp( color / ( vec3( 1.0 ) + color ), 0.0, 1.0 );

}

void main() {
    // if (gl_FragCoord.y < 1.5) {
    //     gl_FragColor = saveCamera(iTime, gl_FragCoord, iMouse/resolution.xyxy);
    //     if( abs(gl_FragCoord.x-1.5)<0.5 ) gl_FragColor = vec4(iMouse);
    //     if( abs(gl_FragCoord.x-0.5)<0.5 ) gl_FragColor = mouseChanged() ? vec4(0) : vec4(resolution.xy,0,0);
    // } else {
    //     if( letterBox(gl_FragCoord, resolution.xy, 2.25) ) {
    //     	gl_FragColor = vec4( 0., 0., 0., 1. );
    //    		return;
    //     } else {
    float depthValue = texelFetch(tDepth, ivec2(gl_FragCoord), 0).r;
    // vec2 depthValueUV = gl_FragCoord.xy / resolution;
    // float depthValue = getDepthValue(tDepth, depthValueUV);
    if (depthValue < 0.99) {
        gl_FragColor = vec4(0,0,0,1);
        return;
    }
    float dist = 60000.0; // texelFetch(tDepth, ivec2(gl_FragCoord),0).w * SCENE_SCALE;
    // dist = 30000.0 * SCENE_SCALE;
    vec4 col = vec4(0,0,0,1);
    vec3 camRight   = vec3( uCameraMatrix[0][0],  uCameraMatrix[0][1],  uCameraMatrix[0][2]);
    vec3 camUp      = vec3( uCameraMatrix[1][0],  uCameraMatrix[1][1],  uCameraMatrix[1][2]);
	vec3 camForward = vec3(-uCameraMatrix[2][0], -uCameraMatrix[2][1], -uCameraMatrix[2][2]);

	// calculate unique seed for rng() function
	// seed = uvec2(uFrameCounter, uFrameCounter + 1.0) * uvec2(gl_FragCoord);
	// initialize rand() variables
	// randNumber = 0.0; // the final randomly-generated number (range: 0.0 to 1.0)
	float blueNoise = texelFetch(tBlueNoise, ivec2(mod(floor(gl_FragCoord.xy), 128.0)), 0).r * 0.5;
    // vec2 blueNoiseUV = mod(gl_FragCoord.xy, vec2(128.0)) / 128.0;
    // float blueNoise = getDepthValue(tBlueNoise, blueNoiseUV) * 0.5;

	// vec2 pixelOffset = vec2( tentFilter(rand()), tentFilter(rand()) ) * 0.5;
	// // we must map pixelPos into the range -1.0 to +1.0

    float camFOVWidth = 35.0 / 180.0 * 3.1415926;
    float camHeightScale = tan(camFOVWidth / 2.0);
    float camWidthScale = camHeightScale * resolution.x / resolution.y;
    vec2 uv = (gl_FragCoord.xy + vec2(0.5) + blueNoise) / resolution;
	vec2 pixelPos = uv * 2.0 - 1.0;

	vec3 rayDir = normalize( pixelPos.x * camRight * camWidthScale + pixelPos.y * camUp * camHeightScale + camForward );

	// depth of field
	// vec3 focalPoint = uFocusDistance * rayDir;
	// float randomAngle = rng() * TWO_PI; // pick random point on aperture
	// float randomRadius = rng() * uApertureSize;
	// vec3  randomAperturePos = ( cos(randomAngle) * camRight + sin(randomAngle) * camUp ) * sqrt(randomRadius);
	// // point on aperture to focal point
	// vec3 finalRayDir = normalize(focalPoint - randomAperturePos);

	// vec3 ro = vec3(0., 0., 0.); // cameraPosition.xzy; // CAMERA_RO; // cameraPosition.xzy / 10.;
    vec3 ro = mvt_cameraPosition.xzy;
    // ro += blueNoise;
	vec3 rd = rayDir.xzy;
    if( rd.y > 0. ) {
        // clouds
        col = renderClouds(ro, rd, dist);
        // TODO: \u8C03\u6574\u4E91\u7684\u9AD8\u5149\u533A\u57DF\uFF0C\u9632\u6B62\u8FC7\u66DD
       //  col.rgb = ReinhardToneMapping(col.rgb);
        // float fogAmount = 1.-(.1 + exp(-dist*0.000001));
        float fogAmount = 1.0 - clamp(rd.y * 20.0, 0.0, 1.0);
        // vec3 skyColor = getSkyColor(rd);
        vec3 skyColor = clamp(texture2D(tDiffuse, uv).rgb, 0.0, 1.0);
        col.rgb = mix(col.rgb, skyColor*(1.-col.a), fogAmount);
    } else {
        // cloud layer below horizon
        // col = renderCloudLayer(ro, rd, dist);
        // // height based fog, see https://iquilezles.org/articles/fog
        // float fogAmount = HEIGHT_BASED_FOG_C * 
        //     (1.-exp( -dist*rd.y*(INV_SCENE_SCALE*HEIGHT_BASED_FOG_B)))/rd.y;
        // vec3 skyColor = texture(tDiffuse, uv).rgb;
        // col.rgb = mix(col.rgb, skyColor*(1.-col.a), clamp(fogAmount,0.,1.));
    }
    // vec4 previousColor = texelFetch(tPrevious, ivec2(gl_FragCoord.xy), 0);
    // gl_FragColor = col * 0.1 + previousColor * 0.9;	
    #ifdef MVT_USE_VOULEMTRIC
    if( col.w > 1. ) {
         gl_FragColor = vec4(0,0,0,1);
    } else {
        // float ratio = 0.3;
        // if (!cameraChanged) {
        //     // vec2 spos = reprojectPos(ro+rd*dist, resolution.xy, tPrevious);
        //     // \u7B80\u5316\u53E0\u52A0
        //     // col.r = ocol.a;
        //     // col.x += 0.5;
        //     ratio = 0.2;
        // }
        // else {

        // }
        vec2 spos = uv;
        vec4 ocol = texture2D( tPrevious, spos, 0.0 ).xyzw;
        col = mix(ocol, col, previousRatio);
    }
    #endif
    gl_FragColor = col;
}`, shapeFragShader = `#define GLSLIFY 1
// Himalayas. Created by Reinder Nijhoff 2018
// @reindernijhoff
//
// https://www.shadertoy.com/view/MdGfzh
//
// This is my first attempt to render volumetric clouds in a fragment shader.
//
// Buffer A: The main look-up texture for the cloud shapes. 
// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details 
//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.
// 
varying vec2 vUv;
void main() { 

    vec3 coord = fract(vec3(vUv + vec2(.2,0.62), .5));
    
    vec4 col = vec4(1);
    
    float mfbm = 0.9;
    float mvor = 0.7;
    
    col.r = mix(1., tilableFbm( coord, 7, 4. ), mfbm) * 
            mix(1., tilableVoronoi( coord, 8, 9. ), mvor);
    col.g = 0.625 * tilableVoronoi( coord + 0., 3, 15. ) +
            0.250 * tilableVoronoi(  coord + 0., 3, 19. ) +
            0.125 * tilableVoronoi( coord + 0., 3, 23. ) 
            -1.;
    col.b = 1. - tilableVoronoi( coord + 0.5, 6, 9. );
    
    gl_FragColor = col;
}`, detailFragShader = `#define GLSLIFY 1
// Himalayas. Created by Reinder Nijhoff 2018
// @reindernijhoff
//
// https://www.shadertoy.com/view/MdGfzh
//
// This is my first attempt to render volumetric clouds in a fragment shader.
//
// Buffer A: The main look-up texture for the cloud shapes. 
// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details 
//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.
// 

void main() { 
    
        // pack 32x32x32 3d texture in 2d texture (with padding)
    float z = floor(gl_FragCoord.x/34.) + 8.*floor(gl_FragCoord.y/34.);
    vec2 uv = mod(gl_FragCoord.xy, 34.) - 1.;
    vec3 coord = vec3(uv, z) / 32.;

    float r = tilableVoronoi( coord, 16,  3. );
    float g = tilableVoronoi( coord,  4,  8. );
    float b = tilableVoronoi( coord,  4, 16. );

    float c = max(0., 1.-(r + g * .5 + b * .25) / 1.75);

    gl_FragColor = vec4(c,c,c,c);

}`, VolumetricCloudsShapeShader = {
  uniforms: {},
  vertexShader: mainVertShader,
  fragmentShader: commonFragShader + `
` + shapeFragShader
}, VolumetricCloudsDetailShader = {
  uniforms: {},
  vertexShader: mainVertShader,
  fragmentShader: commonFragShader + `
` + detailFragShader
}, VolumetricCloudsShader = {
  uniforms: {
    tShape: {
      value: null
    },
    tPrevious: {
      value: null
    },
    tDepth: {
      value: null
    },
    tDetail: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    tBlueNoise: {
      value: null
    },
    tWeather: {
      value: null
    },
    tNoise: {
      value: null
    },
    resolution: {
      value: new Vector2$1(1, 1)
    },
    iTime: {
      value: 0
    },
    mvt_projectionMatrixInverse: {
      value: new Matrix4()
    },
    mvt_viewMatrixInverse: {
      value: new Matrix4()
    },
    uCameraMatrix: {
      value: new Matrix4()
    },
    uLastCameraMatrix: {
      value: new Matrix4()
    },
    mvt_cameraPosition: {
      value: new Vector3$1()
    },
    sunColor: {
      value: new Vector3$1(1, 1, 1)
    },
    sunDirection: {
      value: new Vector3$1(0, 1, 0)
    },
    coverage: {
      value: 0.52
    },
    density: {
      value: 0.03
    },
    speed: {
      value: 1
    },
    cameraChanged: {
      value: !1
    },
    ambientColorBottom: {
      value: new Vector3$1(0.2, 0.35, 0.5)
    },
    shapeScale: {
      value: new Vector4(5.51, 50, 1, 1)
    },
    previousRatio: {
      value: 0.5
    }
  },
  vertexShader: mainVertShader,
  fragmentShader: commonFragShader + `
` + mainFragShader
}, compostionFragShader = `
    uniform sampler2D tDiffuse;
    uniform sampler2D tClold;
    varying vec2 vUv;
    void main() {
        vec4 color = texture2D(tDiffuse, vUv);
        vec4 cloud = texture2D(tClold, vUv);
        // gl_FragColor.rgb = mix(color.rgb, cloud.rgb, 1.0 - clamp(cloud.a, 0.0, 1.0));
        gl_FragColor.rgb = cloud.rgb + color.rgb * cloud.a;
        gl_FragColor.a = 1.0;
        // gl_FragColor.rgb += cloud.rgb;
        // gl_FragColor = cloud;
        // gl_FragColor = vec4(cloud.a, 0.0, 0.0, 1.0);
        // gl_FragColor = vec4(cloud.rgb, 1.0);
    }
`;
class VolumetricCloudsPass extends Pass {
  constructor(e = {}) {
    super();
    _(this, "_coverage", 0.56);
    _(this, "_density", 0.015);
    _(this, "_speed", 1);
    _(this, "_shapeBaseScale", 0.55);
    _(this, "_shapeDetailScale", 20);
    _(this, "_sunColor", new Vector3$1(1, 1, 1));
    _(this, "_sunDirection", new Vector3$1(0, 1, 0));
    _(this, "_ambientColorBottom", new Vector3$1(0.2, 0.35, 0.5));
    _(this, "_useVolumetric", !0);
    this._fsQuad = new FullScreenQuad(null), this._shapeRenderTarget = new WebGLRenderTarget(1280, 720, {
      format: "RGBA",
      depthBuffer: !1,
      stencilBuffer: !1
    }), this._shapeRenderTarget.texture.generateMipmaps = !1, this._shapeRenderTarget.texture.minFilter = LinearFilter, this._shapeRenderTarget.texture.magFilter = LinearFilter, this._shapeRenderTarget.texture.wrapS = RepeatWrapping, this._shapeRenderTarget.texture.wrapT = RepeatWrapping, this._shapeMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(VolumetricCloudsShapeShader.uniforms),
      vertexShader: VolumetricCloudsShapeShader.vertexShader,
      fragmentShader: VolumetricCloudsShapeShader.fragmentShader,
      depthTest: !1,
      depthWrite: !1
    }), this._detailRenderTarget = new WebGLRenderTarget(1024, 512, {
      format: "RGBA",
      depthBuffer: !1,
      stencilBuffer: !1
    }), this._detailRenderTarget.texture.generateMipmaps = !1, this._detailRenderTarget.texture.wrapS = RepeatWrapping, this._detailRenderTarget.texture.wrapT = RepeatWrapping, this._detailRenderTarget.texture.minFilter = LinearFilter, this._detailRenderTarget.texture.magFilter = LinearFilter, this._detailMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(VolumetricCloudsDetailShader.uniforms),
      vertexShader: VolumetricCloudsDetailShader.vertexShader,
      fragmentShader: VolumetricCloudsDetailShader.fragmentShader,
      depthTest: !1,
      depthWrite: !1
    });
    const r = {
      MVT_CLOUD_MARCH_STEPS: 8,
      MVT_CLOUD_SELF_SHADOW_STEPS: 3
    };
    this._useVolumetric && (r.MVT_USE_VOULEMTRIC = !0);
    const s = this._mainMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(VolumetricCloudsShader.uniforms),
      vertexShader: VolumetricCloudsShader.vertexShader,
      fragmentShader: VolumetricCloudsShader.fragmentShader,
      defines: r,
      depthTest: !1,
      depthWrite: !1,
      name: "VolumetricCloudsShader"
    });
    s.uniforms.tShape.value = this._shapeRenderTarget.texture, s.uniforms.tDetail.value = this._detailRenderTarget.texture, s.uniforms.tBlueNoise.value = e.tBlueNoise, s.uniforms.tWeather.value = e.tWeather, s.uniforms.tNoise.value = e.tNoise, this._previousRenderTarget = new WebGLRenderTarget(1, 1, {
      format: "RGBA",
      depthBuffer: !1,
      stencilBuffer: !1
    }), this._copyMaterial = new ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1 }
      },
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      name: "VolumetricCloudsCopyShader",
      depthTest: !1,
      depthWrite: !1
    }), s.uniforms.tPrevious.value = this._previousRenderTarget.texture, this._compostionMaterial = new ShaderMaterial({
      uniforms: {
        tDiffuse: { value: null },
        tClold: { value: null }
      },
      vertexShader: CopyShader.vertexShader,
      fragmentShader: compostionFragShader,
      name: "VolumetricCloudsCompostionShader",
      depthTest: !1,
      depthWrite: !1
    }), this.needsDepthTexture = !0;
  }
  render(e, r, s, a, c) {
    if (!this.sky)
      return;
    const h = this.rendering, d = h.camera, f = h.resolution, p = h.pixelRatio, m = e.autoClear, y = this._mainMaterial, x = this._copyMaterial, v = this._fsQuad;
    if (e.autoClear = !1, !this._hasRenderShapeTexture || h.renderState.isRendererRecreated) {
      v.material = this._shapeMaterial, e.setRenderTarget(this._shapeRenderTarget), e.clear(!0, !1, !1), v.render(e);
      const M = this._detailMaterial;
      v.material = M, e.setRenderTarget(this._detailRenderTarget), e.clear(!0, !1, !1), v.render(e), this._hasRenderShapeTexture = !0;
    }
    if (y.uniforms.tDiffuse.value = s.texture, y.uniforms.tDepth.value = this.rendering.main.sceneRendering.depthTexture, y.uniforms.mvt_projectionMatrixInverse.value.copy(d.projectionMatrixInverse), y.uniforms.mvt_viewMatrixInverse.value.copy(d.matrixWorld), y.uniforms.cameraChanged.value = h.renderState.viewChanged, y.uniforms.speed.value = this._speed, y.uniforms.ambientColorBottom.value.copy(this._ambientColorBottom), y.uniforms.sunColor.value.copy(this._sunColor), y.uniforms.sunDirection.value.copy(this._sunDirection), y.uniforms.coverage.value = this._coverage, y.uniforms.density.value = this._density, y.uniforms.shapeScale.value.set(this._shapeBaseScale, this._shapeDetailScale, 1, 1), h._engine.map.isGlobe) {
      let P = h._engine.map._map._ellipsoidCamera;
      y.uniforms.uCameraMatrix.value.copy(P.getLocalTransform());
      const D = P.positionCartographic.z;
      y.uniforms.mvt_cameraPosition.value.set(0, 0, D);
    } else
      y.uniforms.uCameraMatrix.value.copy(d.matrixWorld), y.uniforms.mvt_cameraPosition.value.set(0, 0, 0);
    y.uniforms.coverage.value = this._coverage, y.uniforms.density.value = this._density, y.uniforms.iTime.value += a;
    let S = !1;
    (this._previousRenderTarget.width !== f.x * p || this._previousRenderTarget.height !== f.y * p) && (this._previousRenderTarget.setSize(f.x * p, f.y * p), y.uniforms.resolution.value.set(f.x * p, f.y * p), S = !0);
    const E = h.renderState.viewChanged;
    S ? (y.previousRatio = 0, this._stableFrames = 0) : E ? (y.uniforms.previousRatio.value = 0.5, this._stableFrames = 0) : (y.uniforms.previousRatio.value = 0.1, this._stableFrames++), this._stableFrames < 30 ? (h.requestRender(), this.isStable = !1) : this.isStable = !0;
    const b = h.sharedFullScreenRenderTargets.getAvailableRenderTarget();
    e.setRenderTarget(b), v.material = y, e.clear(!0, !1, !1), v.render(e), e.setRenderTarget(this._previousRenderTarget), x.uniforms.tDiffuse.value = b.texture, v.material = x, e.clear(!0, !1, !1), v.render(e);
    const w = this._compostionMaterial;
    w.uniforms.tDiffuse.value = s.texture, w.uniforms.tClold.value = b.texture, v.material = w, e.setRenderTarget(this.renderToScreen ? null : r), e.clear(!0, !1, !1), v.render(e), y.uniforms.uLastCameraMatrix.value.copy(y.uniforms.uCameraMatrix.value), e.autoClear = m;
  }
  getCurrentUsedTextures() {
    return [
      this._shapeRenderTarget.texture,
      this._detailRenderTarget.texture
    ];
  }
  _resetStableState() {
    this._stableFrames = 0;
  }
  get coverage() {
    return this._coverage;
  }
  set coverage(e) {
    this._coverage = e, this._mainMaterial.uniforms.coverage.value = e, this._resetStableState();
  }
  get density() {
    return this._density;
  }
  set density(e) {
    this._density = e, this._mainMaterial.uniforms.density.value = e, this._resetStableState();
  }
  get speed() {
    return this._speed;
  }
  set speed(e) {
    this._speed = e, this._mainMaterial.uniforms.speed.value = e, this._resetStableState();
  }
  get sunColor() {
    return this._sunColor;
  }
  set sunColor(e) {
    this._sunColor.copy(e), this._mainMaterial.uniforms.sunColor.value.copy(e), this._resetStableState();
  }
  get sunDirection() {
    return this._sunDirection;
  }
  set sunDirection(e) {
    this._sunDirection.copy(e), this._mainMaterial.uniforms.sunDirection.value.copy(e), this._resetStableState();
  }
  get ambientColorBottom() {
    return this._ambientColorBottom;
  }
  set ambientColorBottom(e) {
    this._ambientColorBottom.copy(e), this._mainMaterial.uniforms.ambientColorBottom.value.copy(e), this._resetStableState();
  }
  get shapeBaseScale() {
    return this._shapeBaseScale;
  }
  set shapeBaseScale(e) {
    this._shapeBaseScale = e, this._mainMaterial.uniforms.shapeScale.value.x = e, this._resetStableState();
  }
  get shapeDetailScale() {
    return this._shapeDetailScale;
  }
  set shapeDetailScale(e) {
    this._shapeDetailScale = e, this._mainMaterial.uniforms.shapeScale.value.y = e, this._resetStableState();
  }
  get useVolumetric() {
    return this._useVolumetric;
  }
  set useVolumetric(e) {
    this._useVolumetric = e, e ? this._mainMaterial.defines.MVT_USE_VOULEMTRIC = !0 : delete this._mainMaterial.defines.MVT_USE_VOULEMTRIC, this._mainMaterial.needsUpdate = !0, this._resetStableState();
  }
  get marchSteps() {
    return this._mainMaterial.defines.MVT_CLOUD_MARCH_STEPS;
  }
  set marchSteps(e) {
    this._mainMaterial.defines.MVT_CLOUD_MARCH_STEPS = parseInt(e, 10), this._mainMaterial.needsUpdate = !0;
  }
  get selfShadowSteps() {
    return this._mainMaterial.defines.MVT_CLOUD_SELF_SHADOW_STEPS;
  }
  set selfShadowSteps(e) {
    this._mainMaterial.defines.MVT_CLOUD_SELF_SHADOW_STEPS = parseInt(e, 10), this._mainMaterial.needsUpdate = !0;
  }
}
const ENV_TYPE_CUBE_UV = 2, _vector3$2 = new Vector3$1(), _color = new Color(), _matrix4$3 = new Matrix4();
class DynamicSky extends EmptySky {
  constructor(e = {}) {
    super(e);
    _(this, "isDynamicSky", !0);
    _(this, "_rtFlipCount", 0);
    _(this, "_skyNeedsCapture", !0);
    _(this, "_skyNeedsUpdate", !0);
    _(this, "_staticEnvMapNeedsUpdate", !0);
    _(this, "_realtimeCapture", !0);
    _(this, "_envMapType", ENV_TYPE_CUBE_UV);
    _(this, "_PMREMGenerator", null);
    _(this, "_cloud", null);
    _(this, "_envRenderTarget1", null);
    _(this, "_envRenderTarget2", null);
    _(this, "_skyAtmosphere", null);
    _(this, "_lastCameraZ", -1 / 0);
    _(this, "_skyLightIntensity", 0.2);
    _(this, "_sunLightIntensity", 2.2);
    _(this, "name", "DynamicSky");
    _(this, "dynamicCloud", !1);
    _(this, "_envCaptureLocationKey", "");
    _(this, "_presetWeatherProperties", {
      clear: {
        sunLightIntensity: 2.5,
        skyLightIntensity: 0.1,
        cloudsCoverage: 0,
        mixGrayFactor: 0
      },
      partlyCloudy: {
        sunLightIntensity: 2.2,
        skyLightIntensity: 0.2,
        cloudsCoverage: 0.55,
        mixGrayFactor: 0.2
      },
      cloudy: {
        sunLightIntensity: 0.5,
        skyLightIntensity: 0.5,
        cloudsCoverage: 0.6,
        mixGrayFactor: 0.5
      },
      overcast: {
        sunLightIntensity: 0,
        skyLightIntensity: 0.5,
        cloudsCoverage: 0.8,
        mixGrayFactor: 0.75
      },
      foggy: {
        sunLightIntensity: 0,
        skyLightIntensity: 0.5,
        cloudsCoverage: 0,
        mixGrayFactor: 1
      },
      rainy: {
        sunLightIntensity: 0,
        skyLightIntensity: 0.5,
        cloudsCoverage: 0,
        mixGrayFactor: 1
      },
      snowy: {
        sunLightIntensity: 0,
        skyLightIntensity: 0.5,
        cloudsCoverage: 0,
        mixGrayFactor: 1
      },
      stormy: {
        sunLightIntensity: 0,
        skyLightIntensity: 0.5,
        cloudsCoverage: 0.8,
        mixGrayFactor: 1
      },
      thunderstorm: {
        sunLightIntensity: 0,
        skyLightIntensity: 0.3,
        cloudsCoverage: 0.3,
        mixGrayFactor: 0.5
      }
    });
    _(this, "_setupClouds", () => {
      const e = this._engine, r = new TextureLoader(), s = r.load(getAssetUrl("assets/textures/cloud/weather_1.png"), (h) => {
        s.wrapS = s.wrapT = RepeatWrapping;
      }), a = r.load(getAssetUrl("assets/textures/cloud/shape_1.png"), (h) => {
        a.wrapS = a.wrapT = RepeatWrapping;
      }), c = r.load(
        getAssetUrl("assets/textures/cloud/BlueNoise_R_128.png"),
        (h) => {
          c.wrapS = c.wrapT = RepeatWrapping;
        }
      ), l = this._cloudsPass = new VolumetricCloudsPass({
        tBlueNoise: c,
        tWeather: s,
        tNoise: a
      });
      l.renderOrder = 2001, l.sky = this, e.rendering.main.postprocessings.add(l);
    });
    _(this, "updateRealtimeEnvironment", () => {
      const e = this._engine;
      if (this._skyAtmosphere.material.uStarVisible = !1, !this._cubeRenderTarget) {
        const l = this._cubeRenderTarget = new WebGLCubeRenderTarget(256);
        l.texture.type = HalfFloatType, l.texture.minFilter = LinearMipmapLinearFilter, l.texture.magFilter = LinearFilter, l.texture.generateMipmaps = !0, this._cubeCamera = new CubeCamera(1, 1e3, l);
      }
      e.rendering.objectsScene.visible = !1, e.rendering.environmentScene.visible = !0;
      const r = e.scene;
      let s = r.background;
      r.background = {};
      const a = e.rendering.environmentScene;
      e.map.isGlobe && (e.map.projection.localFrameToFixedFrame(e.rendering.camera.position, _matrix4$3), _matrix4$3.decompose(_vector3$2, a.quaternion, _vector3$2), a.updateMatrixWorld()), this._cubeCamera.update(e.renderer, r), this._PMREMGenerator || (this._PMREMGenerator = new PMREMGenerator(e.renderer)), this._PMREMGenerator._renderer !== e.renderer ? (this._PMREMGenerator.dispose(), this._PMREMGenerator = new PMREMGenerator(e.renderer), this._envRT && this._envRT.dispose(), this._envRT = this._PMREMGenerator.fromCubemap(this._cubeRenderTarget.texture)) : this._envRT = this._PMREMGenerator.fromCubemap(this._cubeRenderTarget.texture, this._envRT), e.rendering.scene.environment = this._envRT.texture, r.background = s, e.rendering.objectsScene.visible = !0, e.rendering.environmentScene.visible = !1, this._skyAtmosphere.material.uStarVisible = !0;
    });
    _(this, "disposeEnvRenderTarget", (e) => {
      this._envRenderTarget1 && (this._envRenderTarget1.dispose(), this._envRenderTarget1 = null), this._envRenderTarget2 && (this._envRenderTarget2.dispose(), this._envRenderTarget2 = null);
    });
    this._affectWorld = !0, this._upDirection = new Vector3$1(0, 0, 1);
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e), this._engine = e, this.initEnv();
  }
  initEnv() {
    const e = this._engine, r = this._skyAtmosphere = new SkyAtmosphere();
    r.collisionDisabled = !0, r.__isEnvironment = !0, r.renderOrder = -100, e.add(r);
    const s = this._atmospherePass = new SkyAtmospherePass();
    s.renderOrder = 2e3, s.sky = this, e.rendering.main.opaquePostprocessings.add(s), this._cloudAmbientBottomColorGradient = new GradientColorLerp([
      [0, new Color("#010105")],
      [5.5 / 24, new Color("#010105")],
      [5.8 / 24, new Color("#aa0000")],
      [6.1 / 24, new Color("#aa9944")],
      [7.5 / 24, new Color("#aaaaaa")],
      [12 / 24, new Color("#bbccdd")]
    ]), this._cloudSunIntensityGradient = new GradientColorLerp([
      [0, 0.01],
      [5.5 / 24, 0.05],
      [7.5 / 24, 0.1],
      [12 / 24, 0.4]
    ]), this._setupClouds();
  }
  onBeforeScenePrepareRender() {
    super.onBeforeScenePrepareRender();
    const e = this._engine, r = e.map.isGlobe, s = this._skyAtmosphere, a = this._cloud;
    s.material.uTime = e.rendering.uniforms.elapsedTime.value, s.material.uniforms.isGlobe.value = r, e.rendering.renderState.isRendererRecreated && (this.disposeEnvRenderTarget(), s._hasPaintedScatterBuffer = !1, this._skyNeedsUpdate = !0, this._skyNeedsCapture = !0, this._hasCaptureSky = !1, a && a.updateRenderCacheData());
    let c = e.map.getViewHeight();
    const l = Math.abs(c - (this._lastViewHeight || -1 / 0));
    if (this._lastViewHeight = c, r) {
      l > 1 && (this._skyNeedsUpdate = !0), e.map.getCameraLocation(_vector3$2);
      const h = `${Math.round(_vector3$2.x / 10)}-${Math.round(_vector3$2.y / 10)}`;
      h !== this._envCaptureLocationKey && (this._envCaptureLocationKey = h, this._skyNeedsCapture = !0, this._hasCaptureSky = !1);
    } else
      this._skyNeedsUpdate = !1;
    (this._skyNeedsCapture || this._skyNeedsUpdate) && (r ? s.viewHeight = Math.max(c / 1e6, 2e-4) : s.viewHeight = 2e-4, s.updateRenderTargets(e.rendering.renderer, e.rendering.camera), a && (a.material.uniforms.skyAltitude.value = s.altitude)), this.dynamicCloud && (a.material.uniforms.time.value = e.rendering.uniforms.elapsedTime.value), this._hasCaptureSky || (this._skyNeedsCapture = !0), c > 1e4 && (this._skyNeedsCapture = !1), (this._skyNeedsCapture || this.dynamicCloud) && (s.position.set(0, 0, 0), s.updateMatrixWorld(), a && (a.position.set(0, 0, 0), a.updateMatrixWorld()), this._affectWorld && (e.rendering.stats.beginTimeStatsItem("Sky.CaptureEnvironment"), this.updateRealtimeEnvironment(), e.rendering.stats.endTimeStatsItem("Sky.CaptureEnvironment")), this._hasCaptureSky = !0), this._affectWorld || (e.rendering.scene.environment = null), s.position.copy(e.rendering.camera.position), s.position.z -= 0, a && a.position.copy(e.rendering.camera.position), this._skyNeedsCapture = !1;
  }
  updateLight() {
    if (super.updateLight(), this._lensflare) {
      const e = this._sunDirection.z, r = this._sunDirection.x;
      let s = this._engine.map.getCameraDistance() * 10;
      if (e > 0.01 && this.sunLight.intensity > 0.1 && s < 1e6) {
        this._lensflare.visible = !0;
        const [a, c] = this._engine.map.getProjectionCenter();
        this._lensflare.position.set(a + r * s, c, e * s);
      } else
        this._lensflare.visible = !1;
    }
  }
  onTimeChanged(e) {
    const r = this._skyAtmosphere;
    r.altitude = (e / 86400 - 0.25) * Math.PI * 2, this._skyNeedsCapture = !0, this._updateClouds();
  }
  _updateClouds() {
    const e = this._cloudsPass;
    if (e) {
      const r = this._timeRatio > 0.5 ? 1 - this._timeRatio : this._timeRatio, s = this._cloudSunIntensityGradient.lerp(r), a = this.sunLight.color;
      e.sunColor = _vector3$2.set(a.r, a.g, a.b).multiplyScalar(s * (1 - this.mixGrayFactor)), e.sunDirection = _vector3$2.set(
        -this.localSunDirection.x,
        -this.localSunDirection.y,
        -this.localSunDirection.z
      ), this._cloudAmbientBottomColorGradient.lerp(r, _color), _vector3$2.set(_color.r, _color.g, _color.b).multiplyScalar(1 - this.mixGrayFactor), e.ambientColorBottom = _vector3$2;
    }
  }
  getTextures() {
    return this._envMapType === ENV_TYPE_CUBE_UV ? [this._envRenderTarget1.texture, this._envRenderTarget2.texture] : [];
  }
  beforeRemoveFromEngine(e) {
    this.disposeEnvRenderTarget(this._realtimeCapture), e.remove(this._skyAtmosphere), e.remove(this._cloud), e.rendering.main.postprocessings.remove(this._atmospherePass), e.rendering.main.postprocessings.remove(this._cloudsPass), this._skyNeedsUpdate = !0, this._skyNeedsCapture = !0, this._timeChanged = !0, super.beforeRemoveFromEngine(e);
  }
  dispose() {
    super.dispose();
  }
  set useVolumetricClouds(e) {
    this._cloudsPass.useVolumetric = e;
  }
  get useVolumetricClouds() {
    return this._cloudsPass.useVolumetric;
  }
  set affectWorld(e) {
    this._skyNeedsCapture = !0, this._affectWorld = e;
  }
  get affectWorld() {
    return this._affectWorld;
  }
  get mixGrayFactor() {
    return this._skyAtmosphere.mixGrayFactor;
  }
  set mixGrayFactor(e) {
    this._skyAtmosphere.mixGrayFactor = e, this._skyNeedsCapture = !0, this._updateClouds();
  }
  get realtimeCapture() {
    return this._realtimeCapture;
  }
  set realtimeCapture(e) {
    e !== this._realtimeCapture && (console.warn("has not been supported"), this._skyNeedsCapture = !0, this._realtimeCapture = e);
  }
  get skyAtmosphere() {
    return this._skyAtmosphere;
  }
  get clipUnderground() {
    return !1;
  }
  set clipUnderground(e) {
    console.warn("has not been supported");
  }
  get enableAtmospherePass() {
    return this._atmospherePass.enabled || !1;
  }
  set enableAtmospherePass(e) {
    this._atmospherePass && (this._atmospherePass.enabled = e);
  }
  get enableCloudsPass() {
    return this._cloudsPass && this._cloudsPass.enabled || !1;
  }
  set enableCloudsPass(e) {
    this._cloudsPass && (this._cloudsPass.enabled = e);
  }
  get cloudsCoverage() {
    return this._cloudsPass && this._cloudsPass.coverage || 0;
  }
  set cloudsCoverage(e) {
    this._cloudsPass && (this._cloudsPass.coverage = e);
  }
  get cloudDensity() {
    return this._cloudsPass && this._cloudsPass.density || 0;
  }
  set cloudDensity(e) {
    this._cloudsPass && (this._cloudsPass.density = e);
  }
  get cloudsSpeed() {
    return this._cloudsPass && this._cloudsPass.speed || 1;
  }
  set cloudsSpeed(e) {
    this._cloudsPass && (this._cloudsPass.speed = e);
  }
  get cloudShapeBaseScale() {
    return this._cloudsPass && this._cloudsPass.shapeBaseScale || 1;
  }
  set cloudShapeBaseScale(e) {
    this._cloudsPass && (this._cloudsPass.shapeBaseScale = e);
  }
  get cloudShapeDetailScale() {
    return this._cloudsPass && this._cloudsPass.shapeDetailScale || 1;
  }
  set cloudShapeDetailScale(e) {
    this._cloudsPass && (this._cloudsPass.shapeDetailScale = e);
  }
  get cloudMarchSteps() {
    return this._cloudsPass.marchSteps;
  }
  set cloudMarchSteps(e) {
    this._cloudsPass.marchSteps = e;
  }
  get cloudSelfShadowSteps() {
    return this._cloudsPass.selfShadowSteps;
  }
  set cloudSelfShadowSteps(e) {
    this._cloudsPass.selfShadowSteps = e;
  }
  get upDirection() {
    return this._upDirection;
  }
  get cloudsBaseHeight() {
    return 0;
  }
  set cloudsBaseHeight(e) {
    console.warn("cloudsBaseHeight has not been supported");
  }
}
class RGBELoader extends DataTextureLoader {
  constructor(i) {
    super(i), this.type = HalfFloatType;
  }
  parse(i) {
    const c = function(O, F) {
      switch (O) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (F || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (F || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (F || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (F || ""));
      }
    }, f = `
`, p = function(O, F, k) {
      F = F || 1024;
      let N = O.pos, U = -1, z = 0, $ = "", G = String.fromCharCode.apply(null, new Uint16Array(O.subarray(N, N + 128)));
      for (; 0 > (U = G.indexOf(f)) && z < F && N < O.byteLength; )
        $ += G, z += G.length, N += 128, G += String.fromCharCode.apply(null, new Uint16Array(O.subarray(N, N + 128)));
      return -1 < U ? (k !== !1 && (O.pos += z + U + 1), $ + G.slice(0, U)) : !1;
    }, m = function(O) {
      const F = /^#\?(\S+)/, k = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, V = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, N = /^\s*FORMAT=(\S+)\s*$/, U = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, z = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let $, G;
      for ((O.pos >= O.byteLength || !($ = p(O))) && c(1, "no header found"), (G = $.match(F)) || c(3, "bad initial token"), z.valid |= 1, z.programtype = G[1], z.string += $ + `
`; $ = p(O), $ !== !1; ) {
        if (z.string += $ + `
`, $.charAt(0) === "#") {
          z.comments += $ + `
`;
          continue;
        }
        if ((G = $.match(k)) && (z.gamma = parseFloat(G[1])), (G = $.match(V)) && (z.exposure = parseFloat(G[1])), (G = $.match(N)) && (z.valid |= 2, z.format = G[1]), (G = $.match(U)) && (z.valid |= 4, z.height = parseInt(G[1], 10), z.width = parseInt(G[2], 10)), z.valid & 2 && z.valid & 4)
          break;
      }
      return z.valid & 2 || c(3, "missing format specifier"), z.valid & 4 || c(3, "missing image size specifier"), z;
    }, y = function(O, F, k) {
      const V = F;
      if (V < 8 || V > 32767 || O[0] !== 2 || O[1] !== 2 || O[2] & 128)
        return new Uint8Array(O);
      V !== (O[2] << 8 | O[3]) && c(3, "wrong scanline width");
      const N = new Uint8Array(4 * F * k);
      N.length || c(4, "unable to allocate buffer space");
      let U = 0, z = 0;
      const $ = 4 * V, G = new Uint8Array(4), j = new Uint8Array($);
      let Y = k;
      for (; Y > 0 && z < O.byteLength; ) {
        z + 4 > O.byteLength && c(1), G[0] = O[z++], G[1] = O[z++], G[2] = O[z++], G[3] = O[z++], (G[0] != 2 || G[1] != 2 || (G[2] << 8 | G[3]) != V) && c(3, "bad rgbe scanline format");
        let H = 0, W;
        for (; H < $ && z < O.byteLength; ) {
          W = O[z++];
          const Z = W > 128;
          if (Z && (W -= 128), (W === 0 || H + W > $) && c(3, "bad scanline data"), Z) {
            const X = O[z++];
            for (let K = 0; K < W; K++)
              j[H++] = X;
          } else
            j.set(O.subarray(z, z + W), H), H += W, z += W;
        }
        const q = V;
        for (let Z = 0; Z < q; Z++) {
          let X = 0;
          N[U] = j[Z + X], X += V, N[U + 1] = j[Z + X], X += V, N[U + 2] = j[Z + X], X += V, N[U + 3] = j[Z + X], U += 4;
        }
        Y--;
      }
      return N;
    }, x = function(O, F, k, V) {
      const N = O[F + 3], U = Math.pow(2, N - 128) / 255;
      k[V + 0] = O[F + 0] * U, k[V + 1] = O[F + 1] * U, k[V + 2] = O[F + 2] * U, k[V + 3] = 1;
    }, v = function(O, F, k, V) {
      const N = O[F + 3], U = Math.pow(2, N - 128) / 255;
      k[V + 0] = DataUtils.toHalfFloat(Math.min(O[F + 0] * U, 65504)), k[V + 1] = DataUtils.toHalfFloat(Math.min(O[F + 1] * U, 65504)), k[V + 2] = DataUtils.toHalfFloat(Math.min(O[F + 2] * U, 65504)), k[V + 3] = DataUtils.toHalfFloat(1);
    }, S = new Uint8Array(i);
    S.pos = 0;
    const E = m(S), b = E.width, w = E.height, M = y(S.subarray(S.pos), b, w);
    let P, D, L;
    switch (this.type) {
      case FloatType:
        L = M.length / 4;
        const O = new Float32Array(L * 4);
        for (let k = 0; k < L; k++)
          x(M, k * 4, O, k * 4);
        P = O, D = FloatType;
        break;
      case HalfFloatType:
        L = M.length / 4;
        const F = new Uint16Array(L * 4);
        for (let k = 0; k < L; k++)
          v(M, k * 4, F, k * 4);
        P = F, D = HalfFloatType;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: b,
      height: w,
      data: P,
      header: E.string,
      gamma: E.gamma,
      exposure: E.exposure,
      type: D
    };
  }
  setDataType(i) {
    return this.type = i, this;
  }
  load(i, e, r, s) {
    function a(c, l) {
      switch (c.type) {
        case FloatType:
        case HalfFloatType:
          c.colorSpace = LinearSRGBColorSpace, c.minFilter = LinearFilter, c.magFilter = LinearFilter, c.generateMipmaps = !1, c.flipY = !0;
          break;
      }
      e && e(c, l);
    }
    return super.load(i, a, r, s);
  }
}
class HDRCubeTextureLoader extends Loader {
  constructor(i) {
    super(i), this.hdrLoader = new RGBELoader(), this.type = HalfFloatType;
  }
  load(i, e, r, s) {
    const a = new CubeTexture();
    switch (a.type = this.type, a.type) {
      case FloatType:
        a.colorSpace = LinearSRGBColorSpace, a.minFilter = LinearFilter, a.magFilter = LinearFilter, a.generateMipmaps = !1;
        break;
      case HalfFloatType:
        a.colorSpace = LinearSRGBColorSpace, a.minFilter = LinearFilter, a.magFilter = LinearFilter, a.generateMipmaps = !1;
        break;
    }
    const c = this;
    let l = 0;
    function h(d, f, p, m) {
      new FileLoader(c.manager).setPath(c.path).setResponseType("arraybuffer").setWithCredentials(c.withCredentials).load(i[d], function(y) {
        l++;
        const x = c.hdrLoader.parse(y);
        if (!!x) {
          if (x.data !== void 0) {
            const v = new DataTexture(x.data, x.width, x.height);
            v.type = a.type, v.colorSpace = a.colorSpace, v.format = a.format, v.minFilter = a.minFilter, v.magFilter = a.magFilter, v.generateMipmaps = a.generateMipmaps, a.images[d] = v;
          }
          l === 6 && (a.needsUpdate = !0, f && f(a));
        }
      }, p, m);
    }
    for (let d = 0; d < i.length; d++)
      h(d, e, r, s);
    return a;
  }
  setDataType(i) {
    return this.type = i, this.hdrLoader.setDataType(i), this;
  }
}
const vertexShader$i = `#define GLSLIFY 1
varying vec2 vUv;

void main()
{
    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);
    vUv = uv;
    gl_Position = projectionMatrix * viewPos;
    gl_Position.z = gl_Position.w;
}
`, fragmentShader$g = `#define GLSLIFY 1
#include <common>
varying vec2 vUv;
uniform sampler2D map;
uniform float opacity;
void main() {

    vec4 color = texture2D(map, vUv);
    color.a *= opacity;
    gl_FragColor = color;

    #include <colorspace_fragment>
}
`, uniforms$j = {
  map: { value: null },
  opacity: { value: 1 },
  isEmissive: { value: !1 }
};
class StaticSkyMaterial extends ShaderMaterial {
  constructor(i) {
    super(), this.defines = {}, this.uniforms = UniformsUtils.clone(uniforms$j), this.side = DoubleSide, this.vertexShader = vertexShader$i, this.fragmentShader = fragmentShader$g, this.depthWrite = !1, this.depthTest = !0, this.transparent = !0, this.envMap = null, this.envMapRotation = new Euler(0, 0, 0), defineMaterialNormalProperties(this, [
      "isEmissive"
    ]), Object.defineProperties(this, {
      map: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          this.uniforms.map.value = e, this.needsUpdate = !0;
        }
      },
      opacity: {
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(e) {
          this.uniforms.opacity.value = e;
        }
      }
    });
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
const _vector3$1 = new Vector3$1(), _vector32 = new Vector3$1(), _matrix4$2 = new Matrix4();
class CustomStaticSky extends EmptySky {
  constructor(e = {}) {
    super(e);
    _(this, "isCustomStaticSky", !0);
    _(this, "name", "CustomStaticSky");
    _(this, "_textureIsCube", !1);
    _(this, "_textureIsHDR", !1);
    _(this, "_textureURL", null);
    _(this, "_textureNames", null);
    _(this, "_affectWorld", !0);
    _(this, "_isVerticalTexture", null);
    _(this, "_mesh", null);
    _(this, "_material", null);
    _(this, "_sphereGeometry", null);
    _(this, "_envTexture", null);
    _(this, "_engine", null);
    _(this, "_PMREMGenerator", null);
    _(this, "_fadeHeightStart", 5e3);
    _(this, "_fadeHeightRange", 2e3);
    _(this, "_envCaptureLocationKey", "");
    e.texture;
    const r = this._sphereGeometry = new SphereGeometry(1, 32, 32);
    this.isVerticalTexture = e.isVerticalTexture || !1;
    const s = this._mesh = new Mesh(r, this._material);
    s.frustumCulled = !1, s.collisionDisabled = !0, this.add(s);
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e), this._engine = e, this._PMREMGenerator = new PMREMGenerator(e.renderer), this._loadSkyTexture();
  }
  onBeforeScenePrepareRender(e, r, s) {
    super.onBeforeScenePrepareRender(e, r, s);
    const a = this._mesh, c = this._material, l = e.map.isGlobe;
    if (l) {
      const h = e.map.getViewHeight();
      h < this._fadeHeightStart ? c.opacity = 1 : h > this._fadeHeightStart + this._fadeHeightRange ? c.opacity = 0 : c.opacity = 1 - (h - this._fadeHeightStart) / this._fadeHeightRange;
    } else
      c.opacity = 1;
    if (a.position.set(0, 0, 0), a.rotation.set(0, 0, 0), a.quaternion.set(0, 0, 0, 1), a.scale.set(1, 1, 1), this._onLocalTransform(a), a.updateMatrixWorld(!0), l) {
      e.map.unprojectCoordinate(s.position, _vector3$1), _vector3$1.z = _vector3$1.z * 0.8, e.map.projectCoordinate(_vector3$1, _vector32);
      const h = e.map.projection.localFrameToFixedFrame(_vector32, _matrix4$2);
      a.applyMatrix4(h);
    } else {
      const h = e.map.projection.localFrameToFixedFrame(s.position, _matrix4$2);
      a.applyMatrix4(h);
    }
    if (l && e.scene.environment === this._envTexture && (e.map.getCameraLocation(_vector3$1), _vector3$1.z < this._fadeHeightStart)) {
      const h = `${Math.round(_vector3$1.x / 10)}-${Math.round(_vector3$1.y / 10)}`;
      h !== this._envCaptureLocationKey && (this._envCaptureLocationKey = h, this._renderEnvTexture(), this._envTexture = this._envRT.texture, e.scene.environment = this._envTexture);
    }
  }
  _onLocalTransform(e) {
    e.rotateX(Math.PI / 2), e.scale.setScalar(1e4);
  }
  _renderEnvTexture() {
    if (!this._cubeRenderTarget) {
      const s = this._cubeRenderTarget = new WebGLCubeRenderTarget(256);
      s.texture.type = HalfFloatType, s.texture.minFilter = LinearFilter, s.texture.magFilter = LinearFilter, s.texture.generateMipmaps = !1, this._cubeCamera = new CubeCamera(1, 1e3, s);
    }
    const e = this._mesh, r = e.position.clone();
    e.position.set(0, 0, 0), this._cubeCamera.update(this._engine.renderer, e), e.position.copy(r), this._envRT = this._PMREMGenerator.fromCubemap(this._cubeRenderTarget.texture, this._envRT);
  }
  _loadSkyTexture() {
    if (!this._engine || !this._textureURL)
      return;
    let e = null;
    this._textureIsHDR ? this._textureIsCube ? e = new HDRCubeTextureLoader() : e = new RGBELoader() : this._textureIsCube ? e = new CubeTextureLoader() : e = new TextureLoader();
    const r = this._engine.rendering.scene;
    let s = null;
    this._textureIsCube ? (e.setPath(this._textureURL), this._textureNames ? s = this._textureNames : this._textureIsHDR ? s = ["nz.HDR", "pz.HDR", "px.HDR", "nx.HDR", "py.HDR", "ny.HDR"] : s = ["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]) : s = this._textureURL, e.load(s, (a) => {
      this._textureIsCube ? (this._mesh.visible = !1, a.colorSpace = SRGBColorSpace, r.background = a, this._envTexture = this._PMREMGenerator.fromCubemap(a).texture, this._affectWorld && (r.environment = this._envTexture)) : (r.background = null, this._mesh.visible = !0, a.colorSpace = SRGBColorSpace, this._material.map = a, this._material.needsUpdate = !0, this._isVerticalTexture ? r.environment = null : (this._renderEnvTexture(), this._envTexture = this._envRT.texture, this._affectWorld && (r.environment = this._envTexture))), this._engine.requestRender();
    });
  }
  get isVerticalTexture() {
    return this._verticalTexture;
  }
  set isVerticalTexture(e) {
    e !== this._isVerticalTexture && (this._material && this._material.dispose(), this._material = new StaticSkyMaterial(), this._isVerticalTexture = e, this._mesh && (this._mesh.material = this._material));
  }
  set textureIsCube(e) {
    this._textureIsCube = e;
  }
  get textureIsCube() {
    return this._textureIsCube;
  }
  get textureURL() {
    return this._textureURL;
  }
  set textureURL(e) {
    this._textureURL = e, this._loadSkyTexture();
  }
  get affectWorld() {
    return this._affectWorld;
  }
  set affectWorld(e) {
    const r = this._engine.rendering.scene;
    e ? (this._affectWorld = !0, r.environment = this._envTexture) : (this._affectWorld = !1, r.environment === this._envTexture && (r.environment = null));
  }
}
class StaticSky extends CustomStaticSky {
  constructor() {
    super(...arguments);
    _(this, "isStaticSky", !0);
    _(this, "name", "StaticSky");
    _(this, "weather", "clear");
    _(this, "_phase", "default");
    _(this, "_lastPhase", null);
    _(this, "_lastWeather", null);
    _(this, "_nightStartTime", 18 * 3600);
    _(this, "_nightEndTime", 6 * 3600);
    _(this, "_afternoonTime", 15.5 * 3600);
    _(this, "_duskTime", 17 * 3600);
    _(this, "_engine", null);
  }
  _onLocalTransform(e) {
    super._onLocalTransform(e), e.rotateY(Math.PI);
  }
  onTimeChanged(e) {
    e >= this._nightStartTime || e <= this._nightEndTime ? this._phase = "night" : e >= this._duskTime ? this._phase = "dusk" : e >= this._afternoonTime ? this._phase = "afternoon" : this._phase = "default", this.loadSkyTexture();
  }
  onWeatherChanged(e) {
    this._weather = e, this.loadSkyTexture();
  }
  loadSkyTexture() {
    if (!this._engine || this._phase === this._lastPhase && this.weather === this._lastWeather)
      return;
    let e = urlJoin(getBaseUrl(), "assets/textures/sky", this.weather, this._phase, "/" + this._phase + ".jpg");
    this.textureURL = e, this._lastPhase = this._phase, this._lastWeather = this._weather;
  }
}
const http$9 = window.location.protocol === "http:" ? "http:" : "https:", styleMap = {
  [STADIA_MAP_STYLE_STAMEN_WATERCOLOR]: `${http$9}//tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{reverseY}.jpg`,
  [STADIA_MAP_STYLE_STAMEN_TONER]: `${http$9}//tiles.stadiamaps.com/tiles/stamen_toner/{z}/{x}/{reverseY}@2x.png`,
  [STADIA_MAP_STYLE_ALIDE_SMOOTH]: `${http$9}//tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{reverseY}@2x.png`,
  [STADIA_MAP_STYLE_ALIDE_SMOOTH_DARK]: `${http$9}//tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{reverseY}@2x.png`,
  [STADIA_MAP_STYLE_OUTDOORS]: `${http$9}//tiles.stadiamaps.com/tiles/outdoors/{z}/{x}/{reverseY}@2x.png`
};
class StadiaImageryTileProvider extends ImageryTileProvider {
  constructor(e = {}) {
    super({
      ...e,
      projection: PROJECTION_WEB_MERCATOR
    });
    _(this, "name", "StadiaImageryTileProvider");
    _(this, "_supportedTargetProjectionNames", [PROJECTION_WEB_MERCATOR, PROJECTION_GEO]);
    _(this, "_defaultStartLevel", 1);
    _(this, "_defaultMaxLevel", 18);
    _(this, "_maxParallelRequestNum", 24);
    _(this, "_useWebMeractorProjectionAndGrid", !0);
    this._style = e.style || STADIA_MAP_STYLE_STAMEN_WATERCOLOR, this._replaceStr = {
      x: "{x}",
      y: "{y}",
      z: "{z}",
      reverseY: "{reverseY}"
    };
  }
  get style() {
    return this._style;
  }
  set style(e) {
    this._style !== e && (this._style = e, this._needsClearCache = !0);
  }
  getTileURL(e, r, s, a) {
    return styleMap[this._style].replaceAll(this._replaceStr.x, r).replaceAll(this._replaceStr.y, s).replaceAll(this._replaceStr.reverseY, a.reverseY).replaceAll(this._replaceStr.z, e);
  }
}
const http$8 = window.location.protocol === "http:" ? "http:" : "https:", osmUrls = [
  `${http$8}//tile.osm.org`,
  `${http$8}//a.tile.osm.org`,
  `${http$8}//b.tile.osm.org`,
  `${http$8}//c.tile.osm.org`
];
class OSMImageryTileProvider extends ImageryTileProvider {
  constructor(e) {
    super({
      ...e,
      projection: PROJECTION_WEB_MERCATOR
    });
    _(this, "name", "OSMImageryTileProvider");
    _(this, "_supportedTargetProjectionNames", [PROJECTION_WEB_MERCATOR, PROJECTION_GEO]);
    _(this, "_defaultStartLevel", 1);
    _(this, "_defaultMaxLevel", 18);
    _(this, "_maxParallelRequestNum", 24);
    _(this, "_useWebMeractorProjectionAndGrid", !0);
  }
  getTileURL(e, r, s, a) {
    const c = Math.abs(r + s) % osmUrls.length;
    return `${osmUrls[c]}/${e}/${r}/${a.reverseY}.png`;
  }
}
class TiandituImageryTileProvider extends ImageryTileProvider {
  constructor(e = {}) {
    super({
      ...e
    });
    _(this, "name", "TiandituImageryTileProvider");
    _(this, "_tk", "");
    _(this, "_supportedTargetProjectionNames", [PROJECTION_GEO, PROJECTION_WEB_MERCATOR]);
    _(this, "_defaultMaxLevel", 18);
    this._tk = e.tk || TiandituConfig.tk;
  }
  initProjectionAndGrid() {
    this._sourceProjection = this._targetProjection, this._sourceProjection.name === PROJECTION_WEB_MERCATOR ? this._grid = new WebMercatorGrid(this._engine, this._sourceProjection, this._targetProjection) : this._sourceProjection.name === PROJECTION_GEO && (this._grid = new GeoGrid(this._engine, this._sourceProjection, this._targetProjection));
  }
  getTileURL(e, r, s, a) {
    const l = this._sourceProjection.name === PROJECTION_GEO ? "vec_c" : "vec_w";
    return `https://t2.tianditu.gov.cn/DataServer?tk=${this._tk}&T=${l}&x=${r}&y=${a.reverseY}&l=${e}`;
  }
}
class XYZImageryTileProvider extends ImageryTileProvider {
  constructor(e = {}) {
    super(e);
    _(this, "name", "XYZImageryTileProvider");
    _(this, "_supportedTargetProjectionNames", [PROJECTION_WEB_MERCATOR, PROJECTION_GEO]);
    _(this, "_maxParallelRequestNum", 24);
    _(this, "_url", null);
    if (!e.url)
      throw new Error("XYZImageryTileProvider: url is required");
    this._replaceStr = {
      x: "{x}",
      z: "{z}",
      y: "{reverseY}",
      reverseY: "{y}"
    }, (this._maxLevel === void 0 || this._maxLevel === 1 / 0) && (this._maxLevel = 18), this._url = e.url, this._defaultXYZProjectionName = e.projection || PROJECTION_WEB_MERCATOR;
  }
  initProjectionAndGrid() {
    this._defaultXYZProjectionName === PROJECTION_WEB_MERCATOR ? (this._sourceProjection = getProjection(PROJECTION_WEB_MERCATOR), this._grid = new WebMercatorGrid(this._engine, this._sourceProjection, this._targetProjection)) : this._defaultXYZProjectionName === PROJECTION_GEO && (this._sourceProjection = getProjection(PROJECTION_GEO), this._grid = new GeoGrid(this._engine, this._sourceProjection, this._targetProjection));
  }
  getTileURL(e, r, s, a) {
    return this._url.replaceAll(this._replaceStr.x, r).replaceAll(this._replaceStr.y, s).replaceAll(this._replaceStr.reverseY, a.reverseY).replaceAll(this._replaceStr.z, e);
  }
}
class Baidu09ImageryTileProvider extends ImageryTileProvider {
  constructor(e = {}) {
    super({
      ...e
    });
    _(this, "name", "Baidu09ImageryTileProvider");
    _(this, "isBaiduProvider", !0);
    _(this, "_supportedTargetProjectionNames", [PROJECTION_WEB_MERCATOR, PROJECTION_GEO]);
    _(this, "_defaultStartLevel", 3);
    _(this, "_defaultMaxLevel", 19);
    _(this, "_maxParallelRequestNum", 24);
    _(this, "_type", null);
    const r = e.ak || BaiduMapConfig.ak;
    this._ak = r, this._type = e.type;
  }
  initProjectionAndGrid() {
    this._sourceProjection = getProjection(PROJECTION_BD_MERCATOR), this._grid = new BaiduImageryGrid(this._engine, this._sourceProjection, this._targetProjection);
  }
  getTileURL(e, r, s, a) {
    if (e < 3)
      return !1;
    const [c, l, h] = a.grid.getRasterTileCoord(e, r, s);
    return this._type === "satellite" ? `https://apimaponline${Math.abs(r + s) % 4}.bdimg.com/starpic/?qt=satepc&ak=${this._ak}&u=x=${l};y=${h};z=${c};v=009;type=sate&fm=46&app=webearth2&udt=20250724&v=009&from=mapvthree` : `https://apimaponline${Math.abs(r + s) % 4}.bdimg.com/tile/?qt=vtile&v=three&ak=${this._ak}&x=${l}&y=${h}&z=${c}&styles=pl&scaler=2&udt=20211014&from=mapvthree`;
  }
}
class WMSImageryTileProvider extends ImageryTileProvider {
  constructor(e = {}) {
    super(e);
    _(this, "name", "WMSImageryTileProvider");
    _(this, "_supportedTargetProjectionNames", [PROJECTION_WEB_MERCATOR, PROJECTION_GEO]);
    _(this, "_maxParallelRequestNum", 24);
    _(this, "_defaultMaxLevel", 18);
    _(this, "_url", null);
    _(this, "_serverType", null);
    _(this, "_hidpi", !1);
    _(this, "_devicePixelRatio", 1);
    if (!e.url)
      throw new Error("WMSImageryTileProvider: url is required");
    this._replaceStr = {
      x: "{x}",
      y: "{y}",
      z: "{z}",
      b: "{b}",
      reverseY: "{reverseY}"
    }, this._url = e.url, this._baseUrl = e.url.split("?")[0], this._params = e.params || {}, this._serverType = e.serverType, this._hidpi = e.hidpi || !1, this._setWmsParams();
  }
  _setWmsParams() {
    const e = this.getUrlParams(this._url);
    this._params = Object.assign({
      SERVICE: "WMS",
      VERSION: "1.3.0",
      REQUEST: "GetMap",
      FORMAT: "image/png",
      TRANSPARENT: !0,
      LAYERS: "",
      WIDTH: 256,
      HEIGHT: 256,
      STYLES: "",
      BBOX: "{b}"
    }, this._getUppercaseKeys(e), this._getUppercaseKeys(this._params)), this._params.TRANSPARENT = this._params.TRANSPARENT !== void 0 ? this._params.TRANSPARENT === "true" || this._params.TRANSPARENT === !0 : !0, this._params.WIDTH = parseInt(this._params.WIDTH || this._params.width || "256", 10), this._params.HEIGHT = parseInt(this._params.HEIGHT || this._params.height || "256", 10), this._compareVersions(this._params.VERSION, "1.3") >= 0 ? this._params.CRS = this._params.CRS || this._params.crs || PROJECTION_WEB_MERCATOR : this._params.SRS = this._params.SRS || this._params.srs || PROJECTION_WEB_MERCATOR;
  }
  getHiDPIParams() {
    if (this._engine && this._engine.rendering && (this._devicePixelRatio = this._engine.rendering.pixelRatio), !(!this._hidpi || this._devicePixelRatio <= 1))
      switch (this._serverType) {
        case "geoserver":
          const e = 90 * this._devicePixelRatio + 0.5 | 0;
          "FORMAT_OPTIONS" in this._params ? this._params.FORMAT_OPTIONS += ";dpi:" + e : this._params.FORMAT_OPTIONS = "dpi:" + e;
          break;
        case "mapserver":
          this._params.MAP_RESOLUTION = 90 * this._devicePixelRatio;
          break;
        case "carmentaserver":
        case "qgis":
          this._params.DPI = 90 * this._devicePixelRatio;
          break;
        default:
          throw new Error("Unknown `serverType` configured");
      }
  }
  _getUppercaseKeys(e) {
    const r = {};
    for (const s in e)
      r[s.toUpperCase()] = e[s];
    return r;
  }
  initProjectionAndGrid() {
    this.getHiDPIParams();
    const e = this._params, r = e.CRS || e.SRS || PROJECTION_WEB_MERCATOR, s = this._normalizeProjectionName(r);
    s === PROJECTION_WEB_MERCATOR ? (this._sourceProjection = getProjection(PROJECTION_WEB_MERCATOR), this._grid = new WebMercatorGrid(this._engine, this._sourceProjection, this._targetProjection)) : s === PROJECTION_GEO && (this._sourceProjection = getProjection(PROJECTION_GEO), this._grid = new GeoGrid(this._engine, this._sourceProjection, this._targetProjection));
  }
  _normalizeProjectionName(e) {
    if (!e)
      return PROJECTION_WEB_MERCATOR;
    const r = e.toUpperCase().trim();
    return {
      "EPSG:900913": PROJECTION_WEB_MERCATOR,
      "EPSG:3857": PROJECTION_WEB_MERCATOR,
      "EPSG:4326": PROJECTION_GEO,
      "CRS:84": PROJECTION_GEO,
      "OGC:CRS84": PROJECTION_GEO
    }[r] || r;
  }
  _compareVersions(e, r) {
    const s = e.split(".").map(Number), a = r.split(".").map(Number);
    for (let c = 0; c < Math.max(s.length, a.length); c++) {
      const l = s[c] || 0, h = a[c] || 0;
      if (l < h)
        return -1;
      if (l > h)
        return 1;
    }
    return 0;
  }
  _formatBbox(e, r, s) {
    const { min: a, max: c } = e;
    let l = Math.max(a.x, r ? -180 : -20037508342789244e-9), h = Math.max(a.y, r ? -90 : -20037508342789244e-9), d = Math.min(c.x, r ? 180 : 20037508342789244e-9), f = Math.min(c.y, r ? 90 : 20037508342789244e-9), p = [l, h, d, f];
    return this._compareVersions(s, "1.3") >= 0 && r && (p = [h, l, f, d]), p.join(",");
  }
  appendParams(e, r) {
    const s = [];
    Object.keys(r).forEach((c) => {
      if (r[c] !== null && r[c] !== void 0) {
        let l = r[c];
        Object.values(this._replaceStr).some((h) => typeof l == "string" && l.indexOf(h) >= 0) || (l = encodeURIComponent(l)), s.push(c + "=" + l);
      }
    });
    const a = s.join("&");
    return e = e.replace(/[?&]$/, ""), e += e.includes("?") ? "&" : "?", e + a;
  }
  getUrlParams(e) {
    const r = e.split("?").pop().split("#").shift().split("&");
    let s = {};
    return r.forEach((a) => {
      if (a) {
        const [c, l] = a.split("=");
        c && l !== void 0 && (s[c] = decodeURIComponent(l));
      }
    }), s;
  }
  getTileURL(e, r, s, a) {
    let c = this.appendParams(this._baseUrl, this._params);
    const { min: l, max: h } = this._sourceProjection.isGeo ? a.geoBoundingBox : a.projectedBoundingBox, d = this._formatBbox({ min: l, max: h }, this._sourceProjection.isGeo, this._params.VERSION);
    return c = c.replaceAll(this._replaceStr.b, d), c;
  }
  setParams(e) {
    this._params = { ...this._params, ...e }, this._needsClearCache = !0;
  }
  getParams() {
    return { ...this._params };
  }
}
class WMTSImageryTileProvider extends ImageryTileProvider {
  constructor(e = {}) {
    super(e);
    _(this, "name", "WMTSImageryTileProvider");
    _(this, "_supportedTargetProjectionNames", [PROJECTION_WEB_MERCATOR, PROJECTION_GEO]);
    _(this, "_maxParallelRequestNum", 24);
    _(this, "_defaultMaxLevel", 18);
    _(this, "_url", null);
    _(this, "_requestEncoding", "KVP");
    _(this, "_matrixIds", null);
    if (!e.url)
      throw new Error("WMTSImageryTileProvider: url is required");
    this._replaceStr = {
      x: "{x}",
      y: "{y}",
      z: "{z}",
      reverseY: "{reverseY}"
    }, this._url = e.url, this._baseUrl = e.url.split("?")[0], this._params = e.params || {}, this._matrixIds = e.matrixIds || null, this._requestEncoding = e.requestEncoding || "KVP", this._setWmtsParams();
  }
  _setWmtsParams() {
    const e = this.getUrlParams(this._url), r = {
      LAYER: "",
      STYLE: "",
      TILEMATRIXSET: "EPSG:3857",
      TILEMATRIX: "{z}",
      TILEROW: "{y}",
      TILECOL: "{x}"
    };
    this._requestEncoding === "KVP" && Object.assign(r, {
      SERVICE: "WMTS",
      REQUEST: "GetTile",
      VERSION: "1.0.0",
      FORMAT: "image/png"
    }), this._params = Object.assign(
      r,
      this._getUppercaseKeys(e),
      this._getUppercaseKeys(this._params)
    );
  }
  _getUppercaseKeys(e) {
    const r = {};
    for (const s in e)
      r[s.toUpperCase()] = e[s];
    return r;
  }
  initProjectionAndGrid() {
    const r = this._params.TILEMATRIXSET || "EPSG:3857", s = this._normalizeProjectionName(r);
    s === PROJECTION_WEB_MERCATOR ? (this._sourceProjection = getProjection(PROJECTION_WEB_MERCATOR), this._grid = new WebMercatorGrid(this._engine, this._sourceProjection, this._targetProjection)) : s === PROJECTION_GEO && (this._sourceProjection = getProjection(PROJECTION_GEO), this._grid = new GeoGrid(this._engine, this._sourceProjection, this._targetProjection));
  }
  _normalizeProjectionName(e) {
    if (!e)
      return PROJECTION_WEB_MERCATOR;
    const r = e.toUpperCase().trim();
    return {
      "EPSG:900913": PROJECTION_WEB_MERCATOR,
      "EPSG:3857": PROJECTION_WEB_MERCATOR,
      "EPSG:4326": PROJECTION_GEO,
      "CRS:84": PROJECTION_GEO,
      "OGC:CRS84": PROJECTION_GEO,
      GOOGLEMAPSCOMPATIBLE: PROJECTION_WEB_MERCATOR,
      WGS84: PROJECTION_GEO,
      WGS84QUAD: PROJECTION_GEO,
      DEFAULT028MM: PROJECTION_WEB_MERCATOR
    }[r] || r;
  }
  appendParams(e, r) {
    const s = [];
    Object.keys(r).forEach((c) => {
      if (r[c] !== null && r[c] !== void 0) {
        let l = r[c];
        Object.values(this._replaceStr).some((h) => typeof l == "string" && l.indexOf(h) >= 0) || (l = encodeURIComponent(l)), s.push(c + "=" + l);
      }
    });
    const a = s.join("&");
    return e = e.replace(/[?&]$/, ""), e += e.includes("?") ? "&" : "?", e + a;
  }
  getUrlParams(e) {
    const r = e.split("?").pop().split("#").shift().split("&");
    let s = {};
    return r.forEach((a) => {
      if (a) {
        const [c, l] = a.split("=");
        c && l !== void 0 && (s[c] = decodeURIComponent(l));
      }
    }), s;
  }
  getTileURL(e, r, s, a) {
    const c = this._getTileMatrixValue(e), l = {
      ...this._params
    };
    this._matrixIds && Array.isArray(this._matrixIds) && this._matrixIds[e] !== void 0 && (l.TILEMATRIX = c);
    let h = "";
    return this._requestEncoding === "REST" ? (h = this._url, h = h.replace(/(\{layer\})/gi, l.LAYER).replace(/(\{style\})/gi, l.STYLE).replace(/(\{tilematrixset\})/gi, l.TILEMATRIXSET).replace(/(\{tilematrix\})/gi, l.TILEMATRIX).replace(/(\{tilerow\})/gi, l.TILEROW).replace(/(\{tilecol\})/gi, l.TILECOL)) : h = this.appendParams(this._baseUrl, l), h = h.replaceAll(this._replaceStr.x, r).replaceAll(this._replaceStr.y, a.reverseY).replaceAll(this._replaceStr.z, c), h;
  }
  _getTileMatrixValue(e) {
    return this._matrixIds && Array.isArray(this._matrixIds) && this._matrixIds[e] !== void 0 ? this._matrixIds[e] : e;
  }
  setParams(e) {
    this._params = { ...this._params, ...e }, this._needsClearCache = !0;
  }
  getParams() {
    return { ...this._params };
  }
}
const IndexDatatype = {
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123,
  UNSIGNED_INT: 5125
};
IndexDatatype.getSizeInBytes = function(o) {
  switch (o) {
    case IndexDatatype.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case IndexDatatype.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case IndexDatatype.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
  }
  throw new DeveloperError(
    "indexDatatype is required and must be a valid IndexDatatype constant."
  );
};
IndexDatatype.fromSizeInBytes = function(o) {
  switch (o) {
    case 2:
      return IndexDatatype.UNSIGNED_SHORT;
    case 4:
      return IndexDatatype.UNSIGNED_INT;
    case 1:
      return IndexDatatype.UNSIGNED_BYTE;
    default:
      throw new DeveloperError(
        "Size in bytes cannot be mapped to an IndexDatatype"
      );
  }
};
IndexDatatype.validate = function(o) {
  return defined$2(o) && (o === IndexDatatype.UNSIGNED_BYTE || o === IndexDatatype.UNSIGNED_SHORT || o === IndexDatatype.UNSIGNED_INT);
};
IndexDatatype.createTypedArray = function(o, i) {
  if (!defined$2(o))
    throw new DeveloperError("numberOfVertices is required.");
  return o >= CesiumMath.SIXTY_FOUR_KILOBYTES ? new Uint32Array(i) : new Uint16Array(i);
};
IndexDatatype.createTypedArrayFromArrayBuffer = function(o, i, e, r) {
  if (!defined$2(o))
    throw new DeveloperError("numberOfVertices is required.");
  if (!defined$2(i))
    throw new DeveloperError("sourceArray is required.");
  if (!defined$2(e))
    throw new DeveloperError("byteOffset is required.");
  return o >= CesiumMath.SIXTY_FOUR_KILOBYTES ? new Uint32Array(i, e, r) : new Uint16Array(i, e, r);
};
IndexDatatype.fromTypedArray = function(o) {
  if (o instanceof Uint8Array)
    return IndexDatatype.UNSIGNED_BYTE;
  if (o instanceof Uint16Array)
    return IndexDatatype.UNSIGNED_SHORT;
  if (o instanceof Uint32Array)
    return IndexDatatype.UNSIGNED_INT;
  throw new DeveloperError(
    "array must be a Uint8Array, Uint16Array, or Uint32Array."
  );
};
const IndexDatatype$1 = Object.freeze(IndexDatatype), arrayScratch = [], QuantizedMeshExtensionIds = {
  OCT_VERTEX_NORMALS: 1,
  WATER_MASK: 2,
  METADATA: 4
};
function sortIndicesIfNecessary(o, i, e) {
  arrayScratch.length = o.length;
  let r = !1;
  for (let s = 0, a = o.length; s < a; ++s)
    arrayScratch[s] = o[s], r = r || s > 0 && i(o[s - 1], o[s]) > 0;
  return r ? (arrayScratch.sort(i), IndexDatatype$1.createTypedArray(e, arrayScratch)) : o;
}
function zigZagDecode(o) {
  return o >> 1 ^ -(o & 1);
}
function zigZagDeltaDecode(o, i, e) {
  const r = o.length;
  let s = 0, a = 0, c = 0;
  for (let l = 0; l < r; ++l)
    s += zigZagDecode(o[l]), a += zigZagDecode(i[l]), o[l] = s, i[l] = a, defined$2(e) && (c += zigZagDecode(e[l]), e[l] = c);
}
class QuantizedMeshTerrainData {
  constructor(i) {
    if (!defined$2(i) || !defined$2(i.quantizedVertices))
      throw new DeveloperError("options.quantizedVertices is required.");
    if (!defined$2(i.indices))
      throw new DeveloperError("options.indices is required.");
    if (!defined$2(i.minimumHeight))
      throw new DeveloperError("options.minimumHeight is required.");
    if (!defined$2(i.maximumHeight))
      throw new DeveloperError("options.maximumHeight is required.");
    if (!defined$2(i.maximumHeight))
      throw new DeveloperError("options.maximumHeight is required.");
    if (!defined$2(i.westIndices))
      throw new DeveloperError("options.westIndices is required.");
    if (!defined$2(i.southIndices))
      throw new DeveloperError("options.southIndices is required.");
    if (!defined$2(i.eastIndices))
      throw new DeveloperError("options.eastIndices is required.");
    if (!defined$2(i.northIndices))
      throw new DeveloperError("options.northIndices is required.");
    this._quantizedVertices = i.quantizedVertices, this._encodedNormals = i.encodedNormals, this._indices = i.indices, this._minimumHeight = i.minimumHeight, this._maximumHeight = i.maximumHeight, this._boundingSphere = i.boundingSphere, this._horizonOcclusionPoint = i.horizonOcclusionPoint;
    const e = this._quantizedVertices.length / 3, r = this._uValues = this._quantizedVertices.subarray(
      0,
      e
    ), s = this._vValues = this._quantizedVertices.subarray(
      e,
      2 * e
    );
    this._heightValues = this._quantizedVertices.subarray(
      2 * e,
      3 * e
    );
    function a(l, h) {
      return s[l] - s[h];
    }
    function c(l, h) {
      return r[l] - r[h];
    }
    this._westIndices = sortIndicesIfNecessary(
      i.westIndices,
      a,
      e
    ), this._southIndices = sortIndicesIfNecessary(
      i.southIndices,
      c,
      e
    ), this._eastIndices = sortIndicesIfNecessary(
      i.eastIndices,
      a,
      e
    ), this._northIndices = sortIndicesIfNecessary(
      i.northIndices,
      c,
      e
    ), this._childTileMask = defaultValue$1(i.childTileMask, 15), this._mesh = void 0;
  }
  static createQuantizedMeshTerrainData(i, e) {
    let r = 0;
    const s = 3, a = s + 1, c = Float64Array.BYTES_PER_ELEMENT * s, l = Float64Array.BYTES_PER_ELEMENT * a, h = 3, d = Uint16Array.BYTES_PER_ELEMENT * h, f = 3;
    let p = Uint16Array.BYTES_PER_ELEMENT, m = p * f;
    const y = new DataView(e);
    r += c;
    const x = y.getFloat32(r, !0);
    r += Float32Array.BYTES_PER_ELEMENT;
    const v = y.getFloat32(r, !0);
    r += Float32Array.BYTES_PER_ELEMENT;
    const S = {
      center: new Vector3$1(
        y.getFloat64(r, !0),
        y.getFloat64(r + 8, !0),
        y.getFloat64(r + 16, !0)
      ),
      radius: y.getFloat64(r + c, !0)
    };
    r += l;
    const E = new Vector3$1(
      y.getFloat64(r, !0),
      y.getFloat64(r + 8, !0),
      y.getFloat64(r + 16, !0)
    );
    r += c;
    const b = y.getUint32(r, !0);
    r += Uint32Array.BYTES_PER_ELEMENT;
    const w = new Uint16Array(e, r, b * 3);
    r += b * d, b > 64 * 1024 && (p = Uint32Array.BYTES_PER_ELEMENT, m = p * f);
    const M = w.subarray(0, b), P = w.subarray(b, 2 * b), D = w.subarray(
      b * 2,
      3 * b
    );
    zigZagDeltaDecode(M, P, D), r % p !== 0 && (r += p - r % p);
    const L = y.getUint32(r, !0);
    r += Uint32Array.BYTES_PER_ELEMENT;
    const O = IndexDatatype$1.createTypedArrayFromArrayBuffer(
      b,
      e,
      r,
      L * f
    );
    r += L * m;
    let F = 0;
    const k = O.length;
    for (let W = 0; W < k; ++W) {
      const q = O[W];
      O[W] = F - q, q === 0 && ++F;
    }
    const V = y.getUint32(r, !0);
    r += Uint32Array.BYTES_PER_ELEMENT;
    const N = IndexDatatype$1.createTypedArrayFromArrayBuffer(
      b,
      e,
      r,
      V
    );
    r += V * p;
    const U = y.getUint32(r, !0);
    r += Uint32Array.BYTES_PER_ELEMENT;
    const z = IndexDatatype$1.createTypedArrayFromArrayBuffer(
      b,
      e,
      r,
      U
    );
    r += U * p;
    const $ = y.getUint32(r, !0);
    r += Uint32Array.BYTES_PER_ELEMENT;
    const G = IndexDatatype$1.createTypedArrayFromArrayBuffer(
      b,
      e,
      r,
      $
    );
    r += $ * p;
    const j = y.getUint32(r, !0);
    r += Uint32Array.BYTES_PER_ELEMENT;
    const Y = IndexDatatype$1.createTypedArrayFromArrayBuffer(
      b,
      e,
      r,
      j
    );
    r += j * p;
    let H;
    for (; r < y.byteLength; ) {
      const W = y.getUint8(r, !0);
      r += Uint8Array.BYTES_PER_ELEMENT;
      const q = !0, Z = y.getUint32(r, q);
      r += Uint32Array.BYTES_PER_ELEMENT, W === QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS && i.hasVertexNormals && (H = new Uint8Array(e, r, b * 2)), r += Z;
    }
    return new QuantizedMeshTerrainData({
      minimumHeight: x,
      maximumHeight: v,
      boundingSphere: S,
      horizonOcclusionPoint: E,
      quantizedVertices: w,
      encodedNormals: H,
      indices: O,
      westIndices: N,
      southIndices: z,
      eastIndices: G,
      northIndices: Y
    });
  }
}
class TerrainMesh {
  constructor(i, e, r, s, a, c, l, h, d, f, p, m, y, x, v, S) {
    this.center = i, this.vertices = e, this.stride = defaultValue$1(f, 6), this.indices = r, this.indexCountWithoutSkirts = s, this.vertexCountWithoutSkirts = a, this.minimumHeight = c, this.maximumHeight = l, this.boundingSphere3D = h, this.occludeePointInScaledSpace = d, this.orientedBoundingBox = p, this.encoding = m, this.westIndicesSouthToNorth = y, this.southIndicesEastToWest = x, this.eastIndicesNorthToSouth = v, this.northIndicesWestToEast = S;
  }
}
class AsyncCesiumTerrainDataLoader {
  constructor(i, e, r) {
    this.provider = i, this._workerTaskScheduler = new WorkerTaskScheduler(e, r), this._workerTaskScheduler.getResponseMessageId = this.getResponseMessageId, this._workerTaskScheduler.isMessageCompleted = this.isMessageCompleted;
  }
  isMessageCompleted(i, e) {
    return i.type === "terrainMeshCreated" || i.type === "terrainDataUpsampled";
  }
  getResponseMessageId(i, e) {
    return i.tileKey;
  }
  _vectorToArray(i) {
    return [i.x, i.y, i.z];
  }
  _boxToArray(i) {
    return [i.min.x, i.min.y, i.min.z, i.max.x, i.max.y, i.max.z];
  }
  async upsample(i, e, r) {
    const s = this.provider, a = s._engine.map.map._ellipsoid, c = s.hasVertexNormals, l = e.x, h = e.y, d = r.x, f = r.y;
    if (!defined$2(i) || !defined$2(i._mesh))
      return;
    const p = i._mesh, m = l * 2 !== d, y = h * 2 !== f, x = Rectangle.fromBox(r.geoBoundingBox), v = "upsampleTerrainData", S = {
      type: v,
      tileKey: r.key,
      isEastChild: m,
      isNorthChild: y,
      childRectangle: x,
      ellipsoid: a,
      vertices: p.vertices,
      indices: p.indices,
      vertexCountWithoutSkirts: p.vertexCountWithoutSkirts,
      indexCountWithoutSkirts: p.indexCountWithoutSkirts,
      minimumHeight: p.minimumHeight,
      maximumHeight: p.maximumHeight,
      hasVertexNormals: c
    };
    if (s.getFetchOptions) {
      const P = s.getFetchOptions(r);
      S.fetchOptions = P;
    }
    if (s.getWorkerOptions) {
      const P = s.getWorkerOptions(r);
      S.workerOptions = P;
    }
    let E = await this._workerTaskScheduler.postMessage(S, [], v + "-" + r.key);
    E = E.content;
    const b = new Uint16Array(E.vertices), w = IndexDatatype$1.createTypedArray(
      b.length / 3,
      E.indices
    );
    return new QuantizedMeshTerrainData({
      quantizedVertices: b,
      indices: w,
      minimumHeight: E.minimumHeight,
      maximumHeight: E.maximumHeight,
      westIndices: E.westIndices,
      southIndices: E.southIndices,
      eastIndices: E.eastIndices,
      northIndices: E.northIndices,
      encodedNormals: E.encodedNormals,
      childTileMask: 0
    });
  }
  async requestTile(i) {
    const e = this.provider;
    let r = e.getTileURL(i.z, i.x, i.y, i), s;
    try {
      const c = e.getFetchOptions(i);
      s = await reFetch(
        r,
        {
          responseType: "arraybuffer",
          ...c
        }
      ).then((l) => l.arrayBuffer());
    } catch {
      console.warn("no tile");
      return;
    }
    return s ? QuantizedMeshTerrainData.createQuantizedMeshTerrainData(e, s) : Promise.reject("Mesh buffer dosen't exist");
  }
  async createMesh(i, e, r) {
    const s = this.provider, a = s._engine.map.map._ellipsoid, c = Rectangle.fromBox(e.geoBoundingBox), l = "createTerrainMesh";
    let h = e.targetCenter;
    const d = {
      type: l,
      tileKey: e.key,
      tileCenter: h,
      minimumHeight: i._minimumHeight,
      maximumHeight: i._maximumHeight,
      quantizedVertices: i._quantizedVertices,
      indices: i._indices,
      westIndices: i._westIndices,
      southIndices: i._southIndices,
      eastIndices: i._eastIndices,
      northIndices: i._northIndices,
      rectangle: c,
      level: e.z,
      ellipsoid: a,
      sourceProjectionName: s.sourceProjection.name,
      targetProjectionName: s.targetProjection.name,
      octEncodedNormals: i._encodedNormals
    };
    if (s.getFetchOptions) {
      const w = s.getFetchOptions(e);
      d.fetchOptions = w;
    }
    if (s.getWorkerOptions) {
      const w = s.getWorkerOptions(e);
      d.workerOptions = w;
    }
    const f = await this._workerTaskScheduler.postMessage(d, [], l + "-" + e.key);
    if (!defined$2(f.content))
      return;
    const p = f.content, m = i._quantizedVertices.length / 3, y = m + i._westIndices.length + i._southIndices.length + i._eastIndices.length + i._northIndices.length, x = IndexDatatype$1.createTypedArray(
      y,
      p.indices
    ), v = new Float32Array(p.vertices), S = p.center, E = p.minimumHeight, b = p.maximumHeight;
    return i._mesh = new TerrainMesh(
      S,
      v,
      x,
      p.indexCountWithoutSkirts,
      m,
      E,
      b,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      p.westIndicesSouthToNorth,
      p.southIndicesEastToWest,
      p.eastIndicesNorthToSouth,
      p.northIndicesWestToEast
    ), i._quantizedVertices = void 0, i._encodedNormals = void 0, i._indices = void 0, i._uValues = void 0, i._vValues = void 0, i._heightValues = void 0, i._westIndices = void 0, i._southIndices = void 0, i._eastIndices = void 0, i._northIndices = void 0, i._mesh;
  }
  postMessageToAll(i, e) {
    this._workerTaskScheduler.postMessageToAll(i, e);
  }
}
function WorkerWrapper$1() {
  return new Worker(getAssetUrl('assets/workers/CesiumTerrainParser.worker-ba35b937.js'), { type: "module" });
}
new Vector3$1();
new Vector3$1();
const upsampleTileKey = new Vector3$1();
class CesiumTerrainTileProvider extends PlaneTerrainTileProvider {
  constructor(e = {}) {
    super(e);
    _(this, "name", "CesiumTerrainTileProvider");
    _(this, "_supportedTargetProjectionNames", [PROJECTION_ECEF, PROJECTION_WEB_MERCATOR, PROJECTION_GEO]);
    _(this, "_url", "https://assets.ion.cesium.com/ap-northeast-1/asset_depot/1/CesiumWorldTerrain/v1.2");
    _(this, "_defaultMaxLevel", 16);
    _(this, "_shouldCheckTileAvailable", !0);
    _(this, "_canUpsample", !0);
    _(this, "_isDefaultCesium", !0);
    this._accessToken = e.accessToken || CesiumConfig.accessToken, this._requestVertexNormals = e.requestVertexNormals || !0, e.url && (this._url = e.url, this._isDefaultCesium = !1);
  }
  initProjectionAndGrid() {
    const e = this._sourceProjection.name;
    e === PROJECTION_WEB_MERCATOR ? this._grid = new WebMercatorGrid(this._engine, this._sourceProjection, this._targetProjection) : e === PROJECTION_GEO && (this._grid = new GeoGrid(this._engine, this._sourceProjection, this._targetProjection));
    const r = this._targetProjection.name;
    let s = null;
    e === PROJECTION_WEB_MERCATOR && r === PROJECTION_WEB_MERCATOR ? s = getProjection(PROJECTION_WEB_MERCATOR) : s = getProjection(PROJECTION_GEO), this.rasterProjection = s, this._grid.rasterProjection = s;
  }
  async _asyncInit() {
    await this._refreshAccessToken();
    let e = null;
    const r = {};
    this._isDefaultCesium && (e = {
      Accept: "application/json",
      Authorization: "Bearer " + this._sessionToken
    }, r.headers = e);
    const s = await reFetch(`${this._url}/layer.json`, r).then((d) => d.json());
    let a = !1, c = !0;
    s.extensions && s.extensions.indexOf("octvertexnormals") !== -1 ? a = !0 : s.extensions && s.extensions.indexOf("vertexnormals") !== -1 && (a = !0, c = !1), this.hasVertexNormals = a && this._requestVertexNormals, this.littleEndianExtensionSize = c, this._layerConfig = s, this._urlTemplate = this._url + "/" + s.tiles[0], this._version = s.version;
    const l = this._availableTiles = s.available;
    this._maxLevel = l.length - 1;
    const h = s.projection || PROJECTION_GEO;
    this._sourceProjection = getProjection(h), this._dataLoader = new AsyncCesiumTerrainDataLoader(this, WorkerWrapper$1, 2);
  }
  async _refreshAccessToken() {
    if (!this._isDefaultCesium)
      return;
    const e = await reFetch(`https://api.cesium.com/v1/assets/1/endpoint?access_token=${this._accessToken}`, {
      headers: {
        Accept: "application/json",
        Authorization: "Bearer " + this._accessToken
      }
    }).then((r) => r.json());
    this._sessionToken = e.accessToken, this._lastRefreshTokenTime = Date.now();
  }
  async _checkAndRefreshAccessToken() {
    !this._isDefaultCesium || Date.now() - this._lastRefreshTokenTime > 3600 * 1e3 && await this._refreshAccessToken();
  }
  getTileURL(e, r, s, a) {
    return this._urlTemplate.replace("{version}", this._version).replace("{z}", this._sourceProjection.name === PROJECTION_GEO ? e - 1 : e).replace("{x}", r).replace("{y}", s);
  }
  getFetchOptions() {
    return this._isDefaultCesium ? {
      headers: {
        Accept: "application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01",
        Authorization: "Bearer " + this._sessionToken
      }
    } : {};
  }
  isTileAvailable(e, r, s) {
    this._sourceProjection.name === PROJECTION_GEO && (e -= 1);
    const a = this._availableTiles;
    if (!a || a.length === 0)
      return;
    if (e >= a.length)
      return !1;
    const c = a[e];
    for (let l = 0, h = c.length; l < h; ++l) {
      const d = c[l];
      if (r >= d.startX && r <= d.endX && s >= d.startY && s <= d.endY)
        return !0;
    }
    return !1;
  }
  async doRequestTileData(e) {
    this._targetProjection.name, await this._checkAndRefreshAccessToken();
    let r, s;
    if (e.needUpSample) {
      const h = e.parentKey.split("-").map((f) => +f);
      upsampleTileKey.set(h[1], h[2], h[0]);
      const d = this._quadtree.getTile(upsampleTileKey.z, upsampleTileKey.x, upsampleTileKey.y);
      r = await this._dataLoader.upsample(
        d.terrainData,
        upsampleTileKey,
        e
      );
    } else
      r = await this._dataLoader.requestTile(e), e.quantizedMesh = r;
    if (e.terrainData = r, r && (s = await this._dataLoader.createMesh(r, e, {})), !s)
      return super.doRequestTileData(e);
    const a = new BufferGeometry(), c = this.hasVertexNormals;
    let l;
    return c ? (l = new InterleavedBuffer(s.vertices, 9), a.setAttribute("normal", new InterleavedBufferAttribute(l, 3, 6))) : l = new InterleavedBuffer(s.vertices, 6), a.setAttribute("position", new InterleavedBufferAttribute(l, 3, 0)), a.setAttribute("uv", new InterleavedBufferAttribute(l, 2, 4)), a.setIndex(new BufferAttribute(s.indices, 1)), a._heights = [s.minimumHeight, s.maximumHeight], a;
  }
}
const _centerIn = new Vector3$1(), _lastPosition = new Vector3$1(), _currentPosition = new Vector3$1(), _lineNormal = new Vector3$1(), _offset = new Vector3$1(), _segmentLines3D = (o, i, e, r, s, a, c, l, h, d, f, p, m, y, x, v) => {
  const S = m.targetCenter, E = m.targetProjection, { sourceProjectionName: b, targetProjectionName: w } = m;
  let M = 0;
  _centerIn.fromArray(S), _lastPosition.fromArray(c), _currentPosition.fromArray(l);
  let P = p.value;
  s.push(P, P), a.push(
    P,
    1,
    P,
    0
  );
  const D = E.getProjectedSurfaceNormal(_lastPosition, _lineNormal), L = _offset.copy(_currentPosition).sub(_lastPosition), O = _lineNormal.crossVectors(D, L).normalize();
  b !== w && (_lastPosition.sub(_centerIn), _currentPosition.sub(_centerIn)), e.push(O.x, O.y, O.z, -O.x, -O.y, -O.z), o.push(
    _lastPosition.x,
    _lastPosition.y,
    _lastPosition.z,
    _lastPosition.x,
    _lastPosition.y,
    _lastPosition.z
  ), i.push(h, h), M += 2, f || (r.push(d + 0 - 2, d + 1 - 2, d + 2 - 2), r.push(d + 2 - 2, d + 1 - 2, d + 3 - 2)), r.push(d, d + 1, d + 2), e.push(O.x, O.y, O.z, -O.x, -O.y, -O.z), o.push(
    _currentPosition.x,
    _currentPosition.y,
    _currentPosition.z,
    _currentPosition.x,
    _currentPosition.y,
    _currentPosition.z
  ), i.push(h, h);
  const F = x && v ? getDistance(x, v) : getDistance(c, l);
  return P += F / y, s.push(P, P), a.push(
    P,
    1,
    P,
    0
  ), p.value = P, M += 2, r.push(d + 2, d + 1, d + 3), M;
};
function lineToMesh(o, i, e, r, s = 1, a) {
  let c = o;
  if (!Array.isArray(o[0])) {
    c = [];
    for (let D = 0; D < o.length; D += 3)
      c.push([o[D], o[D + 1], o[D + 2]]);
  }
  let h = 0, d = null, f = null, p = null;
  const m = [], y = [], x = [], v = [], S = [], E = [];
  let b;
  const w = { value: 0 }, M = a || c;
  let P = !0;
  for (let D = 1, L = c.length - 1; D <= L; D++) {
    d = p || c[D - 1], f = c[D];
    const O = p ? a ? a[c.indexOf(p)] : p : M[D - 1], F = M[D], k = M[D + 1];
    if (k && isPointEqual(F, k)) {
      p = d;
      continue;
    }
    let V = 0;
    V = _segmentLines3D(
      m,
      v,
      y,
      x,
      S,
      E,
      d,
      f,
      i,
      h,
      P,
      w,
      e,
      s,
      O,
      F
    ), V !== -1 && (h += V, p = null), P = !1;
  }
  for (let D = 0; D < E.length; D++)
    D % 2 === 0 && (E[D] = w.value - E[D]);
  return r && (b = new Array(S.length).fill(w.value)), {
    vertices: m,
    indices: x,
    normals: y,
    widths: v,
    lengths: S,
    totalLengths: b,
    uvs: E
  };
}
function fillFlatArray(o, i, e) {
  e || (e = i.length);
  const r = e * o, s = new Array(r);
  for (let a = 0, c = r - e + 1; a < c; a += e)
    for (let l = 0; l < e; l++)
      s[a + l] = i[l];
  return s;
}
const arrFeatureStyles = [
  [2, "rgba(79,210,125,1)", 2, 2, 0, [], 0, 0],
  [2, "rgba(79,210,125,1)", 3, 2, 0, [], 0, 0],
  [2, "rgba(79,210,125,1)", 3, 2, 0, [], 0, 0],
  [2, "rgba(79,210,125,1)", 5, 2, 0, [], 0, 0],
  [2, "rgba(79,210,125,1)", 6, 2, 0, [], 0, 0],
  [2, "rgba(255,208,69,1)", 2, 2, 0, [], 0, 0],
  [2, "rgba(255,208,69,1)", 3, 2, 0, [], 0, 0],
  [2, "rgba(255,208,69,1)", 3, 2, 0, [], 0, 0],
  [2, "rgba(255,208,69,1)", 5, 2, 0, [], 0, 0],
  [2, "rgba(255,208,69,1)", 6, 2, 0, [], 0, 0],
  [2, "rgba(232,14,14,1)", 2, 2, 0, [], 0, 0],
  [2, "rgba(232,14,14,1)", 3, 2, 0, [], 0, 0],
  [2, "rgba(232,14,14,1)", 3, 2, 0, [], 0, 0],
  [2, "rgba(232,14,14,1)", 5, 2, 0, [], 0, 0],
  [2, "rgba(232,14,14,1)", 6, 2, 0, [], 0, 0],
  [2, "rgba(181,0,0,1)", 2, 2, 0, [], 0, 0],
  [2, "rgba(181,0,0,1)", 3, 2, 0, [], 0, 0],
  [2, "rgba(181,0,0,1)", 3, 2, 0, [], 0, 0],
  [2, "rgba(181,0,0,1)", 5, 2, 0, [], 0, 0],
  [2, "rgba(181,0,0,1)", 6, 2, 0, [], 0, 0],
  [2, "rgba(255,255,255,1)", 4, 0, 0, [], 0, 0],
  [2, "rgba(255,255,255,1)", 5.5, 0, 0, [], 0, 0],
  [2, "rgba(255,255,255,1)", 7, 0, 0, [], 0, 0],
  [2, "rgba(255,255,255,1)", 8.5, 0, 0, [], 0, 0],
  [2, "rgba(255,255,255,1)", 10, 0, 0, [], 0, 0]
];
arrFeatureStyles[404] = [2, "rgba(204,204,204,1)", 2, 2, 0, [], 0, 0];
arrFeatureStyles[405] = [2, "rgba(204,204,204,1)", 3, 2, 0, [], 0, 0];
arrFeatureStyles[406] = [2, "rgba(204,204,204,1)", 4, 2, 0, [], 0, 0];
arrFeatureStyles[407] = [2, "rgba(204,204,204,1)", 5, 2, 0, [], 0, 0];
arrFeatureStyles[408] = [2, "rgba(204,204,204,1)", 6, 2, 0, [], 0, 0];
const trafficDataLoader = {
  requestTile: async (o, i) => {
    const e = o.getTileURL(i.z, i.x, i.y, i), r = {
      type: "requestTile",
      tileKey: i.key,
      sourceProjectionName: o.sourceProjection.name,
      targetProjectionName: o.targetProjection.name,
      projectedBoundingBox: _boxToArray(i.projectedBoundingBox),
      geoBoundingBox: _boxToArray(i.geoBoundingBox),
      projectedCenter: _vectorToArray(i.projectedCenter),
      targetCenter: _vectorToArray(i.targetCenter),
      id: i.id,
      x: i.x,
      y: i.y,
      z: i.z,
      reverseY: i.reverseY,
      url: e,
      timeStart: performance.now(),
      sourceCoordType: o.sourceCoordType || void 0,
      targetCoordType: o.targetCoordType || void 0
    };
    if (o.getWorkerOptions) {
      const a = o.getWorkerOptions(i);
      r.workerOptions = a;
    }
    return await handleRequestTile(r);
  }
};
async function handleRequestTile(o) {
  const {
    tileKey: i,
    workerOptions: e,
    url: r,
    sourceProjectionName: s,
    targetProjectionName: a
  } = o;
  o.sourceProjection = getProjection(s), o.targetProjection = getProjection(a);
  const c = a === PROJECTION_WEB_MERCATOR && s === PROJECTION_WEB_MERCATOR;
  o.isNormalized = c;
  for (const d in e)
    if (Object.hasOwnProperty.call(e, d)) {
      const f = e[d];
      trafficDataLoader[d] = f;
    }
  let l = await jsonp(r, {}, {
    jsonp: "fn"
  }), h = null;
  try {
    const d = parseData(l, o);
    h = mergePrimitives(d);
  } catch (d) {
    console.warn(d);
  }
  return {
    type: "responseTile",
    tileKey: i,
    content: {
      data: h
    },
    isNormalized: c
  };
}
function parseData(o, i) {
  i.targetProjectionName;
  const e = [];
  let r = [], s = 10;
  o.error === 0 ? (r = o.content && o.content.tf, o.precision && typeof o.precision == "number" && (s *= o.precision)) : o.status === 0 && (r = o.result.trafficData);
  for (let a = 0; a < r.length; a++) {
    let c = r[a][1], l = 0, h = 0, d = arrFeatureStyles[Math.max(0, r[a][3])];
    if (!d)
      continue;
    let f = [];
    trafficDataLoader.colors && trafficDataLoader.colors[Math.floor(r[a][3] / 5)] ? f = colorToArr4(trafficDataLoader.colors[Math.floor(r[a][3] / 5)]) : f = colorToArr4(d[1]);
    let p = trafficDataLoader.lineWidth || d[2], m = [];
    for (let x = 0, v = c.length; x < v / 2; x++)
      l += c[x * 2] / s, h += c[x * 2 + 1] / s, m.push([l / 256 - 0.5, 0.5 - h / 256, 0]);
    projectVertices(m, i, !1, !1);
    const y = lineToMesh(m, p, i);
    y.colors = fillFlatArray(y.vertices.length / 3, [f[0], f[1], f[2], 1]), y.layerIndices = fillFlatArray(y.vertices.length / 3, [1]), e.push(y);
  }
  return e;
}
function mergePrimitives(o) {
  const i = [], e = [];
  let r = null, s = null, a = null, c = null, l = null, h = null, d = null, f = 0, p = 0;
  for (let m = 0; m < o.length; m++)
    if (r = o[m], s = r.vertices, a = r.normals, c = r.indices, l = r.colors, h = r.widths, d = r.layerIndices, !(!c || !c.length)) {
      for (let y = 0, x = s.length - 2; y < x; y += 3)
        i.push(s[y], s[y + 1], s[y + 2]), i.push(a[y], a[y + 1], a[y + 2]), f = y / 3 * 4, i.push(
          l[f],
          l[f + 1],
          l[f + 2],
          l[f + 3]
        ), i.push(h[y / 3]), i.push(d[y / 3]);
      for (let y = 0, x = c.length; y < x; y++)
        e.push(c[y] + p);
      p += s.length / 3;
    }
  return {
    attributes: new Float32Array(i),
    indices: new Uint32Array(e)
  };
}
function _boxToArray(o) {
  return [o.min.x, o.min.y, o.min.z, o.max.x, o.max.y, o.max.z];
}
function _vectorToArray(o) {
  return [o.x, o.y, o.z];
}
class BaiduTrafficTileProvider extends VectorTileProvider {
  constructor(e = {}) {
    super(e);
    _(this, "name", "BaiduTrafficTileProvider");
    _(this, "isBaiduProvider", !0);
    _(this, "_supportAllProjections", !0);
    _(this, "_defaultStartLevel", 2);
    _(this, "_defaultMaxLevel", 16);
    this._options = e, this._url = e.url, this.params = e.params, this._isOffline = e.isOffline, this._autoRefresh = defaultValue$1(e.autoRefresh, !0), this._refreshInterval = defaultValue$1(e.refreshInterval, 6e4), this._refreshTimer = null, this._isOffline ? (this._sourceProjectionName = defaultValue$1(e.projection, PROJECTION_WEB_MERCATOR), this._isWebMercator = this._sourceProjectionName === PROJECTION_WEB_MERCATOR) : (this._sourceProjectionName = PROJECTION_BD_MERCATOR, this._isWebMercator = !1), this._isWebMercator ? (this._defaultMinLevel = 2, this._defaultMaxLevel = 16) : (this._defaultMinLevel = 3, this._defaultMaxLevel = 19);
  }
  async _asyncInit() {
    this.refreshInterval = this._refreshInterval;
  }
  initProjectionAndGrid() {
    this._sourceProjection = getProjection(this._sourceProjectionName), this._sourceProjectionName === PROJECTION_BD_MERCATOR ? this._grid = new BaiduImageryGrid(this._engine, this._sourceProjection, this._targetProjection) : this._grid = new WebMercatorGrid(this._engine, this._sourceProjection, this._targetProjection);
  }
  getTileURL(e, r, s, a) {
    return this._isOffline ? this._getOfflineTileURL(e, r, s, a) : this._getOnlineTileURL(e, r, s, a);
  }
  _getOnlineTileURL(e, r, s, a) {
    const [c, l, h] = a.grid.getRasterTileCoord(e, r, s);
    let d = `https://traffic.map.baidu.com/traffic/?qt=vtraffic&z=${c}&x=${l}&y=${h}&udt=20250717`;
    if (this.params) {
      const f = Object.entries(this.params).map(([p, m]) => `${encodeURIComponent(p)}=${encodeURIComponent(m)}`).join("&");
      d += `&${f}`;
    }
    return d;
  }
  _getOfflineTileURL(e, r, s, a) {
    let c = e, l = r, h = a.reverseY;
    this._isWebMercator || ([c, l, h] = a.grid.getRasterTileCoord(e, r, s));
    let d = `http://10.27.57.8:8837/traffic/v1/traffic/?qt=traffic&z=${c}&x=${l}&y=${h}&udt=20190618&ApiAuthorization=USER_AK`;
    if (this._url ? d = `${this._url}/traffic/?qt=traffic&z=${c}&x=${l}&y=${h}&udt=20190618&ApiAuthorization=USER_AK` : window.BMAPGL_URL && window.TRAFFIC_URL && (d = `${window.TRAFFIC_URL}/traffic/?qt=traffic&z=${c}&x=${l}&y=${h}&udt=20190618&ApiAuthorization=USER_AK`), d += "&yanpanIds=&geoproIds=", this.params) {
      const f = Object.entries(this.params).map(([p, m]) => `${encodeURIComponent(p)}=${encodeURIComponent(m)}`).join("&");
      d += `&${f}`;
    }
    return d;
  }
  getWorkerOptions() {
    return {
      colors: this._options.colors,
      lineWidth: this._options.lineWidth
    };
  }
  async doRequestVectorTileData(e) {
    let r = await trafficDataLoader.requestTile(this, e);
    const s = r.isNormalized, {
      data: a
    } = r.content, {
      attributes: c,
      indices: l
    } = a, h = new Group(), d = new Group(), f = new BufferGeometry(), p = new InterleavedBuffer(c, 12);
    f.setAttribute("position", new InterleavedBufferAttribute(p, 3, 0)), f.setAttribute("normal", new InterleavedBufferAttribute(p, 3, 3)), f.setAttribute("aColor", new InterleavedBufferAttribute(p, 4, 6)), f.setAttribute("aWidth", new InterleavedBufferAttribute(p, 1, 10)), f.setAttribute("layerIndex", new InterleavedBufferAttribute(p, 1, 11)), f.setIndex(new BufferAttribute(l, 1));
    const m = new FatLineMaterial({
      transparent: !0,
      lineWidth: 4,
      vertexColors: !0,
      keepSize: !0,
      vertexZIndexLegacy: !0,
      enableDepthRange: !0
    });
    m.setCommonUniforms(this._engine.rendering.uniforms);
    const y = new Mesh(f, m);
    return d.add(y), s ? (e.projectedBoundingBox.getSize(h.scale), h.scale.z = 1, d.scale.copy(h.scale), h.position.copy(e.targetCenter), d.position.copy(e.targetCenter)) : (h.position.copy(e.targetCenter), d.position.copy(e.targetCenter)), [h, d];
  }
  _startAutoRefresh() {
    this._refreshTimer && this._stopAutoRefresh(), this._refreshTimer = setInterval(() => {
      this._needsClearCache = !0, this._engine.requestRender && this._engine.requestRender();
    }, this._refreshInterval);
  }
  _stopAutoRefresh() {
    this._refreshTimer && (clearInterval(this._refreshTimer), this._refreshTimer = null);
  }
  get autoRefresh() {
    return this._autoRefresh;
  }
  set autoRefresh(e) {
    this._autoRefresh !== e && (this._autoRefresh = e, e ? this._startAutoRefresh() : this._stopAutoRefresh());
  }
  get refreshInterval() {
    return this._refreshInterval;
  }
  set refreshInterval(e) {
    e < 6e4 && (e = 6e4), this._refreshInterval = e, this._autoRefresh && this._startAutoRefresh();
  }
  dispose() {
    this._stopAutoRefresh();
  }
  onTileDispose(e) {
  }
}
function WorkerWrapper() {
  return new Worker(getAssetUrl('assets/workers/MVTParser.worker-bb80e3b4.js'), { type: "module" });
}
const mapboxBaseUrl = "https://api.mapbox.com";
function getMapboxPath(o) {
  const i = "mapbox://";
  return o.indexOf(i) !== 0 ? "" : o.slice(i.length);
}
function getMapvThreeMvtPath(o, i) {
  const e = "mapvthree://";
  return o.indexOf(e) !== 0 ? "" : o.replace(e, i);
}
function normalizeStyleUrl(o, i) {
  const e = getMapboxPath(o);
  if (!e)
    return decodeURI(o);
  const r = "styles/";
  if (e.indexOf(r) !== 0)
    throw new Error(`unexpected style url: ${o}`);
  const s = e.slice(r.length);
  return `${mapboxBaseUrl}/styles/v1/${s}?&access_token=${i}`;
}
function normalizeSpriteUrl(o, i, e) {
  const r = getMapboxPath(o);
  if (!r)
    return decodeURI(new URL(o, e).href);
  const s = "sprites/";
  if (r.indexOf(s) !== 0)
    throw new Error(`unexpected sprites url: ${o}`);
  const a = r.slice(s.length);
  return `${mapboxBaseUrl}/styles/v1/${a}/sprite?access_token=${i}`;
}
function normalizeSourceUrl(o, i, e = "access_token", r) {
  const s = new URL(o, r), a = getMapboxPath(o);
  if (!a)
    return i && s.searchParams.set(e, i), decodeURI(s.href);
  if (a === "mapbox.satellite") {
    const c = window.devicePixelRatio >= 1.5 ? "@2x" : "";
    return `https://api.mapbox.com/v4/${a}/{z}/{x}/{y}${c}.webp?access_token=${i}`;
  }
  return `https://api.mapbox.com/v4/${a}/{z}/{x}/{y}.vector.pbf?access_token=${i}`;
}
function assert(o) {
  if (!o)
    throw new Error("The expression evaluated to a falsy value");
}
class Sprite {
  constructor(i, e) {
    _(this, "_spriteUrl");
    _(this, "_accessToken");
    _(this, "_channels", 4);
    this._spriteUrl = i, this._accessToken = e;
  }
  loadSpriteData() {
    return Promise.all([this._loadSpriteJson(), this._loadSpriteImage()]).then(
      ([i, e]) => (this._generateIconUv(i, e), {
        data: i,
        image: e
      })
    );
  }
  _getSpriteUrlObj() {
    const i = new URL(normalizeSpriteUrl(this._spriteUrl, this._accessToken)), e = window.devicePixelRatio >= 1.5 ? "@2x" : "";
    return i.sizeFactor = e, i;
  }
  _loadSpriteJson() {
    const { origin: i, pathname: e, search: r, sizeFactor: s } = this._getSpriteUrlObj(), a = i + e + s + ".json" + r;
    return reFetch(a).then((c) => c.json());
  }
  _loadSpriteImage() {
    const { origin: i, pathname: e, search: r, sizeFactor: s } = this._getSpriteUrlObj(), a = i + e + s + ".png" + r;
    return new Promise((c, l) => {
      const h = new Image();
      h.src = a, h.crossOrigin = "Anonymous", h.onload = function() {
        c(h);
      }, h.onerror = function(d) {
        l(d);
      };
    });
  }
  _generateIconUv(i, e) {
    for (const r in i) {
      const s = i[r], a = s.x / e.width, c = s.y / e.height, l = (s.x + s.width) / e.width, h = (s.y + s.height) / e.height, d = new Float32Array([
        a,
        h,
        a,
        c,
        l,
        c,
        l,
        h
      ]);
      s.uvs = d;
    }
    return i;
  }
  _generateSpriteData(i, e) {
    const r = {};
    for (const s in i) {
      const { width: a, height: c, x: l, y: h, sdf: d, pixelRatio: f, stretchX: p, stretchY: m, content: y } = i[s], x = {
        width: a,
        height: c,
        data: new Uint8Array(a * c * this._channels)
      };
      this._copyImage(e, x, { x: l, y: h }, { width: a, height: c }), r[s] = {
        width: a,
        height: c,
        data: x.data,
        sdf: d,
        pixelRatio: f,
        stretchX: p,
        stretchY: m,
        content: y
      };
    }
    return r;
  }
  _copyImage(i, e, r, s) {
    if (s.width === 0 || s.height === 0)
      return e;
    if (s.width > i.width || s.height > i.height || r.x > i.width - s.width || r.y > i.height - s.height)
      throw new RangeError("out of range source coordinates for image copy");
    if (s.width > e.width || s.height > e.height || 0 > e.width - s.width || 0 > e.height - s.height)
      throw new RangeError("out of range destination coordinates for image copy");
    const a = i.data, c = e.data;
    assert(a !== c);
    for (let l = 0; l < s.height; l++) {
      const h = ((r.y + l) * i.width + r.x) * this._channels, d = ((0 + l) * e.width + 0) * this._channels;
      for (let f = 0; f < s.width * this._channels; f++)
        c[d + f] = a[h + f];
    }
    return e;
  }
  _getImageData(i) {
    const e = document.createElement("canvas");
    e.width = i.width, e.height = i.height;
    const r = e.getContext("2d");
    return r.drawImage(i, 0, 0), r.getImageData(0, 0, e.width, e.height);
  }
}
const vertexShader$h = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif

#include <normal_pars_vertex>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>

#if defined(MVT_USE_EXTENT_CLIP) && !defined(MVT_USE_UV_CLIP)
    attribute vec2 extentVertex;
    varying vec2 vExtentVertex;
#endif

#ifdef MVT_USE_VERTEX_ZINDEX_LEGACY
    attribute float layerIndex;
    varying float vLayerIndex;
#endif

#ifdef IS_PATTERN
    attribute vec4 patternImage;
    varying vec4 vPatternImage;
#endif

varying vec2 vUv;

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = color;
    #endif

    #ifdef IS_PATTERN
        vPatternImage = patternImage;
    #endif

    #include <begin_vertex>
    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);

    vec4 mvPosition = viewMatrix * worldPosition;
    gl_Position = projectionMatrix * mvPosition;

    #ifdef MVT_USE_VERTEX_ZINDEX_LEGACY
        vLayerIndex = layerIndex;
    #endif

    vUv = uv;

    #if defined(MVT_USE_EXTENT_CLIP) && !defined(MVT_USE_UV_CLIP)
        vExtentVertex = extentVertex;
    #endif
    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <fog_vertex>
    #include <shadowmap_vertex>
    #include <logdepthbuf_vertex>

}

`, fragmentShader$f = `#define GLSLIFY 1
#include <common>
#include <fog_pars_fragment>

#ifdef MVT_USE_VERTEX_COLOR
varying vec4 vColor;
#else
uniform vec3 color;
#endif
uniform float opacity;
varying vec2 vUv;

#ifdef IS_PATTERN
uniform sampler2D patternMap;
varying vec4 vPatternImage;
#endif

#if defined(MVT_USE_EXTENT_CLIP) && !defined(MVT_USE_UV_CLIP)
varying vec2 vExtentVertex;
#endif

#include <mvt_depth_range_pars_fragment>

#include <packing>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {

    #ifdef MVT_USE_EXTENT_CLIP
        #ifdef MVT_USE_UV_CLIP
            if (vUv.x < 0.0 || vUv.x > 1.0 || vUv.y < 0.0 || vUv.y > 1.0) {
                discard;
            }
        #else
            if (vExtentVertex.x < 0.0 || vExtentVertex.x > 1.0 || vExtentVertex.y < 0.0 || vExtentVertex.y > 1.0) {
                discard;
            }
        #endif
    #endif

    vec4 diffuseColor = vec4(0.0);
    #ifdef MVT_USE_VERTEX_COLOR
    diffuseColor = vColor;
    #else
    diffuseColor = vec4(color, 1.0);
    #endif

    diffuseColor.a *= opacity;
    if (diffuseColor.a <= 0.) {
        discard;
    }

    #if ( NUM_DIR_LIGHTS > 0 )
        // \u6839\u636E\u65B9\u5411\u5149\u7684\u65B9\u5411\u4E0E\u6CD5\u5411\uFF0C\u6765\u8BA1\u7B97\u989C\u8272\u8870\u51CF\u7A0B\u5EA6\uFF0C\u503C\u8303\u56F4\u4E3A-1~1\uFF0C\u7ED9\u91CD\u6620\u5C04\u52300~1\u7684\u8303\u56F4
    float normalLightIntensity = dot(vNormal, directionalLights[0].direction) * getShadowMask();
    gl_FragColor = vec4(diffuseColor.rgb * (normalLightIntensity / 2.0 + 0.5), diffuseColor.a);
    #else 
    gl_FragColor = diffuseColor;
    #endif

    #ifdef OPAQUE
    gl_FragColor.a = 1.0;
    #endif

    #ifdef IS_PATTERN
    vec2 patternUv = vec2(vPatternImage.x + mod(vUv.x, vPatternImage.z), vPatternImage.y + mod(vUv.y, vPatternImage.w));
    gl_FragColor = texture2D(patternMap, patternUv);
    #endif

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>

    #include <mvt_depth_range_fragment>
}

`, uniforms$i = UniformsUtils.merge([
  UniformsLib.fog,
  UniformsLib.lights,
  {
    opacity: { value: 1 },
    uColor: { value: [0, 1, 1] },
    vertexColors: { value: !1 },
    vertexZIndexLegacy: { value: !1 },
    isEmissive: { value: !1 },
    depthRange: { value: new Vector2$1(0, 1) },
    patternMap: { value: null }
  }
]);
class MVTMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "MVTMaterial", this.type = "MVTMaterial", this.isMVTMaterial = !0, this.lights = !0, this.fog = !0, this.fragmentShader = fragmentShader$f, this.vertexShader = vertexShader$h, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$i)), defineMaterialNormalProperties(this, [
      "opacity",
      "isEmissive",
      "depthRange",
      "patternMap"
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexZIndexLegacy", "MVT_USE_VERTEX_ZINDEX_LEGACY"],
      ["enableDepthRange", "MVT_USE_DEPTH_RANGE"],
      ["enableExtentClip", "MVT_USE_EXTENT_CLIP"],
      ["useUVClip", "MVT_USE_UV_CLIP"],
      ["isPattern", "IS_PATTERN"]
    ]), this.useUVClip = !0, this.setValues(i);
  }
}
const getPixelSize$1 = (o, i, e) => 0.2 * Math.tan(i / 2) * o / e;
class MapboxVectorTileProvider extends VectorTileProvider {
  constructor(e = {}) {
    super(e);
    _(this, "name", "MapboxVectorTileProvider");
    _(this, "_shouldRenderPlaceholder", !0);
    _(this, "_placeholderColor", new Color(0.8663865327835083, 0.8170174360275269, 0.7507214546203613));
    _(this, "_defaultStartLevel", 0);
    _(this, "_defaultMaxLevel", 18);
    _(this, "_lodScaleFactor", 0.4);
    _(this, "_defaultMaterials", {});
    _(this, "_symbols", {});
    _(this, "_materialManager", null);
    _(this, "_useWebMeractorProjectionAndGrid", !0);
    _(this, "_supportAllProjections", !0);
    this._style = e.style || "mapbox://styles/mapbox/streets-v11", this._accessToken = e.accessToken || MapboxConfig.accessToken, this._defaultStyle = e.defaultStyle, this._dispalyOptions = e.displayOptions || {}, this._options = e;
  }
  async _asyncInit() {
    this._dataLoader || (this._dataLoader = new AsyncDataTileLoader(this, WorkerWrapper, 2)), await this._loadStyle();
  }
  async _loadStyle() {
    try {
      if (typeof this._style == "string" && this._style.endsWith(".json")) {
        const d = this._style.lastIndexOf("/", this._style.lastIndexOf(".json"));
        this._stylePath = this._style.slice(0, d + 1);
      }
      const [e, r] = await this._getStyleJSON();
      if (e.version !== 8)
        throw new Error("mapbox style version 8 required");
      let s, a = e.layers.length;
      for (let d = 0; d < a; d++) {
        const f = e.layers[d];
        if (s && f.source !== s) {
          console.warn(
            "only support one source, the first source will be used,you can use mapbox studio to merge multiple sources into oneor add multiple mvt layer to the map"
          );
          break;
        }
        s = f.source;
      }
      const c = e.sources[s];
      if (c.type !== "vector")
        throw new Error("only support vector source");
      const l = await this._getTileJson(c);
      let h = e.sprite;
      if (h && h.startsWith("mapvthree://") && (h = getMapvThreeMvtPath(h, this._stylePath)), this._sourceUrl = l.tiles[0], this._sourceUrl.startsWith("mapvthree://") && (this._sourceUrl = getMapvThreeMvtPath(this._sourceUrl, this._stylePath)), this._styleJSON = e, this._defaultStyleJSON = r, h) {
        const f = await new Sprite(h, this._accessToken).loadSpriteData();
        this._spriteData = f.data, this._spriteImage = f.image, this.spriteTexture = new Texture(this._spriteImage), this.spriteTexture.generateMipmaps = !1, this.spriteTexture.colorSpace = SRGBColorSpace, this.spriteTexture.needsUpdate = !0, this._ready = !0;
      } else
        this._ready = !0;
      this._ready && this._dataLoader.postMessageToAll({
        type: "changeStyle",
        styleJSON: this._styleJSON,
        defaultStyleJSON: this._defaultStyleJSON,
        spriteData: this._spriteData
      });
    } catch (e) {
      console.warn(e);
    }
  }
  _getTileJson(e) {
    const r = e.url;
    let s;
    if (r && !e.tiles) {
      const a = normalizeSourceUrl(r, this._accessToken);
      if (r.startsWith("mapbox://"))
        s = Promise.resolve({
          tiles: [a]
        });
      else if (r.startsWith("mapvthree://")) {
        const c = getMapvThreeMvtPath(a, this._stylePath);
        s = reFetch(c).then((l) => l.json()).then((l) => Promise.resolve(l));
      } else
        s = reFetch(a).then((c) => c.json()).then((c) => Promise.resolve(c));
    } else
      s = Promise.resolve(e);
    return s;
  }
  _getStyleJSON() {
    const e = [];
    if (typeof this._style == "object")
      e.push(Promise.resolve(this._style));
    else {
      const r = normalizeStyleUrl(this._style, this._accessToken), s = reFetch(r).then((a) => a.json());
      e.push(s);
    }
    if (this._defaultStyle)
      if (typeof this._defaultStyle == "object")
        e.push(Promise.resolve(this._defaultStyle));
      else {
        const r = reFetch(this._defaultStyle).then((s) => s.json());
        e.push(r);
      }
    else {
      const r = reFetch(getAssetUrl("assets/map/mapbox/v8.json")).then((s) => s.json());
      e.push(r);
    }
    return Promise.all(e);
  }
  getTileURL(e, r, s, a) {
    return this._sourceUrl.replace("{z}", e).replace("{x}", r).replace("{y}", a.reverseY);
  }
  getWorkerOptions() {
    return {
      displayOptions: this._options.displayOptions
    };
  }
  async doRequestVectorTileData(e) {
    const s = (await this._dataLoader.requestTile(e)).content, a = new Object3D(), c = new Vector3$1(), l = [
      "background",
      "fill_opaque",
      "fill_pattern",
      "fill_water",
      "fill_wood",
      "fill_translucent",
      "fill_extrusion_opaque",
      "fill_extrusion_translucent",
      "line_opaque",
      "line_translucent",
      "line_dashed",
      "symbol"
    ], h = new Object3D();
    for (const d of l)
      if (this._hasBufferData(s[d])) {
        let f;
        switch (d) {
          case "background":
            f = this._getBackgroundMesh(s[d], d);
            break;
          case "fill_opaque":
          case "fill_water":
          case "fill_wood":
            f = this._getFillOpaqueMesh(s[d], d);
            break;
          case "fill_pattern":
            f = this._getFillPatternMesh(s[d], d);
            break;
          case "fill_translucent":
            f = this._getFillTranslucentMesh(s[d], d);
            break;
          case "line_opaque":
            f = this._getLineOpaqueMesh(s[d], d);
            break;
          case "line_translucent":
            f = this._getLineTranslucentMesh(s[d], d);
            break;
          case "line_dashed":
            f = this._getLineDashedMesh(s[d], d, c, e);
            break;
          case "fill_extrusion_opaque":
            f = this._getExtrusionOpaqueMesh(
              s[d],
              d
            );
            break;
          case "fill_extrusion_translucent":
            f = this._getExtrusionTranslucentMesh(
              s[d],
              d
            );
            break;
          case "symbol":
            this._setupSymbolData(s[d], a);
            continue;
          default:
            throw new Error(`Unknown mesh type: ${d}`);
        }
        f.material.enableDepthRange ? h.add(f) : a.add(f);
      }
    return this.targetProjection.name === this.sourceProjection.name && (e.targetBoundingBox.getSize(a.scale), a.scale.z = 1, h.scale.copy(a.scale)), a.position.copy(e.targetCenter), h.position.copy(e.targetCenter), [a, h];
  }
  cancelTiles(e) {
    this._dataLoader && this._dataLoader.cancelTiles && this._dataLoader.cancelTiles(e);
  }
  _hasBufferData(e) {
    const r = e && e.vertices && e.vertices.length > 0, s = e && e.symbols && e.symbols.length > 0;
    return r || s;
  }
  _getBackgroundMesh(e, r) {
    const { colors: s, vertices: a, uvs: c, indices: l, normals: h, layerIndices: d } = e, f = new BufferGeometry();
    f.setAttribute("position", new BufferAttribute(a, 3)), f.setAttribute("uv", new BufferAttribute(c, 2)), f.setAttribute("color", new BufferAttribute(s, 4)), f.setAttribute("normal", new BufferAttribute(h, 3)), f.setAttribute("layerIndex", new BufferAttribute(d, 1)), f.setIndex(new BufferAttribute(l, 1));
    const p = this._getMaterial(r), m = new Mesh(f, p);
    return m.name = "MVTBackground", m.renderOrder = -102, m.raycast = () => {
    }, m;
  }
  _getFillOpaqueMesh(e, r) {
    const { colors: s, vertices: a, uvs: c, indices: l, normals: h, layerIndices: d } = e, f = new BufferGeometry();
    f.setAttribute("position", new BufferAttribute(a, 3)), f.setAttribute("uv", new BufferAttribute(c, 2)), f.setAttribute("color", new BufferAttribute(s, 4)), f.setAttribute("normal", new BufferAttribute(h, 3)), f.setAttribute("layerIndex", new BufferAttribute(d, 1)), f.setIndex(new BufferAttribute(l, 1));
    const p = this._getMaterial(r), m = new Mesh(f, p);
    return m.name = "MVTFillOpaque", m.renderOrder = -101, m.raycast = () => {
    }, m;
  }
  _getFillPatternMesh(e, r) {
    const { colors: s, vertices: a, uvs: c, indices: l, normals: h, layerIndices: d, icons: f } = e, p = new BufferGeometry();
    p.setAttribute("position", new BufferAttribute(a, 3)), p.setAttribute("uv", new BufferAttribute(c, 2)), p.setAttribute("color", new BufferAttribute(s, 4)), p.setAttribute("normal", new BufferAttribute(h, 3)), p.setAttribute("layerIndex", new BufferAttribute(d, 1)), p.setAttribute("patternImage", new BufferAttribute(f, 4)), p.setIndex(new BufferAttribute(l, 1));
    const m = this._getMaterial(r), y = new Mesh(p, m);
    return y.name = "MVTFillPattern", y.renderOrder = -101, y.raycast = () => {
    }, y;
  }
  _getFillTranslucentMesh(e, r) {
    const { colors: s, vertices: a, uvs: c, indices: l, normals: h, layerIndices: d } = e, f = new BufferGeometry();
    f.setAttribute("position", new BufferAttribute(a, 3)), f.setAttribute("uv", new BufferAttribute(c, 2)), f.setAttribute("color", new BufferAttribute(s, 4)), f.setAttribute("normal", new BufferAttribute(h, 3)), f.setAttribute("layerIndex", new BufferAttribute(d, 1)), f.setIndex(new BufferAttribute(l, 1));
    const p = this._getMaterial(r), m = new Mesh(f, p);
    return m.name = "MVTFillTranslucent", m.renderOrder = -101, m.raycast = () => {
    }, m;
  }
  _getLineOpaqueMesh(e, r) {
    const { colors: s, vertices: a, normals: c, indices: l, widths: h, layerIndices: d, extentVertices: f } = e, p = new BufferGeometry();
    p.setAttribute("position", new BufferAttribute(a, 3)), p.setAttribute("aColor", new BufferAttribute(s, 4)), p.setAttribute("normal", new BufferAttribute(c, 3)), p.setAttribute("aWidth", new BufferAttribute(h, 1)), p.setAttribute("layerIndex", new BufferAttribute(d, 1)), p.setAttribute("extentVertex", new BufferAttribute(f, 2)), p.setIndex(new BufferAttribute(l, 1));
    const m = this._getMaterial(r), y = new Mesh(p, m);
    return y.name = "MVTLineOpaque", y.renderOrder = -100, y.raycast = () => {
    }, y;
  }
  _getLineTranslucentMesh(e, r) {
    const { colors: s, vertices: a, normals: c, indices: l, widths: h, layerIndices: d, extentVertices: f } = e, p = new BufferGeometry();
    p.setAttribute("position", new BufferAttribute(a, 3)), p.setAttribute("aColor", new BufferAttribute(s, 4)), p.setAttribute("normal", new BufferAttribute(c, 3)), p.setAttribute("aWidth", new BufferAttribute(h, 1)), p.setAttribute("layerIndex", new BufferAttribute(d, 1)), p.setAttribute("extentVertex", new BufferAttribute(f, 2)), p.setIndex(new BufferAttribute(l, 1));
    const m = this._getMaterial(r), y = new Mesh(p, m);
    return y.name = "MVTLineTranslucent", y.renderOrder = -100, y.raycast = () => {
    }, y;
  }
  _getLineDashedMesh(e, r, s, a) {
    const {
      colors: c,
      vertices: l,
      normals: h,
      indices: d,
      widths: f,
      layerIndices: p,
      extentVertices: m,
      lengths: y,
      dashArrays: x,
      dashRatios: v
    } = e, S = new BufferGeometry();
    S.setAttribute("position", new BufferAttribute(l, 3)), S.setAttribute("aColor", new BufferAttribute(c, 4)), S.setAttribute("normal", new BufferAttribute(h, 3)), S.setAttribute("aWidth", new BufferAttribute(f, 1)), S.setAttribute("layerIndex", new BufferAttribute(p, 1)), S.setAttribute("extentVertex", new BufferAttribute(m, 2)), S.setAttribute("lengths", new BufferAttribute(y, 1)), S.setAttribute("aDashArray", new BufferAttribute(x, 1)), S.setAttribute("aDashRatio", new BufferAttribute(v, 1)), S.setIndex(new BufferAttribute(d, 1));
    const E = this._getMaterial(r), b = new Mesh(S, E);
    return b.name = "MVTLineDashed", b.renderOrder = -100, b.onBeforeRender = () => {
      const w = a.targetCenter, M = this._engine.camera, P = this._engine.rendering.renderState, D = M.position, L = w.clone();
      L.x -= P.cameraOffset.x, L.y -= P.cameraOffset.y, L.z -= P.cameraOffset.z;
      const O = D.distanceTo(L), F = getPixelSize$1(
        O,
        M.fov * Math.PI / 180,
        this._engine.container.clientHeight
      );
      E.zoomUnits = F * 8, E.useLength = !0;
    }, b.raycast = () => {
    }, b;
  }
  _getExtrusionOpaqueMesh(e, r) {
    const { colors: s, vertices: a, uvs: c, indices: l, indices_side: h, normals: d, layerIndices: f, extentVertices: p } = e, m = new BufferGeometry();
    m.setAttribute("position", new BufferAttribute(a, 3)), m.setAttribute("uv", new BufferAttribute(c, 2)), m.setAttribute("color", new BufferAttribute(s, 4)), m.setAttribute("normal", new BufferAttribute(d, 3)), m.setAttribute("layerIndex", new BufferAttribute(f, 1)), m.setAttribute("extentVertex", new BufferAttribute(p, 2)), m.setIndex(new BufferAttribute(new Uint32Array([...l, ...h]), 1)), m.clearGroups(), m.addGroup(0, l.length, 1), m.addGroup(l.length, h.length, 0);
    const y = this._getMaterial(r), x = new Mesh(m, y);
    return x.name = "MVTExtrusionOpaque", x.renderOrder = -99, x.raycast = () => {
    }, x;
  }
  _getExtrusionTranslucentMesh(e, r) {
    const { colors: s, vertices: a, uvs: c, indices: l, indices_side: h, normals: d, layerIndices: f, extentVertices: p } = e, m = new BufferGeometry();
    m.setAttribute("position", new BufferAttribute(a, 3)), m.setAttribute("uv", new BufferAttribute(c, 2)), m.setAttribute("color", new BufferAttribute(s, 4)), m.setAttribute("normal", new BufferAttribute(d, 3)), m.setAttribute("layerIndex", new BufferAttribute(f, 1)), m.setAttribute("extentVertex", new BufferAttribute(p, 2)), m.setIndex(new BufferAttribute(new Uint32Array([...l, ...h]), 1)), m.clearGroups(), m.addGroup(0, l.length, 1), m.addGroup(l.length, h.length, 0);
    const y = this._getMaterial(r), x = new Mesh(m, y);
    return x.name = "MVTExtrusionTranslucent", x.renderOrder = -99, x.raycast = () => {
    }, x;
  }
  _getMaterial(e) {
    const r = this._engine.rendering.features.antialias.samples > 0;
    if (this.materialManager)
      return this.materialManager.getMaterialByKey(e);
    if (this._defaultMaterials[e])
      return this._defaultMaterials[e];
    let s;
    switch (e) {
      case "background":
        s = new MVTMaterial({
          name: e,
          vertexColors: !0,
          enableDepthRange: !0,
          depthRange: new Vector2$1(0, 1),
          vertexZIndexLegacy: !0
        });
        break;
      case "fill_extrusion_opaque":
        s = new MVTMaterial({
          name: e,
          vertexColors: !0,
          vertexZIndexLegacy: !0,
          depthRange: new Vector2$1(0, 1),
          useUVClip: !1,
          enableExtentClip: !0
        });
        break;
      case "fill_extrusion_translucent":
        s = new MVTMaterial({
          name: e,
          vertexColors: !0,
          vertexZIndexLegacy: !0,
          transparent: !0,
          depthRange: new Vector2$1(0, 1),
          useUVClip: !1,
          enableExtentClip: !0
        });
        break;
      case "fill_opaque":
        s = new MVTMaterial({
          name: e,
          vertexColors: !0,
          vertexZIndexLegacy: !0,
          enableDepthRange: !0,
          depthRange: new Vector2$1(0, 1),
          enableExtentClip: !0
        });
        break;
      case "fill_pattern":
        s = new MVTMaterial({
          name: e,
          vertexColors: !0,
          vertexZIndexLegacy: !0,
          enableDepthRange: !0,
          transparent: !0,
          depthRange: new Vector2$1(0, 1),
          enableExtentClip: !0,
          patternMap: this.spriteTexture,
          isPattern: !0
        });
        break;
      case "fill_water":
        s = new MVTMaterial({
          name: e,
          vertexColors: !0,
          vertexZIndexLegacy: !0,
          enableDepthRange: !0,
          depthRange: new Vector2$1(0, 1),
          enableExtentClip: !0
        });
        break;
      case "fill_wood":
        s = new MVTMaterial({
          name: e,
          vertexColors: !0,
          vertexZIndexLegacy: !0,
          enableDepthRange: !0,
          depthRange: new Vector2$1(0, 1),
          enableExtentClip: !0
        });
        break;
      case "fill_translucent":
        s = new MVTMaterial({
          name: e,
          transparent: !0,
          vertexZIndexLegacy: !0,
          vertexColors: !0,
          enableDepthRange: !0,
          depthRange: new Vector2$1(0, 1),
          enableExtentClip: !0
        });
        break;
      case "line_opaque":
        s = new FatLineMaterial({
          name: e,
          keepSize: !0,
          vertexColors: !0,
          enableDepthRange: !0,
          vertexZIndexLegacy: !0,
          depthRange: new Vector2$1(0, 1),
          antialias: !r,
          antialiasFactor: 0.6,
          lineWidth: 1,
          enableExtentClip: !0
        });
        break;
      case "line_dashed":
        s = new FatLineMaterial({
          name: e,
          dashed: !0,
          keepSize: !0,
          vertexColors: !0,
          dashArray: 5,
          enableDepthRange: !0,
          vertexZIndexLegacy: !0,
          depthRange: new Vector2$1(0, 1),
          enableExtentClip: !0,
          transparent: !0,
          antialias: !r,
          antialiasFactor: 0.6,
          lineWidth: 1,
          vertexDashArray: !0,
          vertexDashRatio: !0
        });
        break;
      case "line_translucent":
        s = new FatLineMaterial({
          name: e,
          keepSize: !0,
          transparent: !0,
          vertexZIndexLegacy: !0,
          antialias: !r,
          antialiasFactor: 0.6,
          lineWidth: 1,
          vertexColors: !0,
          enableDepthRange: !0,
          depthRange: new Vector2$1(0, 1),
          enableExtentClip: !0
        });
        break;
      default:
        throw new Error("unknown material type: " + e);
    }
    return this._defaultMaterials[e] = s, s.setCommonUniforms(this._engine.rendering.uniforms), s;
  }
  _calculateTolerance(e, r, s) {
    const a = e.tile.z;
    let c = 0;
    return a === 5 && s.text === "\u4E2D\u534E\u4EBA\u6C11\u5171\u548C\u56FD" && (c = -3), a === 6 && s.text === "\u5E7F\u5DDE" && (c = -4), a === 7 ? (c = 4, (s.text === "\u4E09\u6C99" || s.text === "\u4E09\u4E9A" || s.text === "\u510B\u5DDE") && (c = -1)) : a > 7 && (c = 12), (s.text === "\u9999\u6E2F" || s.text === "\u6FB3\u95E8" || s.text === "\u53F0\u5317") && (c = -3), c;
  }
  _setupSymbolData(e, r) {
    r.symbols = e.symbols;
  }
  _addTilePOI(e, r) {
    const s = [0, 0];
    r.rendering.label.spriteTexture = this.spriteTexture;
    const a = r.map.projectionName, c = e.tile.z < 10;
    if (e.object && e.object.symbols) {
      const l = [];
      for (let d = 0; d < e.object.symbols.length; d++) {
        const f = e.object.symbols[d];
        if (!this._symbols[f.id]) {
          this._symbols[f.id] = f;
          const p = f.textStyle || {}, { width: m, height: y, opacity: x } = f.iconStyle || {}, v = p.fontSize || 0, S = p.fontWeight || "400", E = p.textOffset || s, b = p.hOffset || 0, w = p.vOffset || 0;
          l.push({
            crs: a,
            id: f.id,
            text: f.text,
            type: f.type,
            rank: f.rank,
            position: f.position,
            rotateZ: f.rotateZ,
            iconUvs: f.iconUvs,
            bucket: e.dataTile.key,
            textWeight: S,
            textSize: v,
            textFillStyle: p.fillRgba,
            textStrokeStyle: p.haloRgba,
            textStrokeWidth: p.haloSize,
            textOffset: [E[0] * v + b, E[1] * v + w],
            textAnchor: p.textAnchor,
            maxWidth: p.maxWidth,
            iconSize: [m, y],
            iconOpacity: x,
            tolerance: this._calculateTolerance(e, r, f),
            checkVisible: c
          });
        }
      }
      const h = e.dataTile.key;
      r.rendering.label.addLabels(l, h);
    }
  }
  _removeTilePOI(e, r) {
    if (e.object && e.object.symbols) {
      const s = [];
      for (let c = 0; c < e.object.symbols.length; c++) {
        const l = e.object.symbols[c];
        this._symbols[l.id] && (delete this._symbols[l.id], s.push(l));
      }
      const a = e.dataTile.key;
      r.rendering.label.removeLabels(s, a);
    }
  }
  onSurfaceTileAdded(e, r) {
    this._addTilePOI(e, r);
  }
  onSurfaceTileRemoved(e, r) {
    this._removeTilePOI(e, r);
  }
  addAllSymbols() {
    Object.keys(this._symbols).forEach((e) => {
      const r = this._symbols[e];
      !r.isHidden || (r.isHidden = !1, this._engine.rendering.label.addLabel(r));
    });
  }
  removeAllSymbols() {
    Object.keys(this._symbols).forEach((e) => {
      const r = this._symbols[e];
      r.isHidden || (r.isHidden = !0, this._engine.rendering.label.removeLabel(r));
    });
  }
  onTileDispose(e) {
  }
  get materialManager() {
    return this._materialManager && !this._materialManager._inited && (this._materialManager.engine = this._engine, this._materialManager.init()), this._materialManager;
  }
  set materialManager(e) {
    e !== this._materialManager && (this._needsClearCache = !0, this._materialManager = e);
  }
}
function estimateBytesUsed$1(o) {
  let i = 0;
  for (const r in o.attributes) {
    const s = o.getAttribute(r);
    i += s.count * s.itemSize * s.array.BYTES_PER_ELEMENT;
  }
  const e = o.getIndex();
  return i += e ? e.count * e.itemSize * e.array.BYTES_PER_ELEMENT : 0, i;
}
function toTrianglesDrawMode(o, i) {
  if (i === TrianglesDrawMode)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), o;
  if (i === TriangleFanDrawMode || i === TriangleStripDrawMode) {
    let e = o.getIndex();
    if (e === null) {
      const c = [], l = o.getAttribute("position");
      if (l !== void 0) {
        for (let h = 0; h < l.count; h++)
          c.push(h);
        o.setIndex(c), e = o.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), o;
    }
    const r = e.count - 2, s = [];
    if (i === TriangleFanDrawMode)
      for (let c = 1; c <= r; c++)
        s.push(e.getX(0)), s.push(e.getX(c)), s.push(e.getX(c + 1));
    else
      for (let c = 0; c < r; c++)
        c % 2 === 0 ? (s.push(e.getX(c)), s.push(e.getX(c + 1)), s.push(e.getX(c + 2))) : (s.push(e.getX(c + 2)), s.push(e.getX(c + 1)), s.push(e.getX(c)));
    s.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const a = o.clone();
    return a.setIndex(s), a.clearGroups(), a;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", i), o;
}
const REVISION_GEQ_165 = parseInt(REVISION, 10) >= 165, REVISION_GEQ_166 = parseInt(REVISION, 10) >= 166, _box$2 = /* @__PURE__ */ new Box2(), _currentScissor = /* @__PURE__ */ new Vector4(), _pos$1 = /* @__PURE__ */ new Vector2$1(), TextureReadUtility = new class {
  constructor() {
    this._renderer = new WebGLRenderer(), this._target = new WebGLRenderTarget(1, 1), this._texTarget = new WebGLRenderTarget(), this._quad = new FullScreenQuad(new ShaderMaterial({
      blending: CustomBlending,
      blendDst: ZeroFactor,
      blendSrc: OneFactor,
      uniforms: {
        map: { value: null },
        pixel: { value: new Vector2$1() }
      },
      vertexShader: `
				void main() {

					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
			`,
      fragmentShader: `
				uniform sampler2D map;
				uniform ivec2 pixel;

				void main() {

					gl_FragColor = texelFetch( map, pixel, 0 );

				}
			`
    }));
  }
  increaseSizeTo(o) {
    this._target.setSize(Math.max(this._target.width, o), 1);
  }
  readDataAsync(o) {
    const { _renderer: i, _target: e } = this;
    return REVISION_GEQ_165 ? i.readRenderTargetPixelsAsync(e, 0, 0, o.length / 4, 1, o) : Promise.resolve().then(() => this.readData(o));
  }
  readData(o) {
    const { _renderer: i, _target: e } = this;
    i.readRenderTargetPixels(e, 0, 0, o.length / 4, 1, o);
  }
  renderPixelToTarget(o, i, e) {
    const { _quad: r, _renderer: s, _target: a, _texTarget: c } = this;
    if (REVISION_GEQ_166)
      _box$2.min.copy(i), _box$2.max.copy(i), _box$2.max.x += 1, _box$2.max.y += 1, s.initRenderTarget(a), s.copyTextureToTexture(o, a.texture, _box$2, e, 0);
    else {
      const l = s.autoClear, h = s.getRenderTarget(), d = s.getScissorTest();
      s.getScissor(_currentScissor), c.setSize(o.image.width, o.image.height), s.setRenderTarget(c), _pos$1.set(0, 0), REVISION_GEQ_165 ? s.copyTextureToTexture(o, c.texture, null, _pos$1) : s.copyTextureToTexture(_pos$1, o, c.texture), r.material.uniforms.map.value = c.texture, r.material.uniforms.pixel.value.copy(i), s.setRenderTarget(a), s.setScissorTest(!0), s.setScissor(e.x, e.y, 1, 1), s.autoClear = !1, r.render(s), s.setScissorTest(d), s.setScissor(_currentScissor), s.setRenderTarget(h), s.autoClear = l, c.dispose();
    }
  }
}(), _uv0 = /* @__PURE__ */ new Vector2$1(), _uv1 = /* @__PURE__ */ new Vector2$1(), _uv2 = /* @__PURE__ */ new Vector2$1();
function getTextureCoordAttribute(o, i) {
  return i === 0 ? o.getAttribute("uv") : o.getAttribute(`uv${i}`);
}
function getTriangleVertexIndices(o, i, e = new Array(3)) {
  let r = 3 * i, s = 3 * i + 1, a = 3 * i + 2;
  return o.index && (r = o.index.getX(r), s = o.index.getX(s), a = o.index.getX(a)), e[0] = r, e[1] = s, e[2] = a, e;
}
function getTexCoord(o, i, e, r, s) {
  const [a, c, l] = r, h = getTextureCoordAttribute(o, i);
  _uv0.fromBufferAttribute(h, a), _uv1.fromBufferAttribute(h, c), _uv2.fromBufferAttribute(h, l), s.set(0, 0, 0).addScaledVector(_uv0, e.x).addScaledVector(_uv1, e.y).addScaledVector(_uv2, e.z);
}
function getTexelIndices(o, i, e, r) {
  const s = o.x - Math.floor(o.x), a = o.y - Math.floor(o.y), c = Math.floor(s * i % i), l = Math.floor(a * e % e);
  return r.set(c, l), r;
}
const _uv = /* @__PURE__ */ new Vector2$1(), _pixel = /* @__PURE__ */ new Vector2$1(), _dstPixel = /* @__PURE__ */ new Vector2$1();
function getMaxBarycoordIndex(o) {
  return o.x > o.y && o.x > o.z ? 0 : o.y > o.z ? 1 : 2;
}
class MeshFeatures {
  constructor(i, e, r) {
    this.geometry = i, this.textures = e, this.data = r, this._asyncRead = !1, this.featureIds = r.featureIds.map((s) => {
      const { texture: a, ...c } = s, l = {
        label: null,
        propertyTable: null,
        nullFeatureId: null,
        ...c
      };
      return a && (l.texture = {
        texCoord: 0,
        channels: [0],
        ...a
      }), l;
    });
  }
  getTextures() {
    return this.textures;
  }
  getFeatureInfo() {
    return this.featureIds;
  }
  getFeaturesAsync(...i) {
    this._asyncRead = !0;
    const e = this.getFeatures(...i);
    return this._asyncRead = !1, e;
  }
  getFeatures(i, e) {
    const { geometry: r, textures: s, featureIds: a } = this, c = new Array(a.length).fill(null), l = a.length;
    TextureReadUtility.increaseSizeTo(l);
    const h = getTriangleVertexIndices(r, i), d = h[getMaxBarycoordIndex(e)];
    for (let m = 0, y = a.length; m < y; m++) {
      const x = a[m], v = "nullFeatureId" in x ? x.nullFeatureId : null;
      if ("texture" in x) {
        const S = s[x.texture.index];
        getTexCoord(r, x.texture.texCoord, e, h, _uv), getTexelIndices(_uv, S.image.width, S.image.height, _pixel), _dstPixel.set(m, 0), TextureReadUtility.renderPixelToTarget(s[x.texture.index], _pixel, _dstPixel);
      } else if ("attribute" in x) {
        const E = r.getAttribute(`_feature_id_${x.attribute}`).getX(d);
        E !== v && (c[m] = E);
      } else {
        const S = d;
        S !== v && (c[m] = S);
      }
    }
    const f = new Uint8Array(l * 4);
    if (this._asyncRead)
      return TextureReadUtility.readDataAsync(f).then(() => (p(), c));
    return TextureReadUtility.readData(f), p(), c;
    function p() {
      const m = new Uint32Array(1);
      for (let y = 0, x = a.length; y < x; y++) {
        const v = a[y], S = "nullFeatureId" in v ? v.nullFeatureId : null;
        if ("texture" in v) {
          const { channels: E } = v.texture, b = E.map((M) => f[4 * y + M]);
          new Uint8Array(m.buffer).set(b);
          const w = m[0];
          w !== S && (c[y] = w);
        }
      }
    }
  }
  dispose() {
    this.textures.forEach((i) => {
      i && (i.dispose(), i.image instanceof ImageBitmap && i.image.close());
    });
  }
}
const EXT_NAME$1 = "EXT_mesh_features";
function forEachPrimitiveExtension(o, i, e) {
  o.traverse((r) => {
    if (i.associations.has(r)) {
      const { meshes: s, primitives: a } = i.associations.get(r);
      if (defined$2(s) && defined$2(a)) {
        const c = i.json.meshes[s].primitives[a];
        c && c.extensions && c.extensions[EXT_NAME$1] && e(r, c.extensions[EXT_NAME$1]);
      }
    }
  });
}
class GLTFMeshFeaturesExtension {
  constructor(i) {
    this.parser = i, this.name = EXT_NAME$1;
  }
  async afterRoot({ scene: i, parser: e }) {
    var l;
    const r = e.json.extensionsUsed;
    if (!r || !r.includes(EXT_NAME$1))
      return;
    const s = ((l = e.json.textures) == null ? void 0 : l.length) || 0, a = new Array(s).fill(null);
    forEachPrimitiveExtension(i, e, (h, { featureIds: d }) => {
      d.forEach((f) => {
        if (f.texture && a[f.texture.index] === null) {
          const p = f.texture.index;
          a[p] = e.loadTexture(p);
        }
      });
    });
    const c = await Promise.all(a);
    forEachPrimitiveExtension(i, e, (h, d) => {
      h.userData.meshFeatures = new MeshFeatures(h.geometry, c, d);
    });
  }
}
class StructuralMetadata {
  constructor(i) {
    i = defaultValue$1(i, defaultValue$1.EMPTY_OBJECT), this._schema = i.schema;
    const e = i.propertyTables;
    this._propertyTableCount = defined$2(e) ? e.length : 0, this._propertyTables = e, this._propertyTextures = i.propertyTextures, this._propertyAttributes = i.propertyAttributes, this._statistics = i.statistics, this._extras = i.extras, this._extensions = i.extensions;
  }
  get schema() {
    return this._schema;
  }
  get statistics() {
    return this._statistics;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  get propertyTableCount() {
    return this._propertyTableCount;
  }
  get propertyTables() {
    return this._propertyTables;
  }
  get propertyTextures() {
    return this._propertyTextures;
  }
  get propertyAttributes() {
    return this._propertyAttributes;
  }
  get propertyTablesByteLength() {
    if (!defined$2(this._propertyTables))
      return 0;
    let i = 0;
    const e = this._propertyTables.length;
    for (let r = 0; r < e; r++)
      i += this._propertyTables[r].byteLength;
    return i;
  }
  getPropertyTable(i) {
    return this._propertyTables[i];
  }
  getPropertyTexture(i) {
    return this._propertyTextures[i];
  }
  getPropertyAttribute(i) {
    return this._propertyAttributes[i];
  }
  dispose() {
  }
}
function supportsBigInt$1() {
  return typeof BigInt < "u";
}
const MetadataComponentType = {
  INT8: "INT8",
  UINT8: "UINT8",
  INT16: "INT16",
  UINT16: "UINT16",
  INT32: "INT32",
  UINT32: "UINT32",
  INT64: "INT64",
  UINT64: "UINT64",
  FLOAT32: "FLOAT32",
  FLOAT64: "FLOAT64"
};
MetadataComponentType.getMinimum = function(o) {
  switch (o) {
    case MetadataComponentType.INT8:
      return -128;
    case MetadataComponentType.UINT8:
      return 0;
    case MetadataComponentType.INT16:
      return -32768;
    case MetadataComponentType.UINT16:
      return 0;
    case MetadataComponentType.INT32:
      return -2147483648;
    case MetadataComponentType.UINT32:
      return 0;
    case MetadataComponentType.INT64:
      return supportsBigInt$1() ? BigInt("-9223372036854775808") : -Math.pow(2, 63);
    case MetadataComponentType.UINT64:
      return supportsBigInt$1() ? BigInt(0) : 0;
    case MetadataComponentType.FLOAT32:
      return -34028234663852886e22;
    case MetadataComponentType.FLOAT64:
      return -Number.MAX_VALUE;
  }
};
MetadataComponentType.getMaximum = function(o) {
  switch (o) {
    case MetadataComponentType.INT8:
      return 127;
    case MetadataComponentType.UINT8:
      return 255;
    case MetadataComponentType.INT16:
      return 32767;
    case MetadataComponentType.UINT16:
      return 65535;
    case MetadataComponentType.INT32:
      return 2147483647;
    case MetadataComponentType.UINT32:
      return 4294967295;
    case MetadataComponentType.INT64:
      return supportsBigInt$1() ? BigInt("9223372036854775807") : Math.pow(2, 63) - 1;
    case MetadataComponentType.UINT64:
      return supportsBigInt$1() ? BigInt("18446744073709551615") : Math.pow(2, 64) - 1;
    case MetadataComponentType.FLOAT32:
      return 34028234663852886e22;
    case MetadataComponentType.FLOAT64:
      return Number.MAX_VALUE;
  }
};
MetadataComponentType.isIntegerType = function(o) {
  switch (o) {
    case MetadataComponentType.INT8:
    case MetadataComponentType.UINT8:
    case MetadataComponentType.INT16:
    case MetadataComponentType.UINT16:
    case MetadataComponentType.INT32:
    case MetadataComponentType.UINT32:
    case MetadataComponentType.INT64:
    case MetadataComponentType.UINT64:
      return !0;
    default:
      return !1;
  }
};
MetadataComponentType.isUnsignedIntegerType = function(o) {
  switch (o) {
    case MetadataComponentType.UINT8:
    case MetadataComponentType.UINT16:
    case MetadataComponentType.UINT32:
    case MetadataComponentType.UINT64:
      return !0;
    default:
      return !1;
  }
};
MetadataComponentType.isVectorCompatible = function(o) {
  switch (o) {
    case MetadataComponentType.INT8:
    case MetadataComponentType.UINT8:
    case MetadataComponentType.INT16:
    case MetadataComponentType.UINT16:
    case MetadataComponentType.INT32:
    case MetadataComponentType.UINT32:
    case MetadataComponentType.FLOAT32:
    case MetadataComponentType.FLOAT64:
      return !0;
    default:
      return !1;
  }
};
MetadataComponentType.normalize = function(o, i) {
  return Math.max(
    Number(o) / Number(MetadataComponentType.getMaximum(i)),
    -1
  );
};
MetadataComponentType.unnormalize = function(o, i) {
  const e = MetadataComponentType.getMaximum(i), r = MetadataComponentType.isUnsignedIntegerType(i) ? 0 : -e;
  return o = CesiumMath.sign(o) * Math.round(Math.abs(o) * Number(e)), (i === MetadataComponentType.INT64 || i === MetadataComponentType.UINT64) && supportsBigInt$1() && (o = BigInt(o)), o > e ? e : o < r ? r : o;
};
MetadataComponentType.applyValueTransform = function(o, i, e) {
  return e * o + i;
};
MetadataComponentType.unapplyValueTransform = function(o, i, e) {
  return e === 0 ? 0 : (o - i) / e;
};
MetadataComponentType.getSizeInBytes = function(o) {
  switch (o) {
    case MetadataComponentType.INT8:
    case MetadataComponentType.UINT8:
      return 1;
    case MetadataComponentType.INT16:
    case MetadataComponentType.UINT16:
      return 2;
    case MetadataComponentType.INT32:
    case MetadataComponentType.UINT32:
      return 4;
    case MetadataComponentType.INT64:
    case MetadataComponentType.UINT64:
      return 8;
    case MetadataComponentType.FLOAT32:
      return 4;
    case MetadataComponentType.FLOAT64:
      return 8;
  }
};
const MetadataComponentType$1 = Object.freeze(MetadataComponentType);
class MetadataEnumValue {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.value, r = i.name;
    this._value = e, this._name = r, this._description = i.description, this._extras = clone$2(i.extras, !0), this._extensions = clone$2(i.extensions, !0);
  }
  static fromJson(i) {
    return new MetadataEnumValue({
      value: i.value,
      name: i.name,
      description: i.description,
      extras: i.extras,
      extensions: i.extensions
    });
  }
  get value() {
    return this._value;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
class MetadataEnum {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.id, r = i.values, s = {}, a = {}, c = r.length;
    for (let h = 0; h < c; ++h) {
      const d = r[h];
      s[d.value] = d.name, a[d.name] = d.value;
    }
    const l = defaultValue$1(
      i.valueType,
      MetadataComponentType$1.UINT16
    );
    this._values = r, this._namesByValue = s, this._valuesByName = a, this._valueType = l, this._id = e, this._name = i.name, this._description = i.description, this._extras = clone$2(i.extras, !0), this._extensions = clone$2(i.extensions, !0);
  }
  static fromJson(i) {
    i = defaultValue$1(i, {});
    const e = i.id, r = i.enum, s = r.values.map(function(a) {
      return MetadataEnumValue.fromJson(a);
    });
    return new MetadataEnum({
      id: e,
      values: s,
      valueType: MetadataComponentType$1[r.valueType],
      name: r.name,
      description: r.description,
      extras: r.extras,
      extensions: r.extensions
    });
  }
  get values() {
    return this._values;
  }
  get namesByValue() {
    return this._namesByValue;
  }
  get valuesByName() {
    return this._valuesByName;
  }
  get valueType() {
    return this._valueType;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
const MetadataType = {
  SCALAR: "SCALAR",
  VEC2: "VEC2",
  VEC3: "VEC3",
  VEC4: "VEC4",
  MAT2: "MAT2",
  MAT3: "MAT3",
  MAT4: "MAT4",
  BOOLEAN: "BOOLEAN",
  STRING: "STRING",
  ENUM: "ENUM"
};
MetadataType.isVectorType = function(o) {
  switch (o) {
    case MetadataType.VEC2:
    case MetadataType.VEC3:
    case MetadataType.VEC4:
      return !0;
    default:
      return !1;
  }
};
MetadataType.isMatrixType = function(o) {
  switch (o) {
    case MetadataType.MAT2:
    case MetadataType.MAT3:
    case MetadataType.MAT4:
      return !0;
    default:
      return !1;
  }
};
MetadataType.getComponentCount = function(o) {
  switch (o) {
    case MetadataType.SCALAR:
    case MetadataType.STRING:
    case MetadataType.ENUM:
    case MetadataType.BOOLEAN:
      return 1;
    case MetadataType.VEC2:
      return 2;
    case MetadataType.VEC3:
      return 3;
    case MetadataType.VEC4:
      return 4;
    case MetadataType.MAT2:
      return 4;
    case MetadataType.MAT3:
      return 9;
    case MetadataType.MAT4:
      return 16;
    default:
      throw new Error(`Invalid metadata type ${o}`);
  }
};
MetadataType.getMathType = function(o) {
  switch (o) {
    case MetadataType.VEC2:
      return Vector2$1;
    case MetadataType.VEC3:
      return Vector3$1;
    case MetadataType.VEC4:
      return Vector4;
    case MetadataType.MAT2:
      console.warn("not support mat2");
      return;
    case MetadataType.MAT3:
      return Matrix3;
    case MetadataType.MAT4:
      return Matrix4;
    default:
      return;
  }
};
function unpackVectorArray(o, i, e) {
  const r = i.length;
  defined$2(e) ? e.length = r / 2 : e = new Array(r / 2);
  for (let s = 0; s < r; s += 2) {
    const a = s / 2;
    defined$2(e[a]) || (e[a] = new o()), e[a] = e[a].fromArray(i, s);
  }
  return e;
}
class MetadataClassProperty {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.id, r = i.type, s = i.componentType, a = i.enumType, c = defined$2(s) && MetadataComponentType$1.isIntegerType(s) && defaultValue$1(i.normalized, !1);
    this._id = e, this._name = i.name, this._description = i.description, this._semantic = i.semantic, this._isLegacyExtension = i.isLegacyExtension, this._type = r, this._componentType = s, this._enumType = a, this._valueType = defined$2(a) ? a.valueType : s, this._isArray = defaultValue$1(i.isArray, !1), this._isVariableLengthArray = defaultValue$1(
      i.isVariableLengthArray,
      !1
    ), this._arrayLength = i.arrayLength, this._min = clone$2(i.min, !0), this._max = clone$2(i.max, !0), this._normalized = c;
    let l = clone$2(i.offset, !0), h = clone$2(i.scale, !0);
    const d = defined$2(l) || defined$2(h), f = !0;
    defined$2(l) || (l = this.expandConstant(0, f)), defined$2(h) || (h = this.expandConstant(1, f)), this._offset = l, this._scale = h, this._hasValueTransform = d, this._noData = clone$2(i.noData, !0), this._default = clone$2(i.default, !0), this._required = defaultValue$1(i.required, !0), this._extras = clone$2(i.extras, !0), this._extensions = clone$2(i.extensions, !0);
  }
  static fromJson(i) {
    i = defaultValue$1(i, {});
    const e = i.id, r = i.property, s = isLegacy(r), a = parseType(r, i.enums);
    let c;
    return defined$2(s) ? s ? c = defined$2(r.optional) ? !r.optional : !0 : c = defaultValue$1(r.required, !1) : c = !1, new MetadataClassProperty({
      id: e,
      type: a.type,
      componentType: a.componentType,
      enumType: a.enumType,
      isArray: a.isArray,
      isVariableLengthArray: a.isVariableLengthArray,
      arrayLength: a.arrayLength,
      normalized: r.normalized,
      min: r.min,
      max: r.max,
      offset: r.offset,
      scale: r.scale,
      noData: r.noData,
      default: r.default,
      required: c,
      name: r.name,
      description: r.description,
      semantic: r.semantic,
      extras: r.extras,
      extensions: r.extensions,
      isLegacyExtension: s
    });
  }
  normalize(i) {
    return this._normalized ? normalizeInPlace(
      i,
      this._valueType,
      MetadataComponentType$1.normalize
    ) : i;
  }
  unnormalize(i) {
    return this._normalized ? normalizeInPlace(
      i,
      this._valueType,
      MetadataComponentType$1.unnormalize
    ) : i;
  }
  applyValueTransform(i) {
    return !this._hasValueTransform || this._isVariableLengthArray ? i : MetadataClassProperty.valueTransformInPlace(
      i,
      this._offset,
      this._scale,
      MetadataComponentType$1.applyValueTransform
    );
  }
  unapplyValueTransform(i) {
    return !this._hasValueTransform || this._isVariableLengthArray ? i : MetadataClassProperty.valueTransformInPlace(
      i,
      this._offset,
      this._scale,
      MetadataComponentType$1.unapplyValueTransform
    );
  }
  expandConstant(i, e) {
    e = defaultValue$1(e, !1);
    const r = this._isArray, s = this._arrayLength, a = MetadataType.getComponentCount(this._type), c = r && a > 1;
    if (!r && a === 1)
      return i;
    if (!r)
      return new Array(a).fill(i);
    if (!c)
      return new Array(s).fill(i);
    if (!e)
      return new Array(this._arrayLength * a).fill(i);
    const l = new Array(a).fill(i);
    return new Array(this._arrayLength).fill(l);
  }
  handleNoData(i) {
    const e = this._noData;
    if (!defined$2(e))
      return i;
    if (!arrayEquals(i, e))
      return i;
  }
  unpackVectorAndMatrixTypes(i, e) {
    e = defaultValue$1(e, !1);
    const r = MetadataType.getMathType(this._type), s = this._isArray, a = MetadataType.getComponentCount(this._type), c = s && a > 1;
    return defined$2(r) ? e && c ? i.map(function(l) {
      return new r().fromArray(l);
    }) : s ? unpackVectorArray(r, i) : new r().fromArray(i) : i;
  }
  packVectorAndMatrixTypes(i) {
    if (!(!defined$2(i) && defined$2(this._default)))
      return this._required && !defined$2(i) ? "required property must have a value" : this._isArray ? validateArray(this, i) : validateSingleValue(this, i);
  }
  valueTransformInPlace(i, e, r, s) {
    if (!Array.isArray(i))
      return s(i, e, r);
    for (let a = 0; a < i.length; a++)
      i[a] = MetadataClassProperty.valueTransformInPlace(
        i[a],
        e[a],
        r[a],
        s
      );
    return i;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get type() {
    return this._type;
  }
  get enumType() {
    return this._enumType;
  }
  get componentType() {
    return this._componentType;
  }
  get valueType() {
    return this._valueType;
  }
  get isArray() {
    return this._isArray;
  }
  get isVariableLengthArray() {
    return this._isVariableLengthArray;
  }
  get arrayLength() {
    return this._arrayLength;
  }
  get normalized() {
    return this._normalized;
  }
  get max() {
    return this._max;
  }
  get min() {
    return this._min;
  }
  get noData() {
    return this._noData;
  }
  get default() {
    return this._default;
  }
  get required() {
    return this._required;
  }
  get semantic() {
    return this._semantic;
  }
  get hasValueTransform() {
    return this._hasValueTransform;
  }
  get offset() {
    return this._offset;
  }
  get scale() {
    return this._scale;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
function normalizeInPlace(o, i, e) {
  if (!Array.isArray(o))
    return e(o, i);
  for (let r = 0; r < o.length; r++)
    o[r] = normalizeInPlace(o[r], i, e);
  return o;
}
function isLegacy(o) {
  if (o.type === "ARRAY")
    return !0;
  const i = o.type;
  if (i === MetadataType.SCALAR || MetadataType.isMatrixType(i) || MetadataType.isVectorType(i))
    return !1;
  if (defined$2(MetadataComponentType$1[i]))
    return !0;
  if (defined$2(o.noData) || defined$2(o.scale) || defined$2(o.offset) || defined$2(o.required) || defined$2(o.count) || defined$2(o.array) || defined$2(o.optional))
    return !1;
}
function parseType(o, i) {
  const e = o.type, r = o.componentType, s = e === "ARRAY";
  let a, c, l;
  s ? (a = !0, c = o.componentCount, l = !defined$2(c)) : o.array ? (a = !0, c = o.count, l = !defined$2(o.count)) : (a = !1, c = void 0, l = !1);
  let h;
  if (defined$2(o.enumType) && (h = i[o.enumType]), e === MetadataType.ENUM)
    return {
      type: e,
      componentType: void 0,
      enumType: h,
      valueType: h.valueType,
      isArray: a,
      isVariableLengthArray: l,
      arrayLength: c
    };
  if (s && r === MetadataType.ENUM)
    return {
      type: r,
      componentType: void 0,
      enumType: h,
      valueType: h.valueType,
      isArray: a,
      isVariableLengthArray: l,
      arrayLength: c
    };
  if (e === MetadataType.SCALAR || MetadataType.isMatrixType(e) || MetadataType.isVectorType(e))
    return {
      type: e,
      componentType: r,
      enumType: void 0,
      valueType: r,
      isArray: a,
      isVariableLengthArray: l,
      arrayLength: c
    };
  if (e === MetadataType.BOOLEAN || e === MetadataType.STRING)
    return {
      type: e,
      componentType: void 0,
      enumType: void 0,
      valueType: void 0,
      isArray: a,
      isVariableLengthArray: l,
      arrayLength: c
    };
  if (s && (r === MetadataType.BOOLEAN || r === MetadataType.STRING))
    return {
      type: r,
      componentType: void 0,
      enumType: void 0,
      valueType: void 0,
      isArray: a,
      isVariableLengthArray: l,
      arrayLength: c
    };
  if (defined$2(r) && defined$2(MetadataComponentType$1[r]))
    return {
      type: MetadataType.SCALAR,
      componentType: r,
      enumType: void 0,
      valueType: r,
      isArray: a,
      isVariableLengthArray: l,
      arrayLength: c
    };
  if (defined$2(MetadataComponentType$1[e]))
    return {
      type: MetadataType.SCALAR,
      componentType: e,
      enumType: void 0,
      valueType: e,
      isArray: a,
      isVariableLengthArray: l,
      arrayLength: c
    };
  throw new Error(
    `unknown metadata type {type: ${e}, componentType: ${r})`
  );
}
function arrayEquals(o, i) {
  if (!Array.isArray(o))
    return o === i;
  if (!Array.isArray(i) || o.length !== i.length)
    return !1;
  for (let e = 0; e < o.length; e++)
    if (!arrayEquals(o[e], i[e]))
      return !1;
  return !0;
}
function validateArray(o, i) {
  if (!Array.isArray(i))
    return `value ${i} must be an array`;
  const e = i.length;
  if (!o._isVariableLengthArray && e !== o._arrayLength)
    return "Array length does not match property.arrayLength";
  for (let r = 0; r < e; r++) {
    const s = validateSingleValue(o, i[r]);
    if (defined$2(s))
      return s;
  }
}
function validateSingleValue(o, i) {
  const e = o._type, r = o._componentType, s = o._enumType, a = o._normalized;
  return MetadataType.isVectorType(e) ? validateVector(i, e, r) : MetadataType.isMatrixType(e) ? validateMatrix(i, e, r) : e === MetadataType.STRING ? validateString(i) : e === MetadataType.BOOLEAN ? validateBoolean(i) : e === MetadataType.ENUM ? validateEnum(i, s) : validateScalar(i, r, a);
}
function validateVector(o, i, e) {
  if (!MetadataComponentType$1.isVectorCompatible(e))
    return `componentType ${e} is incompatible with vector type ${i}`;
  if (i === MetadataType.VEC2 && !(o instanceof Vector2$1))
    return `vector value ${o} must be a Vector2`;
  if (i === MetadataType.VEC3 && !(o instanceof Vector3$1))
    return `vector value ${o} must be a Vector3`;
  if (i === MetadataType.VEC4 && !(o instanceof Vector4))
    return `vector value ${o} must be a Vector4`;
}
function validateMatrix(o, i, e) {
  if (!MetadataComponentType$1.isVectorCompatible(e))
    return `componentType ${e} is incompatible with matrix type ${i}`;
  if (i === MetadataType.MAT2 && console.warn("not support mat2"), i === MetadataType.MAT3 && !(o instanceof Matrix3))
    return `matrix value ${o} must be a Matrix3`;
  if (i === MetadataType.MAT4 && !(o instanceof Matrix4))
    return `matrix value ${o} must be a Matrix4`;
}
function validateString(o) {
  if (typeof o != "string")
    return getTypeErrorMessage(o, MetadataType.STRING);
}
function validateBoolean(o) {
  if (typeof o != "boolean")
    return getTypeErrorMessage(o, MetadataType.BOOLEAN);
}
function validateEnum(o, i) {
  const e = typeof o;
  if (defined$2(i))
    return e !== "string" || !defined$2(i.valuesByName[o]) ? `value ${o} is not a valid enum name for ${i.id}` : void 0;
}
function validateScalar(o, i, e) {
  const r = typeof o;
  switch (i) {
    case MetadataComponentType$1.INT8:
    case MetadataComponentType$1.UINT8:
    case MetadataComponentType$1.INT16:
    case MetadataComponentType$1.UINT16:
    case MetadataComponentType$1.INT32:
    case MetadataComponentType$1.UINT32:
    case MetadataComponentType$1.FLOAT32:
    case MetadataComponentType$1.FLOAT64:
      return r !== "number" ? getTypeErrorMessage(o, i) : isFinite(o) ? checkInRange(o, i, e) : getNonFiniteErrorMessage(o, i);
    case MetadataComponentType$1.INT64:
    case MetadataComponentType$1.UINT64:
      return r !== "number" && r !== "bigint" ? getTypeErrorMessage(o, i) : r === "number" && !isFinite(o) ? getNonFiniteErrorMessage(o, i) : checkInRange(o, i, e);
  }
}
function getTypeErrorMessage(o, i) {
  return `value ${o} does not match type ${i}`;
}
function getOutOfRangeErrorMessage(o, i, e) {
  let r = `value ${o} is out of range for type ${i}`;
  return e && (r += " (normalized)"), r;
}
function checkInRange(o, i, e) {
  if (e) {
    const r = MetadataComponentType$1.isUnsignedIntegerType(i) ? 0 : -1, s = 1;
    return o < r || o > s ? getOutOfRangeErrorMessage(o, i, e) : void 0;
  }
  if (o < MetadataComponentType$1.getMinimum(i) || o > MetadataComponentType$1.getMaximum(i))
    return getOutOfRangeErrorMessage(o, i, e);
}
function getNonFiniteErrorMessage(o, i) {
  return `value ${o} of type ${i} must be finite`;
}
const mt = class {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.id, r = defaultValue$1(i.properties, {}), s = {};
    for (const a in r)
      if (r.hasOwnProperty(a)) {
        const c = r[a];
        defined$2(c.semantic) && (s[c.semantic] = c);
      }
    this._id = e, this._name = i.name, this._description = i.description, this._properties = r, this._propertiesBySemantic = s, this._extras = clone$2(i.extras, !0), this._extensions = clone$2(i.extensions, !0);
  }
  static fromJson(i) {
    i = defaultValue$1(i, {});
    const e = i.id, r = i.class, s = {};
    for (const a in r.properties)
      if (r.properties.hasOwnProperty(a)) {
        const c = MetadataClassProperty.fromJson({
          id: a,
          property: r.properties[a],
          enums: i.enums
        });
        s[a] = c;
      }
    return new mt({
      id: e,
      name: r.name,
      description: r.description,
      properties: s,
      extras: r.extras,
      extensions: r.extensions
    });
  }
  get properties() {
    return this._properties;
  }
  get propertiesBySemantic() {
    return this._propertiesBySemantic;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
};
let MetadataClass = mt;
_(MetadataClass, "BATCH_TABLE_CLASS_NAME", "_batchTable");
class MetadataSchema {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = defaultValue$1(i.classes, {}), r = defaultValue$1(i.enums, {});
    this._classes = e, this._enums = r, this._id = i.id, this._name = i.name, this._description = i.description, this._version = i.version, this._extras = clone$2(i.extras, !0), this._extensions = clone$2(i.extensions, !0);
  }
  static fromJson(i) {
    const e = {};
    if (defined$2(i.enums))
      for (const s in i.enums)
        i.enums.hasOwnProperty(s) && (e[s] = MetadataEnum.fromJson({
          id: s,
          enum: i.enums[s]
        }));
    const r = {};
    if (defined$2(i.classes))
      for (const s in i.classes)
        i.classes.hasOwnProperty(s) && (r[s] = MetadataClass.fromJson({
          id: s,
          class: i.classes[s],
          enums: e
        }));
    return new MetadataSchema({
      id: i.id,
      name: i.name,
      description: i.description,
      version: i.version,
      classes: r,
      enums: e,
      extras: i.extras,
      extensions: i.extensions
    });
  }
  get classes() {
    return this._classes;
  }
  get enums() {
    return this._enums;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get version() {
    return this._version;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
class MetadataEntity {
  static hasProperty(i, e, r) {
    if (defined$2(e[i]))
      return !0;
    const s = r.properties;
    if (!defined$2(s))
      return !1;
    const a = s[i];
    return !!(defined$2(a) && defined$2(a.default));
  }
  static hasPropertyBySemantic(i, e, r) {
    const s = r.propertiesBySemantic;
    if (!defined$2(s))
      return !1;
    const a = s[i];
    return defined$2(a);
  }
  static getPropertyIds(i, e, r) {
    r = defined$2(r) ? r : [], r.length = 0;
    for (const a in i)
      i.hasOwnProperty(a) && defined$2(i[a]) && r.push(a);
    const s = e.properties;
    if (defined$2(s))
      for (const a in s)
        s.hasOwnProperty(a) && !defined$2(i[a]) && defined$2(s[a].default) && r.push(a);
    return r;
  }
  static getProperty(i, e, r) {
    const s = r.properties[i];
    let a = e[i];
    Array.isArray(a) && (a = a.slice());
    const c = !0;
    if (a = s.handleNoData(a), !defined$2(a) && defined$2(s.default))
      return a = clone$2(s.default, !0), s.unpackVectorAndMatrixTypes(a, c);
    if (!!defined$2(a))
      return a = s.normalize(a), a = s.unpackVectorAndMatrixTypes(a, c), a;
  }
  static setProperty(i, e, r, s) {
    const a = s.properties[i];
    e = a.packVectorAndMatrixTypes(e);
    const c = a.transform(e);
    return defined$2(c) ? (Array.isArray(c) ? r[i] = c.slice() : r[i] = c, !0) : !1;
  }
  static getPropertyBySemantic(i, e, r) {
    const s = r.propertiesBySemantic;
    if (!defined$2(s))
      return;
    const a = s[i];
    if (!!defined$2(a))
      return MetadataEntity.getProperty(a.id, e, r);
  }
  static setPropertyBySemantic(i, e, r, s) {
    const a = s.propertiesBySemantic;
    if (!defined$2(a))
      return !1;
    const c = a[i];
    return defined$2(c) ? MetadataEntity.setProperty(c.id, e, r, s) : !1;
  }
}
const RequestState = {
  UNISSUED: 0,
  ISSUED: 1,
  ACTIVE: 2,
  RECEIVED: 3,
  CANCELLED: 4,
  FAILED: 5
}, RequestState$1 = Object.freeze(RequestState);
class Request {
  constructor(i = {}) {
    const e = defaultValue$1(i.throttleByServer, !1), r = defaultValue$1(i.throttle, !1);
    this.url = i.url, this.requestFunction = i.requestFunction, this.cancelFunction = i.cancelFunction, this.priorityFunction = i.priorityFunction, this.priority = defaultValue$1(i.priority, 0), this.throttle = r, this.throttleByServer = e, this.serverKey = i.serverKey, this.state = RequestState$1.UNISSUED, this.deferred = void 0, this.cancelled = !1;
  }
  cancel() {
    this.cancelled = !0;
  }
  clone(i) {
    return defined$2(i) ? (i.url = this.url, i.requestFunction = this.requestFunction, i.cancelFunction = this.cancelFunction, i.priorityFunction = this.priorityFunction, i.priority = this.priority, i.throttle = this.throttle, i.throttleByServer = this.throttleByServer, i.type = this.type, i.serverKey = this.serverKey, i.state = RequestState$1.UNISSUED, i.deferred = void 0, i.cancelled = !1, i) : new Request(this);
  }
}
function getStringFromTypedArray(o, i, e) {
  if (!defined$2(o))
    throw new Error("uint8Array is required.");
  if (i < 0)
    throw new Error("byteOffset cannot be negative.");
  if (e < 0)
    throw new Error("byteLength cannot be negative.");
  if (i + e > o.byteLength)
    throw new Error("sub-region exceeds array bounds.");
  return i = defaultValue$1(i, 0), e = defaultValue$1(e, o.byteLength - i), o = o.subarray(i, i + e), getStringFromTypedArray.decode(o);
}
getStringFromTypedArray.decodeWithTextDecoder = function(o) {
  return new TextDecoder("utf-8").decode(o);
};
getStringFromTypedArray.decodeWithFromCharCode = function(o) {
  let i = "";
  const e = utf8Handler(o), r = e.length;
  for (let s = 0; s < r; ++s) {
    let a = e[s];
    a <= 65535 ? i += String.fromCharCode(a) : (a -= 65536, i += String.fromCharCode((a >> 10) + 55296, (a & 1023) + 56320));
  }
  return i;
};
function inRange(o, i, e) {
  return i <= o && o <= e;
}
function utf8Handler(o) {
  let i = 0, e = 0, r = 0, s = 128, a = 191;
  const c = [], l = o.length;
  for (let h = 0; h < l; ++h) {
    const d = o[h];
    if (r === 0) {
      if (inRange(d, 0, 127)) {
        c.push(d);
        continue;
      }
      if (inRange(d, 194, 223)) {
        r = 1, i = d & 31;
        continue;
      }
      if (inRange(d, 224, 239)) {
        d === 224 && (s = 160), d === 237 && (a = 159), r = 2, i = d & 15;
        continue;
      }
      if (inRange(d, 240, 244)) {
        d === 240 && (s = 144), d === 244 && (a = 143), r = 3, i = d & 7;
        continue;
      }
      throw new Error("String decoding failed.");
    }
    if (!inRange(d, s, a)) {
      i = r = e = 0, s = 128, a = 191, --h;
      continue;
    }
    s = 128, a = 191, i = i << 6 | d & 63, ++e, e === r && (c.push(i), i = r = e = 0);
  }
  return c;
}
typeof TextDecoder < "u" ? getStringFromTypedArray.decode = getStringFromTypedArray.decodeWithTextDecoder : getStringFromTypedArray.decode = getStringFromTypedArray.decodeWithFromCharCode;
function getMagic(o, i) {
  return i = defaultValue$1(i, 0), getStringFromTypedArray(
    o,
    i,
    Math.min(4, o.length)
  );
}
function getJsonFromTypedArray$2(o, i, e) {
  return JSON.parse(
    getStringFromTypedArray(o, i, e)
  );
}
class MetadataTableProperty {
  constructor(i) {
    i = defaultValue$1(i, defaultValue$1.EMPTY_OBJECT);
    const e = i.count, r = i.property, s = i.classProperty, a = i.bufferViews, c = s.type, l = s.isArray, h = s.isVariableLengthArray;
    let d = s.valueType;
    const f = s.enumType, p = c === MetadataType.STRING, m = c === MetadataType.BOOLEAN;
    let y = 0, x;
    if (h) {
      let N = defaultValue$1(
        r.arrayOffsetType,
        r.offsetType
      );
      N = defaultValue$1(
        MetadataComponentType$1[N],
        MetadataComponentType$1.UINT32
      );
      const U = defaultValue$1(
        r.arrayOffsets,
        r.arrayOffsetBufferView
      );
      x = new BufferView(
        a[U],
        N,
        e + 1
      ), y += x.typedArray.byteLength;
    }
    const v = MetadataType.getComponentCount(c);
    let S;
    h ? S = x.get(e) - x.get(0) : l ? S = e * s.arrayLength : S = e;
    const E = v * S;
    let b;
    if (p) {
      let N = defaultValue$1(
        r.stringOffsetType,
        r.offsetType
      );
      N = defaultValue$1(
        MetadataComponentType$1[N],
        MetadataComponentType$1.UINT32
      );
      const U = defaultValue$1(
        r.stringOffsets,
        r.stringOffsetBufferView
      );
      b = new BufferView(
        a[U],
        N,
        E + 1
      ), y += b.typedArray.byteLength;
    }
    (p || m) && (d = MetadataComponentType$1.UINT8);
    let w;
    p ? w = b.get(E) - b.get(0) : m ? w = Math.ceil(E / 8) : w = E;
    const M = defaultValue$1(r.values, r.bufferView), P = new BufferView(
      a[M],
      d,
      w
    );
    y += P.typedArray.byteLength;
    let D = r.offset, L = r.scale;
    const O = s.hasValueTransform || defined$2(D) || defined$2(L);
    D = defaultValue$1(D, s.offset), L = defaultValue$1(L, s.scale), D = flatten(D), L = flatten(L);
    let F, k;
    const V = this;
    p ? F = function(N) {
      return getString(N, V._values, V._stringOffsets);
    } : m ? (F = function(N) {
      return getBoolean(N, V._values);
    }, k = function(N, U) {
      setBoolean(N, V._values, U);
    }) : defined$2(f) ? (F = function(N) {
      const U = V._values.get(N);
      return f.namesByValue[U];
    }, k = function(N, U) {
      const z = f.valuesByName[U];
      V._values.set(N, z);
    }) : (F = function(N) {
      return V._values.get(N);
    }, k = function(N, U) {
      V._values.set(N, U);
    }), this._arrayOffsets = x, this._stringOffsets = b, this._values = P, this._classProperty = s, this._count = e, this._vectorComponentCount = v, this._min = r.min, this._max = r.max, this._offset = D, this._scale = L, this._hasValueTransform = O, this._getValue = F, this._setValue = k, this._unpackedValues = void 0, this._extras = r.extras, this._extensions = r.extensions, this._byteLength = y;
  }
  get(i) {
    let e = get(this, i);
    return e = this._classProperty.handleNoData(e), defined$2(e) ? (e = this._classProperty.normalize(e), e = applyValueTransform(this, e), this._classProperty.unpackVectorAndMatrixTypes(e)) : (e = this._classProperty.default, this._classProperty.unpackVectorAndMatrixTypes(e));
  }
  set(i, e) {
    const r = this._classProperty;
    e = r.packVectorAndMatrixTypes(e), e = unapplyValueTransform(this, e), e = r.unnormalize(e), set(this, i, e);
  }
  getTypedArray() {
    if (defined$2(this._values))
      return this._values.typedArray;
  }
  get hasValueTransform() {
    return this._hasValueTransform;
  }
  get offset() {
    return this._offset;
  }
  get scale() {
    return this._scale;
  }
  get extensions() {
    return this._extensions;
  }
  get byteLength() {
    return this._byteLength;
  }
}
function BufferView(o, i, e) {
  const r = this;
  let s, a, c;
  i === MetadataComponentType$1.INT64 ? supportsBigInt() ? supportsBigInt64Array() ? (s = new BigInt64Array(
    o.buffer,
    o.byteOffset,
    e
  ), c = function(l, h) {
    r.typedArray[l] = BigInt(h);
  }) : (s = new Uint8Array(
    o.buffer,
    o.byteOffset,
    e * 8
  ), a = function(l) {
    return getInt64BigIntFallback(l, r);
  }) : (warnOnce(
    "INT64 type is not fully supported on this platform. Values greater than 2^53 - 1 or less than -(2^53 - 1) may lose precision when read."
  ), s = new Uint8Array(
    o.buffer,
    o.byteOffset,
    e * 8
  ), a = function(l) {
    return getInt64NumberFallback(l, r);
  }) : i === MetadataComponentType$1.UINT64 ? supportsBigInt() ? supportsBigUint64Array() ? (s = new BigUint64Array(
    o.buffer,
    o.byteOffset,
    e
  ), c = function(l, h) {
    r.typedArray[l] = BigInt(h);
  }) : (s = new Uint8Array(
    o.buffer,
    o.byteOffset,
    e * 8
  ), a = function(l) {
    return getUint64BigIntFallback(l, r);
  }) : (warnOnce(
    "UINT64 type is not fully supported on this platform. Values greater than 2^53 - 1 may lose precision when read."
  ), s = new Uint8Array(
    o.buffer,
    o.byteOffset,
    e * 8
  ), a = function(l) {
    return getUint64NumberFallback(l, r);
  }) : (s = getTypedArrayByDatatype(
    i,
    o.buffer,
    o.byteOffset,
    e
  ), c = function(l, h) {
    r.typedArray[l] = h;
  }), defined$2(a) || (a = function(l) {
    return r.typedArray[l];
  }), this.typedArray = s, this.dataView = new DataView(s.buffer, s.byteOffset), this.get = a, this.set = c, this._componentType = i;
}
function flatten(o) {
  if (!Array.isArray(o))
    return o;
  const i = [];
  for (let e = 0; e < o.length; e++) {
    const r = o[e];
    Array.isArray(r) ? i.push.apply(i, r) : i.push(r);
  }
  return i;
}
function get(o, i) {
  requiresUnpackForGet(o) && unpackProperty(o);
  const e = o._classProperty, r = e.isArray, s = e.type, a = MetadataType.getComponentCount(s);
  if (defined$2(o._unpackedValues)) {
    const c = o._unpackedValues[i];
    return r ? clone$2(c, !0) : c;
  }
  return !r && a === 1 ? o._getValue(i) : getArrayValues(o, e, i);
}
function getArrayValues(o, i, e) {
  let r, s;
  if (i.isVariableLengthArray) {
    r = o._arrayOffsets.get(e), s = o._arrayOffsets.get(e + 1) - r;
    const c = MetadataType.getComponentCount(i.type);
    r *= c, s *= c;
  } else {
    const l = defaultValue$1(i.arrayLength, 1) * o._vectorComponentCount;
    r = e * l, s = l;
  }
  const a = new Array(s);
  for (let c = 0; c < s; c++)
    a[c] = o._getValue(r + c);
  return a;
}
function set(o, i, e) {
  requiresUnpackForSet(o, i, e) && unpackProperty(o);
  const r = o._classProperty, s = r.isArray, a = r.type, c = MetadataType.getComponentCount(a);
  if (defined$2(o._unpackedValues)) {
    r.isArray && (e = clone$2(e, !0)), o._unpackedValues[i] = e;
    return;
  }
  if (!s && c === 1) {
    o._setValue(i, e);
    return;
  }
  let l, h;
  if (r.isVariableLengthArray)
    l = o._arrayOffsets.get(i), h = o._arrayOffsets.get(i + 1) - l;
  else {
    const f = defaultValue$1(r.arrayLength, 1) * o._vectorComponentCount;
    l = i * f, h = f;
  }
  for (let d = 0; d < h; ++d)
    o._setValue(l + d, e[d]);
}
function getString(o, i, e) {
  const r = e.get(o), s = e.get(o + 1) - r;
  return getStringFromTypedArray(
    i.typedArray,
    r,
    s
  );
}
function getBoolean(o, i) {
  const e = o >> 3, r = o % 8;
  return (i.typedArray[e] >> r & 1) === 1;
}
function setBoolean(o, i, e) {
  const r = o >> 3, s = o % 8;
  e ? i.typedArray[r] |= 1 << s : i.typedArray[r] &= ~(1 << s);
}
function getInt64NumberFallback(o, i) {
  const e = i.dataView, r = o * 8;
  let s = 0;
  const a = (e.getUint8(r + 7) & 128) > 0;
  let c = !0;
  for (let l = 0; l < 8; ++l) {
    let h = e.getUint8(r + l);
    a && (c ? h !== 0 && (h = ~(h - 1) & 255, c = !1) : h = ~h & 255), s += h * Math.pow(256, l);
  }
  return a && (s = -s), s;
}
function getInt64BigIntFallback(o, i) {
  const e = i.dataView, r = o * 8;
  let s = BigInt(0);
  const a = (e.getUint8(r + 7) & 128) > 0;
  let c = !0;
  for (let l = 0; l < 8; ++l) {
    let h = e.getUint8(r + l);
    a && (c ? h !== 0 && (h = ~(h - 1) & 255, c = !1) : h = ~h & 255), s += BigInt(h) * (BigInt(1) << BigInt(l * 8));
  }
  return a && (s = -s), s;
}
function getUint64NumberFallback(o, i) {
  const e = i.dataView, r = o * 8, s = e.getUint32(r, !0), a = e.getUint32(r + 4, !0);
  return s + 4294967296 * a;
}
function getUint64BigIntFallback(o, i) {
  const e = i.dataView, r = o * 8, s = BigInt(e.getUint32(r, !0)), a = BigInt(e.getUint32(r + 4, !0));
  return s + BigInt(4294967296) * a;
}
function getTypedArrayByDatatype(o, i, e, r) {
  switch (o) {
    case MetadataComponentType$1.INT8:
      return new Int8Array(i, e, r);
    case MetadataComponentType$1.UINT8:
      return new Uint8Array(i, e, r);
    case MetadataComponentType$1.INT16:
      return new Int16Array(i, e, r);
    case MetadataComponentType$1.UINT16:
      return new Uint16Array(i, e, r);
    case MetadataComponentType$1.INT32:
      return new Int32Array(i, e, r);
    case MetadataComponentType$1.UINT32:
      return new Uint32Array(i, e, r);
    case MetadataComponentType$1.FLOAT32:
      return new Float32Array(i, e, r);
    case MetadataComponentType$1.FLOAT64:
      return new Float64Array(i, e, r);
    default:
      throw new Error(`Unsupported component type: ${o}`);
  }
}
function requiresUnpackForGet(o) {
  if (defined$2(o._unpackedValues))
    return !1;
  const i = o._classProperty, e = i.type, r = i.valueType;
  return e === MetadataType.STRING || r === MetadataComponentType$1.INT64 && !supportsBigInt64Array() || r === MetadataComponentType$1.UINT64 && !supportsBigUint64Array();
}
function requiresUnpackForSet(o, i, e) {
  if (requiresUnpackForGet(o))
    return !0;
  const r = o._arrayOffsets;
  if (defined$2(r)) {
    const s = r.get(i + 1) - r.get(i), a = e.length;
    if (s !== a)
      return !0;
  }
  return !1;
}
function unpackProperty(o) {
  o._unpackedValues = unpackValues(o), o._arrayOffsets = void 0, o._stringOffsets = void 0, o._values = void 0;
}
function unpackValues(o) {
  const i = o._count, e = new Array(i), r = o._classProperty, s = r.isArray, a = r.type, c = MetadataType.getComponentCount(a);
  if (!s && c === 1) {
    for (let l = 0; l < i; ++l)
      e[l] = o._getValue(l);
    return e;
  }
  for (let l = 0; l < i; l++)
    e[l] = getArrayValues(o, r, l);
  return e;
}
function applyValueTransform(o, i) {
  const r = o._classProperty.isVariableLengthArray;
  return !o._hasValueTransform || r ? i : MetadataClassProperty.valueTransformInPlace(
    i,
    o._offset,
    o._scale,
    MetadataComponentType$1.applyValueTransform
  );
}
function unapplyValueTransform(o, i) {
  const r = o._classProperty.isVariableLengthArray;
  return !o._hasValueTransform || r ? i : MetadataClassProperty.valueTransformInPlace(
    i,
    o._offset,
    o._scale,
    MetadataComponentType$1.unapplyValueTransform
  );
}
function supportsBigInt() {
  return typeof BigInt < "u";
}
function supportsBigInt64Array() {
  return typeof BigInt64Array < "u";
}
function supportsBigUint64Array() {
  return typeof BigUint64Array < "u";
}
class MetadataTable {
  constructor(i = {}) {
    i = defaultValue$1(i, defaultValue$1.EMPTY_OBJECT);
    const { count: e, properties: r, class: s, bufferViews: a } = i;
    if (this._count = e, this._class = s, this._properties = {}, this._byteLength = 0, defined$2(r)) {
      for (const c in r)
        if (r.hasOwnProperty(c)) {
          const l = new MetadataTableProperty({
            count: e,
            property: r[c],
            classProperty: s.properties[c],
            bufferViews: a
          });
          this._properties[c] = l, this._byteLength += l.byteLength;
        }
    }
  }
  get count() {
    return this._count;
  }
  get class() {
    return this._class;
  }
  get byteLength() {
    return this._byteLength;
  }
  hasProperty(i) {
    return MetadataEntity.hasProperty(i, this._properties, this._class);
  }
  hasPropertyBySemantic(i) {
    return MetadataEntity.hasPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  getPropertyIds(i = []) {
    return MetadataEntity.getPropertyIds(this._properties, this._class, i);
  }
  getProperty(i, e) {
    const r = this._properties[e];
    let s;
    return defined$2(r) ? s = r.get(i) : s = getDefault(this._class, e), s;
  }
  setProperty(i, e, r) {
    const s = this._properties[e];
    return defined$2(s) ? (s.set(i, r), !0) : !1;
  }
  getPropertyBySemantic(i, e) {
    let r;
    const s = this._class.propertiesBySemantic;
    if (defined$2(s) && (r = s[e]), defined$2(r))
      return this.getProperty(i, r.id);
  }
  setPropertyBySemantic(i, e, r) {
    let s;
    const a = this._class.propertiesBySemantic;
    return defined$2(a) && (s = a[e]), defined$2(s) ? this.setProperty(i, s.id, r) : !1;
  }
  getPropertyTypedArray(i) {
    const e = this._properties[i];
    if (defined$2(e))
      return e.getTypedArray();
  }
  getPropertyTypedArrayBySemantic(i) {
    let e;
    const r = this._class.propertiesBySemantic;
    if (defined$2(r) && (e = r[i]), defined$2(e))
      return this.getPropertyTypedArray(e.id);
  }
}
function getDefault(o, i) {
  const e = o.properties;
  if (!defined$2(e))
    return;
  const r = e[i];
  if (defined$2(r) && defined$2(r.default)) {
    let s = r.default;
    return r.isArray && (s = clone$2(s, !0)), s = r.normalize(s), r.unpackVectorAndMatrixTypes(s);
  }
}
const emptyClass = {};
class JsonMetadataTable {
  constructor(i) {
    this._count = i.count, this._properties = clone$2(i.properties, !0);
  }
  hasProperty(i) {
    return MetadataEntity.hasProperty(i, this._properties, emptyClass);
  }
  getPropertyIds(i = []) {
    return MetadataEntity.getPropertyIds(this._properties, emptyClass, i);
  }
  getProperty(i, e) {
    const r = this._properties[e];
    if (defined$2(r))
      return clone$2(r[i], !0);
  }
  setProperty(i, e, r) {
    let s = this._properties[e];
    defined$2(s) || (s = new Array(this._count), this._properties[e] = s), s[i] = clone$2(r, !0);
  }
}
const scratchResults = [];
class PropertyTable {
  constructor(i = defaultValue$1.EMPTY_OBJECT) {
    this._name = i.name, this._id = i.id, this._count = i.count, this._extras = i.extras, this._extensions = i.extensions, this._metadataTable = i.metadataTable, this._jsonMetadataTable = i.jsonMetadataTable, this._batchTableHierarchy = i.batchTableHierarchy;
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }
  get count() {
    return this._count;
  }
  get class() {
    return this._metadataTable ? this._metadataTable.class : void 0;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  get byteLength() {
    let i = 0;
    return this._metadataTable && (i += this._metadataTable.byteLength), this._batchTableHierarchy && (i += this._batchTableHierarchy.byteLength), i;
  }
  hasProperty(i, e) {
    return !!(this._metadataTable && this._metadataTable.hasProperty(e) || this._batchTableHierarchy && this._batchTableHierarchy.hasProperty(i, e) || this._jsonMetadataTable && this._jsonMetadataTable.hasProperty(e));
  }
  hasPropertyBySemantic(i, e) {
    return this._metadataTable ? this._metadataTable.hasPropertyBySemantic(e) : !1;
  }
  propertyExists(i) {
    return !!(this._metadataTable && this._metadataTable.hasProperty(i) || this._batchTableHierarchy && this._batchTableHierarchy.propertyExists(i) || this._jsonMetadataTable && this._jsonMetadataTable.hasProperty(i));
  }
  propertyExistsBySemantic(i) {
    return this._metadataTable ? this._metadataTable.hasPropertyBySemantic(i) : !1;
  }
  getPropertyIds(i, e = []) {
    return e.length = 0, this._metadataTable && e.push(...this._metadataTable.getPropertyIds(scratchResults)), this._batchTableHierarchy && e.push(...this._batchTableHierarchy.getPropertyIds(i, scratchResults)), this._jsonMetadataTable && e.push(...this._jsonMetadataTable.getPropertyIds(scratchResults)), e;
  }
  getProperty(i, e) {
    let r;
    if (this._metadataTable && (r = this._metadataTable.getProperty(i, e), r) || this._batchTableHierarchy && (r = this._batchTableHierarchy.getProperty(i, e), r) || this._jsonMetadataTable && (r = this._jsonMetadataTable.getProperty(i, e), r))
      return r;
  }
  setProperty(i, e, r) {
    this._metadataTable && this._metadataTable.setProperty(i, e, r) || this._batchTableHierarchy && this._batchTableHierarchy.setProperty(i, e, r) || (this._jsonMetadataTable || (this._jsonMetadataTable = new JsonMetadataTable({
      count: this._count,
      properties: {}
    })), this._jsonMetadataTable.setProperty(i, e, r));
  }
  getPropertyBySemantic(i, e) {
    return this._metadataTable ? this._metadataTable.getPropertyBySemantic(i, e) : void 0;
  }
  setPropertyBySemantic(i, e, r) {
    return this._metadataTable ? this._metadataTable.setPropertyBySemantic(i, e, r) : !1;
  }
  getPropertyTypedArray(i) {
    return this._metadataTable ? this._metadataTable.getPropertyTypedArray(i) : void 0;
  }
  getPropertyTypedArrayBySemantic(i) {
    return this._metadataTable ? this._metadataTable.getPropertyTypedArrayBySemantic(i) : void 0;
  }
  isClass(i, e) {
    return this._batchTableHierarchy ? this._batchTableHierarchy.isClass(i, e) : !1;
  }
  isExactClass(i, e) {
    return this.getExactClassName(i) === e;
  }
  getExactClassName(i) {
    return this._batchTableHierarchy ? this._batchTableHierarchy.getClassName(i) : void 0;
  }
}
class PropertyTextureProperty {
  constructor(i) {
    i = defaultValue$1(i, defaultValue$1.EMPTY_OBJECT);
    const e = i.property, r = i.classProperty, s = i.textures, a = defined$2(e.channels) ? e.channels : [0], c = e;
    this._textureInfo = c, this._channels = reformatChannels(a), this._texture = s[c.index], this._min = e.min, this._max = e.max;
    let l = e.offset, h = e.scale;
    const d = r.hasValueTransform || defined$2(l) || defined$2(h);
    l = defaultValue$1(l, r.offset), h = defaultValue$1(h, r.scale), l = r.unpackVectorAndMatrixTypes(l), h = r.unpackVectorAndMatrixTypes(h), this._offset = l, this._scale = h, this._hasValueTransform = d, this._classProperty = r, this._extras = e.extras, this._extensions = e.extensions;
  }
  get texture() {
    return this._texture;
  }
  get channels() {
    return this._channels;
  }
  get offset() {
    return this._offset;
  }
  get scale() {
    return this._scale;
  }
  get extra() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  get classProperty() {
    return this._classProperty;
  }
  get textureInfo() {
    return this._textureInfo;
  }
}
function reformatChannels(o) {
  return o.map(function(i) {
    return "rgba".charAt(i);
  }).join("");
}
class PropertyTexture {
  constructor(i) {
    i = defaultValue$1(i, defaultValue$1.EMPTY_OBJECT);
    const e = i.propertyTexture, r = i.class, s = i.textures, a = e.extensions, c = e.extras, l = {};
    if (defined$2(e.properties))
      for (const h in e.properties)
        e.properties.hasOwnProperty(h) && (l[h] = new PropertyTextureProperty({
          property: e.properties[h],
          classProperty: r.properties[h],
          textures: s
        }));
    this._name = i.name, this._id = i.id, this._class = r, this._properties = l, this._extras = c, this._extensions = a;
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }
  get class() {
    return this._class;
  }
  get properties() {
    return this._properties;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  getProperty(i) {
    return this._properties[i];
  }
}
class PropertyAttributeProperty {
  constructor(i) {
    i = defaultValue$1(i, defaultValue$1.EMPTY_OBJECT);
    const e = i.property, r = i.classProperty;
    this._attribute = e.attribute, this._classProperty = r, this._min = e.min, this._max = e.max;
    let s = e.offset, a = e.scale;
    const c = r.hasValueTransform || defined$2(s) || defined$2(a);
    s = defaultValue$1(s, r.offset), a = defaultValue$1(a, r.scale), s = r.unpackVectorAndMatrixTypes(s), a = r.unpackVectorAndMatrixTypes(a), this._offset = s, this._scale = a, this._hasValueTransform = c, this._extras = e.extras, this._extensions = e.extensions;
  }
  get attribute() {
    return this._attribute;
  }
  get hasValueTransform() {
    return this._hasValueTransform;
  }
  get offset() {
    return this._offset;
  }
  get scale() {
    return this._scale;
  }
  get classProperty() {
    return this._classProperty;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
class PropertyAttribute {
  constructor(i) {
    i = defaultValue$1(i, defaultValue$1.EMPTY_OBJECT);
    const e = i.propertyAttribute, r = i.class, s = {};
    if (defined$2(e.properties))
      for (const a in e.properties)
        e.properties.hasOwnProperty(a) && (s[a] = new PropertyAttributeProperty({
          property: e.properties[a],
          classProperty: r.properties[a]
        }));
    this._name = i.name, this._id = i.id, this._class = r, this._properties = s, this._extras = e.extras, this._extensions = e.extensions;
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }
  get class() {
    return this._class;
  }
  get properties() {
    return this._properties;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  getProperty(i) {
    return this._properties[i];
  }
}
function parseStructuralMetadata(o) {
  o = defaultValue$1(o, defaultValue$1.EMPTY_OBJECT);
  const i = o.extension, e = o.schema, r = [];
  if (defined$2(i.propertyTables))
    for (let c = 0; c < i.propertyTables.length; c++) {
      const l = i.propertyTables[c], h = e.classes[l.class], d = new MetadataTable({
        count: l.count,
        properties: l.properties,
        class: h,
        bufferViews: o.bufferViews
      });
      r.push(
        new PropertyTable({
          id: c,
          name: l.name,
          count: l.count,
          metadataTable: d,
          extras: l.extras,
          extensions: l.extensions
        })
      );
    }
  const s = [];
  if (defined$2(i.propertyTextures))
    for (let c = 0; c < i.propertyTextures.length; c++) {
      const l = i.propertyTextures[c];
      s.push(
        new PropertyTexture({
          id: c,
          name: l.name,
          propertyTexture: l,
          class: e.classes[l.class],
          textures: o.textures
        })
      );
    }
  const a = [];
  if (defined$2(i.propertyAttributes))
    for (let c = 0; c < i.propertyAttributes.length; c++) {
      const l = i.propertyAttributes[c];
      a.push(
        new PropertyAttribute({
          id: c,
          name: l.name,
          class: e.classes[l.class],
          propertyAttribute: l
        })
      );
    }
  return new StructuralMetadata({
    schema: e,
    propertyTables: r,
    propertyTextures: s,
    propertyAttributes: a,
    statistics: i.statistics,
    extras: i.extras,
    extensions: i.extensions
  });
}
function createChildStructuralMetadata(o, i) {
  let e = [], r = [];
  if (i) {
    if (i.propertyTextures) {
      const a = o.propertyTextures;
      e = i.propertyTextures.map((c) => a[c]);
    }
    if (i.propertyAttributes) {
      const a = o.propertyAttributes;
      r = i.propertyAttributes.map((c) => a[c]);
    }
  }
  return new StructuralMetadata({
    schema: o.schema,
    propertyTables: o.propertyTables,
    propertyTextures: e,
    propertyAttributes: r,
    extras: o.extras,
    extensions: o.extensions
  });
}
const EXT_NAME = "EXT_structural_metadata";
function getRelevantTextures(o, i = []) {
  var s;
  const e = ((s = o.json.textures) == null ? void 0 : s.length) || 0, r = new Array(e).fill(null);
  return i.forEach(({ properties: a }) => {
    for (const c in a)
      if (a.hasOwnProperty(c)) {
        const { index: l } = a[c];
        r[l] === null && (r[l] = o.loadTexture(l));
      }
  }), Promise.all(r);
}
function getRelevantBuffers(o, i = []) {
  var s;
  const e = ((s = o.json.bufferViews) == null ? void 0 : s.length) || 0, r = new Array(e).fill(null);
  return i.forEach(({ properties: a }) => {
    for (const c in a)
      if (a.hasOwnProperty(c)) {
        const { values: l, arrayOffsets: h, stringOffsets: d } = a[c];
        r[l] === null && (r[l] = o.loadBufferView(l)), r[h] === null && (r[h] = o.loadBufferView(h)), r[d] === null && (r[d] = o.loadBufferView(d));
      }
  }), Promise.all(r);
}
class GLTFStructuralMetadataExtension {
  constructor(i) {
    this.parser = i, this.name = EXT_NAME;
  }
  async afterRoot({ scene: i, parser: e }) {
    const r = e.json.extensionsUsed;
    if (!r || !r.includes(EXT_NAME))
      return;
    let s = null, a = e.json.extensions[EXT_NAME];
    if (a.schemaUri) {
      const { manager: p, path: m, requestHeader: y, crossOrigin: x } = e.options, v = new URL(a.schemaUri, m).toString(), S = new FileLoader(p);
      S.setCrossOrigin(x), S.setResponseType("json"), S.setRequestHeader(y), s = S.loadAsync(v).then((E) => {
        a = { ...a, schema: E };
      });
    }
    const [c, l] = await Promise.all([
      getRelevantTextures(e, a.propertyTextures),
      getRelevantBuffers(e, a.propertyTables),
      s
    ]), h = l.map((p) => {
      if (p)
        return new Uint8Array(p);
    }), d = MetadataSchema.fromJson(a.schema), f = parseStructuralMetadata({
      extension: a,
      schema: d,
      bufferViews: h,
      textures: c
    });
    i.userData.structuralMetadata = f, i.traverse((p) => {
      if (e.associations.has(p)) {
        const { meshes: m, primitives: y } = e.associations.get(p);
        if (defined$2(m) && defined$2(y)) {
          const x = e.json.meshes[m].primitives[y];
          if (x && x.extensions && x.extensions[EXT_NAME]) {
            const v = x.extensions[EXT_NAME];
            p.userData.structuralMetadata = createChildStructuralMetadata(
              f,
              v
            );
          } else
            p.userData.structuralMetadata = f;
        }
      }
    });
  }
}
class GLTFCesiumRTCExtension {
  constructor() {
    this.name = "CESIUM_RTC";
  }
  afterRoot(i) {
    if (i.parser.json.extensions && i.parser.json.extensions.CESIUM_RTC) {
      const { center: e } = i.parser.json.extensions.CESIUM_RTC;
      e && (i.scene.position.x += e[0], i.scene.position.y += e[1], i.scene.position.z += e[2]);
    }
  }
}
class GLTFLoader$1 extends Loader {
  constructor(i) {
    super(i), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.forceUnlit = !1, this.pluginCallbacks = [], this.register(function(e) {
      return new GLTFMaterialsClearcoatExtension$1(e);
    }), this.register(function(e) {
      return new GLTFTextureBasisUExtension$1(e);
    }), this.register(function(e) {
      return new GLTFTextureWebPExtension$1(e);
    }), this.register(function(e) {
      return new GLTFTextureAVIFExtension$1(e);
    }), this.register(function(e) {
      return new GLTFMaterialsSheenExtension$1(e);
    }), this.register(function(e) {
      return new GLTFMaterialsTransmissionExtension$1(e);
    }), this.register(function(e) {
      return new GLTFMaterialsVolumeExtension$1(e);
    }), this.register(function(e) {
      return new GLTFMaterialsIorExtension$1(e);
    }), this.register(function(e) {
      return new GLTFMaterialsEmissiveStrengthExtension$1(e);
    }), this.register(function(e) {
      return new GLTFMaterialsSpecularExtension$1(e);
    }), this.register(function(e) {
      return new GLTFMaterialsIridescenceExtension$1(e);
    }), this.register(function(e) {
      return new GLTFMaterialsAnisotropyExtension$1(e);
    }), this.register(function(e) {
      return new GLTFLightsExtension$1(e);
    }), this.register(function(e) {
      return new GLTFMeshoptCompression$1(e);
    }), this.register(function(e) {
      return new GLTFMeshGpuInstancing$1(e);
    }), this.register(function(e) {
      return new GLTFMeshFeaturesExtension(e);
    }), this.register(function(e) {
      return new GLTFStructuralMetadataExtension(e);
    }), this.register(function(e) {
      return new GLTFCesiumRTCExtension(e);
    });
  }
  load(i, e, r, s) {
    const a = this;
    let c;
    this.resourcePath !== "" ? c = this.resourcePath : this.path !== "" ? c = this.path : c = LoaderUtils.extractUrlBase(i), this.manager.itemStart(i);
    const l = function(d) {
      s ? s(d) : console.error(d), a.manager.itemError(i), a.manager.itemEnd(i);
    }, h = new FileLoader(this.manager);
    h.setPath(this.path), h.setResponseType("arraybuffer"), h.setRequestHeader(this.requestHeader), h.setWithCredentials(this.withCredentials), h.load(i, function(d) {
      try {
        a.parse(d, c, function(f) {
          e(f), a.manager.itemEnd(i);
        }, l);
      } catch (f) {
        l(f);
      }
    }, r, l);
  }
  setForceUnlit(i) {
    return this.forceUnlit = i, this;
  }
  setDRACOLoader(i) {
    return this.dracoLoader = i, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(i) {
    return this.ktx2Loader = i, this;
  }
  setMeshoptDecoder(i) {
    return this.meshoptDecoder = i, this;
  }
  register(i) {
    return this.pluginCallbacks.indexOf(i) === -1 && this.pluginCallbacks.push(i), this;
  }
  unregister(i) {
    return this.pluginCallbacks.indexOf(i) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(i), 1), this;
  }
  parse(i, e, r, s) {
    let a;
    const c = {}, l = {}, h = new TextDecoder();
    if (typeof i == "string")
      a = JSON.parse(i);
    else if (i instanceof ArrayBuffer) {
      const f = h.decode(new Uint8Array(i, 0, 4));
      if (f === BINARY_EXTENSION_HEADER_MAGIC$1 || f === BINARY_EXTENSION_ENCRYPT_FLAG) {
        try {
          c[EXTENSIONS$1.KHR_BINARY_GLTF] = new GLTFBinaryExtension$1(i);
        } catch (p) {
          s && s(p);
          return;
        }
        a = JSON.parse(c[EXTENSIONS$1.KHR_BINARY_GLTF].content);
      } else
        a = JSON.parse(h.decode(i));
    } else
      a = i;
    if (a.asset === void 0 || a.asset.version[0] < 2) {
      s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const d = new GLTFParser$1(a, {
      path: e || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
      forceUnlit: this.forceUnlit
    });
    d.fileLoader.setRequestHeader(this.requestHeader);
    for (let f = 0; f < this.pluginCallbacks.length; f++) {
      const p = this.pluginCallbacks[f](d);
      l[p.name] = p, c[p.name] = !0;
    }
    if (a.extensionsUsed)
      for (let f = 0; f < a.extensionsUsed.length; ++f) {
        const p = a.extensionsUsed[f], m = a.extensionsRequired || [];
        switch (p) {
          case EXTENSIONS$1.KHR_MATERIALS_UNLIT:
            c[p] = new GLTFMaterialsUnlitExtension$1();
            break;
          case EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION:
            c[p] = new GLTFDracoMeshCompressionExtension$1(a, this.dracoLoader);
            break;
          case EXTENSIONS$1.KHR_TEXTURE_TRANSFORM:
            c[p] = new GLTFTextureTransformExtension$1();
            break;
          case EXTENSIONS$1.KHR_MESH_QUANTIZATION:
            c[p] = new GLTFMeshQuantizationExtension$1();
            break;
          case EXTENSIONS$1.KHR_TEXTURE_BASISU:
            c[p] = new GLTFTextureBasisUExtension$1(d);
            break;
          default:
            m.indexOf(p) >= 0 && l[p] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + p + '".');
        }
      }
    if (a.textures)
      for (let f = 0, p = a.textures.length; f < p; f++) {
        const m = a.textures[f];
        m.extensions && m.extensions.KHR_texture_basisu && typeof m.extensions.KHR_texture_basisu.source == "number" && (m.source = m.source || m.extensions.KHR_texture_basisu.source), a.images[m.source].mimeType === "image/ktx2" && (c.KHR_texture_basisu = new GLTFTextureBasisUExtension$1(
          d
        ), a.textures[f].extensions = {
          KHR_texture_basisu: m
        });
      }
    this.forceUnlit && (c.KHR_materials_unlit = new GLTFMaterialsUnlitExtension$1()), d.setExtensions(c), d.setPlugins(l), d.parse(r, s);
  }
  parseAsync(i, e) {
    const r = this;
    return new Promise(function(s, a) {
      r.parse(i, e, s, a);
    });
  }
}
function GLTFRegistry$1() {
  let o = {};
  return {
    get: function(i) {
      return o[i];
    },
    add: function(i, e) {
      o[i] = e;
    },
    remove: function(i) {
      delete o[i];
    },
    removeAll: function() {
      o = {};
    }
  };
}
const EXTENSIONS$1 = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class GLTFLightsExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const i = this.parser, e = this.parser.json.nodes || [];
    for (let r = 0, s = e.length; r < s; r++) {
      const a = e[r];
      a.extensions && a.extensions[this.name] && a.extensions[this.name].light !== void 0 && i._addNodeRef(this.cache, a.extensions[this.name].light);
    }
  }
  _loadLight(i) {
    const e = this.parser, r = "light:" + i;
    let s = e.cache.get(r);
    if (s)
      return s;
    const a = e.json, h = ((a.extensions && a.extensions[this.name] || {}).lights || [])[i];
    let d;
    const f = new Color(16777215);
    h.color !== void 0 && f.fromArray(h.color);
    const p = h.range !== void 0 ? h.range : 0;
    switch (h.type) {
      case "directional":
        d = new DirectionalLight(f), d.target.position.set(0, 0, -1), d.add(d.target);
        break;
      case "point":
        d = new PointLight(f), d.distance = p;
        break;
      case "spot":
        d = new SpotLight(f), d.distance = p, h.spot = h.spot || {}, h.spot.innerConeAngle = h.spot.innerConeAngle !== void 0 ? h.spot.innerConeAngle : 0, h.spot.outerConeAngle = h.spot.outerConeAngle !== void 0 ? h.spot.outerConeAngle : Math.PI / 4, d.angle = h.spot.outerConeAngle, d.penumbra = 1 - h.spot.innerConeAngle / h.spot.outerConeAngle, d.target.position.set(0, 0, -1), d.add(d.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + h.type);
    }
    return d.position.set(0, 0, 0), d.decay = 2, assignExtrasToUserData$1(d, h), h.intensity !== void 0 && (d.intensity = h.intensity), d.name = e.createUniqueName(h.name || "light_" + i), s = Promise.resolve(d), e.cache.add(r, s), s;
  }
  getDependency(i, e) {
    if (i === "light")
      return this._loadLight(e);
  }
  createNodeAttachment(i) {
    const e = this, r = this.parser, a = r.json.nodes[i], l = (a.extensions && a.extensions[this.name] || {}).light;
    return l === void 0 ? null : this._loadLight(l).then(function(h) {
      return r._getNodeRef(e.cache, l, h);
    });
  }
}
class GLTFMaterialsUnlitExtension$1 {
  constructor() {
    this.name = EXTENSIONS$1.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(i, e, r) {
    const s = [];
    i.color = new Color(1, 1, 1), i.opacity = 1;
    const a = e.pbrMetallicRoughness;
    if (a) {
      if (Array.isArray(a.baseColorFactor)) {
        const c = a.baseColorFactor;
        i.color.fromArray(c), i.opacity = c[3];
      }
      a.baseColorTexture !== void 0 && s.push(r.assignTexture(i, "map", a.baseColorTexture, SRGBColorSpace));
    }
    return Promise.all(s);
  }
}
class GLTFMaterialsEmissiveStrengthExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(i, e) {
    const s = this.parser.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = s.extensions[this.name].emissiveStrength;
    return a !== void 0 && (e.emissiveIntensity = a), Promise.resolve();
  }
}
class GLTFMaterialsClearcoatExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    if (c.clearcoatFactor !== void 0 && (e.clearcoat = c.clearcoatFactor), c.clearcoatTexture !== void 0 && a.push(r.assignTexture(e, "clearcoatMap", c.clearcoatTexture)), c.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = c.clearcoatRoughnessFactor), c.clearcoatRoughnessTexture !== void 0 && a.push(r.assignTexture(e, "clearcoatRoughnessMap", c.clearcoatRoughnessTexture)), c.clearcoatNormalTexture !== void 0 && (a.push(r.assignTexture(e, "clearcoatNormalMap", c.clearcoatNormalTexture)), c.clearcoatNormalTexture.scale !== void 0)) {
      const l = c.clearcoatNormalTexture.scale;
      e.clearcoatNormalScale = new Vector2$1(l, l);
    }
    return Promise.all(a);
  }
}
class GLTFMaterialsIridescenceExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    return c.iridescenceFactor !== void 0 && (e.iridescence = c.iridescenceFactor), c.iridescenceTexture !== void 0 && a.push(r.assignTexture(e, "iridescenceMap", c.iridescenceTexture)), c.iridescenceIor !== void 0 && (e.iridescenceIOR = c.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [100, 400]), c.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = c.iridescenceThicknessMinimum), c.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = c.iridescenceThicknessMaximum), c.iridescenceThicknessTexture !== void 0 && a.push(r.assignTexture(e, "iridescenceThicknessMap", c.iridescenceThicknessTexture)), Promise.all(a);
  }
}
class GLTFMaterialsSheenExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [];
    e.sheenColor = new Color(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
    const c = s.extensions[this.name];
    return c.sheenColorFactor !== void 0 && e.sheenColor.fromArray(c.sheenColorFactor), c.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = c.sheenRoughnessFactor), c.sheenColorTexture !== void 0 && a.push(r.assignTexture(e, "sheenColorMap", c.sheenColorTexture, SRGBColorSpace)), c.sheenRoughnessTexture !== void 0 && a.push(r.assignTexture(e, "sheenRoughnessMap", c.sheenRoughnessTexture)), Promise.all(a);
  }
}
class GLTFMaterialsTransmissionExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    return c.transmissionFactor !== void 0 && (e.transmission = c.transmissionFactor), c.transmissionTexture !== void 0 && a.push(r.assignTexture(e, "transmissionMap", c.transmissionTexture)), Promise.all(a);
  }
}
class GLTFMaterialsVolumeExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    e.thickness = c.thicknessFactor !== void 0 ? c.thicknessFactor : 0, c.thicknessTexture !== void 0 && a.push(r.assignTexture(e, "thicknessMap", c.thicknessTexture)), e.attenuationDistance = c.attenuationDistance || 1 / 0;
    const l = c.attenuationColor || [1, 1, 1];
    return e.attenuationColor = new Color(l[0], l[1], l[2]), Promise.all(a);
  }
}
class GLTFMaterialsIorExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_MATERIALS_IOR;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const s = this.parser.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = s.extensions[this.name];
    return e.ior = a.ior !== void 0 ? a.ior : 1.5, Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    e.specularIntensity = c.specularFactor !== void 0 ? c.specularFactor : 1, c.specularTexture !== void 0 && a.push(r.assignTexture(e, "specularIntensityMap", c.specularTexture));
    const l = c.specularColorFactor || [1, 1, 1];
    return e.specularColor = new Color(l[0], l[1], l[2]), c.specularColorTexture !== void 0 && a.push(r.assignTexture(e, "specularColorMap", c.specularColorTexture, SRGBColorSpace)), Promise.all(a);
  }
}
class GLTFMaterialsAnisotropyExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    return c.anisotropyStrength !== void 0 && (e.anisotropy = c.anisotropyStrength), c.anisotropyRotation !== void 0 && (e.anisotropyRotation = c.anisotropyRotation), c.anisotropyTexture !== void 0 && a.push(r.assignTexture(e, "anisotropyMap", c.anisotropyTexture)), Promise.all(a);
  }
}
class GLTFTextureBasisUExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.KHR_TEXTURE_BASISU;
  }
  loadTexture(i) {
    const e = this.parser, r = e.json, s = r.textures[i];
    if (!s.extensions || !s.extensions[this.name])
      return null;
    const a = s.extensions[this.name], c = e.options.ktx2Loader;
    if (!c) {
      if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return e.loadTextureImage(i, a.source, c);
  }
}
class GLTFTextureWebPExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(i) {
    const e = this.name, r = this.parser, s = r.json, a = s.textures[i];
    if (!a.extensions || !a.extensions[e])
      return null;
    const c = a.extensions[e], l = s.images[c.source];
    let h = r.textureLoader;
    if (l.uri) {
      const d = r.options.manager.getHandler(l.uri);
      d !== null && (h = d);
    }
    return this.detectSupport().then(function(d) {
      if (d)
        return r.loadTextureImage(i, c.source, h);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(e) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return r.loadTexture(i);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(i) {
      const e = new Image();
      e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
        i(e.height === 1);
      };
    })), this.isSupported;
  }
}
class GLTFTextureAVIFExtension$1 {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS$1.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(i) {
    const e = this.name, r = this.parser, s = r.json, a = s.textures[i];
    if (!a.extensions || !a.extensions[e])
      return null;
    const c = a.extensions[e], l = s.images[c.source];
    let h = r.textureLoader;
    if (l.uri) {
      const d = r.options.manager.getHandler(l.uri);
      d !== null && (h = d);
    }
    return this.detectSupport().then(function(d) {
      if (d)
        return r.loadTextureImage(i, c.source, h);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(e) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return r.loadTexture(i);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(i) {
      const e = new Image();
      e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function() {
        i(e.height === 1);
      };
    })), this.isSupported;
  }
}
class GLTFMeshoptCompression$1 {
  constructor(i) {
    this.name = EXTENSIONS$1.EXT_MESHOPT_COMPRESSION, this.parser = i;
  }
  loadBufferView(i) {
    const e = this.parser.json, r = e.bufferViews[i];
    if (r.extensions && r.extensions[this.name]) {
      const s = r.extensions[this.name], a = this.parser.getDependency("buffer", s.buffer), c = this.parser.options.meshoptDecoder;
      if (!c || !c.supported) {
        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return a.then(function(l) {
        const h = s.byteOffset || 0, d = s.byteLength || 0, f = s.count, p = s.byteStride, m = new Uint8Array(l, h, d);
        return c.decodeGltfBufferAsync ? c.decodeGltfBufferAsync(f, p, m, s.mode, s.filter).then(function(y) {
          return y.buffer;
        }) : c.ready.then(function() {
          const y = new ArrayBuffer(f * p);
          return c.decodeGltfBuffer(new Uint8Array(y), f, p, m, s.mode, s.filter), y;
        });
      });
    }
    return null;
  }
}
class GLTFMeshGpuInstancing$1 {
  constructor(i) {
    this.name = EXTENSIONS$1.EXT_MESH_GPU_INSTANCING, this.parser = i;
  }
  createNodeMesh(i) {
    const e = this.parser.json, r = e.nodes[i];
    if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0)
      return null;
    const s = e.meshes[r.mesh];
    for (const d of s.primitives)
      if (d.mode !== WEBGL_CONSTANTS$1.TRIANGLES && d.mode !== WEBGL_CONSTANTS$1.TRIANGLE_STRIP && d.mode !== WEBGL_CONSTANTS$1.TRIANGLE_FAN && d.mode !== void 0)
        return null;
    const c = r.extensions[this.name].attributes, l = [], h = {};
    for (const d in c)
      l.push(this.parser.getDependency("accessor", c[d]).then((f) => (h[d] = f, h[d])));
    return l.length < 1 ? null : (l.push(this.parser.createNodeMesh(i)), Promise.all(l).then((d) => {
      const f = d.pop(), p = f.isGroup ? f.children : [f], m = d[0].count, y = [];
      for (const x of p) {
        const v = new Matrix4(), S = new Vector3$1(), E = new Quaternion$1(), b = new Vector3$1(1, 1, 1), w = new InstancedMesh(x.geometry, x.material, m);
        for (let M = 0; M < m; M++)
          h.TRANSLATION && S.fromBufferAttribute(h.TRANSLATION, M), h.ROTATION && E.fromBufferAttribute(h.ROTATION, M), h.SCALE && b.fromBufferAttribute(h.SCALE, M), w.setMatrixAt(M, v.compose(S, E, b));
        for (const M in h)
          M !== "TRANSLATION" && M !== "ROTATION" && M !== "SCALE" && x.geometry.setAttribute(M, h[M]);
        Object3D.prototype.copy.call(w, x), this.parser.assignFinalMaterial(w), y.push(w);
      }
      return f.isGroup ? (f.clear(), f.add(...y), f) : y[0];
    }));
  }
}
const BINARY_EXTENSION_ENCRYPT_FLAG = "embf", BINARY_EXTENSION_HEADER_MAGIC$1 = "glTF", BINARY_EXTENSION_HEADER_LENGTH$1 = 12, BINARY_EXTENSION_CHUNK_TYPES$1 = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension$1 {
  constructor(i) {
    this.name = EXTENSIONS$1.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const e = new TextDecoder();
    let r = 0;
    if (e.decode(new Uint8Array(i.slice(0, 4))) === BINARY_EXTENSION_ENCRYPT_FLAG && new Uint8Array(i, 4, 1)[0] === 1) {
      const f = new Uint8Array(i, 5, 1)[0];
      r = 4 + 1 + 1 + f;
    }
    const a = new DataView(i, r, BINARY_EXTENSION_HEADER_LENGTH$1);
    if (this.header = {
      magic: e.decode(new Uint8Array(i.slice(r, r + 4))),
      version: a.getUint32(4, !0),
      length: a.getUint32(8, !0)
    }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC$1)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const c = this.header.length - BINARY_EXTENSION_HEADER_LENGTH$1 + r, l = new DataView(i, BINARY_EXTENSION_HEADER_LENGTH$1);
    let h = r;
    for (; h < c; ) {
      const d = l.getUint32(h, !0);
      h += 4;
      const f = l.getUint32(h, !0);
      if (h += 4, f === BINARY_EXTENSION_CHUNK_TYPES$1.JSON) {
        const p = new Uint8Array(i, BINARY_EXTENSION_HEADER_LENGTH$1 + h, d);
        this.content = e.decode(p);
      } else if (f === BINARY_EXTENSION_CHUNK_TYPES$1.BIN) {
        const p = BINARY_EXTENSION_HEADER_LENGTH$1 + h;
        this.body = i.slice(p, p + d);
      }
      h += d;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class GLTFDracoMeshCompressionExtension$1 {
  constructor(i, e) {
    if (!e)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION, this.json = i, this.dracoLoader = e, this.dracoLoader.preload();
  }
  decodePrimitive(i, e) {
    const r = this.json, s = this.dracoLoader, a = i.extensions[this.name].bufferView, c = i.extensions[this.name].attributes, l = {}, h = {}, d = {};
    for (const f in c) {
      const p = ATTRIBUTES$1[f] || f.toLowerCase();
      l[p] = c[f];
    }
    for (const f in i.attributes) {
      const p = ATTRIBUTES$1[f] || f.toLowerCase();
      if (c[f] !== void 0) {
        const m = r.accessors[i.attributes[f]], y = WEBGL_COMPONENT_TYPES$1[m.componentType];
        d[p] = y.name, h[p] = m.normalized === !0;
      }
    }
    return e.getDependency("bufferView", a).then(function(f) {
      return new Promise(function(p) {
        s.decodeDracoFile(f, function(m) {
          for (const y in m.attributes) {
            const x = m.attributes[y], v = h[y];
            v !== void 0 && (x.normalized = v);
          }
          p(m);
        }, l, d);
      });
    });
  }
}
class GLTFTextureTransformExtension$1 {
  constructor() {
    this.name = EXTENSIONS$1.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(i, e) {
    return (e.texCoord === void 0 || e.texCoord === i.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (i = i.clone(), e.texCoord !== void 0 && (i.channel = e.texCoord), e.offset !== void 0 && i.offset.fromArray(e.offset), e.rotation !== void 0 && (i.rotation = e.rotation), e.scale !== void 0 && i.repeat.fromArray(e.scale), i.needsUpdate = !0), i;
  }
}
class GLTFMeshQuantizationExtension$1 {
  constructor() {
    this.name = EXTENSIONS$1.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant$1 extends Interpolant {
  constructor(i, e, r, s) {
    super(i, e, r, s);
  }
  copySampleValue_(i) {
    const e = this.resultBuffer, r = this.sampleValues, s = this.valueSize, a = i * s * 3 + s;
    for (let c = 0; c !== s; c++)
      e[c] = r[a + c];
    return e;
  }
  interpolate_(i, e, r, s) {
    const a = this.resultBuffer, c = this.sampleValues, l = this.valueSize, h = l * 2, d = l * 3, f = s - e, p = (r - e) / f, m = p * p, y = m * p, x = i * d, v = x - d, S = -2 * y + 3 * m, E = y - m, b = 1 - S, w = E - m + p;
    for (let M = 0; M !== l; M++) {
      const P = c[v + M + l], D = c[v + M + h] * f, L = c[x + M + l], O = c[x + M] * f;
      a[M] = b * P + w * D + S * L + E * O;
    }
    return a;
  }
}
const _q = new Quaternion$1();
class GLTFCubicSplineQuaternionInterpolant$1 extends GLTFCubicSplineInterpolant$1 {
  interpolate_(i, e, r, s) {
    const a = super.interpolate_(i, e, r, s);
    return _q.fromArray(a).normalize().toArray(a), a;
  }
}
const WEBGL_CONSTANTS$1 = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, WEBGL_COMPONENT_TYPES$1 = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, WEBGL_FILTERS$1 = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
}, WEBGL_WRAPPINGS$1 = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
}, WEBGL_TYPE_SIZES$1 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, ATTRIBUTES$1 = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, PATH_PROPERTIES$1 = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, INTERPOLATION$1 = {
  CUBICSPLINE: void 0,
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
}, ALPHA_MODES$1 = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial$1(o) {
  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new MeshStandardMaterial({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: FrontSide
  })), o.DefaultMaterial;
}
function addUnknownExtensionsToUserData$1(o, i, e) {
  for (const r in e.extensions)
    o[r] === void 0 && (i.userData.gltfExtensions = i.userData.gltfExtensions || {}, i.userData.gltfExtensions[r] = e.extensions[r]);
}
function assignExtrasToUserData$1(o, i) {
  i.extras !== void 0 && (typeof i.extras == "object" ? Object.assign(o.userData, i.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + i.extras));
}
function addMorphTargets$1(o, i, e) {
  let r = !1, s = !1, a = !1;
  for (let d = 0, f = i.length; d < f; d++) {
    const p = i[d];
    if (p.POSITION !== void 0 && (r = !0), p.NORMAL !== void 0 && (s = !0), p.COLOR_0 !== void 0 && (a = !0), r && s && a)
      break;
  }
  if (!r && !s && !a)
    return Promise.resolve(o);
  const c = [], l = [], h = [];
  for (let d = 0, f = i.length; d < f; d++) {
    const p = i[d];
    if (r) {
      const m = p.POSITION !== void 0 ? e.getDependency("accessor", p.POSITION) : o.attributes.position;
      c.push(m);
    }
    if (s) {
      const m = p.NORMAL !== void 0 ? e.getDependency("accessor", p.NORMAL) : o.attributes.normal;
      l.push(m);
    }
    if (a) {
      const m = p.COLOR_0 !== void 0 ? e.getDependency("accessor", p.COLOR_0) : o.attributes.color;
      h.push(m);
    }
  }
  return Promise.all([
    Promise.all(c),
    Promise.all(l),
    Promise.all(h)
  ]).then(function(d) {
    const f = d[0], p = d[1], m = d[2];
    return r && (o.morphAttributes.position = f), s && (o.morphAttributes.normal = p), a && (o.morphAttributes.color = m), o.morphTargetsRelative = !0, o;
  });
}
function updateMorphTargets$1(o, i) {
  if (o.updateMorphTargets(), i.weights !== void 0)
    for (let e = 0, r = i.weights.length; e < r; e++)
      o.morphTargetInfluences[e] = i.weights[e];
  if (i.extras && Array.isArray(i.extras.targetNames)) {
    const e = i.extras.targetNames;
    if (o.morphTargetInfluences.length === e.length) {
      o.morphTargetDictionary = {};
      for (let r = 0, s = e.length; r < s; r++)
        o.morphTargetDictionary[e[r]] = r;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function createPrimitiveKey$1(o) {
  let i;
  const e = o.extensions && o.extensions[EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION];
  if (e ? i = "draco:" + e.bufferView + ":" + e.indices + ":" + createAttributesKey$1(e.attributes) : i = o.indices + ":" + createAttributesKey$1(o.attributes) + ":" + o.mode, o.targets !== void 0)
    for (let r = 0, s = o.targets.length; r < s; r++)
      i += ":" + createAttributesKey$1(o.targets[r]);
  return i;
}
function createAttributesKey$1(o) {
  let i = "";
  const e = Object.keys(o).sort();
  for (let r = 0, s = e.length; r < s; r++)
    i += e[r] + ":" + o[e[r]] + ";";
  return i;
}
function getNormalizedComponentScale$1(o) {
  switch (o) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType$1(o) {
  return o.search(/\.jpe?g($|\?)/i) > 0 || o.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : o.search(/\.webp($|\?)/i) > 0 || o.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const _identityMatrix$1 = new Matrix4();
class GLTFParser$1 {
  constructor(i = {}, e = {}) {
    this.json = i, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new GLTFRegistry$1(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let r = !1, s = !1, a = -1;
    typeof navigator < "u" && (r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf("Firefox") > -1, a = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r || s && a < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(i) {
    this.extensions = i;
  }
  setPlugins(i) {
    this.plugins = i;
  }
  parse(i, e) {
    const r = this, s = this.json, a = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(c) {
      return c._markDefs && c._markDefs();
    }), Promise.all(this._invokeAll(function(c) {
      return c.beforeRoot && c.beforeRoot();
    })).then(function() {
      return Promise.all([
        r.getDependencies("scene"),
        r.getDependencies("animation"),
        r.getDependencies("camera")
      ]);
    }).then(function(c) {
      const l = {
        scene: c[0][s.scene || 0],
        scenes: c[0],
        animations: c[1],
        cameras: c[2],
        asset: s.asset,
        parser: r,
        userData: {}
      };
      addUnknownExtensionsToUserData$1(a, l, s), assignExtrasToUserData$1(l, s), Promise.all(r._invokeAll(function(h) {
        return h.afterRoot && h.afterRoot(l);
      })).then(function() {
        i(l);
      });
    }).catch(e);
  }
  _markDefs() {
    const i = this.json.nodes || [], e = this.json.skins || [], r = this.json.meshes || [];
    for (let s = 0, a = e.length; s < a; s++) {
      const c = e[s].joints;
      for (let l = 0, h = c.length; l < h; l++)
        i[c[l]].isBone = !0;
    }
    for (let s = 0, a = i.length; s < a; s++) {
      const c = i[s];
      c.mesh !== void 0 && (this._addNodeRef(this.meshCache, c.mesh), c.skin !== void 0 && (r[c.mesh].isSkinnedMesh = !0)), c.camera !== void 0 && this._addNodeRef(this.cameraCache, c.camera);
    }
  }
  _addNodeRef(i, e) {
    e !== void 0 && (i.refs[e] === void 0 && (i.refs[e] = i.uses[e] = 0), i.refs[e]++);
  }
  _getNodeRef(i, e, r) {
    if (i.refs[e] <= 1)
      return r;
    const s = r.clone(), a = (c, l) => {
      const h = this.associations.get(c);
      h != null && this.associations.set(l, h);
      for (const [d, f] of c.children.entries())
        a(f, l.children[d]);
    };
    return a(r, s), s.name += "_instance_" + i.uses[e]++, s;
  }
  _invokeOne(i) {
    const e = Object.values(this.plugins);
    e.push(this);
    for (let r = 0; r < e.length; r++) {
      const s = i(e[r]);
      if (s)
        return s;
    }
    return null;
  }
  _invokeAll(i) {
    const e = Object.values(this.plugins);
    e.unshift(this);
    const r = [];
    for (let s = 0; s < e.length; s++) {
      const a = i(e[s]);
      a && r.push(a);
    }
    return r;
  }
  getDependency(i, e) {
    const r = i + ":" + e;
    let s = this.cache.get(r);
    if (!s) {
      switch (i) {
        case "scene":
          s = this.loadScene(e);
          break;
        case "node":
          s = this._invokeOne(function(a) {
            return a.loadNode && a.loadNode(e);
          });
          break;
        case "mesh":
          s = this._invokeOne(function(a) {
            return a.loadMesh && a.loadMesh(e);
          });
          break;
        case "accessor":
          s = this.loadAccessor(e);
          break;
        case "bufferView":
          s = this._invokeOne(function(a) {
            return a.loadBufferView && a.loadBufferView(e);
          });
          break;
        case "buffer":
          s = this.loadBuffer(e);
          break;
        case "material":
          s = this._invokeOne(function(a) {
            return a.loadMaterial && a.loadMaterial(e);
          });
          break;
        case "texture":
          s = this._invokeOne(function(a) {
            return a.loadTexture && a.loadTexture(e);
          });
          break;
        case "skin":
          s = this.loadSkin(e);
          break;
        case "animation":
          s = this._invokeOne(function(a) {
            return a.loadAnimation && a.loadAnimation(e);
          });
          break;
        case "camera":
          s = this.loadCamera(e);
          break;
        default:
          if (s = this._invokeOne(function(a) {
            return a != this && a.getDependency && a.getDependency(i, e);
          }), !s)
            throw new Error("Unknown type: " + i);
          break;
      }
      this.cache.add(r, s);
    }
    return s;
  }
  getDependencies(i) {
    let e = this.cache.get(i);
    if (!e) {
      const r = this, s = this.json[i + (i === "mesh" ? "es" : "s")] || [];
      e = Promise.all(s.map(function(a, c) {
        return r.getDependency(i, c);
      })), this.cache.add(i, e);
    }
    return e;
  }
  loadBuffer(i) {
    const e = this.json.buffers[i], r = this.fileLoader;
    if (e.type && e.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
    if (e.uri === void 0 && i === 0)
      return Promise.resolve(this.extensions[EXTENSIONS$1.KHR_BINARY_GLTF].body);
    const s = this.options;
    return new Promise(function(a, c) {
      r.load(LoaderUtils.resolveURL(e.uri, s.path), a, void 0, function() {
        c(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
      });
    });
  }
  loadBufferView(i) {
    const e = this.json.bufferViews[i];
    return this.getDependency("buffer", e.buffer).then(function(r) {
      const s = e.byteLength || 0, a = e.byteOffset || 0;
      return r.slice(a, a + s);
    });
  }
  loadAccessor(i) {
    const e = this, r = this.json, s = this.json.accessors[i];
    if (s.bufferView === void 0 && s.sparse === void 0) {
      const c = WEBGL_TYPE_SIZES$1[s.type], l = WEBGL_COMPONENT_TYPES$1[s.componentType], h = s.normalized === !0, d = new l(s.count * c);
      return Promise.resolve(new BufferAttribute(d, c, h));
    }
    const a = [];
    return s.bufferView !== void 0 ? a.push(this.getDependency("bufferView", s.bufferView)) : a.push(null), s.sparse !== void 0 && (a.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), a.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(a).then(function(c) {
      const l = c[0], h = WEBGL_TYPE_SIZES$1[s.type], d = WEBGL_COMPONENT_TYPES$1[s.componentType], f = d.BYTES_PER_ELEMENT, p = f * h, m = s.byteOffset || 0, y = s.bufferView !== void 0 ? r.bufferViews[s.bufferView].byteStride : void 0, x = s.normalized === !0;
      let v, S;
      if (y && y !== p) {
        const E = Math.floor(m / y), b = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + E + ":" + s.count;
        let w = e.cache.get(b);
        w || (v = new d(l, E * y, s.count * y / f), w = new InterleavedBuffer(v, y / f), e.cache.add(b, w)), S = new InterleavedBufferAttribute(w, h, m % y / f, x);
      } else
        l === null ? v = new d(s.count * h) : v = new d(l, m, s.count * h), S = new BufferAttribute(v, h, x);
      if (s.sparse !== void 0) {
        const E = WEBGL_TYPE_SIZES$1.SCALAR, b = WEBGL_COMPONENT_TYPES$1[s.sparse.indices.componentType], w = s.sparse.indices.byteOffset || 0, M = s.sparse.values.byteOffset || 0, P = new b(c[1], w, s.sparse.count * E), D = new d(c[2], M, s.sparse.count * h);
        l !== null && (S = new BufferAttribute(S.array.slice(), S.itemSize, S.normalized));
        for (let L = 0, O = P.length; L < O; L++) {
          const F = P[L];
          if (S.setX(F, D[L * h]), h >= 2 && S.setY(F, D[L * h + 1]), h >= 3 && S.setZ(F, D[L * h + 2]), h >= 4 && S.setW(F, D[L * h + 3]), h >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return S;
    });
  }
  loadTexture(i) {
    const e = this.json, r = this.options, a = e.textures[i].source, c = e.images[a], l = this.extensions;
    let h = this.textureLoader;
    if (c.mimeType === "image/ktx2" && l[EXTENSIONS$1.KHR_TEXTURE_BASISU])
      return l[EXTENSIONS$1.KHR_TEXTURE_BASISU].loadTexture(
        i
      );
    if (c.uri) {
      const d = r.manager.getHandler(c.uri);
      d !== null && (h = d);
    }
    return this.loadTextureImage(i, a, h);
  }
  loadTextureImage(i, e, r) {
    const s = this, a = this.json, c = a.textures[i], l = a.images[e], h = (l.uri || l.bufferView) + ":" + c.sampler;
    if (this.textureCache[h])
      return this.textureCache[h];
    const d = this.loadImageSource(e, r).then(function(f) {
      f.flipY = !1, f.name = c.name || l.name || "", f.name === "" && typeof l.uri == "string" && l.uri.startsWith("data:image/") === !1 && (f.name = l.uri);
      const m = (a.samplers || {})[c.sampler] || {};
      return f.magFilter = WEBGL_FILTERS$1[m.magFilter] || LinearFilter, f.minFilter = WEBGL_FILTERS$1[m.minFilter] || LinearMipmapLinearFilter, f.wrapS = WEBGL_WRAPPINGS$1[m.wrapS] || RepeatWrapping, f.wrapT = WEBGL_WRAPPINGS$1[m.wrapT] || RepeatWrapping, s.associations.set(f, { textures: i }), f;
    }).catch(function() {
      return null;
    });
    return this.textureCache[h] = d, d;
  }
  loadImageSource(i, e) {
    const r = this, s = this.json, a = this.options;
    if (this.sourceCache[i] !== void 0)
      return this.sourceCache[i].then((p) => p.clone());
    const c = s.images[i], l = self.URL || self.webkitURL;
    let h = c.uri || "", d = !1;
    if (c.bufferView !== void 0)
      h = r.getDependency("bufferView", c.bufferView).then(function(p) {
        d = !0;
        const m = new Blob([p], { type: c.mimeType });
        return h = l.createObjectURL(m), h;
      });
    else if (c.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + i + " is missing URI and bufferView");
    const f = Promise.resolve(h).then(function(p) {
      return new Promise(function(m, y) {
        let x = m;
        e.isImageBitmapLoader === !0 && (x = function(v) {
          const S = new Texture(v);
          S.needsUpdate = !0, m(S);
        }), e.load(LoaderUtils.resolveURL(p, a.path), x, void 0, y);
      });
    }).then(function(p) {
      return d === !0 && l.revokeObjectURL(h), p.userData.mimeType = c.mimeType || getImageURIMimeType$1(c.uri), p;
    }).catch(function(p) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", h), p;
    });
    return this.sourceCache[i] = f, f;
  }
  assignTexture(i, e, r, s) {
    const a = this;
    return this.getDependency("texture", r.index).then(function(c) {
      if (!c)
        return null;
      if (r.texCoord !== void 0 && r.texCoord > 0 && (c = c.clone(), c.channel = r.texCoord), a.extensions[EXTENSIONS$1.KHR_TEXTURE_TRANSFORM]) {
        const l = r.extensions !== void 0 ? r.extensions[EXTENSIONS$1.KHR_TEXTURE_TRANSFORM] : void 0;
        if (l) {
          const h = a.associations.get(c);
          c = a.extensions[EXTENSIONS$1.KHR_TEXTURE_TRANSFORM].extendTexture(c, l), a.associations.set(c, h);
        }
      }
      return s !== void 0 && (c.colorSpace = s), i[e] = c, c;
    });
  }
  assignFinalMaterial(i) {
    const e = i.geometry;
    let r = i.material;
    const s = e.attributes.tangent === void 0, a = e.attributes.color !== void 0, c = e.attributes.normal === void 0;
    if (i.isPoints) {
      const l = "PointsMaterial:" + r.uuid;
      let h = this.cache.get(l);
      h || (h = new PointsMaterial(), Material.prototype.copy.call(h, r), h.color.copy(r.color), h.map = r.map, h.sizeAttenuation = !1, this.cache.add(l, h)), r = h;
    } else if (i.isLine) {
      const l = "LineBasicMaterial:" + r.uuid;
      let h = this.cache.get(l);
      h || (h = new LineBasicMaterial(), Material.prototype.copy.call(h, r), h.color.copy(r.color), h.map = r.map, this.cache.add(l, h)), r = h;
    }
    if (s || a || c) {
      let l = "ClonedMaterial:" + r.uuid + ":";
      s && (l += "derivative-tangents:"), a && (l += "vertex-colors:"), c && (l += "flat-shading:");
      let h = this.cache.get(l);
      h || (h = r.clone(), a && (h.vertexColors = !0), c && (h.flatShading = !0), s && (h.normalScale && (h.normalScale.y *= -1), h.clearcoatNormalScale && (h.clearcoatNormalScale.y *= -1)), this.cache.add(l, h), this.associations.set(h, this.associations.get(r))), r = h;
    }
    i.material = r;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(i) {
    const e = this, r = this.json, s = this.extensions, a = r.materials[i];
    let c;
    const l = {}, h = a.extensions || {}, d = [];
    if (h[EXTENSIONS$1.KHR_MATERIALS_UNLIT] || e.options.forceUnlit) {
      const p = s[EXTENSIONS$1.KHR_MATERIALS_UNLIT];
      c = p.getMaterialType(), d.push(p.extendParams(l, a, e));
    } else {
      const p = a.pbrMetallicRoughness || {};
      if (l.color = new Color(1, 1, 1), l.opacity = 1, Array.isArray(p.baseColorFactor)) {
        const m = p.baseColorFactor;
        l.color.fromArray(m), l.opacity = m[3];
      }
      p.baseColorTexture !== void 0 && d.push(e.assignTexture(l, "map", p.baseColorTexture, SRGBColorSpace)), l.metalness = p.metallicFactor !== void 0 ? p.metallicFactor : 1, l.roughness = p.roughnessFactor !== void 0 ? p.roughnessFactor : 1, p.metallicRoughnessTexture !== void 0 && (d.push(e.assignTexture(l, "metalnessMap", p.metallicRoughnessTexture)), d.push(e.assignTexture(l, "roughnessMap", p.metallicRoughnessTexture))), c = this._invokeOne(function(m) {
        return m.getMaterialType && m.getMaterialType(i);
      }), d.push(Promise.all(this._invokeAll(function(m) {
        return m.extendMaterialParams && m.extendMaterialParams(i, l);
      })));
    }
    a.doubleSided === !0 && (l.side = DoubleSide);
    const f = a.alphaMode || ALPHA_MODES$1.OPAQUE;
    if (f === ALPHA_MODES$1.BLEND ? (l.transparent = !0, l.depthWrite = !1) : (l.transparent = !1, f === ALPHA_MODES$1.MASK && (l.alphaTest = a.alphaCutoff !== void 0 ? a.alphaCutoff : 0.5)), a.normalTexture !== void 0 && c !== MeshBasicMaterial && (d.push(e.assignTexture(l, "normalMap", a.normalTexture)), l.normalScale = new Vector2$1(1, 1), a.normalTexture.scale !== void 0)) {
      const p = a.normalTexture.scale;
      l.normalScale.set(p, p);
    }
    return a.occlusionTexture !== void 0 && c !== MeshBasicMaterial && (d.push(e.assignTexture(l, "aoMap", a.occlusionTexture)), a.occlusionTexture.strength !== void 0 && (l.aoMapIntensity = a.occlusionTexture.strength)), a.emissiveFactor !== void 0 && c !== MeshBasicMaterial && (l.emissive = new Color().fromArray(a.emissiveFactor)), a.emissiveTexture !== void 0 && c !== MeshBasicMaterial && d.push(e.assignTexture(l, "emissiveMap", a.emissiveTexture, SRGBColorSpace)), Promise.all(d).then(function() {
      const p = new c(l);
      return a.name && (p.name = a.name), assignExtrasToUserData$1(p, a), e.associations.set(p, { materials: i }), a.extensions && addUnknownExtensionsToUserData$1(s, p, a), p;
    });
  }
  createUniqueName(i) {
    const e = PropertyBinding.sanitizeNodeName(i || "");
    return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e);
  }
  loadGeometries(i) {
    const e = this, r = this.extensions, s = this.primitiveCache;
    function a(l) {
      return r[EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(l, e).then(function(h) {
        return addPrimitiveAttributes$1(h, l, e);
      });
    }
    const c = [];
    for (let l = 0, h = i.length; l < h; l++) {
      const d = i[l], f = createPrimitiveKey$1(d), p = s[f];
      if (p)
        c.push(p.promise);
      else {
        let m;
        d.extensions && d.extensions[EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION] ? m = a(d) : m = addPrimitiveAttributes$1(new BufferGeometry(), d, e), s[f] = { primitive: d, promise: m }, c.push(m);
      }
    }
    return Promise.all(c);
  }
  loadMesh(i) {
    const e = this, r = this.json, s = this.extensions, a = r.meshes[i], c = a.primitives, l = [];
    for (let h = 0, d = c.length; h < d; h++) {
      const f = c[h].material === void 0 ? createDefaultMaterial$1(this.cache) : this.getDependency("material", c[h].material);
      l.push(f);
    }
    return l.push(e.loadGeometries(c)), Promise.all(l).then(function(h) {
      const d = h.slice(0, h.length - 1), f = h[h.length - 1], p = [];
      for (let y = 0, x = f.length; y < x; y++) {
        const v = f[y], S = c[y];
        let E;
        const b = d[y];
        if (S.mode === WEBGL_CONSTANTS$1.TRIANGLES || S.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP || S.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN || S.mode === void 0)
          E = a.isSkinnedMesh === !0 ? new SkinnedMesh(v, b) : new Mesh(v, b), E.isSkinnedMesh === !0 && E.normalizeSkinWeights(), S.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ? E.geometry = toTrianglesDrawMode(E.geometry, TriangleStripDrawMode) : S.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN && (E.geometry = toTrianglesDrawMode(E.geometry, TriangleFanDrawMode));
        else if (S.mode === WEBGL_CONSTANTS$1.LINES)
          E = new LineSegments(v, b);
        else if (S.mode === WEBGL_CONSTANTS$1.LINE_STRIP)
          E = new Line(v, b);
        else if (S.mode === WEBGL_CONSTANTS$1.LINE_LOOP)
          E = new LineLoop(v, b);
        else if (S.mode === WEBGL_CONSTANTS$1.POINTS)
          E = new Points(v, b);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + S.mode);
        Object.keys(E.geometry.morphAttributes).length > 0 && updateMorphTargets$1(E, a), E.name = e.createUniqueName(a.name || "mesh_" + i), assignExtrasToUserData$1(E, a), S.extensions && addUnknownExtensionsToUserData$1(s, E, S), e.assignFinalMaterial(E), p.push(E);
      }
      for (let y = 0, x = p.length; y < x; y++)
        e.associations.set(p[y], {
          meshes: i,
          primitives: y
        });
      if (p.length === 1)
        return a.extensions && addUnknownExtensionsToUserData$1(s, p[0], a), p[0];
      const m = new Group();
      a.extensions && addUnknownExtensionsToUserData$1(s, m, a), e.associations.set(m, { meshes: i });
      for (let y = 0, x = p.length; y < x; y++)
        m.add(p[y]);
      return m;
    });
  }
  loadCamera(i) {
    let e;
    const r = this.json.cameras[i], s = r[r.type];
    if (!s) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return r.type === "perspective" ? e = new PerspectiveCamera(MathUtils.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : r.type === "orthographic" && (e = new OrthographicCamera(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), r.name && (e.name = this.createUniqueName(r.name)), assignExtrasToUserData$1(e, r), Promise.resolve(e);
  }
  loadSkin(i) {
    const e = this.json.skins[i], r = [];
    for (let s = 0, a = e.joints.length; s < a; s++)
      r.push(this._loadNodeShallow(e.joints[s]));
    return e.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", e.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function(s) {
      const a = s.pop(), c = s, l = [], h = [];
      for (let d = 0, f = c.length; d < f; d++) {
        const p = c[d];
        if (p) {
          l.push(p);
          const m = new Matrix4();
          a !== null && m.fromArray(a.array, d * 16), h.push(m);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[d]);
      }
      return new Skeleton(l, h);
    });
  }
  loadAnimation(i) {
    const r = this.json.animations[i], s = r.name ? r.name : "animation_" + i, a = [], c = [], l = [], h = [], d = [];
    for (let f = 0, p = r.channels.length; f < p; f++) {
      const m = r.channels[f], y = r.samplers[m.sampler], x = m.target, v = x.node, S = r.parameters !== void 0 ? r.parameters[y.input] : y.input, E = r.parameters !== void 0 ? r.parameters[y.output] : y.output;
      x.node !== void 0 && (a.push(this.getDependency("node", v)), c.push(this.getDependency("accessor", S)), l.push(this.getDependency("accessor", E)), h.push(y), d.push(x));
    }
    return Promise.all([
      Promise.all(a),
      Promise.all(c),
      Promise.all(l),
      Promise.all(h),
      Promise.all(d)
    ]).then(function(f) {
      const p = f[0], m = f[1], y = f[2], x = f[3], v = f[4], S = [];
      for (let E = 0, b = p.length; E < b; E++) {
        const w = p[E], M = m[E], P = y[E], D = x[E], L = v[E];
        if (w === void 0)
          continue;
        w.updateMatrix();
        let O;
        switch (PATH_PROPERTIES$1[L.path]) {
          case PATH_PROPERTIES$1.weights:
            O = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES$1.rotation:
            O = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES$1.position:
          case PATH_PROPERTIES$1.scale:
          default:
            O = VectorKeyframeTrack;
            break;
        }
        const F = w.name ? w.name : w.uuid, k = D.interpolation !== void 0 ? INTERPOLATION$1[D.interpolation] : InterpolateLinear, V = [];
        PATH_PROPERTIES$1[L.path] === PATH_PROPERTIES$1.weights ? w.traverse(function(U) {
          U.morphTargetInfluences && V.push(U.name ? U.name : U.uuid);
        }) : V.push(F);
        let N = P.array;
        if (P.normalized) {
          const U = getNormalizedComponentScale$1(N.constructor), z = new Float32Array(N.length);
          for (let $ = 0, G = N.length; $ < G; $++)
            z[$] = N[$] * U;
          N = z;
        }
        for (let U = 0, z = V.length; U < z; U++) {
          const $ = new O(
            V[U] + "." + PATH_PROPERTIES$1[L.path],
            M.array,
            N,
            k
          );
          D.interpolation === "CUBICSPLINE" && ($.createInterpolant = function(j) {
            const Y = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant$1 : GLTFCubicSplineInterpolant$1;
            return new Y(this.times, this.values, this.getValueSize() / 3, j);
          }, $.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), S.push($);
        }
      }
      return new AnimationClip(s, void 0, S);
    });
  }
  createNodeMesh(i) {
    const e = this.json, r = this, s = e.nodes[i];
    return s.mesh === void 0 ? null : r.getDependency("mesh", s.mesh).then(function(a) {
      const c = r._getNodeRef(r.meshCache, s.mesh, a);
      return s.weights !== void 0 && c.traverse(function(l) {
        if (!!l.isMesh)
          for (let h = 0, d = s.weights.length; h < d; h++)
            l.morphTargetInfluences[h] = s.weights[h];
      }), c;
    });
  }
  loadNode(i) {
    const e = this.json, r = this, s = e.nodes[i], a = r._loadNodeShallow(i), c = [], l = s.children || [];
    for (let d = 0, f = l.length; d < f; d++)
      c.push(r.getDependency("node", l[d]));
    const h = s.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", s.skin);
    return Promise.all([
      a,
      Promise.all(c),
      h
    ]).then(function(d) {
      const f = d[0], p = d[1], m = d[2];
      m !== null && f.traverse(function(y) {
        !y.isSkinnedMesh || y.bind(m, _identityMatrix$1);
      });
      for (let y = 0, x = p.length; y < x; y++)
        f.add(p[y]);
      return f;
    });
  }
  _loadNodeShallow(i) {
    const e = this.json, r = this.extensions, s = this;
    if (this.nodeCache[i] !== void 0)
      return this.nodeCache[i];
    const a = e.nodes[i], c = a.name ? s.createUniqueName(a.name) : "", l = [], h = s._invokeOne(function(d) {
      return d.createNodeMesh && d.createNodeMesh(i);
    });
    return h && l.push(h), a.camera !== void 0 && l.push(s.getDependency("camera", a.camera).then(function(d) {
      return s._getNodeRef(s.cameraCache, a.camera, d);
    })), s._invokeAll(function(d) {
      return d.createNodeAttachment && d.createNodeAttachment(i);
    }).forEach(function(d) {
      l.push(d);
    }), this.nodeCache[i] = Promise.all(l).then(function(d) {
      let f;
      if (a.isBone === !0 ? f = new Bone() : d.length > 1 ? f = new Group() : d.length === 1 ? f = d[0] : f = new Object3D(), f !== d[0])
        for (let p = 0, m = d.length; p < m; p++)
          f.add(d[p]);
      if (a.name && (f.userData.name = a.name, f.name = c), assignExtrasToUserData$1(f, a), a.extensions && addUnknownExtensionsToUserData$1(r, f, a), a.matrix !== void 0) {
        const p = new Matrix4();
        p.fromArray(a.matrix), f.applyMatrix4(p);
      } else
        a.translation !== void 0 && f.position.fromArray(a.translation), a.rotation !== void 0 && f.quaternion.fromArray(a.rotation), a.scale !== void 0 && f.scale.fromArray(a.scale);
      return s.associations.has(f) || s.associations.set(f, {}), s.associations.get(f).nodes = i, f;
    }), this.nodeCache[i];
  }
  loadScene(i) {
    const e = this.extensions, r = this.json.scenes[i], s = this, a = new Group();
    r.name && (a.name = s.createUniqueName(r.name)), assignExtrasToUserData$1(a, r), r.extensions && addUnknownExtensionsToUserData$1(e, a, r);
    const c = r.nodes || [], l = [];
    for (let h = 0, d = c.length; h < d; h++)
      l.push(s.getDependency("node", c[h]));
    return Promise.all(l).then(function(h) {
      for (let f = 0, p = h.length; f < p; f++)
        a.add(h[f]);
      const d = (f) => {
        const p = /* @__PURE__ */ new Map();
        for (const [m, y] of s.associations)
          (m instanceof Material || m instanceof Texture) && p.set(m, y);
        return f.traverse((m) => {
          const y = s.associations.get(m);
          y != null && p.set(m, y);
        }), p;
      };
      return s.associations = d(a), a;
    });
  }
}
function computeBounds$1(o, i, e) {
  const r = i.attributes, s = new Box3();
  if (r.POSITION !== void 0) {
    const l = e.json.accessors[r.POSITION], h = l.min, d = l.max;
    if (h !== void 0 && d !== void 0) {
      if (s.set(
        new Vector3$1(h[0], h[1], h[2]),
        new Vector3$1(d[0], d[1], d[2])
      ), l.normalized) {
        const f = getNormalizedComponentScale$1(WEBGL_COMPONENT_TYPES$1[l.componentType]);
        s.min.multiplyScalar(f), s.max.multiplyScalar(f);
      }
    } else {
      warnOnce("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const a = i.targets;
  if (a !== void 0) {
    const l = new Vector3$1(), h = new Vector3$1();
    for (let d = 0, f = a.length; d < f; d++) {
      const p = a[d];
      if (p.POSITION !== void 0) {
        const m = e.json.accessors[p.POSITION], y = m.min, x = m.max;
        if (y !== void 0 && x !== void 0) {
          if (h.setX(Math.max(Math.abs(y[0]), Math.abs(x[0]))), h.setY(Math.max(Math.abs(y[1]), Math.abs(x[1]))), h.setZ(Math.max(Math.abs(y[2]), Math.abs(x[2]))), m.normalized) {
            const v = getNormalizedComponentScale$1(WEBGL_COMPONENT_TYPES$1[m.componentType]);
            h.multiplyScalar(v);
          }
          l.max(h);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    s.expandByVector(l);
  }
  o.boundingBox = s;
  const c = new Sphere();
  s.getCenter(c.center), c.radius = s.min.distanceTo(s.max) / 2, o.boundingSphere = c;
}
function addPrimitiveAttributes$1(o, i, e) {
  const r = i.attributes, s = [];
  function a(c, l) {
    return e.getDependency("accessor", c).then(function(h) {
      o.setAttribute(l, h);
    });
  }
  for (const c in r) {
    const l = ATTRIBUTES$1[c] || c.toLowerCase();
    l in o.attributes || s.push(a(r[c], l));
  }
  if (i.indices !== void 0 && !o.index) {
    const c = e.getDependency("accessor", i.indices).then(function(l) {
      o.setIndex(l);
    });
    s.push(c);
  }
  return assignExtrasToUserData$1(o, i), computeBounds$1(o, i, e), Promise.all(s).then(function() {
    return i.targets !== void 0 ? addMorphTargets$1(o, i.targets, e) : o;
  });
}
var MeshoptDecoder = function() {
  var o = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q:Odkr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq;w8Wqdbk;esezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9Uc;WFbGgocjdaocjd6EhDaicefhocbhqdnindndndnaeaq9nmbaDaeaq9RaqaDfae6Egkcsfglcl4cifcd4hxalc9WGgmTmecbhPawcjdfhsaohzinaraz9Rax6mvarazaxfgo9RcK6mvczhlcbhHinalgic9WfgOawcj;cbffhldndndndndnazaOco4fRbbaHcoG4ciGPlbedibkal9cb83ibalcwf9cb83ibxikalaoRblaoRbbgOco4gAaAciSgAE86bbawcj;cbfaifglcGfaoclfaAfgARbbaOcl4ciGgCaCciSgCE86bbalcVfaAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc7faAaCfgARbbaOciGgOaOciSgOE86bbalctfaAaOfgARbbaoRbegOco4gCaCciSgCE86bbalc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc93faAaCfgARbbaOciGgOaOciSgOE86bbalc94faAaOfgARbbaoRbdgOco4gCaCciSgCE86bbalc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc97faAaCfgARbbaOciGgOaOciSgOE86bbalc98faAaOfgORbbaoRbigoco4gAaAciSgAE86bbalc99faOaAfgORbbaocl4ciGgAaAciSgAE86bbalc9:faOaAfgORbbaocd4ciGgAaAciSgAE86bbalcufaOaAfglRbbaociGgoaociSgoE86bbalaofhoxdkalaoRbwaoRbbgOcl4gAaAcsSgAE86bbawcj;cbfaifglcGfaocwfaAfgARbbaOcsGgOaOcsSgOE86bbalcVfaAaOfgORbbaoRbegAcl4gCaCcsSgCE86bbalc7faOaCfgORbbaAcsGgAaAcsSgAE86bbalctfaOaAfgORbbaoRbdgAcl4gCaCcsSgCE86bbalc91faOaCfgORbbaAcsGgAaAcsSgAE86bbalc4faOaAfgORbbaoRbigAcl4gCaCcsSgCE86bbalc93faOaCfgORbbaAcsGgAaAcsSgAE86bbalc94faOaAfgORbbaoRblgAcl4gCaCcsSgCE86bbalc95faOaCfgORbbaAcsGgAaAcsSgAE86bbalc96faOaAfgORbbaoRbvgAcl4gCaCcsSgCE86bbalc97faOaCfgORbbaAcsGgAaAcsSgAE86bbalc98faOaAfgORbbaoRbogAcl4gCaCcsSgCE86bbalc99faOaCfgORbbaAcsGgAaAcsSgAE86bbalc9:faOaAfgORbbaoRbrgocl4gAaAcsSgAE86bbalcufaOaAfglRbbaocsGgoaocsSgoE86bbalaofhoxekalao8Pbb83bbalcwfaocwf8Pbb83bbaoczfhokdnaiam9pmbaHcdfhHaiczfhlarao9RcL0mekkaiam6mvaoTmvdnakTmbawaPfRbbhHawcj;cbfhlashiakhOinaialRbbgzce4cbazceG9R7aHfgH86bbaiadfhialcefhlaOcufgOmbkkascefhsaohzaPcefgPad9hmbxikkcbc99arao9Radcaadca0ESEhoxlkaoaxad2fhCdnakmbadhlinaoTmlarao9Rax6mlaoaxfhoalcufglmbkaChoxekcbhmawcjdfhAinarao9Rax6miawamfRbbhHawcj;cbfhlaAhiakhOinaialRbbgzce4cbazceG9R7aHfgH86bbaiadfhialcefhlaOcufgOmbkaAcefhAaoaxfhoamcefgmad9hmbkaChokabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqaombkc9:hoxekc9:hokavcj;ebf8Kjjjjbaok;cseHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgwce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhDaicefgqarfhidnaeTmbcmcsawceSEhkcbhxcbhmcbhPcbhwcbhlindnaiaD9nmbc9:hoxikdndnaqRbbgoc;Ve0mbavc;abfalaocu7gscl4fcsGcitfgzydlhrazydbhzdnaocsGgHak9pmbavawasfcsGcdtfydbaxaHEhoaHThsdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkaxasfhxcdhHavawcdtfaoBdbawasfhwcehsalhOxdkdndnaHcsSmbaHc987aHamffcefhoxekaicefhoai8SbbgHcFeGhsdndnaHcu9mmbaohixekaicvfhiascFbGhscrhHdninao8SbbgOcFbGaHtasVhsaOcu9kmeaocefhoaHcrfgHc8J9hmbxdkkaocefhikasce4cbasceG9R7amfhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhHavawcdtfaoBdbcehsawcefhwalhOaohmxekdnaocpe0mbaxcefgHavawaDaocsGfRbbgocl49RcsGcdtfydbaocz6gzEhravawao9RcsGcdtfydbaHazfgAaocsGgHEhoaHThCdndnadcd9hmbabaPcetfgHax87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHaxBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfaxBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgOaxBdlaOarBdbavawazfgwcsGcdtfaoBdbalcefcsGhOawaCfhwaxhzaAaCfhxxekaxcbaiRbbgOEgzaoc;:eSgHfhraOcsGhCaOcl4hAdndnaOcs0mbarcefhoxekarhoavawaA9RcsGcdtfydbhrkdndnaCmbaocefhxxekaohxavawaO9RcsGcdtfydbhokdndnaHTmbaicefhHxekaicdfhHai8SbegscFeGhzdnascu9kmbaicofhXazcFbGhzcrhidninaH8SbbgscFbGaitazVhzascu9kmeaHcefhHaicrfgic8J9hmbkaXhHxekaHcefhHkazce4cbazceG9R7amfgmhzkdndnaAcsSmbaHhsxekaHcefhsaH8SbbgicFeGhrdnaicu9kmbaHcvfhXarcFbGhrcrhidninas8SbbgHcFbGaitarVhraHcu9kmeascefhsaicrfgic8J9hmbkaXhsxekascefhskarce4cbarceG9R7amfgmhrkdndnaCcsSmbashixekascefhias8SbbgocFeGhHdnaocu9kmbascvfhXaHcFbGhHcrhodninai8SbbgscFbGaotaHVhHascu9kmeaicefhiaocrfgoc8J9hmbkaXhixekaicefhikaHce4cbaHceG9R7amfgmhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfazBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgXazBdlaXarBdbavawaOcz6aAcsSVfgwcsGcdtfaoBdbawaCTaCcsSVfhwalcefcsGhOkaqcefhqavc;abfaOcitfgOarBdlaOaoBdbavc;abfalasfcsGcitfgraoBdlarazBdbawcsGhwalaHfcsGhlaPcifgPae6mbkkcbc99aiaDSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;oiliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabaiavcefciGfcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:OhDxekcjjjj94hDkabaiavciGfgkcd7cetfaD87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:OhDxekcjjjj94hDkabaiavcufciGfcetfaD87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohvxekcjjjj94hvkabakcetfav87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2gdTmbinababydbgecwtcw91:Yaece91cjjj98Gcjjj;8if::NUdbabclfhbadcufgdmbkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaeczfheaiczfhiadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklzNbb", i = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q:6dkr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq:p9sqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk:N8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhlaicefhodnaeTmbadTmbalc;WFbGglcjdalcjd6EhwcbhDinawaeaD9RaDawfae6Egqcsfglc9WGgkci2hxakcethmalcl4cifcd4hPabaDad2fhsakc;ab6hzcbhHincbhOaohAdndninaraA9RaP6meavcj;cbfaOak2fhCaAaPfhocbhidnazmbarao9Rc;Gb6mbcbhlinaCalfhidndndndndnaAalco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklbaoczfhokdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklzaoczfhokdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklaaoczfhokdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WaoclfaYpQbfaXc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WaocwfaYpQbfaXc:q:yjjbfRbbfhoxekaiaopbbbpkl8Waoczfhokalc;abfhialcjefak0meaihlarao9Rc;Fb0mbkkdnaiak9pmbaici4hlinarao9RcK6miaCaifhXdndndndndnaAaico4fRbbalcoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpkbbxikaXaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkbbaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaXaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkbbaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaXaopbbbpkbbaoczfhokalcdfhlaiczfgiak6mbkkaoTmeaohAaOcefgOclSmdxbkkc9:hoxlkdnakTmbavcjdfaHfhiavaHfpbdbhYcbhXinaiavcj;cbfaXfglpblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLalakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEalamfpblbg3cep9Ta3aQp9op9Hp9rg3alaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfhiaXczfgXak6mbkkaHclfgHad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfgDae6mbkkcbc99arao9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk::seHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgwce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhDaicefgqarfhidnaeTmbcmcsawceSEhkcbhxcbhmcbhPcbhwcbhlindnaiaD9nmbc9:hoxikdndnaqRbbgoc;Ve0mbavc;abfalaocu7gscl4fcsGcitfgzydlhrazydbhzdnaocsGgHak9pmbavawasfcsGcdtfydbaxaHEhoaHThsdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkaxasfhxcdhHavawcdtfaoBdbawasfhwcehsalhOxdkdndnaHcsSmbaHc987aHamffcefhoxekaicefhoai8SbbgHcFeGhsdndnaHcu9mmbaohixekaicvfhiascFbGhscrhHdninao8SbbgOcFbGaHtasVhsaOcu9kmeaocefhoaHcrfgHc8J9hmbxdkkaocefhikasce4cbasceG9R7amfhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhHavawcdtfaoBdbcehsawcefhwalhOaohmxekdnaocpe0mbaxcefgHavawaDaocsGfRbbgocl49RcsGcdtfydbaocz6gzEhravawao9RcsGcdtfydbaHazfgAaocsGgHEhoaHThCdndnadcd9hmbabaPcetfgHax87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHaxBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfaxBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgOaxBdlaOarBdbavawazfgwcsGcdtfaoBdbalcefcsGhOawaCfhwaxhzaAaCfhxxekaxcbaiRbbgOEgzaoc;:eSgHfhraOcsGhCaOcl4hAdndnaOcs0mbarcefhoxekarhoavawaA9RcsGcdtfydbhrkdndnaCmbaocefhxxekaohxavawaO9RcsGcdtfydbhokdndnaHTmbaicefhHxekaicdfhHai8SbegscFeGhzdnascu9kmbaicofhXazcFbGhzcrhidninaH8SbbgscFbGaitazVhzascu9kmeaHcefhHaicrfgic8J9hmbkaXhHxekaHcefhHkazce4cbazceG9R7amfgmhzkdndnaAcsSmbaHhsxekaHcefhsaH8SbbgicFeGhrdnaicu9kmbaHcvfhXarcFbGhrcrhidninas8SbbgHcFbGaitarVhraHcu9kmeascefhsaicrfgic8J9hmbkaXhsxekascefhskarce4cbarceG9R7amfgmhrkdndnaCcsSmbashixekascefhias8SbbgocFeGhHdnaocu9kmbascvfhXaHcFbGhHcrhodninai8SbbgscFbGaotaHVhHascu9kmeaicefhiaocrfgoc8J9hmbkaXhixekaicefhikaHce4cbaHceG9R7amfgmhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfazBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgXazBdlaXarBdbavawaOcz6aAcsSVfgwcsGcdtfaoBdbawaCTaCcsSVfhwalcefcsGhOkaqcefhqavc;abfaOcitfgOarBdlaOaoBdbavc;abfalasfcsGcitfgraoBdlarazBdbawcsGhwalaHfcsGhlaPcifgPae6mbkkcbc99aiaDSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:wPliuo97eue978Jjjjjbca9Rhiaec98Ghldndnadcl9hmbdnalTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalaeSmeaipxbbbbbbbbbbbbbbbbgqpklbaiabalcdtfgdaeciGglcdtgv;8qbbdnalTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDaqp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkadaiav;8qbbskdnalTmbcbhvabhdinadczfgxaxpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmbediwDqkzHOAKY8AEgwczp:Reczp:Sep;6egraDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eawczp:Sep;6egwp;Gearp;Gep;Kep;Legopxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegrpxb;:FSb;:FSb;:FSb;:FSararp;Meaoaop;Meawaqawamp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFFbbFFbbFFbbFFbbp9oaoawp;Meaqp;Keczp:Rep9qgoarawp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogrpmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oaoarpmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgval6mbkkalaeSmbaiaeciGgvcitgdfcbcaad9R;8kbaiabalcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmbediwDqkzHOAKY8AEgwczp:Reczp:Sep;6egraDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eawczp:Sep;6egwp;Gearp;Gep;Kep;Legopxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegrpxb;:FSb;:FSb;:FSb;:FSararp;Meaoaop;Meawaqawamp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFFbbFFbbFFbbFFbbp9oaoawp;Meaqp;Keczp:Rep9qgoarawp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogrpmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oaoarpmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaDakp;Mearp;Keamp9oaqakp;Mearp;Keczp:Rep9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalaeSmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaDakp;Mearp;Keamp9oaqakp;Mearp;Keczp:Rep9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbheabhdinadadpbbbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepkbbadczfhdaeclfgeav6mbkkdnavalSmbaialciGgecdtgdVcbc;abad9R;8kbaiabavcdtfgvad;8qbbdnaeTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepklbkavaiad;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz:Dbb", e = new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    4,
    1,
    96,
    0,
    0,
    3,
    3,
    2,
    0,
    0,
    5,
    3,
    1,
    0,
    1,
    12,
    1,
    0,
    10,
    22,
    2,
    12,
    0,
    65,
    0,
    65,
    0,
    65,
    0,
    252,
    10,
    0,
    0,
    11,
    7,
    0,
    65,
    0,
    253,
    15,
    26,
    11
  ]), r = new Uint8Array([
    32,
    0,
    65,
    2,
    1,
    106,
    34,
    33,
    3,
    128,
    11,
    4,
    13,
    64,
    6,
    253,
    10,
    7,
    15,
    116,
    127,
    5,
    8,
    12,
    40,
    16,
    19,
    54,
    20,
    9,
    27,
    255,
    113,
    17,
    42,
    67,
    24,
    23,
    146,
    148,
    18,
    14,
    22,
    45,
    70,
    69,
    56,
    114,
    101,
    21,
    25,
    63,
    75,
    136,
    108,
    28,
    118,
    29,
    73,
    115
  ]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  var s = WebAssembly.validate(e) ? l(i) : l(o), a, c = WebAssembly.instantiate(s, {}).then(function(E) {
    a = E.instance, a.exports.__wasm_call_ctors();
  });
  function l(E) {
    for (var b = new Uint8Array(E.length), w = 0; w < E.length; ++w) {
      var M = E.charCodeAt(w);
      b[w] = M > 96 ? M - 97 : M > 64 ? M - 39 : M + 4;
    }
    for (var P = 0, w = 0; w < E.length; ++w)
      b[P++] = b[w] < 60 ? r[b[w]] : (b[w] - 60) * 64 + b[++w];
    return b.buffer.slice(0, P);
  }
  function h(E, b, w, M, P, D, L) {
    var O = E.exports.sbrk, F = M + 3 & -4, k = O(F * P), V = O(D.length), N = new Uint8Array(E.exports.memory.buffer);
    N.set(D, V);
    var U = b(k, M, P, V, D.length);
    if (U == 0 && L && L(k, F, P), w.set(N.subarray(k, k + M * P)), O(k - O(0)), U != 0)
      throw new Error("Malformed buffer data: " + U);
  }
  var d = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, f = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  }, p = [], m = 0;
  function y(E) {
    var b = {
      object: new Worker(E),
      pending: 0,
      requests: {}
    };
    return b.object.onmessage = function(w) {
      var M = w.data;
      b.pending -= M.count, b.requests[M.id][M.action](M.value), delete b.requests[M.id];
    }, b;
  }
  function x(E) {
    for (var b = "self.ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(s) + "]), {}).then(function(result) { result.instance.exports.__wasm_call_ctors(); return result.instance; });self.onmessage = " + S.name + ";" + h.toString() + S.toString(), w = new Blob([b], { type: "text/javascript" }), M = URL.createObjectURL(w), P = p.length; P < E; ++P)
      p[P] = y(M);
    for (var P = E; P < p.length; ++P)
      p[P].object.postMessage({});
    p.length = E, URL.revokeObjectURL(M);
  }
  function v(E, b, w, M, P) {
    for (var D = p[0], L = 1; L < p.length; ++L)
      p[L].pending < D.pending && (D = p[L]);
    return new Promise(function(O, F) {
      var k = new Uint8Array(w), V = ++m;
      D.pending += E, D.requests[V] = { resolve: O, reject: F }, D.object.postMessage({ id: V, count: E, size: b, source: k, mode: M, filter: P }, [k.buffer]);
    });
  }
  function S(E) {
    var b = E.data;
    if (!b.id)
      return self.close();
    self.ready.then(function(w) {
      try {
        var M = new Uint8Array(b.count * b.size);
        h(w, w.exports[b.mode], M, b.count, b.size, b.source, w.exports[b.filter]), self.postMessage({ id: b.id, count: b.count, action: "resolve", value: M }, [M.buffer]);
      } catch (P) {
        self.postMessage({ id: b.id, count: b.count, action: "reject", value: P });
      }
    });
  }
  return {
    ready: c,
    supported: !0,
    useWorkers: function(E) {
      x(E);
    },
    decodeVertexBuffer: function(E, b, w, M, P) {
      h(a, a.exports.meshopt_decodeVertexBuffer, E, b, w, M, a.exports[d[P]]);
    },
    decodeIndexBuffer: function(E, b, w, M) {
      h(a, a.exports.meshopt_decodeIndexBuffer, E, b, w, M);
    },
    decodeIndexSequence: function(E, b, w, M) {
      h(a, a.exports.meshopt_decodeIndexSequence, E, b, w, M);
    },
    decodeGltfBuffer: function(E, b, w, M, P, D) {
      h(a, a.exports[f[P]], E, b, w, M, a.exports[d[D]]);
    },
    decodeGltfBufferAsync: function(E, b, w, M, P) {
      return p.length > 0 ? v(E, b, w, f[M], d[P]) : c.then(function() {
        var D = new Uint8Array(E * b);
        return h(a, a.exports[f[M]], D, E, b, w, a.exports[d[P]]), D;
      });
    }
  };
}();
const _taskCache$1 = /* @__PURE__ */ new WeakMap();
class DRACOLoader extends Loader {
  constructor(i) {
    super(i), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(i) {
    return this.decoderPath = i, this;
  }
  setDecoderConfig(i) {
    return this.decoderConfig = i, this;
  }
  setWorkerLimit(i) {
    return this.workerLimit = i, this;
  }
  load(i, e, r, s) {
    const a = new FileLoader(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(i, (c) => {
      this.parse(c, e, s);
    }, r, s);
  }
  parse(i, e, r = () => {
  }) {
    this.decodeDracoFile(i, e, null, null, SRGBColorSpace, r).catch(r);
  }
  decodeDracoFile(i, e, r, s, a = LinearSRGBColorSpace, c = () => {
  }) {
    const l = {
      attributeIDs: r || this.defaultAttributeIDs,
      attributeTypes: s || this.defaultAttributeTypes,
      useUniqueIDs: !!r,
      vertexColorSpace: a
    };
    return this.decodeGeometry(i, l).then(e).catch(c);
  }
  decodeGeometry(i, e) {
    const r = JSON.stringify(e);
    if (_taskCache$1.has(i)) {
      const h = _taskCache$1.get(i);
      if (h.key === r)
        return h.promise;
      if (i.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let s;
    const a = this.workerNextTaskID++, c = i.byteLength, l = this._getWorker(a, c).then((h) => (s = h, new Promise((d, f) => {
      s._callbacks[a] = { resolve: d, reject: f }, s.postMessage({ type: "decode", id: a, taskConfig: e, buffer: i }, [i]);
    }))).then((h) => this._createGeometry(h.geometry));
    return l.catch(() => !0).then(() => {
      s && a && this._releaseTask(s, a);
    }), _taskCache$1.set(i, {
      key: r,
      promise: l
    }), l;
  }
  _createGeometry(i) {
    const e = new BufferGeometry();
    i.index && e.setIndex(new BufferAttribute(i.index.array, 1));
    for (let r = 0; r < i.attributes.length; r++) {
      const s = i.attributes[r], a = s.name, c = s.array, l = s.itemSize, h = new BufferAttribute(c, l);
      a === "color" && (this._assignVertexColorSpace(h, s.vertexColorSpace), h.normalized = !(c instanceof Float32Array)), e.setAttribute(a, h);
    }
    return e;
  }
  _assignVertexColorSpace(i, e) {
    if (e !== SRGBColorSpace)
      return;
    const r = new Color();
    for (let s = 0, a = i.count; s < a; s++)
      r.fromBufferAttribute(i, s), ColorManagement.colorSpaceToWorking(r, SRGBColorSpace), i.setXYZ(s, r.r, r.g, r.b);
  }
  _loadLibrary(i, e) {
    const r = new FileLoader(this.manager);
    return r.setPath(this.decoderPath), r.setResponseType(e), r.setWithCredentials(this.withCredentials), new Promise((s, a) => {
      r.load(i, s, void 0, a);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const i = typeof WebAssembly != "object" || this.decoderConfig.type === "js", e = [];
    return i ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then((r) => {
      const s = r[0];
      i || (this.decoderConfig.wasmBinary = r[1]);
      const a = DRACOWorker.toString(), c = [
        "/* draco decoder */",
        s,
        "",
        "/* worker */",
        a.substring(a.indexOf("{") + 1, a.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([c]));
    }), this.decoderPending;
  }
  _getWorker(i, e) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const s = new Worker(this.workerSourceURL);
        s._callbacks = {}, s._taskCosts = {}, s._taskLoad = 0, s.postMessage({ type: "init", decoderConfig: this.decoderConfig }), s.onmessage = function(a) {
          const c = a.data;
          switch (c.type) {
            case "decode":
              s._callbacks[c.id].resolve(c);
              break;
            case "error":
              s._callbacks[c.id].reject(c);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + c.type + '"');
          }
        }, this.workerPool.push(s);
      } else
        this.workerPool.sort(function(s, a) {
          return s._taskLoad > a._taskLoad ? -1 : 1;
        });
      const r = this.workerPool[this.workerPool.length - 1];
      return r._taskCosts[i] = e, r._taskLoad += e, r;
    });
  }
  _releaseTask(i, e) {
    i._taskLoad -= i._taskCosts[e], delete i._callbacks[e], delete i._taskCosts[e];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((i) => i._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i)
      this.workerPool[i].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function DRACOWorker() {
  let o, i;
  onmessage = function(c) {
    const l = c.data;
    switch (l.type) {
      case "init":
        o = l.decoderConfig, i = new Promise(function(f) {
          o.onModuleLoaded = function(p) {
            f({ draco: p });
          }, DracoDecoderModule(o);
        });
        break;
      case "decode":
        const h = l.buffer, d = l.taskConfig;
        i.then((f) => {
          const p = f.draco, m = new p.Decoder();
          try {
            const y = e(p, m, new Int8Array(h), d), x = y.attributes.map((v) => v.array.buffer);
            y.index && x.push(y.index.array.buffer), self.postMessage({ type: "decode", id: l.id, geometry: y }, x);
          } catch (y) {
            console.error(y), self.postMessage({ type: "error", id: l.id, error: y.message });
          } finally {
            p.destroy(m);
          }
        });
        break;
    }
  };
  function e(c, l, h, d) {
    const f = d.attributeIDs, p = d.attributeTypes;
    let m, y;
    const x = l.GetEncodedGeometryType(h);
    if (x === c.TRIANGULAR_MESH)
      m = new c.Mesh(), y = l.DecodeArrayToMesh(h, h.byteLength, m);
    else if (x === c.POINT_CLOUD)
      m = new c.PointCloud(), y = l.DecodeArrayToPointCloud(h, h.byteLength, m);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!y.ok() || m.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + y.error_msg());
    const v = { index: null, attributes: [] };
    for (const S in f) {
      const E = self[p[S]];
      let b, w;
      if (d.useUniqueIDs)
        w = f[S], b = l.GetAttributeByUniqueId(m, w);
      else {
        if (w = l.GetAttributeId(m, c[f[S]]), w === -1)
          continue;
        b = l.GetAttribute(m, w);
      }
      const M = s(c, l, m, S, E, b);
      S === "color" && (M.vertexColorSpace = d.vertexColorSpace), v.attributes.push(M);
    }
    return x === c.TRIANGULAR_MESH && (v.index = r(c, l, m)), c.destroy(m), v;
  }
  function r(c, l, h) {
    const f = h.num_faces() * 3, p = f * 4, m = c._malloc(p);
    l.GetTrianglesUInt32Array(h, p, m);
    const y = new Uint32Array(c.HEAPF32.buffer, m, f).slice();
    return c._free(m), { array: y, itemSize: 1 };
  }
  function s(c, l, h, d, f, p) {
    const m = p.num_components(), x = h.num_points() * m, v = x * f.BYTES_PER_ELEMENT, S = a(c, f), E = c._malloc(v);
    l.GetAttributeDataArrayForAllPoints(h, p, S, v, E);
    const b = new f(c.HEAPF32.buffer, E, x).slice();
    return c._free(E), {
      name: d,
      array: b,
      itemSize: m
    };
  }
  function a(c, l) {
    switch (l) {
      case Float32Array:
        return c.DT_FLOAT32;
      case Int8Array:
        return c.DT_INT8;
      case Int16Array:
        return c.DT_INT16;
      case Int32Array:
        return c.DT_INT32;
      case Uint8Array:
        return c.DT_UINT8;
      case Uint16Array:
        return c.DT_UINT16;
      case Uint32Array:
        return c.DT_UINT32;
    }
  }
}
class WorkerPool {
  constructor(i = 4) {
    this.pool = i, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0, this.workerCreator = null;
  }
  _initWorker(i) {
    if (!this.workers[i]) {
      const e = this.workerCreator();
      e.addEventListener("message", this._onMessage.bind(this, i)), this.workers[i] = e;
    }
  }
  _getIdleWorker() {
    for (let i = 0; i < this.pool; i++)
      if (!(this.workerStatus & 1 << i))
        return i;
    return -1;
  }
  _onMessage(i, e) {
    const r = this.workersResolve[i];
    if (r && r(e), this.queue.length) {
      const { resolve: s, msg: a, transfer: c } = this.queue.shift();
      this.workersResolve[i] = s, this.workers[i].postMessage(a, c);
    } else
      this.workerStatus ^= 1 << i;
  }
  setWorkerCreator(i) {
    this.workerCreator = i;
  }
  setWorkerLimit(i) {
    this.pool = i;
  }
  postMessage(i, e) {
    return new Promise((r) => {
      const s = this._getIdleWorker();
      s !== -1 ? (this._initWorker(s), this.workerStatus |= 1 << s, this.workersResolve[s] = r, this.workers[s].postMessage(i, e)) : this.queue.push({ resolve: r, msg: i, transfer: e });
    });
  }
  dispose() {
    this.workers.forEach((i) => i.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
const t = 0, n = 2, g$1 = 1, u = 2, T = 0, C$1 = 1, R = 10, it = 0, ct = 9, yt = 15, xt = 16, wt = 22, Ft = 37, Ct = 43, te = 76, ae = 83, ge = 97, ue = 100, we = 103, Ae = 109, Ge = 131, Je = 132, Qe = 133, Ze = 134, en = 137, nn = 138, rn = 141, on = 142, hn = 145, Un = 146, _n = 148, xn = 152, mn = 157, Dn = 158, In = 165, Sn = 166, pi = 1000066e3;
class Ii {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
}
class Si {
  constructor(i, e, r, s) {
    this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(i.buffer, i.byteOffset + e, r), this._littleEndian = s, this._offset = 0;
  }
  _nextUint8() {
    const i = this._dataView.getUint8(this._offset);
    return this._offset += 1, i;
  }
  _nextUint16() {
    const i = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, i;
  }
  _nextUint32() {
    const i = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, i;
  }
  _nextUint64() {
    const i = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, i;
  }
  _nextInt32() {
    const i = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, i;
  }
  _nextUint8Array(i) {
    const e = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, i);
    return this._offset += i, e;
  }
  _skip(i) {
    return this._offset += i, this;
  }
  _scan(i, e) {
    e === void 0 && (e = 0);
    const r = this._offset;
    let s = 0;
    for (; this._dataView.getUint8(this._offset) !== e && s < i; )
      s++, this._offset++;
    return s < i && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + r, s);
  }
}
const Oi = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Ti(o) {
  return new TextDecoder().decode(o);
}
function Pi(o) {
  const i = new Uint8Array(o.buffer, o.byteOffset, Oi.length);
  if (i[0] !== Oi[0] || i[1] !== Oi[1] || i[2] !== Oi[2] || i[3] !== Oi[3] || i[4] !== Oi[4] || i[5] !== Oi[5] || i[6] !== Oi[6] || i[7] !== Oi[7] || i[8] !== Oi[8] || i[9] !== Oi[9] || i[10] !== Oi[10] || i[11] !== Oi[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const e = new Ii(), r = 17 * Uint32Array.BYTES_PER_ELEMENT, s = new Si(o, Oi.length, r, !0);
  e.vkFormat = s._nextUint32(), e.typeSize = s._nextUint32(), e.pixelWidth = s._nextUint32(), e.pixelHeight = s._nextUint32(), e.pixelDepth = s._nextUint32(), e.layerCount = s._nextUint32(), e.faceCount = s._nextUint32();
  const a = s._nextUint32();
  e.supercompressionScheme = s._nextUint32();
  const c = s._nextUint32(), l = s._nextUint32(), h = s._nextUint32(), d = s._nextUint32(), f = s._nextUint64(), p = s._nextUint64(), m = new Si(o, Oi.length + r, 3 * a * 8, !0);
  for (let j = 0; j < a; j++)
    e.levels.push({ levelData: new Uint8Array(o.buffer, o.byteOffset + m._nextUint64(), m._nextUint64()), uncompressedByteLength: m._nextUint64() });
  const y = new Si(o, c, l, !0), x = { vendorId: y._skip(4)._nextUint16(), descriptorType: y._nextUint16(), versionNumber: y._nextUint16(), descriptorBlockSize: y._nextUint16(), colorModel: y._nextUint8(), colorPrimaries: y._nextUint8(), transferFunction: y._nextUint8(), flags: y._nextUint8(), texelBlockDimension: [y._nextUint8(), y._nextUint8(), y._nextUint8(), y._nextUint8()], bytesPlane: [y._nextUint8(), y._nextUint8(), y._nextUint8(), y._nextUint8(), y._nextUint8(), y._nextUint8(), y._nextUint8(), y._nextUint8()], samples: [] }, v = (x.descriptorBlockSize / 4 - 6) / 4;
  for (let j = 0; j < v; j++) {
    const Y = { bitOffset: y._nextUint16(), bitLength: y._nextUint8(), channelType: y._nextUint8(), samplePosition: [y._nextUint8(), y._nextUint8(), y._nextUint8(), y._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
    64 & Y.channelType ? (Y.sampleLower = y._nextInt32(), Y.sampleUpper = y._nextInt32()) : (Y.sampleLower = y._nextUint32(), Y.sampleUpper = y._nextUint32()), x.samples[j] = Y;
  }
  e.dataFormatDescriptor.length = 0, e.dataFormatDescriptor.push(x);
  const S = new Si(o, h, d, !0);
  for (; S._offset < d; ) {
    const j = S._nextUint32(), Y = S._scan(j), H = Ti(Y);
    if (e.keyValue[H] = S._nextUint8Array(j - Y.byteLength - 1), H.match(/^ktx/i)) {
      const W = Ti(e.keyValue[H]);
      e.keyValue[H] = W.substring(0, W.lastIndexOf("\0"));
    }
    S._skip(j % 4 ? 4 - j % 4 : 0);
  }
  if (p <= 0)
    return e;
  const E = new Si(o, f, p, !0), b = E._nextUint16(), w = E._nextUint16(), M = E._nextUint32(), P = E._nextUint32(), D = E._nextUint32(), L = E._nextUint32(), O = [];
  for (let j = 0; j < a; j++)
    O.push({ imageFlags: E._nextUint32(), rgbSliceByteOffset: E._nextUint32(), rgbSliceByteLength: E._nextUint32(), alphaSliceByteOffset: E._nextUint32(), alphaSliceByteLength: E._nextUint32() });
  const F = f + E._offset, k = F + M, V = k + P, N = V + D, U = new Uint8Array(o.buffer, o.byteOffset + F, M), z = new Uint8Array(o.buffer, o.byteOffset + k, P), $ = new Uint8Array(o.buffer, o.byteOffset + V, D), G = new Uint8Array(o.buffer, o.byteOffset + N, L);
  return e.globalData = { endpointCount: b, selectorCount: w, imageDescs: O, endpointsData: U, selectorsData: z, tablesData: $, extendedData: G }, e;
}
let A, I, B;
const g = { env: { emscripten_notify_memory_growth: function(o) {
  B = new Uint8Array(I.exports.memory.buffer);
} } };
class Q {
  init() {
    return A || (A = typeof fetch < "u" ? fetch("data:application/wasm;base64," + C).then((i) => i.arrayBuffer()).then((i) => WebAssembly.instantiate(i, g)).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init), A);
  }
  _init(i) {
    I = i.instance, g.env.emscripten_notify_memory_growth(0);
  }
  decode(i, e = 0) {
    if (!I)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const r = i.byteLength, s = I.exports.malloc(r);
    B.set(i, s), e = e || Number(I.exports.ZSTD_findDecompressedSize(s, r));
    const a = I.exports.malloc(e), c = I.exports.ZSTD_decompress(a, e, s, r), l = B.slice(a, a + c);
    return I.exports.free(s), I.exports.free(a), l;
  }
}
const C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", DisplayP3ColorSpace = "display-p3", LinearDisplayP3ColorSpace = "display-p3-linear", _taskCache = /* @__PURE__ */ new WeakMap();
let _activeLoaders = 0, _zstd;
class KTX2Loader extends Loader {
  constructor(i) {
    super(i), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new WorkerPool(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn(
      'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
    );
  }
  setTranscoderPath(i) {
    return this.transcoderPath = i, this;
  }
  setWorkerLimit(i) {
    return this.workerPool.setWorkerLimit(i), this;
  }
  async detectSupportAsync(i) {
    return this.workerConfig = {
      astcSupported: await i.hasFeatureAsync("texture-compression-astc"),
      astcHDRSupported: !1,
      etc1Supported: await i.hasFeatureAsync("texture-compression-etc1"),
      etc2Supported: await i.hasFeatureAsync("texture-compression-etc2"),
      dxtSupported: await i.hasFeatureAsync("texture-compression-bc"),
      bptcSupported: await i.hasFeatureAsync("texture-compression-bptc"),
      pvrtcSupported: await i.hasFeatureAsync("texture-compression-pvrtc")
    }, this;
  }
  detectSupport(i) {
    return i.isWebGPURenderer === !0 ? this.workerConfig = {
      astcSupported: i.hasFeature("texture-compression-astc"),
      astcHDRSupported: !1,
      etc1Supported: i.hasFeature("texture-compression-etc1"),
      etc2Supported: i.hasFeature("texture-compression-etc2"),
      dxtSupported: i.hasFeature("texture-compression-bc"),
      bptcSupported: i.hasFeature("texture-compression-bptc"),
      pvrtcSupported: i.hasFeature("texture-compression-pvrtc")
    } : this.workerConfig = {
      astcSupported: i.extensions.has("WEBGL_compressed_texture_astc"),
      astcHDRSupported: i.extensions.has("WEBGL_compressed_texture_astc") && i.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
      etc1Supported: i.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: i.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: i.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: i.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: i.extensions.has("WEBGL_compressed_texture_pvrtc") || i.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    }, this;
  }
  init() {
    if (!this.transcoderPending) {
      const i = new FileLoader(this.manager);
      i.setPath(this.transcoderPath), i.setWithCredentials(this.withCredentials);
      const e = i.loadAsync("basis_transcoder.js"), r = new FileLoader(this.manager);
      r.setPath(this.transcoderPath), r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials);
      const s = r.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([e, s]).then(([a, c]) => {
        const l = KTX2Loader.BasisWorker.toString(), h = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat),
          "let _EngineType = " + JSON.stringify(KTX2Loader.EngineType),
          "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat),
          "/* basis_transcoder.js */",
          a,
          "/* worker */",
          l.substring(l.indexOf("{") + 1, l.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([h])), this.transcoderBinary = c, this.workerPool.setWorkerCreator(() => {
          const d = new Worker(this.workerSourceURL), f = this.transcoderBinary.slice(0);
          return d.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: f }, [f]), d;
        });
      }), _activeLoaders > 0 && console.warn(
        "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
      ), _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(i, e, r, s) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const a = new FileLoader(this.manager);
    a.setPath(this.path), a.setCrossOrigin(this.crossOrigin), a.setWithCredentials(this.withCredentials), a.setResponseType("arraybuffer"), a.load(i, (c) => {
      this.parse(c, e, s);
    }, r, s);
  }
  parse(i, e, r) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    if (_taskCache.has(i))
      return _taskCache.get(i).promise.then(e).catch(r);
    this._createTexture(i).then((s) => e ? e(s) : null).catch(r);
  }
  _createTextureFrom(i, e) {
    const { type: r, error: s, data: { faces: a, width: c, height: l, format: h, type: d, dfdFlags: f } } = i;
    if (r === "error")
      return Promise.reject(s);
    let p;
    if (e.faceCount === 6)
      p = new CompressedCubeTexture(a, h, d);
    else {
      const m = a[0].mipmaps;
      p = e.layerCount > 1 ? new CompressedArrayTexture(m, c, l, e.layerCount, h, d) : new CompressedTexture(m, c, l, h, d);
    }
    return p.minFilter = a[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter, p.magFilter = LinearFilter, p.generateMipmaps = !1, p.needsUpdate = !0, p.colorSpace = parseColorSpace(e), p.premultiplyAlpha = !!(f & g$1), p;
  }
  async _createTexture(i, e = {}) {
    const r = Pi(new Uint8Array(i)), s = r.vkFormat === pi && r.dataFormatDescriptor[0].colorModel === 167;
    if (!(r.vkFormat === it || s && !this.workerConfig.astcHDRSupported))
      return createRawTexture(r);
    const c = e, l = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: i, taskConfig: c }, [i])).then((h) => this._createTextureFrom(h.data, r));
    return _taskCache.set(i, { promise: l }), l;
  }
  dispose() {
    this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), _activeLoaders--;
  }
}
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC: 1,
  UASTC_HDR: 2
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16,
  BC6H: 22,
  RGB_HALF: 24,
  RGBA_HALF: 25
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGB_BPTC_UNSIGNED_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format
};
KTX2Loader.EngineType = {
  UnsignedByteType,
  HalfFloatType,
  FloatType
};
KTX2Loader.BasisWorker = function() {
  let o, i, e;
  const r = _EngineFormat, s = _EngineType, a = _TranscoderFormat, c = _BasisFormat;
  self.addEventListener("message", function(x) {
    const v = x.data;
    switch (v.type) {
      case "init":
        o = v.config, l(v.transcoderBinary);
        break;
      case "transcode":
        i.then(() => {
          try {
            const { faces: S, buffers: E, width: b, height: w, hasAlpha: M, format: P, type: D, dfdFlags: L } = h(v.buffer);
            self.postMessage({ type: "transcode", id: v.id, data: { faces: S, width: b, height: w, hasAlpha: M, format: P, type: D, dfdFlags: L } }, E);
          } catch (S) {
            console.error(S), self.postMessage({ type: "error", id: v.id, error: S.message });
          }
        });
        break;
    }
  });
  function l(x) {
    i = new Promise((v) => {
      e = { wasmBinary: x, onRuntimeInitialized: v }, BASIS(e);
    }).then(() => {
      e.initializeBasis(), e.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
    });
  }
  function h(x) {
    const v = new e.KTX2File(new Uint8Array(x));
    function S() {
      v.close(), v.delete();
    }
    if (!v.isValid())
      throw S(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    let E;
    if (v.isUASTC())
      E = c.UASTC;
    else if (v.isETC1S())
      E = c.ETC1S;
    else if (v.isHDR())
      E = c.UASTC_HDR;
    else
      throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
    const b = v.getWidth(), w = v.getHeight(), M = v.getLayers() || 1, P = v.getLevels(), D = v.getFaces(), L = v.getHasAlpha(), O = v.getDFDFlags(), { transcoderFormat: F, engineFormat: k, engineType: V } = p(E, b, w, L);
    if (!b || !w || !P)
      throw S(), new Error("THREE.KTX2Loader:	Invalid texture");
    if (!v.startTranscoding())
      throw S(), new Error("THREE.KTX2Loader: .startTranscoding failed");
    const N = [], U = [];
    for (let z = 0; z < D; z++) {
      const $ = [];
      for (let G = 0; G < P; G++) {
        const j = [];
        let Y, H;
        for (let q = 0; q < M; q++) {
          const Z = v.getImageLevelInfo(G, q, z);
          z === 0 && G === 0 && q === 0 && (Z.origWidth % 4 !== 0 || Z.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), P > 1 ? (Y = Z.origWidth, H = Z.origHeight) : (Y = Z.width, H = Z.height);
          let X = new Uint8Array(v.getImageTranscodedSizeInBytes(G, q, 0, F));
          const K = v.transcodeImage(X, G, q, z, F, 0, -1, -1);
          if (V === s.HalfFloatType && (X = new Uint16Array(X.buffer, X.byteOffset, X.byteLength / Uint16Array.BYTES_PER_ELEMENT)), !K)
            throw S(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
          j.push(X);
        }
        const W = y(j);
        $.push({ data: W, width: Y, height: H }), U.push(W.buffer);
      }
      N.push({ mipmaps: $, width: b, height: w, format: k, type: V });
    }
    return S(), { faces: N, buffers: U, width: b, height: w, hasAlpha: L, dfdFlags: O, format: k, type: V };
  }
  const d = [
    {
      if: "astcSupported",
      basisFormat: [c.UASTC],
      transcoderFormat: [a.ASTC_4x4, a.ASTC_4x4],
      engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 1 / 0,
      priorityUASTC: 1,
      needsPowerOfTwo: !1
    },
    {
      if: "bptcSupported",
      basisFormat: [c.ETC1S, c.UASTC],
      transcoderFormat: [a.BC7_M5, a.BC7_M5],
      engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: !1
    },
    {
      if: "dxtSupported",
      basisFormat: [c.ETC1S, c.UASTC],
      transcoderFormat: [a.BC1, a.BC3],
      engineFormat: [r.RGBA_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: !1
    },
    {
      if: "etc2Supported",
      basisFormat: [c.ETC1S, c.UASTC],
      transcoderFormat: [a.ETC1, a.ETC2],
      engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: !1
    },
    {
      if: "etc1Supported",
      basisFormat: [c.ETC1S, c.UASTC],
      transcoderFormat: [a.ETC1],
      engineFormat: [r.RGB_ETC1_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: !1
    },
    {
      if: "pvrtcSupported",
      basisFormat: [c.ETC1S, c.UASTC],
      transcoderFormat: [a.PVRTC1_4_RGB, a.PVRTC1_4_RGBA],
      engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format],
      engineType: [s.UnsignedByteType],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: !0
    },
    {
      if: "bptcSupported",
      basisFormat: [c.UASTC_HDR],
      transcoderFormat: [a.BC6H],
      engineFormat: [r.RGB_BPTC_UNSIGNED_Format],
      engineType: [s.HalfFloatType],
      priorityHDR: 1,
      needsPowerOfTwo: !1
    },
    {
      basisFormat: [c.ETC1S, c.UASTC],
      transcoderFormat: [a.RGBA32, a.RGBA32],
      engineFormat: [r.RGBAFormat, r.RGBAFormat],
      engineType: [s.UnsignedByteType, s.UnsignedByteType],
      priorityETC1S: 100,
      priorityUASTC: 100,
      needsPowerOfTwo: !1
    },
    {
      basisFormat: [c.UASTC_HDR],
      transcoderFormat: [a.RGBA_HALF],
      engineFormat: [r.RGBAFormat],
      engineType: [s.HalfFloatType],
      priorityHDR: 100,
      needsPowerOfTwo: !1
    }
  ], f = {
    [c.ETC1S]: d.filter((x) => x.basisFormat.includes(c.ETC1S)).sort((x, v) => x.priorityUASTC - v.priorityUASTC),
    [c.UASTC]: d.filter((x) => x.basisFormat.includes(c.UASTC)).sort((x, v) => x.priorityUASTC - v.priorityUASTC),
    [c.UASTC_HDR]: d.filter((x) => x.basisFormat.includes(c.UASTC_HDR)).sort((x, v) => x.priorityHDR - v.priorityHDR)
  };
  function p(x, v, S, E) {
    const b = f[x];
    for (let w = 0; w < b.length; w++) {
      const M = b[w];
      if (M.if && !o[M.if] || !M.basisFormat.includes(x) || E && M.transcoderFormat.length < 2 || M.needsPowerOfTwo && !(m(v) && m(S)))
        continue;
      const P = M.transcoderFormat[E ? 1 : 0], D = M.engineFormat[E ? 1 : 0], L = M.engineType[0];
      return { transcoderFormat: P, engineFormat: D, engineType: L };
    }
    throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.");
  }
  function m(x) {
    return x <= 2 ? !0 : (x & x - 1) === 0 && x !== 0;
  }
  function y(x) {
    if (x.length === 1)
      return x[0];
    let v = 0;
    for (let b = 0; b < x.length; b++) {
      const w = x[b];
      v += w.byteLength;
    }
    const S = new Uint8Array(v);
    let E = 0;
    for (let b = 0; b < x.length; b++) {
      const w = x[b];
      S.set(w, E), E += w.byteLength;
    }
    return S;
  }
};
const UNCOMPRESSED_FORMATS = /* @__PURE__ */ new Set([RGBAFormat, RGFormat, RedFormat]), FORMAT_MAP = {
  [Ae]: RGBAFormat,
  [ge]: RGBAFormat,
  [Ft]: RGBAFormat,
  [Ct]: RGBAFormat,
  [we]: RGFormat,
  [ae]: RGFormat,
  [xt]: RGFormat,
  [wt]: RGFormat,
  [ue]: RedFormat,
  [te]: RedFormat,
  [yt]: RedFormat,
  [ct]: RedFormat,
  [_n]: RGB_ETC2_Format,
  [xn]: RGBA_ETC2_EAC_Format,
  [pi]: RGBA_ASTC_4x4_Format,
  [Dn]: RGBA_ASTC_4x4_Format,
  [mn]: RGBA_ASTC_4x4_Format,
  [Sn]: RGBA_ASTC_6x6_Format,
  [In]: RGBA_ASTC_6x6_Format,
  [Qe]: RGBA_S3TC_DXT1_Format,
  [Ze]: RGBA_S3TC_DXT1_Format,
  [Ge]: RGB_S3TC_DXT1_Format,
  [Je]: RGB_S3TC_DXT1_Format,
  [nn]: RGBA_S3TC_DXT3_Format,
  [en]: RGBA_S3TC_DXT3_Format,
  [on]: RGBA_S3TC_DXT5_Format,
  [rn]: RGBA_S3TC_DXT5_Format,
  [Un]: RGBA_BPTC_Format,
  [hn]: RGBA_BPTC_Format
}, TYPE_MAP = {
  [Ae]: FloatType,
  [ge]: HalfFloatType,
  [Ft]: UnsignedByteType,
  [Ct]: UnsignedByteType,
  [we]: FloatType,
  [ae]: HalfFloatType,
  [xt]: UnsignedByteType,
  [wt]: UnsignedByteType,
  [ue]: FloatType,
  [te]: HalfFloatType,
  [yt]: UnsignedByteType,
  [ct]: UnsignedByteType,
  [_n]: UnsignedByteType,
  [xn]: UnsignedByteType,
  [pi]: HalfFloatType,
  [Sn]: UnsignedByteType,
  [In]: UnsignedByteType
};
async function createRawTexture(o) {
  const { vkFormat: i } = o;
  if (FORMAT_MAP[i] === void 0)
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  let e;
  o.supercompressionScheme === n && (_zstd || (_zstd = new Promise(async (a) => {
    const c = new Q();
    await c.init(), a(c);
  })), e = await _zstd);
  const r = [];
  for (let a = 0; a < o.levels.length; a++) {
    const c = Math.max(1, o.pixelWidth >> a), l = Math.max(1, o.pixelHeight >> a), h = o.pixelDepth ? Math.max(1, o.pixelDepth >> a) : 0, d = o.levels[a];
    let f;
    if (o.supercompressionScheme === t)
      f = d.levelData;
    else if (o.supercompressionScheme === n)
      f = e.decode(d.levelData, d.uncompressedByteLength);
    else
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    let p;
    TYPE_MAP[i] === FloatType ? p = new Float32Array(
      f.buffer,
      f.byteOffset,
      f.byteLength / Float32Array.BYTES_PER_ELEMENT
    ) : TYPE_MAP[i] === HalfFloatType ? p = new Uint16Array(
      f.buffer,
      f.byteOffset,
      f.byteLength / Uint16Array.BYTES_PER_ELEMENT
    ) : p = f, r.push({
      data: p,
      width: c,
      height: l,
      depth: h
    });
  }
  let s;
  if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[i]))
    s = o.pixelDepth === 0 ? new DataTexture(r[0].data, o.pixelWidth, o.pixelHeight) : new Data3DTexture(r[0].data, o.pixelWidth, o.pixelHeight, o.pixelDepth);
  else {
    if (o.pixelDepth > 0)
      throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    s = new CompressedTexture(r, o.pixelWidth, o.pixelHeight), s.minFilter = r.length === 1 ? LinearFilter : LinearMipmapLinearFilter, s.magFilter = LinearFilter;
  }
  return s.mipmaps = r, s.type = TYPE_MAP[i], s.format = FORMAT_MAP[i], s.colorSpace = parseColorSpace(o), s.needsUpdate = !0, Promise.resolve(s);
}
function parseColorSpace(o) {
  const i = o.dataFormatDescriptor[0];
  return i.colorPrimaries === C$1 ? i.transferFunction === u ? SRGBColorSpace : LinearSRGBColorSpace : i.colorPrimaries === R ? i.transferFunction === u ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace : i.colorPrimaries === T ? NoColorSpace : (console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${i.colorPrimaries}"`), NoColorSpace);
}
const ktx2Loader = new KTX2Loader(), renderer = new WebGLRenderer();
ktx2Loader.detectSupport(renderer);
ktx2Loader.setWorkerLimit = 4;
ktx2Loader.setTranscoderPath(getAssetUrl("assets/libs/basis/"));
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath(getAssetUrl("assets/libs/draco/gltf/"));
dracoLoader.setDecoderConfig({ type: "js" });
function createEnhancedLoader() {
  const o = new GLTFLoader$1();
  return o.setMeshoptDecoder(MeshoptDecoder), o.setDRACOLoader(dracoLoader), o.setKTX2Loader(ktx2Loader), o;
}
let gltfLoader = createEnhancedLoader();
function clone$1(o) {
  const i = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), r = o.clone();
  return parallelTraverse(o, r, function(s, a) {
    i.set(a, s), e.set(s, a);
  }), r.traverse(function(s) {
    if (!s.isSkinnedMesh)
      return;
    const a = s, c = i.get(s), l = c.skeleton.bones;
    a.skeleton = c.skeleton.clone(), a.bindMatrix.copy(c.bindMatrix), a.skeleton.bones = l.map(function(h) {
      return e.get(h);
    }), a.bind(a.skeleton, a.bindMatrix);
  }), r;
}
function parallelTraverse(o, i, e) {
  e(o, i);
  for (let r = 0; r < o.children.length; r++)
    parallelTraverse(o.children[r], i.children[r], e);
}
const _modelMeshSingleton = new PromisedSingleton();
_modelMeshSingleton.generate = async (o) => new Promise((i, e) => {
  gltfLoader.load(o, (r) => {
    i(r);
  }, null, e);
});
const _pointScratch = new Vector3$1(), _scaleScratch = new Vector3$1(), _rotationScratch = new Euler();
new Matrix4();
class SimpleModel extends Object3D {
  constructor(e) {
    super(e);
    _(this, "_autoYUpToZUp", !0);
    this._parameters = e, this._name = e.name || "", this._object = e.object || e.url, e.autoYUpToZUp !== void 0 && (this._autoYUpToZUp = e.autoYUpToZUp);
  }
  afterAddToEngine(e) {
    this._engine = e, this.setTransform({
      point: this._parameters.point || [0, 0, 0],
      scale: this._parameters.scale || [1, 1, 1],
      rotation: this._parameters.rotation || [0, 0, 0]
    }), this._initModel();
  }
  beforeRemoveFromEngine() {
    this.dispose();
  }
  async _initModel() {
    if (!this._object) {
      console.error("object of SimpleModel is required");
      return;
    }
    let e = null;
    if (typeof this._object == "string") {
      const r = await _modelMeshSingleton.get(this._object);
      r.animations && r.animations.length > 0 ? e = clone$1(r.scene) : e = r.scene.clone(), this._updateData(r, e), this.dispatchEvent({
        type: "loaded",
        value: this
      }), this._autoYUpToZUp && e.rotateX(Math.PI / 2);
    } else
      this._object.isObject3D && (e = this._object);
    this.add(e);
  }
  dispose() {
  }
  setTransform(e = {}) {
    if (e.point) {
      e.point instanceof Vector3$1 ? _pointScratch.copy(e.point) : e.point instanceof Array && _pointScratch.set(e.point[0], e.point[1], e.point[2] || 0);
      const r = this._engine.map.projectCoordinate(_pointScratch);
      this.position.copy(r);
    }
    if (e.rotation) {
      if (e.rotation instanceof Euler ? _rotationScratch.copy(e.rotation) : e.rotation instanceof Vector3$1 ? _rotationScratch.setFromVector3(e.rotation, "XYZ") : e.rotation instanceof Array && _rotationScratch.set(e.rotation[0], e.rotation[1], e.rotation[2], "XYZ"), this._engine.map.isGlobe) {
        const r = {
          heading: _rotationScratch.z,
          pitch: _rotationScratch.y,
          roll: _rotationScratch.x
        }, s = Transforms.headingPitchRollToFixedFrame(this.position, r);
        _rotationScratch.setFromRotationMatrix(s);
      }
      this.rotation.set(_rotationScratch.x, _rotationScratch.y, _rotationScratch.z, _rotationScratch.order);
    }
    e.scale && (e.scale instanceof Vector3$1 ? _scaleScratch.copy(e.scale) : typeof e.scale == "number" ? _scaleScratch.set(e.scale, e.scale, e.scale) : e.scale instanceof Array && _scaleScratch.set(e.scale[0], e.scale[1], e.scale[2]), this.scale.set(_scaleScratch.x, _scaleScratch.y, _scaleScratch.z));
  }
  set point(e) {
    !e || this.setTransform({ point: e });
  }
  get autoYUpToZUp() {
    return this._autoYUpToZUp;
  }
  _updateData() {
  }
}
class AnimationModel extends SimpleModel {
  constructor(i) {
    super(i);
  }
  _updateData(i, e) {
    let r = [];
    i.animations && i.animations.length > 0 && (this.animations = i.animations, this.mixer = new AnimationMixer(e), r = this.animations.map((s) => this.mixer.clipAction(s)), this._parameters.autoPlay && r[0].play(), this._engine.rendering.animation.addMixer(this.mixer)), this.animationActions = r;
  }
  play(i) {
    i = i || 0, this.animationActions[i] && this.animationActions[i].play();
  }
  stop(i) {
    i = i || 0, this.animationActions[i] && this.animationActions[i].stop();
  }
  playAll() {
    this.animationActions.forEach((i) => i.play());
  }
  stopAll() {
    this.animationActions.forEach((i) => i.stop());
  }
  setSpeed(i, e) {
    e !== void 0 ? this.animationActions[e] && (this.animationActions[e].timeScale = i) : this.animationActions.forEach((r) => r.timeScale = i);
  }
  setLoop(i, e) {
    const r = i === !0 ? LoopRepeat : LoopOnce;
    e !== void 0 ? this.animationActions[e] && (this.animationActions[e].loop = r) : this.animationActions.forEach((s) => s.loop = r);
  }
  dispose() {
    this.mixer && (this._engine.rendering.animation.removeMixer(this.mixer), this.mixer.stopAllAction(), this.mixer.uncacheAction(), this.animationActions.forEach((i) => {
      this.mixer.uncacheClip(i);
    })), this.mixer = null, this.animations = null, this.animationActions = null, super.dispose();
  }
}
const LodModelCache = new LRUCache$1({
  max: 100,
  onRemove(o) {
    o.destroyModel();
  }
});
class LODModel extends Object3D {
  constructor(e) {
    super(e);
    _(this, "_hysteresis", 0.1);
    _(this, "_levels", []);
    _(this, "_currentLevel");
    _(this, "_currentModel");
    _(this, "_loader", gltfLoader);
    _(this, "_generateModelMesh", async (e) => new Promise((r, s) => {
      this._loader.load(e, (a) => {
        r(a.scene);
      }, null, s);
    }));
    _(this, "update", async () => {
      if (!this.visible)
        return;
      const e = this._engine.camera, r = this.levels, s = this.position, a = r.length;
      if (a > 0) {
        const c = e.position.distanceTo(s), l = r[a - 1].hysteresis || this.hysteresis;
        if (c > r[a - 1].distance * (1 + l)) {
          this._modelMeshSingleton.keys.forEach(async (f) => {
            let p = await this._modelMeshSingleton.get(f);
            p.visible = !1;
          }), !LodModelCache.cache[this.uuid] && this.isInit && LodModelCache.set(this.uuid, this), this._currentLevel = void 0, this._currentModel = void 0;
          return;
        }
        LodModelCache.remove(this.uuid);
        let h, d;
        for (let f = 0; f < a; f++) {
          const p = r[f];
          let m = p.distance;
          if (p.init && (await this._modelMeshSingleton.get(p.file)).visible === !0) {
            let x = p.hysteresis || this.hysteresis;
            m += m * x;
          }
          if (h === void 0 && c <= m) {
            h = f;
            continue;
          }
          if (p.init) {
            let y = await this._modelMeshSingleton.get(p.file);
            y.visible = !1;
          }
        }
        if (h >= 0) {
          let f = r[h], p = await this._modelMeshSingleton.get(f.file);
          f.init ? p.visible = !0 : (this.add(p), f.init = !0, this.handleLoaded(p)), d = p;
        }
        this._currentLevel = h, this._currentModel = d;
      }
    });
    e.hysteresis && (this.hysteresis = e.hysteresis), e.levels && (this.levels = e.levels);
  }
  afterAddToEngine(e) {
    this._engine = e, this._modelMeshSingleton = new PromisedSingleton(), this._modelMeshSingleton.generate = this._generateModelMesh, this._engine.rendering.addPrepareRenderListener(this.update);
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  addLevel(e, r = 0, s = 0) {
    r = Math.abs(r);
    const a = this.levels;
    let c;
    for (c = 0; c < a.length && !(r < a[c].distance); c++)
      ;
    return a.splice(c, 0, { distance: r, hysteresis: s, file: e, init: !1 }), this;
  }
  removeLevel(e) {
    for (let r = 0; r < this.levels.length; r++) {
      const s = this.levels[r];
      if (e === s.file) {
        this.levels.splice(r, 1);
        break;
      }
    }
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getCurrentModel() {
    return this._currentModel;
  }
  async getModel(e) {
    let r = this.levels[e];
    if (!!r)
      return await this._modelMeshSingleton.get(r.file);
  }
  handleLoaded(e) {
    this.dispatchEvent({
      type: "loaded",
      value: e
    }), this.levels.every((s) => s.init) && this.dispatchEvent({
      type: "complete",
      value: this
    });
  }
  dispose() {
    this._loaded && (this._engine.rendering.removePrepareRenderListener(this.update), this.destroyModel());
  }
  get isInit() {
    return this.levels.findIndex((r) => r.init) >= 0;
  }
  destroyModel() {
    this._modelMeshSingleton.keys.forEach(async (e) => {
      let r = await this._modelMeshSingleton.get(e);
      this.remove(r), r.traverse((s) => {
        if (s.isMesh) {
          s.geometry.dispose(), s.material.dispose();
          const a = s.material.map;
          a && (a.image instanceof ImageBitmap && a.image.close(), a.dispose());
        }
      });
    });
    for (let e = 0; e < this.levels.length; e++) {
      const r = this.levels[e];
      r.init = !1;
    }
    this._modelMeshSingleton.clear();
  }
  get transform() {
    return {
      translate: this.position,
      rotation: this.rotation,
      scale: this.scale
    };
  }
  set transform(e) {
    e.translate && (e.translate instanceof Vector3$1 ? this.position.copy(e.translate) : this.position.set(...e.translate)), e.rotation && (e.rotation instanceof Vector3$1 ? this.rotation.copy(e.rotation) : this.rotation.set(...e.rotation)), e.scale && (e.scale instanceof Vector3$1 ? this.scale.copy(e.scale) : typeof e.scale == "number" ? this.scale.setScalar(e.scale) : this.scale.set(...e.scale));
  }
  get levels() {
    return this._levels;
  }
  set levels(e) {
    this._levels = e.map((r) => (r.init = !1, r));
  }
  get hysteresis() {
    return this._hysteresis;
  }
  set hysteresis(e) {
    this._hysteresis = e;
  }
}
const Cesium3DTileContentState = {
  UNLOADED: 0,
  LOADING: 1,
  PROCESSING: 2,
  READY: 3,
  EXPIRED: 4,
  FAILED: 5
}, Cesium3DTileContentState$1 = Object.freeze(Cesium3DTileContentState);
function swap$1(o, i, e) {
  const r = o[i];
  o[i] = o[e], o[e] = r;
}
class Heap {
  constructor(i) {
    this._comparator = i.comparator, this._array = [], this._length = 0, this._maximumLength = void 0;
  }
  reserve(i) {
    i = defaultValue$1(i, this._length), this._array.length = i;
  }
  heapify(i) {
    i = defaultValue$1(i, 0);
    const e = this._length, r = this._comparator, s = this._array;
    let a = -1, c = !0;
    for (; c; ) {
      const l = 2 * (i + 1), h = l - 1;
      h < e && r(s[h], s[i]) < 0 ? a = h : a = i, l < e && r(s[l], s[a]) < 0 && (a = l), a !== i ? (swap$1(s, a, i), i = a) : c = !1;
    }
  }
  resort() {
    const i = this._length;
    for (let e = Math.ceil(i / 2); e >= 0; --e)
      this.heapify(e);
  }
  insert(i) {
    const e = this._array, r = this._comparator, s = this._maximumLength;
    let a = this._length++;
    for (a < e.length ? e[a] = i : e.push(i); a !== 0; ) {
      const l = Math.floor((a - 1) / 2);
      if (r(e[a], e[l]) < 0)
        swap$1(e, a, l), a = l;
      else
        break;
    }
    let c;
    return defined$2(s) && this._length > s && (c = e[s], this._length = s), c;
  }
  pop(i) {
    if (i = defaultValue$1(i, 0), this._length === 0)
      return;
    const e = this._array, r = e[i];
    return swap$1(e, i, --this._length), this.heapify(i), e[this._length] = void 0, r;
  }
  get length() {
    return this._length;
  }
  get internalArray() {
    return this._array;
  }
  get maximumLength() {
    return this._maximumLength;
  }
  set maximumLength(i) {
    const e = this._length;
    if (i < e) {
      const r = this._array;
      for (let s = i; s < e; ++s)
        r[s] = void 0;
      this._length = i, r.length = i;
    }
    this._maximumLength = i;
  }
  get comparator() {
    return this._comparator;
  }
}
const dataUriRegex$1 = /^data:/i;
function isDataUri(o) {
  return dataUriRegex$1.test(o);
}
const blobUriRegex = /^blob:/i;
function isBlobUri(o) {
  return blobUriRegex.test(o);
}
function sortRequests(o, i) {
  return o.priority - i.priority;
}
const statistics = {
  numberOfAttemptedRequests: 0,
  numberOfActiveRequests: 0,
  numberOfCancelledRequests: 0,
  numberOfCancelledActiveRequests: 0,
  numberOfFailedRequests: 0,
  numberOfActiveRequestsEver: 0,
  lastNumberOfActiveRequests: 0
};
let priorityHeapLength = 20;
const requestHeap = new Heap({
  comparator: sortRequests
});
requestHeap.maximumLength = priorityHeapLength;
requestHeap.reserve(priorityHeapLength);
const pageUri = typeof document < "u" ? new Uri(document.location.href) : new Uri(), activeRequests = [];
let numberOfActiveRequestsByServer = {};
const Ye = class {
  static get statistics() {
    return statistics;
  }
  static get priorityHeapLength() {
    return priorityHeapLength;
  }
  static set priorityHeapLength(i) {
    if (i < priorityHeapLength)
      for (; requestHeap.length > i; ) {
        const e = requestHeap.pop();
        cancelRequest(e);
      }
    priorityHeapLength = i, requestHeap.maximumLength = i, requestHeap.reserve(i);
  }
  static update() {
    let i, e, r = 0;
    const s = activeRequests.length;
    for (i = 0; i < s; i++) {
      if (e = activeRequests[i], e.cancelled && cancelRequest(e), e.state !== RequestState$1.ACTIVE) {
        ++r;
        continue;
      }
      r > 0 && (activeRequests[i - r] = e);
    }
    activeRequests.length -= r;
    const a = requestHeap.internalArray, c = requestHeap.length;
    for (i = 0; i < c; ++i)
      updatePriority(a[i]);
    requestHeap.resort();
    const l = Math.max(
      Ye.maximumRequests - activeRequests.length,
      0
    );
    let h = 0;
    for (; h < l && requestHeap.length > 0; ) {
      if (e = requestHeap.pop(), e.cancelled) {
        cancelRequest(e);
        continue;
      }
      if (e.throttleByServer && !Ye.serverHasOpenSlots(e.serverKey)) {
        cancelRequest(e);
        continue;
      }
      startRequest(e), ++h;
    }
  }
  static request(i) {
    if (isDataUri(i.url) || isBlobUri(i.url))
      return i.state = RequestState$1.RECEIVED, i.requestFunction();
    if (++statistics.numberOfAttemptedRequests, defined$2(i.serverKey) || (i.serverKey = Ye.getServerKey(i.url)), !i.throttle)
      return startRequest(i);
    if (activeRequests.length >= Ye.maximumRequests)
      return;
    updatePriority(i);
    const e = requestHeap.insert(i);
    if (defined$2(e)) {
      if (e === i)
        return;
      cancelRequest(e);
    }
    return issueRequest(i);
  }
};
let RequestScheduler = Ye;
_(RequestScheduler, "maximumRequests", 50), _(RequestScheduler, "maximumRequestsPerServer", 18), _(RequestScheduler, "requestsByServer", {}), _(RequestScheduler, "throttleRequests", !0), _(RequestScheduler, "debugShowStatistics", !1), _(RequestScheduler, "getServerKey", function(i) {
  let e = new Uri(i);
  e.scheme() === "" && (e = e.absoluteTo(pageUri), e.normalize());
  let r = e.authority();
  /:/.test(r) || (r = `${r}:${e.scheme() === "https" ? "443" : "80"}`);
  const s = numberOfActiveRequestsByServer[r];
  return defined$2(s) || (numberOfActiveRequestsByServer[r] = 0), r;
}), _(RequestScheduler, "serverHasOpenSlots", function(i, e) {
  e = defaultValue$1(e, 1);
  const r = defaultValue$1(
    Ye.requestsByServer[i],
    Ye.maximumRequestsPerServer
  );
  return numberOfActiveRequestsByServer[i] + e <= r;
}), _(RequestScheduler, "heapHasOpenSlots", function(i) {
  return requestHeap.length + i <= priorityHeapLength;
});
function cancelRequest(o) {
  const i = o.state === RequestState$1.ACTIVE;
  if (o.state = RequestState$1.CANCELLED, ++statistics.numberOfCancelledRequests, defined$2(o.deferred)) {
    const e = o.deferred;
    o.deferred = void 0, e.reject();
  }
  i && (--statistics.numberOfActiveRequests, --numberOfActiveRequestsByServer[o.serverKey], ++statistics.numberOfCancelledActiveRequests), defined$2(o.cancelFunction) && o.cancelFunction();
}
function updatePriority(o) {
  defined$2(o.priorityFunction) && (o.priority = o.priorityFunction());
}
function issueRequest(o) {
  return o.state === RequestState$1.UNISSUED && (o.state = RequestState$1.ISSUED, o.deferred = defer()), o.deferred.promise;
}
function getRequestReceivedFunction(o) {
  return function(i) {
    if (o.state === RequestState$1.CANCELLED)
      return;
    const e = o.deferred;
    --statistics.numberOfActiveRequests, --numberOfActiveRequestsByServer[o.serverKey], o.state = RequestState$1.RECEIVED, o.deferred = void 0, e.resolve(i);
  };
}
function getRequestFailedFunction(o) {
  return function(i) {
    o.state !== RequestState$1.CANCELLED && (++statistics.numberOfFailedRequests, --statistics.numberOfActiveRequests, --numberOfActiveRequestsByServer[o.serverKey], o.state = RequestState$1.FAILED, o.deferred.reject(i));
  };
}
function startRequest(o) {
  const i = issueRequest(o);
  return o.state = RequestState$1.ACTIVE, activeRequests.push(o), ++statistics.numberOfActiveRequests, ++statistics.numberOfActiveRequestsEver, ++numberOfActiveRequestsByServer[o.serverKey], o.requestFunction().then(getRequestReceivedFunction(o)).catch(getRequestFailedFunction(o)), i;
}
class DoublyLinkedListNode {
  constructor(i, e, r) {
    this.item = i, this.previous = e, this.next = r;
  }
}
function remove(o, i) {
  defined$2(i.previous) && defined$2(i.next) ? (i.previous.next = i.next, i.next.previous = i.previous) : defined$2(i.previous) ? (i.previous.next = void 0, o.tail = i.previous) : defined$2(i.next) ? (i.next.previous = void 0, o.head = i.next) : (o.head = void 0, o.tail = void 0), i.next = void 0, i.previous = void 0;
}
class DoublyLinkedList {
  constructor() {
    this.head = void 0, this.tail = void 0, this._length = 0;
  }
  add(i) {
    const e = new DoublyLinkedListNode(i, this.tail, void 0);
    return defined$2(this.tail) ? (this.tail.next = e, this.tail = e) : (this.head = e, this.tail = e), ++this._length, e;
  }
  remove(i) {
    !defined$2(i) || (remove(this, i), --this._length);
  }
  splice(i, e) {
    if (i === e)
      return;
    remove(this, e);
    const r = i.next;
    i.next = e, this.tail === i ? this.tail = e : r.previous = e, e.next = r, e.previous = i;
  }
  get length() {
    return this._length;
  }
}
class Cesium3DTilesetCache {
  constructor() {
    this._list = new DoublyLinkedList(), this._sentinel = this._list.add(), this.trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(i) {
    const e = i.cacheNode;
    defined$2(e) && this._list.splice(this._sentinel, e);
  }
  add(i) {
    defined$2(i.cachedNode) || (i.cacheNode = this._list.add(i));
  }
  unloadTile(i, e, r) {
    const s = e.cacheNode;
    !defined$2(s) || (this._list.remove(s), e.cacheNode = void 0, r(i, e));
  }
  unloadTiles(i, e) {
    const r = this._trimTiles;
    this._trimTiles = !1;
    const s = this._list, a = this._sentinel;
    let c = s.head;
    for (; c !== a && (i.totalMemoryUsageInBytes > i.cacheBytes || r); ) {
      const l = c.item;
      c = c.next, this.unloadTile(i, l, e);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
class Cesium3DTilesetStatistics {
  constructor() {
    this.selected = 0, this.visited = 0, this.numberOfAttemptedRequests = 0, this.numberOfPendingRequests = 0, this.numberOfTilesProcessing = 0, this.numberOfTilesWithContentReady = 0, this.numberOfTilesTotal = 0, this.numberOfLoadedTilesTotal = 0, this.numberOfTilesCulledWithChildrenUnion = 0, this.totalByteLength = 0;
  }
  clear() {
    this.selected = 0, this.visited = 0, this.numberOfAttemptedRequests = 0, this.numberOfTilesCulledWithChildrenUnion = 0;
  }
  incrementSelectionCounts() {
    updatePointAndFeatureCounts(this, this.content, !1, !1);
  }
  incrementLoadCounts(i) {
    updatePointAndFeatureCounts(this, i, !1, !0);
  }
  decrementLoadCounts(i) {
    updatePointAndFeatureCounts(this, i, !0, !0);
  }
}
function updatePointAndFeatureCounts(o, i, e, r) {
  const s = i.innerContents;
  i.pointsLength, i.trianglesLength, i.featuresLength;
  const a = i.byteSize;
  if (r && (o.totalByteLength += e ? -a : a), defined$2(s)) {
    const c = s.length;
    for (let l = 0; l < c; ++l)
      updatePointAndFeatureCounts(o, s[l], e, r);
  }
}
function objectToQuery(o) {
  if (!defined$2(o))
    throw new Error("obj is required.");
  let i = "";
  for (const e in o)
    if (o.hasOwnProperty(e)) {
      const r = o[e], s = `${encodeURIComponent(e)}=`;
      if (Array.isArray(r))
        for (let a = 0, c = r.length; a < c; ++a)
          i += `${s + encodeURIComponent(r[a])}&`;
      else
        i += `${s + encodeURIComponent(r)}&`;
    }
  return i = i.slice(0, -1), i;
}
function checkAndResetRequest(o) {
  if (o.state === RequestState$1.ISSUED || o.state === RequestState$1.ACTIVE)
    throw new Error("The Resource is already being fetched.");
  o.state = RequestState$1.UNISSUED, o.deferred = void 0;
}
function stringifyQuery(o) {
  const i = Object.keys(o);
  return i.length === 0 ? "" : i.length === 1 && !defined$2(o[i[0]]) ? `?${i[0]}` : `?${objectToQuery(o)}`;
}
function queryToObject(o) {
  const i = {};
  if (o === "")
    return i;
  const e = o.replace(/\+/g, "%20").split(/[&;]/);
  for (let r = 0, s = e.length; r < s; ++r) {
    const a = e[r].split("="), c = decodeURIComponent(a[0]);
    let l = a[1];
    defined$2(l) ? l = decodeURIComponent(l) : l = "";
    const h = i[c];
    typeof h == "string" ? i[c] = [h, l] : Array.isArray(h) ? h.push(l) : i[c] = l;
  }
  return i;
}
function combine(o, i, e) {
  e = defaultValue$1(e, !1);
  const r = {}, s = defined$2(o), a = defined$2(i);
  let c, l, h;
  if (s)
    for (c in o)
      o.hasOwnProperty(c) && (l = o[c], a && e && typeof l == "object" && i.hasOwnProperty(c) ? (h = i[c], typeof h == "object" ? r[c] = combine(l, h, e) : r[c] = l) : r[c] = l);
  if (a)
    for (c in i)
      i.hasOwnProperty(c) && !r.hasOwnProperty(c) && (h = i[c], r[c] = h);
  return r;
}
function clone(o, i) {
  if (o === null || typeof o != "object")
    return o;
  i = defaultValue$1(i, !1);
  const e = new o.constructor();
  for (const r in o)
    if (o.hasOwnProperty(r)) {
      let s = o[r];
      i && (s = clone(s, i)), e[r] = s;
    }
  return e;
}
function combineQueryParameters(o, i, e) {
  if (!e)
    return combine(o, i);
  const r = clone(o, !0);
  for (const s in i)
    if (i.hasOwnProperty(s)) {
      let a = r[s];
      const c = i[s];
      defined$2(a) ? (Array.isArray(a) || (a = r[s] = [a]), r[s] = a.concat(c)) : r[s] = Array.isArray(c) ? c.slice() : c;
    }
  return r;
}
function parseQueryString(o) {
  return o.length === 0 ? {} : o.indexOf("=") === -1 ? { [o]: void 0 } : queryToObject(o);
}
class Resource {
  constructor(i) {
    i = defaultValue$1(i, {}), typeof i == "string" && (i = {
      url: i
    }), this._url = void 0, this._templateValues = defaultValue$1(i.templateValues, {}), this._queryParameters = defaultValue$1(i.queryParameters, {}), this.headers = defaultValue$1(i.headers, {}), this.request = defaultValue$1(i.request, new Request()), this.proxy = i.proxy, this.retryCallback = i.retryCallback, this.retryAttempts = defaultValue$1(i.retryAttempts, 0), this._retryCount = 0, defaultValue$1(i.parseUrl, !0) ? this.parseUrl(i.url, !0, !0) : this._url = i.url;
  }
  parseUrl(i, e, r, s) {
    let a = new Uri(i);
    const c = parseQueryString(a.query());
    this._queryParameters = e ? combineQueryParameters(c, this.queryParameters, r) : c, a.search(""), a.fragment(""), defined$2(s) && a.scheme() === "" && (a = a.absoluteTo(getAbsoluteUri(s))), this._url = a.toString();
  }
  clone(i) {
    return defined$2(i) ? (i._url = this._url, i._queryParameters = clone(this._queryParameters), i._templateValues = clone(this._templateValues), i.headers = clone(this.headers), i.proxy = this.proxy, i.retryCallback = this.retryCallback, i.retryAttempts = this.retryAttempts, i._retryCount = 0, i.request = this.request.clone(), i) : new Resource({
      url: this._url,
      queryParameters: this.queryParameters,
      templateValues: this.templateValues,
      headers: this.headers,
      proxy: this.proxy,
      retryCallback: this.retryCallback,
      retryAttempts: this.retryAttempts,
      request: this.request.clone(),
      parseUrl: !1,
      credits: defined$2(this.credits) ? this.credits.slice() : void 0
    });
  }
  setQueryParameters(i, e) {
    e ? this._queryParameters = combineQueryParameters(
      this._queryParameters,
      i,
      !1
    ) : this._queryParameters = combineQueryParameters(
      i,
      this._queryParameters,
      !1
    );
  }
  getDerivedResource(i) {
    const e = this.clone();
    if (e._retryCount = 0, defined$2(i.url)) {
      const r = defaultValue$1(i.preserveQueryParameters, !1);
      e.parseUrl(i.url, !0, r, this._url);
    }
    return defined$2(i.queryParameters) && (e._queryParameters = combine(
      i.queryParameters,
      e.queryParameters
    )), defined$2(i.templateValues) && (e._templateValues = combine(
      i.templateValues,
      e.templateValues
    )), defined$2(i.headers) && (e.headers = combine(i.headers, e.headers)), defined$2(i.proxy) && (e.proxy = i.proxy), defined$2(i.request) && (e.request = i.request), defined$2(i.retryCallback) && (e.retryCallback = i.retryCallback), defined$2(i.retryAttempts) && (e.retryAttempts = i.retryAttempts), e;
  }
  fetchJson() {
    const i = this.fetch({
      responseType: "text",
      headers: {
        Accept: "application/json,*/*;q=0.01"
      }
    });
    if (!!defined$2(i))
      return i.then(function(e) {
        if (!!defined$2(e))
          return JSON.parse(e);
      });
  }
  fetchArrayBuffer() {
    return this.fetch({
      responseType: "arraybuffer"
    });
  }
  fetch(i) {
    return i = defaultValue$1(i, {}), i.method = "GET", this._makeRequest(i);
  }
  retryOnError(i) {
    const e = this.retryCallback;
    if (typeof e != "function" || this._retryCount >= this.retryAttempts)
      return Promise.resolve(!1);
    const r = this;
    return Promise.resolve(e(this, i)).then(function(s) {
      return ++r._retryCount, s;
    });
  }
  _makeRequest(i) {
    const e = this;
    checkAndResetRequest(e.request);
    const r = e.request, s = e.url;
    r.url = s, r.requestFunction = function() {
      const c = i.responseType, l = combine(i.headers, e.headers), h = i.overrideMimeType, d = i.method, f = i.data, p = defer(), m = Resource._Implementations.loadWithXhr(
        s,
        c,
        d,
        f,
        l,
        p,
        h
      );
      return defined$2(m) && defined$2(m.abort) && (r.cancelFunction = function() {
        m.abort();
      }), p.promise;
    };
    const a = RequestScheduler.request(r);
    if (!!defined$2(a))
      return a.then(function(c) {
        return r.cancelFunction = void 0, c;
      }).catch(function(c) {
        return r.cancelFunction = void 0, r.state !== RequestState$1.FAILED ? Promise.reject(c) : e.retryOnError(c).then(function(l) {
          return l ? (r.state = RequestState$1.UNISSUED, r.deferred = void 0, e.fetch(i)) : Promise.reject(c);
        });
      });
  }
  getUrlComponent(i, e) {
    if (this.isDataUri)
      return this._url;
    let r = this._url;
    i && (r = `${r}${stringifyQuery(this.queryParameters || {})}`), r = r.replace(/%7B/g, "{").replace(/%7D/g, "}");
    const s = this._templateValues;
    return Object.keys(s).length > 0 && (r = r.replace(/{(.*?)}/g, function(a, c) {
      const l = s[c];
      return defined$2(l) ? encodeURIComponent(l) : a;
    })), e && defined$2(this.proxy) && (r = this.proxy.getURL(r)), r;
  }
  getBaseUri(i) {
    return getBaseUri(this.getUrlComponent(i), i);
  }
  static createIfNeeded(i) {
    return i instanceof Resource ? i.getDerivedResource({
      request: i.request
    }) : typeof i != "string" ? i : new Resource({
      url: i
    });
  }
  static fetchArrayBuffer(i) {
    return new Resource(i).fetchArrayBuffer();
  }
  get url() {
    return this.getUrlComponent(!0, !0);
  }
  set url(i) {
    this.parseUrl(i, !1, !1);
  }
  get queryParameters() {
    return this._queryParameters;
  }
  get extension() {
    return getExtensionFromUri(this._url);
  }
}
const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
function decodeDataUriText(o, i) {
  const e = decodeURIComponent(i);
  return o ? atob(e) : e;
}
function decodeDataUriArrayBuffer(o, i) {
  const e = decodeDataUriText(o, i), r = new ArrayBuffer(e.length), s = new Uint8Array(r);
  for (let a = 0; a < e.length; a++)
    s[a] = e.charCodeAt(a);
  return r;
}
function decodeDataUri(o, i) {
  i = defaultValue$1(i, "");
  const e = o[1], r = !!o[2], s = o[3];
  let a, c;
  switch (i) {
    case "":
    case "text":
      return decodeDataUriText(r, s);
    case "arraybuffer":
      return decodeDataUriArrayBuffer(r, s);
    case "blob":
      return a = decodeDataUriArrayBuffer(r, s), new Blob([a], {
        type: e
      });
    case "document":
      return c = new DOMParser(), c.parseFromString(
        decodeDataUriText(r, s),
        e
      );
    case "json":
      return JSON.parse(decodeDataUriText(r, s));
    default:
      throw new Error(`Unhandled responseType: ${i}`);
  }
}
const noXMLHttpRequest = typeof XMLHttpRequest > "u";
function loadWithHttpRequest(o, i, e, r, s, a, c) {
  fetch(o, {
    method: e,
    headers: s
  }).then(async (l) => {
    if (!l.ok) {
      l.headers.forEach((h, d) => {
      }), a.reject();
      return;
    }
    switch (i) {
      case "text":
        a.resolve(l.text());
        break;
      case "json":
        a.resolve(l.json());
        break;
      default:
        a.resolve(new Uint8Array(await l.arrayBuffer()).buffer);
        break;
    }
  }).catch(() => {
  });
}
Resource._Implementations = {};
Resource._Implementations.loadWithXhr = function(o, i, e, r, s, a, c) {
  const l = dataUriRegex.exec(o);
  if (l !== null) {
    a.resolve(decodeDataUri(l, i));
    return;
  }
  if (noXMLHttpRequest) {
    loadWithHttpRequest(
      o,
      i,
      e,
      r,
      s,
      a
    );
    return;
  }
  const h = new XMLHttpRequest();
  if (h.open(e, o, !0), defined$2(c) && defined$2(h.overrideMimeType) && h.overrideMimeType(c), defined$2(s))
    for (const f in s)
      s.hasOwnProperty(f) && h.setRequestHeader(f, s[f]);
  defined$2(i) && (h.responseType = i);
  let d = !1;
  return typeof o == "string" && (d = o.indexOf("file://") === 0 || typeof window < "u" && window.location.origin === "file://"), h.onload = function() {
    if ((h.status < 200 || h.status >= 300) && !(d && h.status === 0)) {
      a.reject();
      return;
    }
    const f = h.response, p = h.responseType;
    if (e === "HEAD" || e === "OPTIONS") {
      const y = h.getAllResponseHeaders().trim().split(/[\r\n]+/), x = {};
      y.forEach(function(v) {
        const S = v.split(": "), E = S.shift();
        x[E] = S.join(": ");
      }), a.resolve(x);
      return;
    }
    if (h.status === 204)
      a.resolve(void 0);
    else if (defined$2(f) && (!defined$2(i) || p === i))
      a.resolve(f);
    else if (i === "json" && typeof f == "string")
      try {
        a.resolve(JSON.parse(f));
      } catch (m) {
        a.reject(m);
      }
    else
      (p === "" || p === "document") && defined$2(h.responseXML) && h.responseXML.hasChildNodes() ? a.resolve(h.responseXML) : (p === "" || p === "text") && defined$2(h.responseText) ? a.resolve(h.responseText) : a.reject(
        new Error("Invalid XMLHttpRequest response type.")
      );
  }, h.onerror = function(f) {
  }, h.send(r), h;
};
const Cesium3DTileOptimizations = {}, scratchAxis = new Vector3$1(), Cesium3DTileOptimizationHint = {
  NOT_COMPUTED: -1,
  USE_OPTIMIZATION: 1,
  SKIP_OPTIMIZATION: 0
};
function getObb(o) {
  const i = o.boundingVolume;
  let e;
  return i.obb ? e = i.obb : i.regionObb && (e = i.regionObb), e;
}
Cesium3DTileOptimizations.checkChildrenWithinParent = function(o) {
  const i = o.children, e = i.length, r = getObb(o);
  if (r) {
    o._optimChildrenWithinParent = Cesium3DTileOptimizationHint.USE_OPTIMIZATION;
    for (let s = 0; s < e; ++s) {
      const a = i[s], c = getObb(a);
      if (!c) {
        o._optimChildrenWithinParent = Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;
        break;
      }
      const l = scratchAxis.subVectors(
        c.center,
        r.center
      ), h = l.length();
      l.divideScalar(h);
      const d = r.halfAxes, f = Math.abs(d[0] * l.x) + Math.abs(d[1] * l.y) + Math.abs(d[2] * l.z) + Math.abs(d[3] * l.x) + Math.abs(d[4] * l.y) + Math.abs(d[5] * l.z) + Math.abs(d[6] * l.x) + Math.abs(d[7] * l.y) + Math.abs(d[8] * l.z), p = c.halfAxes, m = Math.abs(p[0] * l.x) + Math.abs(p[1] * l.y) + Math.abs(p[2] * l.z) + Math.abs(p[3] * l.x) + Math.abs(p[4] * l.y) + Math.abs(p[5] * l.z) + Math.abs(p[6] * l.x) + Math.abs(p[7] * l.y) + Math.abs(p[8] * l.z);
      if (f <= m + h) {
        o._optimChildrenWithinParent = Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;
        break;
      }
    }
  }
  return o._optimChildrenWithinParent === Cesium3DTileOptimizationHint.USE_OPTIMIZATION;
};
const _mat3 = new Matrix3();
function findIntersectionPoint(o, i, e, r) {
  const s = _mat3.set(
    o.normal.x,
    o.normal.y,
    o.normal.z,
    i.normal.x,
    i.normal.y,
    i.normal.z,
    e.normal.x,
    e.normal.y,
    e.normal.z
  );
  return r.set(-o.constant, -i.constant, -e.constant), r.applyMatrix3(s.invert()), r;
}
class ExtendedFrustum extends Frustum {
  constructor() {
    super(), this.points = Array(8).fill().map(() => new Vector3$1());
  }
  setFromProjectionMatrix(i, e) {
    super.setFromProjectionMatrix(i, e), this.calculateFrustumPoints();
  }
  calculateFrustumPoints() {
    const { planes: i, points: e } = this;
    [
      [i[0], i[3], i[4]],
      [i[1], i[3], i[4]],
      [i[0], i[2], i[4]],
      [i[1], i[2], i[4]],
      [i[0], i[3], i[5]],
      [i[1], i[3], i[5]],
      [i[0], i[2], i[5]],
      [i[1], i[2], i[5]]
    ].forEach((s, a) => {
      findIntersectionPoint(s[0], s[1], s[2], e[a]);
    });
  }
}
function Empty3DTileContent(o, i) {
  this._tileset = o, this._tile = i, this.featurePropertiesDirty = !1;
}
Object.defineProperties(Empty3DTileContent.prototype, {
  featuresLength: {
    get: function() {
      return 0;
    }
  },
  pointsLength: {
    get: function() {
      return 0;
    }
  },
  trianglesLength: {
    get: function() {
      return 0;
    }
  },
  geometryByteLength: {
    get: function() {
      return 0;
    }
  },
  texturesByteLength: {
    get: function() {
      return 0;
    }
  },
  batchTableByteLength: {
    get: function() {
      return 0;
    }
  },
  innerContents: {
    get: function() {
    }
  },
  ready: {
    get: function() {
      return !0;
    }
  },
  tileset: {
    get: function() {
      return this._tileset;
    }
  },
  tile: {
    get: function() {
      return this._tile;
    }
  },
  url: {
    get: function() {
    }
  },
  metadata: {
    get: function() {
    },
    set: function(o) {
      throw new Error(
        "Empty3DTileContent cannot have content metadata"
      );
    }
  },
  batchTable: {
    get: function() {
    }
  },
  group: {
    get: function() {
    },
    set: function(o) {
      throw new Error("Empty3DTileContent cannot have group metadata");
    }
  }
});
Empty3DTileContent.prototype.hasProperty = function(o, i) {
  return !1;
};
Empty3DTileContent.prototype.getFeature = function(o) {
};
Empty3DTileContent.prototype.applyDebugSettings = function(o, i) {
};
Empty3DTileContent.prototype.applyStyle = function(o) {
};
Empty3DTileContent.prototype.update = function(o, i) {
};
Empty3DTileContent.prototype.pick = function(o, i, e) {
};
Empty3DTileContent.prototype.isDestroyed = function() {
  return !1;
};
Empty3DTileContent.prototype.destroy = function() {
  return destroyObject(this);
};
const Cesium3DTileContentType = {
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  VECTOR: "vctr",
  GEOMETRY: "geom",
  GLTF: "gltf",
  GLTF_BINARY: "glb",
  IMPLICIT_SUBTREE: "subt",
  IMPLICIT_SUBTREE_JSON: "subtreeJson",
  EXTERNAL_TILESET: "externalTileset",
  MULTIPLE_CONTENT: "multipleContent",
  GEOJSON: "geoJson",
  VOXEL_BINARY: "voxl",
  VOXEL_JSON: "voxelJson"
};
Cesium3DTileContentType.isBinaryFormat = function(o) {
  switch (o) {
    case Cesium3DTileContentType.BATCHED_3D_MODEL:
    case Cesium3DTileContentType.INSTANCED_3D_MODEL:
    case Cesium3DTileContentType.COMPOSITE:
    case Cesium3DTileContentType.POINT_CLOUD:
    case Cesium3DTileContentType.VECTOR:
    case Cesium3DTileContentType.GEOMETRY:
    case Cesium3DTileContentType.IMPLICIT_SUBTREE:
    case Cesium3DTileContentType.VOXEL_BINARY:
    case Cesium3DTileContentType.GLTF_BINARY:
      return !0;
    default:
      return !1;
  }
};
const Cesium3DTileContentType$1 = Object.freeze(Cesium3DTileContentType);
class Tileset3DTileContent {
  constructor(i, e, r) {
    this.isTileset3DTileContent = !0, this._tileset = i, this._tile = e, this._resource = r, this.featurePropertiesDirty = null, this._metadata = void 0, this._group = void 0, this._ready = !1;
  }
  static fromJson(i, e, r, s) {
    const a = new Tileset3DTileContent(i, e, r);
    return a._tileset.loadTileset(a._resource, s, a._tile), a._ready = !0, a;
  }
  hasProperty(i, e) {
    return !1;
  }
  getFeature(i) {
  }
  applyDebugSettings() {
  }
  applyStyle(i) {
  }
  update(i, e) {
  }
  isDestroyed() {
    return !1;
  }
  destroy() {
    return destroyObject(this);
  }
  get featuresLength() {
    return 0;
  }
  get pointsLength() {
    return 0;
  }
  get trianglesLength() {
    return 0;
  }
  get geometryByteLength() {
    return 0;
  }
  get texturesByteLength() {
    return 0;
  }
  get batchTableByteLength() {
    return 0;
  }
  get innerContents() {
  }
  get ready() {
    return this._ready;
  }
  get tileset() {
    return this._tileset;
  }
  get tile() {
    return this._tile;
  }
  get url() {
    return this._resource.getUrlComponent(!0);
  }
  get batchTable() {
  }
  get metadata() {
    return this._metadata;
  }
  set metadata(i) {
    this._metadata = i;
  }
  get group() {
    return this._group;
  }
  set group(i) {
    this._group = i;
  }
}
const utf8decoder = new TextDecoder();
function arrayToString(o) {
  return utf8decoder.decode(o);
}
function parseBinArray(o, i, e, r, s, a) {
  let c;
  switch (r) {
    case "SCALAR":
      c = 1;
      break;
    case "VEC2":
      c = 2;
      break;
    case "VEC3":
      c = 3;
      break;
    case "VEC4":
      c = 4;
      break;
    default:
      throw new Error(`FeatureTable : Feature type not provided for "${a}".`);
  }
  let l;
  const h = e * c;
  switch (s) {
    case "BYTE":
      l = new Int8Array(o, i, h);
      break;
    case "UNSIGNED_BYTE":
      l = new Uint8Array(o, i, h);
      break;
    case "SHORT":
      l = new Int16Array(o, i, h);
      break;
    case "UNSIGNED_SHORT":
      l = new Uint16Array(o, i, h);
      break;
    case "INT":
      l = new Int32Array(o, i, h);
      break;
    case "UNSIGNED_INT":
      l = new Uint32Array(o, i, h);
      break;
    case "FLOAT":
      l = new Float32Array(o, i, h);
      break;
    case "DOUBLE":
      l = new Float64Array(o, i, h);
      break;
    default:
      throw new Error(`FeatureTable : Feature component type not provided for "${a}".`);
  }
  return l;
}
class FeatureTable {
  constructor(i, e, r, s) {
    this.buffer = i, this.binOffset = e + r, this.binLength = s;
    let a = null;
    if (r !== 0) {
      const c = new Uint8Array(i, e, r);
      a = JSON.parse(arrayToString(c));
    } else
      a = {};
    this.header = a;
  }
  getKeys() {
    return Object.keys(this.header);
  }
  getData(i, e, r = null, s = null) {
    const a = this.header;
    if (!(i in a))
      return null;
    const c = a[i];
    if (c instanceof Object) {
      if (Array.isArray(c))
        return c;
    } else
      return c;
    const { buffer: l, binOffset: h, binLength: d } = this, f = c.byteOffset || 0, p = c.type || s, m = c.componentType || r;
    if ("type" in c && s && c.type !== s)
      throw new Error("FeatureTable: Specified type does not match expected type.");
    const y = h + f, x = parseBinArray(l, y, e, p, m, i);
    if (y + x.byteLength > h + d)
      throw new Error("FeatureTable: Feature data read outside binary body length.");
    return x;
  }
  getBuffer(i, e) {
    const { buffer: r, binOffset: s } = this;
    return r.slice(s + i, s + i + e);
  }
}
class BatchTableHierarchyExtension {
  constructor(i) {
    var s;
    this.batchTable = i;
    const e = i.header.extensions["3DTILES_batch_table_hierarchy"];
    this.classes = e.classes;
    for (const a of this.classes) {
      const c = a.instances;
      for (const l in c)
        c.hasOwnProperty(l) && (a.instances[l] = this._parseProperty(c[l], a.length, l));
    }
    if (this.instancesLength = e.instancesLength, this.classIds = this._parseProperty(e.classIds, this.instancesLength, "classIds"), e.parentCounts ? this.parentCounts = this._parseProperty(e.parentCounts, this.instancesLength, "parentCounts") : this.parentCounts = new Array(this.instancesLength).fill(1), e.parentIds) {
      const a = this.parentCounts.reduce((c, l) => c + l, 0);
      this.parentIds = this._parseProperty(e.parentIds, a, "parentIds");
    } else
      this.parentIds = null;
    this.instancesIds = [];
    const r = {};
    for (const a of this.classIds)
      r[a] = (s = r[a]) != null ? s : 0, this.instancesIds.push(r[a]), r[a]++;
  }
  _parseProperty(i, e, r) {
    if (Array.isArray(i))
      return i;
    const { buffer: s, binOffset: a } = this.batchTable, c = i.byteOffset, l = i.componentType || "UNSIGNED_SHORT", h = a + c;
    return parseBinArray(s, h, e, "SCALAR", l, r);
  }
  getDataFromId(i, e = {}) {
    const r = this.parentCounts[i];
    if (this.parentIds && r > 0) {
      let h = 0;
      for (let d = 0; d < i; d++)
        h += this.parentCounts[d];
      for (let d = 0; d < r; d++) {
        const f = this.parentIds[h + d];
        f !== i && this.getDataFromId(f, e);
      }
    }
    const s = this.classIds[i], a = this.classes[s].instances, c = this.classes[s].name, l = this.instancesIds[i];
    for (const h in a)
      a.hasOwnProperty(h) && (e[c] = e[c] || {}, e[c][h] = a[h][l]);
    return e;
  }
}
class BatchTable extends FeatureTable {
  constructor(i, e, r, s, a) {
    super(i, r, s, a), this.batchSize = e, this.extensions = {};
    const c = this.header.extensions;
    c && c["3DTILES_batch_table_hierarchy"] && (this.extensions["3DTILES_batch_table_hierarchy"] = new BatchTableHierarchyExtension(this));
  }
  getData(i, e = null, r = null) {
    return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId instead."), super.getData(i, this.batchSize, e, r);
  }
  getDataFromId(i, e = {}) {
    if (i < 0 || i >= this.batchSize)
      throw new Error(`BatchTable: id value "${i}" out of bounds for "${this.batchSize}" features number.`);
    for (const r of this.getKeys())
      r !== "extensions" && (e[r] = super.getData(r, this.batchSize)[i]);
    for (const r in this.extensions)
      if (this.extensions.hasOwnProperty(r)) {
        const s = this.extensions[r];
        s.getDataFromId instanceof Function && (e[r] = e[r] || {}, s.getDataFromId(i, e[r]));
      }
    return e;
  }
}
class LoaderBase {
  constructor() {
    this.fetchOptions = {}, this.workingPath = "";
  }
  load(i) {
    return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'), this.loadAsync(i);
  }
  loadAsync(i) {
    return fetch(i, this.fetchOptions).then((e) => {
      if (!e.ok)
        throw new Error(`Failed to load file "${i}" with status ${e.status} : ${e.statusText}`);
      return e.arrayBuffer();
    }).then((e) => (this.workingPath === "" && (this.workingPath = this.workingPathForURL(i)), this.parse(e)));
  }
  resolveExternalURL(i) {
    return /^[^\\/]/.test(i) ? this.workingPath + "/" + i : i;
  }
  workingPathForURL(i) {
    const e = i.split(/[\\/]/g);
    return e.pop(), e.join("/") + "/";
  }
  parse(i) {
    throw new Error("LoaderBase: Parse not implemented.");
  }
}
class B3DMLoaderBase extends LoaderBase {
  parse(i) {
    const e = new DataView(i), r = e.getUint32(4, !0);
    console.assert(r === 1);
    const s = e.getUint32(8, !0);
    console.assert(s === i.byteLength);
    const a = e.getUint32(12, !0), c = e.getUint32(16, !0), l = e.getUint32(20, !0), h = e.getUint32(24, !0), d = 28, f = i.slice(
      d,
      d + a + c
    ), p = new FeatureTable(
      f,
      0,
      a,
      c
    ), m = d + a + c, y = i.slice(
      m,
      m + l + h
    ), x = new BatchTable(
      y,
      p.getData("BATCH_LENGTH"),
      0,
      l,
      h
    ), v = m + l + h, S = new Uint8Array(i, v, s - v);
    return {
      version: r,
      featureTable: p,
      batchTable: x,
      glbBytes: S
    };
  }
}
class GLTFLoader extends Loader {
  constructor(i) {
    super(i), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e) {
      return new GLTFMaterialsClearcoatExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsDispersionExtension(e);
    }), this.register(function(e) {
      return new GLTFTextureBasisUExtension(e);
    }), this.register(function(e) {
      return new GLTFTextureWebPExtension(e);
    }), this.register(function(e) {
      return new GLTFTextureAVIFExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsSheenExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsTransmissionExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsVolumeExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsIorExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsEmissiveStrengthExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsSpecularExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsIridescenceExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsAnisotropyExtension(e);
    }), this.register(function(e) {
      return new GLTFMaterialsBumpExtension(e);
    }), this.register(function(e) {
      return new GLTFLightsExtension(e);
    }), this.register(function(e) {
      return new GLTFMeshoptCompression(e);
    }), this.register(function(e) {
      return new GLTFMeshGpuInstancing(e);
    });
  }
  load(i, e, r, s) {
    const a = this;
    let c;
    if (this.resourcePath !== "")
      c = this.resourcePath;
    else if (this.path !== "") {
      const d = LoaderUtils.extractUrlBase(i);
      c = LoaderUtils.resolveURL(d, this.path);
    } else
      c = LoaderUtils.extractUrlBase(i);
    this.manager.itemStart(i);
    const l = function(d) {
      s ? s(d) : console.error(d), a.manager.itemError(i), a.manager.itemEnd(i);
    }, h = new FileLoader(this.manager);
    h.setPath(this.path), h.setResponseType("arraybuffer"), h.setRequestHeader(this.requestHeader), h.setWithCredentials(this.withCredentials), h.load(i, function(d) {
      try {
        a.parse(d, c, function(f) {
          e(f), a.manager.itemEnd(i);
        }, l);
      } catch (f) {
        l(f);
      }
    }, r, l);
  }
  setDRACOLoader(i) {
    return this.dracoLoader = i, this;
  }
  setKTX2Loader(i) {
    return this.ktx2Loader = i, this;
  }
  setMeshoptDecoder(i) {
    return this.meshoptDecoder = i, this;
  }
  register(i) {
    return this.pluginCallbacks.indexOf(i) === -1 && this.pluginCallbacks.push(i), this;
  }
  unregister(i) {
    return this.pluginCallbacks.indexOf(i) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(i), 1), this;
  }
  parse(i, e, r, s) {
    let a;
    const c = {}, l = {}, h = new TextDecoder();
    if (typeof i == "string")
      a = JSON.parse(i);
    else if (i instanceof ArrayBuffer)
      if (h.decode(new Uint8Array(i, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          c[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(i);
        } catch (p) {
          s && s(p);
          return;
        }
        a = JSON.parse(c[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else
        a = JSON.parse(h.decode(i));
    else
      a = i;
    if (a.asset === void 0 || a.asset.version[0] < 2) {
      s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const d = new GLTFParser(a, {
      path: e || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    d.fileLoader.setRequestHeader(this.requestHeader);
    for (let f = 0; f < this.pluginCallbacks.length; f++) {
      const p = this.pluginCallbacks[f](d);
      p.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), l[p.name] = p, c[p.name] = !0;
    }
    if (a.extensionsUsed)
      for (let f = 0; f < a.extensionsUsed.length; ++f) {
        const p = a.extensionsUsed[f], m = a.extensionsRequired || [];
        switch (p) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            c[p] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            c[p] = new GLTFDracoMeshCompressionExtension(a, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            c[p] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            c[p] = new GLTFMeshQuantizationExtension();
            break;
          default:
            m.indexOf(p) >= 0 && l[p] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + p + '".');
        }
      }
    d.setExtensions(c), d.setPlugins(l), d.parse(r, s);
  }
  parseAsync(i, e) {
    const r = this;
    return new Promise(function(s, a) {
      r.parse(i, e, s, a);
    });
  }
}
function GLTFRegistry() {
  let o = {};
  return {
    get: function(i) {
      return o[i];
    },
    add: function(i, e) {
      o[i] = e;
    },
    remove: function(i) {
      delete o[i];
    },
    removeAll: function() {
      o = {};
    }
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class GLTFLightsExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const i = this.parser, e = this.parser.json.nodes || [];
    for (let r = 0, s = e.length; r < s; r++) {
      const a = e[r];
      a.extensions && a.extensions[this.name] && a.extensions[this.name].light !== void 0 && i._addNodeRef(this.cache, a.extensions[this.name].light);
    }
  }
  _loadLight(i) {
    const e = this.parser, r = "light:" + i;
    let s = e.cache.get(r);
    if (s)
      return s;
    const a = e.json, h = ((a.extensions && a.extensions[this.name] || {}).lights || [])[i];
    let d;
    const f = new Color(16777215);
    h.color !== void 0 && f.setRGB(h.color[0], h.color[1], h.color[2], LinearSRGBColorSpace);
    const p = h.range !== void 0 ? h.range : 0;
    switch (h.type) {
      case "directional":
        d = new DirectionalLight(f), d.target.position.set(0, 0, -1), d.add(d.target);
        break;
      case "point":
        d = new PointLight(f), d.distance = p;
        break;
      case "spot":
        d = new SpotLight(f), d.distance = p, h.spot = h.spot || {}, h.spot.innerConeAngle = h.spot.innerConeAngle !== void 0 ? h.spot.innerConeAngle : 0, h.spot.outerConeAngle = h.spot.outerConeAngle !== void 0 ? h.spot.outerConeAngle : Math.PI / 4, d.angle = h.spot.outerConeAngle, d.penumbra = 1 - h.spot.innerConeAngle / h.spot.outerConeAngle, d.target.position.set(0, 0, -1), d.add(d.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + h.type);
    }
    return d.position.set(0, 0, 0), assignExtrasToUserData(d, h), h.intensity !== void 0 && (d.intensity = h.intensity), d.name = e.createUniqueName(h.name || "light_" + i), s = Promise.resolve(d), e.cache.add(r, s), s;
  }
  getDependency(i, e) {
    if (i === "light")
      return this._loadLight(e);
  }
  createNodeAttachment(i) {
    const e = this, r = this.parser, a = r.json.nodes[i], l = (a.extensions && a.extensions[this.name] || {}).light;
    return l === void 0 ? null : this._loadLight(l).then(function(h) {
      return r._getNodeRef(e.cache, l, h);
    });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(i, e, r) {
    const s = [];
    i.color = new Color(1, 1, 1), i.opacity = 1;
    const a = e.pbrMetallicRoughness;
    if (a) {
      if (Array.isArray(a.baseColorFactor)) {
        const c = a.baseColorFactor;
        i.color.setRGB(c[0], c[1], c[2], LinearSRGBColorSpace), i.opacity = c[3];
      }
      a.baseColorTexture !== void 0 && s.push(r.assignTexture(i, "map", a.baseColorTexture, SRGBColorSpace));
    }
    return Promise.all(s);
  }
}
class GLTFMaterialsEmissiveStrengthExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(i, e) {
    const s = this.parser.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = s.extensions[this.name].emissiveStrength;
    return a !== void 0 && (e.emissiveIntensity = a), Promise.resolve();
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    if (c.clearcoatFactor !== void 0 && (e.clearcoat = c.clearcoatFactor), c.clearcoatTexture !== void 0 && a.push(r.assignTexture(e, "clearcoatMap", c.clearcoatTexture)), c.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = c.clearcoatRoughnessFactor), c.clearcoatRoughnessTexture !== void 0 && a.push(r.assignTexture(e, "clearcoatRoughnessMap", c.clearcoatRoughnessTexture)), c.clearcoatNormalTexture !== void 0 && (a.push(r.assignTexture(e, "clearcoatNormalMap", c.clearcoatNormalTexture)), c.clearcoatNormalTexture.scale !== void 0)) {
      const l = c.clearcoatNormalTexture.scale;
      e.clearcoatNormalScale = new Vector2$1(l, l);
    }
    return Promise.all(a);
  }
}
class GLTFMaterialsDispersionExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const s = this.parser.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = s.extensions[this.name];
    return e.dispersion = a.dispersion !== void 0 ? a.dispersion : 0, Promise.resolve();
  }
}
class GLTFMaterialsIridescenceExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    return c.iridescenceFactor !== void 0 && (e.iridescence = c.iridescenceFactor), c.iridescenceTexture !== void 0 && a.push(r.assignTexture(e, "iridescenceMap", c.iridescenceTexture)), c.iridescenceIor !== void 0 && (e.iridescenceIOR = c.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [100, 400]), c.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = c.iridescenceThicknessMinimum), c.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = c.iridescenceThicknessMaximum), c.iridescenceThicknessTexture !== void 0 && a.push(r.assignTexture(e, "iridescenceThicknessMap", c.iridescenceThicknessTexture)), Promise.all(a);
  }
}
class GLTFMaterialsSheenExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [];
    e.sheenColor = new Color(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
    const c = s.extensions[this.name];
    if (c.sheenColorFactor !== void 0) {
      const l = c.sheenColorFactor;
      e.sheenColor.setRGB(l[0], l[1], l[2], LinearSRGBColorSpace);
    }
    return c.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = c.sheenRoughnessFactor), c.sheenColorTexture !== void 0 && a.push(r.assignTexture(e, "sheenColorMap", c.sheenColorTexture, SRGBColorSpace)), c.sheenRoughnessTexture !== void 0 && a.push(r.assignTexture(e, "sheenRoughnessMap", c.sheenRoughnessTexture)), Promise.all(a);
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    return c.transmissionFactor !== void 0 && (e.transmission = c.transmissionFactor), c.transmissionTexture !== void 0 && a.push(r.assignTexture(e, "transmissionMap", c.transmissionTexture)), Promise.all(a);
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    e.thickness = c.thicknessFactor !== void 0 ? c.thicknessFactor : 0, c.thicknessTexture !== void 0 && a.push(r.assignTexture(e, "thicknessMap", c.thicknessTexture)), e.attenuationDistance = c.attenuationDistance || 1 / 0;
    const l = c.attenuationColor || [1, 1, 1];
    return e.attenuationColor = new Color().setRGB(l[0], l[1], l[2], LinearSRGBColorSpace), Promise.all(a);
  }
}
class GLTFMaterialsIorExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const s = this.parser.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = s.extensions[this.name];
    return e.ior = a.ior !== void 0 ? a.ior : 1.5, Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    e.specularIntensity = c.specularFactor !== void 0 ? c.specularFactor : 1, c.specularTexture !== void 0 && a.push(r.assignTexture(e, "specularIntensityMap", c.specularTexture));
    const l = c.specularColorFactor || [1, 1, 1];
    return e.specularColor = new Color().setRGB(l[0], l[1], l[2], LinearSRGBColorSpace), c.specularColorTexture !== void 0 && a.push(r.assignTexture(e, "specularColorMap", c.specularColorTexture, SRGBColorSpace)), Promise.all(a);
  }
}
class GLTFMaterialsBumpExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    return e.bumpScale = c.bumpFactor !== void 0 ? c.bumpFactor : 1, c.bumpTexture !== void 0 && a.push(r.assignTexture(e, "bumpMap", c.bumpTexture)), Promise.all(a);
  }
}
class GLTFMaterialsAnisotropyExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(i) {
    const r = this.parser.json.materials[i];
    return !r.extensions || !r.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(i, e) {
    const r = this.parser, s = r.json.materials[i];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const a = [], c = s.extensions[this.name];
    return c.anisotropyStrength !== void 0 && (e.anisotropy = c.anisotropyStrength), c.anisotropyRotation !== void 0 && (e.anisotropyRotation = c.anisotropyRotation), c.anisotropyTexture !== void 0 && a.push(r.assignTexture(e, "anisotropyMap", c.anisotropyTexture)), Promise.all(a);
  }
}
class GLTFTextureBasisUExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(i) {
    const e = this.parser, r = e.json, s = r.textures[i];
    if (!s.extensions || !s.extensions[this.name])
      return null;
    const a = s.extensions[this.name], c = e.options.ktx2Loader;
    if (!c) {
      if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return e.loadTextureImage(i, a.source, c);
  }
}
class GLTFTextureWebPExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
  }
  loadTexture(i) {
    const e = this.name, r = this.parser, s = r.json, a = s.textures[i];
    if (!a.extensions || !a.extensions[e])
      return null;
    const c = a.extensions[e], l = s.images[c.source];
    let h = r.textureLoader;
    if (l.uri) {
      const d = r.options.manager.getHandler(l.uri);
      d !== null && (h = d);
    }
    return r.loadTextureImage(i, c.source, h);
  }
}
class GLTFTextureAVIFExtension {
  constructor(i) {
    this.parser = i, this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
  }
  loadTexture(i) {
    const e = this.name, r = this.parser, s = r.json, a = s.textures[i];
    if (!a.extensions || !a.extensions[e])
      return null;
    const c = a.extensions[e], l = s.images[c.source];
    let h = r.textureLoader;
    if (l.uri) {
      const d = r.options.manager.getHandler(l.uri);
      d !== null && (h = d);
    }
    return r.loadTextureImage(i, c.source, h);
  }
}
class GLTFMeshoptCompression {
  constructor(i) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION, this.parser = i;
  }
  loadBufferView(i) {
    const e = this.parser.json, r = e.bufferViews[i];
    if (r.extensions && r.extensions[this.name]) {
      const s = r.extensions[this.name], a = this.parser.getDependency("buffer", s.buffer), c = this.parser.options.meshoptDecoder;
      if (!c || !c.supported) {
        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return a.then(function(l) {
        const h = s.byteOffset || 0, d = s.byteLength || 0, f = s.count, p = s.byteStride, m = new Uint8Array(l, h, d);
        return c.decodeGltfBufferAsync ? c.decodeGltfBufferAsync(f, p, m, s.mode, s.filter).then(function(y) {
          return y.buffer;
        }) : c.ready.then(function() {
          const y = new ArrayBuffer(f * p);
          return c.decodeGltfBuffer(new Uint8Array(y), f, p, m, s.mode, s.filter), y;
        });
      });
    } else
      return null;
  }
}
class GLTFMeshGpuInstancing {
  constructor(i) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING, this.parser = i;
  }
  createNodeMesh(i) {
    const e = this.parser.json, r = e.nodes[i];
    if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0)
      return null;
    const s = e.meshes[r.mesh];
    for (const d of s.primitives)
      if (d.mode !== WEBGL_CONSTANTS.TRIANGLES && d.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && d.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && d.mode !== void 0)
        return null;
    const c = r.extensions[this.name].attributes, l = [], h = {};
    for (const d in c)
      l.push(this.parser.getDependency("accessor", c[d]).then((f) => (h[d] = f, h[d])));
    return l.length < 1 ? null : (l.push(this.parser.createNodeMesh(i)), Promise.all(l).then((d) => {
      const f = d.pop(), p = f.isGroup ? f.children : [f], m = d[0].count, y = [];
      for (const x of p) {
        const v = new Matrix4(), S = new Vector3$1(), E = new Quaternion$1(), b = new Vector3$1(1, 1, 1), w = new InstancedMesh(x.geometry, x.material, m);
        for (let M = 0; M < m; M++)
          h.TRANSLATION && S.fromBufferAttribute(h.TRANSLATION, M), h.ROTATION && E.fromBufferAttribute(h.ROTATION, M), h.SCALE && b.fromBufferAttribute(h.SCALE, M), w.setMatrixAt(M, v.compose(S, E, b));
        for (const M in h)
          if (M === "_COLOR_0") {
            const P = h[M];
            w.instanceColor = new InstancedBufferAttribute(P.array, P.itemSize, P.normalized);
          } else
            M !== "TRANSLATION" && M !== "ROTATION" && M !== "SCALE" && x.geometry.setAttribute(M, h[M]);
        Object3D.prototype.copy.call(w, x), this.parser.assignFinalMaterial(w), y.push(w);
      }
      return f.isGroup ? (f.clear(), f.add(...y), f) : y[0];
    }));
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF", BINARY_EXTENSION_HEADER_LENGTH = 12, BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(i) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const e = new DataView(i, 0, BINARY_EXTENSION_HEADER_LENGTH), r = new TextDecoder();
    if (this.header = {
      magic: r.decode(new Uint8Array(i.slice(0, 4))),
      version: e.getUint32(4, !0),
      length: e.getUint32(8, !0)
    }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const s = this.header.length - BINARY_EXTENSION_HEADER_LENGTH, a = new DataView(i, BINARY_EXTENSION_HEADER_LENGTH);
    let c = 0;
    for (; c < s; ) {
      const l = a.getUint32(c, !0);
      c += 4;
      const h = a.getUint32(c, !0);
      if (c += 4, h === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const d = new Uint8Array(i, BINARY_EXTENSION_HEADER_LENGTH + c, l);
        this.content = r.decode(d);
      } else if (h === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const d = BINARY_EXTENSION_HEADER_LENGTH + c;
        this.body = i.slice(d, d + l);
      }
      c += l;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(i, e) {
    if (!e)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION, this.json = i, this.dracoLoader = e, this.dracoLoader.preload();
  }
  decodePrimitive(i, e) {
    const r = this.json, s = this.dracoLoader, a = i.extensions[this.name].bufferView, c = i.extensions[this.name].attributes, l = {}, h = {}, d = {};
    for (const f in c) {
      const p = ATTRIBUTES[f] || f.toLowerCase();
      l[p] = c[f];
    }
    for (const f in i.attributes) {
      const p = ATTRIBUTES[f] || f.toLowerCase();
      if (c[f] !== void 0) {
        const m = r.accessors[i.attributes[f]], y = WEBGL_COMPONENT_TYPES[m.componentType];
        d[p] = y.name, h[p] = m.normalized === !0;
      }
    }
    return e.getDependency("bufferView", a).then(function(f) {
      return new Promise(function(p, m) {
        s.decodeDracoFile(f, function(y) {
          for (const x in y.attributes) {
            const v = y.attributes[x], S = h[x];
            S !== void 0 && (v.normalized = S);
          }
          p(y);
        }, l, d, LinearSRGBColorSpace, m);
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(i, e) {
    return (e.texCoord === void 0 || e.texCoord === i.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (i = i.clone(), e.texCoord !== void 0 && (i.channel = e.texCoord), e.offset !== void 0 && i.offset.fromArray(e.offset), e.rotation !== void 0 && (i.rotation = e.rotation), e.scale !== void 0 && i.repeat.fromArray(e.scale), i.needsUpdate = !0), i;
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(i, e, r, s) {
    super(i, e, r, s);
  }
  copySampleValue_(i) {
    const e = this.resultBuffer, r = this.sampleValues, s = this.valueSize, a = i * s * 3 + s;
    for (let c = 0; c !== s; c++)
      e[c] = r[a + c];
    return e;
  }
  interpolate_(i, e, r, s) {
    const a = this.resultBuffer, c = this.sampleValues, l = this.valueSize, h = l * 2, d = l * 3, f = s - e, p = (r - e) / f, m = p * p, y = m * p, x = i * d, v = x - d, S = -2 * y + 3 * m, E = y - m, b = 1 - S, w = E - m + p;
    for (let M = 0; M !== l; M++) {
      const P = c[v + M + l], D = c[v + M + h] * f, L = c[x + M + l], O = c[x + M] * f;
      a[M] = b * P + w * D + S * L + E * O;
    }
    return a;
  }
}
const _quaternion = new Quaternion$1();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(i, e, r, s) {
    const a = super.interpolate_(i, e, r, s);
    return _quaternion.fromArray(a).normalize().toArray(a), a;
  }
}
const WEBGL_CONSTANTS = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
}, WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
}, WEBGL_TYPE_SIZES = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, INTERPOLATION = {
  CUBICSPLINE: void 0,
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
}, ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(o) {
  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new MeshStandardMaterial({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: FrontSide
  })), o.DefaultMaterial;
}
function addUnknownExtensionsToUserData(o, i, e) {
  for (const r in e.extensions)
    o[r] === void 0 && (i.userData.gltfExtensions = i.userData.gltfExtensions || {}, i.userData.gltfExtensions[r] = e.extensions[r]);
}
function assignExtrasToUserData(o, i) {
  i.extras !== void 0 && (typeof i.extras == "object" ? Object.assign(o.userData, i.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + i.extras));
}
function addMorphTargets(o, i, e) {
  let r = !1, s = !1, a = !1;
  for (let d = 0, f = i.length; d < f; d++) {
    const p = i[d];
    if (p.POSITION !== void 0 && (r = !0), p.NORMAL !== void 0 && (s = !0), p.COLOR_0 !== void 0 && (a = !0), r && s && a)
      break;
  }
  if (!r && !s && !a)
    return Promise.resolve(o);
  const c = [], l = [], h = [];
  for (let d = 0, f = i.length; d < f; d++) {
    const p = i[d];
    if (r) {
      const m = p.POSITION !== void 0 ? e.getDependency("accessor", p.POSITION) : o.attributes.position;
      c.push(m);
    }
    if (s) {
      const m = p.NORMAL !== void 0 ? e.getDependency("accessor", p.NORMAL) : o.attributes.normal;
      l.push(m);
    }
    if (a) {
      const m = p.COLOR_0 !== void 0 ? e.getDependency("accessor", p.COLOR_0) : o.attributes.color;
      h.push(m);
    }
  }
  return Promise.all([
    Promise.all(c),
    Promise.all(l),
    Promise.all(h)
  ]).then(function(d) {
    const f = d[0], p = d[1], m = d[2];
    return r && (o.morphAttributes.position = f), s && (o.morphAttributes.normal = p), a && (o.morphAttributes.color = m), o.morphTargetsRelative = !0, o;
  });
}
function updateMorphTargets(o, i) {
  if (o.updateMorphTargets(), i.weights !== void 0)
    for (let e = 0, r = i.weights.length; e < r; e++)
      o.morphTargetInfluences[e] = i.weights[e];
  if (i.extras && Array.isArray(i.extras.targetNames)) {
    const e = i.extras.targetNames;
    if (o.morphTargetInfluences.length === e.length) {
      o.morphTargetDictionary = {};
      for (let r = 0, s = e.length; r < s; r++)
        o.morphTargetDictionary[e[r]] = r;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function createPrimitiveKey(o) {
  let i;
  const e = o.extensions && o.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (e ? i = "draco:" + e.bufferView + ":" + e.indices + ":" + createAttributesKey(e.attributes) : i = o.indices + ":" + createAttributesKey(o.attributes) + ":" + o.mode, o.targets !== void 0)
    for (let r = 0, s = o.targets.length; r < s; r++)
      i += ":" + createAttributesKey(o.targets[r]);
  return i;
}
function createAttributesKey(o) {
  let i = "";
  const e = Object.keys(o).sort();
  for (let r = 0, s = e.length; r < s; r++)
    i += e[r] + ":" + o[e[r]] + ";";
  return i;
}
function getNormalizedComponentScale(o) {
  switch (o) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(o) {
  return o.search(/\.jpe?g($|\?)/i) > 0 || o.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : o.search(/\.webp($|\?)/i) > 0 || o.search(/^data\:image\/webp/) === 0 ? "image/webp" : o.search(/\.ktx2($|\?)/i) > 0 || o.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
}
const _identityMatrix = new Matrix4();
class GLTFParser {
  constructor(i = {}, e = {}) {
    this.json = i, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new GLTFRegistry(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let r = !1, s = -1, a = !1, c = -1;
    if (typeof navigator < "u") {
      const l = navigator.userAgent;
      r = /^((?!chrome|android).)*safari/i.test(l) === !0;
      const h = l.match(/Version\/(\d+)/);
      s = r && h ? parseInt(h[1], 10) : -1, a = l.indexOf("Firefox") > -1, c = a ? l.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    typeof createImageBitmap > "u" || r && s < 17 || a && c < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(i) {
    this.extensions = i;
  }
  setPlugins(i) {
    this.plugins = i;
  }
  parse(i, e) {
    const r = this, s = this.json, a = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(c) {
      return c._markDefs && c._markDefs();
    }), Promise.all(this._invokeAll(function(c) {
      return c.beforeRoot && c.beforeRoot();
    })).then(function() {
      return Promise.all([
        r.getDependencies("scene"),
        r.getDependencies("animation"),
        r.getDependencies("camera")
      ]);
    }).then(function(c) {
      const l = {
        scene: c[0][s.scene || 0],
        scenes: c[0],
        animations: c[1],
        cameras: c[2],
        asset: s.asset,
        parser: r,
        userData: {}
      };
      return addUnknownExtensionsToUserData(a, l, s), assignExtrasToUserData(l, s), Promise.all(r._invokeAll(function(h) {
        return h.afterRoot && h.afterRoot(l);
      })).then(function() {
        for (const h of l.scenes)
          h.updateMatrixWorld();
        i(l);
      });
    }).catch(e);
  }
  _markDefs() {
    const i = this.json.nodes || [], e = this.json.skins || [], r = this.json.meshes || [];
    for (let s = 0, a = e.length; s < a; s++) {
      const c = e[s].joints;
      for (let l = 0, h = c.length; l < h; l++)
        i[c[l]].isBone = !0;
    }
    for (let s = 0, a = i.length; s < a; s++) {
      const c = i[s];
      c.mesh !== void 0 && (this._addNodeRef(this.meshCache, c.mesh), c.skin !== void 0 && (r[c.mesh].isSkinnedMesh = !0)), c.camera !== void 0 && this._addNodeRef(this.cameraCache, c.camera);
    }
  }
  _addNodeRef(i, e) {
    e !== void 0 && (i.refs[e] === void 0 && (i.refs[e] = i.uses[e] = 0), i.refs[e]++);
  }
  _getNodeRef(i, e, r) {
    if (i.refs[e] <= 1)
      return r;
    const s = r.clone(), a = (c, l) => {
      const h = this.associations.get(c);
      h != null && this.associations.set(l, h);
      for (const [d, f] of c.children.entries())
        a(f, l.children[d]);
    };
    return a(r, s), s.name += "_instance_" + i.uses[e]++, s;
  }
  _invokeOne(i) {
    const e = Object.values(this.plugins);
    e.push(this);
    for (let r = 0; r < e.length; r++) {
      const s = i(e[r]);
      if (s)
        return s;
    }
    return null;
  }
  _invokeAll(i) {
    const e = Object.values(this.plugins);
    e.unshift(this);
    const r = [];
    for (let s = 0; s < e.length; s++) {
      const a = i(e[s]);
      a && r.push(a);
    }
    return r;
  }
  getDependency(i, e) {
    const r = i + ":" + e;
    let s = this.cache.get(r);
    if (!s) {
      switch (i) {
        case "scene":
          s = this.loadScene(e);
          break;
        case "node":
          s = this._invokeOne(function(a) {
            return a.loadNode && a.loadNode(e);
          });
          break;
        case "mesh":
          s = this._invokeOne(function(a) {
            return a.loadMesh && a.loadMesh(e);
          });
          break;
        case "accessor":
          s = this.loadAccessor(e);
          break;
        case "bufferView":
          s = this._invokeOne(function(a) {
            return a.loadBufferView && a.loadBufferView(e);
          });
          break;
        case "buffer":
          s = this.loadBuffer(e);
          break;
        case "material":
          s = this._invokeOne(function(a) {
            return a.loadMaterial && a.loadMaterial(e);
          });
          break;
        case "texture":
          s = this._invokeOne(function(a) {
            return a.loadTexture && a.loadTexture(e);
          });
          break;
        case "skin":
          s = this.loadSkin(e);
          break;
        case "animation":
          s = this._invokeOne(function(a) {
            return a.loadAnimation && a.loadAnimation(e);
          });
          break;
        case "camera":
          s = this.loadCamera(e);
          break;
        default:
          if (s = this._invokeOne(function(a) {
            return a != this && a.getDependency && a.getDependency(i, e);
          }), !s)
            throw new Error("Unknown type: " + i);
          break;
      }
      this.cache.add(r, s);
    }
    return s;
  }
  getDependencies(i) {
    let e = this.cache.get(i);
    if (!e) {
      const r = this, s = this.json[i + (i === "mesh" ? "es" : "s")] || [];
      e = Promise.all(s.map(function(a, c) {
        return r.getDependency(i, c);
      })), this.cache.add(i, e);
    }
    return e;
  }
  loadBuffer(i) {
    const e = this.json.buffers[i], r = this.fileLoader;
    if (e.type && e.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
    if (e.uri === void 0 && i === 0)
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    const s = this.options;
    return new Promise(function(a, c) {
      r.load(LoaderUtils.resolveURL(e.uri, s.path), a, void 0, function() {
        c(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
      });
    });
  }
  loadBufferView(i) {
    const e = this.json.bufferViews[i];
    return this.getDependency("buffer", e.buffer).then(function(r) {
      const s = e.byteLength || 0, a = e.byteOffset || 0;
      return r.slice(a, a + s);
    });
  }
  loadAccessor(i) {
    const e = this, r = this.json, s = this.json.accessors[i];
    if (s.bufferView === void 0 && s.sparse === void 0) {
      const c = WEBGL_TYPE_SIZES[s.type], l = WEBGL_COMPONENT_TYPES[s.componentType], h = s.normalized === !0, d = new l(s.count * c);
      return Promise.resolve(new BufferAttribute(d, c, h));
    }
    const a = [];
    return s.bufferView !== void 0 ? a.push(this.getDependency("bufferView", s.bufferView)) : a.push(null), s.sparse !== void 0 && (a.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), a.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(a).then(function(c) {
      const l = c[0], h = WEBGL_TYPE_SIZES[s.type], d = WEBGL_COMPONENT_TYPES[s.componentType], f = d.BYTES_PER_ELEMENT, p = f * h, m = s.byteOffset || 0, y = s.bufferView !== void 0 ? r.bufferViews[s.bufferView].byteStride : void 0, x = s.normalized === !0;
      let v, S;
      if (y && y !== p) {
        const E = Math.floor(m / y), b = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + E + ":" + s.count;
        let w = e.cache.get(b);
        w || (v = new d(l, E * y, s.count * y / f), w = new InterleavedBuffer(v, y / f), e.cache.add(b, w)), S = new InterleavedBufferAttribute(w, h, m % y / f, x);
      } else
        l === null ? v = new d(s.count * h) : v = new d(l, m, s.count * h), S = new BufferAttribute(v, h, x);
      if (s.sparse !== void 0) {
        const E = WEBGL_TYPE_SIZES.SCALAR, b = WEBGL_COMPONENT_TYPES[s.sparse.indices.componentType], w = s.sparse.indices.byteOffset || 0, M = s.sparse.values.byteOffset || 0, P = new b(c[1], w, s.sparse.count * E), D = new d(c[2], M, s.sparse.count * h);
        l !== null && (S = new BufferAttribute(S.array.slice(), S.itemSize, S.normalized)), S.normalized = !1;
        for (let L = 0, O = P.length; L < O; L++) {
          const F = P[L];
          if (S.setX(F, D[L * h]), h >= 2 && S.setY(F, D[L * h + 1]), h >= 3 && S.setZ(F, D[L * h + 2]), h >= 4 && S.setW(F, D[L * h + 3]), h >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        S.normalized = x;
      }
      return S;
    });
  }
  loadTexture(i) {
    const e = this.json, r = this.options, a = e.textures[i].source, c = e.images[a];
    let l = this.textureLoader;
    if (c.uri) {
      const h = r.manager.getHandler(c.uri);
      h !== null && (l = h);
    }
    return this.loadTextureImage(i, a, l);
  }
  loadTextureImage(i, e, r) {
    const s = this, a = this.json, c = a.textures[i], l = a.images[e], h = (l.uri || l.bufferView) + ":" + c.sampler;
    if (this.textureCache[h])
      return this.textureCache[h];
    const d = this.loadImageSource(e, r).then(function(f) {
      f.flipY = !1, f.name = c.name || l.name || "", f.name === "" && typeof l.uri == "string" && l.uri.startsWith("data:image/") === !1 && (f.name = l.uri);
      const m = (a.samplers || {})[c.sampler] || {};
      return f.magFilter = WEBGL_FILTERS[m.magFilter] || LinearFilter, f.minFilter = WEBGL_FILTERS[m.minFilter] || LinearMipmapLinearFilter, f.wrapS = WEBGL_WRAPPINGS[m.wrapS] || RepeatWrapping, f.wrapT = WEBGL_WRAPPINGS[m.wrapT] || RepeatWrapping, f.generateMipmaps = !f.isCompressedTexture && f.minFilter !== NearestFilter && f.minFilter !== LinearFilter, s.associations.set(f, { textures: i }), f;
    }).catch(function() {
      return null;
    });
    return this.textureCache[h] = d, d;
  }
  loadImageSource(i, e) {
    const r = this, s = this.json, a = this.options;
    if (this.sourceCache[i] !== void 0)
      return this.sourceCache[i].then((p) => p.clone());
    const c = s.images[i], l = self.URL || self.webkitURL;
    let h = c.uri || "", d = !1;
    if (c.bufferView !== void 0)
      h = r.getDependency("bufferView", c.bufferView).then(function(p) {
        d = !0;
        const m = new Blob([p], { type: c.mimeType });
        return h = l.createObjectURL(m), h;
      });
    else if (c.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + i + " is missing URI and bufferView");
    const f = Promise.resolve(h).then(function(p) {
      return new Promise(function(m, y) {
        let x = m;
        e.isImageBitmapLoader === !0 && (x = function(v) {
          const S = new Texture(v);
          S.needsUpdate = !0, m(S);
        }), e.load(LoaderUtils.resolveURL(p, a.path), x, void 0, y);
      });
    }).then(function(p) {
      return d === !0 && l.revokeObjectURL(h), assignExtrasToUserData(p, c), p.userData.mimeType = c.mimeType || getImageURIMimeType(c.uri), p;
    }).catch(function(p) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", h), p;
    });
    return this.sourceCache[i] = f, f;
  }
  assignTexture(i, e, r, s) {
    const a = this;
    return this.getDependency("texture", r.index).then(function(c) {
      if (!c)
        return null;
      if (r.texCoord !== void 0 && r.texCoord > 0 && (c = c.clone(), c.channel = r.texCoord), a.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const l = r.extensions !== void 0 ? r.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (l) {
          const h = a.associations.get(c);
          c = a.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(c, l), a.associations.set(c, h);
        }
      }
      return s !== void 0 && (c.colorSpace = s), i[e] = c, c;
    });
  }
  assignFinalMaterial(i) {
    const e = i.geometry;
    let r = i.material;
    const s = e.attributes.tangent === void 0, a = e.attributes.color !== void 0, c = e.attributes.normal === void 0;
    if (i.isPoints) {
      const l = "PointsMaterial:" + r.uuid;
      let h = this.cache.get(l);
      h || (h = new PointsMaterial(), Material.prototype.copy.call(h, r), h.color.copy(r.color), h.map = r.map, h.sizeAttenuation = !1, this.cache.add(l, h)), r = h;
    } else if (i.isLine) {
      const l = "LineBasicMaterial:" + r.uuid;
      let h = this.cache.get(l);
      h || (h = new LineBasicMaterial(), Material.prototype.copy.call(h, r), h.color.copy(r.color), h.map = r.map, this.cache.add(l, h)), r = h;
    }
    if (s || a || c) {
      let l = "ClonedMaterial:" + r.uuid + ":";
      s && (l += "derivative-tangents:"), a && (l += "vertex-colors:"), c && (l += "flat-shading:");
      let h = this.cache.get(l);
      h || (h = r.clone(), a && (h.vertexColors = !0), c && (h.flatShading = !0), s && (h.normalScale && (h.normalScale.y *= -1), h.clearcoatNormalScale && (h.clearcoatNormalScale.y *= -1)), this.cache.add(l, h), this.associations.set(h, this.associations.get(r))), r = h;
    }
    i.material = r;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(i) {
    const e = this, r = this.json, s = this.extensions, a = r.materials[i];
    let c;
    const l = {}, h = a.extensions || {}, d = [];
    if (h[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const p = s[EXTENSIONS.KHR_MATERIALS_UNLIT];
      c = p.getMaterialType(), d.push(p.extendParams(l, a, e));
    } else {
      const p = a.pbrMetallicRoughness || {};
      if (l.color = new Color(1, 1, 1), l.opacity = 1, Array.isArray(p.baseColorFactor)) {
        const m = p.baseColorFactor;
        l.color.setRGB(m[0], m[1], m[2], LinearSRGBColorSpace), l.opacity = m[3];
      }
      p.baseColorTexture !== void 0 && d.push(e.assignTexture(l, "map", p.baseColorTexture, SRGBColorSpace)), l.metalness = p.metallicFactor !== void 0 ? p.metallicFactor : 1, l.roughness = p.roughnessFactor !== void 0 ? p.roughnessFactor : 1, p.metallicRoughnessTexture !== void 0 && (d.push(e.assignTexture(l, "metalnessMap", p.metallicRoughnessTexture)), d.push(e.assignTexture(l, "roughnessMap", p.metallicRoughnessTexture))), c = this._invokeOne(function(m) {
        return m.getMaterialType && m.getMaterialType(i);
      }), d.push(Promise.all(this._invokeAll(function(m) {
        return m.extendMaterialParams && m.extendMaterialParams(i, l);
      })));
    }
    a.doubleSided === !0 && (l.side = DoubleSide);
    const f = a.alphaMode || ALPHA_MODES.OPAQUE;
    if (f === ALPHA_MODES.BLEND ? (l.transparent = !0, l.depthWrite = !1) : (l.transparent = !1, f === ALPHA_MODES.MASK && (l.alphaTest = a.alphaCutoff !== void 0 ? a.alphaCutoff : 0.5)), a.normalTexture !== void 0 && c !== MeshBasicMaterial && (d.push(e.assignTexture(l, "normalMap", a.normalTexture)), l.normalScale = new Vector2$1(1, 1), a.normalTexture.scale !== void 0)) {
      const p = a.normalTexture.scale;
      l.normalScale.set(p, p);
    }
    if (a.occlusionTexture !== void 0 && c !== MeshBasicMaterial && (d.push(e.assignTexture(l, "aoMap", a.occlusionTexture)), a.occlusionTexture.strength !== void 0 && (l.aoMapIntensity = a.occlusionTexture.strength)), a.emissiveFactor !== void 0 && c !== MeshBasicMaterial) {
      const p = a.emissiveFactor;
      l.emissive = new Color().setRGB(p[0], p[1], p[2], LinearSRGBColorSpace);
    }
    return a.emissiveTexture !== void 0 && c !== MeshBasicMaterial && d.push(e.assignTexture(l, "emissiveMap", a.emissiveTexture, SRGBColorSpace)), Promise.all(d).then(function() {
      const p = new c(l);
      return a.name && (p.name = a.name), assignExtrasToUserData(p, a), e.associations.set(p, { materials: i }), a.extensions && addUnknownExtensionsToUserData(s, p, a), p;
    });
  }
  createUniqueName(i) {
    const e = PropertyBinding.sanitizeNodeName(i || "");
    return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e);
  }
  loadGeometries(i) {
    const e = this, r = this.extensions, s = this.primitiveCache;
    function a(l) {
      return r[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(l, e).then(function(h) {
        return addPrimitiveAttributes(h, l, e);
      });
    }
    const c = [];
    for (let l = 0, h = i.length; l < h; l++) {
      const d = i[l], f = createPrimitiveKey(d), p = s[f];
      if (p)
        c.push(p.promise);
      else {
        let m;
        d.extensions && d.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? m = a(d) : m = addPrimitiveAttributes(new BufferGeometry(), d, e), s[f] = { primitive: d, promise: m }, c.push(m);
      }
    }
    return Promise.all(c);
  }
  loadMesh(i) {
    const e = this, r = this.json, s = this.extensions, a = r.meshes[i], c = a.primitives, l = [];
    for (let h = 0, d = c.length; h < d; h++) {
      const f = c[h].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", c[h].material);
      l.push(f);
    }
    return l.push(e.loadGeometries(c)), Promise.all(l).then(function(h) {
      const d = h.slice(0, h.length - 1), f = h[h.length - 1], p = [];
      for (let y = 0, x = f.length; y < x; y++) {
        const v = f[y], S = c[y];
        let E;
        const b = d[y];
        if (S.mode === WEBGL_CONSTANTS.TRIANGLES || S.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || S.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || S.mode === void 0)
          E = a.isSkinnedMesh === !0 ? new SkinnedMesh(v, b) : new Mesh(v, b), E.isSkinnedMesh === !0 && E.normalizeSkinWeights(), S.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? E.geometry = toTrianglesDrawMode(E.geometry, TriangleStripDrawMode) : S.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (E.geometry = toTrianglesDrawMode(E.geometry, TriangleFanDrawMode));
        else if (S.mode === WEBGL_CONSTANTS.LINES)
          E = new LineSegments(v, b);
        else if (S.mode === WEBGL_CONSTANTS.LINE_STRIP)
          E = new Line(v, b);
        else if (S.mode === WEBGL_CONSTANTS.LINE_LOOP)
          E = new LineLoop(v, b);
        else if (S.mode === WEBGL_CONSTANTS.POINTS)
          E = new Points(v, b);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + S.mode);
        Object.keys(E.geometry.morphAttributes).length > 0 && updateMorphTargets(E, a), E.name = e.createUniqueName(a.name || "mesh_" + i), assignExtrasToUserData(E, a), S.extensions && addUnknownExtensionsToUserData(s, E, S), e.assignFinalMaterial(E), p.push(E);
      }
      for (let y = 0, x = p.length; y < x; y++)
        e.associations.set(p[y], {
          meshes: i,
          primitives: y
        });
      if (p.length === 1)
        return a.extensions && addUnknownExtensionsToUserData(s, p[0], a), p[0];
      const m = new Group();
      a.extensions && addUnknownExtensionsToUserData(s, m, a), e.associations.set(m, { meshes: i });
      for (let y = 0, x = p.length; y < x; y++)
        m.add(p[y]);
      return m;
    });
  }
  loadCamera(i) {
    let e;
    const r = this.json.cameras[i], s = r[r.type];
    if (!s) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return r.type === "perspective" ? e = new PerspectiveCamera(MathUtils.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : r.type === "orthographic" && (e = new OrthographicCamera(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), r.name && (e.name = this.createUniqueName(r.name)), assignExtrasToUserData(e, r), Promise.resolve(e);
  }
  loadSkin(i) {
    const e = this.json.skins[i], r = [];
    for (let s = 0, a = e.joints.length; s < a; s++)
      r.push(this._loadNodeShallow(e.joints[s]));
    return e.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", e.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function(s) {
      const a = s.pop(), c = s, l = [], h = [];
      for (let d = 0, f = c.length; d < f; d++) {
        const p = c[d];
        if (p) {
          l.push(p);
          const m = new Matrix4();
          a !== null && m.fromArray(a.array, d * 16), h.push(m);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[d]);
      }
      return new Skeleton(l, h);
    });
  }
  loadAnimation(i) {
    const e = this.json, r = this, s = e.animations[i], a = s.name ? s.name : "animation_" + i, c = [], l = [], h = [], d = [], f = [];
    for (let p = 0, m = s.channels.length; p < m; p++) {
      const y = s.channels[p], x = s.samplers[y.sampler], v = y.target, S = v.node, E = s.parameters !== void 0 ? s.parameters[x.input] : x.input, b = s.parameters !== void 0 ? s.parameters[x.output] : x.output;
      v.node !== void 0 && (c.push(this.getDependency("node", S)), l.push(this.getDependency("accessor", E)), h.push(this.getDependency("accessor", b)), d.push(x), f.push(v));
    }
    return Promise.all([
      Promise.all(c),
      Promise.all(l),
      Promise.all(h),
      Promise.all(d),
      Promise.all(f)
    ]).then(function(p) {
      const m = p[0], y = p[1], x = p[2], v = p[3], S = p[4], E = [];
      for (let b = 0, w = m.length; b < w; b++) {
        const M = m[b], P = y[b], D = x[b], L = v[b], O = S[b];
        if (M === void 0)
          continue;
        M.updateMatrix && M.updateMatrix();
        const F = r._createAnimationTracks(M, P, D, L, O);
        if (F)
          for (let k = 0; k < F.length; k++)
            E.push(F[k]);
      }
      return new AnimationClip(a, void 0, E);
    });
  }
  createNodeMesh(i) {
    const e = this.json, r = this, s = e.nodes[i];
    return s.mesh === void 0 ? null : r.getDependency("mesh", s.mesh).then(function(a) {
      const c = r._getNodeRef(r.meshCache, s.mesh, a);
      return s.weights !== void 0 && c.traverse(function(l) {
        if (!!l.isMesh)
          for (let h = 0, d = s.weights.length; h < d; h++)
            l.morphTargetInfluences[h] = s.weights[h];
      }), c;
    });
  }
  loadNode(i) {
    const e = this.json, r = this, s = e.nodes[i], a = r._loadNodeShallow(i), c = [], l = s.children || [];
    for (let d = 0, f = l.length; d < f; d++)
      c.push(r.getDependency("node", l[d]));
    const h = s.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", s.skin);
    return Promise.all([
      a,
      Promise.all(c),
      h
    ]).then(function(d) {
      const f = d[0], p = d[1], m = d[2];
      m !== null && f.traverse(function(y) {
        !y.isSkinnedMesh || y.bind(m, _identityMatrix);
      });
      for (let y = 0, x = p.length; y < x; y++)
        f.add(p[y]);
      return f;
    });
  }
  _loadNodeShallow(i) {
    const e = this.json, r = this.extensions, s = this;
    if (this.nodeCache[i] !== void 0)
      return this.nodeCache[i];
    const a = e.nodes[i], c = a.name ? s.createUniqueName(a.name) : "", l = [], h = s._invokeOne(function(d) {
      return d.createNodeMesh && d.createNodeMesh(i);
    });
    return h && l.push(h), a.camera !== void 0 && l.push(s.getDependency("camera", a.camera).then(function(d) {
      return s._getNodeRef(s.cameraCache, a.camera, d);
    })), s._invokeAll(function(d) {
      return d.createNodeAttachment && d.createNodeAttachment(i);
    }).forEach(function(d) {
      l.push(d);
    }), this.nodeCache[i] = Promise.all(l).then(function(d) {
      let f;
      if (a.isBone === !0 ? f = new Bone() : d.length > 1 ? f = new Group() : d.length === 1 ? f = d[0] : f = new Object3D(), f !== d[0])
        for (let p = 0, m = d.length; p < m; p++)
          f.add(d[p]);
      if (a.name && (f.userData.name = a.name, f.name = c), assignExtrasToUserData(f, a), a.extensions && addUnknownExtensionsToUserData(r, f, a), a.matrix !== void 0) {
        const p = new Matrix4();
        p.fromArray(a.matrix), f.applyMatrix4(p);
      } else
        a.translation !== void 0 && f.position.fromArray(a.translation), a.rotation !== void 0 && f.quaternion.fromArray(a.rotation), a.scale !== void 0 && f.scale.fromArray(a.scale);
      if (!s.associations.has(f))
        s.associations.set(f, {});
      else if (a.mesh !== void 0 && s.meshCache.refs[a.mesh] > 1) {
        const p = s.associations.get(f);
        s.associations.set(f, { ...p });
      }
      return s.associations.get(f).nodes = i, f;
    }), this.nodeCache[i];
  }
  loadScene(i) {
    const e = this.extensions, r = this.json.scenes[i], s = this, a = new Group();
    r.name && (a.name = s.createUniqueName(r.name)), assignExtrasToUserData(a, r), r.extensions && addUnknownExtensionsToUserData(e, a, r);
    const c = r.nodes || [], l = [];
    for (let h = 0, d = c.length; h < d; h++)
      l.push(s.getDependency("node", c[h]));
    return Promise.all(l).then(function(h) {
      for (let f = 0, p = h.length; f < p; f++)
        a.add(h[f]);
      const d = (f) => {
        const p = /* @__PURE__ */ new Map();
        for (const [m, y] of s.associations)
          (m instanceof Material || m instanceof Texture) && p.set(m, y);
        return f.traverse((m) => {
          const y = s.associations.get(m);
          y != null && p.set(m, y);
        }), p;
      };
      return s.associations = d(a), a;
    });
  }
  _createAnimationTracks(i, e, r, s, a) {
    const c = [], l = i.name ? i.name : i.uuid, h = [];
    PATH_PROPERTIES[a.path] === PATH_PROPERTIES.weights ? i.traverse(function(m) {
      m.morphTargetInfluences && h.push(m.name ? m.name : m.uuid);
    }) : h.push(l);
    let d;
    switch (PATH_PROPERTIES[a.path]) {
      case PATH_PROPERTIES.weights:
        d = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        d = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.translation:
      case PATH_PROPERTIES.scale:
        d = VectorKeyframeTrack;
        break;
      default:
        switch (r.itemSize) {
          case 1:
            d = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            d = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const f = s.interpolation !== void 0 ? INTERPOLATION[s.interpolation] : InterpolateLinear, p = this._getArrayFromAccessor(r);
    for (let m = 0, y = h.length; m < y; m++) {
      const x = new d(
        h[m] + "." + PATH_PROPERTIES[a.path],
        e.array,
        p,
        f
      );
      s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(x), c.push(x);
    }
    return c;
  }
  _getArrayFromAccessor(i) {
    let e = i.array;
    if (i.normalized) {
      const r = getNormalizedComponentScale(e.constructor), s = new Float32Array(e.length);
      for (let a = 0, c = e.length; a < c; a++)
        s[a] = e[a] * r;
      e = s;
    }
    return e;
  }
  _createCubicSplineTrackInterpolant(i) {
    i.createInterpolant = function(r) {
      const s = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new s(this.times, this.values, this.getValueSize() / 3, r);
    }, i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function computeBounds(o, i, e) {
  const r = i.attributes, s = new Box3();
  if (r.POSITION !== void 0) {
    const l = e.json.accessors[r.POSITION], h = l.min, d = l.max;
    if (h !== void 0 && d !== void 0) {
      if (s.set(
        new Vector3$1(h[0], h[1], h[2]),
        new Vector3$1(d[0], d[1], d[2])
      ), l.normalized) {
        const f = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[l.componentType]);
        s.min.multiplyScalar(f), s.max.multiplyScalar(f);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const a = i.targets;
  if (a !== void 0) {
    const l = new Vector3$1(), h = new Vector3$1();
    for (let d = 0, f = a.length; d < f; d++) {
      const p = a[d];
      if (p.POSITION !== void 0) {
        const m = e.json.accessors[p.POSITION], y = m.min, x = m.max;
        if (y !== void 0 && x !== void 0) {
          if (h.setX(Math.max(Math.abs(y[0]), Math.abs(x[0]))), h.setY(Math.max(Math.abs(y[1]), Math.abs(x[1]))), h.setZ(Math.max(Math.abs(y[2]), Math.abs(x[2]))), m.normalized) {
            const v = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[m.componentType]);
            h.multiplyScalar(v);
          }
          l.max(h);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    s.expandByVector(l);
  }
  o.boundingBox = s;
  const c = new Sphere();
  s.getCenter(c.center), c.radius = s.min.distanceTo(s.max) / 2, o.boundingSphere = c;
}
function addPrimitiveAttributes(o, i, e) {
  const r = i.attributes, s = [];
  function a(c, l) {
    return e.getDependency("accessor", c).then(function(h) {
      o.setAttribute(l, h);
    });
  }
  for (const c in r) {
    const l = ATTRIBUTES[c] || c.toLowerCase();
    l in o.attributes || s.push(a(r[c], l));
  }
  if (i.indices !== void 0 && !o.index) {
    const c = e.getDependency("accessor", i.indices).then(function(l) {
      o.setIndex(l);
    });
    s.push(c);
  }
  return ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in r && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`), assignExtrasToUserData(o, i), computeBounds(o, i, e), Promise.all(s).then(function() {
    return i.targets !== void 0 ? addMorphTargets(o, i.targets, e) : o;
  });
}
class B3DMLoader extends B3DMLoaderBase {
  constructor(i = DefaultLoadingManager) {
    super(), this.manager = i, this.adjustmentTransform = new Matrix4();
  }
  parse(i) {
    const e = super.parse(i), r = e.glbBytes.slice().buffer;
    return new Promise((s, a) => {
      const c = this.manager, l = this.fetchOptions, h = c.getHandler("path.gltf") || new GLTFLoader(c);
      l.credentials === "include" && l.mode === "cors" && h.setCrossOrigin("use-credentials"), "credentials" in l && h.setWithCredentials(l.credentials === "include"), l.headers && h.setRequestHeader(l.headers);
      let d = this.workingPath;
      !/[\\/]$/.test(d) && d.length && (d += "/");
      const f = this.adjustmentTransform;
      h.parse(r, d, (p) => {
        const { batchTable: m, featureTable: y } = e, { scene: x } = p, v = y.getData("RTC_CENTER");
        v && (x.position.x += v[0], x.position.y += v[1], x.position.z += v[2]), p.scene.updateMatrix(), p.scene.matrix.multiply(f), p.scene.matrix.decompose(p.scene.position, p.scene.quaternion, p.scene.scale), p.batchTable = m, p.featureTable = y, x.batchTable = m, x.featureTable = y, s(p);
      }, a);
    });
  }
}
class I3DMLoaderBase extends LoaderBase {
  parse(i) {
    const e = new DataView(i), r = e.getUint32(4, !0);
    console.assert(r === 1);
    const s = e.getUint32(8, !0);
    console.assert(s === i.byteLength);
    const a = e.getUint32(12, !0), c = e.getUint32(16, !0), l = e.getUint32(20, !0), h = e.getUint32(24, !0), d = e.getUint32(28, !0), f = 32, p = i.slice(
      f,
      f + a + c
    ), m = new FeatureTable(
      p,
      0,
      a,
      c
    ), y = f + a + c, x = i.slice(
      y,
      y + l + h
    ), v = new BatchTable(
      x,
      m.getData("INSTANCES_LENGTH"),
      0,
      l,
      h
    ), S = y + l + h, E = new Uint8Array(i, S, s - S);
    let b = null, w = null;
    if (d)
      b = E, w = Promise.resolve();
    else {
      const M = this.resolveExternalURL(arrayToString(E));
      w = fetch(M, this.fetchOptions).then((P) => {
        if (!P.ok)
          throw new Error(`I3DMLoaderBase : Failed to load file "${M}" with status ${P.status} : ${P.statusText}`);
        return P.arrayBuffer();
      }).then((P) => {
        b = new Uint8Array(P);
      });
    }
    return w.then(() => ({
      version: r,
      featureTable: m,
      batchTable: v,
      glbBytes: b
    }));
  }
}
const tempFwd = new Vector3$1(), tempUp = new Vector3$1(), tempRight = new Vector3$1(), tempPos = new Vector3$1(), tempQuat = new Quaternion$1(), tempSca = new Vector3$1(), tempMat = new Matrix4();
class I3DMLoader extends I3DMLoaderBase {
  constructor(i = DefaultLoadingManager) {
    super(), this.manager = i, this.adjustmentTransform = new Matrix4();
  }
  resolveExternalURL(i) {
    return this.manager.resolveURL(super.resolveExternalURL(i));
  }
  parse(i) {
    return super.parse(i).then((e) => {
      const { featureTable: r, batchTable: s } = e, a = e.glbBytes.slice().buffer;
      return new Promise((c, l) => {
        const h = this.fetchOptions, d = this.manager, f = d.getHandler("path.gltf") || new GLTFLoader(d);
        h.credentials === "include" && h.mode === "cors" && f.setCrossOrigin("use-credentials"), "credentials" in h && f.setWithCredentials(h.credentials === "include"), h.headers && f.setRequestHeader(h.headers);
        let p = this.workingPath;
        /[\\/]$/.test(p) || (p += "/");
        const m = this.adjustmentTransform;
        f.parse(a, p, (y) => {
          const x = r.getData("INSTANCES_LENGTH"), v = r.getData("POSITION", x, "FLOAT", "VEC3"), S = r.getData("NORMAL_UP", x, "FLOAT", "VEC3"), E = r.getData("NORMAL_RIGHT", x, "FLOAT", "VEC3"), b = r.getData("SCALE_NON_UNIFORM", x, "FLOAT", "VEC3"), w = r.getData("SCALE", x, "FLOAT", "SCALAR");
          [
            "RTC_CENTER",
            "QUANTIZED_VOLUME_OFFSET",
            "QUANTIZED_VOLUME_SCALE",
            "EAST_NORTH_UP",
            "POSITION_QUANTIZED",
            "NORMAL_UP_OCT32P",
            "NORMAL_RIGHT_OCT32P"
          ].forEach((L) => {
            L in r.header && console.warn(`I3DMLoader: Unsupported FeatureTable feature "${L}" detected.`);
          });
          const M = /* @__PURE__ */ new Map(), P = [];
          y.scene.traverse((L) => {
            if (L.isMesh) {
              const { geometry: O, material: F } = L, k = new InstancedMesh(O, F, x);
              k.position.copy(L.position), k.rotation.copy(L.rotation), k.scale.copy(L.scale), P.push(k), M.set(L, k);
            }
          });
          const D = new Vector3$1();
          for (let L = 0; L < x; L++)
            D.x += v[L * 3 + 0] / x, D.y += v[L * 3 + 1] / x, D.z += v[L * 3 + 2] / x;
          M.forEach((L, O) => {
            const F = O.parent;
            F && (F.remove(O), F.add(L), L.updateMatrixWorld(), L.position.copy(D).applyMatrix4(L.matrixWorld));
          });
          for (let L = 0; L < x; L++) {
            tempPos.set(
              v[L * 3 + 0] - D.x,
              v[L * 3 + 1] - D.y,
              v[L * 3 + 2] - D.z
            ), S ? (tempUp.set(
              S[L * 3 + 0],
              S[L * 3 + 1],
              S[L * 3 + 2]
            ), tempRight.set(
              E[L * 3 + 0],
              E[L * 3 + 1],
              E[L * 3 + 2]
            ), tempFwd.crossVectors(tempRight, tempUp).normalize(), tempMat.makeBasis(
              tempRight,
              tempUp,
              tempFwd
            ), tempQuat.setFromRotationMatrix(tempMat)) : tempQuat.set(0, 0, 0, 1), w ? tempSca.setScalar(w[L]) : b ? tempSca.set(
              b[L * 3 + 0],
              b[L * 3 + 1],
              b[L * 3 + 2]
            ) : tempSca.set(1, 1, 1), tempMat.compose(tempPos, tempQuat, tempSca).multiply(m);
            for (let O = 0, F = P.length; O < F; O++)
              P[O].setMatrixAt(L, tempMat);
          }
          y.batchTable = s, y.featureTable = r, y.scene.batchTable = s, y.scene.featureTable = r, c(y);
        }, l);
      });
    });
  }
}
class PNTSLoaderBase extends LoaderBase {
  parse(i) {
    const e = new DataView(i), r = e.getUint32(4, !0);
    console.assert(r === 1);
    const s = e.getUint32(8, !0);
    console.assert(s === i.byteLength);
    const a = e.getUint32(12, !0), c = e.getUint32(16, !0), l = e.getUint32(20, !0), h = e.getUint32(24, !0), d = 28, f = i.slice(
      d,
      d + a + c
    ), p = new FeatureTable(
      f,
      0,
      a,
      c
    ), m = d + a + c, y = i.slice(
      m,
      m + l + h
    ), x = new BatchTable(
      y,
      p.getData("BATCH_LENGTH") || p.getData("POINTS_LENGTH"),
      0,
      l,
      h
    );
    return Promise.resolve({
      version: r,
      featureTable: p,
      batchTable: x
    });
  }
}
const DRACO_ATTRIBUTE_MAP = {
  RGB: "color",
  POSITION: "position"
};
class PNTSLoader extends PNTSLoaderBase {
  constructor(i = DefaultLoadingManager) {
    super(), this.manager = i;
  }
  parse(i) {
    return super.parse(i).then(async (e) => {
      const { featureTable: r, batchTable: s } = e, a = new PointsMaterial(), c = r.header.extensions, l = new Vector3$1();
      let h;
      if (c && c["3DTILES_draco_point_compression"]) {
        const { byteOffset: p, byteLength: m, properties: y } = c["3DTILES_draco_point_compression"], x = this.manager.getHandler("draco.drc");
        if (x == null)
          throw new Error("PNTSLoader: dracoLoader not available.");
        const v = {};
        for (const b in y)
          if (b in DRACO_ATTRIBUTE_MAP && b in y) {
            const w = DRACO_ATTRIBUTE_MAP[b];
            v[w] = y[b];
          }
        const S = {
          attributeIDs: v,
          attributeTypes: {
            position: "Float32Array",
            color: "Uint8Array"
          },
          useUniqueIDs: !0
        }, E = r.getBuffer(p, m);
        h = await x.decodeGeometry(E, S), h.attributes.color && (a.vertexColors = !0);
      } else {
        const p = r.getData("POINTS_LENGTH"), m = r.getData("POSITION", p, "FLOAT", "VEC3"), y = r.getData("RGB", p, "UNSIGNED_BYTE", "VEC3"), x = r.getData("RGBA", p, "UNSIGNED_BYTE", "VEC4"), v = r.getData("RGB565", p, "UNSIGNED_SHORT", "SCALAR"), S = r.getData("CONSTANT_RGBA", p, "UNSIGNED_BYTE", "VEC4"), E = r.getData("POSITION_QUANTIZED", p, "UNSIGNED_SHORT", "VEC3"), b = r.getData("QUANTIZED_VOLUME_SCALE", p, "FLOAT", "VEC3"), w = r.getData("QUANTIZED_VOLUME_OFFSET", p, "FLOAT", "VEC3");
        if (h = new BufferGeometry(), E) {
          const M = new Float32Array(p * 3);
          for (let P = 0; P < p; P++)
            for (let D = 0; D < 3; D++) {
              const L = 3 * P + D;
              M[L] = E[L] / 65535 * b[D];
            }
          l.x = w[0], l.y = w[1], l.z = w[2], h.setAttribute("position", new BufferAttribute(M, 3, !1));
        } else
          h.setAttribute("position", new BufferAttribute(m, 3, !1));
        if (x !== null)
          h.setAttribute("color", new BufferAttribute(x, 4, !0)), a.vertexColors = !0, a.transparent = !0, a.depthWrite = !1;
        else if (y !== null)
          h.setAttribute("color", new BufferAttribute(y, 3, !0)), a.vertexColors = !0;
        else if (v !== null) {
          const M = new Uint8Array(p * 3);
          for (let P = 0; P < p; P++) {
            const D = rgb565torgb(v[P]);
            for (let L = 0; L < 3; L++) {
              const O = 3 * P + L;
              M[O] = D[L];
            }
          }
          h.setAttribute("color", new BufferAttribute(M, 3, !0)), a.vertexColors = !0;
        } else if (S !== null) {
          const M = new Color(S[0], S[1], S[2]);
          a.color = M;
          const P = S[3] / 255;
          P < 1 && (a.opacity = P, a.transparent = !0, a.depthWrite = !1);
        }
      }
      [
        "BATCH_LENGTH",
        "NORMAL",
        "NORMAL_OCT16P"
      ].forEach((p) => {
        p in r.header && console.warn(
          `PNTSLoader: Unsupported FeatureTable feature "${p}" detected.`
        );
      });
      const d = new Points(h, a);
      d.position.copy(l), e.scene = d, e.scene.featureTable = r, e.scene.batchTable = s;
      const f = r.getData("RTC_CENTER");
      return f && (e.scene.position.x += f[0], e.scene.position.y += f[1], e.scene.position.z += f[2]), e;
    });
  }
}
function readMagicBytes(o) {
  let i;
  if (o instanceof DataView ? i = o : i = new DataView(o), String.fromCharCode(i.getUint8(0)) === "{")
    return null;
  let e = "";
  for (let r = 0; r < 4; r++)
    e += String.fromCharCode(i.getUint8(r));
  return e;
}
class CMPTLoaderBase extends LoaderBase {
  parse(i) {
    const e = new DataView(i), r = readMagicBytes(e);
    console.assert(r === "cmpt", 'CMPTLoader: The magic bytes equal "cmpt".');
    const s = e.getUint32(4, !0);
    console.assert(s === 1, 'CMPTLoader: The version listed in the header is "1".');
    const a = e.getUint32(8, !0);
    console.assert(
      a === i.byteLength,
      "CMPTLoader: The contents buffer length listed in the header matches the file."
    );
    const c = e.getUint32(12, !0), l = [];
    let h = 16;
    for (let d = 0; d < c; d++) {
      const f = new DataView(i, h, 12), p = readMagicBytes(f), m = f.getUint32(4, !0), y = f.getUint32(8, !0), x = new Uint8Array(i, h, y);
      l.push({
        type: p,
        buffer: x,
        version: m
      }), h += y;
    }
    return {
      version: s,
      tiles: l
    };
  }
}
class CMPTLoader extends CMPTLoaderBase {
  constructor(i = DefaultLoadingManager) {
    super(), this.manager = i, this.adjustmentTransform = new Matrix4();
  }
  parse(i) {
    const e = super.parse(i), r = this.manager, s = this.adjustmentTransform, a = [];
    for (const c in e.tiles)
      if (e.tiles.hasOwnProperty(c)) {
        const { type: l, buffer: h } = e.tiles[c];
        switch (l) {
          case "b3dm": {
            const d = h.slice(), f = new B3DMLoader(r);
            f.workingPath = this.workingPath, f.fetchOptions = this.fetchOptions, f.adjustmentTransform.copy(s);
            const p = f.parse(d.buffer);
            a.push(p);
            break;
          }
          case "pnts": {
            const d = h.slice(), f = new PNTSLoader(r);
            f.workingPath = this.workingPath, f.fetchOptions = this.fetchOptions;
            const p = f.parse(d.buffer);
            a.push(p);
            break;
          }
          case "i3dm": {
            const d = h.slice(), f = new I3DMLoader(r);
            f.workingPath = this.workingPath, f.fetchOptions = this.fetchOptions, f.adjustmentTransform.copy(s);
            const p = f.parse(d.buffer);
            a.push(p);
            break;
          }
        }
      }
    return Promise.all(a).then((c) => {
      const l = new Group();
      return c.forEach((h) => {
        l.add(h.scene);
      }), {
        tiles: c,
        scene: l
      };
    });
  }
}
class GLTFExtensionLoader extends LoaderBase {
  constructor(i = DefaultLoadingManager) {
    super(), this.manager = i;
  }
  parse(i) {
    return new Promise((e, r) => {
      const s = this.manager, a = this.fetchOptions;
      let c = s.getHandler("path.gltf") || s.getHandler("path.glb");
      c || (c = new GLTFLoader(s)), a.credentials === "include" && a.mode === "cors" && c.setCrossOrigin("use-credentials"), "credentials" in a && c.setWithCredentials(a.credentials === "include"), a.headers && c.setRequestHeader(a.headers);
      let l = c.resourcePath || c.path || this.workingPath;
      !/[\\/]$/.test(l) && l.length && (l += "/"), c.parse(i, l, (h) => {
        e(h);
      }, r);
    });
  }
}
const ImplicitSubdivisionScheme = {
  QUADTREE: "QUADTREE",
  OCTREE: "OCTREE"
};
ImplicitSubdivisionScheme.getBranchingFactor = function(o) {
  switch (o) {
    case ImplicitSubdivisionScheme.OCTREE:
      return 8;
    case ImplicitSubdivisionScheme.QUADTREE:
      return 4;
    default:
      throw new Error("subdivisionScheme is not a valid value.");
  }
};
class ImplicitAvailabilityBitstream {
  constructor(i) {
    const e = i.lengthBits;
    let r = i.availableCount;
    const s = i.constant, a = i.bitstream;
    if (defined$2(s))
      r = e;
    else {
      const c = Math.ceil(e / 8);
      if (a.length !== c)
        throw new Error(
          `Availability bitstream must be exactly ${c} bytes long to store ${e} bits.
                    Actual bitstream was ${a.length} bytes long.`
        );
      const l = defaultValue$1(
        i.computeAvailableCountEnabled,
        !1
      );
      !defined$2(r) && l && (r = count1Bits(a, e));
    }
    this._lengthBits = e, this._availableCount = r, this._constant = s, this._bitstream = a;
  }
  getBit(i) {
    if (defined$2(this._constant))
      return this._constant;
    const e = i >> 3, r = i % 8;
    return (this._bitstream[e] >> r & 1) === 1;
  }
  get lengthBits() {
    return this._lengthBits;
  }
  get availableCount() {
    return this._availableCount;
  }
}
function count1Bits(o, i) {
  let e = 0;
  for (let r = 0; r < i; r++) {
    const s = r >> 3, a = r % 8;
    e += o[s] >> a & 1;
  }
  return e;
}
class ImplicitSubtreeMetadata {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.subtreeMetadata, r = i.class, s = defined$2(e) ? e.properties : {};
    this._class = r, this._properties = s, this._extras = e.extras, this._extensions = e.extensions;
  }
  get class() {
    return this._class;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(i) {
    return MetadataEntity.hasProperty(i, this._properties, this._class);
  }
  hasPropertyBySemantic(i) {
    return MetadataEntity.hasPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  getPropertyIds(i) {
    return MetadataEntity.getPropertyIds(this._properties, this._class, i);
  }
  getProperty(i) {
    return MetadataEntity.getProperty(i, this._properties, this._class);
  }
  setProperty(i, e) {
    return MetadataEntity.setProperty(
      i,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(i) {
    return MetadataEntity.getPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(i, e) {
    return MetadataEntity.setPropertyBySemantic(
      i,
      e,
      this._properties,
      this._class
    );
  }
}
function getExternalResourceCacheKey(o) {
  return getAbsoluteUri(o.url);
}
class ResourceCacheKey {
  static getSchemaCacheKey(i) {
    const { schema: e, resource: r } = i;
    return defined$2(e) ? `embedded-schema:${JSON.stringify(e)}` : `external-schema:${getExternalResourceCacheKey(r)}`;
  }
}
class ResourceLoader {
  unload() {
  }
  process() {
    return !1;
  }
  isDestroyed() {
    return !1;
  }
  destroy() {
    return this.unload(), destroyObject(this);
  }
}
const ResourceLoaderState = {
  UNLOADED: 0,
  LOADING: 1,
  LOADED: 2,
  PROCESSING: 3,
  READY: 4,
  FAILED: 5
}, ResourceLoaderState$1 = Object.freeze(ResourceLoaderState);
class MetadataSchemaLoader extends ResourceLoader {
  constructor(i) {
    super(i), i = defaultValue$1(i, {});
    const e = i.schema, r = i.resource, s = i.cacheKey;
    this._schema = defined$2(e) ? MetadataSchema.fromJson(e) : void 0, this._resource = r, this._cacheKey = s, this._state = ResourceLoaderState$1.UNLOADED, this._promise = void 0;
  }
  load() {
    return defined$2(this._promise) ? this._promise : defined$2(this._schema) ? (this._promise = Promise.resolve(this), this._promise) : (this._promise = loadExternalSchema(this), this._promise);
  }
  unload() {
    this._schema = void 0;
  }
  get cacheKey() {
    return this._cacheKey;
  }
  get schema() {
    return this._schema;
  }
}
async function loadExternalSchema(o) {
  const i = o._resource;
  o._state = ResourceLoaderState$1.LOADING;
  try {
    const e = await i.fetchJson();
    return o.isDestroyed() ? void 0 : (o._schema = MetadataSchema.fromJson(e), o._state = ResourceLoaderState$1.READY, o);
  } catch (e) {
    if (o.isDestroyed())
      return;
    o._state = ResourceLoaderState$1.FAILED;
    const r = `Failed to load schema: ${i.url}`;
    throw o.getError(r, e);
  }
}
class BufferLoader extends ResourceLoader {
  constructor(i) {
    super(), i = defaultValue$1(i, {});
    const e = i.typedArray, r = i.resource, s = i.cacheKey;
    this._typedArray = e, this._resource = r, this._cacheKey = s, this._state = ResourceLoaderState$1.UNLOADED, this._promise = void 0;
  }
  get cacheKey() {
    return this._cacheKey;
  }
  get typedArray() {
    return this._typedArray;
  }
  async load() {
    return defined$2(this._promise) ? this._promise : defined$2(this._typedArray) ? (this._promise = Promise.resolve(this), this._promise) : (this._promise = this.loadExternalBuffer(), this._promise);
  }
  unload() {
    this._typedArray = void 0;
  }
  async loadExternalBuffer() {
    const i = this._resource;
    this._state = ResourceLoaderState$1.LOADING;
    try {
      const e = await BufferLoader._fetchArrayBuffer(i);
      return this.isDestroyed() ? void 0 : (this._typedArray = new Uint8Array(e), this._state = ResourceLoaderState$1.READY, this);
    } catch (e) {
      if (this.isDestroyed())
        return;
      this._state = ResourceLoaderState$1.FAILED;
      const r = `Failed to load external buffer: ${i.url}`;
      throw this.getError(r, e);
    }
  }
  static _fetchArrayBuffer(i) {
    return i.fetchArrayBuffer();
  }
}
function CacheEntry(o) {
  this.referenceCount = 1, this.resourceLoader = o, this._statisticsPromise = void 0;
}
const Ue = class {
  static get(i) {
    const e = Ue.cacheEntries[i];
    if (defined$2(e))
      return ++e.referenceCount, e.resourceLoader;
  }
  static add(i) {
    const e = i.cacheKey;
    return Ue.cacheEntries[e] = new CacheEntry(i), i;
  }
  static unload(i) {
    const e = i.cacheKey, r = Ue.cacheEntries[e];
    --r.referenceCount, r.referenceCount === 0 && (i.destroy(), delete Ue.cacheEntries[e]);
  }
  static getSchemaLoader(i) {
    i = defaultValue$1(i, {});
    const { schema: e, resource: r } = i, s = ResourceCacheKey.getSchemaCacheKey({
      schema: e,
      resource: r
    });
    let a = Ue.get(s);
    return defined$2(a) ? a : (a = new MetadataSchemaLoader({
      schema: e,
      resource: r,
      cacheKey: s
    }), Ue.add(a));
  }
  static getExternalBufferLoader(i) {
    i = defaultValue$1(i, {});
    const { resource: e } = i, r = ResourceCacheKey.getExternalBufferCacheKey({
      resource: e
    });
    let s = Ue.get(r);
    return defined$2(s) ? s : (s = new BufferLoader({
      resource: e,
      cacheKey: r
    }), Ue.add(s));
  }
};
let ResourceCache = Ue;
_(ResourceCache, "cacheEntries", {});
class ImplicitMetadataView {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.metadataTable, r = i.class, s = i.entityId, a = i.propertyTableJson;
    this._class = r, this._metadataTable = e, this._entityId = s, this._extensions = a.extensions, this._extras = a.extras;
  }
  get class() {
    return this._class;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(i) {
    return this._metadataTable.hasProperty(i);
  }
  hasPropertyBySemantic(i) {
    return this._metadataTable.hasPropertyBySemantic(i);
  }
  getPropertyIds(i) {
    return this._metadataTable.getPropertyIds(i);
  }
  getProperty(i) {
    return this._metadataTable.getProperty(this._entityId, i);
  }
  setProperty(i, e) {
    return this._metadataTable.setProperty(this._entityId, i, e);
  }
  getPropertyBySemantic(i) {
    return this._metadataTable.getPropertyBySemantic(this._entityId, i);
  }
  setPropertyBySemantic(i, e) {
    return this._metadataTable.setPropertyBySemantic(
      this._entityId,
      i,
      e
    );
  }
}
class ImplicitSubtree {
  constructor(i, e, r) {
    this._resource = i, this._subtreeJson = void 0, this._bufferLoader = void 0, this._tileAvailability = void 0, this._contentAvailabilityBitstreams = [], this._childSubtreeAvailability = void 0, this._implicitCoordinates = r, this._subtreeLevels = e.subtreeLevels, this._subdivisionScheme = e.subdivisionScheme, this._branchingFactor = e.branchingFactor, this._metadata = void 0, this._tileMetadataTable = void 0, this._tilePropertyTableJson = void 0, this._contentMetadataTables = [], this._contentPropertyTableJsons = [], this._tileJumpBuffer = void 0, this._contentJumpBuffers = [], this._ready = !1;
  }
  get ready() {
    return this._ready;
  }
  get metadata() {
    return this._metadata;
  }
  get tileMetadataTable() {
    return this._tileMetadataTable;
  }
  get tilePropertyTableJson() {
    return this._tilePropertyTableJson;
  }
  get contentMetadataTables() {
    return this._contentMetadataTables;
  }
  get contentPropertyTableJsons() {
    return this._contentPropertyTableJsons;
  }
  get implicitCoordinates() {
    return this._implicitCoordinates;
  }
  tileIsAvailableAtIndex(i) {
    return this._tileAvailability.getBit(i);
  }
  tileIsAvailableAtCoordinates(i) {
    const e = this.getTileIndex(i);
    return this.tileIsAvailableAtIndex(e);
  }
  contentIsAvailableAtIndex(i, e) {
    return e = defaultValue$1(e, 0), this._contentAvailabilityBitstreams[e].getBit(i);
  }
  contentIsAvailableAtCoordinates(i, e) {
    const r = this.getTileIndex(i);
    return this.contentIsAvailableAtIndex(r, e);
  }
  childSubtreeIsAvailableAtIndex(i) {
    return this._childSubtreeAvailability.getBit(i);
  }
  childSubtreeIsAvailableAtCoordinates(i) {
    const e = this.getChildSubtreeIndex(i);
    return this.childSubtreeIsAvailableAtIndex(e);
  }
  getLevelOffset(i) {
    const e = this._branchingFactor;
    return (Math.pow(e, i) - 1) / (e - 1);
  }
  getParentMortonIndex(i) {
    let e = 2;
    return this._subdivisionScheme === ImplicitSubdivisionScheme.OCTREE && (e = 3), i >> e;
  }
  getTileIndex(i) {
    const e = i.level - this._implicitCoordinates.level;
    if (e < 0 || this._subtreeLevels <= e)
      throw new Error("level is out of bounds for this subtree");
    return i.getSubtreeCoordinates().getOffsetCoordinates(
      i
    ).tileIndex;
  }
  getChildSubtreeIndex(i) {
    if (i.level - this._implicitCoordinates.level !== this._implicitCoordinates.subtreeLevels)
      throw new Error("level is out of bounds for this subtree");
    return i.getParentSubtreeCoordinates().getOffsetCoordinates(
      i
    ).mortonIndex;
  }
  getTileMetadataView(i) {
    const e = getTileEntityId(this, i);
    if (!defined$2(e))
      return;
    const r = this._tileMetadataTable;
    return new ImplicitMetadataView({
      class: r.class,
      metadataTable: r,
      entityId: e,
      propertyTableJson: this._tilePropertyTableJson
    });
  }
  getContentMetadataView(i, e) {
    const r = getContentEntityId(this, i, e);
    if (!defined$2(r))
      return;
    const s = this._contentMetadataTables[e], a = this._contentPropertyTableJsons[e];
    return new ImplicitMetadataView({
      class: s.class,
      metadataTable: s,
      entityId: r,
      contentIndex: e,
      propertyTableJson: a
    });
  }
  isDestroyed() {
    return !1;
  }
  destroy() {
    return defined$2(this._bufferLoader) && ResourceCache.unload(this._bufferLoader), destroyObject(this);
  }
  static async fromSubtreeJson(i, e, r, s, a) {
    const c = new ImplicitSubtree(
      i,
      s,
      a
    );
    let l;
    defined$2(e) ? l = {
      json: e,
      binary: void 0
    } : l = parseSubtreeChunks(r);
    const h = l.json;
    c._subtreeJson = h;
    let d;
    if (hasExtension(h, "3DTILES_metadata"))
      d = h.extensions["3DTILES_metadata"];
    else if (defined$2(h.tileMetadata)) {
      const w = h.tileMetadata;
      d = h.propertyTables[w];
    }
    const f = [];
    if (defined$2(h.contentMetadata)) {
      const w = h.contentMetadata.length;
      for (let M = 0; M < w; M++) {
        const P = h.contentMetadata[M];
        f.push(
          h.propertyTables[P]
        );
      }
    }
    let p;
    const m = s.metadataSchema, y = h.subtreeMetadata;
    if (defined$2(y)) {
      const w = y.class, M = m.classes[w];
      p = new ImplicitSubtreeMetadata({
        subtreeMetadata: y,
        class: M
      });
    }
    c._metadata = p, c._tilePropertyTableJson = d, c._contentPropertyTableJsons = f;
    const x = {
      constant: 0
    };
    h.contentAvailabilityHeaders = [], hasExtension(h, "3DTILES_multiple_contents") ? h.contentAvailabilityHeaders = h.extensions["3DTILES_multiple_contents"].contentAvailability : Array.isArray(h.contentAvailability) ? h.contentAvailabilityHeaders = h.contentAvailability : h.contentAvailabilityHeaders.push(
      defaultValue$1(h.contentAvailability, x)
    );
    const v = preprocessBuffers(h.buffers), S = preprocessBufferViews(
      h.bufferViews,
      v
    );
    markActiveBufferViews(h, S), defined$2(d) && markActiveMetadataBufferViews(d, S);
    for (let w = 0; w < f.length; w++) {
      const M = f[w];
      markActiveMetadataBufferViews(M, S);
    }
    const E = await requestActiveBuffers(
      c,
      v,
      l.binary
    ), b = parseActiveBufferViews(S, E);
    return parseAvailability(c, h, s, b), defined$2(d) && (parseTileMetadataTable(c, s), makeTileJumpBuffer(c)), parseContentMetadataTables(c, s), makeContentJumpBuffers(c), c._ready = !0, c;
  }
}
function parseSubtreeChunks(o) {
  const e = new DataView(
    o.buffer,
    o.byteOffset
  );
  let r = 8;
  const s = e.getUint32(r, !0);
  r += 8;
  const a = e.getUint32(r, !0);
  r += 8;
  const c = getJsonFromTypedArray$2(
    o,
    r,
    s
  );
  r += s;
  const l = o.subarray(
    r,
    r + a
  );
  return {
    json: c,
    binary: l
  };
}
function preprocessBuffers(o) {
  o = defined$2(o) ? o : [];
  for (let i = 0; i < o.length; i++) {
    const e = o[i];
    e.isExternal = defined$2(e.uri), e.isActive = !1;
  }
  return o;
}
function preprocessBufferViews(o, i) {
  o = defined$2(o) ? o : [];
  for (let e = 0; e < o.length; e++) {
    const r = o[e], s = i[r.buffer];
    r.bufferHeader = s, r.isActive = !1;
  }
  return o;
}
function markActiveBufferViews(o, i) {
  let e;
  const r = o.tileAvailability;
  defined$2(r.bitstream) ? e = i[r.bitstream] : defined$2(r.bufferView) && (e = i[r.bufferView]), defined$2(e) && (e.isActive = !0, e.bufferHeader.isActive = !0);
  const s = o.contentAvailabilityHeaders;
  for (let c = 0; c < s.length; c++)
    e = void 0, defined$2(s[c].bitstream) ? e = i[s[c].bitstream] : defined$2(s[c].bufferView) && (e = i[s[c].bufferView]), defined$2(e) && (e.isActive = !0, e.bufferHeader.isActive = !0);
  e = void 0;
  const a = o.childSubtreeAvailability;
  defined$2(a.bitstream) ? e = i[a.bitstream] : defined$2(a.bufferView) && (e = i[a.bufferView]), defined$2(e) && (e.isActive = !0, e.bufferHeader.isActive = !0);
}
function markActiveMetadataBufferViews(o, i) {
  const e = o.properties;
  let r;
  for (const s in e)
    if (e.hasOwnProperty(s)) {
      const a = e[s], c = defaultValue$1(
        a.values,
        a.bufferView
      );
      r = i[c], r.isActive = !0, r.bufferHeader.isActive = !0;
      const l = defaultValue$1(
        a.stringOffsets,
        a.stringOffsetBufferView
      );
      defined$2(l) && (r = i[l], r.isActive = !0, r.bufferHeader.isActive = !0);
      const h = defaultValue$1(
        a.arrayOffsets,
        a.arrayOffsetBufferView
      );
      defined$2(h) && (r = i[h], r.isActive = !0, r.bufferHeader.isActive = !0);
    }
}
function requestActiveBuffers(o, i, e) {
  const r = [];
  for (let s = 0; s < i.length; s++) {
    const a = i[s];
    if (!a.isActive)
      r.push(Promise.resolve(void 0));
    else if (a.isExternal) {
      const c = requestExternalBuffer(o, a);
      r.push(c);
    } else
      r.push(Promise.resolve(e));
  }
  return Promise.all(r).then(function(s) {
    const a = {};
    for (let c = 0; c < s.length; c++) {
      const l = s[c];
      defined$2(l) && (a[c] = l);
    }
    return a;
  });
}
async function requestExternalBuffer(o, i) {
  const r = o._resource.getDerivedResource({
    url: i.uri
  }), s = ResourceCache.getExternalBufferLoader({
    resource: r
  });
  o._bufferLoader = s;
  try {
    await s.load();
  } catch (a) {
    if (s.isDestroyed())
      return;
    throw a;
  }
  return s.typedArray;
}
function parseActiveBufferViews(o, i) {
  const e = {};
  for (let r = 0; r < o.length; r++) {
    const s = o[r];
    if (!s.isActive)
      continue;
    const a = s.byteOffset, c = a + s.byteLength, h = i[s.buffer].subarray(a, c);
    e[r] = h;
  }
  return e;
}
function parseAvailability(o, i, e, r) {
  const s = e.branchingFactor, a = e.subtreeLevels, c = (Math.pow(s, a) - 1) / (s - 1), l = Math.pow(s, a), h = hasExtension(i, "3DTILES_metadata"), d = defined$2(o._tilePropertyTableJson);
  let f = h || d;
  o._tileAvailability = parseAvailabilityBitstream(
    i.tileAvailability,
    r,
    c,
    f
  );
  const p = o._contentPropertyTableJsons.length > 0;
  f = f || p;
  for (let m = 0; m < i.contentAvailabilityHeaders.length; m++) {
    const y = parseAvailabilityBitstream(
      i.contentAvailabilityHeaders[m],
      r,
      c,
      f
    );
    o._contentAvailabilityBitstreams.push(y);
  }
  o._childSubtreeAvailability = parseAvailabilityBitstream(
    i.childSubtreeAvailability,
    r,
    l
  );
}
function parseAvailabilityBitstream(o, i, e, r) {
  if (defined$2(o.constant))
    return new ImplicitAvailabilityBitstream({
      constant: Boolean(o.constant),
      lengthBits: e,
      availableCount: o.availableCount
    });
  let s;
  return defined$2(o.bitstream) ? s = i[o.bitstream] : defined$2(o.bufferView) && (s = i[o.bufferView]), new ImplicitAvailabilityBitstream({
    bitstream: s,
    lengthBits: e,
    availableCount: o.availableCount,
    computeAvailableCountEnabled: r
  });
}
function parseTileMetadataTable(o, i, e) {
  const r = o._tilePropertyTableJson;
  o._tileAvailability.availableCount;
  const s = i.metadataSchema, a = r.class;
  s.classes[a];
}
function parseContentMetadataTables(o, i, e) {
  const r = o._contentPropertyTableJsons, s = o._contentAvailabilityBitstreams, a = i.metadataSchema;
  o._contentMetadataTables;
  for (let c = 0; c < r.length; c++) {
    const l = r[c];
    s[c].availableCount;
    const d = l.class;
    a.classes[d];
  }
}
function makeJumpBuffer(o) {
  let i = 0;
  const e = o.lengthBits, r = o.availableCount;
  let s;
  r < 256 ? s = new Uint8Array(e) : r < 65536 ? s = new Uint16Array(e) : s = new Uint32Array(e);
  for (let a = 0; a < o.lengthBits; a++)
    o.getBit(a) && (s[a] = i, i++);
  return s;
}
function makeTileJumpBuffer(o) {
  const i = makeJumpBuffer(o._tileAvailability);
  o._tileJumpBuffer = i;
}
function makeContentJumpBuffers(o) {
  const i = o._contentJumpBuffers, e = o._contentAvailabilityBitstreams;
  for (let r = 0; r < e.length; r++) {
    const s = e[r], a = makeJumpBuffer(s);
    i.push(a);
  }
}
function getTileEntityId(o, i) {
  if (!defined$2(o._tileMetadataTable))
    return;
  const e = o.getTileIndex(i);
  if (o._tileAvailability.getBit(e))
    return o._tileJumpBuffer[e];
}
function getContentEntityId(o, i, e) {
  const r = o._contentMetadataTables;
  if (!defined$2(r))
    return;
  const s = r[e];
  if (!defined$2(s))
    return;
  const a = o._contentAvailabilityBitstreams[e], c = o.getTileIndex(i);
  if (a.getBit(c))
    return o._contentJumpBuffers[e][c];
}
const MetadataSemantic = {
  ID: "ID",
  NAME: "NAME",
  DESCRIPTION: "DESCRIPTION",
  TILESET_TILE_COUNT: "TILESET_TILE_COUNT",
  TILE_BOUNDING_BOX: "TILE_BOUNDING_BOX",
  TILE_BOUNDING_REGION: "TILE_BOUNDING_REGION",
  TILE_BOUNDING_SPHERE: "TILE_BOUNDING_SPHERE",
  TILE_MINIMUM_HEIGHT: "TILE_MINIMUM_HEIGHT",
  TILE_MAXIMUM_HEIGHT: "TILE_MAXIMUM_HEIGHT",
  TILE_HORIZON_OCCLUSION_POINT: "TILE_HORIZON_OCCLUSION_POINT",
  TILE_GEOMETRIC_ERROR: "TILE_GEOMETRIC_ERROR",
  CONTENT_BOUNDING_BOX: "CONTENT_BOUNDING_BOX",
  CONTENT_BOUNDING_REGION: "CONTENT_BOUNDING_REGION",
  CONTENT_BOUNDING_SPHERE: "CONTENT_BOUNDING_SPHERE",
  CONTENT_MINIMUM_HEIGHT: "CONTENT_MINIMUM_HEIGHT",
  CONTENT_MAXIMUM_HEIGHT: "CONTENT_MAXIMUM_HEIGHT",
  CONTENT_HORIZON_OCCLUSION_POINT: "CONTENT_HORIZON_OCCLUSION_POINT"
}, MetadataSemantic$1 = Object.freeze(MetadataSemantic);
class Implicit3DTileContent {
  constructor(i, e, r) {
    const s = e.implicitTileset, a = e.implicitCoordinates;
    this._implicitTileset = s, this._implicitCoordinates = a, this._implicitSubtree = void 0, this._tileset = i, this._tile = e, this._resource = r, this._metadata = void 0, this.featurePropertiesDirty = !1, this._group = void 0;
    const c = a.getTemplateValues(), l = s.subtreeUriTemplate.getDerivedResource(
      {
        templateValues: c
      }
    );
    this._url = l.getUrlComponent(!0), this._ready = !1;
  }
  hasProperty(i, e) {
    return !1;
  }
  getFeature(i) {
  }
  applyDebugSettings(i, e) {
  }
  update(i, e) {
  }
  pick(i, e, r) {
  }
  isDestroyed() {
    return !1;
  }
  destroy() {
    return this._implicitSubtree = this._implicitSubtree && this._implicitSubtree.destroy(), destroyObject(this);
  }
  get featuresLength() {
    return 0;
  }
  get pointsLength() {
    return 0;
  }
  get trianglesLength() {
    return 0;
  }
  get geometryByteLength() {
    return 0;
  }
  get texturesByteLength() {
    return 0;
  }
  get batchTableByteLength() {
    return 0;
  }
  get innerContents() {
  }
  get ready() {
    return this._ready;
  }
  get tileset() {
    return this._tileset;
  }
  get tile() {
    return this._tile;
  }
  get url() {
    return this._url;
  }
  get metadata() {
  }
  get batchTable() {
  }
  get group() {
    return this._group;
  }
  set group(i) {
    this._group = i;
  }
  static async fromSubtreeJson(i, e, r, s, a, c) {
    c = defaultValue$1(c, 0);
    let l;
    defined$2(a) && (l = new Uint8Array(a, c));
    const h = e.implicitTileset, d = e.implicitCoordinates, f = await ImplicitSubtree.fromSubtreeJson(
      r,
      s,
      l,
      h,
      d
    ), p = new Implicit3DTileContent(i, e, r);
    return p._implicitSubtree = f, expandSubtree(p, f), p._ready = !0, p;
  }
}
function expandSubtree(o, i) {
  const e = o._tile, r = o._implicitCoordinates.childIndex, s = transcodeSubtreeTiles(
    o,
    i,
    e,
    r
  ), a = o._tileset.statistics;
  e.children.push(s.rootTile), a.numberOfTilesTotal++;
  const c = listChildSubtrees(o, i, s.bottomRow);
  for (let l = 0; l < c.length; l++) {
    const h = c[l], d = h.tile, f = makePlaceholderChildSubtree(
      o,
      d,
      h.childIndex
    );
    d.children.push(f), a.numberOfTilesTotal++;
  }
}
function listChildSubtrees(o, i, e) {
  const r = [], s = o._implicitTileset.branchingFactor;
  for (let a = 0; a < e.length; a++) {
    const c = e[a];
    if (!!defined$2(c))
      for (let l = 0; l < s; l++) {
        const h = a * s + l;
        i.childSubtreeIsAvailableAtIndex(h) && r.push({
          tile: c,
          childIndex: l
        });
      }
  }
  return r;
}
function transcodeSubtreeTiles(o, i, e, r) {
  const c = deriveChildTile(
    o,
    i,
    e,
    r,
    0,
    !0
  ), l = o._tileset.statistics;
  let h = [c], d = [];
  const f = o._implicitTileset;
  for (let p = 1; p < f.subtreeLevels; p++) {
    const m = i.getLevelOffset(p), y = f.branchingFactor * h.length;
    for (let x = 0; x < y; x++) {
      const v = m + x;
      if (!i.tileIsAvailableAtIndex(v)) {
        d.push(void 0);
        continue;
      }
      const S = i.getParentMortonIndex(x), E = h[S], b = x % f.branchingFactor, w = deriveChildTile(
        o,
        i,
        E,
        b,
        v
      );
      E.children.push(w), l.numberOfTilesTotal++, d.push(w);
    }
    h = d, d = [];
  }
  return {
    rootTile: c,
    bottomRow: h
  };
}
function getGeometricError(o, i, e) {
  const r = MetadataSemantic$1.TILE_GEOMETRIC_ERROR;
  return defined$2(o) && o.hasPropertyBySemantic(r) ? o.getPropertyBySemantic(r) : i.geometricError / Math.pow(2, e.level);
}
function deriveChildTile(o, i, e, r, s, a) {
  const c = o._implicitTileset;
  let l;
  defaultValue$1(a, !1) ? l = e.implicitCoordinates : l = e.implicitCoordinates.getChildCoordinates(
    r
  );
  let h, d, f;
  defined$2(i.tilePropertyTableJson) && (h = i.getTileMetadataView(l));
  const m = i.contentPropertyTableJsons.length;
  let y = !1;
  for (let D = 0; D < m; D++)
    if (i.contentIsAvailableAtCoordinates(l, D)) {
      y = !0;
      break;
    }
  const x = getTileBoundingVolume(
    c,
    l,
    r,
    a,
    e,
    d
  ), v = [];
  for (let D = 0; D < c.contentCount; D++) {
    if (!i.contentIsAvailableAtIndex(s, D))
      continue;
    const F = {
      uri: c.contentUriTemplates[D].getDerivedResource({
        templateValues: l.getTemplateValues()
      }).url
    }, k = getContentBoundingVolume(
      x,
      f
    );
    defined$2(k) && (F.boundingVolume = k), v.push(combine$1(F, c.contentHeaders[D]));
  }
  const S = getGeometricError(
    h,
    c,
    l
  ), E = {
    boundingVolume: x,
    geometricError: S,
    refine: c.refine,
    contents: v
  }, b = !0, w = clone$2(c.tileHeader, b);
  delete w.boundingVolume, delete w.transform, delete w.metadata;
  const M = combine$1(E, w, b), P = makeTile$1(
    o,
    c.baseResource,
    M,
    e
  );
  return P.implicitCoordinates = l, P.implicitSubtree = i, P.metadata = h, P.hasImplicitContentMetadata = y, P;
}
function canUpdateHeights(o, i) {
  return defined$2(o) && defined$2(i) && (defined$2(i.minimumHeight) || defined$2(i.maximumHeight)) && (hasExtension(o, "3DTILES_bounding_volume_S2") || defined$2(o.region));
}
function updateHeights(o, i) {
  !defined$2(i) || (hasExtension(o, "3DTILES_bounding_volume_S2") ? updateS2CellHeights(
    o.extensions["3DTILES_bounding_volume_S2"],
    i.minimumHeight,
    i.maximumHeight
  ) : defined$2(o.region) && updateRegionHeights(
    o.region,
    i.minimumHeight,
    i.maximumHeight
  ));
}
function updateRegionHeights(o, i, e) {
  defined$2(i) && (o[4] = i), defined$2(e) && (o[5] = e);
}
function updateS2CellHeights(o, i, e) {
  defined$2(i) && (o.minimumHeight = i), defined$2(e) && (o.maximumHeight = e);
}
function getTileBoundingVolume(o, i, e, r, s, a) {
  let c;
  return !defined$2(a) || !defined$2(a.boundingVolume) || !canUpdateHeights(a.boundingVolume, a) && canUpdateHeights(o.boundingVolume, a) ? c = deriveBoundingVolume(
    o,
    i,
    e,
    defaultValue$1(r, !1),
    s
  ) : c = a.boundingVolume, updateHeights(c, a), c;
}
function getContentBoundingVolume(o, i) {
  let e;
  return defined$2(i) && (e = i.boundingVolume), canUpdateHeights(e, i) ? updateHeights(e, i) : canUpdateHeights(o, i) && (e = clone$2(o, !0), updateHeights(e, i)), e;
}
function deriveBoundingVolume(o, i, e, r, s) {
  const a = o.boundingVolume;
  return hasExtension(a, "3DTILES_bounding_volume_S2") ? (i.level, i.x, i.y, i.z, void 0) : defined$2(a.region) ? {
    region: deriveBoundingRegion(
      a.region,
      i.level,
      i.x,
      i.y,
      i.z
    )
  } : {
    box: deriveBoundingBox(
      a.box,
      i.level,
      i.x,
      i.y,
      i.z
    )
  };
}
function deriveBoundingVolumeS2(o, i, e, r, s, a, c) {
}
const scratchScaleFactors = new Vector3$1(), scratchRootCenter = new Vector3$1(), scratchCenter$1 = new Vector3$1(), scratchHalfAxes = new Matrix3();
function deriveBoundingBox(o, i, e, r, s) {
  if (i === 0)
    return o;
  const a = scratchRootCenter.fromArray(o, 0), c = scratchHalfAxes.fromArray(o, 3), l = Math.pow(2, -i), h = -1 + (2 * e + 1) * l, d = -1 + (2 * r + 1) * l;
  let f = 0;
  const p = scratchScaleFactors.set(l, l, 1);
  defined$2(s) && (f = -1 + (2 * s + 1) * l, p.z = l);
  let m = scratchCenter$1.set(h, d, f);
  m = scratchCenter$1.applyMatrix3(c), m = scratchCenter$1.addVectors(m, a);
  let y = new Matrix3().copy(c);
  StaticMatrix3.multiplyByScale(y, p, y);
  const x = new Array(12);
  return m.toArray(x), y.toArray(x, 3), x;
}
const scratchRectangle = new Rectangle();
function deriveBoundingRegion(o, i, e, r, s) {
  if (i === 0)
    return o.slice();
  const a = Rectangle.unpack(o, 0, scratchRectangle), c = o[4], l = o[5], h = Math.pow(2, -i), d = h * a.width, f = CesiumMath.negativePiToPi(a.west + e * d), p = CesiumMath.negativePiToPi(f + d), m = h * a.height, y = CesiumMath.negativePiToPi(a.south + r * m), x = CesiumMath.negativePiToPi(y + m);
  let v = c, S = l;
  if (defined$2(s)) {
    const E = h * (l - c);
    v += s * E, S = v + E;
  }
  return [f, y, p, x, v, S];
}
function makePlaceholderChildSubtree(o, i, e) {
  const r = o._implicitTileset, s = i.implicitCoordinates.getChildCoordinates(
    e
  ), a = deriveBoundingVolume(
    r,
    s,
    e,
    !1,
    i
  ), c = getGeometricError(
    void 0,
    r,
    s
  ), l = r.subtreeUriTemplate.getDerivedResource(
    {
      templateValues: s.getTemplateValues()
    }
  ).url, h = {
    boundingVolume: a,
    geometricError: c,
    refine: r.refine,
    contents: [
      {
        uri: l
      }
    ]
  }, d = makeTile$1(
    o,
    r.baseResource,
    h,
    i
  );
  return d.implicitTileset = r, d.implicitCoordinates = s, d;
}
function makeTile$1(o, i, e, r) {
  const s = o._tile.constructor;
  return new s(o._tileset, i, e, r);
}
const INITIAL_FRUSTUM_CULLED = Symbol("INITIAL_FRUSTUM_CULLED");
function updateFrustumCulled(o, i) {
  o.traverse((e) => {
    e.frustumCulled = e[INITIAL_FRUSTUM_CULLED] && i;
  });
}
class Mesh3DTileContent {
  constructor(i) {
    _(this, "byteSize", 0);
    this.scene = i.scene, this.asset = defaultValue$1(i.asset, {}), this.parser = i.parser, this.animations = defaultValue$1(i.animations, []), this.batchTable = defaultValue$1(i.batchTable, {}), this.featureTable = defaultValue$1(i.featureTable, {}), this.userData = defaultValue$1(i.userData, {}), this.metadata = defaultValue$1(i.metadata, {}), this.group = defaultValue$1(i.group, {}), this.tile = i.tile, this.type = defaultValue$1(i.type, "gltf");
  }
  static fromJson(i) {
    return i = defaultValue$1(i, {}), new Mesh3DTileContent(i);
  }
  traverse(i) {
    const e = this.scene;
    e && e.traverse(i);
  }
  dispose() {
    const i = this.scene, s = this.tile.tileset.materialManager;
    let a = [];
    if (s) {
      const l = s._materrialMap.values();
      a = Array.from(l);
    }
    if (i) {
      const c = [], l = [], h = [];
      this.traverse((d) => {
        d.geometry && l.push(d.geometry), d.material && c.push(d.material), d.userData.meshFeatures && d.userData.meshFeatures.dispose(), d.userData.structuralMetadata && d.userData.structuralMetadata.dispose();
      });
      for (let d = 0, f = l.length; d < f; d++)
        l[d].dispose();
      for (let d = 0, f = c.length; d < f; d++) {
        const p = c[d];
        if (!a.includes(p)) {
          for (const m in p)
            if (p.hasOwnProperty(m)) {
              const y = p[m];
              y && y.isTexture && h.push(y);
            }
          c[d].dispose();
        }
      }
      for (let d = 0, f = h.length; d < f; d++) {
        const p = h[d];
        p.image instanceof ImageBitmap && p.image.close(), p.dispose();
      }
      i.removeFromParent();
    }
  }
  update(i) {
    const e = i.tileset, r = this.scene, s = e.gltfUpMatrix;
    e.optimizeRaycast, r.updateMatrix(), (this.type === "gltf" || this.type === "glb") && r.matrix.multiply(s), r.matrix.premultiply(i.computedTransform), r.matrix.decompose(r.position, r.quaternion, r.scale), r.traverse((a) => {
      a[INITIAL_FRUSTUM_CULLED] = a.frustumCulled, a.isMesh && (a.content = this, a.tile = i);
    }), updateFrustumCulled(r, !1);
  }
}
const Cesium3DTileContentFactory = {
  externalTileset: function(o, i, e, r) {
    return Tileset3DTileContent.fromJson(o, i, e, r);
  },
  b3dm: async function(o, i, e, r) {
    const s = o._manager, c = e.url.split(/[\\/]/g);
    c.pop();
    const l = c.join("/"), h = new B3DMLoader(s), d = o.gltfUpMatrix;
    h.adjustmentTransform.copy(d), h.workingPath = l;
    const p = await h.parse(r);
    return p.type = "b3dm", p.tile = i, Mesh3DTileContent.fromJson(p);
  },
  pnts: async function(o, i, e, r) {
    const s = o._manager, c = e.url.split(/[\\/]/g);
    c.pop();
    const l = c.join("/"), h = new PNTSLoader(s);
    h.workingPath = l;
    const f = await h.parse(r);
    return f.type = "pnts", f.tile = i, Mesh3DTileContent.fromJson(f);
  },
  i3dm: async function(o, i, e, r) {
    const s = o._manager, c = e.url.split(/[\\/]/g);
    c.pop();
    const l = c.join("/"), h = new I3DMLoader(s), d = o.gltfUpMatrix;
    h.adjustmentTransform.copy(d), h.workingPath = l;
    const p = await h.parse(r);
    return p.type = "i3dm", p.tile = i, Mesh3DTileContent.fromJson(p);
  },
  cmpt: async function(o, i, e, r) {
    const s = o._manager, c = e.url.split(/[\\/]/g);
    c.pop();
    const l = c.join("/"), h = new CMPTLoader(s), d = o.gltfUpMatrix;
    h.adjustmentTransform.copy(d), h.workingPath = l;
    const p = await h.parse(r);
    return p.type = "cmpt", p.tile = i, Mesh3DTileContent.fromJson(p);
  },
  gltf: async function(o, i, e, r) {
    const s = o._manager, c = e.url.split(/[\\/]/g);
    c.pop();
    const l = c.join("/"), h = new GLTFExtensionLoader(s);
    h.workingPath = l;
    const f = await h.parse(r);
    return f.type = "gltf", f.tile = i, Mesh3DTileContent.fromJson(f);
  },
  glb: async function(o, i, e, r) {
    const s = o._manager, c = e.url.split(/[\\/]/g);
    c.pop();
    const l = c.join("/"), h = new GLTFExtensionLoader(s);
    h.workingPath = l;
    const f = await h.parse(r);
    return f.type = "glb", f.tile = i, Mesh3DTileContent.fromJson(f);
  },
  subt: function(o, i, e, r, s) {
    return Implicit3DTileContent.fromSubtreeJson(
      o,
      i,
      e,
      void 0,
      r,
      s
    );
  },
  subtreeJson: function(o, i, e, r) {
    return Implicit3DTileContent.fromSubtreeJson(o, i, e, r);
  }
}, _worldMin = new Vector3$1(), _worldMax = new Vector3$1(), _norm$1 = new Vector3$1(), _ray = new Ray();
class OBB {
  constructor(i = new Box3(), e = new Matrix4()) {
    this.box = i.clone(), this.absoluteBox = i.clone(), this.transform = e.clone(), this.inverseTransform = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3$1()), this.planes = new Array(6).fill().map(() => new Plane());
  }
  clampPoint(i, e) {
    return e.copy(i).applyMatrix4(this.inverseTransform).clamp(this.box.min, this.box.max).applyMatrix4(this.transform);
  }
  distanceToPoint(i) {
    return this.clampPoint(i, _norm$1).distanceTo(i);
  }
  containsPoint(i) {
    return _norm$1.copy(i).applyMatrix4(this.inverseTransform), this.box.containsPoint(_norm$1);
  }
  intersectsRay(i) {
    return _ray.copy(i).applyMatrix4(this.inverseTransform), _ray.intersectsBox(this.box);
  }
  intersectRay(i, e) {
    return _ray.copy(i).applyMatrix4(this.inverseTransform), _ray.intersectBox(this.box, e) ? (e.applyMatrix4(this.transform), e) : null;
  }
  update() {
    const { points: i, inverseTransform: e, transform: r, box: s } = this;
    e.copy(r).invert();
    const { min: a, max: c } = s;
    let l = 0;
    for (let h = -1; h <= 1; h += 2)
      for (let d = -1; d <= 1; d += 2)
        for (let f = -1; f <= 1; f += 2)
          i[l].set(
            h < 0 ? a.x : c.x,
            d < 0 ? a.y : c.y,
            f < 0 ? a.z : c.z
          ).applyMatrix4(r), l++;
    this.updatePlanes();
  }
  updatePlanes() {
    _worldMin.copy(this.box.min).applyMatrix4(this.transform), _worldMax.copy(this.box.max).applyMatrix4(this.transform), _norm$1.set(0, 0, 1).transformDirection(this.transform), this.planes[0].setFromNormalAndCoplanarPoint(_norm$1, _worldMin), this.planes[1].setFromNormalAndCoplanarPoint(_norm$1, _worldMax).negate(), _norm$1.set(0, 1, 0).transformDirection(this.transform), this.planes[2].setFromNormalAndCoplanarPoint(_norm$1, _worldMin), this.planes[3].setFromNormalAndCoplanarPoint(_norm$1, _worldMax).negate(), _norm$1.set(1, 0, 0).transformDirection(this.transform), this.planes[4].setFromNormalAndCoplanarPoint(_norm$1, _worldMin), this.planes[5].setFromNormalAndCoplanarPoint(_norm$1, _worldMax).negate();
  }
  intersectsFrustum(i) {
    const { points: e } = this, { planes: r } = i;
    for (let s = 0; s < 6; s++) {
      const a = r[s];
      let c = -1 / 0;
      for (let l = 0; l < 8; l++) {
        const h = e[l], d = a.distanceToPoint(h);
        c = c < d ? d : c;
      }
      if (c < 0)
        return !1;
    }
    for (let s = 0; s < 6; s++) {
      const a = this.planes[s];
      let c = -1 / 0;
      for (let l = 0; l < 8; l++) {
        const h = i.points[l], d = a.distanceToPoint(h);
        c = c < d ? d : c;
      }
      if (c < 0)
        return !1;
    }
    return !0;
  }
}
const PI = Math.PI, HALF_PI = PI / 2, _orthoX = new Vector3$1(), _orthoY = new Vector3$1(), _orthoZ = new Vector3$1(), _invMatrix = new Matrix4(), _tempCartographic = new Vector3$1(), _position = new Vector3$1();
new Matrix4();
let _poolIndex = 0;
const _pointsPool = [];
function getVector(o = !1) {
  return o ? (_pointsPool[_poolIndex] || (_pointsPool[_poolIndex] = new Vector3$1()), _poolIndex++, _pointsPool[_poolIndex - 1]) : new Vector3$1();
}
function resetPool() {
  _poolIndex = 0;
}
class EllipsoidRegion extends Ellipsoid {
  constructor(i, e, r, s = -HALF_PI, a = HALF_PI, c = 0, l = 2 * PI, h = 0, d = 0) {
    super(i, e, r), this.latStart = s, this.latEnd = a, this.lonStart = c, this.lonEnd = l, this.heightStart = h, this.heightEnd = d;
  }
  _getPoints(i = !1) {
    const {
      latStart: e,
      latEnd: r,
      lonStart: s,
      lonEnd: a,
      heightStart: c,
      heightEnd: l
    } = this, h = MathUtils.mapLinear(0.5, 0, 1, e, r), d = MathUtils.mapLinear(0.5, 0, 1, s, a), f = Math.floor(s / HALF_PI) * HALF_PI, p = [
      [-PI / 2, 0],
      [PI / 2, 0],
      [0, f],
      [0, f + PI / 2],
      [0, f + PI],
      [0, f + 3 * PI / 2],
      [e, a],
      [r, a],
      [e, s],
      [r, s],
      [0, s],
      [0, a],
      [h, d],
      [e, d],
      [r, d],
      [h, s],
      [h, a]
    ], m = [], y = p.length;
    for (let x = 0; x <= 1; x++) {
      const v = MathUtils.mapLinear(x, 0, 1, c, l);
      for (let S = 0, E = y; S < E; S++) {
        const [b, w] = p[S];
        if (b >= e && b <= r && w >= s && w <= a) {
          const M = getVector(i);
          m.push(M), this.cartographicToCartesian(_position.set(w, b, v), M);
        }
      }
    }
    return m;
  }
  getBoundingBox(i, e) {
    resetPool();
    const {
      latStart: r,
      latEnd: s,
      lonStart: a,
      lonEnd: c
    } = this;
    if (s - r < PI / 2) {
      const d = MathUtils.mapLinear(0.5, 0, 1, r, s), f = MathUtils.mapLinear(0.5, 0, 1, a, c);
      this.cartographicToCartesian(_tempCartographic.set(f, d, 0), _position);
      const p = Transforms.eastNorthUpToFixedFrame(_position);
      e.copy(p);
    } else
      _orthoX.set(1, 0, 0), _orthoY.set(0, 1, 0), _orthoZ.set(0, 0, 1), e.makeBasis(_orthoX, _orthoY, _orthoZ);
    const h = this._getPoints(!0);
    i.makeEmpty(), i.setFromPoints(h), _invMatrix.copy(e).invert();
    for (let d = 0, f = h.length; d < f; d++)
      h[d].applyMatrix4(_invMatrix);
    i.makeEmpty(), i.setFromPoints(h);
  }
  getBoundingSphere(i, e) {
    resetPool();
    const r = this._getPoints(!0);
    i.makeEmpty(), i.setFromPoints(r, e);
  }
}
const _vecX = new Vector3$1(), _vecY = new Vector3$1(), _vecZ = new Vector3$1(), _sphereVec = new Vector3$1(), _obbVec = new Vector3$1();
new Matrix3();
const _obbHalfAxes = new Matrix3(), _obbCartographic = new Vector3$1(), scratchOffset = new Vector3$1(), scratchScale = new Vector3$1(), WGS84_RADIUS = 6378137, WGS84_FLATTENING = 1 / 298.257223563, WGS84_HEIGHT = -(WGS84_FLATTENING * WGS84_RADIUS - WGS84_RADIUS);
class TileBoundingVolume {
  constructor() {
    this.sphere = null, this.obb = null, this.region = null, this.regionObb = null;
  }
  intersectsRay(i) {
    const e = this.sphere, r = this.obb || this.regionObb;
    return !(e && !i.intersectsSphere(e) || r && !r.intersectsRay(i));
  }
  intersectRay(i, e = null) {
    const r = this.sphere, s = this.obb || this.regionObb;
    let a = -1 / 0, c = -1 / 0;
    r && i.intersectSphere(r, _sphereVec) && (a = r.containsPoint(i.origin) ? 0 : i.origin.distanceToSquared(_sphereVec)), s && s.intersectRay(i, _obbVec) && (c = s.containsPoint(i.origin) ? 0 : i.origin.distanceToSquared(_obbVec));
    const l = Math.max(a, c);
    return l === -1 / 0 ? null : (i.at(Math.sqrt(l), e), e);
  }
  distanceToPoint(i) {
    const e = this.sphere, r = this.obb || this.regionObb;
    let s = -1 / 0, a = -1 / 0;
    return e && (s = Math.max(e.distanceToPoint(i), 0)), r && (a = r.distanceToPoint(i)), s > a ? s : a;
  }
  intersectsFrustum(i, e) {
    const r = this.obb || this.regionObb, s = this.sphere;
    return s && !i.intersectsSphere(s) || r && !r.intersectsFrustum(i) ? !1 : Boolean(s || r);
  }
  getOBB(i, e) {
    const r = this.obb || this.regionObb;
    r ? (i.copy(r.box), e.copy(r.transform)) : (this.getAABB(i), e.identity());
  }
  getAABB(i) {
    if (this.sphere)
      this.sphere.getBoundingBox(i);
    else {
      const e = this.obb || this.regionObb;
      i.copy(e.box).applyMatrix4(e.transform);
    }
  }
  getSphere(i) {
    if (this.sphere)
      i.copy(this.sphere);
    else if (this.region)
      this.region.getBoundingSphere(i);
    else {
      const e = this.obb || this.regionObb;
      e.box.getBoundingSphere(i), i.applyMatrix4(e.transform);
    }
  }
  setObbData(i, e) {
    const r = new OBB();
    _vecX.set(i[3], i[4], i[5]), _vecY.set(i[6], i[7], i[8]), _vecZ.set(i[9], i[10], i[11]);
    const s = _vecX.length(), a = _vecY.length(), c = _vecZ.length();
    _vecX.normalize(), _vecY.normalize(), _vecZ.normalize(), s === 0 && _vecX.crossVectors(_vecY, _vecZ), a === 0 && _vecY.crossVectors(_vecX, _vecZ), c === 0 && _vecZ.crossVectors(_vecX, _vecY), r.transform.set(
      _vecX.x,
      _vecY.x,
      _vecZ.x,
      i[0],
      _vecX.y,
      _vecY.y,
      _vecZ.y,
      i[1],
      _vecX.z,
      _vecY.z,
      _vecZ.z,
      i[2],
      0,
      0,
      0,
      1
    ).premultiply(e);
    const l = new Vector3$1().setFromMatrixColumn(r.transform, 3);
    r.center = l, _obbHalfAxes.fromArray(i, 3);
    const h = new Matrix3().setFromMatrix4(e);
    r.halfAxes = h.multiply(_obbHalfAxes), r.box.min.set(-s, -a, -c), r.box.max.set(s, a, c), r.update(), r.absoluteBox.copy(r.box).applyMatrix4(r.transform), this.obb = r;
  }
  setSphereData(i, e, r, s, a) {
    const c = new Sphere();
    c.center.set(i, e, r), c.radius = s, c.applyMatrix4(a), this.sphere = c;
  }
  setRegionData(i, e, r, s, a, c) {
    const l = new EllipsoidRegion(
      WGS84_RADIUS,
      WGS84_RADIUS,
      WGS84_HEIGHT,
      e,
      s,
      i,
      r,
      a,
      c
    ), h = new OBB();
    l.getBoundingBox(h.box, h.transform), h.update();
    const d = MathUtils.mapLinear(0.5, 0, 1, e, s), f = MathUtils.mapLinear(0.5, 0, 1, i, r), { min: p, max: m } = h.box, y = new Matrix3().setFromMatrix4(h.transform);
    let x = scratchOffset;
    x.x = (p.x + m.x) / 2, x.y = (p.y + m.y) / 2, x.z = (p.z + m.z) / 2;
    const v = scratchScale;
    v.x = (m.x - p.x) / 2, v.y = (m.y - p.y) / 2, v.z = (m.z - p.z) / 2;
    const S = l.cartographicToCartesian(_obbCartographic.set(f, d, 0));
    x.applyMatrix3(y), h.center = S.add(x), StaticMatrix3.multiplyByScale(y, v, y), h.halfAxes = y, h.absoluteBox.copy(h.box).applyMatrix4(h.transform), this.region = l, this.regionObb = h;
  }
}
function getJsonFromTypedArray$1(o, i, e) {
  return JSON.parse(
    getStringFromTypedArray(o, i, e)
  );
}
function getJsonContent$1(o) {
  let i;
  try {
    i = getJsonFromTypedArray$1(o);
  } catch {
    throw new Error("Invalid tile content.");
  }
  return i;
}
function preprocess3DTileContent$1(o) {
  const i = new Uint8Array(o);
  let e = getMagic(i);
  if (e === "glTF" && (e = "glb"), Cesium3DTileContentType$1.isBinaryFormat(e))
    return {
      contentType: e,
      binaryPayload: i
    };
  const r = getJsonContent$1(i);
  if (defined$2(r.root))
    return {
      contentType: Cesium3DTileContentType$1.EXTERNAL_TILESET,
      jsonPayload: r
    };
  if (defined$2(r.root))
    return {
      contentType: Cesium3DTileContentType$1.EXTERNAL_TILESET,
      jsonPayload: r
    };
  if (defined$2(r.asset))
    return {
      contentType: Cesium3DTileContentType$1.GLTF,
      jsonPayload: r
    };
  if (defined$2(r.tileAvailability))
    return {
      contentType: Cesium3DTileContentType$1.IMPLICIT_SUBTREE_JSON,
      jsonPayload: r
    };
  if (defined$2(r.type))
    return {
      contentType: Cesium3DTileContentType$1.GEOJSON,
      jsonPayload: r
    };
  if (defined$2(r.voxelTable))
    return {
      contentType: Cesium3DTileContentType$1.VOXEL_JSON,
      jsonPayload: r
    };
  throw new Error("Invalid tile content.");
}
class TileMetadata {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.tile, r = i.class;
    this._class = r, this._properties = e.properties, this._extensions = e.extensions, this._extras = e.extras;
  }
  get class() {
    return this._class;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(i) {
    return MetadataEntity.hasProperty(i, this._properties, this._class);
  }
  hasPropertyBySemantic(i) {
    return MetadataEntity.hasPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  getPropertyIds(i) {
    return MetadataEntity.getPropertyIds(this._properties, this._class, i);
  }
  getProperty(i) {
    return MetadataEntity.getProperty(i, this._properties, this._class);
  }
  setProperty(i, e) {
    return MetadataEntity.setProperty(
      i,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(i) {
    return MetadataEntity.getPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(i, e) {
    return MetadataEntity.setPropertyBySemantic(
      i,
      e,
      this._properties,
      this._class
    );
  }
}
class ContentMetadata {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.content, r = i.class;
    this._class = r, this._properties = e.properties, this._extensions = e.extensions, this._extras = e.extras;
  }
  get class() {
    return this._class;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(i) {
    return MetadataEntity.hasProperty(i, this._properties, this._class);
  }
  hasPropertyBySemantic(i) {
    return MetadataEntity.hasPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  getPropertyIds(i) {
    return MetadataEntity.getPropertyIds(this._properties, this._class, i);
  }
  getProperty(i) {
    return MetadataEntity.getProperty(i, this._properties, this._class);
  }
  setProperty(i, e) {
    return MetadataEntity.setProperty(
      i,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(i) {
    return MetadataEntity.getPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(i, e) {
    return MetadataEntity.setPropertyBySemantic(
      i,
      e,
      this._properties,
      this._class
    );
  }
}
function findTileMetadata(o, i) {
  const e = hasExtension(i, "3DTILES_metadata") ? i.extensions["3DTILES_metadata"] : i.metadata;
  if (!defined$2(e))
    return;
  if (!defined$2(o.schema)) {
    warnOnce("Could not find a metadata schema for tile metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json.");
    return;
  }
  const r = defaultValue$1(
    o.schema.classes,
    {}
  );
  if (defined$2(e.class)) {
    const s = r[e.class];
    return new TileMetadata({
      tile: e,
      class: s
    });
  }
}
function findGroupMetadata(o, i) {
  const e = o.metadataExtension;
  if (!defined$2(e))
    return;
  const r = e.groups, s = hasExtension(i, "3DTILES_metadata") ? i.extensions["3DTILES_metadata"].group : i.group;
  if (typeof s == "number")
    return r[s];
  const a = e.groupIds.findIndex(function(c) {
    return c === s;
  });
  return a >= 0 ? r[a] : void 0;
}
function findContentMetadata(o, i) {
  const e = hasExtension(i, "3DTILES_metadata") ? i.extensions["3DTILES_metadata"] : i.metadata;
  if (!defined$2(e))
    return;
  if (!defined$2(o.schema)) {
    warnOnce("Could not find a metadata schema for content metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json.");
    return;
  }
  const r = defaultValue$1(
    o.schema.classes,
    {}
  );
  if (defined$2(e.class)) {
    const s = r[e.class];
    return new ContentMetadata({
      content: e,
      class: s
    });
  }
}
class Cesium3DContentGroup {
  constructor(i) {
    i = defaultValue$1(i, {}), this._metadata = i.metadata;
  }
  get metadata() {
    return this._metadata;
  }
}
function contain(o, i) {
  const e = o.image && o.image.width ? o.image.width / o.image.height : 1;
  return e > i ? (o.repeat.x = 1, o.repeat.y = e / i, o.offset.x = 0, o.offset.y = (1 - o.repeat.y) / 2) : (o.repeat.x = i / e, o.repeat.y = 1, o.offset.x = (1 - o.repeat.x) / 2, o.offset.y = 0), o;
}
function cover(o, i) {
  const e = o.image && o.image.width ? o.image.width / o.image.height : 1;
  return e > i ? (o.repeat.x = i / e, o.repeat.y = 1, o.offset.x = (1 - o.repeat.x) / 2, o.offset.y = 0) : (o.repeat.x = 1, o.repeat.y = e / i, o.offset.x = 0, o.offset.y = (1 - o.repeat.y) / 2), o;
}
function fill(o) {
  return o.repeat.x = 1, o.repeat.y = 1, o.offset.x = 0, o.offset.y = 0, o;
}
function getByteLength(o, i, e, r) {
  const s = getTextureTypeByteLength(r);
  switch (e) {
    case AlphaFormat:
      return o * i;
    case RedFormat:
      return o * i / s.components * s.byteLength;
    case RedIntegerFormat:
      return o * i / s.components * s.byteLength;
    case RGFormat:
      return o * i * 2 / s.components * s.byteLength;
    case RGIntegerFormat:
      return o * i * 2 / s.components * s.byteLength;
    case RGBAFormat:
      return o * i * 4 / s.components * s.byteLength;
    case RGBAIntegerFormat:
      return o * i * 4 / s.components * s.byteLength;
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((o + 3) / 4) * Math.floor((i + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((o + 3) / 4) * Math.floor((i + 3) / 4) * 16;
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return Math.max(o, 16) * Math.max(i, 8) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return Math.max(o, 8) * Math.max(i, 8) / 2;
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
      return Math.floor((o + 3) / 4) * Math.floor((i + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
      return Math.floor((o + 3) / 4) * Math.floor((i + 3) / 4) * 16;
    case RGBA_ASTC_4x4_Format:
      return Math.floor((o + 3) / 4) * Math.floor((i + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((o + 4) / 5) * Math.floor((i + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((o + 4) / 5) * Math.floor((i + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((o + 5) / 6) * Math.floor((i + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((o + 5) / 6) * Math.floor((i + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((o + 7) / 8) * Math.floor((i + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((o + 7) / 8) * Math.floor((i + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((o + 7) / 8) * Math.floor((i + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((o + 9) / 10) * Math.floor((i + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((o + 9) / 10) * Math.floor((i + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((o + 9) / 10) * Math.floor((i + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((o + 9) / 10) * Math.floor((i + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((o + 11) / 12) * Math.floor((i + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((o + 11) / 12) * Math.floor((i + 11) / 12) * 16;
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(o / 4) * Math.ceil(i / 4) * 16;
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(o / 4) * Math.ceil(i / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(o / 4) * Math.ceil(i / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${e} format.`
  );
}
function getTextureTypeByteLength(o) {
  switch (o) {
    case UnsignedByteType:
    case ByteType:
      return { byteLength: 1, components: 1 };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return { byteLength: 2, components: 1 };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return { byteLength: 2, components: 4 };
    case UnsignedIntType:
    case IntType:
    case FloatType:
      return { byteLength: 4, components: 1 };
  }
  throw new Error(`Unknown texture type ${o}.`);
}
const TextureUtils = {
  contain,
  cover,
  fill,
  getByteLength
};
function estimateBytesUsed(o) {
  if (!TextureUtils)
    return 0;
  const i = /* @__PURE__ */ new Set();
  let e = 0;
  return o.traverse((r) => {
    if (r.geometry && !i.has(r.geometry) && (e += estimateBytesUsed$1(r.geometry), i.add(r.geometry)), r.material) {
      const s = r.material;
      for (const a in s)
        if (s.hasOwnProperty(a)) {
          const c = s[a];
          if (c && c.isTexture && !i.has(c)) {
            const { format: l, type: h, image: d } = c, { width: f, height: p } = d, m = TextureUtils.getByteLength(f, p, l, h);
            e += c.generateMipmaps ? m * 4 / 3 : m, i.add(c);
          }
        }
    }
  }), e;
}
function canScheduleAllRequests(o) {
  const i = {};
  for (let e = 0; e < o.length; e++) {
    const r = o[e];
    defined$2(i[r]) ? i[r]++ : i[r] = 1;
  }
  for (let e in i)
    if (i.hasOwnProperty(e) && !RequestScheduler.serverHasOpenSlots(e, i[e]))
      return !1;
  return RequestScheduler.heapHasOpenSlots(o.length);
}
function cancelPendingRequests(o, i) {
  o._cancelCount++, o._tile._contentState = i;
  const e = o.tileset.statistics;
  e.numberOfPendingRequests -= o._requestsInFlight, e.numberOfAttemptedRequests += o._requestsInFlight, o._requestsInFlight = 0;
  const r = o._innerContentHeaders.length;
  o._arrayFetchPromises = new Array(r);
}
function requestInnerContent(o, i, e, r) {
  const s = o._innerContentResources[i].clone(), a = o.tile, c = function() {
    return a._priority;
  }, l = o._serverKeys[i], h = new Request({
    throttle: !0,
    throttleByServer: !0,
    priorityFunction: c,
    serverKey: l
  });
  s.request = h, o._requests[i] = h;
  const d = s.fetchArrayBuffer();
  if (!!defined$2(d))
    return d.then(function(f) {
      if (!(e < o._cancelCount)) {
        if (s.request.cancelled || s.request.state === RequestState$1.CANCELLED) {
          cancelPendingRequests(o, r);
          return;
        }
        return updatePendingRequests(o, -1), f;
      }
    }).catch(function(f) {
      if (!(e < o._cancelCount)) {
        if (s.request.cancelled || s.request.state === RequestState$1.CANCELLED) {
          cancelPendingRequests(o, r);
          return;
        }
        updatePendingRequests(o, -1), handleInnerContentFailed(o, i, f);
      }
    });
}
function updatePendingRequests(o, i) {
  o._requestsInFlight += i, o.tileset.statistics.numberOfPendingRequests += i;
}
async function createInnerContents(o) {
  const i = o._cancelCount, e = await Promise.all(o._arrayFetchPromises);
  if (i < o._cancelCount)
    return;
  const r = e.map((a, c) => createInnerContent(o, a, c)), s = await Promise.all(r);
  return o._contentCreated = !0, o._contents = s.filter(defined$2), s;
}
function handleInnerContentFailed(o, i, e) {
  o._tileset, o._innerContentResources[i].url, defined$2(e.message) ? e.message : e.toString();
}
async function createInnerContent(o, i, e) {
  if (!!defined$2(i))
    try {
      const r = preprocess3DTileContent$1(i);
      if (r.contentType === Cesium3DTileContentType$1.EXTERNAL_TILESET)
        throw new Error("External tilesets are disabllowed inside multiple contents");
      const s = o._tileset, a = o._innerContentResources[e], c = o._tile;
      let l;
      const h = Cesium3DTileContentFactory[r.contentType];
      defined$2(r.binaryPayload) ? l = await h(
        s,
        c,
        c._contentResource,
        r.binaryPayload.buffer,
        0
      ) : l = await Promise.resolve(
        h(
          s,
          c,
          a,
          r.binaryPayload.buffer
        )
      );
      const d = o._innerContentHeaders[e];
      if (c.hasImplicitContentMetadata) {
        const p = c.implicitSubtree, m = c.implicitCoordinates;
        l.metadata = p.getContentMetadataView(m, e);
      } else
        c.hasImplicitContent || (l.metadata = findContentMetadata(s, d));
      const f = findGroupMetadata(s, d);
      if (defined$2(f) && (l.group = new Cesium3DContentGroup({
        metadata: f
      })), !c.hasTilesetContent && !c.hasImplicitContent) {
        const p = l.scene;
        defined$2(p) && (l.byteSize = estimateBytesUsed(l.scene));
      }
      return l;
    } catch (r) {
      handleInnerContentFailed(o, e, r);
    }
}
class Multiple3DTileContents {
  constructor(i, e, r, s) {
    _(this, "isMultiple3DTileContents", !0);
    this._tileset = i, this._tile = e, this._tilesetResource = r;
    const a = defined$2(s.contents) ? s.contents : s.content;
    this._innerContentHeaders = a, this._requestsInFlight = 0, this._cancelCount = 0;
    const c = this._innerContentHeaders.length;
    this._arrayFetchPromises = new Array(c), this._requests = new Array(c), this._ready = !1, this._innerContentResources = new Array(c), this._serverKeys = new Array(c);
    for (let l = 0; l < c; l++) {
      const h = r.getDerivedResource({
        url: a[l].uri
      }), d = RequestScheduler.getServerKey(
        h.getUrlComponent()
      );
      this._innerContentResources[l] = h, this._serverKeys[l] = d;
    }
  }
  updatePendingRequests(i) {
  }
  requestInnerContents() {
    if (!canScheduleAllRequests(this._serverKeys)) {
      this.tileset.statistics.numberOfAttemptedRequests += this._serverKeys.length;
      return;
    }
    const i = this._innerContentHeaders;
    updatePendingRequests(this, i.length);
    const e = this._cancelCount;
    for (let r = 0; r < i.length; r++)
      this._arrayFetchPromises[r] = requestInnerContent(
        this,
        r,
        e,
        this._tileset._contentState
      );
    return createInnerContents(this);
  }
  cancelRequests() {
    for (let i = 0; i < this._requests.length; i++) {
      const e = this._requests[i];
      defined$2(e) && e.cancel();
    }
  }
  traverse(i) {
    const e = this._contents;
    if (e && e.length > 0)
      for (let r = 0; r < e.length; r++) {
        const a = e[r].scene;
        a && a.traverse(i);
      }
  }
  dispose() {
    const i = this._contents;
    if (i && i.length > 0)
      for (let e = 0; e < i.length; e++)
        i[e].dispose();
  }
  update(i) {
    const e = this._contents;
    e && e.length > 0 && e.forEach((r) => {
      r.update(i);
    });
  }
  get tileset() {
    return this._tileset;
  }
  get tile() {
    return this._tile;
  }
}
const scratchSphere = new Sphere(), scratchToTileCenter = new Vector3$1(), scratchDirectionWC = new Vector3$1(), scratchCartesian = new Vector3$1();
function isolateDigits(o, i, e) {
  const r = o * Math.pow(10, i);
  return parseInt(r, 10) * Math.pow(10, e);
}
function hasExtension$1(o, i) {
  return defined$2(o) && defined$2(o.extensions) && defined$2(o.extensions[i]);
}
function requestMultipleContents(o) {
  let i = o._content;
  const e = o._tileset;
  if (!defined$2(i)) {
    const s = hasExtension$1(o.content, "3DTILES_multiple_contents") ? o._header.extensions["3DTILES_multiple_contents"] : o._header;
    i = new Multiple3DTileContents(
      e,
      o,
      o._contentResource.clone(),
      s
    ), o._content = i;
  }
  const r = i.requestInnerContents();
  if (!!defined$2(r))
    return o._contentState = Cesium3DTileContentState$1.LOADING, r.then((s) => {
      if (!o.isDestroyed() && !!defined$2(s))
        return o._contentState = Cesium3DTileContentState$1.PROCESSING, i;
    }).catch((s) => {
      if (!o.isDestroyed())
        return o._contentState = Cesium3DTileContentState$1.FAILED, s;
    });
}
function createPriorityFunction(o) {
  return function() {
    return o._priority;
  };
}
function requestSingleContent(o) {
  const i = o._contentResource.clone(), e = new Request({
    throttle: !0,
    throttleByServer: !0,
    priorityFunction: createPriorityFunction(o),
    serverKey: o._serverKey
  });
  o._request = e, i.request = e;
  const r = o._tileset, s = i.fetchArrayBuffer();
  if (!defined$2(s)) {
    ++r.statistics.numberOfAttemptedRequests;
    return;
  }
  return processArrayBuffer(o, r, e, !1, s);
}
function fogDensity(o, i) {
  const e = o * i;
  return 1 - Math.exp(-(e * e));
}
function getJsonFromTypedArray(o, i, e) {
  return JSON.parse(
    getStringFromTypedArray(o, i, e)
  );
}
function getJsonContent(o) {
  let i;
  try {
    i = getJsonFromTypedArray(o);
  } catch {
    throw new Error("Invalid tile content.");
  }
  return i;
}
function priorityNormalizeAndClamp(o, i, e) {
  return Math.max(
    CesiumMath.normalize(o, i, e) - CesiumMath.EPSILON7,
    0
  );
}
function isPriorityDeferred(o, i) {
  const { tileset: e, boundingVolume: r } = o;
  r.getSphere(scratchSphere);
  const a = i._rendering.camera, c = scratchSphere.center, l = scratchSphere.radius, h = e._cameraInfo, d = scratchDirectionWC.copy(h.directionWC).multiplyScalar(o._centerZDepth), f = scratchCartesian.addVectors(
    h.position,
    d
  ), p = scratchCartesian.subVectors(f, c);
  if (p.length() > scratchSphere.radius) {
    const P = scratchCartesian.copy(p).normalize().multiplyScalar(l), D = scratchCartesian.addVectors(c, P);
    scratchCartesian.subVectors(D, h.position);
    const L = scratchCartesian.normalize();
    o._foveatedFactor = 1 - Math.abs(h.directionWC.dot(L));
  } else
    o._foveatedFactor = 0;
  const x = 1 - Math.cos(a.fov * 0.5), v = e.foveatedConeSize * x;
  if (o._foveatedFactor <= v)
    return !1;
  const S = x - v, E = CesiumMath.clamp(
    (o._foveatedFactor - v) / S,
    0,
    1
  ), b = e.foveatedInterpolationCallback(
    e.foveatedMinimumScreenSpaceErrorRelaxation,
    e.screenSpaceError,
    E
  ), w = o._screenSpaceError === 0 && defined$2(o.parent) ? o.parent._screenSpaceError * 0.5 : o._screenSpaceError;
  return e.screenSpaceError - b <= w * 4;
}
function preprocess3DTileContent(o) {
  const i = new Uint8Array(o);
  let e = getMagic(i);
  if (e === "glTF" && (e = "glb"), Cesium3DTileContentType$1.isBinaryFormat(e))
    return {
      contentType: e,
      binaryPayload: i
    };
  const r = getJsonContent(i);
  if (defined$2(r.root))
    return {
      contentType: Cesium3DTileContentType$1.EXTERNAL_TILESET,
      jsonPayload: r
    };
  if (defined$2(r.root))
    return {
      contentType: Cesium3DTileContentType$1.EXTERNAL_TILESET,
      jsonPayload: r
    };
  if (defined$2(r.asset))
    return {
      contentType: Cesium3DTileContentType$1.GLTF,
      jsonPayload: r
    };
  if (defined$2(r.tileAvailability))
    return {
      contentType: Cesium3DTileContentType$1.IMPLICIT_SUBTREE_JSON,
      jsonPayload: r
    };
  if (defined$2(r.type))
    return {
      contentType: Cesium3DTileContentType$1.GEOJSON,
      jsonPayload: r
    };
  if (defined$2(r.voxelTable))
    return {
      contentType: Cesium3DTileContentType$1.VOXEL_JSON,
      jsonPayload: r
    };
  throw new Error("Invalid tile content.");
}
async function makeContent(o, i) {
  const e = preprocess3DTileContent(i), r = o._tileset;
  r._disableSkipLevelOfDetail = r._disableSkipLevelOfDetail || e.contentType === Cesium3DTileContentType$1.GEOMETRY || e.contentType === Cesium3DTileContentType$1.VECTOR, (e.contentType === Cesium3DTileContentType$1.IMPLICIT_SUBTREE || e.contentType === Cesium3DTileContentType$1.IMPLICIT_SUBTREE_JSON) && (o.hasImplicitContent = !0), e.contentType === Cesium3DTileContentType$1.EXTERNAL_TILESET && (o.hasTilesetContent = !0);
  let s;
  const a = Cesium3DTileContentFactory[e.contentType];
  if (o.isDestroyed())
    return;
  defined$2(e.binaryPayload) ? s = await a(
    r,
    o,
    o._contentResource,
    e.binaryPayload.buffer,
    0
  ) : s = await Promise.resolve(
    a(
      r,
      o,
      o._contentResource,
      e.jsonPayload
    )
  );
  const c = o._contentHeader;
  if (o.hasImplicitContentMetadata) {
    const h = o.implicitSubtree, d = o.implicitCoordinates;
    s.metadata = h.getContentMetadataView(d, 0);
  } else
    o.hasImplicitContent || (s.metadata = findContentMetadata(r, c));
  const l = findGroupMetadata(r, c);
  if (defined$2(l) && (s.group = new Cesium3DContentGroup({
    metadata: l
  })), !o.hasTilesetContent && !o.hasImplicitContent) {
    const h = s.scene;
    defined$2(h) && (s.byteSize = estimateBytesUsed(h));
  }
  return s;
}
async function processArrayBuffer(o, i, e, r, s) {
  const a = o._contentState;
  o._contentState = Cesium3DTileContentState$1.LOADING, ++i.statistics.numberOfPendingRequests;
  let c;
  try {
    c = await s;
  } catch {
    if (--i.statistics.numberOfPendingRequests, o.isDestroyed())
      return;
    if (e.cancelled || e.state === RequestState$1.CANCELLED) {
      o._contentState = a, ++i.statistics.numberOfAttemptedRequests;
      return;
    }
    o._contentState = Cesium3DTileContentState$1.FAILED;
  }
  if (o.isDestroyed()) {
    --i.statistics.numberOfPendingRequests;
    return;
  }
  if (e.cancelled || e.state === RequestState$1.CANCELLED) {
    o._contentState = a, --i.statistics.numberOfPendingRequests, ++i.statistics.numberOfAttemptedRequests;
    return;
  }
  try {
    const l = await makeContent(o, c);
    return --i.statistics.numberOfPendingRequests, o.isDestroyed() ? void 0 : (o._content = l, o._contentState = Cesium3DTileContentState$1.PROCESSING, l);
  } catch (l) {
    if (--i.statistics.numberOfPendingRequests, o.isDestroyed())
      return;
    throw o._contentState = Cesium3DTileContentState$1.FAILED, l;
  }
}
function isPriorityProgressiveResolution(o, i) {
  if (o.progressiveResolutionHeightFraction <= 0 || o.progressiveResolutionHeightFraction > 0.5)
    return !1;
  const e = o.screenSpaceError;
  let r = i._screenSpaceErrorProgressiveResolution > e;
  i._priorityProgressiveResolutionScreenSpaceErrorLeaf = !1;
  const s = i.parent, a = i._screenSpaceErrorProgressiveResolution <= e, c = defined$2(s) && s._screenSpaceErrorProgressiveResolution > e;
  return a && c && (i._priorityProgressiveResolutionScreenSpaceErrorLeaf = !0, r = !0), r;
}
class Cesium3DTile {
  constructor(i, e, r, s) {
    this._tileset = i, this._header = r, this.hasTilesetContent = !1, this.hasImplicitContent = !1, this.hasImplicitContentMetadata = !1, this._updatedVisibilityFrame = 0;
    const a = defined$2(r.contents), c = a && r.contents.length > 1 || hasExtension$1(r, "3DTILES_multiple_contents"), l = a && !c ? r.contents[0] : r.content;
    this._contentHeader = l, this.transform = defined$2(r.transform) ? new Matrix4().fromArray(r.transform) : new Matrix4();
    const h = defined$2(s) ? s.computedTransform : i.modelMatrix, d = new Matrix4().copy(h).multiply(this.transform);
    this.computedTransform = d, this.metadata = findTileMetadata(i, r), this.geometricError = r.geometricError, this._geometricError = r.geometricError, defined$2(this._geometricError) || (this._geometricError = defined$2(s) ? s._geometricError : i._geometricError);
    let f;
    defined$2(r.refine) ? f = r.refine.toUpperCase() === "REPLACE" ? Cesium3DTileRefine.REPLACE : Cesium3DTileRefine.ADD : defined$2(s) ? f = s.refine : f = Cesium3DTileRefine.REPLACE, this._parent = s;
    let p, m = !1, y, x;
    if (e = Resource.createIfNeeded(e), c)
      y = Cesium3DTileContentState$1.UNLOADED, x = e.clone();
    else if (defined$2(l)) {
      let S = l.uri;
      defined$2(l.url) && (console.warn(
        'This tileset JSON uses the "content.url" property which has been deprecated. Use "content.uri" instead.'
      ), S = l.url), S === "" ? (p = new Empty3DTileContent(i, this), m = !0, y = Cesium3DTileContentState$1.READY) : (y = Cesium3DTileContentState$1.UNLOADED, x = e.getDerivedResource({
        url: S
      }), RequestScheduler.getServerKey(
        x.getUrlComponent()
      ));
    } else
      p = new Empty3DTileContent(i, this), m = !0, y = Cesium3DTileContentState$1.READY;
    this._content = p, this._contentResource = x, this._contentState = y, this.hasEmptyContent = m, this.hasMultipleContents = c, this.refine = f, this.children = [], this.parent = s, this._screenSpaceError = 0, this._depthToCamera = 0, this._centerZDepth = 0, this._depth = 0, this._refines = !1, this.priorityDeferred = !1, this._visible = !1, this._inRequestVolume = !0, this.contentExpired = !1, this._isInRequestVolume = !0, this._priority = 0, this._priorityHolder = this, this._foveatedFactor = 0;
    const v = new TileBoundingVolume();
    "sphere" in r.boundingVolume && v.setSphereData(...r.boundingVolume.sphere, this.computedTransform), "box" in r.boundingVolume && v.setObbData(r.boundingVolume.box, this.computedTransform), "region" in r.boundingVolume && v.setRegionData(...r.boundingVolume.region), this.boundingVolume = v;
  }
  updatePriority() {
    const i = this.tileset, e = i.preferLeaves, r = i._minimumPriority, s = i._maximumPriority, a = 4, c = 1, l = 0, h = a, p = l + h + a, m = c, y = Math.pow(
      10,
      p
    ), x = p + m, v = Math.pow(10, x);
    let S = priorityNormalizeAndClamp(
      this._depth,
      r.depth,
      s.depth
    );
    S = e ? 1 - S : S;
    const E = priorityNormalizeAndClamp(
      this._priorityHolder._distanceToCamera,
      r.distance,
      s.distance
    ), b = isolateDigits(
      E,
      h,
      l
    ), w = this._priorityProgressiveResolution ? 0 : y;
    priorityNormalizeAndClamp(
      this._priorityHolder._foveatedFactor,
      r.foveatedFactor,
      s.foveatedFactor
    ), this.priorityDeferred;
    const M = this.isVisible ? 0 : Math.pow(10, 10);
    this._priority = S + b + M + w;
  }
  updateContent(i) {
    const e = this.tileset;
    i.update(this), e.dispatchEvent({
      type: "loaded",
      tile: this
    });
  }
  process(i) {
    this.contentReady || (this._selectedFrame = 0, this.lastStyleTime = 0, this._contentState = Cesium3DTileContentState$1.READY, !this.hasTilesetContent && !this.hasImplicitContent && (i._statistics.incrementLoadCounts(this.content), ++i._statistics.numberOfTilesWithContentReady, ++i._statistics.numberOfLoadedTilesTotal, i._cache.add(this)));
    try {
      const e = this._content;
      e.isTileset3DTileContent ? e.update(i) : this.updateContent(e);
    } catch {
      this._contentState = Cesium3DTileContentState$1.FAILED;
    }
  }
  update(i) {
  }
  cancelRequests() {
    this.hasMultipleContents ? this._content.cancelRequests() : this._request.cancel();
  }
  unloadContent() {
    if (!this.hasRenderableContent)
      return;
    const i = this._content;
    i && (i.dispose(), this.tileset.dispatchEvent({
      type: "dispose",
      tile: this
    }), this._content = null), this._contentState = Cesium3DTileContentState$1.UNLOADED;
  }
  requestContent() {
    if (!this.hasEmptyContent)
      return this.hasMultipleContents ? requestMultipleContents(this) : requestSingleContent(this);
  }
  visibility() {
    const i = this.boundingVolume, s = this._tileset._cameraInfo.frustum;
    i.intersectsFrustum(s, !0) ? this._visible = !0 : this._visible = !1;
  }
  computeVisibility(i, e) {
    const a = this.tileset.getCamera().frustum;
    return this.intersectBoundingVolume(i, a);
  }
  intersectBoundingVolume(i, e) {
  }
  updateVisibility(i) {
    const { tileset: e } = this;
    this._updatedVisibilityFrame !== e._updatedVisibilityFrame && (this.updateTransform(), this._distanceToCamera = this.distanceToTile(), this._centerZDepth = this.distanceToTileCenter(i), this._screenSpaceError = this.getScreenSpaceError(), this._screenSpaceErrorProgressiveResolution = this.getScreenSpaceError(
      !1,
      this.tileset.progressiveResolutionHeightFraction
    ), this._priorityProgressiveResolution = isPriorityProgressiveResolution(e, this), this.priorityDeferred = isPriorityDeferred(this, i), this.visibility(), this._updatedVisibilityFrame = e._updatedVisibilityFrame);
  }
  updateTransform() {
    this.geometricError = this._geometricError;
  }
  distanceToTile() {
    const i = this.boundingVolume, e = this.tileset._cameraInfo;
    return i.distanceToPoint(e.position);
  }
  distanceToTileCenter(i) {
    this.boundingVolume;
    const r = this._tileset._cameraInfo, s = this.boundingVolumeCenter;
    return scratchToTileCenter.subVectors(
      s,
      r.position
    ).dot(r.directionWC);
  }
  getScreenSpaceError(i, e) {
    const r = this._tileset, s = defaultValue$1(e, 1), a = defined$2(this.parent) ? this.parent.geometricError : r._scaledGeometricError, c = i ? a : this.geometricError;
    if (c === 0)
      return 0;
    const l = r._cameraInfo;
    this.boundingVolume;
    const h = l.invScale;
    let d;
    if (l.isOrthographic) {
      const f = l.pixelSize;
      d = c / (f * h);
    } else {
      const f = Math.max(this._distanceToCamera, 1e-7), p = f * h, m = l.sseDenominator;
      if (d = c * s / (p * m), r.dynamicScreenSpaceError) {
        const y = r._dynamicScreenSpaceErrorComputedDensity, x = r.dynamicScreenSpaceErrorFactor, v = fogDensity(f, y) * x;
        d -= v;
      }
    }
    return d;
  }
  getDistance() {
    return 100;
  }
  isDestroyed() {
    return !1;
  }
  get contentReady() {
    return this._contentState === Cesium3DTileContentState$1.READY;
  }
  get contentAvailable() {
    return this.contentReady && this.hasRenderableContent;
  }
  get hasRenderableContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent && !this.hasImplicitContent;
  }
  get isVisible() {
    return this._visible && this._inRequestVolume;
  }
  get tileset() {
    return this._tileset;
  }
  get hasUnloadedRenderableContent() {
    return this.hasRenderableContent && this.contentUnLoaded;
  }
  get contentUnLoaded() {
    return this._contentState === Cesium3DTileContentState$1.UNLOADED;
  }
  get content() {
    return this._content;
  }
  get cached() {
    return this._content;
  }
  get __visible() {
    const i = this._tileset;
    return this._selectedFrame === i._updatedVisibilityFrame;
  }
  get boundingVolumeCenter() {
    const i = this.boundingVolume.obb || this.boundingVolume.regionObb;
    return defined$2(i) ? i.center : this.boundingVolume.sphere.center;
  }
}
class Cesium3DTilesetSkipTraversal {
}
const tempSphere = new Sphere();
function isOnScreenLongEnough(o) {
  const { tileset: i } = o;
  if (!i._cullRequestsWhileMoving)
    return !0;
  const e = i._cameraInfo, {
    positionWCDeltaMagnitude: r,
    positionWCDeltaMagnitudeLastFrame: s
  } = e, a = r !== 0 ? r : s;
  o.boundingVolume.getSphere(tempSphere);
  const l = Math.max(tempSphere.radius * 2, 1);
  return i.cullRequestsWhileMovingMultiplier * a / l < 1;
}
class Cesium3DTilesetTraversal {
  static selectTile(i, e) {
    i._wasSelectedLastFrame = !0;
    const { content: r, tileset: s } = i;
    i._selectedFrame = e.frameCount, s._selectedTiles.push(i);
  }
  static sortChildrenByDistanceToCamera(i, e) {
    return e._distanceToCamera === 0 && i._distanceToCamera === 0 ? e._centerZDepth - i._centerZDepth : e._distanceToCamera - i._distanceToCamera;
  }
  static canTraverse(i) {
    return i.children.length === 0 ? !1 : i.hasTilesetContent || i.hasImplicitContent ? !0 : i._screenSpaceError > i.tileset.screenSpaceError;
  }
  static visitTile(i, e) {
    ++i.tileset._statistics.visited, i._visitedFrame = e.frameCount;
  }
  static touchTile(i, e) {
    i._touchedFrame !== e.frameCount && (i.tileset._cache.touch(i), i._touchedFrame = e.frameCount);
  }
  static loadTile(i, e) {
    const { tileset: r } = i;
    i._requestedFrame === e.frameCount || !i.hasUnloadedRenderableContent || !isOnScreenLongEnough(i) || (i._requestedFrame = e.frameCount, r._requestedTiles.push(i));
  }
  static updateTile(i, e) {
    updateTileVisibility(i, e), i._wasMinPriorityChild = !1, i._priorityHolder = i, updateMinimumMaximumPriority(i), i._shouldSelect = !1, i._finalResolution = !0;
  }
}
function updateTileVisibility(o, i) {
  if (o.updateVisibility(i), !o.isVisible)
    return;
  const e = o.children.length > 0;
  if ((o.hasTilesetContent || o.hasImplicitContent) && e) {
    const a = o.children[0];
    updateTileVisibility(a, i), o._visible = a._visible;
    return;
  }
  if (meetsScreenSpaceErrorEarly(o)) {
    o._visible = !1;
    return;
  }
  const r = o.refine === Cesium3DTileRefine.REPLACE, s = o._optimChildrenWithinParent === Cesium3DTileOptimizationHint.USE_OPTIMIZATION;
  if (r && s && e && !anyChildrenVisible(o, i)) {
    ++o.tileset._statistics.numberOfTilesCulledWithChildrenUnion, o._visible = !1;
    return;
  }
}
function updateMinimumMaximumPriority(o) {
  const i = o.tileset._minimumPriority, e = o.tileset._maximumPriority, r = o._priorityHolder;
  e.distance = Math.max(
    r._distanceToCamera,
    e.distance
  ), i.distance = Math.min(
    r._distanceToCamera,
    i.distance
  ), e.depth = Math.max(o._depth, e.depth), i.depth = Math.min(o._depth, i.depth), e.foveatedFactor = Math.max(
    r._foveatedFactor,
    e.foveatedFactor
  ), i.foveatedFactor = Math.min(
    r._foveatedFactor,
    i.foveatedFactor
  );
}
function anyChildrenVisible(o, i) {
  let e = !1;
  const r = o.children;
  for (let s = 0; s < r.length; ++s) {
    const a = r[s];
    a.updateVisibility(i), e = e || a.isVisible;
  }
  return e;
}
function meetsScreenSpaceErrorEarly(o) {
  const { parent: i, tileset: e } = o;
  return !defined$2(i) || i.hasTilesetContent || i.hasImplicitContent || i.refine !== Cesium3DTileRefine.ADD ? !1 : o.getScreenSpaceError(!0) <= e.screenSpaceError;
}
class ManagedArray {
  constructor(i = 0) {
    i = defaultValue$1(i, 0), this._array = new Array(i), this._length = i;
  }
  get length() {
    return this._length;
  }
  set length(i) {
    const e = this._array, r = this._length;
    if (i < r)
      for (let s = i; s < r; ++s)
        e[s] = void 0;
    else
      i > e.length && (e.length = i);
    this._length = i;
  }
  get values() {
    return this._array;
  }
  get(i) {
    return this._array[i];
  }
  set(i, e) {
    i >= this._length && (this.length = i + 1), this._array[i] = e;
  }
  peek() {
    return this._array[this._length - 1];
  }
  push(i) {
    const e = this.length++;
    this._array[e] = i;
  }
  pop() {
    if (this._length === 0)
      return;
    const i = this._array[this._length - 1];
    return --this.length, i;
  }
  reserve(i) {
    i > this._array.length && (this._array.length = i);
  }
  resize(i) {
    this.length = i;
  }
  trim(i) {
    i = defaultValue$1(i, this._length), this._array.length = i;
  }
}
const traversal = {
  stack: new ManagedArray(),
  stackMaximumLength: 0
}, emptyTraversal = {
  stack: new ManagedArray(),
  stackMaximumLength: 0
}, loadedTraversal = {
  stack: new ManagedArray(),
  stackMaximumLength: 0
};
class Cesium3DTilesetBaseTraversal {
  static selectTiles(i, e) {
    i._requestedTiles.length = 0, i._selectedTiles.length = 0, i._selectedTilesToStyle.length = 0, i._emptyTiles.length = 0, i.hasMixedContent = !1;
    let r = i.root;
    if (Cesium3DTilesetTraversal.updateTile(r, e), !r.isVisible || r.getScreenSpaceError(!0) < i.screenSpaceError)
      return;
    executeTraversal(r, e), traversal.stack.trim(traversal.stackMaximumLength), emptyTraversal.stack.trim(emptyTraversal.stackMaximumLength);
    const s = i._requestedTiles;
    for (let a = 0; a < s.length; ++a)
      s[a].updatePriority();
  }
  static forEachLoadedTile(i, e) {
    const r = i.root;
    if (!defined$2(r))
      return;
    const s = loadedTraversal.stack;
    for (s.push(r); s.length > 0; ) {
      const a = s.pop();
      a.children.forEach((h) => {
        s.push(h);
      });
      const l = a.content;
      if (a.hasRenderableContent && l) {
        const h = l.scene;
        e(h, a);
      }
    }
  }
}
function executeTraversal(o, i) {
  const { tileset: e } = o, {
    canTraverse: r,
    loadTile: s,
    visitTile: a,
    touchTile: c
  } = Cesium3DTilesetTraversal, l = traversal.stack;
  for (l.push(o); l.length > 0; ) {
    traversal.stackMaximumLength = Math.max(
      traversal.stackMaximumLength,
      l.length
    );
    const h = l.pop(), d = h.parent, f = !defined$2(d) || d._refines;
    let p = !0;
    if (r(h)) {
      const x = updateAndPushChildren(h, l, i);
      p = x.anyChildrenVisible, h._refines = x.refines && f;
    } else
      h._refines = !1;
    const y = !h._refines && f;
    h.hasRenderableContent ? h.refine === Cesium3DTileRefine.ADD ? (selectDesiredTile(h, i, p), s(h, i)) : h.refine === Cesium3DTileRefine.REPLACE && (s(h, i), y && selectDesiredTile(h, i, p)) : (e._emptyTiles.push(h), s(h, i), y && selectDesiredTile(h, i, p)), a(h, i), c(h, i);
  }
}
function selectDesiredTile(o, i, e) {
  const r = o.refine === Cesium3DTileRefine.REPLACE, s = o._optimChildrenWithinParent === Cesium3DTileOptimizationHint.USE_OPTIMIZATION, a = o.children && o.children.length > 0, c = s && a && r;
  if (o.contentAvailable) {
    if (c && !e) {
      ++o.tileset._statistics.numberOfTilesCulledWithChildrenUnion;
      return;
    }
    Cesium3DTilesetTraversal.selectTile(o, i);
  }
}
function updateAndPushChildren(o, i, e) {
  const r = o.refine === Cesium3DTileRefine.REPLACE, { tileset: s, children: a } = o, { updateTile: c, loadTile: l, touchTile: h } = Cesium3DTilesetTraversal;
  for (let x = 0; x < a.length; x++)
    c(a[x], e);
  a.sort(Cesium3DTilesetTraversal.sortChildrenByDistanceToCamera);
  const d = r && o.hasRenderableContent;
  let f = !0, p = !1, m = -1, y = Number.MAX_VALUE;
  for (let x = 0; x < a.length; ++x) {
    const v = a[x];
    if (v.isVisible ? (i.push(v), v._foveatedFactor < y && (m = x, y = v._foveatedFactor), p = !0) : (d || s.loadSiblings) && (v._foveatedFactor < y && (m = x, y = v._foveatedFactor), l(v, e), h(v, e)), d) {
      let S;
      v._isInRequestVolume ? v.hasRenderableContent ? S = v.contentAvailable : S = executeEmptyTraversal(v, e) : S = !1, f = f && !(v.isVisible && !S);
    }
  }
  if (p || (f = !1), m !== -1 && r) {
    const x = a[m];
    x._wasMinPriorityChild = !0;
    const v = (o._wasMinPriorityChild || o === s.root) && y <= o._priorityHolder._foveatedFactor ? o._priorityHolder : o;
    v._foveatedFactor = Math.min(
      x._foveatedFactor,
      v._foveatedFactor
    ), v._distanceToCamera = Math.min(
      x._distanceToCamera,
      v._distanceToCamera
    );
    for (let S = 0; S < a.length; ++S)
      a[S]._priorityHolder = v;
  }
  return {
    refines: f,
    anyChildrenVisible: p
  };
}
function executeEmptyTraversal(o, i) {
  const {
    canTraverse: e,
    updateTile: r,
    loadTile: s,
    touchTile: a
  } = Cesium3DTilesetTraversal;
  let c = !0;
  const l = emptyTraversal.stack;
  for (l.push(o); l.length > 0; ) {
    emptyTraversal.stackMaximumLength = Math.max(
      emptyTraversal.stackMaximumLength,
      l.length
    );
    const h = l.pop(), d = h.children, f = d.length, p = !h.hasRenderableContent && e(h);
    if (!p && !h.contentAvailable && (c = !1), r(h, i), h.isVisible || (s(h, i), a(h, i)), p)
      for (let m = 0; m < f; ++m) {
        const y = d[m];
        l.push(y);
      }
  }
  return o.hasEmptyContent || c;
}
class ImplicitTileset {
  constructor(i, e, r) {
    const s = hasExtension(e, "3DTILES_implicit_tiling") ? e.extensions["3DTILES_implicit_tiling"] : e.implicitTiling;
    this.baseResource = i, this.geometricError = e.geometricError, this.metadataSchema = r;
    const a = e.boundingVolume;
    if (!defined$2(a.box) && !defined$2(a.region) && !hasExtension(a, "3DTILES_bounding_volume_S2") && !hasExtension(a, "3DTILES_bounding_volume_cylinder"))
      throw new Error(
        "Only box, region, 3DTILES_bounding_volume_S2, and 3DTILES_bounding_volume_cylinder are supported for implicit tiling"
      );
    this.boundingVolume = a, this.refine = e.refine, this.subtreeUriTemplate = new Resource({ url: s.subtrees.uri }), this.contentUriTemplates = [], this.contentHeaders = [];
    const c = gatherContentHeader(e);
    for (let l = 0; l < c.length; l++) {
      const h = c[l];
      this.contentHeaders.push(clone$2(h, !0));
      const d = new Resource({
        url: h.uri
      });
      this.contentUriTemplates.push(d);
    }
    this.contentCount = this.contentHeaders.length, this.tileHeader = makeTileHeaderTemplate(e), this.subdivisionScheme = ImplicitSubdivisionScheme[s.subdivisionScheme], this.branchingFactor = ImplicitSubdivisionScheme.getBranchingFactor(this.subdivisionScheme), this.subtreeLevels = s.subtreeLevels, defined$2(s.availableLevels) ? this.availableLevels = s.availableLevels : this.availableLevels = s.maximumLevel + 1;
  }
}
function gatherContentHeader(o) {
  if (hasExtension(o, "3DTILES_multiple_contents")) {
    const i = o.extensions["3DTILES_multiple_contents"];
    return defined$2(i.contents) ? i.contents : i.content;
  }
  return defined$2(o.contents) ? o.contents : defined$2(o.content) ? [o.content] : [];
}
function makeTileHeaderTemplate(o) {
  const i = clone$2(o, !0);
  return defined$2(i.extensions) && (delete i.extensions["3DTILES_implicit_tiling"], delete i.extensions["3DTILES_multiple_contents"], Object.keys(i.extensions).length === 0 && delete i.extensions), delete i.implicitTiling, delete i.contents, delete i.content, i;
}
const MortonOrder = {};
function insertOneSpacing(o) {
  return o = (o ^ o << 8) & 16711935, o = (o ^ o << 4) & 252645135, o = (o ^ o << 2) & 858993459, o = (o ^ o << 1) & 1431655765, o;
}
function insertTwoSpacing(o) {
  return o = (o ^ o << 16) & 50331903, o = (o ^ o << 8) & 50393103, o = (o ^ o << 4) & 51130563, o = (o ^ o << 2) & 153391689, o;
}
function removeOneSpacing(o) {
  return o &= 1431655765, o = (o ^ o >> 1) & 858993459, o = (o ^ o >> 2) & 252645135, o = (o ^ o >> 4) & 16711935, o = (o ^ o >> 8) & 65535, o;
}
function removeTwoSpacing(o) {
  return o &= 153391689, o = (o ^ o >> 2) & 51130563, o = (o ^ o >> 4) & 50393103, o = (o ^ o >> 8) & 4278190335, o = (o ^ o >> 16) & 1023, o;
}
MortonOrder.encode2D = function(o, i) {
  return (insertOneSpacing(o) | insertOneSpacing(i) << 1) >>> 0;
};
MortonOrder.decode2D = function(o, i) {
  return defined$2(i) || (i = new Array(2)), i[0] = removeOneSpacing(o), i[1] = removeOneSpacing(o >> 1), i;
};
MortonOrder.encode3D = function(o, i, e) {
  return insertTwoSpacing(o) | insertTwoSpacing(i) << 1 | insertTwoSpacing(e) << 2;
};
MortonOrder.decode3D = function(o, i) {
  return defined$2(i) || (i = new Array(3)), i[0] = removeTwoSpacing(o), i[1] = removeTwoSpacing(o >> 1), i[2] = removeTwoSpacing(o >> 2), i;
};
const scratchCoordinatesArray = [0, 0, 0];
class ImplicitTileCoordinates {
  constructor(i) {
    this.subdivisionScheme = i.subdivisionScheme, this.subtreeLevels = i.subtreeLevels, this.level = i.level, this.x = i.x, this.y = i.y, this.z = void 0, i.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE && (this.z = i.z);
  }
  getDescendantCoordinates(i) {
    const e = this.level + i.level, r = (this.x << i.level) + i.x, s = (this.y << i.level) + i.y;
    if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {
      const a = (this.z << i.level) + i.z;
      return new ImplicitTileCoordinates({
        subdivisionScheme: this.subdivisionScheme,
        subtreeLevels: this.subtreeLevels,
        level: e,
        x: r,
        y: s,
        z: a
      });
    }
    return new ImplicitTileCoordinates({
      subdivisionScheme: this.subdivisionScheme,
      subtreeLevels: this.subtreeLevels,
      level: e,
      x: r,
      y: s
    });
  }
  getAncestorCoordinates(i) {
    const e = 1 << i, r = this.level - i, s = Math.floor(this.x / e), a = Math.floor(this.y / e);
    if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {
      const c = Math.floor(this.z / e);
      return new ImplicitTileCoordinates({
        subdivisionScheme: this.subdivisionScheme,
        subtreeLevels: this.subtreeLevels,
        level: r,
        x: s,
        y: a,
        z: c
      });
    }
    return new ImplicitTileCoordinates({
      subdivisionScheme: this.subdivisionScheme,
      subtreeLevels: this.subtreeLevels,
      level: r,
      x: s,
      y: a
    });
  }
  getOffsetCoordinates(i) {
    const e = i.level - this.level, r = 1 << e, s = i.x % r, a = i.y % r;
    if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {
      const c = i.z % r;
      return new ImplicitTileCoordinates({
        subdivisionScheme: this.subdivisionScheme,
        subtreeLevels: this.subtreeLevels,
        level: e,
        x: s,
        y: a,
        z: c
      });
    }
    return new ImplicitTileCoordinates({
      subdivisionScheme: this.subdivisionScheme,
      subtreeLevels: this.subtreeLevels,
      level: e,
      x: s,
      y: a
    });
  }
  getChildCoordinates(i) {
    const e = this.level + 1, r = 2 * this.x + i % 2, s = 2 * this.y + Math.floor(i / 2) % 2;
    if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {
      const a = 2 * this.z + Math.floor(i / 4) % 2;
      return new ImplicitTileCoordinates({
        subdivisionScheme: this.subdivisionScheme,
        subtreeLevels: this.subtreeLevels,
        level: e,
        x: r,
        y: s,
        z: a
      });
    }
    return new ImplicitTileCoordinates({
      subdivisionScheme: this.subdivisionScheme,
      subtreeLevels: this.subtreeLevels,
      level: e,
      x: r,
      y: s
    });
  }
  getSubtreeCoordinates() {
    return this.getAncestorCoordinates(this.level % this.subtreeLevels);
  }
  getParentSubtreeCoordinates() {
    return this.getAncestorCoordinates(
      this.level % this.subtreeLevels + this.subtreeLevels
    );
  }
  isAncestor(i) {
    const e = i.level - this.level;
    if (e <= 0)
      return !1;
    const r = i.x >> e, s = i.y >> e, a = this.x === r, c = this.y === s;
    if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {
      const l = i.z >> e, h = this.z === l;
      return a && c && h;
    }
    return a && c;
  }
  isEqual(i) {
    return this.subdivisionScheme === i.subdivisionScheme && this.subtreeLevels === i.subtreeLevels && this.level === i.level && this.x === i.x && this.y === i.y && (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE ? this.z === i.z : !0);
  }
  isImplicitTilesetRoot() {
    return this.level === 0;
  }
  isSubtreeRoot() {
    return this.level % this.subtreeLevels === 0;
  }
  isBottomOfSubtree() {
    return this.level % this.subtreeLevels === this.subtreeLevels - 1;
  }
  getTemplateValues() {
    const i = {
      level: this.level,
      x: this.x,
      y: this.y
    };
    return this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE && (i.z = this.z), i;
  }
  static fromMortonIndex(i, e, r, s) {
    let a;
    return i === ImplicitSubdivisionScheme.OCTREE ? (a = MortonOrder.decode3D(
      s,
      scratchCoordinatesArray
    ), new ImplicitTileCoordinates({
      subdivisionScheme: i,
      subtreeLevels: e,
      level: r,
      x: a[0],
      y: a[1],
      z: a[2]
    })) : (a = MortonOrder.decode2D(s, scratchCoordinatesArray), new ImplicitTileCoordinates({
      subdivisionScheme: i,
      subtreeLevels: e,
      level: r,
      x: a[0],
      y: a[1]
    }));
  }
  static fromTileIndex(i, e, r) {
    let s, a, c;
    return i === ImplicitSubdivisionScheme.OCTREE ? (s = Math.floor(Math.log2(7 * r + 1) / 3), a = ((1 << 3 * s) - 1) / 7, c = r - a) : (s = Math.floor(Math.log2(3 * r + 1) / 2), a = ((1 << 2 * s) - 1) / 3, c = r - a), ImplicitTileCoordinates.fromMortonIndex(
      i,
      e,
      s,
      c
    );
  }
  get childIndex() {
    let i = 0;
    return i |= this.x & 1, i |= (this.y & 1) << 1, this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE && (i |= (this.z & 1) << 2), i;
  }
  get mortonIndex() {
    return this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE ? MortonOrder.encode3D(this.x, this.y, this.z) : MortonOrder.encode2D(this.x, this.y);
  }
  get tileIndex() {
    const i = this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE ? ((1 << 3 * this.level) - 1) / 7 : ((1 << 2 * this.level) - 1) / 3, e = this.mortonIndex;
    return i + e;
  }
}
const _norm = new Vector3$1(), _norm2 = new Vector3$1(), _cartographic = new Vector3$1(), _pos = new Vector3$1();
new Vector3$1();
new Vector3$1();
function getRegionGeometry(o) {
  const {
    latStart: i = -Math.PI / 2,
    latEnd: e = Math.PI / 2,
    lonStart: r = 0,
    lonEnd: s = 2 * Math.PI,
    heightStart: a = 0,
    heightEnd: c = 0
  } = o, l = new BoxGeometry(1, 1, 1, 32, 32), { normal: h, position: d } = l.attributes, f = d.clone();
  for (let p = 0; p < d.count; ++p) {
    _pos.fromBufferAttribute(d, p);
    const m = MathUtils.mapLinear(_pos.x, -0.5, 0.5, i, e), y = MathUtils.mapLinear(_pos.y, -0.5, 0.5, r, s);
    let x = a;
    _pos.z < 0 && (x = c), o.cartographicToCartesian(_cartographic.set(y, m, x), _pos), d.setXYZ(p, ..._pos);
  }
  l.computeVertexNormals();
  for (let p = 0, m = f.count; p < m; p++) {
    _pos.fromBufferAttribute(f, p);
    const y = MathUtils.mapLinear(_pos.x, -0.5, 0.5, i, e), x = MathUtils.mapLinear(_pos.y, -0.5, 0.5, r, s);
    _norm.fromBufferAttribute(h, p), o.geodeticSurfaceNormalCartographic(_cartographic.set(x, y, 0), _norm2), Math.abs(_norm.dot(_norm2)) > 0.1 && (_pos.z > 0 && _norm2.multiplyScalar(-1), h.setXYZ(p, ..._norm2));
  }
  return l;
}
class EllipsoidRegionLineHelper extends LineSegments {
  constructor(i = new EllipsoidRegion(), e = 16776960) {
    super(), this.ellipsoidRegion = i, this.material.color.set(e), this.update();
  }
  update() {
    const i = getRegionGeometry(this.ellipsoidRegion);
    this.geometry.dispose(), this.geometry = new EdgesGeometry(i, 80);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const _vector$2 = new Vector3$1(), axes = ["x", "y", "z"];
class SphereHelper extends LineSegments {
  constructor(i, e = 16776960, r = 40) {
    const s = new BufferGeometry(), a = [];
    for (let c = 0; c < 3; c++) {
      const l = axes[c], h = axes[(c + 1) % 3];
      _vector$2.set(0, 0, 0);
      for (let d = 0; d < r; d++) {
        let f;
        f = 2 * Math.PI * d / (r - 1), _vector$2[l] = Math.sin(f), _vector$2[h] = Math.cos(f), a.push(_vector$2.x, _vector$2.y, _vector$2.z), f = 2 * Math.PI * (d + 1) / (r - 1), _vector$2[l] = Math.sin(f), _vector$2[h] = Math.cos(f), a.push(_vector$2.x, _vector$2.y, _vector$2.z);
      }
    }
    s.setAttribute("position", new BufferAttribute(new Float32Array(a), 3)), s.computeBoundingSphere(), super(s, new LineBasicMaterial({ color: e, toneMapped: !1 })), this.sphere = i, this.type = "SphereHelper";
  }
  updateMatrixWorld(i) {
    const e = this.sphere;
    this.position.copy(e.center), this.scale.setScalar(e.radius), super.updateMatrixWorld(i);
  }
}
const ORIGINAL_MATERIAL = Symbol("ORIGINAL_MATERIAL"), emptyRaycast = () => {
}, colors = {};
function getIndexedRandomColor(o) {
  if (!colors[o]) {
    const i = Math.random(), e = 0.5 + Math.random() * 0.5, r = 0.375 + Math.random() * 0.25;
    colors[o] = new Color().setHSL(i, e, r);
  }
  return colors[o];
}
const NONE = 0;
class DebugTilesPlugin {
  constructor(i) {
    i = {
      displayBoxBounds: !1,
      displaySphereBounds: !1,
      displayRegionBounds: !0,
      colorMode: NONE,
      maxDebugDepth: -1,
      maxDebugDistance: -1,
      maxDebugError: -1,
      customColorCallback: null,
      ...i
    }, this.name = "DEBUG_TILES_PLUGIN", this.tiles = null, this.extremeDebugDepth = -1, this.extremeDebugError = -1, this.boxGroup = null, this.sphereGroup = null, this.regionGroup = null, this.displayBoxBounds = i.displayBoxBounds, this.displaySphereBounds = i.displaySphereBounds, this.displayRegionBounds = i.displayRegionBounds, this.colorMode = i.colorMode, this.maxDebugDepth = i.maxDebugDepth, this.maxDebugDistance = i.maxDebugDistance, this.maxDebugError = i.maxDebugError, this.customColorCallback = i.customColorCallback, this.getDebugColor = (e, r) => {
      r.setRGB(e, e, e);
    };
  }
  init(i) {
    this.tileset = i;
    const e = i.group;
    this.boxGroup = new Group(), this.boxGroup.name = "DebugTilesRenderer.boxGroup", e.add(this.boxGroup), this.boxGroup.updateMatrixWorld(), this.sphereGroup = new Group(), this.sphereGroup.name = "DebugTilesRenderer.sphereGroup", e.add(this.sphereGroup), this.sphereGroup.updateMatrixWorld(), this.regionGroup = new Group(), this.regionGroup.name = "DebugTilesRenderer.regionGroup", e.add(this.regionGroup), this.regionGroup.updateMatrixWorld(), this._onLoadTileSetCB = (r) => {
    }, this._onLoadTileCB = ({ scene: r, tile: s }) => {
      this._onLoadTile(s);
    }, this._onDisposeTileCB = ({ tile: r }) => {
      this._onDisposeTile(r);
    }, this._onUpdateAfterCB = () => {
      this._onUpdateAfter();
    }, this._onTileVisibilityChangeCB = ({ scene: r, tile: s, visible: a }) => {
      this._onTileVisibilityChange(s, a);
    }, i.addEventListener("loaded", this._onLoadTileCB), i.addEventListener("dispose", this._onDisposeTileCB), i.addEventListener("update-after", this._onUpdateAfterCB), i.addEventListener("visibilitychange", this._onTileVisibilityChangeCB), i.traversalLoadedTile((r, s) => {
      this._onLoadTile(s);
    }), i._selectedTiles.forEach((r) => {
      this._onTileVisibilityChange(r, !0);
    });
  }
  _onLoadTile(i) {
    const e = i.content, r = i.boundingVolume, { obb: s, sphere: a, region: c, regionObb: l } = r, h = i.tileset._selectedTiles;
    if (s) {
      const d = new Group();
      d.name = "DebugTilesRenderer.boxHelperGroup", d.matrix.copy(s.transform), d.matrixAutoUpdate = !1;
      const f = new Box3Helper(s.box, getIndexedRandomColor(i._depth));
      f.raycast = emptyRaycast, d.add(f), e.boxHelperGroup = d, h.includes(i) && this.displayBoxBounds && (this.boxGroup.add(d), d.updateMatrixWorld());
    }
    if (a) {
      const d = new SphereHelper(
        a,
        getIndexedRandomColor(i._depth)
      );
      d.raycast = emptyRaycast, e.sphereHelper = d, h.includes(i) && this.displaySphereBounds && (this.boxGroup.add(d), d.updateMatrixWorld());
    }
    if (c) {
      const d = new EllipsoidRegionLineHelper(c, getIndexedRandomColor(i._depth));
      d.raycast = emptyRaycast;
      const f = l.center;
      d.position.copy(f);
      const p = f.clone().multiplyScalar(-1);
      d.geometry.translate(...p), e.regionHelper = d, h.includes(i) && this.displayRegionBounds && (this.regionGroup.add(d), d.updateMatrixWorld(!0));
    }
    e.traverse((d) => {
      const f = d.material;
      f && (d[ORIGINAL_MATERIAL] = f);
    });
  }
  _onDisposeTile(i) {
    const e = i.content;
    e.boxHelperGroup && (e.boxHelperGroup.removeFromParent(), e.boxHelperGroup.children[0].geometry.dispose(), delete e.boxHelperGroup), e.sphereHelper && (e.sphereHelper.removeFromParent(), e.sphereHelper.geometry.dispose(), delete e.sphereHelper), e.regionHelper && (e.regionHelper.removeFromParent(), e.regionHelper.geometry.dispose(), delete e.regionHelper);
  }
  _initExtremes(i) {
  }
  _onUpdateAfter() {
    !this.tileset.root || (this.boxGroup.visible = this.displayBoxBounds, this.sphereGroup.visible = this.displaySphereBounds, this.regionGroup.visible = this.displayRegionBounds);
  }
  _onTileVisibilityChange(i, e) {
    const r = i.content, s = this.sphereGroup, a = this.boxGroup, c = this.regionGroup, l = r.boxHelperGroup, h = r.sphereHelper, d = r.regionHelper;
    e ? (l && (a.add(l), l.updateMatrixWorld(!0)), h && (s.add(h), h.updateMatrixWorld(!0)), d && (c.add(d), d.updateMatrixWorld(!0))) : (l && a.remove(l), h && s.remove(h), d && c.remove(d));
  }
  dispose() {
    const i = this.tileset;
    i.removeEventListener("loaded", this._onLoadTileCB), i.removeEventListener("dispose", this._onDisposeModelCB), i.removeEventListener("update-after", this._onUpdateAfterCB), i.removeEventListener("visibilitychange", this._onTileVisibilityChangeCB), i.traversalLoadedTile((e, r) => {
      this._onDisposeTile(r);
    }), this.boxGroup.removeFromParent(), this.sphereGroup.removeFromParent(), this.regionGroup.removeFromParent();
  }
}
const _mat = new Matrix4(), _localRay = new Ray(), _vec = new Vector3$1(), _hitArray = [];
function distanceSort(o, i) {
  return o.distance - i.distance;
}
function intersectTileScene(o, i, e) {
  o.traverse((r) => {
    Object.getPrototypeOf(r).raycast.call(r, i, e);
  }), _hitArray.sort(distanceSort);
}
function intersectTilesSceneFirstHist(o, i) {
  intersectTileScene(o, i, _hitArray);
  const e = _hitArray[0] || null;
  return _hitArray.length = 0, e;
}
function raycastTraverseFirstHit(o, i, e, r = null) {
  const { group: s } = o, a = i.content;
  r === null && (r = _localRay, _mat.copy(s.matrixWorld).invert(), r.copy(e.ray).applyMatrix4(_mat));
  const c = [], l = i.children;
  for (let p = 0; p < l.length; p++) {
    const m = l[p];
    if (m._touchedFrame !== o._updatedVisibilityFrame)
      continue;
    m.boundingVolume.intersectRay(r, _vec) !== null && (_vec.applyMatrix4(s.matrixWorld), c.push({
      distance: _vec.distanceToSquared(e.ray.origin),
      tile: m
    }));
  }
  c.sort(distanceSort);
  let h = null, d = null;
  const f = !i.isVisible && i._touchedFrame === o._updatedVisibilityFrame;
  if ((i.__visible || f) && i.hasRenderableContent && a) {
    const p = a.scene, m = intersectTilesSceneFirstHist(p, e);
    m && (h = m, d = Math.pow(m.distance, 2));
  }
  for (let p = 0, m = c.length; p < m; p++) {
    const y = c[p], x = y.distance, v = y.tile;
    if (x > d)
      break;
    const S = raycastTraverseFirstHit(o, v, e, r);
    if (S) {
      const E = S.distance * S.distance;
      E < d && (h = S, d = E);
    }
  }
  return h;
}
function raycastTraverse(o, i, e, r, s = null) {
  const { group: a } = o, { content: c, boundingVolume: l } = i;
  if (s === null && (s = _localRay, _mat.copy(a.matrixWorld).invert(), s.copy(e.ray).applyMatrix4(_mat)), i._touchedFrame !== o._updatedVisibilityFrame || !l.intersectsRay(s))
    return;
  const h = !i.isVisible && i._touchedFrame === o._updatedVisibilityFrame;
  if ((i.__visible || h) && i.hasRenderableContent && c)
    if (c.isMultiple3DTileContents)
      c._contents.forEach((p) => {
        const m = p.scene;
        m && intersectTileScene(m, e, r);
      });
    else {
      const f = c.scene;
      intersectTileScene(f, e, r);
    }
  const d = i.children;
  for (let f = 0; f < d.length; f++)
    raycastTraverse(o, d[f], e, r, s);
}
class ElementsManager {
  constructor(i) {
    _(this, "_tileMaxLevel", 19);
    _(this, "_subscribedMaxLodLevel", 1);
    _(this, "_elementHandlers", []);
    _(this, "_objectParent", null);
    _(this, "subscribedDataTypeMap", {});
    _(this, "_active", !1);
    _(this, "_configVersion", 0);
    _(this, "shouldIgnoreTile", (i) => i.__lodLevel > this._subscribedMaxLodLevel);
    _(this, "parseElements", (i) => {
      const e = i.cached.scene, r = e.batchTable && e.batchTable.header;
      if (!r || !r.id || !r.dataType)
        return;
      const s = r.id, a = r.dataType, c = {}, l = /* @__PURE__ */ new Map();
      let h = null, d = null, f = null;
      for (let p = 0, m = a.length; p < m; p++) {
        if (!this.subscribedDataTypeMap[a[p]])
          continue;
        h = a[p], d = this.subscribedDataTypeMap[h], f = s[p];
        const y = {
          id: f,
          dataType: h,
          position: [],
          uv: [],
          normal: [],
          index: []
        };
        c[p] = y;
        const x = l.get(d);
        x ? x.push(y) : l.set(d, [
          y
        ]);
      }
      for (const p of e.children)
        this.findElementInMesh(p, c, l);
      for (const p of l.keys()) {
        const m = l.get(p);
        p.addTileElementObjects(i, m);
      }
    });
    _(this, "getInterleavedBufferValue2", (i, e) => {
      const r = i.data.array, s = i.data.stride * e + i.offset;
      return [r[s], r[s + 1]];
    });
    _(this, "getInterleavedBufferValue3", (i, e) => {
      const r = i.data.array, s = i.data.stride * e + i.offset;
      return [r[s], r[s + 1], r[s + 2]];
    });
    _(this, "findElementInMesh", (i, e, r) => {
      if (!i || !i.geometry)
        return;
      const s = i.geometry.getAttribute("_batchid");
      if (!s)
        return;
      const a = i.geometry.getAttribute("normal");
      if (!a)
        return;
      const c = i.geometry.getAttribute("position"), l = i.geometry.getAttribute("uv"), h = s.data.count, d = {};
      let f = null;
      for (let m = 0; m < h; m++) {
        if (f = s.getX(m), !e[f])
          continue;
        let y = e[f], x = this.getInterleavedBufferValue3(c, m), v = this.getInterleavedBufferValue3(a, m), S = this.getInterleavedBufferValue2(l, m);
        y.position.push(x[0], x[1], x[2]), y.normal.push(v[0], v[1], v[2]), y.uv.push(S[0], S[1]), d[m] = {
          batchId: f,
          index: y.position.length / 3 - 1
        };
      }
      const p = i.geometry.index.array;
      for (let m = 0, y = p.length - 2; m < y; m += 3) {
        let x = p[m];
        if (d[x] === void 0)
          continue;
        let v = p[m + 1], S = p[m + 2], E = d[x], b = E.batchId, w = E.index, M = d[v] && d[v].index, P = d[S] && d[S].index;
        if (M === void 0 || P === void 0) {
          console.warn("one face includes more than one object");
          continue;
        }
        e[b].index.push(w, M, P);
      }
      for (const m of Object.keys(e)) {
        const y = e[m], x = new BufferGeometry();
        x.setAttribute("position", new BufferAttribute(new Float32Array(y.position), 3)), x.setAttribute("normal", new BufferAttribute(new Float32Array(y.normal), 3)), x.setAttribute("uv", new BufferAttribute(new Float32Array(y.uv), 2)), x.setIndex(y.index), y.geometry = x;
      }
    });
    _(this, "onTileLoad", (i, e) => {
      this.parseTileInfo(i), this.shouldIgnoreTile(i);
    });
    _(this, "onTileDispose", (i, e) => {
      if (!this.shouldIgnoreTile(i))
        for (const r of this._elementHandlers)
          r.disposeTileElementObjects(i);
    });
    _(this, "onTileShow", (i) => {
      !this._active || this.shouldIgnoreTile(i) || this.refreshTile(i);
    });
    _(this, "onTileHide", (i) => {
      if (!(!this._active || this.shouldIgnoreTile(i)))
        for (const e of this._elementHandlers)
          e.hideTileElementObjects(i);
    });
    _(this, "parseTileInfo", (i) => {
      const e = i._contentResource.url, r = e.substring(e.lastIndexOf("/") + 1).split(".")[0], s = r.split("-");
      i.__id = r, i.__level = parseInt(s[0], 10), i.__lodLevel = this._tileMaxLevel - i.__level;
    });
    _(this, "refreshTile", (i) => {
      if (i.__elementsConfigVersion !== this._configVersion) {
        for (const e of this._elementHandlers)
          e.disposeTileElementObjects(i);
        this.parseElements(i), i.__elementsConfigVersion = this._configVersion;
      }
      for (const e of this._elementHandlers)
        e.showTileElementObjects(i);
    });
    _(this, "refreshTiles", () => {
      this.tilesRenderer.forEachLoadedModel((i, e) => {
        !e.__visible || this.shouldIgnoreTile(e) || this.refreshTile(e);
      }), this.engine.requestRender();
    });
    this._objectParent = i;
  }
  registerElement(i) {
    i.parent = this._objectParent, i.engine = this.engine;
    for (const e of i.subscribedDataTypeIds)
      this.subscribedDataTypeMap[e] = i;
    return this._elementHandlers.push(i), this._configVersion++, this._active = !0, this.refreshTiles(), i;
  }
  unregisterElement(i) {
    for (let r of Object.keys(this.subscribedDataTypeMap))
      this.subscribedDataTypeMap[r] === i && delete this.subscribedDataTypeMap[r];
    let e = this._elementHandlers.indexOf(i);
    e > -1 && (i.dispose(), this._elementHandlers.splice(e, 1)), this._configVersion++, this._active = this._elementHandlers.length > 0, this.refreshTiles();
  }
  tick(i) {
    if (!!this._active)
      for (const e of this._elementHandlers)
        e.tick(i);
  }
  get subscribedMaxLodLevel() {
    return this._subscribedMaxLodLevel;
  }
  set subscribedMaxLodLevel(i) {
    this._subscribedMaxLodLevel = i;
  }
}
class TilesetMetadata {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.tileset, r = i.class, s = defined$2(e.properties) ? e.properties : {};
    this._class = r, this._properties = s, this._extras = e.extras, this._extensions = e.extensions;
  }
  hasProperty(i) {
    return MetadataEntity.hasProperty(i, this._properties, this._class);
  }
  hasPropertyBySemantic(i) {
    return MetadataEntity.hasPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  getPropertyIds(i) {
    return MetadataEntity.getPropertyIds(this._properties, this._class, i);
  }
  getProperty(i) {
    return MetadataEntity.getProperty(i, this._properties, this._class);
  }
  setProperty(i, e) {
    return MetadataEntity.setProperty(
      i,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(i) {
    return MetadataEntity.getPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(i, e) {
    return MetadataEntity.setPropertyBySemantic(
      i,
      e,
      this._properties,
      this._class
    );
  }
  get class() {
    return this._class;
  }
  get extra() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
class GroupMetadata {
  constructor(i = {}) {
    i = defaultValue$1(i, {});
    const { id: e, group: r, class: s } = i;
    this._id = e, this._class = s, this._properties = defined$2(r.properties) ? r.properties : {}, this._extras = r.extras, this._extensions = r.extensions;
  }
  get class() {
    return this._class;
  }
  get id() {
    return this._id;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(i) {
    return MetadataEntity.hasProperty(i, this._properties, this._class);
  }
  hasPropertyBySemantic(i) {
    return MetadataEntity.hasPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  getPropertyIds(i) {
    return MetadataEntity.getPropertyIds(this._properties, this._class, i);
  }
  getProperty(i) {
    return MetadataEntity.getProperty(i, this._properties, this._class);
  }
  setProperty(i, e) {
    return MetadataEntity.setProperty(
      i,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(i) {
    return MetadataEntity.getPropertyBySemantic(
      i,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(i, e) {
    return MetadataEntity.setPropertyBySemantic(
      i,
      e,
      this._properties,
      this._class
    );
  }
}
class Cesium3DTilesetMetadata {
  constructor(i) {
    i = defaultValue$1(i, {});
    const e = i.metadataJson, r = i.schema, s = defaultValue$1(e.metadata, e.tileset);
    let a;
    defined$2(s) && (a = new TilesetMetadata({
      tileset: s,
      class: r.classes[s.class]
    }));
    let c = [];
    const l = [], h = e.groups;
    if (Array.isArray(h)) {
      const d = h.length;
      for (let f = 0; f < d; f++) {
        const p = h[f];
        l.push(
          new GroupMetadata({
            group: p,
            class: r.classes[p.class]
          })
        );
      }
    } else if (defined$2(h)) {
      c = Object.keys(h).sort();
      const d = c.length;
      for (let f = 0; f < d; f++) {
        const p = c[f];
        if (h.hasOwnProperty(p)) {
          const m = h[p];
          l.push(
            new GroupMetadata({
              id: p,
              group: h[p],
              class: r.classes[m.class]
            })
          );
        }
      }
    }
    this._schema = r, this._groups = l, this._groupIds = c, this._tileset = a, this._statistics = e.statistics, this._extras = e.extras, this._extensions = e.extensions;
  }
  get schema() {
    return this._schema;
  }
  get groups() {
    return this._groups;
  }
  get groupIds() {
    return this._groupIds;
  }
  get tileset() {
    return this._tileset;
  }
  get statistics() {
    return this._statistics;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
const defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1ZjJlYTllMy1kYWRiLTQwYjctOGZhOS02NGJkOTJhYTA1ODUiLCJpZCI6MjU5LCJpYXQiOjE3Mjc3OTI2NzB9.XbfI79d1v3T5OpMl4CznrcBuctSfW1lycPWlt8bq_1A", Ion = {};
Ion.defaultAccessToken = defaultAccessToken;
Ion.defaultServer = new Resource({ url: "https://api.cesium.com/" });
function retryCallback(o, i) {
  const e = defaultValue$1(o._ionRoot, o), r = e._ionEndpointResource, s = typeof Image < "u";
  return !defined$2(i) || i.statusCode !== 401 && !(s && i.target instanceof Image) ? Promise.resolve(!1) : (defined$2(e._pendingPromise) || (e._pendingPromise = r.fetchJson().then(function(a) {
    return e._ionEndpoint = a, a;
  }).finally(function(a) {
    return e._pendingPromise = void 0, a;
  })), e._pendingPromise.then(function(a) {
    return o._ionEndpoint = a, !0;
  }));
}
const rt = class extends Resource {
  constructor(i, e) {
    let r;
    const s = i.externalType, a = defined$2(s);
    if (!a)
      r = {
        url: i.url,
        retryAttempts: 1,
        retryCallback
      };
    else if (s === "3DTILES" || s === "STK_TERRAIN_SERVER")
      r = { url: i.options.url };
    else
      throw new Error(
        "Ion.createResource does not support external imagery assets; use IonImageryProvider instead."
      );
    super(r), this._ionEndpoint = i, this._ionEndpointDomain = a ? void 0 : new Uri(i.url).authority(), this._ionEndpointResource = e, this._ionRoot = void 0, this._pendingPromise = void 0, this._credits = void 0, this._isExternal = a;
  }
  static fromAssetId(i, e) {
    const r = rt._createEndpointResource(
      i,
      e
    );
    return r.fetchJson().then(function(s) {
      return new rt(s, r);
    });
  }
  clone(i) {
    const e = defaultValue$1(this._ionRoot, this);
    return defined$2(i) || (i = new rt(
      e._ionEndpoint,
      e._ionEndpointResource
    )), i = Resource.prototype.clone.call(this, i), i._ionRoot = e, i._isExternal = this._isExternal, i;
  }
  fetchImage(i) {
    if (!this._isExternal) {
      const e = i;
      i = {
        preferBlob: !0
      }, defined$2(e) && (i.flipY = e.flipY, i.preferImageBitmap = e.preferImageBitmap);
    }
    return Resource.prototype.fetchImage.call(this, i);
  }
  _makeRequest(i) {
    return this._isExternal || new Uri(this.url).authority() !== this._ionEndpointDomain ? Resource.prototype._makeRequest.call(this, i) : (defined$2(i.headers) || (i.headers = {}), i.headers.Authorization = `Bearer ${this._ionEndpoint.accessToken}`, i.headers["X-Cesium-Client"] = "CesiumJS", typeof CESIUM_VERSION < "u" && (i.headers["X-Cesium-Client-Version"] = CESIUM_VERSION), Resource.prototype._makeRequest.call(this, i));
  }
};
let IonResource = rt;
_(IonResource, "_createEndpointResource", function(i, e) {
  e = defaultValue$1(e, {});
  let r = defaultValue$1(e.server, Ion.defaultServer);
  const s = defaultValue$1(e.accessToken, Ion.defaultAccessToken);
  r = Resource.createIfNeeded(r);
  const a = {
    url: `v1/assets/${i}/endpoint`
  };
  return defined$2(s) && (a.queryParameters = { access_token: s }), r.getDerivedResource(a);
});
const tempMatrix$1 = new Matrix4(), childMatrix = new Matrix4(), scratchTranslation = new Vector3$1(), scratchRotation$1 = new Vector3$1();
class InstancedModel extends Object3D {
  constructor(e, r) {
    super();
    _(this, "isEventEntitySupported", !0);
    _(this, "isInstancedModel", !0);
    _(this, "_meshes", []);
    _(this, "_idIndexMap", {});
    _(this, "_indexIdMap", {});
    _(this, "_matrixAttribute", null);
    _(this, "_count", 0);
    _(this, "_rtc", null);
    _(this, "updateRenderingMesh", () => {
      this._cleanOldMesh();
      const e = this._meshes, r = e.length;
      for (let s = 0; s < r; ++s) {
        const a = e[s], c = new InstancedMesh(a.geometry, a.material);
        c.__eventProxyByParent = !0, c.castShadow = a.castShadow, c.receiveShadow = a.receiveShadow, c.parent = this, c.name = a.name, this.add(c), a.isInstancedMesh && (c._isOriginalInstancedMesh = !0, c._rawInstanceMatrix = a.instanceMatrix, c._rawCount = a.count);
      }
    });
    _(this, "_cleanOldMesh", () => {
      const e = this.children;
      for (let r = e.length - 1; r >= 0; r--) {
        const s = e[r];
        this.remove(s), s.dispose();
      }
    });
    if (e)
      this._meshes = e;
    else {
      const s = this._defaultMesh = new Mesh(new BoxGeometry(1, 1, 1), new MeshBasicMaterial({
        color: 16777215
      }));
      this._meshes = [s];
    }
    this.updateRenderingMesh(), this._matrixAttribute = new InstancedBufferAttribute(new Float32Array(r * 16), 16), this._initialized = !0;
  }
  afterAddToEngine(e) {
    this.engine = e;
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  getEntityByIndex(e) {
    const r = this._indexIdMap[e];
    if (r === void 0)
      return null;
    const s = {
      id: r,
      index: e
    };
    return s.matrix = this._matrixAttribute.array.slice(e * 16, (e + 1) * 16), s;
  }
  has(e) {
    return this._idIndexMap[e] !== void 0;
  }
  clear() {
    this._idIndexMap = {}, this._indexIdMap = {}, this._rtc = null;
  }
  setBufferData(e) {
    if (this.clear(), !e)
      return;
    const s = e.id.length;
    s !== 0 && (this.count = s, e.instanceMatrix ? this._matrixAttribute.array.set(e.instanceMatrix, 16 * this._count) : this.computeTempMatrix(e));
  }
  computeTempMatrix(e) {
    const r = e.id, s = e.translation, a = e.scale, c = e.rotation, l = this._matrixAttribute.array;
    let h = new Matrix4(), d = new Vector3$1(), f = new Vector3$1(), p = new Euler(), m = new Quaternion$1(), y = null, x = null, v = this._rtc;
    v || (s ? (v = [s[0], s[1], s[2]], this._rtc = v, this.position.set(v[0], v[1], v[2])) : v = [0, 0, 0]);
    for (let S = 0; S < this._count; S++) {
      let E = S * 3;
      if (a ? f.set(a[E], a[E + 1], a[E + 2]) : f.set(1, 1, 1), s ? d.set(
        s[E] - v[0],
        s[E + 1] - v[1],
        s[E + 2] - v[2]
      ) : d.set(0, 0, 0), scratchRotation$1.set(0, 0, 0), c && scratchRotation$1.set(c[E], c[E + 1], c[E + 2]), this.engine && this.engine.map.isGlobe) {
        const w = {
          heading: -scratchRotation$1.z,
          pitch: -scratchRotation$1.y,
          roll: scratchRotation$1.x
        }, M = Transforms.headingPitchRollToFixedFrame(
          scratchTranslation.set(
            s[E],
            s[E + 1],
            s[E + 2]
          ),
          w
        );
        p.setFromRotationMatrix(M, "ZYX");
      } else
        p.set(scratchRotation$1.x, scratchRotation$1.y, scratchRotation$1.z, "ZYX");
      m.setFromEuler(p), h.compose(d, m, f), E = S * 16;
      const b = h.elements;
      for (let w = 0; w < 16; w++)
        l[E + w] = b[w];
      y = r[S], x = S, this._idIndexMap[y] = x, this._indexIdMap[x] = y;
    }
  }
  update() {
    if (!this._initialized)
      return;
    const e = this.children;
    this._matrixAttribute.needsUpdate = !0;
    for (const r of e) {
      if (r._isOriginalInstancedMesh) {
        const s = r._rawCount * this._count, a = new Float32Array(s * 16);
        for (let c = 0; c < this._count; c++) {
          tempMatrix$1.fromArray(this._matrixAttribute.array, c * 16);
          for (let l = 0; l < r._rawCount; l++)
            childMatrix.fromArray(r._rawInstanceMatrix.array, l * 16), childMatrix.multiplyMatrices(tempMatrix$1, childMatrix), a.set(childMatrix.elements, (c * r._rawCount + l) * 16);
        }
        r.instanceMatrix = new InstancedBufferAttribute(a, 16), r.count = s;
      } else
        r.instanceMatrix = this._matrixAttribute, r.count = this._count;
      r.frustumCulled = !1, r.computeBoundingSphere(), r.instanceMatrix.needsUpdate = !0;
    }
  }
  dispose() {
    this._cleanOldMesh(), this._defaultMesh && (this._defaultMesh.geometry.dispose(), this._defaultMesh.material.dispose());
  }
  raycast(e, r) {
    if (!this.visible) {
      this.traverse((s) => {
        s.isMesh && !s._originRaycast && (s._originRaycast = s.raycast, s.raycast = () => {
        });
      });
      return;
    }
    this.traverse((s) => {
      s.isMesh && s._originRaycast && (s.raycast = s._originRaycast, delete s._originRaycast);
    });
  }
  set needsUpdate(e) {
    e && this.update();
  }
  set count(e) {
    e !== this._count && (this._count = e, this._matrixAttribute = new InstancedBufferAttribute(new Float32Array(e * 16), 16));
  }
  get count() {
    return this._count;
  }
  set meshes(e) {
    !e || (Array.isArray(e) ? this._meshes = e : e.isMesh ? this._meshes = [e] : e.isGroup && (this._meshes = e.children), this.updateRenderingMesh(), this.update());
  }
  get meshes() {
    return this._meshes;
  }
}
const tempMatrix = new Matrix4(), normalizeModel = (o) => {
  const i = new Box3();
  i.setFromObject(o);
  const e = Math.max(i.max.x - i.min.x, i.max.y - i.min.y, i.max.z - i.min.z);
  o.scale.multiplyScalar(1 / e);
}, rotateToZUp = (o) => {
  o.rotation.x = Math.PI / 2;
}, applyTransformToGeometry = (o) => {
  if (o.isInstancedMesh)
    for (let i = 0; i < o.count; i++)
      tempMatrix.fromArray(o.instanceMatrix.array, i * 16), tempMatrix.multiplyMatrices(o.matrixWorld, tempMatrix), o.instanceMatrix.array.set(tempMatrix.elements, i * 16);
  else if (o.isSkinnedMesh)
    o.skeleton.pose(), o.geometry.applyMatrix4(o.bindMatrixInverse), o.geometry.applyMatrix4(o.matrixWorld);
  else if (o.isMesh)
    o.geometry.applyMatrix4(o.matrixWorld);
  else if (o.isBone)
    o.matrixWorld.decompose(o.position, o.quaternion, o.scale);
  else if (o.children.length > 0)
    for (const i of o.children)
      applyTransformToGeometry(i);
  o.position.set(0, 0, 0), o.scale.set(1, 1, 1), o.quaternion.set(0, 0, 0, 1);
}, collectMesh = (o, i) => {
  if (o.isMesh || o.isBone)
    i.push(o);
  else if (o.children.length > 0)
    for (const e of o.children)
      collectMesh(e, i);
}, parseScene = (o, i, e) => {
  i && normalizeModel(o), e && rotateToZUp(o), o.updateMatrixWorld(), applyTransformToGeometry(o), o.updateMatrixWorld();
  const r = [];
  return collectMesh(o, r), r;
}, parseLODModel = (o, i, e) => {
  const r = [];
  for (const s of o) {
    const a = s.name;
    if (!a.startsWith("lod"))
      continue;
    const c = parseInt(a.substring(3), 10);
    if (isNaN(c))
      continue;
    const l = parseScene(s, i, e);
    r[c] = l;
  }
  return r;
}, model = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLODModel,
  parseScene
}, Symbol.toStringTag, { value: "Module" }));
let _box$1 = new Box3(), _vector$1 = new Vector3$1();
class CustomInstancedBufferGeometry extends InstancedBufferGeometry {
  constructor() {
    super(...arguments);
    _(this, "isCustomInstancedBufferGeometry", !0);
    _(this, "instanceGeometry", null);
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const e = this.attributes.instancedPosition;
    e !== void 0 ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('CustomInstancedBufferGeometry.computeBoundingBox: Computed min/max have NaN values.The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere());
    let e = this.attributes.instancedPosition;
    if (e) {
      let r = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(e), _box$1.getCenter(r);
      let s = 0;
      for (let a = 0, c = e.count; a < c; a++)
        _vector$1.fromBufferAttribute(e, a), s = Math.max(s, r.distanceToSquared(_vector$1));
      this.boundingSphere.radius = Math.sqrt(s), e.count === 1 && (this.boundingSphere.radius = 1e5), isNaN(this.boundingSphere.radius) && console.error('CustomInstancedBufferGeometry.computeBoundingSphere(): Computed radius is NaN.The "position" attribute is likely to have NaN values.', this);
    }
  }
  getInstanceGeometry() {
    return this.instanceGeometry || (this.instanceGeometry = new BufferGeometry(), this.instanceGeometry.attributes = this.attributes, this.instanceGeometry.index = this.index), this.instanceGeometry;
  }
}
class InstancedBillboardBufferGeometry extends CustomInstancedBufferGeometry {
  constructor() {
    super();
    _(this, "setModelData", () => {
      const e = [
        -0.5,
        0,
        0,
        -0.5,
        0,
        1,
        0.5,
        0,
        1,
        0.5,
        0,
        0
      ], r = [
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0
      ], s = [
        0,
        2,
        1,
        0,
        3,
        2
      ];
      this.setAttribute("position", new Float32BufferAttribute(e, 3)), this.setAttribute("uv", new Float32BufferAttribute(r, 2)), this.setIndex(s);
    });
    this.setModelData();
  }
}
const vertexShader$g = `#define GLSLIFY 1
#include <common>

uniform vec2 imposterFrames;
uniform vec3 positionOffset;
uniform bool isFullSphere;
uniform float imposterScale;
uniform float offsetZ;

#ifdef IS_GLOBE
    attribute mat4 ecefMatrix;
    varying mat4 vEcefMatrix;
#endif

// \u4F20\u9012\u7ED9\u7247\u5143\u7740\u8272\u5668\u7684\u53D8\u91CF
varying vec2 vUv;
varying vec2 grid_classic;
varying vec4 quad_blend_weights;
varying vec3 vNormal;
varying vec3 vViewPosition;
varying vec3 vWorldPosition;
varying vec3 vCenterWorldPosition;
varying vec3 vViewDir;
varying mat3 vTBN;
varying mat3 vRotationMatrix;

// \u516B\u9762\u4F53\u6620\u5C04\u51FD\u6570 - \u5168\u7403\u6A21\u5F0F
vec2 VecToSphereOct(vec3 pivotToCamera) {
    vec3 octant = sign(pivotToCamera);
    float sum = dot(abs(pivotToCamera), vec3(1.0));
    vec3 octahedron = pivotToCamera / sum;

    if (octahedron.y < 0.0) {
        vec3 absolute = abs(octahedron);
        octahedron.xz = octant.xz * vec2(1.0 - absolute.z, 1.0 - absolute.x);
    }
    return octahedron.xz;
}

// \u516B\u9762\u4F53\u6620\u5C04\u51FD\u6570 - \u534A\u7403\u6A21\u5F0F
vec2 VecToHemiSphereOct(vec3 pivotToCamera) {
    vec3 octant = sign(pivotToCamera);
    float sum = dot(abs(pivotToCamera), vec3(1.0));
    vec3 octahedron = pivotToCamera / sum;

    return vec2(
        octahedron.x + octahedron.y,
        octahedron.y - octahedron.x
    );
}
      

// \u6839\u636E\u6A21\u5F0F\u9009\u62E9\u5408\u9002\u7684\u6620\u5C04\u51FD\u6570
vec2 VectorToGrid(vec3 vec) {
    if (isFullSphere) {
        return VecToSphereOct(vec);
    } else {
        return VecToHemiSphereOct(vec);
    }
}

// \u4ECE\u5E27\u5750\u6807\u8F6C\u6362\u56DE\u5C04\u7EBF\u65B9\u5411
vec3 OctaSphereEnc(vec2 coord) {
    coord = (coord - 0.5) * 2.0;
    vec3 position = vec3(coord.x, 0.0, coord.y);
    vec2 absolute = abs(position.xz);
    position.y = 1.0 - absolute.x - absolute.y;

    if (position.y < 0.0) {
        position.xz = sign(position.xz) * vec2(1.0 - absolute.y, 1.0 - absolute.x);
    }

    return position;
}

vec3 OctaHemiSphereEnc(vec2 coord) {
    vec3 position = vec3(coord.x - coord.y, -1.0 + coord.x + coord.y, 0);
    vec2 absolute = abs(position.xy);
    position.z = 1.0 - absolute.x - absolute.y;

    return position;
}

vec3 GridToVector(vec2 coord) {
    if (isFullSphere) {
        return OctaSphereEnc(coord);
    } else {
        return OctaHemiSphereEnc(coord);
    }
}

vec3 FrameXYToRay(vec2 frame, vec2 frameCountMinusOne) {
    vec2 f = frame.xy / frameCountMinusOne;
    vec3 vec = GridToVector(f);
    vec = normalize(vec);
    return vec;
}

// \u8BA1\u7B97\u4E09\u89D2\u5F62\u6DF7\u5408\u6743\u91CD
vec4 quadBlendWieghts(vec2 coords) {
    vec4 res;
    res.x = min(1.0 - coords.x, 1.0 - coords.y);
    res.y = abs(coords.x - coords.y);
    res.z = min(coords.x, coords.y);
    res.w = step(0.0, coords.x - coords.y); // Three.js\u4E2D\u4F7F\u7528step\u66FF\u4EE3ceil
    res.xyz /= (res.x + res.y + res.z);
    return res;
}

float branchFreeTernary(bool comparison, float a, float b) {
    float useA = float(comparison);
    return a * useA + b * (1.0 - useA);
}

float fastApproximateAtan(float x) {
    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);
}

float fastApproximateAtan(float x, float y) {
    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.
    // So range-reduce using abs and by flipping whether x or y is on top.
    float t = abs(x); // t used as swap and atan result.
    float opposite = abs(y);
    float adjacent = max(t, opposite);
    opposite = min(t, opposite);

    t = fastApproximateAtan(opposite / adjacent);

    // Undo range reduction
    t = branchFreeTernary(abs(y) > abs(x), PI / 2.0 - t, t);
    t = branchFreeTernary(x < 0.0, PI - t, t);
    t = branchFreeTernary(y < 0.0, -t, t);
    return t;
}

vec3 SpriteProjection(vec3 viewDir, float frames, vec2 size, vec2 coord) {
    vec3 worldUp = vec3(0.0, 0.0, 1.0); // \u5047\u8BBEZ\u8F74\u662F\u4E16\u754C\u4E0A\u65B9\u5411
    
    vec3 z = normalize(viewDir);
    
    //  \u9876\u89C6\u56FE\u548Cz\u5E73\u884C\uFF0C\u6548\u679C\u4E0D\u597D
    vec3 x = normalize(cross(worldUp, z));
    vec3 y = normalize(cross(z, x));
    if (abs(dot(worldUp, z)) > 0.99) {
        x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));
        y = normalize(cross(z, x));
    }
    
    vec2 uv = ((coord * frames) - 0.5) * 2.0;
    
    vec3 newX = x * uv.x * size.x;
    vec3 newY = y * uv.y * size.y;
    
    return newX + newY;
}

mat4 removeRotation(mat4 matrix) {
    // \u63D0\u53D6\u7F29\u653E\u90E8\u5206
    vec3 scale;
    scale.x = length(matrix[0].xyz);
    scale.y = length(matrix[1].xyz);
    scale.z = length(matrix[2].xyz);

    // \u6784\u5EFA\u65E0\u65CB\u8F6C\u4F46\u4FDD\u7559\u7F29\u653E\u7684\u77E9\u9635
    mat3 scaleMatrix = mat3(
        vec3(scale.x, 0.0, 0.0),
        vec3(0.0, scale.y, 0.0),
        vec3(0.0, 0.0, scale.z)
    );

    // \u6784\u5EFA\u65B0\u7684 matrix\uFF0C\u53BB\u6389\u65CB\u8F6C\u90E8\u5206
    mat4 newMatrix = mat4(
        vec4(scaleMatrix[0], 0.0),
        vec4(scaleMatrix[1], 0.0),
        vec4(scaleMatrix[2], 0.0),
        matrix[3] // \u4FDD\u6301\u539F\u6765\u7684\u5E73\u79FB\u90E8\u5206
    );

    return newMatrix;
}

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main () {
    #include <mvt_selective_vertex>

    vec3 scaleSize;
    scaleSize.x = imposterScale * length(instanceMatrix[0].xyz);
    scaleSize.y = imposterScale * length(instanceMatrix[1].xyz);
    scaleSize.z = imposterScale * length(instanceMatrix[2].xyz);

    vec3 up = vec3(0.0, 0.0, 1.0);
    #ifdef IS_GLOBE
        up = vec3(ecefMatrix[2][0], ecefMatrix[2][1], ecefMatrix[2][2]);
    #endif

    // \u521B\u5EFA\u4E00\u4E2Az\u8F74\u5E73\u79FB10\u4E2A\u5355\u4F4D\u7684\u5E73\u79FB\u77E9\u9635
    mat4 translationMatrix = mat4(
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        up * scaleSize.z * (1.0 + offsetZ), 1.0
    );

    mat4 currentInstanceMatrix = removeRotation(instanceMatrix);

    // \u5C06\u5E73\u79FB\u77E9\u9635\u4E0EinstanceMatrix\u76F8\u4E58
    mat4 translatedInstanceMatrix = currentInstanceMatrix * translationMatrix;

    vec4 worldPosition = modelMatrix * translatedInstanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);

    // \u76F8\u673A\u4E0E plane \u7684\u65B9\u5411\u5411\u91CF
    vec3 toCamera = normalize(cameraPosition - worldPosition.xyz);

    float angleZ = fastApproximateAtan(instanceMatrix[1][0], instanceMatrix[0][0]);
    float c = cos(angleZ);
    float s = sin(angleZ);
    mat3 rotZ = mat3(
        vec3(  c,  -s,  0.0),
        vec3(  s,   c,  0.0),
        vec3(0.0, 0.0,  1.0)
    );
    vRotationMatrix = rotZ;

    #ifdef IS_GLOBE
        mat4 ecefMatrixInverse = inverse(ecefMatrix);
        toCamera = (ecefMatrixInverse * vec4(toCamera, 0.0)).xyz;

        vEcefMatrix = ecefMatrix;
    #endif

    vec3 pivotToCameraRay = normalize(rotZ * toCamera);

    // \u8BA1\u7B97\u516B\u9762\u4F53\u6620\u5C04\u5750\u6807
    vec2 framesMinusOne = imposterFrames - vec2(1.0);
    vec2 grid = VectorToGrid(pivotToCameraRay);
    grid = clamp((grid + 1.0) * 0.5, vec2(0.0), vec2(1.0));
    grid *= framesMinusOne;
    vec2 gridFloor = floor(grid);

    // \u8BA1\u7B97\u6DF7\u5408\u6743\u91CD
    quad_blend_weights = quadBlendWieghts(fract(grid));
    grid_classic = gridFloor;

    // \u8BA1\u7B97\u9876\u70B9\u7684\u65B0\u4F4D\u7F6E
    vec2 texcoord = uv * (1.0 / imposterFrames.x);
    vec2 size = vec2(scaleSize.xy);
    
    // \u4ECE\u7EB9\u7406\u56FE\u96C6\u5E27\u8BA1\u7B97\u65B9\u5411\u5411\u91CF
    vec3 projectedQuadARray = FrameXYToRay(gridFloor, framesMinusOne);
    vec3 projectedQuadBRray = FrameXYToRay(
        gridFloor + mix(vec2(0.0, 1.0), vec2(1.0, 0.0), quad_blend_weights.w), 
        framesMinusOne
    );
    vec3 projectedQuadCRray = FrameXYToRay(gridFloor + vec2(1.0), framesMinusOne);
    
    // \u6DF7\u5408\u65B9\u5411\u5411\u91CF
    vec3 projectedQuadRay = 
        projectedQuadARray * quad_blend_weights.x +
        projectedQuadBRray * quad_blend_weights.y +
        projectedQuadCRray * quad_blend_weights.z;
    
    // \u8BA1\u7B97\u6295\u5F71\u5750\u6807
    vec3 projected = SpriteProjection(
        normalize(toCamera), 
        imposterFrames.x, 
        size, 
        texcoord.xy
    );

    vec3 N = normalize(projectedQuadRay);
    vec3 T = normalize(cross(N, vec3(0.0, 1.0, 0.0)));
    vec3 B = normalize(cross(T, N));
    vTBN = transpose(mat3(T, B, N));

    vec3 transformed = projected;

    vec3 worldPositionVertex = (modelMatrix * translatedInstanceMatrix * vec4(position, 1.0)).xyz;
    vec3 toCameraFromPosition = normalize(cameraPosition - worldPositionVertex.xyz);
    vViewPosition = -toCameraFromPosition;

    #ifdef IS_GLOBE
        vWorldPosition = (modelMatrix * translatedInstanceMatrix * ecefMatrix * vec4(transformed, 1.0)).xyz;
        vCenterWorldPosition = (currentInstanceMatrix * ecefMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

        gl_Position = projectionMatrix * modelViewMatrix * translatedInstanceMatrix * ecefMatrix * vec4(transformed, 1.0);
    #else 
        vWorldPosition = (modelMatrix * translatedInstanceMatrix * vec4(transformed, 1.0)).xyz;
        vCenterWorldPosition = (currentInstanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;

        gl_Position = projectionMatrix * modelViewMatrix * translatedInstanceMatrix * vec4(transformed, 1.0);
    #endif

    vUv = uv;
    #include <logdepthbuf_vertex>
}`, fragmentShader$e = `#define GLSLIFY 1
#include <common>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

uniform vec2 imposterFrames;
uniform bool isTransparent;
uniform float alphaClamp;
uniform float depthScale;
uniform float normalmapDepth;
uniform vec3 color;
uniform float metallic;
uniform float roughness;
uniform float specular;
uniform mat3 normalMatrix;
uniform float worldPositionScale;

// \u989C\u8272\u53D8\u5316\u63A7\u5236\u53C2\u6570
uniform float colorVariationStrength; // \u989C\u8272\u53D8\u5316\u5F3A\u5EA6 (0.0-1.0)
uniform vec3 yellowTint;              // \u504F\u9EC4\u8272\u8C03 (\u9ED8\u8BA4: vec3(1.2, 1.1, 0.8))
uniform vec3 greenTint;               // \u504F\u7EFF\u8272\u8C03 (\u9ED8\u8BA4: vec3(0.8, 1.3, 0.9))
uniform vec3 darkTint;                // \u504F\u6697\u8272\u8C03 (\u9ED8\u8BA4: vec3(0.6, 0.7, 0.5))
uniform float gradientFalloff;

// \u7EB9\u7406
uniform sampler2D imposterBaseTexture;
uniform sampler2D imposterNormalDepthTexture;
uniform sampler2D imposterORMTexture;

varying vec3 vCameraViewPosition;

varying vec2 vUv;
varying vec2 grid_classic;
varying vec4 quad_blend_weights;
varying vec3 vViewPosition;
varying vec3 vWorldPosition;
varying vec3 vCenterWorldPosition;
varying mat3 vTBN;
varying mat4 vEcefMatrix;
varying mat3 vRotationMatrix;

// \u968F\u673A\u6570\u751F\u6210\u51FD\u6570
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

// \u57FA\u4E8E3D\u4F4D\u7F6E\u7684\u968F\u673A\u6570
float random3D(vec3 pos) {
    vec3 localPos = pos;

    #ifdef IS_GLOBE
        mat4 ecefMatrixInverse = inverse(vEcefMatrix);
        localPos = (ecefMatrixInverse * vec4(worldPos, 1.0)).xyz;
    #endif

    return random(localPos.xy);
}

// \u751F\u6210\u968F\u673A\u989C\u8272\u53D8\u5316
vec3 generateColorVariation(vec3 worldPos) {
    // \u4F7F\u7528\u4E16\u754C\u5750\u6807\u4F5C\u4E3A\u968F\u673A\u79CD\u5B50\uFF0C\u786E\u4FDD\u540C\u4E00\u4F4D\u7F6E\u7684\u6811\u989C\u8272\u4E00\u81F4
    vec3 seed = floor(worldPos * 10.0) * 0.1;
    
    float rand1 = random3D(seed);
    float rand2 = random3D(seed + vec3(1.0, 0.0, 0.0));
    float rand3 = random3D(seed + vec3(0.0, 1.0, 0.0));
    
    vec3 colorTint = vec3(1.0); // \u9ED8\u8BA4\u65E0\u53D8\u5316
    
    if (rand1 < 0.5) {
        // \u5927\u90E8\u5206\u504F\u7EFF\u8272
        colorTint = mix(vec3(1.0), greenTint, colorVariationStrength);
    } else if (rand1 < 0.75) {
        // \u504F\u9EC4\u8272
        colorTint = mix(vec3(1.0), yellowTint, colorVariationStrength);
    } else {
        // \u504F\u6697\u8272
        colorTint = mix(vec3(1.0), darkTint, colorVariationStrength);
    }
    
    vec3 microVariation = vec3(
        0.9 + rand2 * 0.2,  // 0.9 - 1.1
        0.9 + rand3 * 0.2,  // 0.9 - 1.1
        0.9 + random3D(seed + vec3(0.0, 0.0, 1.0)) * 0.2  // 0.9 - 1.1
    );

    // vec3 baseColorVariation = colorTint * microVariation;
    vec3 baseColorVariation = colorTint;
    return baseColorVariation;
}

// \u91C7\u6837\u5E76\u6DF7\u5408\u7EB9\u7406
vec4 blendedColor(vec2 uv, vec2 grid_pos, vec4 grid_weights, sampler2D atlasTexture) {
    vec4 res;
    vec2 quad_size = vec2(1.0) / imposterFrames;
    vec2 uv_quad_a = quad_size * grid_pos;
    uv_quad_a += uv / imposterFrames;

    vec2 uv_quad_b = uv_quad_a + quad_size * mix(
        vec2(0.0, 1.0), 
        vec2(1.0, 0.0), 
        quad_blend_weights.w
    );
    vec2 uv_quad_c = uv_quad_a + quad_size;

    vec4 quad_a = texture2D(atlasTexture, uv_quad_a);
    vec4 quad_b = texture2D(atlasTexture, uv_quad_b);
    vec4 quad_c = texture2D(atlasTexture, uv_quad_c);

    res = quad_a * grid_weights.x + quad_b * grid_weights.y + quad_c * grid_weights.z;
    return res;
}

void main() {
    
    vec3 toCamera = cameraPosition - vWorldPosition;
    #ifdef IS_GLOBE
        mat4 ecefMatrixInverse = inverse(vEcefMatrix);
        toCamera = (ecefMatrixInverse * vec4(toCamera, 0.0)).xyz;
    #endif
    toCamera = vRotationMatrix * toCamera;
    vec3 viewDir = normalize(vTBN * toCamera);
    
    // \u89C6\u5DEE\u6620\u5C04\u504F\u79FB
    vec2 base_uv = vUv;
    float depth = blendedColor(base_uv, grid_classic, quad_blend_weights, imposterNormalDepthTexture).a;
    base_uv -= vec2(viewDir.xy) / viewDir.z * ((depth) * depthScale * 2.0);
    
    // // \u91C7\u6837\u6DF7\u5408\u7EB9\u7406
    vec4 baseTex = blendedColor(base_uv, grid_classic, quad_blend_weights, imposterBaseTexture);

    if (baseTex.a < 0.5) {
        discard;
    }
    vec4 normalTex = blendedColor(base_uv, grid_classic, quad_blend_weights, imposterNormalDepthTexture);
    vec4 ormTex = blendedColor(base_uv, grid_classic, quad_blend_weights, imposterORMTexture);

    // \u5149\u7167\u8BA1\u7B97
    vec3 viewLightDir = directionalLights[0].direction;
    vec3 lightColor = directionalLights[0].color;
    float lightIntensity = 1.0;

    vec3 normalDir = normalTex.xyz;
    #ifdef IS_GLOBE
        normalDir = (ecefMatrixInverse * vec4(normalDir, 0.0)).xyz;
    #endif
    normalDir = normalMatrix * normalDir;

    // \u8BA1\u7B97\u6F2B\u53CD\u5C04\u5149\u7167
    float normalLightIntensity = max(dot(normalDir, normalize(viewLightDir)), 0.0);
    vec3 diffuseLight = normalLightIntensity * lightColor * lightIntensity;

    // \u73AF\u5883\u5149 (\u7B80\u5355\u5B9E\u73B0)
    vec3 ambientLight = 0.2 * lightColor;
    float vRounghness = ormTex.g * roughness;

    // \u8BA1\u7B97\u955C\u9762\u53CD\u5C04 (\u7B80\u5355Blinn-Phong\u6A21\u578B)
    vec3 viewDir1 = normalize(vViewPosition);
    vec3 halfVector = normalize(viewLightDir + viewDir1);
    #ifdef IS_GLOBE
        halfVector = (ecefMatrixInverse * vec4(halfVector, 0.0)).xyz;
    #endif
    float specularIntensity = max(dot(normalTex.xyz, halfVector), 0.0);
    vec3 specularLight = max(specularIntensity, 0.2) * lightColor * 0.3 * (1.0 - vRounghness);

    // \u57FA\u4E8E\u91D1\u5C5E\u5EA6\u548C\u7C97\u7CD9\u5EA6\u8C03\u6574\u6F2B\u53CD\u5C04\u548C\u955C\u9762\u53CD\u5C04
    vec3 baseColor = baseTex.rgb;
    vec3 diffuseContrib = baseColor * (1.0 - metallic);
    vec3 specularContrib = vec3(0.04) * specularLight;

    // \u7EC4\u5408\u6240\u6709\u5149\u7167\u8D21\u732E
    vec3 finalColor = (ambientLight + diffuseLight) * diffuseContrib + specularContrib;

    // \u5E94\u7528\u968F\u673A\u989C\u8272\u53D8\u5316
    vec3 colorVariation = generateColorVariation(vCenterWorldPosition / worldPositionScale);
    finalColor *= colorVariation;
    
    finalColor = clamp(finalColor, 0.0, 1.0);

    // // \u8F93\u51FA\u6700\u7EC8\u989C\u8272
    gl_FragColor = vec4(finalColor, baseTex.a);

    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment>
    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`, uniforms$h = UniformsUtils.merge([
  UniformsLib.lights,
  {
    imposterFrames: { value: new Vector2$1(16, 16) },
    positionOffset: { value: new Vector3$1(0, 0, 0) },
    isFullSphere: { value: !1 },
    isTransparent: { value: !1 },
    alphaClamp: { value: 0.5 },
    imposterScale: { value: 3 },
    depthScale: { value: 0.01 },
    normalmapDepth: { value: 1 },
    color: { value: new Color(1, 1, 1) },
    imposterBaseTexture: { value: null },
    imposterNormalDepthTexture: { value: null },
    imposterORMTexture: { value: null },
    metallic: { value: 0 },
    roughness: { value: 1 },
    specular: { value: 0.5 },
    colorVariationStrength: { value: 1 },
    yellowTint: { value: new Vector3$1(1.2, 1.1, 0.8) },
    greenTint: { value: new Vector3$1(0.8, 1.2, 0.9) },
    darkTint: { value: new Vector3$1(0.6, 0.7, 0.5) },
    gradientFalloff: { value: 1 },
    verticalGradientStrength: { value: 2 },
    worldPositionScale: { value: 2e3 },
    offsetZ: { value: 0 }
  }
]);
class OctahedralImpostorMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "OctahedralImpostorMaterial", this.vertexShader = vertexShader$g, this.fragmentShader = fragmentShader$e, this.side = DoubleSide, this.lights = !0, this.transparent = !1, defineMaterialNormalProperties(this, [
      "imposterScale",
      "imposterBaseTexture",
      "imposterNormalDepthTexture",
      "imposterORMTexture",
      "offsetZ"
    ]), defineMaterialBoolDefineProperties(this, [
      ["isGlobe", "IS_GLOBE"]
    ]), Object.assign(this.uniforms, UniformsUtils.clone(uniforms$h)), this.setValues(i);
  }
}
let _box3 = new Box3(), _sphere$1 = new Sphere(), _instanceLocalMatrix = new Matrix4(), _instanceWorldMatrix = new Matrix4(), _instancePositionMatrix = new Matrix4();
const _instanceMatrix = new Matrix4(), _rtcMatrix = new Matrix4(), _rotationMatrix = new Matrix4();
let _tempMatrix = new Matrix4(), _tempMesh = new Mesh(), _instanceIntersects = [], _vector3 = new Vector3$1(), _vector4$1 = new Vector4();
const scratchRotation = new Vector3$1(), rotationMatrixScratch$1 = new Matrix4(), positionScratch$3 = new Vector3$1(), _instanceEcefMatrix = new Matrix4();
class GeoInstancedMesh extends GeoObject {
  constructor(e, r, s) {
    super();
    _(this, "type", "InstancedMesh");
    _(this, "isMesh", !0);
    _(this, "isInstancedMesh", !0);
    _(this, "frustumCulled", !1);
    _(this, "instanceColor", null);
    _(this, "count", 0);
    _(this, "instanceMatrix");
    _(this, "morphTexture", null);
    _(this, "_enableInstanceColor", !1);
    _(this, "instanceMorphMatrix", new Matrix4());
    _(this, "isEventEntitySupported", !0);
    _(this, "boundingBox", null);
    _(this, "boundingSphere", null);
    _(this, "getInstanceLocalMatrix", (e, r, s, a) => null);
    _(this, "getEcefTransformMatrix", (e, r, s) => {
      const c = this.engine.map.isGlobe, l = new Matrix4();
      if (c) {
        const h = Transforms.eastNorthUpToFixedFrame(positionScratch$3.fromArray(e)), d = rotationMatrixScratch$1.extractRotation(h);
        l.multiply(d);
      }
      return l;
    });
    _(this, "addCustomAttributes", () => {
    });
    this.parameters = Object.assign({}, s), this.geometry = e, this.material = r, this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(0), 16);
  }
  set enableInstanceColor(e) {
    e !== this._enableInstanceColor && (this._enableInstanceColor = e, this.needsUpdate = !0);
  }
  get enableInstanceColor() {
    return this._enableInstanceColor;
  }
  collisionTest(e) {
    let r = this.material.keepSize ? this.size : 0;
    return {
      width: r,
      height: r
    };
  }
  _updateData() {
    const {
      visiblePropName: e = "visible",
      vertexVisible: r = !1
    } = this.parameters, s = this.engine.map.isGlobe;
    let a = [];
    this._enableCollision && this._collisionData ? a = this._collisionData : a = this.dataSource.userData;
    const c = [], l = [], h = [], d = [];
    let f = 1 / 0, p = 1 / 0, m = 1 / 0, y = -1 / 0, x = -1 / 0, v = -1 / 0;
    for (let E = 0; E < a.length; E++) {
      const b = a[E].position, [w, M, P = 0] = b;
      w < f && (f = w), w > y && (y = w), M < p && (p = M), M > x && (x = M), P < m && (m = P), P > v && (v = P);
    }
    let S = [(f + y) / 2, (p + x) / 2, (m + v) / 2 || 0];
    for (let E = 0; E < a.length; E++) {
      const b = a[E].position;
      a[E].index;
      const w = a[E][e];
      if (r && w === !1)
        continue;
      const M = this.dataSource.getDataItem(E), P = this.getInstanceLocalMatrix(b, M, E, a[E]);
      _rtcMatrix.makeTranslation(
        b[0] - S[0],
        b[1] - S[1],
        (b[2] || 0) - S[2]
      );
      const D = this.getEcefTransformMatrix(b, M, E);
      _instanceMatrix.identity(), this.constructor === GeoInstancedMesh && (_rotationMatrix.extractRotation(D), _instanceMatrix.multiplyMatrices(_instanceMatrix, _rotationMatrix)), P && _instanceMatrix.multiplyMatrices(_instanceMatrix, P), _instanceMatrix.multiplyMatrices(_rtcMatrix, _instanceMatrix);
      const L = _instanceMatrix.elements;
      if (c.push(
        L[0],
        L[1],
        L[2],
        L[3],
        L[4],
        L[5],
        L[6],
        L[7],
        L[8],
        L[9],
        L[10],
        L[11],
        L[12],
        L[13],
        L[14],
        L[15]
      ), s) {
        const O = D.elements;
        l.push(
          O[0],
          O[1],
          O[2],
          O[3],
          O[4],
          O[5],
          O[6],
          O[7],
          O[8],
          O[9],
          O[10],
          O[11],
          O[12],
          O[13],
          O[14],
          O[15]
        );
      }
      if (h.push(Math.random()), this._enableInstanceColor) {
        let O = colorToArr4(a[E].color);
        d.push(O[0], O[1], O[2]);
      }
    }
    s && this.geometry.setAttribute(
      "ecefMatrix",
      new InstancedBufferAttribute(new Float32Array(l), 16)
    ), this.geometry.setAttribute(
      "instancedRandomFactor",
      new InstancedBufferAttribute(new Float32Array(h), 1)
    ), this.addCustomAttributes(this.geometry, this.dataSource), this.geometry.computeBoundingSphere(), this.geometry.instanceCount = c.length / 16, this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(c), 16), this._enableInstanceColor && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(d), 3)), this.originCenter = new Vector3$1().fromArray(S), this.count = this.geometry.instanceCount, this.makeMeshPositionOffset(S), this.needsUpdate = !1;
  }
  setBufferData(e) {
    if (!e)
      return;
    const s = e.id.length;
    s !== 0 && (this.count = s, this.geometry.instanceCount = s, e.instanceMatrix ? this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(e.instanceMatrix), 16) : this.computeTempMatrix(e));
  }
  computeTempMatrix(e) {
    const r = this.engine.map.isGlobe;
    e.id;
    const s = e.translation, a = e.scale, c = e.rotation, l = [], h = [];
    let d = new Matrix4(), f = new Vector3$1(), p = new Vector3$1(), m = new Euler(), y = new Quaternion$1(), x = 1 / 0, v = 1 / 0, S = 1 / 0, E = -1 / 0, b = -1 / 0, w = -1 / 0;
    for (let P = 0; P < this.count; P++) {
      let D = P * 3;
      const L = s[D], O = s[D + 1], F = s[D + 2];
      L < x && (x = L), L > E && (E = L), O < v && (v = O), O > b && (b = O), F < S && (S = F), F > w && (w = F);
    }
    let M = [(x + E) / 2, (v + b) / 2, (S + w) / 2 || 0];
    for (let P = 0; P < this.count; P++) {
      let D = P * 3;
      a ? p.set(a[D], a[D + 1], a[D + 2]) : p.set(1, 1, 1), s ? f.set(
        s[D] - M[0],
        s[D + 1] - M[1],
        s[D + 2] - M[2]
      ) : f.set(0, 0, 0), scratchRotation.set(0, 0, 0), c && scratchRotation.set(c[D], c[D + 1], c[D + 2]);
      const L = [s[D], s[D + 1], s[D + 2]];
      if (r) {
        const k = this.getEcefTransformMatrix(L).elements;
        h.push(
          k[0],
          k[1],
          k[2],
          k[3],
          k[4],
          k[5],
          k[6],
          k[7],
          k[8],
          k[9],
          k[10],
          k[11],
          k[12],
          k[13],
          k[14],
          k[15]
        );
      }
      m.set(scratchRotation.x, scratchRotation.y, scratchRotation.z, "ZYX"), y.setFromEuler(m), d.compose(f, y, p), D = P * 16;
      const O = d.elements;
      for (let F = 0; F < 16; F++)
        l[D + F] = O[F];
    }
    r && this.geometry.setAttribute(
      "ecefMatrix",
      new InstancedBufferAttribute(new Float32Array(h), 16)
    ), this.geometry.computeBoundingSphere(), this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(l), 16), this.makeMeshPositionOffset(M);
  }
  computeBoundingBox() {
    const e = this.geometry, r = this.count;
    this.boundingBox === null && (this.boundingBox = new Box3()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let s = 0; s < r; s++)
      this.getMatrixAt(s, _instanceLocalMatrix), _box3.copy(e.boundingBox).applyMatrix4(_instanceLocalMatrix), this.boundingBox.union(_box3);
  }
  computeBoundingSphere() {
    const e = this.geometry, r = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let s = 0; s < r; s++)
      this.getMatrixAt(s, _instanceLocalMatrix), _sphere$1.copy(e.boundingSphere).applyMatrix4(_instanceLocalMatrix), this.boundingSphere.union(_sphere$1);
  }
  getMatrixAt(e, r) {
    r.fromArray(this.instanceMatrix.array, e * 16);
  }
  computeInstanceMorphMatrix(e) {
    const r = this.material;
    let s = r.height || 0;
    e = e || r.zoomUnits;
    let a = 1;
    if (r.keepSize && (a = e || 1), r.isUseSize3) {
      const c = r.size3;
      _vector3.set(c[0] * a, c[1] * a, c[2] * a);
    } else if (r.isUseSize2) {
      const c = r.size2;
      _vector3.set(c[0] * a, c[1] * a, a);
    } else {
      let c = r.size || 1;
      _vector3.set(c * a, c * a, c * a);
    }
    this.instanceMorphMatrix.identity().scale(_vector3).premultiply(_tempMatrix.identity().makeTranslation(0, 0, s * a));
  }
  getEntityByIndex(e) {
    const r = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const s = {
      index: e,
      value: r.getDataItem(e),
      itemIndex: r.getDataItemIndex(e),
      pairs: {}
    }, a = r.data;
    for (const c of Object.keys(a))
      s.pairs[c] = a[c][e];
    return s;
  }
  getPixelSize(e) {
    const { camera: r, rendering: s } = this.engine;
    return r.isOrthographicCamera ? s.uniforms.zoomUnits.value : 0.2 * r.projectionMatrix.elements[5] / s.resolution.y * r.position.distanceTo(e);
  }
  raycast(e, r) {
    if (!this.visible)
      return;
    let s = this.geometry, a = this.material, c = this.matrixWorld;
    const l = this.engine.map.isGlobe;
    if (!a || !s)
      return;
    const h = this.instanceMatrix;
    if (!h)
      return;
    const d = h.array;
    l || this.computeInstanceMorphMatrix();
    const f = this.count;
    if (_tempMesh.geometry = this.geometry.getInstanceGeometry ? this.geometry.getInstanceGeometry() : this.geometry, _tempMesh.material = a, a.isInstancedBallonMaterial) {
      const p = e.camera, m = a.resolution, y = e.mouse, x = a.size / m[0], v = a.size / m[1], S = (a.height + a.size / 2) * 2 / m[1], E = y.x - x, b = y.x + x, w = y.y - v - S, M = y.y + v - S;
      _tempMatrix.multiplyMatrices(p.matrixWorldInverse, c), _tempMatrix.multiplyMatrices(p.projectionMatrix, _tempMatrix);
      for (let P = 0; P < f; ++P)
        if (_instancePositionMatrix.fromArray(d, P * 16), _vector4$1.set(0, 0, 0, 1).applyMatrix4(_instancePositionMatrix).applyMatrix4(_tempMatrix).divideScalar(_vector4$1.w), _vector4$1.x >= E && _vector4$1.y >= w && _vector4$1.x <= b && _vector4$1.y <= M) {
          _vector3.set(
            _instancePositionMatrix.elements[12],
            _instancePositionMatrix.elements[13],
            _instancePositionMatrix.elements[14]
          );
          const D = e.ray.origin.distanceTo(_vector3);
          D >= e.near && D <= e.far && (_instanceIntersects[0] = {
            distance: D,
            point: _vector3.clone(),
            itemIndex: P,
            object: this
          }, r.push(_instanceIntersects[0]), _instanceIntersects.length = 0);
        }
    } else {
      let p = null;
      if (l) {
        const m = this.geometry.getAttribute("ecefMatrix");
        m && (p = m.array);
      }
      for (let m = 0; m < f; ++m) {
        if (_instanceWorldMatrix.fromArray(d, m * 16), l && p) {
          _instanceEcefMatrix.fromArray(p, m * 16);
          const y = _instancePositionMatrix.makeTranslation(
            _instanceWorldMatrix.elements[12],
            _instanceWorldMatrix.elements[13],
            _instanceWorldMatrix.elements[14]
          ), x = _instanceLocalMatrix.copy(_instanceWorldMatrix);
          x.elements[12] = 0, x.elements[13] = 0, x.elements[14] = 0, _instanceWorldMatrix.multiplyMatrices(y, _instanceEcefMatrix), _instanceWorldMatrix.multiply(x);
        }
        if (_instanceWorldMatrix.multiplyMatrices(c, _instanceWorldMatrix), l) {
          const y = _vector3.setFromMatrixPosition(_instanceWorldMatrix), x = this.getPixelSize(y);
          this.computeInstanceMorphMatrix(x);
        }
        _instanceWorldMatrix.multiply(this.instanceMorphMatrix), _tempMesh.matrixWorld = _instanceWorldMatrix, _tempMesh.raycast(e, _instanceIntersects), _instanceIntersects.length > 0 && (_instanceIntersects[0].instanceId = m, _instanceIntersects[0].object = this, r.push(_instanceIntersects[0]), _instanceIntersects.length = 0);
      }
    }
  }
}
const loader = new ImageBitmapLoader();
loader.setOptions({
  imageOrientation: "flipY",
  premultiplyAlpha: "none"
});
const je = class extends GeoInstancedMesh {
  constructor(e = {}) {
    super(e);
    _(this, "onBeforeSceneRender", () => {
      this.dataSource ? super.onBeforeSceneRender() : this.onBeforeScenePrepareRenderHook();
    });
    _(this, "getInstanceLocalMatrix", (e, r, s, a) => {
      const c = new Matrix4(), l = this._createRotationMatrix(a.rotation), h = this._createScaleMatrix(a.scale);
      return c.multiplyMatrices(h, l), c;
    });
    this.parameters = e, this.offsetZ = e.offsetZ || 0, this.modelDistance = e.modelDistance || 0, this.imposterScale = e.imposterScale || 3, this.hasLastResult = !1, this.lastCameraPosition = null, this._texturesInitialized = !1, this._geometryInitialized = !1, this.defineMaterialProxyProperties(["imposterScale"]);
  }
  static _getBitmap(e) {
    const r = this._bitmapPromises, s = r.get(e);
    if (s)
      return s;
    const a = new Promise((c, l) => {
      this.imageBitmapLoader.load(e, c, void 0, l);
    });
    return r.set(e, a), a;
  }
  static async initDefaultTextures() {
    if (!(this.defaultTextures.diffuse && this.defaultTextures.normalDepth && this.defaultTextures.orm)) {
      if (this._defaultTexturesPromise) {
        await this._defaultTexturesPromise;
        return;
      }
      this._defaultTexturesPromise = (async () => {
        const e = getAssetUrl("assets/textures/imposter/tree2/base.webp"), r = getAssetUrl("assets/textures/imposter/tree2/norm_depth.webp"), s = getAssetUrl("assets/textures/imposter/tree2/orm.webp"), { diffuseTexture: a, normalDepthTexture: c, ormTexture: l } = await je.createTextures(e, r, s);
        this.defaultTextures.diffuse = a, this.defaultTextures.normalDepth = c, this.defaultTextures.orm = l;
      })(), await this._defaultTexturesPromise;
    }
  }
  static async createTextures(e, r, s) {
    var m, y, x;
    const a = je;
    if (a[e] && a[r] && a[s])
      return {
        diffuseTexture: a[e],
        normalDepthTexture: a[r],
        ormTexture: a[s]
      };
    const [c, l, h] = await Promise.all([
      this._getBitmap(e),
      this._getBitmap(r),
      this._getBitmap(s)
    ]), d = (m = a[e]) != null ? m : (() => {
      const v = new Texture(c);
      return v.flipY = !0, v.colorSpace = SRGBColorSpace, v.wrapS = v.wrapT = ClampToEdgeWrapping, v.minFilter = v.magFilter = LinearFilter, v.needsUpdate = !0, a[e] = v, v;
    })(), f = (y = a[r]) != null ? y : (() => {
      const v = new Texture(l);
      return v.flipY = !0, v.needsUpdate = !0, a[r] = v, v;
    })(), p = (x = a[s]) != null ? x : (() => {
      const v = new Texture(h);
      return v.flipY = !0, v.needsUpdate = !0, a[s] = v, v;
    })();
    return {
      diffuseTexture: d,
      normalDepthTexture: f,
      ormTexture: p
    };
  }
  async initialize() {
    var e;
    await this.initTextures(), this._initImposter(), this._initModelInstances(), this.material.isGlobe = ((e = this.engine.map) == null ? void 0 : e.isGlobe) || !1, this._geometryInitialized = !0;
  }
  async initTextures() {
    if (!this._texturesInitialized) {
      if (this.parameters.diffuse && this.parameters.normalDepth && this.parameters.orm) {
        const { diffuseTexture: e, normalDepthTexture: r, ormTexture: s } = await je.createTextures(
          this.parameters.diffuse,
          this.parameters.normalDepth,
          this.parameters.orm
        );
        this.diffuseTexture = e, this.normalDepthTexture = r, this.ormTexture = s;
      } else
        await je.initDefaultTextures(), this.diffuseTexture = je.defaultTextures.diffuse, this.normalDepthTexture = je.defaultTextures.normalDepth, this.ormTexture = je.defaultTextures.orm;
      this._texturesInitialized = !0;
    }
  }
  _initImposter() {
    const { diffuse: e, normalDepth: r, orm: s, ...a } = this.parameters;
    this.geometry = new InstancedBillboardBufferGeometry(this.parameters), this.material = new OctahedralImpostorMaterial(a), this.material.imposterBaseTexture = this.diffuseTexture, this.material.imposterNormalDepthTexture = this.normalDepthTexture, this.material.imposterORMTexture = this.ormTexture;
  }
  _initModelInstances() {
    const { modelGeometry: e, modelMaterial: r } = this.parameters;
    e && r && (this.modelInstanceMesh = new GeoInstancedMesh(
      e,
      r
    ), this.modelDataSource = GeoJSONDataSource.fromGeoJSON([]), this.engine.add(this.modelInstanceMesh));
  }
  _updateData() {
    this.modelDistance <= 0 && this._updateBufferData();
  }
  _updateBufferData() {
    const r = this.engine.camera, a = this.dataSource.data, c = this.modelDistance, l = c * c;
    this.lastCameraPosition || (this.lastCameraPosition = r.position.clone(), this.hasLastResult = !1);
    const h = r.position.distanceTo(this.lastCameraPosition), d = c * 0.1;
    (h > d || !this.hasLastResult) && (this._partitionAndUpdateInstanceData(r, a, l), this.hasLastResult = !0, this.lastCameraPosition.copy(r.position));
  }
  _partitionAndUpdateInstanceData(e, r, s) {
    const a = [], c = [], l = [], h = [], d = [], f = [], p = [], m = [], y = r.position.length;
    for (let x = 0; x < y; x++) {
      const v = r.position[x];
      this._calculateSquareDistance(v, e.position) > s ? (a.push(...v), c.push(1, 1, 1), l.push(0, 0, 0), h.push("id_" + x)) : (d.push(...v), f.push(1, 1, 1), p.push(0, 0, 0), m.push("id_" + x));
    }
    this.setBufferData({
      translation: a,
      scale: c,
      rotation: l,
      id: h
    }), this.modelInstanceMesh && this.modelInstanceMesh.setBufferData({
      translation: d,
      scale: f,
      rotation: p,
      id: m
    });
  }
  _calculateSquareDistance(e, r) {
    return (e[0] - r.x) ** 2 + (e[1] - r.y) ** 2 + (e[2] - r.z) ** 2;
  }
  onBeforeScenePrepareRenderHook() {
    if (this.modelDistance <= 0)
      return;
    const { modelGeometry: e, modelMaterial: r } = this.parameters;
    e && r && this._updateBufferData();
  }
  _createRotationMatrix(e) {
    const r = new Matrix4();
    return typeof e == "number" ? r.makeRotationZ(e) : Array.isArray(e) ? r.makeRotationFromEuler(new Euler(e[1], e[2], e[3])) : e instanceof Vector3$1 && r.makeRotationFromEuler(new Euler(e.x, e.y, e.z)), r;
  }
  _createScaleMatrix(e) {
    const r = new Matrix4();
    return typeof e == "number" ? r.makeScale(e, e, e) : Array.isArray(e) ? r.makeScale(e[0], e[1], e[2]) : e instanceof Vector3$1 && r.makeScale(e.x, e.y, e.z), r;
  }
};
let OctahedralImpostor = je;
_(OctahedralImpostor, "imageBitmapLoader", loader), _(OctahedralImpostor, "defaultTextures", {
  diffuse: null,
  normalDepth: null,
  orm: null
}), _(OctahedralImpostor, "_defaultTexturesPromise", null), _(OctahedralImpostor, "_bitmapPromises", /* @__PURE__ */ new Map());
const ANCHOR = ["bottom", "left", "top", "right", "center"];
function decodeColor(o) {
  const i = o >> 24 & 255, e = o >> 16 & 255, r = o >> 8 & 255, s = (o & 255) / 255;
  return [i, e, r, s];
}
function getMercatorScaleFactor(o) {
  return 1 / Math.cos(Math.PI * o / 180);
}
let _tempPointScratch = [], _scaleFactorScratch = 1;
class TileInstancedElementManager {
  constructor() {
    _(this, "_lastUpdateTime", 0);
    _(this, "_updateDelayTimerHander", null);
    _(this, "_configVersion", 0);
    _(this, "_poiConfigVersion", 0);
    _(this, "_poiConfig", {
      poi: {
        enabled: !0
      },
      label: {
        enabled: !0
      }
    });
    _(this, "_config", {
      tree: {
        enabled: !1,
        isFoliage: !0,
        isBox: !1,
        scaleByZ: !1,
        instances: [{
          subtype: "shrub",
          diffuseTexture: getAssetUrl("assets/textures/imposter/tree3/base.webp"),
          normalDepthTexture: getAssetUrl("assets/textures/imposter/tree3/norm_depth.webp"),
          ormTexture: getAssetUrl("assets/textures/imposter/tree3/orm.webp"),
          imposterScale: 1,
          uvOffset: -0.2
        }, {
          subtype: "arbor",
          diffuseTexture: getAssetUrl("assets/textures/imposter/tree2/base.webp"),
          normalDepthTexture: getAssetUrl("assets/textures/imposter/tree2/norm_depth.webp"),
          ormTexture: getAssetUrl("assets/textures/imposter/tree2/orm.webp"),
          imposterScale: 5,
          uvOffset: 0
        }, {
          subtype: "0",
          imposterScale: 5,
          uvOffset: 0
        }, {
          subtype: "1",
          imposterScale: 5,
          uvOffset: 0
        }, {
          subtype: "2",
          imposterScale: 5,
          uvOffset: 0
        }, {
          subtype: "3",
          imposterScale: 5,
          uvOffset: 0
        }]
      }
    });
    _(this, "_labelEnabled", !1);
    _(this, "_poiEnabled", !1);
    _(this, "_generateModelMesh", async (i) => new Promise((e, r) => {
      gltfLoader.load(i, (s) => {
        const a = parseScene(s.scene, !1, !0);
        e(a);
      }, null, r);
    }));
    _(this, "markNeedsUpdate", () => {
      this._updateDelayTimerHander || (this._updateDelayTimerHander = setTimeout(() => {
        this.engine.requestRender(), this._updateDelayTimerHander = null;
      }, 100));
    });
    _(this, "remapBatchValueToNumber", (i) => i ? isFinite(i) ? (i = Math.round(i % 100), i) : typeof i == "string" ? (i = i.charCodeAt(3) || 0, i % 100) : 0 : 0);
    _(this, "parseBatchTableAttribute", (i, e, r) => {
      const s = i.cached.scene, a = [], c = s.batchTable && s.batchTable.header;
      if (!c)
        return;
      const l = c[e];
      if (!!l) {
        s.traverse((h) => {
          h.isMesh && a.push(h);
        });
        for (const h of a) {
          if ("type" in h.geometry.userData && "subtype" in h.geometry.userData)
            continue;
          const d = h.geometry, f = d.getAttribute("_batchid");
          if (!f)
            continue;
          const p = f.data.count;
          let m = -1, y = 0;
          const x = [];
          for (let v = 0; v < p; v++)
            m = f.getX(v), y = this.remapBatchValueToNumber(l[m]), x.push(y);
          d.attributes[r] = new BufferAttribute(new Float32Array(x), 1);
        }
      }
    });
    _(this, "parsePOIData", (i, e, r, s = "default") => {
      const c = e.content.batchTable.header.dataType, l = i.geometry, h = e.__id, d = l.attributes.position, f = l.attributes.angle, p = l.attributes.rank, m = l.attributes._batchid, y = d.count;
      if (y === 0)
        return;
      const x = e.cached.scene.matrix, v = [], S = new Vector3$1(), E = r.detail, b = defaultValue$1(E.direction, 4), w = ANCHOR[b], M = E.styleid, P = this.style[M] || {}, D = defaultValue$1(P.font_size, 16), L = P.font_rgba ? decodeColor(P.font_rgba) : [0, 0, 0, 1], O = P.halo_rgba ? decodeColor(P.halo_rgba) : [255, 255, 255, 1], F = defaultValue$1(P.halo_size, 0), k = defaultValue$1(P.fontWeight, "400"), V = P.icon, N = P.icon_hover;
      let U = E.name || "";
      U = U.replace(/\\n/g, "\\");
      for (let z = 0; z < y; z++) {
        S.set(d.getX(z), d.getY(z), d.getZ(z)), S.applyMatrix4(x);
        const $ = m.getX(z), G = c[$], j = {
          id: `${h}-${S.x},${S.y},${S.z}-${z}`,
          position: [S.x, S.y, S.z],
          crs: this.engine.map.projectionName,
          dataType: G,
          forceProjected: !0,
          isCustom: !0
        };
        if (V && (j.mapSrc = this.getIconUrl(V), j.hoverIcon = this.getIconUrl(N)), P.font_rgba && (j.text = U, j.textFillStyle = L, j.textStrokeStyle = O, j.textStrokeWidth = F, j.textSize = D, j.textAnchor = w, j.textWeight = k), f) {
          const Y = f.getX(z);
          j.flat = !0, j.rotateZ = Math.PI / 2 - MathUtils.degToRad(Y);
        }
        if (p) {
          const Y = p.getX(z);
          j.rank = Y;
        }
        v.push(j);
      }
      e[`__POIData_${s}`] = v;
    });
    _(this, "parseLabelData", (i, e) => {
      const r = i.geometry, s = e.__id, a = r.attributes.position, c = a.count;
      if (c === 0)
        return;
      const l = r.attributes.rotation, h = e.cached.scene, d = h.matrix, f = h.batchTable.header.text, p = h.batchTable.header.rank, m = [], y = new Vector3$1();
      for (let x = 0; x < c; x++)
        y.set(a.getX(x), a.getY(x), a.getZ(x)), y.applyMatrix4(d), m.push({
          id: s + "-" + x,
          type: "text_flat",
          position: [y.x, y.y, y.z],
          text: f[x],
          rotateZ: l.getZ(x),
          rank: p && p[x] || 0
        });
      e.__labelData = m;
    });
    _(this, "onTileLoad", (i, e) => {
      this.refreshTile(i);
    });
    _(this, "onTileDispose", (i, e) => {
      this.resetTile(i);
    });
    _(this, "onTileShow", (i) => {
      if (i.__instanceInfo) {
        const e = i.__instanceInfo;
        Object.keys(e).forEach((r) => {
          const s = e[r];
          s.model && (s.model.visible = !0, this.markNeedsUpdate());
        });
      }
      for (const [e, r] of Object.entries(this._poiConfig)) {
        if (!r.enabled)
          continue;
        const s = i[`__POIData_${e}`], a = `__hasAddPOIData_${e}`;
        s && !i[a] && (this.addLabels(s), i.__visible ? i[a] = !0 : (this.removeLabels(s), i[a] = !1));
      }
    });
    _(this, "onTileHide", (i) => {
      if (i.__instanceInfo) {
        const e = i.__instanceInfo;
        Object.keys(e).forEach((r) => {
          const s = e[r];
          s.model && (s.model.visible = !1, this.markNeedsUpdate());
        });
      }
      for (const e of Object.keys(this._poiConfig)) {
        const r = i[`__POIData_${e}`], s = `__hasAddPOIData_${e}`;
        r && i[s] && (this.removeLabels(r), i[s] = !1);
      }
    });
    _(this, "resetTile", (i) => {
      if (i.__instanceConfigVersion = null, i.__instanceInfo && (Object.keys(i.__instanceInfo).forEach((e) => {
        const r = i.__instanceInfo[e];
        r.model && (this.group.remove(r.model), r.model.dispose());
      }), delete i.__instanceInfo), i.__labelData && i.__hasAddLabelData) {
        const e = i.__labelData;
        this.engine.rendering.label.removeLabels(e, i.__lodLevel), i.__hasAddLabelData = !1;
      }
      for (const e of Object.keys(this._poiConfig)) {
        const r = i[`__POIData_${e}`], s = `__hasAddPOIData_${e}`;
        r && i[s] && (this.removeLabels(r), i[s] = !1);
      }
    });
    _(this, "refreshTile", (i) => {
      var a;
      const e = i.cached.scene, r = [];
      if (i.__instanceConfigVersion !== this._configVersion) {
        e.traverse((c) => {
          c.isMesh && r.push(c);
        });
        for (const c of r)
          if (c.isMesh && "type" in c.geometry.userData && "subtype" in c.geometry.userData) {
            c.visible = !1;
            const { type: l, subtype: h } = c.geometry.userData, d = this.getInstanceCollectionConfig(l);
            if (!d)
              continue;
            const f = this.getInstanceConfig(l, h);
            if (!f)
              continue;
            i.__instanceInfo || (i.__instanceInfo = {}), d.enabled && this.createInstanceComponent(c, i, d, f);
          } else if (c.isMesh && "type" in c.geometry.userData && "detail" in c.geometry.userData) {
            const { type: l, detail: h } = c.geometry.userData, d = {
              type: l,
              detail: JSON.parse(h)
            };
            i.__instanceInfo || (i.__instanceInfo = {}), ((a = this._poiConfig[l]) == null ? void 0 : a.enabled) && this.style && this.parsePOIData(c, i, d, l);
          } else
            c._rawMaterialName === "_label" && (c.visible = !1, this._labelEnabled && !i.__instanceLabelParsed && (this.parseLabelData(c, i), i.__instanceLabelParsed = !0));
        i.__instanceConfigVersion = this._configVersion;
      }
      const s = i.__labelData;
      s && (this._labelEnabled && !i.__hasAddLabelData && (this.engine.rendering.label.addLabels(s, i.__lodLevel), i.__hasAddLabelData = !0), !this._labelEnabled && i.__hasAddLabelData && (this.engine.rendering.label.removeLabels(s, i.__lodLevel), i.__hasAddLabelData = !1));
      for (const [c, l] of Object.entries(this._poiConfig)) {
        const h = i[`__POIData_${c}`], d = `__hasAddPOIData_${c}`;
        !i.__visible || (h && l.enabled && !i[d] && (this.addLabels(h), i.__visible ? i[d] = !0 : (this.engine.rendering.label.removeLabels(h), i[d] = !1)), h && !l.enabled && i[d] && (this.engine.rendering.label.removeLabels(h), i[d] = !1));
      }
    });
    _(this, "refreshTiles", () => {
      this.tilesRenderer.forEachLoadedModel((i, e) => {
        !e.__visible || (this.resetTile(e), this.refreshTile(e));
      }), this.engine.requestRender();
    });
    _(this, "getLabelType", (i) => {
      let e = i.type;
      const r = i.flat;
      let s = !1, a = !1;
      if (i.text && (s = !0), i.mapSrc) {
        const { width: c, height: l } = i;
        i.icon = i.mapSrc, i.iconSize = [c || 32, l || 32], a = !0;
      }
      return s && a ? e = "icon_text" : s ? e = r ? "text_flat" : "text_fix" : a && (e = r ? "icon_flat" : "icon"), e;
    });
    this.group = new Group(), this.group.isInstancedElementManager = !0, this._modelMeshSingleton = new PromisedSingleton(), this._modelMeshSingleton.generate = this._generateModelMesh, this._hiddenDataTypes = /* @__PURE__ */ new Set();
  }
  getIconUrl(i) {
    return this.tilesRenderer._rootPath + i + "@2x.png";
  }
  async createInstanceComponent(i, e, r, s) {
    const a = i.geometry, c = e.__id, l = a.attributes.position, h = l.count;
    if (h === 0)
      return;
    const d = r.type, f = s.subtype, p = d + "-" + f, m = s.itemScale || 1, y = s.zOffset || 0;
    let x;
    if (d === "tree")
      x = new OctahedralImpostor({
        diffuse: s.diffuseTexture,
        normalDepth: s.normalDepthTexture,
        orm: s.ormTexture,
        offsetZ: s.uvOffset,
        imposterScale: s.imposterScale
      });
    else {
      const O = await this._modelMeshSingleton.get(s.modelPath);
      x = new InstancedModel(O, h);
    }
    x.afterAddToEngine && x.afterAddToEngine(this.engine), d === "tree" && await x.initialize();
    const v = [], S = a.attributes.scale, E = a.attributes.rotation, b = new Array(3 * h), w = new Float32Array(3 * h), M = new Float32Array(3 * h), P = e.cached.scene.matrix, D = new Vector3$1();
    for (let O = 0; O < h; O++)
      D.set(l.getX(O), l.getY(O), l.getZ(O)), D.applyMatrix4(P), this.engine.isGlobe || (_tempPointScratch = this.engine.map.unprojectArrayCoordinate([D.x, D.y, D.z]), _scaleFactorScratch = getMercatorScaleFactor(_tempPointScratch[1])), b[3 * O] = D.x, b[3 * O + 1] = D.y, b[3 * O + 2] = D.z + y, w[3 * O] = S.getX(O) * m * _scaleFactorScratch, w[3 * O + 1] = S.getY(O) * m * _scaleFactorScratch, w[3 * O + 2] = S.getZ(O) * m, M[3 * O] = E.getZ(O) / 180 * Math.PI, M[3 * O + 1] = -E.getY(O) / 180 * Math.PI, M[3 * O + 2] = E.getX(O) / 180 * Math.PI, v.push(c + "-" + O);
    const L = {
      translation: b,
      scale: w,
      rotation: M,
      id: v
    };
    x.setBufferData(L), x.needsUpdate = !0, x.__originalMesh = i, e.__instanceInfo[p] = {
      model: x,
      data: L
    }, this.group.add(x), x.visible = e.__visible;
  }
  getInstanceCollectionConfig(i) {
    if (defined$2(this._config[i]))
      return {
        type: i,
        ...this._config[i]
      };
    warnOnce("TileInstancedElementManager: no config for type " + i);
  }
  setInstanceCollectionConfig(i, e) {
    return this._config[i] ? this._config[i] = {
      ...this._config[i],
      ...e
    } : this._config[i] = e, this._configVersion++, this.refreshTiles(), this;
  }
  getInstanceConfig(i, e) {
    if (this._config[i]) {
      let r = this._config[i].instances;
      for (let s = 0; s < r.length; s++) {
        const a = r[s];
        if (String(a.subtype) === String(e))
          return a;
      }
      warnOnce("TileInstancedElementManager: no config for type " + i + " subtype " + e);
    } else
      warnOnce("TileInstancedElementManager: no config for type " + i);
  }
  setInstanceConfig(i, e, r) {
    if (this._config[i]) {
      let s = this._config[i].instances, a = !0;
      for (let c = 0; c < s.length; c++) {
        const l = s[c];
        if (String(l.subtype) === String(e)) {
          s[c] = {
            ...l,
            ...r
          }, a = !1;
          break;
        }
      }
      a && this._config[i].instances.push({
        ...r,
        subtype: e
      }), this._configVersion++, this.refreshTiles();
    }
    return this;
  }
  _getLabelInstance(i) {
    if (i === "icon") {
      if (this._icon)
        return this._icon;
      const e = this._icon = this.engine.rendering.add(new Label({
        type: "icon",
        vertexIcons: !0,
        isRenderInPostprocess: !1
      })), r = new DataSource();
      return r.defineAttributes({
        id: "id",
        icon: "icon",
        iconSize: "iconSize",
        boundingBox: "boundingBox",
        offset: "offset",
        checkVisible: "checkVisible",
        tolerance: "tolerance"
      }), e.dataSource = r, this.engine.rendering.collision.add(e, { margin: [0, 0] }, "tiles_poi"), e;
    } else if (i === "text_fix") {
      if (this._text)
        return this._text;
      const e = this._text = this.engine.rendering.add(new Label({
        type: "text",
        isRenderInPostprocess: !1,
        flat: !1
      })), r = new DataSource();
      return r.defineAttributes({
        id: "id",
        text: "text",
        textSize: "textSize",
        textFillStyle: "textFillStyle",
        textStrokeStyle: "textStrokeStyle",
        textStrokeWidth: "textStrokeWidth",
        textWeight: "textWeight",
        textAnchor: "textAnchor",
        boundingBox: "boundingBox",
        offset: "offset",
        checkVisible: "checkVisible",
        tolerance: "tolerance"
      }), e.dataSource = r, this.engine.rendering.collision.add(e, { margin: [0, 0] }, "tiles_poi"), e;
    } else if (i === "icon_text") {
      if (this._hoverIcon)
        return this._hoverIcon;
      const e = this._icontext = this.engine.rendering.add(new Label({
        type: "icontext",
        vertexIcons: !0,
        enableFade: !0,
        useIconScale: !0,
        fadeDuration: 100,
        isRenderInPostprocess: !0
      })), r = new DataSource();
      r.defineAttributes({
        id: "id",
        text: "text",
        textSize: "textSize",
        textFillStyle: "textFillStyle",
        textStrokeStyle: "textStrokeStyle",
        textStrokeWidth: "textStrokeWidth",
        textWeight: "textWeight",
        textAnchor: "textAnchor",
        textDrawOnIcon: "textDrawOnIcon",
        icon: "icon",
        iconSize: "iconSize",
        direction: "direction",
        rotateZ: "rotateZ",
        boundingBox: "boundingBox",
        offset: "offset",
        checkVisible: "checkVisible",
        tolerance: "tolerance"
      }), e.dataSource = r;
      const s = this._hoverIcon = this.engine.rendering.add(new Label({
        type: "icon",
        vertexIcons: !0,
        isRenderInPostprocess: !1,
        useIconScale: !0
      })), a = new DataSource();
      a.defineAttributes({
        id: "id",
        text: "text",
        textSize: "textSize",
        textFillStyle: "textFillStyle",
        textStrokeStyle: "textStrokeStyle",
        textStrokeWidth: "textStrokeWidth",
        textWeight: "textWeight",
        textAnchor: "textAnchor",
        textDrawOnIcon: "textDrawOnIcon",
        icon: "icon",
        hoverIcon: "hoverIcon",
        iconSize: "iconSize",
        direction: "direction",
        rotateZ: "rotateZ",
        boundingBox: "boundingBox",
        offset: "offset",
        checkVisible: "checkVisible",
        tolerance: "tolerance"
      }), s.dataSource = a, this.engine.rendering.collision.add(s, { margin: [0, 0] }, "tiles_poi");
      const c = (l) => {
        e.dataSource.clear();
        const h = l.entity;
        if (h && h.value) {
          const d = h.value, f = JSON.parse(JSON.stringify(d.attributes)), p = h.pairs, m = f.hoverIcon, y = {
            ...f,
            forceProjected: !0,
            position: p.position,
            mapSrc: m,
            width: 35
          };
          this.addLabel(y, e), e.dataSource.needsUpdate = !0;
        }
      };
      return s.addEventListener("mouseenter", c), s.addEventListener("mousemove", c), s.addEventListener("mouseleave", (l) => {
        e.dataSource.clear(), e.dataSource.needsUpdate = !0;
      }), s;
    } else if (i === "text_flat") {
      if (this._textFlat)
        return this._textFlat;
      const e = this._textFlat = this.engine.rendering.add(new Label({
        type: "text",
        isRenderInPostprocess: !1,
        flat: !0
      })), r = new DataSource();
      return r.defineAttributes({
        id: "id",
        text: "text",
        textSize: "textSize",
        textFillStyle: "textFillStyle",
        textStrokeStyle: "textStrokeStyle",
        textStrokeWidth: "textStrokeWidth",
        textAnchor: "textAnchor",
        textWeight: "textWeight",
        rotateZ: "rotateZ",
        boundingBox: "boundingBox",
        checkVisible: "checkVisible",
        tolerance: "tolerance"
      }), e.dataSource = r, this.engine.rendering.collision.add(e, { margin: [20, 20] }, "tiles_label"), e;
    }
  }
  addLabels(i) {
    if (i.length !== 0)
      for (let e = 0; e < i.length; e++) {
        const r = i[e], s = r.dataType;
        this._hiddenDataTypes.has(s) || this.addLabel(r);
      }
  }
  removeLabels(i) {
    for (let e = 0; e < i.length; e++) {
      const r = i[e], s = this.getLabelType(r);
      this._getLabelInstance(s).dataSource.remove(r);
    }
  }
  addLabel(i, e) {
    const r = this.getLabelType(i), s = e || this._getLabelInstance(r), { position: a, forceProjected: c, ...l } = i, h = new DataItem(a, l, c);
    s.dataSource.add(h);
  }
  removeLabel(i, e) {
    const r = this.getLabelType(i);
    (e || this._getLabelInstance(r)).dataSource.remove(i);
  }
  setPoiConfig(i) {
    return this._poiConfig = {
      ...this._poiConfig,
      ...i
    }, this._poiConfigVersion++, this.refreshTiles(), this;
  }
  getPoiConfig() {
    return { ...this._poiConfig };
  }
  enablePoiType(i) {
    return this._poiConfig[i] || (this._poiConfig[i] = {}), this._poiConfig[i].enabled = !0, this._poiConfigVersion++, this.refreshTiles(), this;
  }
  disablePoiType(i) {
    return this._poiConfig[i] || (this._poiConfig[i] = {}), this._poiConfig[i].enabled = !1, this._poiConfigVersion++, this.refreshTiles(), this;
  }
  togglePoiType(i) {
    this._poiConfig[i] || (this._poiConfig[i] = { enabled: !1 });
    const e = !this._poiConfig[i].enabled;
    return this._poiConfig[i].enabled = e, this._poiConfigVersion++, this.refreshTiles(), e;
  }
  isPoiTypeEnabled(i) {
    var e;
    return ((e = this._poiConfig[i]) == null ? void 0 : e.enabled) || !1;
  }
  getAvailablePoiTypes() {
    return Object.keys(this._poiConfig);
  }
  hideDataType(i) {
    return this._hiddenDataTypes.add(i), this.refreshTiles(), this;
  }
  showDataType(i) {
    return this._hiddenDataTypes.delete(i), this.refreshTiles(), this;
  }
  toggleDataType(i) {
    return this._hiddenDataTypes.has(i) ? (this._hiddenDataTypes.delete(i), this.refreshTiles(), !0) : (this._hiddenDataTypes.add(i), this.refreshTiles(), !1);
  }
  isDataTypeVisible(i) {
    return !this._hiddenDataTypes.has(i);
  }
  getHiddenDataTypes() {
    return Array.from(this._hiddenDataTypes);
  }
  set config(i) {
    this._config = i, this._configVersion++, this.refreshTiles();
  }
  get config() {
    return this._config;
  }
  set labelEnabled(i) {
    this._labelEnabled = i, this._configVersion++, this.refreshTiles();
  }
  get labelEnabled() {
    return this._labelEnabled;
  }
  set poiEnabled(i) {
    this._poiEnabled = i, this._configVersion++, this.refreshTiles();
  }
  get poiEnabled() {
    return this._poiEnabled;
  }
  set poiConfig(i) {
    this.setPoiConfig(i);
  }
  get poiConfig() {
    return this.getPoiConfig();
  }
}
class EditableElementManager {
  constructor() {
    _(this, "_configVersion", 0);
    _(this, "_deletedIds", /* @__PURE__ */ new Set());
    _(this, "_needsRefreshAll", !1);
    _(this, "updateEditableAttribute", (i) => {
      const e = i.cached.scene;
      e.children;
      const r = e.batchTable && e.batchTable.header;
      if (!r)
        return;
      const s = r.id;
      if (!s)
        return;
      const a = "_tileEditableValue", c = this._deletedIds;
      e.traverse((l) => {
        if (l.geometry) {
          const h = l.geometry, d = h.getAttribute("_batchid");
          if (!d)
            return;
          const f = d.array.length;
          let p = -1, m = 0;
          const y = [];
          for (let x = 0; x < f; x++)
            p = d.getX(x), m = s[p] + "", c.has(m) || this.shouldBeHidden(r, p) ? y.push(1) : y.push(0);
          h.attributes[a] = new BufferAttribute(new Float32Array(y), 1);
        }
      });
    });
    _(this, "shouldBeHidden", (i, e) => !1);
    _(this, "onTileLoad", (i, e) => {
      i.__editableConfigVersion = 0;
    });
    _(this, "onTileDispose", (i, e) => {
    });
    _(this, "onTileShow", (i) => {
      this.refreshTile(i);
    });
    _(this, "onTileHide", (i) => {
    });
    _(this, "refreshTile", (i) => {
      i.__editableConfigVersion !== this._configVersion && (this.updateEditableAttribute(i), i.__editableConfigVersion = this._configVersion);
    });
    _(this, "refreshTiles", () => {
      !this._needsRefreshAll || this.tilesRenderer.forEachLoadedModel((i, e) => {
        !e.__visible || this.refreshTile(e);
      });
    });
  }
  addDeletedId(i) {
    i = i + "", this._deletedIds.add(i), this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
  addDeletedIds(i) {
    for (let e = 0; e < i.length; e++) {
      const r = i[e] + "";
      this._deletedIds.add(r);
    }
    this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
  removeDeletedId(i) {
    i = i + "", this._deletedIds.delete(i), this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
  removeDeletedIds(i) {
    for (let e = 0; e < i.length; e++) {
      const r = i[e] + "";
      this._deletedIds.delete(r);
    }
    this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
  hasDeletedId(i) {
    return this._deletedIds.has(i);
  }
  requestUpdate() {
    this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
}
const scratchPositionWC = new Vector3$1();
new Matrix4();
const scratchHalfHeight = new Vector3$1(), scratchCenter = new Vector3$1(), X_AXIS = new Vector3$1(1, 0, 0), Y_AXIS = new Vector3$1(0, 1, 0), _infoPosition = new Vector3$1(), _infoDelta = new Vector3$1(), PLUGIN_REGISTERED = Symbol("PLUGIN_REGISTERED"), Axis = {
  X: 0,
  Y: 1,
  Z: 2
};
Axis.fromName = function(o) {
  return Axis[o];
};
const scratchCartographic = new Vector3$1(), scratchPositionNormal = new Vector3$1(), scratchPosition = new Vector3$1(), scratchDirection = new Vector3$1(), _emptyFunction = () => {
};
function updateDynamicScreenSpaceError(o, i, e) {
  let r, s, a, c, l;
  const h = o._root, d = h.boundingVolume, f = o.getCamera(), p = o._cameraInfo, m = e.map.isGlobe;
  if (defined$2(h.boundingVolume.regionObb)) {
    m ? r = Cartesian3.normalize(f.position, scratchPositionNormal) : r = Cartesian3.UNIT_Z, s = p.directionWC, a = p.positionCartographic.z;
    const w = h.boundingVolume.regionObb.box, { min: M, max: P } = w;
    c = M.z, l = P.z;
  } else {
    const w = h.computedTransform.clone().invert(), M = e.map.map._ellipsoid || Ellipsoid.WGS84, P = d.obb, D = h.boundingVolumeCenter, L = StaticMatrix4.multiplyByPoint(
      w,
      D,
      scratchCenter
    );
    if (Cartesian3.magnitude(L) > M.minimumRadius && m) {
      const O = Cartographic.fromCartesian(
        L,
        M,
        scratchCartographic
      );
      r = Cartesian3.normalize(f.position, scratchPositionNormal), s = p.directionWC, a = p.positionCartographic.z, c = 0, l = O.z * 2;
    } else {
      scratchPositionWC.copy(f.position);
      const O = StaticMatrix4.multiplyByPoint(
        w,
        scratchPositionWC,
        scratchPosition
      );
      if (r = Cartesian3.UNIT_Z, s = StaticMatrix4.multiplyByPointAsVector(
        w,
        p.directionWC,
        scratchDirection
      ), s = Cartesian3.normalize(s, s), a = O.z, defined$2(P)) {
        const V = StaticMatrix3.getColumn(
          P.halfAxes,
          2,
          scratchHalfHeight
        ).length();
        c = L.z - V, l = L.z + V;
      } else {
        const V = h.boundingVolume.sphere.radius;
        c = L.z - V, l = L.z + V;
      }
    }
  }
  const x = o.dynamicScreenSpaceErrorHeightFalloff, v = c + (l - c) * x, S = l * o.dynamicScreenSpaceHeightScale, E = MathUtils.clamp(
    (a - v) / (S - v),
    0,
    1
  );
  let b = 1 - Math.abs(Cartesian3.dot(s, r));
  b = b * (1 - E), o._dynamicScreenSpaceErrorComputedDensity = o.dynamicScreenSpaceErrorDensity * b;
}
async function processMetadataExtension(o, i) {
  const e = hasExtension(i, "3DTILES_metadata") ? i.extensions["3DTILES_metadata"] : i;
  let r;
  if (defined$2(e.schemaUri))
    o = o.getDerivedResource({
      url: e.schemaUri
    }), r = ResourceCache.getSchemaLoader({
      schema: e.schema
    });
  else if (defined$2(e.schema))
    r = ResourceCache.getSchemaLoader({
      schema: e.schema
    });
  else
    return;
  await r.load();
  const s = new Cesium3DTilesetMetadata({
    schema: r.schema,
    metadataJson: e
  });
  return ResourceCache.unload(r), s;
}
const Cesium3DTileRefine = {
  ADD: 0,
  REPLACE: 1
}, Pe = class extends Object3D {
  constructor(e) {
    super();
    _(this, "isEventEntitySupported", !0);
    _(this, "is3DTiles", !0);
    _(this, "_needsRefreshAllLoadedTiles", !1);
    _(this, "_freezeUpdate", !1);
    _(this, "_forceUnlit", !1);
    _(this, "handleBeforeRender", (e) => {
      if (this._needsRefreshAllLoadedTiles && (this._needsRefreshAllLoadedTiles = !1, this.traversalLoadedTile((s, a) => {
        this._refreshTileInfo(a);
      })), this._freezeUpdate || !this.visible)
        return;
      const r = e.rendering.renderState;
      this._elementsManager && this._elementsManager.tick(r.time), this.prePassesUpdate(r), this.update(r), this.postPassesUpdate(r), this._editableElementManager.refreshTiles();
    });
    _(this, "_isInstancedElement", (e) => {
      let r = e;
      for (; r; ) {
        if (r.isInstancedElementManager)
          return !0;
        if (r.is3DTiles)
          return !1;
        r = r.parent;
      }
      return !1;
    });
    _(this, "parseBatchTableAttribute", (e, r) => {
      const a = e.scene.children, c = e.batchTable && e.batchTable.header;
      if (!c)
        return;
      const l = c[r];
      if (!(!l || !l.length))
        for (const h of a) {
          const d = h.geometry, f = d.getAttribute("_batchid");
          if (!f)
            continue;
          const p = f.data.count;
          let m = -1, y = 0;
          const x = [];
          for (let v = 0; v < p; v++)
            m = f.getX(v), y = l[m], x.push(y);
          d.attributes[r] = new BufferAttribute(new Float32Array(x), 1);
        }
    });
    _(this, "_refreshTileInfo", (e) => {
      var s;
      const r = e.content;
      ((s = this._asset) == null ? void 0 : s.tilesetVersion) === "2.0.0" && this.parseBatchTableAttribute(r, "typeId"), r.traverse((a) => {
        if (!a.isMesh || !a.material)
          return;
        a._rawMaterialName === void 0 && (a._rawMaterialName = a.material.name, a._originalMaterial = a.material);
        const c = a._rawMaterialName;
        if (this._materialManager) {
          const l = this._materialManager.getMaterialByKey(c, a);
          l && l.isMaterial ? a.material = l : a.material = a._originalMaterial;
        } else
          a.material = a._originalMaterial;
        a.receiveShadow = this._receiveShadow, a.castShadow = this._castShadow, r._raycastMethod !== this._raycastMethod && (this._raycastMethod === Pe.RAYCAST_NONE ? a.raycast = _emptyFunction : a.raycast = this._overridenRaycast);
      }), r._raycastMethod = this._raycastMethod;
    });
    _(this, "traversalLoadedTile", (e) => {
      this.getTraversal().forEachLoadedTile(this, e);
    });
    e = defaultValue$1(e, {}), this.plugins = [], this.preferLeaves = defaultValue$1(e.preferLeaves, !1), this.dynamicScreenSpaceError = defaultValue$1(e.dynamicScreenSpaceError, !0), this._updatedVisibilityFrame = 0, this.dynamicScreenSpaceErrorDensity = defaultValue$1(
      e.dynamicScreenSpaceErrorDensity,
      278e-5
    ), this.dynamicScreenSpaceErrorFactor = defaultValue$1(
      e.dynamicScreenSpaceErrorFactor,
      40
    ), this.dynamicScreenSpaceErrorHeightFalloff = defaultValue$1(
      e.dynamicScreenSpaceErrorHeightFalloff,
      0.25
    ), this.foveatedScreenSpaceError = defaultValue$1(
      e.foveatedScreenSpaceError,
      !0
    ), this._foveatedConeSize = defaultValue$1(e.foveatedConeSize, 0.05), this._foveatedMinimumScreenSpaceErrorRelaxation = defaultValue$1(
      e.foveatedMinimumScreenSpaceErrorRelaxation,
      0
    ), this.foveatedInterpolationCallback = defaultValue$1(
      e.foveatedInterpolationCallback,
      MathUtils.lerp
    ), this.loadSiblings = defaultValue$1(e.loadSiblings, !1), this.dynamicScreenSpaceHeightScale = e.dynamicScreenSpaceHeightScale || 6, this._dynamicScreenSpaceErrorComputedDensity = 0, this._cullWithChildrenBounds = defaultValue$1(
      e.cullWithChildrenBounds,
      !0
    ), this._url = void 0, this._basePath = void 0, this._rootPath = void 0, this._root = void 0, this._cache = new Cesium3DTilesetCache(), this._processingQueue = [], this._selectedTiles = [], this._selectedTilesToStyle = [], this._emptyTiles = [], this._requestedTiles = [], this._requestedTilesInFlight = [], this._maximumScreenSpaceError = defaultValue$1(
      e.maximumScreenSpaceError,
      64
    ), this._screenSpaceError = this._maximumScreenSpaceError, this.cullRequestsWhileMoving = defaultValue$1(
      e.cullRequestsWhileMoving,
      !0
    ), this._cullRequestsWhileMoving = !1, this.cullRequestsWhileMovingMultiplier = defaultValue$1(
      e.cullRequestsWhileMovingMultiplier,
      60
    ), this.progressiveResolutionHeightFraction = MathUtils.clamp(
      defaultValue$1(e.progressiveResolutionHeightFraction, 0.5),
      0,
      0.5
    ), this._cacheBytes = defaultValue$1(e.cacheBytes, 512 * 1024 * 1024), this._prevSelectedTiles = [];
    const r = defaultValue$1(
      e.maximumCacheOverflowBytes,
      512 * 1024 * 1024
    );
    this._maximumCacheOverflowBytes = r, this._statistics = new Cesium3DTilesetStatistics(), this._statisticsLast = new Cesium3DTilesetStatistics(), this._maximumPriority = {
      foveatedFactor: -Number.MAX_VALUE,
      depth: -Number.MAX_VALUE,
      distance: -Number.MAX_VALUE,
      reverseScreenSpaceError: -Number.MAX_VALUE
    }, this._minimumPriority = {
      foveatedFactor: Number.MAX_VALUE,
      depth: Number.MAX_VALUE,
      distance: Number.MAX_VALUE,
      reverseScreenSpaceError: Number.MAX_VALUE
    }, this._modelMatrix = defined$2(e.modelMatrix) ? new Matrix4().copy(e.modelMatrix) : new Matrix4(), this.optimizeRaycast = defaultValue$1(e.optimizeRaycast, !0), this._raycastMethod = Pe.RAYCAST_DEFAULT;
    const s = this;
    this._overridenRaycast = function(h, d) {
      s.optimizeRaycast || Object.getPrototypeOf(this).raycast.call(this, h, d);
    }, this._camera = null, this._manager = new LoadingManager(), Array.isArray(e.loaders) ? this._loaders = e.loaders : (this._gltfLoader = createEnhancedLoader(), this._loaders = [
      [/\.gltf$/, this._gltfLoader]
    ], e.forceUnlit && (this.forceUnlit = !0)), this.updateCustomLoaders(), this.group = new Group(), this.add(this.group);
    const a = this._elementsManager = new ElementsManager(this.group);
    a.tilesRenderer = this;
    const c = this._instancedElementManager = new TileInstancedElementManager();
    c.tilesRenderer = this, this.add(c.group);
    const l = this._editableElementManager = new EditableElementManager();
    l.tilesRenderer = this, this._displayBoxBounds = defaultValue$1(e.displayBoxBounds, !1), this._displayRegionBounds = defaultValue$1(e.displayRegionBounds, !1), this.debug = defaultValue$1(e.debug, !1), this._initEventListener();
  }
  getBounds() {
    const e = new Box3(), r = this.getBoundingBox(e);
    return r && e.applyMatrix4(this.matrixWorld), r ? e : null;
  }
  isEntityVisible(e) {
    return e.id ? !this._editableElementManager.hasDeletedId(e.id) : !0;
  }
  _initEventListener() {
    this.addEventListener("jsonloaded", this.handleLoadTileset), this.addEventListener("loaded", this.handleLoadTile), this.addEventListener("dispose", this.handleDisposeTile), this.addEventListener("visibilitychange", this.handleTileVisibleChanged);
  }
  handleLoadTileset() {
    this._engine && this._engine.requestRender();
  }
  handleLoadTile(e) {
    const r = e.tile;
    this._refreshTileInfo(r);
    const a = r.content.scene;
    this._elementsManager.onTileLoad(r, a), this._instancedElementManager.onTileLoad(r, a), this._editableElementManager.onTileLoad(r, a), this._engine.requestRender();
  }
  handleDisposeTile(e) {
    const r = e.tile, a = r.content.scene;
    this._elementsManager.onTileDispose(r, a), this._instancedElementManager.onTileDispose(r, a), this._editableElementManager.onTileDispose(r, a);
  }
  handleTileVisibleChanged(e) {
    const {
      tile: r,
      visible: s
    } = e;
    s ? (this._instancedElementManager.onTileShow(r), this._elementsManager.onTileShow(r), this._editableElementManager.onTileShow(r)) : (this._instancedElementManager.onTileHide(r), this._elementsManager.onTileHide(r), this._editableElementManager.onTileHide(r));
  }
  updateCustomLoaders() {
    for (const e of this._loaders)
      this._manager.addHandler(e[0], e[1]);
  }
  afterAddToEngine(e) {
    this._engine = e, e.addPrepareRenderListener(this.handleBeforeRender), this._elementsManager.engine = e, this._instancedElementManager.engine = e, this._editableElementManager.engine = e;
  }
  setCamera(e) {
    this._camera = e;
  }
  hasCamera() {
    return defined$2(this._camera);
  }
  deleteCamera() {
    this._camera = void 0;
  }
  getCamera() {
    return this.hasCamera() ? this._camera : this._engine && this._engine.camera;
  }
  getEntityByIntersection(e) {
    const r = {};
    let s = e.object;
    if (!defined$2(s))
      return null;
    let a, c;
    if (this._isInstancedElement(s))
      a = e.instanceId, c = s.__originalMesh || s.parent.__originalMesh;
    else {
      const { face: p, faceIndex: m } = e;
      a = p && p.a, r._face = p, r._faceIndex = m, c = s;
    }
    const l = c.content, h = c.tile;
    if (l && (r._content = l), h) {
      const p = h.tileset;
      r._tile = h, r._tileset = p;
    }
    const d = c.geometry ? c.geometry.getAttribute("_batchid") : void 0, f = l && l.batchTable;
    if (a !== void 0 && d) {
      const p = Math.round(d.getX(a));
      r._batchId = p;
      for (const m of Object.keys(f.header)) {
        const y = f.header[m];
        r[m] = y[p];
      }
    }
    return r;
  }
  updateInfo() {
    const e = this._engine, r = this.getCamera();
    this.dispatchEvent({ type: "update-before" });
    const s = e.renderer.getPixelRatio(), a = this._cameraInfo || {
      positionWCDeltaMagnitude: 0,
      positionCartographic: new Vector3$1(),
      lastMovedTimestamp: Date.now(),
      positionWCDeltaMagnitudeLastFrame: 0,
      timeSinceMoved: 0,
      position: new Vector3$1(),
      directionWC: new Vector3$1(),
      oldPosition: null
    }, c = e.rendering.resolution;
    (c.x === 0 || c.y === 0) && console.warn("TilesRenderer: resolution for camera error calculation is not set.");
    const l = r.projectionMatrix.elements;
    if (a.isOrthographic = l[15] === 1, a.isOrthographic) {
      const y = 2 / l[0], x = 2 / l[5];
      a.pixelSize = Math.max(x / (c.height * s), y / (c.width * s));
    } else
      a.sseDenominator = 2 / l[5] / (c.y * s);
    a.invScale = 1, a.position = _infoPosition.copy(r.position), a.pixelRatio = e.rendering.pixelRatio;
    const h = a.position;
    a.oldPosition || (a.oldPosition = h.clone()), a.frustum || (a.frustum = new ExtendedFrustum());
    const d = new Matrix4(), f = new Matrix4(), p = this.group;
    d.copy(p.matrixWorld), f.copy(d).invert(), d.premultiply(r.matrixWorldInverse), d.premultiply(r.projectionMatrix), a.frustum.setFromProjectionMatrix(d), h.set(0, 0, 0), h.applyMatrix4(r.matrixWorld), h.applyMatrix4(f), a.positionWCDeltaMagnitudeLastFrame = a.positionWCDeltaMagnitude;
    const m = _infoDelta.subVectors(h, a.oldPosition);
    a.positionWCDeltaMagnitude = m.length(), a.positionWCDeltaMagnitude > 0 ? (a.timeSinceMoved = 0, a.lastMovedTimestamp = Date.now()) : a.timeSinceMoved = Math.max(Date.now() - a.lastMovedTimestamp, 0) / 1e3, a.oldPosition.copy(h), r.getWorldDirection(a.directionWC), a.positionCartographic.fromArray(e.map.unprojectArrayCoordinate(r.position.toArray())), this._cameraInfo = a;
  }
  prePassesUpdate(e) {
    if (this.updateInfo(), !!defined$2(this._root)) {
      if (processTiles(this), this.dynamicScreenSpaceError) {
        const r = this._engine;
        updateDynamicScreenSpaceError(this, e, r);
      }
      this._cache.reset();
    }
  }
  forEachLoadedModel(e) {
    this.traversalLoadedTile(e);
  }
  update(e) {
    update(this, e);
  }
  trimLoadedTiles() {
    this._cache.trim();
  }
  postPassesUpdate(e) {
    !defined$2(this._root) || (cancelOutOfViewRequests(this, e), this._cache.unloadTiles(this, unloadTile), this._styleApplied = !1, RequestScheduler.update());
  }
  beforeRemoveFromEngine(e) {
    this._engine.removePrepareRenderListener(this.handleBeforeRender), this.dispose();
  }
  dispose() {
    this.resetQueue(), this.traversalLoadedTile((e, r) => {
      this._cache.unloadTile(this, r, unloadTile);
    });
  }
  disposePlugins() {
    this.plugins.forEach((e) => {
      e.dispose && e.dispose();
    });
  }
  resetQueue() {
    this._prevSelectedTiles.length = 0, this._processingQueue.length = 0, this._requestedTiles.length = 0;
  }
  getTraversal() {
    return this.isSkippingLevelOfDetail ? Cesium3DTilesetSkipTraversal : Cesium3DTilesetBaseTraversal;
  }
  isDestroyed() {
    return !1;
  }
  async setTilesetProperties(e, r, s) {
    const a = await processMetadataExtension(
      r,
      e
    );
    this._metadataExtension = a, this._geometricError = e.geometricError, this._scaledGeometricError = e.geometricError;
    const c = e.asset;
    this._asset = c, this._extras = e.extras;
    const l = defined$2(e.asset.gltfUpAxis) ? Axis.fromName(e.asset.gltfUpAxis) : Axis.Y, h = defaultValue$1(s.modelUpAxis, l), d = defaultValue$1(s.modelForwardAxis, Axis.X);
    this._gltfUpMatrix = new Matrix4(), this._properties = e.properties, this._extensionsUsed = e.extensionsUsed, this._extensions = e.extensions, this._modelUpAxis = h, this._modelForwardAxis = d, this._root = this.loadTileset(r, e), queueMicrotask(() => {
      this.dispatchEvent({
        type: "rootloaded",
        tileset: e,
        url: r.url
      });
    });
  }
  static async fromAssetId(e, r) {
    const s = await IonResource.fromAssetId(e);
    return Pe.fromUrl(s, r);
  }
  static fromUrl(e, r) {
    r = defaultValue$1(r, {});
    const s = Resource.createIfNeeded(e);
    let a;
    s.extension === "json" ? a = s.getBaseUri(!0) : s.isDataUri && (a = "");
    const c = new Pe(r);
    return c._resource = s, c._url = e, c._basePath = a, c._rootPath = a, Pe.loadJson(s).then(async function(l) {
      c.setTilesetProperties(l, s, r);
    }), c;
  }
  static async fromUrlAsync(e, r) {
    r = defaultValue$1(r, {});
    const s = Resource.createIfNeeded(e);
    let a;
    s.extension === "json" ? a = s.getBaseUri(!0) : s.isDataUri && (a = "");
    const c = await Pe.loadJson(s), l = await processMetadataExtension(
      s,
      c
    ), h = new Pe(r);
    h._resource = s, h._url = e, h._basePath = a, h._rootPath = a, h._metadataExtension = l, h._geometricError = c.geometricError, h._scaledGeometricError = c.geometricError;
    const d = c.asset;
    h._asset = d, h._extras = c.extras;
    const f = defined$2(c.asset.gltfUpAxis) ? Axis.fromName(c.asset.gltfUpAxis) : Axis.Y, p = defaultValue$1(r.modelUpAxis, f), m = defaultValue$1(r.modelForwardAxis, Axis.X);
    return h._gltfUpMatrix = new Matrix4(), h._properties = c.properties, h._extensionsUsed = c.extensionsUsed, h._extensions = c.extensions, h._modelUpAxis = p, h._modelForwardAxis = m, h._root = h.loadTileset(s, c), h;
  }
  static async loadJson(e) {
    return Resource.createIfNeeded(e).fetchJson();
  }
  getBoundingBox(e) {
    if (!this.root)
      return !1;
    const r = this.root.boundingVolume;
    return r ? (r.getAABB(e), !0) : !1;
  }
  loadTileset(e, r, s) {
    const a = r.asset;
    if (!defined$2(a))
      throw new Error("Tileset must have an asset property.");
    if (a.version !== "0.0" && a.version !== "1.0" && a.version !== "1.1")
      throw new Error(
        "The tileset must be 3D Tiles version 0.0, 1.0, or 1.1"
      );
    defined$2(r.extensionsRequired) && Pe.checkSupportedExtensions(r.extensionsRequired);
    const c = this._statistics, l = a.tilesetVersion;
    defined$2(l) && (this._basePath += `?v=${l}`, e = e.clone(), e.setQueryParameters({ v: l }));
    const h = makeTile(this, e, r.root, s);
    defined$2(s) && (s.children.push(h), h._depth = s._depth + 1);
    const d = [];
    for (d.push(h); d.length > 0; ) {
      const f = d.pop();
      ++c.numberOfTilesTotal, this._allTilesAdditive = this._allTilesAdditive && f.refine === Cesium3DTileRefine.ADD;
      const p = f._header.children;
      if (defined$2(p))
        for (let m = 0; m < p.length; ++m) {
          const y = p[m], x = makeTile(this, e, y, f);
          f.children.push(x), x._depth = f._depth + 1, d.push(x);
        }
      this._cullWithChildrenBounds && Cesium3DTileOptimizations.checkChildrenWithinParent(f);
    }
    return queueMicrotask(() => {
      this.dispatchEvent({
        type: "jsonloaded",
        tileset: r,
        url: e.url
      });
    }), h;
  }
  registerPlugin(e) {
    if (e[PLUGIN_REGISTERED] === !0)
      throw new Error("A plugin can only be registered to a single tile set");
    return this.plugins.push(e), e[PLUGIN_REGISTERED] = !0, e.init && e.init(this), e;
  }
  raycast(e, r) {
    if (!!this._root && this.raycastMethod !== Pe.RAYCAST_NONE)
      if (e.firstHitOnly) {
        const s = raycastTraverseFirstHit(this, this._root, e);
        s && r.push(s);
      } else
        raycastTraverse(this, this._root, e, r);
  }
  get raycastMethod() {
    return this._raycastMethod;
  }
  set raycastMethod(e) {
    e !== this._raycastMethod && (this._raycastMethod = parseInt(e, 10), this._needsRefreshAllLoadedTiles = !0, this._engine && this._engine.requestRender());
  }
  get root() {
    return this._root;
  }
  get modelMatrix() {
    return this._modelMatrix;
  }
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  get cacheBytes() {
    return this._cacheBytes;
  }
  set cacheBytes(e) {
    this._cacheBytes = e;
  }
  get maximumCacheOverflowBytes() {
    return this._maximumCacheOverflowBytes;
  }
  set maximumCacheOverflowBytes(e) {
    this._maximumCacheOverflowBytes = e;
  }
  get gltfUpMatrix() {
    switch (this._modelUpAxis) {
      case Axis.X:
        this._gltfUpMatrix.makeRotationAxis(Y_AXIS, -Math.PI / 2);
        break;
      case Axis.Y:
        this._gltfUpMatrix.makeRotationAxis(X_AXIS, Math.PI / 2);
        break;
    }
    return this._gltfUpMatrix;
  }
  get metadataExtension() {
    return this._metadataExtension;
  }
  get schema() {
    if (defined$2(this._metadataExtension))
      return this._metadataExtension.schema;
  }
  get metadata() {
    if (defined$2(this._metadataExtension))
      return this._metadataExtension.tileset;
  }
  get foveatedConeSize() {
    return this._foveatedConeSize;
  }
  set foveatedConeSize(e) {
    this._foveatedConeSize = e;
  }
  get totalMemoryUsageInBytes() {
    return this._statistics.totalByteLength;
  }
  get statistics() {
    return this._statistics;
  }
  get foveatedMinimumScreenSpaceErrorRelaxation() {
    return this._foveatedMinimumScreenSpaceErrorRelaxation;
  }
  set foveatedMinimumScreenSpaceErrorRelaxation(e) {
    this._foveatedMinimumScreenSpaceErrorRelaxation = e;
  }
  get maximumScreenSpaceError() {
    return this._maximumScreenSpaceError;
  }
  set maximumScreenSpaceError(e) {
    this._maximumScreenSpaceError = e, this._screenSpaceError = e, this._engine && this._engine.requestRender();
  }
  get debug() {
    return this._debug;
  }
  set debug(e) {
    this._debug !== e && (this._debug = e, e ? (this._debugTilesPlugin = new DebugTilesPlugin(), this._debugTilesPlugin.displayBoxBounds = this._displayBoxBounds, this._debugTilesPlugin.displayRegionBounds = this._displayRegionBounds, this.registerPlugin(this._debugTilesPlugin)) : this._debugTilesPlugin && this._debugTilesPlugin.dispose());
  }
  get debugTilesPlugin() {
    return this._debugTilesPlugin;
  }
  get displayBoxBounds() {
    return this._displayBoxBounds;
  }
  set displayBoxBounds(e) {
    this._displayBoxBounds = e, this._debugTilesPlugin && (this._debugTilesPlugin.displayBoxBounds = e);
  }
  get displayRegionBounds() {
    return this._displayRegionBounds;
  }
  set displayRegionBounds(e) {
    this._displayRegionBounds = e, this._debugTilesPlugin && (this._debugTilesPlugin.displayRegionBounds = e);
  }
  get displaySphereBounds() {
    return this._displaySphereBounds;
  }
  set displaySphereBounds(e) {
    this._displaySphereBounds = e, this._debugTilesPlugin && (this._debugTilesPlugin.displaySphereBounds = e);
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(e) {
    this._freezeUpdate = e;
  }
  get materialManager() {
    return this._materialManager;
  }
  set materialManager(e) {
    e !== this._materialManager && (e && (e.engine = this._engine, e.tiles = this, e.init(), e.isIdentity3DTilesMaterialManager && (e.type = this._identityType)), this._materialManager = e, this._needsRefreshAllLoadedTiles = !0, this._engine.requestRender());
  }
  get castShadow() {
    return this._castShadow;
  }
  set castShadow(e) {
    e !== this._castShadow && (this._castShadow = e, this._needsRefreshAllLoadedTiles = !0, this._engine && this._engine.requestRender());
  }
  get receiveShadow() {
    return this._receiveShadow;
  }
  set receiveShadow(e) {
    e !== this._receiveShadow && (this._receiveShadow = e, this._needsRefreshAllLoadedTiles = !0, this._engine && this._engine.requestRender());
  }
  get instancedElementManager() {
    return this._instancedElementManager;
  }
  get editableElementManager() {
    return this._editableElementManager;
  }
  get elementsManager() {
    return this._elementsManager;
  }
  get forceUnlit() {
    return this._forceUnlit;
  }
  set forceUnlit(e) {
    e === this._forceUnlit || !this._gltfLoader || (this._forceUnlit = e, this._gltfLoader.setForceUnlit(e), this.dispose(), this.engine && this.engine.requestRender());
  }
};
let Cesium3DTileset = Pe;
_(Cesium3DTileset, "RAYCAST_NONE", 0), _(Cesium3DTileset, "RAYCAST_DEFAULT", 1), _(Cesium3DTileset, "RAYCAST_BVH", 2), _(Cesium3DTileset, "supportedExtensions", {
  "3DTILES_metadata": !0,
  "3DTILES_implicit_tiling": !0,
  "3DTILES_content_gltf": !0,
  "3DTILES_multiple_contents": !0,
  "3DTILES_bounding_volume_S2": !0,
  "3DTILES_batch_table_hierarchy": !0,
  "3DTILES_draco_point_compression": !0,
  MAXAR_content_geojson: !0
}), _(Cesium3DTileset, "checkSupportedExtensions", function(e) {
  for (let r = 0; r < e.length; r++)
    if (!Pe.supportedExtensions[e[r]])
      throw new Error(
        `Unsupported 3D Tiles Extension: ${e[r]}`
      );
});
function makeTile(o, i, e, r) {
  if (!(defined$2(e.implicitTiling) || hasExtension(e, "3DTILES_implicit_tiling")))
    return new Cesium3DTile(o, i, e, r);
  const a = o.schema, c = new ImplicitTileset(
    i,
    e,
    a
  ), l = new ImplicitTileCoordinates({
    subdivisionScheme: c.subdivisionScheme,
    subtreeLevels: c.subtreeLevels,
    level: 0,
    x: 0,
    y: 0,
    z: 0
  }), h = c.subtreeUriTemplate.getDerivedResource({
    templateValues: l.getTemplateValues()
  }).url, f = clone$2(e, !0);
  f.contents = [
    {
      uri: h
    }
  ], delete f.content, delete f.extensions;
  const p = new Cesium3DTile(o, i, f, r);
  return p.implicitTileset = c, p.implicitCoordinates = l, p;
}
function cancelOutOfViewRequests(o, i) {
  const e = o._requestedTilesInFlight;
  let r = 0;
  for (let s = 0; s < e.length; ++s) {
    const a = e[s], c = i.frameCount - a._touchedFrame >= 1;
    if (a._contentState !== Cesium3DTileContentState$1.LOADING) {
      ++r;
      continue;
    } else if (c) {
      a.cancelRequests(), ++r;
      continue;
    }
    r > 0 && (e[s - r] = a);
  }
  e.length -= r;
}
function hasExtension(o, i) {
  return defined$2(o) && defined$2(o.extensions) && defined$2(o.extensions[i]);
}
function filterProcessingQueue(o) {
  const i = o._processingQueue;
  let e = 0;
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    if (s.isDestroyed() || s._contentState !== Cesium3DTileContentState$1.PROCESSING) {
      ++e;
      continue;
    }
    e && (i[r - e] = s);
  }
  i.length -= e;
}
function handleTileFailure(o, i, e) {
  i.isDestroyed() || (e.isDestroyed() || e._contentResource.url, defined$2(o.message) ? o.message : o.toString());
}
function resetMinimumMaximum(o) {
  o._minimumPriority.depth = Number.MAX_VALUE, o._maximumPriority.depth = -Number.MAX_VALUE, o._minimumPriority.foveatedFactor = Number.MAX_VALUE, o._maximumPriority.foveatedFactor = -Number.MAX_VALUE, o._minimumPriority.distance = Number.MAX_VALUE, o._maximumPriority.distance = -Number.MAX_VALUE, o._minimumPriority.reverseScreenSpaceError = Number.MAX_VALUE, o._maximumPriority.reverseScreenSpaceError = -Number.MAX_VALUE;
}
function update(o, i) {
  if (!defined$2(o._root))
    return !1;
  o._statistics.clear(), o._updatedVisibilityFrame = i.frameCount, resetMinimumMaximum(o), o._cullRequestsWhileMoving = o.cullRequestsWhileMoving, o.getTraversal().selectTiles(o, i), requestTiles(o), updateTiles(o, i), o.dispatchEvent({ type: "update-after" });
}
function sortTilesByPriority(o, i) {
  return o._priority - i._priority;
}
function requestTiles(o) {
  const i = o._requestedTiles;
  i.sort(sortTilesByPriority);
  for (let e = 0; e < i.length; ++e)
    requestContent(o, i[e]);
}
function addContent(o) {
  const i = o.tileset, e = o._content;
  if (e.isMultiple3DTileContents) {
    const r = e._contents, s = r.length;
    for (let a = 0; a < s; ++a) {
      const c = r[a].scene;
      i.group.add(c);
    }
  } else {
    const r = e.scene;
    i.group.add(r);
  }
}
function removeContent(o) {
  const i = o.tileset, e = o._content;
  if (e.isMultiple3DTileContents) {
    const r = e._contents, s = r.length;
    for (let a = 0; a < s; ++a) {
      const c = r[a].scene;
      i.group.remove(c);
    }
  } else {
    const r = e.scene;
    i.group.remove(r);
  }
}
function setTileVisible(o, i) {
  const e = o.tileset;
  i ? addContent(o) : removeContent(o), e.dispatchEvent({
    type: "visibilitychange",
    tile: o,
    visible: i
  });
}
function updateTiles(o, i) {
  o._styleApplied = !0;
  const e = o._prevSelectedTiles, r = o._selectedTiles, { statistics: s } = o;
  let a = 0, c = 0;
  for (a = 0, c = e.length; a < c; a++) {
    const h = e[a];
    r.includes(h) || setTileVisible(h, !1);
  }
  for (a = 0, c = r.length; a < c; a++) {
    const h = r[a];
    e.includes(h) || setTileVisible(h, !0), h.update(o, i);
  }
  s.selected = r.length, o._prevSelectedTiles = [...r];
  const l = o._emptyTiles;
  for (let h = 0; h < l.length; ++h)
    l[h].update(o, i);
}
function requestContent(o, i) {
  if (i.hasEmptyContent)
    return;
  const { statistics: e } = o, r = i.requestContent();
  !defined$2(r) || (r.then((s) => {
    !defined$2(s) || i.isDestroyed() || o.isDestroyed() || (o._processingQueue.push(i), ++e.numberOfTilesProcessing, o._engine.requestRender());
  }).catch((s) => {
    handleTileFailure(s, o, i);
  }), o._requestedTilesInFlight.push(i));
}
function unloadTile(o, i) {
  o._statistics.decrementLoadCounts(i.content), --o._statistics.numberOfTilesWithContentReady, i.unloadContent();
}
function processTiles(o) {
  filterProcessingQueue(o);
  const i = o._processingQueue, { cacheBytes: e, maximumCacheOverflowBytes: r, statistics: s } = o;
  for (let a = 0; a < i.length; ++a) {
    const c = i[a];
    try {
      c.process(o), c.contentReady && --s.numberOfTilesProcessing;
    } catch {
      --s.numberOfTilesProcessing, handleTileFailure();
    }
  }
}
class Default3DTiles extends Cesium3DTileset {
  constructor(e) {
    const r = defaultValue$1(e.errorTarget, 64), s = defaultValue$1(e.forceUnlit, !1), a = defaultValue$1(e.cullWithChildrenBounds, !0), c = defaultValue$1(e.cullRequestsWhileMoving, !0), l = defaultValue$1(e.cullRequestsWhileMovingMultiplier, 60), h = defaultValue$1(e.dynamicScreenSpaceError, !0), d = defaultValue$1(e.dynamicScreenSpaceErrorHeightFalloff, 0.25), f = defaultValue$1(e.dynamicScreenSpaceErrorDensity, 278e-5), p = defaultValue$1(e.foveatedScreenSpaceError, !1), m = defaultValue$1(e.foveatedConeSize, 0.3), y = defaultValue$1(e.foveatedMinimumScreenSpaceErrorRelaxation, 0.8), x = defaultValue$1(e.progressiveResolutionHeightFraction, 0.5), v = e.cacheBytes, S = e._maximumCacheOverflowBytes, E = e.loaders;
    super({
      maximumScreenSpaceError: r,
      forceUnlit: s,
      cullWithChildrenBounds: a,
      cullRequestsWhileMoving: c,
      cullRequestsWhileMovingMultiplier: l,
      dynamicScreenSpaceError: h,
      dynamicScreenSpaceErrorHeightFalloff: d,
      dynamicScreenSpaceErrorDensity: f,
      foveatedScreenSpaceError: p,
      foveatedConeSize: m,
      foveatedMinimumScreenSpaceErrorRelaxation: y,
      progressiveResolutionHeightFraction: x,
      cacheBytes: v,
      maximumCacheOverflowBytes: S,
      loaders: E
    });
    _(this, "_showDebug", !1);
    _(this, "transformFromEcefToPlane", (e, r, s = 0) => {
      let a = Transforms.eastNorthUpToFixedFrame(Transforms.lnglatToEcef(e, r, s));
      a.invert();
      const c = new Matrix4(), l = this.engine.map.projectArrayCoordinate([e, r]);
      c.makeTranslation(l[0], l[1], 0);
      const h = new Matrix4();
      h.multiplyMatrices(c, a), h.decompose(this.position, this.quaternion, this.scale);
    });
    _(this, "lockCameraViewport", () => {
      const e = this.getCamera(), r = this._lockedCamera = e.clone();
      this.setCamera(r), this._updateCameraHelper(r);
    });
    _(this, "releaseCameraViewport", () => {
      const e = this._engine;
      if (this._lockedCamera) {
        const s = e.camera;
        this.setCamera(s), this._lockedCamera = null;
      }
      this._destroyCameraHelper();
    });
    this._errorTarget = r;
    const b = e.url;
    e = defaultValue$1(e, {});
    const w = e.assetId;
    if (defined$2(w))
      IonResource.fromAssetId(w).then((M) => {
        let P;
        M.extension === "json" ? P = M.getBaseUri(!0) : M.isDataUri && (P = ""), this._resource = M, this._url = b, this._basePath = P, this._rootPath = P, Cesium3DTileset.loadJson(M).then(async (D) => {
          this.setTilesetProperties(D, M, e);
        });
      });
    else {
      const M = Resource.createIfNeeded(b);
      let P;
      M.extension === "json" ? P = M.getBaseUri(!0) : M.isDataUri && (P = ""), this._resource = M, this._url = b, this._basePath = P, this._rootPath = P, Cesium3DTileset.loadJson(M).then(async (D) => {
        this.setTilesetProperties(D, M, e);
      });
    }
  }
  static async fromAssetId(e, r = {}) {
    const s = await IonResource.fromAssetId(e);
    return r.url = s, new Default3DTiles(r);
  }
  _updateCameraHelper(e) {
    const r = this._engine;
    this._destroyCameraHelper();
    const s = this._cameraHelper = new CameraHelper(e);
    r.add(s);
  }
  _destroyCameraHelper() {
    const e = this._engine;
    this._cameraHelper && (e.remove(this._cameraHelper), this._cameraHelper.dispose(), this._cameraHelper = null);
  }
  get showDebug() {
    return this._showDebug;
  }
  set showDebug(e) {
    this._showDebug !== e && (this.debug = e, this.displayBoxBounds = e, this.displayRegionBounds = e, this.displaySphereBounds = e, this._showDebug = e);
  }
  get errorTarget() {
    return this.maximumScreenSpaceError;
  }
  set errorTarget(e) {
    this.maximumScreenSpaceError = e;
  }
  get cullWithChildrenBounds() {
    return this._cullWithChildrenBounds;
  }
  set cullWithChildrenBounds(e) {
    this._cullWithChildrenBounds = e;
  }
  get cullRequestsWhileMoving() {
    return this._cullRequestsWhileMoving;
  }
  set cullRequestsWhileMoving(e) {
    this._cullRequestsWhileMoving = e;
  }
  get foveatedConeSize() {
    return this._foveatedConeSize;
  }
  set foveatedConeSize(e) {
    this._foveatedConeSize = e;
  }
  get loadSiblings() {
    return this._loadSiblings;
  }
  set loadSiblings(e) {
    this._loadSiblings = e;
  }
}
const ot = class extends DataSource {
  constructor(e = {}) {
    super(e);
    _(this, "_coordinatesKey", "coordinates");
    _(this, "_parseCoordinates");
    _(this, "_parseFeature");
    this.type = "JSONDataSource", e.coordinatesKey && (this._coordinatesKey = e.coordinatesKey), e.parseCoordinates && (this._parseCoordinates = e.parseCoordinates), e.parseFeature && (this._parseFeature = e.parseFeature);
  }
  async _convertStreamingDataToObjectData(e) {
    return await e.json();
  }
  _convertObjectDataToJSONData(e) {
    return Array.isArray(e) ? e : [e];
  }
  _parseObjectDataToDataItems(e) {
    const r = this._convertObjectDataToJSONData(e), s = [];
    for (let a = 0, c = r.length; a < c; a++) {
      const l = r[a], h = {};
      let d = null;
      if (this._parseFeature)
        s.push(this._parseFeature(l));
      else {
        for (const f of Object.keys(l))
          f !== this.coordinatesKey ? h[f] = l[f] : this.parseCoordinates || (d = parseWkt(l[f]));
        this._parseCoordinates && (d = this._parseCoordinates(l)), d = this._formatGeometry(d), s.push(new DataItem({ geometry: d, properties: h }));
      }
    }
    return s;
  }
  get coordinatesKey() {
    return this._coordinatesKey;
  }
  set coordinatesKey(e) {
    this._coordinatesKey = e;
  }
  set parseCoordinates(e) {
    this._parseCoordinates = e;
  }
  get parseCoordinates() {
    return this._parseCoordinates;
  }
  set parseFeature(e) {
    this._parseFeature = e;
  }
  get parseFeature() {
    return this._parseFeature;
  }
};
let JSONDataSource = ot;
_(JSONDataSource, "fromURL", async function(e, r) {
  let s = new ot(r);
  return await s.load(e), s;
}), _(JSONDataSource, "fromUrl", async function(e, r) {
  return console.warn("JSONDataSource.fromUrl is deprecated, please use JSONDataSource.fromURL instead."), await this.fromURL(e, r);
}), _(JSONDataSource, "fromJSON", function(e, r) {
  let s = new ot(r);
  return s.setData(e), s;
});
var global$1 = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {}, lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, inited = !1;
function init() {
  inited = !0;
  for (var o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, e = o.length; i < e; ++i)
    lookup[i] = o[i], revLookup[o.charCodeAt(i)] = i;
  revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(o) {
  inited || init();
  var i, e, r, s, a, c, l = o.length;
  if (l % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  a = o[l - 2] === "=" ? 2 : o[l - 1] === "=" ? 1 : 0, c = new Arr(l * 3 / 4 - a), r = a > 0 ? l - 4 : l;
  var h = 0;
  for (i = 0, e = 0; i < r; i += 4, e += 3)
    s = revLookup[o.charCodeAt(i)] << 18 | revLookup[o.charCodeAt(i + 1)] << 12 | revLookup[o.charCodeAt(i + 2)] << 6 | revLookup[o.charCodeAt(i + 3)], c[h++] = s >> 16 & 255, c[h++] = s >> 8 & 255, c[h++] = s & 255;
  return a === 2 ? (s = revLookup[o.charCodeAt(i)] << 2 | revLookup[o.charCodeAt(i + 1)] >> 4, c[h++] = s & 255) : a === 1 && (s = revLookup[o.charCodeAt(i)] << 10 | revLookup[o.charCodeAt(i + 1)] << 4 | revLookup[o.charCodeAt(i + 2)] >> 2, c[h++] = s >> 8 & 255, c[h++] = s & 255), c;
}
function tripletToBase64(o) {
  return lookup[o >> 18 & 63] + lookup[o >> 12 & 63] + lookup[o >> 6 & 63] + lookup[o & 63];
}
function encodeChunk(o, i, e) {
  for (var r, s = [], a = i; a < e; a += 3)
    r = (o[a] << 16) + (o[a + 1] << 8) + o[a + 2], s.push(tripletToBase64(r));
  return s.join("");
}
function fromByteArray(o) {
  inited || init();
  for (var i, e = o.length, r = e % 3, s = "", a = [], c = 16383, l = 0, h = e - r; l < h; l += c)
    a.push(encodeChunk(o, l, l + c > h ? h : l + c));
  return r === 1 ? (i = o[e - 1], s += lookup[i >> 2], s += lookup[i << 4 & 63], s += "==") : r === 2 && (i = (o[e - 2] << 8) + o[e - 1], s += lookup[i >> 10], s += lookup[i >> 4 & 63], s += lookup[i << 2 & 63], s += "="), a.push(s), a.join("");
}
function read(o, i, e, r, s) {
  var a, c, l = s * 8 - r - 1, h = (1 << l) - 1, d = h >> 1, f = -7, p = e ? s - 1 : 0, m = e ? -1 : 1, y = o[i + p];
  for (p += m, a = y & (1 << -f) - 1, y >>= -f, f += l; f > 0; a = a * 256 + o[i + p], p += m, f -= 8)
    ;
  for (c = a & (1 << -f) - 1, a >>= -f, f += r; f > 0; c = c * 256 + o[i + p], p += m, f -= 8)
    ;
  if (a === 0)
    a = 1 - d;
  else {
    if (a === h)
      return c ? NaN : (y ? -1 : 1) * (1 / 0);
    c = c + Math.pow(2, r), a = a - d;
  }
  return (y ? -1 : 1) * c * Math.pow(2, a - r);
}
function write(o, i, e, r, s, a) {
  var c, l, h, d = a * 8 - s - 1, f = (1 << d) - 1, p = f >> 1, m = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = r ? 0 : a - 1, x = r ? 1 : -1, v = i < 0 || i === 0 && 1 / i < 0 ? 1 : 0;
  for (i = Math.abs(i), isNaN(i) || i === 1 / 0 ? (l = isNaN(i) ? 1 : 0, c = f) : (c = Math.floor(Math.log(i) / Math.LN2), i * (h = Math.pow(2, -c)) < 1 && (c--, h *= 2), c + p >= 1 ? i += m / h : i += m * Math.pow(2, 1 - p), i * h >= 2 && (c++, h /= 2), c + p >= f ? (l = 0, c = f) : c + p >= 1 ? (l = (i * h - 1) * Math.pow(2, s), c = c + p) : (l = i * Math.pow(2, p - 1) * Math.pow(2, s), c = 0)); s >= 8; o[e + y] = l & 255, y += x, l /= 256, s -= 8)
    ;
  for (c = c << s | l, d += s; d > 0; o[e + y] = c & 255, y += x, c /= 256, d -= 8)
    ;
  o[e + y - x] |= v * 128;
}
var toString = {}.toString, isArray = Array.isArray || function(o) {
  return toString.call(o) == "[object Array]";
}, INSPECT_MAX_BYTES = 50;
Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : !0;
kMaxLength();
function kMaxLength() {
  return Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(o, i) {
  if (kMaxLength() < i)
    throw new RangeError("Invalid typed array length");
  return Buffer$1.TYPED_ARRAY_SUPPORT ? (o = new Uint8Array(i), o.__proto__ = Buffer$1.prototype) : (o === null && (o = new Buffer$1(i)), o.length = i), o;
}
function Buffer$1(o, i, e) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1))
    return new Buffer$1(o, i, e);
  if (typeof o == "number") {
    if (typeof i == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return allocUnsafe(this, o);
  }
  return from(this, o, i, e);
}
Buffer$1.poolSize = 8192;
Buffer$1._augment = function(o) {
  return o.__proto__ = Buffer$1.prototype, o;
};
function from(o, i, e, r) {
  if (typeof i == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && i instanceof ArrayBuffer ? fromArrayBuffer(o, i, e, r) : typeof i == "string" ? fromString(o, i, e) : fromObject(o, i);
}
Buffer$1.from = function(o, i, e) {
  return from(null, o, i, e);
};
Buffer$1.TYPED_ARRAY_SUPPORT && (Buffer$1.prototype.__proto__ = Uint8Array.prototype, Buffer$1.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && Buffer$1[Symbol.species]);
function assertSize(o) {
  if (typeof o != "number")
    throw new TypeError('"size" argument must be a number');
  if (o < 0)
    throw new RangeError('"size" argument must not be negative');
}
function alloc(o, i, e, r) {
  return assertSize(i), i <= 0 ? createBuffer(o, i) : e !== void 0 ? typeof r == "string" ? createBuffer(o, i).fill(e, r) : createBuffer(o, i).fill(e) : createBuffer(o, i);
}
Buffer$1.alloc = function(o, i, e) {
  return alloc(null, o, i, e);
};
function allocUnsafe(o, i) {
  if (assertSize(i), o = createBuffer(o, i < 0 ? 0 : checked(i) | 0), !Buffer$1.TYPED_ARRAY_SUPPORT)
    for (var e = 0; e < i; ++e)
      o[e] = 0;
  return o;
}
Buffer$1.allocUnsafe = function(o) {
  return allocUnsafe(null, o);
};
Buffer$1.allocUnsafeSlow = function(o) {
  return allocUnsafe(null, o);
};
function fromString(o, i, e) {
  if ((typeof e != "string" || e === "") && (e = "utf8"), !Buffer$1.isEncoding(e))
    throw new TypeError('"encoding" must be a valid string encoding');
  var r = byteLength(i, e) | 0;
  o = createBuffer(o, r);
  var s = o.write(i, e);
  return s !== r && (o = o.slice(0, s)), o;
}
function fromArrayLike(o, i) {
  var e = i.length < 0 ? 0 : checked(i.length) | 0;
  o = createBuffer(o, e);
  for (var r = 0; r < e; r += 1)
    o[r] = i[r] & 255;
  return o;
}
function fromArrayBuffer(o, i, e, r) {
  if (i.byteLength, e < 0 || i.byteLength < e)
    throw new RangeError("'offset' is out of bounds");
  if (i.byteLength < e + (r || 0))
    throw new RangeError("'length' is out of bounds");
  return e === void 0 && r === void 0 ? i = new Uint8Array(i) : r === void 0 ? i = new Uint8Array(i, e) : i = new Uint8Array(i, e, r), Buffer$1.TYPED_ARRAY_SUPPORT ? (o = i, o.__proto__ = Buffer$1.prototype) : o = fromArrayLike(o, i), o;
}
function fromObject(o, i) {
  if (internalIsBuffer(i)) {
    var e = checked(i.length) | 0;
    return o = createBuffer(o, e), o.length === 0 || i.copy(o, 0, 0, e), o;
  }
  if (i) {
    if (typeof ArrayBuffer < "u" && i.buffer instanceof ArrayBuffer || "length" in i)
      return typeof i.length != "number" || isnan(i.length) ? createBuffer(o, 0) : fromArrayLike(o, i);
    if (i.type === "Buffer" && isArray(i.data))
      return fromArrayLike(o, i.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(o) {
  if (o >= kMaxLength())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  return o | 0;
}
Buffer$1.isBuffer = isBuffer;
function internalIsBuffer(o) {
  return !!(o != null && o._isBuffer);
}
Buffer$1.compare = function o(i, e) {
  if (!internalIsBuffer(i) || !internalIsBuffer(e))
    throw new TypeError("Arguments must be Buffers");
  if (i === e)
    return 0;
  for (var r = i.length, s = e.length, a = 0, c = Math.min(r, s); a < c; ++a)
    if (i[a] !== e[a]) {
      r = i[a], s = e[a];
      break;
    }
  return r < s ? -1 : s < r ? 1 : 0;
};
Buffer$1.isEncoding = function o(i) {
  switch (String(i).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
Buffer$1.concat = function o(i, e) {
  if (!isArray(i))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (i.length === 0)
    return Buffer$1.alloc(0);
  var r;
  if (e === void 0)
    for (e = 0, r = 0; r < i.length; ++r)
      e += i[r].length;
  var s = Buffer$1.allocUnsafe(e), a = 0;
  for (r = 0; r < i.length; ++r) {
    var c = i[r];
    if (!internalIsBuffer(c))
      throw new TypeError('"list" argument must be an Array of Buffers');
    c.copy(s, a), a += c.length;
  }
  return s;
};
function byteLength(o, i) {
  if (internalIsBuffer(o))
    return o.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(o) || o instanceof ArrayBuffer))
    return o.byteLength;
  typeof o != "string" && (o = "" + o);
  var e = o.length;
  if (e === 0)
    return 0;
  for (var r = !1; ; )
    switch (i) {
      case "ascii":
      case "latin1":
      case "binary":
        return e;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(o).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return e * 2;
      case "hex":
        return e >>> 1;
      case "base64":
        return base64ToBytes(o).length;
      default:
        if (r)
          return utf8ToBytes(o).length;
        i = ("" + i).toLowerCase(), r = !0;
    }
}
Buffer$1.byteLength = byteLength;
function slowToString(o, i, e) {
  var r = !1;
  if ((i === void 0 || i < 0) && (i = 0), i > this.length || ((e === void 0 || e > this.length) && (e = this.length), e <= 0) || (e >>>= 0, i >>>= 0, e <= i))
    return "";
  for (o || (o = "utf8"); ; )
    switch (o) {
      case "hex":
        return hexSlice(this, i, e);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, i, e);
      case "ascii":
        return asciiSlice(this, i, e);
      case "latin1":
      case "binary":
        return latin1Slice(this, i, e);
      case "base64":
        return base64Slice(this, i, e);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, i, e);
      default:
        if (r)
          throw new TypeError("Unknown encoding: " + o);
        o = (o + "").toLowerCase(), r = !0;
    }
}
Buffer$1.prototype._isBuffer = !0;
function swap(o, i, e) {
  var r = o[i];
  o[i] = o[e], o[e] = r;
}
Buffer$1.prototype.swap16 = function o() {
  var i = this.length;
  if (i % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var e = 0; e < i; e += 2)
    swap(this, e, e + 1);
  return this;
};
Buffer$1.prototype.swap32 = function o() {
  var i = this.length;
  if (i % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var e = 0; e < i; e += 4)
    swap(this, e, e + 3), swap(this, e + 1, e + 2);
  return this;
};
Buffer$1.prototype.swap64 = function o() {
  var i = this.length;
  if (i % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var e = 0; e < i; e += 8)
    swap(this, e, e + 7), swap(this, e + 1, e + 6), swap(this, e + 2, e + 5), swap(this, e + 3, e + 4);
  return this;
};
Buffer$1.prototype.toString = function o() {
  var i = this.length | 0;
  return i === 0 ? "" : arguments.length === 0 ? utf8Slice(this, 0, i) : slowToString.apply(this, arguments);
};
Buffer$1.prototype.equals = function o(i) {
  if (!internalIsBuffer(i))
    throw new TypeError("Argument must be a Buffer");
  return this === i ? !0 : Buffer$1.compare(this, i) === 0;
};
Buffer$1.prototype.inspect = function o() {
  var i = "", e = INSPECT_MAX_BYTES;
  return this.length > 0 && (i = this.toString("hex", 0, e).match(/.{2}/g).join(" "), this.length > e && (i += " ... ")), "<Buffer " + i + ">";
};
Buffer$1.prototype.compare = function o(i, e, r, s, a) {
  if (!internalIsBuffer(i))
    throw new TypeError("Argument must be a Buffer");
  if (e === void 0 && (e = 0), r === void 0 && (r = i ? i.length : 0), s === void 0 && (s = 0), a === void 0 && (a = this.length), e < 0 || r > i.length || s < 0 || a > this.length)
    throw new RangeError("out of range index");
  if (s >= a && e >= r)
    return 0;
  if (s >= a)
    return -1;
  if (e >= r)
    return 1;
  if (e >>>= 0, r >>>= 0, s >>>= 0, a >>>= 0, this === i)
    return 0;
  for (var c = a - s, l = r - e, h = Math.min(c, l), d = this.slice(s, a), f = i.slice(e, r), p = 0; p < h; ++p)
    if (d[p] !== f[p]) {
      c = d[p], l = f[p];
      break;
    }
  return c < l ? -1 : l < c ? 1 : 0;
};
function bidirectionalIndexOf(o, i, e, r, s) {
  if (o.length === 0)
    return -1;
  if (typeof e == "string" ? (r = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, isNaN(e) && (e = s ? 0 : o.length - 1), e < 0 && (e = o.length + e), e >= o.length) {
    if (s)
      return -1;
    e = o.length - 1;
  } else if (e < 0)
    if (s)
      e = 0;
    else
      return -1;
  if (typeof i == "string" && (i = Buffer$1.from(i, r)), internalIsBuffer(i))
    return i.length === 0 ? -1 : arrayIndexOf(o, i, e, r, s);
  if (typeof i == "number")
    return i = i & 255, Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? s ? Uint8Array.prototype.indexOf.call(o, i, e) : Uint8Array.prototype.lastIndexOf.call(o, i, e) : arrayIndexOf(o, [i], e, r, s);
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(o, i, e, r, s) {
  var a = 1, c = o.length, l = i.length;
  if (r !== void 0 && (r = String(r).toLowerCase(), r === "ucs2" || r === "ucs-2" || r === "utf16le" || r === "utf-16le")) {
    if (o.length < 2 || i.length < 2)
      return -1;
    a = 2, c /= 2, l /= 2, e /= 2;
  }
  function h(y, x) {
    return a === 1 ? y[x] : y.readUInt16BE(x * a);
  }
  var d;
  if (s) {
    var f = -1;
    for (d = e; d < c; d++)
      if (h(o, d) === h(i, f === -1 ? 0 : d - f)) {
        if (f === -1 && (f = d), d - f + 1 === l)
          return f * a;
      } else
        f !== -1 && (d -= d - f), f = -1;
  } else
    for (e + l > c && (e = c - l), d = e; d >= 0; d--) {
      for (var p = !0, m = 0; m < l; m++)
        if (h(o, d + m) !== h(i, m)) {
          p = !1;
          break;
        }
      if (p)
        return d;
    }
  return -1;
}
Buffer$1.prototype.includes = function o(i, e, r) {
  return this.indexOf(i, e, r) !== -1;
};
Buffer$1.prototype.indexOf = function o(i, e, r) {
  return bidirectionalIndexOf(this, i, e, r, !0);
};
Buffer$1.prototype.lastIndexOf = function o(i, e, r) {
  return bidirectionalIndexOf(this, i, e, r, !1);
};
function hexWrite(o, i, e, r) {
  e = Number(e) || 0;
  var s = o.length - e;
  r ? (r = Number(r), r > s && (r = s)) : r = s;
  var a = i.length;
  if (a % 2 !== 0)
    throw new TypeError("Invalid hex string");
  r > a / 2 && (r = a / 2);
  for (var c = 0; c < r; ++c) {
    var l = parseInt(i.substr(c * 2, 2), 16);
    if (isNaN(l))
      return c;
    o[e + c] = l;
  }
  return c;
}
function utf8Write(o, i, e, r) {
  return blitBuffer(utf8ToBytes(i, o.length - e), o, e, r);
}
function asciiWrite(o, i, e, r) {
  return blitBuffer(asciiToBytes(i), o, e, r);
}
function latin1Write(o, i, e, r) {
  return asciiWrite(o, i, e, r);
}
function base64Write(o, i, e, r) {
  return blitBuffer(base64ToBytes(i), o, e, r);
}
function ucs2Write(o, i, e, r) {
  return blitBuffer(utf16leToBytes(i, o.length - e), o, e, r);
}
Buffer$1.prototype.write = function o(i, e, r, s) {
  if (e === void 0)
    s = "utf8", r = this.length, e = 0;
  else if (r === void 0 && typeof e == "string")
    s = e, r = this.length, e = 0;
  else if (isFinite(e))
    e = e | 0, isFinite(r) ? (r = r | 0, s === void 0 && (s = "utf8")) : (s = r, r = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var a = this.length - e;
  if ((r === void 0 || r > a) && (r = a), i.length > 0 && (r < 0 || e < 0) || e > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  s || (s = "utf8");
  for (var c = !1; ; )
    switch (s) {
      case "hex":
        return hexWrite(this, i, e, r);
      case "utf8":
      case "utf-8":
        return utf8Write(this, i, e, r);
      case "ascii":
        return asciiWrite(this, i, e, r);
      case "latin1":
      case "binary":
        return latin1Write(this, i, e, r);
      case "base64":
        return base64Write(this, i, e, r);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, i, e, r);
      default:
        if (c)
          throw new TypeError("Unknown encoding: " + s);
        s = ("" + s).toLowerCase(), c = !0;
    }
};
Buffer$1.prototype.toJSON = function o() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(o, i, e) {
  return i === 0 && e === o.length ? fromByteArray(o) : fromByteArray(o.slice(i, e));
}
function utf8Slice(o, i, e) {
  e = Math.min(o.length, e);
  for (var r = [], s = i; s < e; ) {
    var a = o[s], c = null, l = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1;
    if (s + l <= e) {
      var h, d, f, p;
      switch (l) {
        case 1:
          a < 128 && (c = a);
          break;
        case 2:
          h = o[s + 1], (h & 192) === 128 && (p = (a & 31) << 6 | h & 63, p > 127 && (c = p));
          break;
        case 3:
          h = o[s + 1], d = o[s + 2], (h & 192) === 128 && (d & 192) === 128 && (p = (a & 15) << 12 | (h & 63) << 6 | d & 63, p > 2047 && (p < 55296 || p > 57343) && (c = p));
          break;
        case 4:
          h = o[s + 1], d = o[s + 2], f = o[s + 3], (h & 192) === 128 && (d & 192) === 128 && (f & 192) === 128 && (p = (a & 15) << 18 | (h & 63) << 12 | (d & 63) << 6 | f & 63, p > 65535 && p < 1114112 && (c = p));
      }
    }
    c === null ? (c = 65533, l = 1) : c > 65535 && (c -= 65536, r.push(c >>> 10 & 1023 | 55296), c = 56320 | c & 1023), r.push(c), s += l;
  }
  return decodeCodePointsArray(r);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(o) {
  var i = o.length;
  if (i <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, o);
  for (var e = "", r = 0; r < i; )
    e += String.fromCharCode.apply(
      String,
      o.slice(r, r += MAX_ARGUMENTS_LENGTH)
    );
  return e;
}
function asciiSlice(o, i, e) {
  var r = "";
  e = Math.min(o.length, e);
  for (var s = i; s < e; ++s)
    r += String.fromCharCode(o[s] & 127);
  return r;
}
function latin1Slice(o, i, e) {
  var r = "";
  e = Math.min(o.length, e);
  for (var s = i; s < e; ++s)
    r += String.fromCharCode(o[s]);
  return r;
}
function hexSlice(o, i, e) {
  var r = o.length;
  (!i || i < 0) && (i = 0), (!e || e < 0 || e > r) && (e = r);
  for (var s = "", a = i; a < e; ++a)
    s += toHex(o[a]);
  return s;
}
function utf16leSlice(o, i, e) {
  for (var r = o.slice(i, e), s = "", a = 0; a < r.length; a += 2)
    s += String.fromCharCode(r[a] + r[a + 1] * 256);
  return s;
}
Buffer$1.prototype.slice = function o(i, e) {
  var r = this.length;
  i = ~~i, e = e === void 0 ? r : ~~e, i < 0 ? (i += r, i < 0 && (i = 0)) : i > r && (i = r), e < 0 ? (e += r, e < 0 && (e = 0)) : e > r && (e = r), e < i && (e = i);
  var s;
  if (Buffer$1.TYPED_ARRAY_SUPPORT)
    s = this.subarray(i, e), s.__proto__ = Buffer$1.prototype;
  else {
    var a = e - i;
    s = new Buffer$1(a, void 0);
    for (var c = 0; c < a; ++c)
      s[c] = this[c + i];
  }
  return s;
};
function checkOffset(o, i, e) {
  if (o % 1 !== 0 || o < 0)
    throw new RangeError("offset is not uint");
  if (o + i > e)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer$1.prototype.readUIntLE = function o(i, e, r) {
  i = i | 0, e = e | 0, r || checkOffset(i, e, this.length);
  for (var s = this[i], a = 1, c = 0; ++c < e && (a *= 256); )
    s += this[i + c] * a;
  return s;
};
Buffer$1.prototype.readUIntBE = function o(i, e, r) {
  i = i | 0, e = e | 0, r || checkOffset(i, e, this.length);
  for (var s = this[i + --e], a = 1; e > 0 && (a *= 256); )
    s += this[i + --e] * a;
  return s;
};
Buffer$1.prototype.readUInt8 = function o(i, e) {
  return e || checkOffset(i, 1, this.length), this[i];
};
Buffer$1.prototype.readUInt16LE = function o(i, e) {
  return e || checkOffset(i, 2, this.length), this[i] | this[i + 1] << 8;
};
Buffer$1.prototype.readUInt16BE = function o(i, e) {
  return e || checkOffset(i, 2, this.length), this[i] << 8 | this[i + 1];
};
Buffer$1.prototype.readUInt32LE = function o(i, e) {
  return e || checkOffset(i, 4, this.length), (this[i] | this[i + 1] << 8 | this[i + 2] << 16) + this[i + 3] * 16777216;
};
Buffer$1.prototype.readUInt32BE = function o(i, e) {
  return e || checkOffset(i, 4, this.length), this[i] * 16777216 + (this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3]);
};
Buffer$1.prototype.readIntLE = function o(i, e, r) {
  i = i | 0, e = e | 0, r || checkOffset(i, e, this.length);
  for (var s = this[i], a = 1, c = 0; ++c < e && (a *= 256); )
    s += this[i + c] * a;
  return a *= 128, s >= a && (s -= Math.pow(2, 8 * e)), s;
};
Buffer$1.prototype.readIntBE = function o(i, e, r) {
  i = i | 0, e = e | 0, r || checkOffset(i, e, this.length);
  for (var s = e, a = 1, c = this[i + --s]; s > 0 && (a *= 256); )
    c += this[i + --s] * a;
  return a *= 128, c >= a && (c -= Math.pow(2, 8 * e)), c;
};
Buffer$1.prototype.readInt8 = function o(i, e) {
  return e || checkOffset(i, 1, this.length), this[i] & 128 ? (255 - this[i] + 1) * -1 : this[i];
};
Buffer$1.prototype.readInt16LE = function o(i, e) {
  e || checkOffset(i, 2, this.length);
  var r = this[i] | this[i + 1] << 8;
  return r & 32768 ? r | 4294901760 : r;
};
Buffer$1.prototype.readInt16BE = function o(i, e) {
  e || checkOffset(i, 2, this.length);
  var r = this[i + 1] | this[i] << 8;
  return r & 32768 ? r | 4294901760 : r;
};
Buffer$1.prototype.readInt32LE = function o(i, e) {
  return e || checkOffset(i, 4, this.length), this[i] | this[i + 1] << 8 | this[i + 2] << 16 | this[i + 3] << 24;
};
Buffer$1.prototype.readInt32BE = function o(i, e) {
  return e || checkOffset(i, 4, this.length), this[i] << 24 | this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3];
};
Buffer$1.prototype.readFloatLE = function o(i, e) {
  return e || checkOffset(i, 4, this.length), read(this, i, !0, 23, 4);
};
Buffer$1.prototype.readFloatBE = function o(i, e) {
  return e || checkOffset(i, 4, this.length), read(this, i, !1, 23, 4);
};
Buffer$1.prototype.readDoubleLE = function o(i, e) {
  return e || checkOffset(i, 8, this.length), read(this, i, !0, 52, 8);
};
Buffer$1.prototype.readDoubleBE = function o(i, e) {
  return e || checkOffset(i, 8, this.length), read(this, i, !1, 52, 8);
};
function checkInt(o, i, e, r, s, a) {
  if (!internalIsBuffer(o))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (i > s || i < a)
    throw new RangeError('"value" argument is out of bounds');
  if (e + r > o.length)
    throw new RangeError("Index out of range");
}
Buffer$1.prototype.writeUIntLE = function o(i, e, r, s) {
  if (i = +i, e = e | 0, r = r | 0, !s) {
    var a = Math.pow(2, 8 * r) - 1;
    checkInt(this, i, e, r, a, 0);
  }
  var c = 1, l = 0;
  for (this[e] = i & 255; ++l < r && (c *= 256); )
    this[e + l] = i / c & 255;
  return e + r;
};
Buffer$1.prototype.writeUIntBE = function o(i, e, r, s) {
  if (i = +i, e = e | 0, r = r | 0, !s) {
    var a = Math.pow(2, 8 * r) - 1;
    checkInt(this, i, e, r, a, 0);
  }
  var c = r - 1, l = 1;
  for (this[e + c] = i & 255; --c >= 0 && (l *= 256); )
    this[e + c] = i / l & 255;
  return e + r;
};
Buffer$1.prototype.writeUInt8 = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 1, 255, 0), Buffer$1.TYPED_ARRAY_SUPPORT || (i = Math.floor(i)), this[e] = i & 255, e + 1;
};
function objectWriteUInt16(o, i, e, r) {
  i < 0 && (i = 65535 + i + 1);
  for (var s = 0, a = Math.min(o.length - e, 2); s < a; ++s)
    o[e + s] = (i & 255 << 8 * (r ? s : 1 - s)) >>> (r ? s : 1 - s) * 8;
}
Buffer$1.prototype.writeUInt16LE = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 2, 65535, 0), Buffer$1.TYPED_ARRAY_SUPPORT ? (this[e] = i & 255, this[e + 1] = i >>> 8) : objectWriteUInt16(this, i, e, !0), e + 2;
};
Buffer$1.prototype.writeUInt16BE = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 2, 65535, 0), Buffer$1.TYPED_ARRAY_SUPPORT ? (this[e] = i >>> 8, this[e + 1] = i & 255) : objectWriteUInt16(this, i, e, !1), e + 2;
};
function objectWriteUInt32(o, i, e, r) {
  i < 0 && (i = 4294967295 + i + 1);
  for (var s = 0, a = Math.min(o.length - e, 4); s < a; ++s)
    o[e + s] = i >>> (r ? s : 3 - s) * 8 & 255;
}
Buffer$1.prototype.writeUInt32LE = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 4, 4294967295, 0), Buffer$1.TYPED_ARRAY_SUPPORT ? (this[e + 3] = i >>> 24, this[e + 2] = i >>> 16, this[e + 1] = i >>> 8, this[e] = i & 255) : objectWriteUInt32(this, i, e, !0), e + 4;
};
Buffer$1.prototype.writeUInt32BE = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 4, 4294967295, 0), Buffer$1.TYPED_ARRAY_SUPPORT ? (this[e] = i >>> 24, this[e + 1] = i >>> 16, this[e + 2] = i >>> 8, this[e + 3] = i & 255) : objectWriteUInt32(this, i, e, !1), e + 4;
};
Buffer$1.prototype.writeIntLE = function o(i, e, r, s) {
  if (i = +i, e = e | 0, !s) {
    var a = Math.pow(2, 8 * r - 1);
    checkInt(this, i, e, r, a - 1, -a);
  }
  var c = 0, l = 1, h = 0;
  for (this[e] = i & 255; ++c < r && (l *= 256); )
    i < 0 && h === 0 && this[e + c - 1] !== 0 && (h = 1), this[e + c] = (i / l >> 0) - h & 255;
  return e + r;
};
Buffer$1.prototype.writeIntBE = function o(i, e, r, s) {
  if (i = +i, e = e | 0, !s) {
    var a = Math.pow(2, 8 * r - 1);
    checkInt(this, i, e, r, a - 1, -a);
  }
  var c = r - 1, l = 1, h = 0;
  for (this[e + c] = i & 255; --c >= 0 && (l *= 256); )
    i < 0 && h === 0 && this[e + c + 1] !== 0 && (h = 1), this[e + c] = (i / l >> 0) - h & 255;
  return e + r;
};
Buffer$1.prototype.writeInt8 = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 1, 127, -128), Buffer$1.TYPED_ARRAY_SUPPORT || (i = Math.floor(i)), i < 0 && (i = 255 + i + 1), this[e] = i & 255, e + 1;
};
Buffer$1.prototype.writeInt16LE = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 2, 32767, -32768), Buffer$1.TYPED_ARRAY_SUPPORT ? (this[e] = i & 255, this[e + 1] = i >>> 8) : objectWriteUInt16(this, i, e, !0), e + 2;
};
Buffer$1.prototype.writeInt16BE = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 2, 32767, -32768), Buffer$1.TYPED_ARRAY_SUPPORT ? (this[e] = i >>> 8, this[e + 1] = i & 255) : objectWriteUInt16(this, i, e, !1), e + 2;
};
Buffer$1.prototype.writeInt32LE = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 4, 2147483647, -2147483648), Buffer$1.TYPED_ARRAY_SUPPORT ? (this[e] = i & 255, this[e + 1] = i >>> 8, this[e + 2] = i >>> 16, this[e + 3] = i >>> 24) : objectWriteUInt32(this, i, e, !0), e + 4;
};
Buffer$1.prototype.writeInt32BE = function o(i, e, r) {
  return i = +i, e = e | 0, r || checkInt(this, i, e, 4, 2147483647, -2147483648), i < 0 && (i = 4294967295 + i + 1), Buffer$1.TYPED_ARRAY_SUPPORT ? (this[e] = i >>> 24, this[e + 1] = i >>> 16, this[e + 2] = i >>> 8, this[e + 3] = i & 255) : objectWriteUInt32(this, i, e, !1), e + 4;
};
function checkIEEE754(o, i, e, r, s, a) {
  if (e + r > o.length)
    throw new RangeError("Index out of range");
  if (e < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(o, i, e, r, s) {
  return s || checkIEEE754(o, i, e, 4), write(o, i, e, r, 23, 4), e + 4;
}
Buffer$1.prototype.writeFloatLE = function o(i, e, r) {
  return writeFloat(this, i, e, !0, r);
};
Buffer$1.prototype.writeFloatBE = function o(i, e, r) {
  return writeFloat(this, i, e, !1, r);
};
function writeDouble(o, i, e, r, s) {
  return s || checkIEEE754(o, i, e, 8), write(o, i, e, r, 52, 8), e + 8;
}
Buffer$1.prototype.writeDoubleLE = function o(i, e, r) {
  return writeDouble(this, i, e, !0, r);
};
Buffer$1.prototype.writeDoubleBE = function o(i, e, r) {
  return writeDouble(this, i, e, !1, r);
};
Buffer$1.prototype.copy = function o(i, e, r, s) {
  if (r || (r = 0), !s && s !== 0 && (s = this.length), e >= i.length && (e = i.length), e || (e = 0), s > 0 && s < r && (s = r), s === r || i.length === 0 || this.length === 0)
    return 0;
  if (e < 0)
    throw new RangeError("targetStart out of bounds");
  if (r < 0 || r >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (s < 0)
    throw new RangeError("sourceEnd out of bounds");
  s > this.length && (s = this.length), i.length - e < s - r && (s = i.length - e + r);
  var a = s - r, c;
  if (this === i && r < e && e < s)
    for (c = a - 1; c >= 0; --c)
      i[c + e] = this[c + r];
  else if (a < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT)
    for (c = 0; c < a; ++c)
      i[c + e] = this[c + r];
  else
    Uint8Array.prototype.set.call(
      i,
      this.subarray(r, r + a),
      e
    );
  return a;
};
Buffer$1.prototype.fill = function o(i, e, r, s) {
  if (typeof i == "string") {
    if (typeof e == "string" ? (s = e, e = 0, r = this.length) : typeof r == "string" && (s = r, r = this.length), i.length === 1) {
      var a = i.charCodeAt(0);
      a < 256 && (i = a);
    }
    if (s !== void 0 && typeof s != "string")
      throw new TypeError("encoding must be a string");
    if (typeof s == "string" && !Buffer$1.isEncoding(s))
      throw new TypeError("Unknown encoding: " + s);
  } else
    typeof i == "number" && (i = i & 255);
  if (e < 0 || this.length < e || this.length < r)
    throw new RangeError("Out of range index");
  if (r <= e)
    return this;
  e = e >>> 0, r = r === void 0 ? this.length : r >>> 0, i || (i = 0);
  var c;
  if (typeof i == "number")
    for (c = e; c < r; ++c)
      this[c] = i;
  else {
    var l = internalIsBuffer(i) ? i : utf8ToBytes(new Buffer$1(i, s).toString()), h = l.length;
    for (c = 0; c < r - e; ++c)
      this[c + e] = l[c % h];
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(o) {
  if (o = stringtrim(o).replace(INVALID_BASE64_RE, ""), o.length < 2)
    return "";
  for (; o.length % 4 !== 0; )
    o = o + "=";
  return o;
}
function stringtrim(o) {
  return o.trim ? o.trim() : o.replace(/^\s+|\s+$/g, "");
}
function toHex(o) {
  return o < 16 ? "0" + o.toString(16) : o.toString(16);
}
function utf8ToBytes(o, i) {
  i = i || 1 / 0;
  for (var e, r = o.length, s = null, a = [], c = 0; c < r; ++c) {
    if (e = o.charCodeAt(c), e > 55295 && e < 57344) {
      if (!s) {
        if (e > 56319) {
          (i -= 3) > -1 && a.push(239, 191, 189);
          continue;
        } else if (c + 1 === r) {
          (i -= 3) > -1 && a.push(239, 191, 189);
          continue;
        }
        s = e;
        continue;
      }
      if (e < 56320) {
        (i -= 3) > -1 && a.push(239, 191, 189), s = e;
        continue;
      }
      e = (s - 55296 << 10 | e - 56320) + 65536;
    } else
      s && (i -= 3) > -1 && a.push(239, 191, 189);
    if (s = null, e < 128) {
      if ((i -= 1) < 0)
        break;
      a.push(e);
    } else if (e < 2048) {
      if ((i -= 2) < 0)
        break;
      a.push(
        e >> 6 | 192,
        e & 63 | 128
      );
    } else if (e < 65536) {
      if ((i -= 3) < 0)
        break;
      a.push(
        e >> 12 | 224,
        e >> 6 & 63 | 128,
        e & 63 | 128
      );
    } else if (e < 1114112) {
      if ((i -= 4) < 0)
        break;
      a.push(
        e >> 18 | 240,
        e >> 12 & 63 | 128,
        e >> 6 & 63 | 128,
        e & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return a;
}
function asciiToBytes(o) {
  for (var i = [], e = 0; e < o.length; ++e)
    i.push(o.charCodeAt(e) & 255);
  return i;
}
function utf16leToBytes(o, i) {
  for (var e, r, s, a = [], c = 0; c < o.length && !((i -= 2) < 0); ++c)
    e = o.charCodeAt(c), r = e >> 8, s = e % 256, a.push(s), a.push(r);
  return a;
}
function base64ToBytes(o) {
  return toByteArray(base64clean(o));
}
function blitBuffer(o, i, e, r) {
  for (var s = 0; s < r && !(s + e >= i.length || s >= o.length); ++s)
    i[s + e] = o[s];
  return s;
}
function isnan(o) {
  return o !== o;
}
function isBuffer(o) {
  return o != null && (!!o._isBuffer || isFastBuffer(o) || isSlowBuffer(o));
}
function isFastBuffer(o) {
  return !!o.constructor && typeof o.constructor.isBuffer == "function" && o.constructor.isBuffer(o);
}
function isSlowBuffer(o) {
  return typeof o.readFloatLE == "function" && typeof o.slice == "function" && isFastBuffer(o.slice(0, 0));
}
class CsvError extends Error {
  constructor(i, e, r, ...s) {
    Array.isArray(e) && (e = e.join(" ").trim()), super(e), Error.captureStackTrace !== void 0 && Error.captureStackTrace(this, CsvError), this.code = i;
    for (const a of s)
      for (const c in a) {
        const l = a[c];
        this[c] = isBuffer(l) ? l.toString(r.encoding) : l == null ? l : JSON.parse(JSON.stringify(l));
      }
  }
}
const is_object = function(o) {
  return typeof o == "object" && o !== null && !Array.isArray(o);
}, normalize_columns_array = function(o) {
  const i = [];
  for (let e = 0, r = o.length; e < r; e++) {
    const s = o[e];
    if (s == null || s === !1)
      i[e] = { disabled: !0 };
    else if (typeof s == "string")
      i[e] = { name: s };
    else if (is_object(s)) {
      if (typeof s.name != "string")
        throw new CsvError("CSV_OPTION_COLUMNS_MISSING_NAME", [
          "Option columns missing name:",
          `property "name" is required at position ${e}`,
          "when column is an object literal"
        ]);
      i[e] = s;
    } else
      throw new CsvError("CSV_INVALID_COLUMN_DEFINITION", [
        "Invalid column definition:",
        "expect a string or a literal object,",
        `got ${JSON.stringify(s)} at position ${e}`
      ]);
  }
  return i;
};
class ResizeableBuffer {
  constructor(i = 100) {
    this.size = i, this.length = 0, this.buf = Buffer$1.allocUnsafe(i);
  }
  prepend(i) {
    if (isBuffer(i)) {
      const e = this.length + i.length;
      if (e >= this.size && (this.resize(), e >= this.size))
        throw Error("INVALID_BUFFER_STATE");
      const r = this.buf;
      this.buf = Buffer$1.allocUnsafe(this.size), i.copy(this.buf, 0), r.copy(this.buf, i.length), this.length += i.length;
    } else {
      const e = this.length++;
      e === this.size && this.resize();
      const r = this.clone();
      this.buf[0] = i, r.copy(this.buf, 1, 0, e);
    }
  }
  append(i) {
    const e = this.length++;
    e === this.size && this.resize(), this.buf[e] = i;
  }
  clone() {
    return Buffer$1.from(this.buf.slice(0, this.length));
  }
  resize() {
    const i = this.length;
    this.size = this.size * 2;
    const e = Buffer$1.allocUnsafe(this.size);
    this.buf.copy(e, 0, 0, i), this.buf = e;
  }
  toString(i) {
    return i ? this.buf.slice(0, this.length).toString(i) : Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
  }
  toJSON() {
    return this.toString("utf8");
  }
  reset() {
    this.length = 0;
  }
}
const np = 12, cr$1 = 13, nl$1 = 10, space = 32, tab = 9, init_state = function(o) {
  return {
    bomSkipped: !1,
    bufBytesStart: 0,
    castField: o.cast_function,
    commenting: !1,
    error: void 0,
    enabled: o.from_line === 1,
    escaping: !1,
    escapeIsQuote: isBuffer(o.escape) && isBuffer(o.quote) && Buffer$1.compare(o.escape, o.quote) === 0,
    expectedRecordLength: Array.isArray(o.columns) ? o.columns.length : void 0,
    field: new ResizeableBuffer(20),
    firstLineToHeaders: o.cast_first_line_to_header,
    needMoreDataSize: Math.max(
      o.comment !== null ? o.comment.length : 0,
      ...o.delimiter.map((i) => i.length),
      o.quote !== null ? o.quote.length : 0
    ),
    previousBuf: void 0,
    quoting: !1,
    stop: !1,
    rawBuffer: new ResizeableBuffer(100),
    record: [],
    recordHasError: !1,
    record_length: 0,
    recordDelimiterMaxLength: o.record_delimiter.length === 0 ? 0 : Math.max(...o.record_delimiter.map((i) => i.length)),
    trimChars: [
      Buffer$1.from(" ", o.encoding)[0],
      Buffer$1.from("	", o.encoding)[0]
    ],
    wasQuoting: !1,
    wasRowDelimiter: !1,
    timchars: [
      Buffer$1.from(Buffer$1.from([cr$1], "utf8").toString(), o.encoding),
      Buffer$1.from(Buffer$1.from([nl$1], "utf8").toString(), o.encoding),
      Buffer$1.from(Buffer$1.from([np], "utf8").toString(), o.encoding),
      Buffer$1.from(Buffer$1.from([space], "utf8").toString(), o.encoding),
      Buffer$1.from(Buffer$1.from([tab], "utf8").toString(), o.encoding)
    ]
  };
}, underscore = function(o) {
  return o.replace(/([A-Z])/g, function(i, e) {
    return "_" + e.toLowerCase();
  });
}, normalize_options = function(o) {
  const i = {};
  for (const r in o)
    i[underscore(r)] = o[r];
  if (i.encoding === void 0 || i.encoding === !0)
    i.encoding = "utf8";
  else if (i.encoding === null || i.encoding === !1)
    i.encoding = null;
  else if (typeof i.encoding != "string" && i.encoding !== null)
    throw new CsvError(
      "CSV_INVALID_OPTION_ENCODING",
      [
        "Invalid option encoding:",
        "encoding must be a string or null to return a buffer,",
        `got ${JSON.stringify(i.encoding)}`
      ],
      i
    );
  if (i.bom === void 0 || i.bom === null || i.bom === !1)
    i.bom = !1;
  else if (i.bom !== !0)
    throw new CsvError(
      "CSV_INVALID_OPTION_BOM",
      [
        "Invalid option bom:",
        "bom must be true,",
        `got ${JSON.stringify(i.bom)}`
      ],
      i
    );
  if (i.cast_function = null, i.cast === void 0 || i.cast === null || i.cast === !1 || i.cast === "")
    i.cast = void 0;
  else if (typeof i.cast == "function")
    i.cast_function = i.cast, i.cast = !0;
  else if (i.cast !== !0)
    throw new CsvError(
      "CSV_INVALID_OPTION_CAST",
      [
        "Invalid option cast:",
        "cast must be true or a function,",
        `got ${JSON.stringify(i.cast)}`
      ],
      i
    );
  if (i.cast_date === void 0 || i.cast_date === null || i.cast_date === !1 || i.cast_date === "")
    i.cast_date = !1;
  else if (i.cast_date === !0)
    i.cast_date = function(r) {
      const s = Date.parse(r);
      return isNaN(s) ? r : new Date(s);
    };
  else if (typeof i.cast_date != "function")
    throw new CsvError(
      "CSV_INVALID_OPTION_CAST_DATE",
      [
        "Invalid option cast_date:",
        "cast_date must be true or a function,",
        `got ${JSON.stringify(i.cast_date)}`
      ],
      i
    );
  if (i.cast_first_line_to_header = null, i.columns === !0)
    i.cast_first_line_to_header = void 0;
  else if (typeof i.columns == "function")
    i.cast_first_line_to_header = i.columns, i.columns = !0;
  else if (Array.isArray(i.columns))
    i.columns = normalize_columns_array(i.columns);
  else if (i.columns === void 0 || i.columns === null || i.columns === !1)
    i.columns = !1;
  else
    throw new CsvError(
      "CSV_INVALID_OPTION_COLUMNS",
      [
        "Invalid option columns:",
        "expect an array, a function or true,",
        `got ${JSON.stringify(i.columns)}`
      ],
      i
    );
  if (i.group_columns_by_name === void 0 || i.group_columns_by_name === null || i.group_columns_by_name === !1)
    i.group_columns_by_name = !1;
  else {
    if (i.group_columns_by_name !== !0)
      throw new CsvError(
        "CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",
        [
          "Invalid option group_columns_by_name:",
          "expect an boolean,",
          `got ${JSON.stringify(i.group_columns_by_name)}`
        ],
        i
      );
    if (i.columns === !1)
      throw new CsvError(
        "CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",
        [
          "Invalid option group_columns_by_name:",
          "the `columns` mode must be activated."
        ],
        i
      );
  }
  if (i.comment === void 0 || i.comment === null || i.comment === !1 || i.comment === "")
    i.comment = null;
  else if (typeof i.comment == "string" && (i.comment = Buffer$1.from(i.comment, i.encoding)), !isBuffer(i.comment))
    throw new CsvError(
      "CSV_INVALID_OPTION_COMMENT",
      [
        "Invalid option comment:",
        "comment must be a buffer or a string,",
        `got ${JSON.stringify(i.comment)}`
      ],
      i
    );
  if (i.comment_no_infix === void 0 || i.comment_no_infix === null || i.comment_no_infix === !1)
    i.comment_no_infix = !1;
  else if (i.comment_no_infix !== !0)
    throw new CsvError(
      "CSV_INVALID_OPTION_COMMENT",
      [
        "Invalid option comment_no_infix:",
        "value must be a boolean,",
        `got ${JSON.stringify(i.comment_no_infix)}`
      ],
      i
    );
  const e = JSON.stringify(i.delimiter);
  if (Array.isArray(i.delimiter) || (i.delimiter = [i.delimiter]), i.delimiter.length === 0)
    throw new CsvError(
      "CSV_INVALID_OPTION_DELIMITER",
      [
        "Invalid option delimiter:",
        "delimiter must be a non empty string or buffer or array of string|buffer,",
        `got ${e}`
      ],
      i
    );
  if (i.delimiter = i.delimiter.map(function(r) {
    if (r == null || r === !1)
      return Buffer$1.from(",", i.encoding);
    if (typeof r == "string" && (r = Buffer$1.from(r, i.encoding)), !isBuffer(r) || r.length === 0)
      throw new CsvError(
        "CSV_INVALID_OPTION_DELIMITER",
        [
          "Invalid option delimiter:",
          "delimiter must be a non empty string or buffer or array of string|buffer,",
          `got ${e}`
        ],
        i
      );
    return r;
  }), i.escape === void 0 || i.escape === !0 ? i.escape = Buffer$1.from('"', i.encoding) : typeof i.escape == "string" ? i.escape = Buffer$1.from(i.escape, i.encoding) : (i.escape === null || i.escape === !1) && (i.escape = null), i.escape !== null && !isBuffer(i.escape))
    throw new Error(
      `Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(i.escape)}`
    );
  if (i.from === void 0 || i.from === null)
    i.from = 1;
  else if (typeof i.from == "string" && /\d+/.test(i.from) && (i.from = parseInt(i.from)), Number.isInteger(i.from)) {
    if (i.from < 0)
      throw new Error(
        `Invalid Option: from must be a positive integer, got ${JSON.stringify(o.from)}`
      );
  } else
    throw new Error(
      `Invalid Option: from must be an integer, got ${JSON.stringify(i.from)}`
    );
  if (i.from_line === void 0 || i.from_line === null)
    i.from_line = 1;
  else if (typeof i.from_line == "string" && /\d+/.test(i.from_line) && (i.from_line = parseInt(i.from_line)), Number.isInteger(i.from_line)) {
    if (i.from_line <= 0)
      throw new Error(
        `Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(o.from_line)}`
      );
  } else
    throw new Error(
      `Invalid Option: from_line must be an integer, got ${JSON.stringify(o.from_line)}`
    );
  if (i.ignore_last_delimiters === void 0 || i.ignore_last_delimiters === null)
    i.ignore_last_delimiters = !1;
  else if (typeof i.ignore_last_delimiters == "number")
    i.ignore_last_delimiters = Math.floor(i.ignore_last_delimiters), i.ignore_last_delimiters === 0 && (i.ignore_last_delimiters = !1);
  else if (typeof i.ignore_last_delimiters != "boolean")
    throw new CsvError(
      "CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS",
      [
        "Invalid option `ignore_last_delimiters`:",
        "the value must be a boolean value or an integer,",
        `got ${JSON.stringify(i.ignore_last_delimiters)}`
      ],
      i
    );
  if (i.ignore_last_delimiters === !0 && i.columns === !1)
    throw new CsvError(
      "CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS",
      [
        "The option `ignore_last_delimiters`",
        "requires the activation of the `columns` option"
      ],
      i
    );
  if (i.info === void 0 || i.info === null || i.info === !1)
    i.info = !1;
  else if (i.info !== !0)
    throw new Error(
      `Invalid Option: info must be true, got ${JSON.stringify(i.info)}`
    );
  if (i.max_record_size === void 0 || i.max_record_size === null || i.max_record_size === !1)
    i.max_record_size = 0;
  else if (!(Number.isInteger(i.max_record_size) && i.max_record_size >= 0))
    if (typeof i.max_record_size == "string" && /\d+/.test(i.max_record_size))
      i.max_record_size = parseInt(i.max_record_size);
    else
      throw new Error(
        `Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(i.max_record_size)}`
      );
  if (i.objname === void 0 || i.objname === null || i.objname === !1)
    i.objname = void 0;
  else if (isBuffer(i.objname)) {
    if (i.objname.length === 0)
      throw new Error("Invalid Option: objname must be a non empty buffer");
    i.encoding === null || (i.objname = i.objname.toString(i.encoding));
  } else if (typeof i.objname == "string") {
    if (i.objname.length === 0)
      throw new Error("Invalid Option: objname must be a non empty string");
  } else if (typeof i.objname != "number")
    throw new Error(
      `Invalid Option: objname must be a string or a buffer, got ${i.objname}`
    );
  if (i.objname !== void 0) {
    if (typeof i.objname == "number") {
      if (i.columns !== !1)
        throw Error(
          "Invalid Option: objname index cannot be combined with columns or be defined as a field"
        );
    } else if (i.columns === !1)
      throw Error(
        "Invalid Option: objname field must be combined with columns or be defined as an index"
      );
  }
  if (i.on_record === void 0 || i.on_record === null)
    i.on_record = void 0;
  else if (typeof i.on_record != "function")
    throw new CsvError(
      "CSV_INVALID_OPTION_ON_RECORD",
      [
        "Invalid option `on_record`:",
        "expect a function,",
        `got ${JSON.stringify(i.on_record)}`
      ],
      i
    );
  if (i.on_skip !== void 0 && i.on_skip !== null && typeof i.on_skip != "function")
    throw new Error(
      `Invalid Option: on_skip must be a function, got ${JSON.stringify(i.on_skip)}`
    );
  if (i.quote === null || i.quote === !1 || i.quote === "")
    i.quote = null;
  else if (i.quote === void 0 || i.quote === !0 ? i.quote = Buffer$1.from('"', i.encoding) : typeof i.quote == "string" && (i.quote = Buffer$1.from(i.quote, i.encoding)), !isBuffer(i.quote))
    throw new Error(
      `Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(i.quote)}`
    );
  if (i.raw === void 0 || i.raw === null || i.raw === !1)
    i.raw = !1;
  else if (i.raw !== !0)
    throw new Error(
      `Invalid Option: raw must be true, got ${JSON.stringify(i.raw)}`
    );
  if (i.record_delimiter === void 0)
    i.record_delimiter = [];
  else if (typeof i.record_delimiter == "string" || isBuffer(i.record_delimiter)) {
    if (i.record_delimiter.length === 0)
      throw new CsvError(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a non empty string or buffer,",
          `got ${JSON.stringify(i.record_delimiter)}`
        ],
        i
      );
    i.record_delimiter = [i.record_delimiter];
  } else if (!Array.isArray(i.record_delimiter))
    throw new CsvError(
      "CSV_INVALID_OPTION_RECORD_DELIMITER",
      [
        "Invalid option `record_delimiter`:",
        "value must be a string, a buffer or array of string|buffer,",
        `got ${JSON.stringify(i.record_delimiter)}`
      ],
      i
    );
  if (i.record_delimiter = i.record_delimiter.map(function(r, s) {
    if (typeof r != "string" && !isBuffer(r))
      throw new CsvError(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a string, a buffer or array of string|buffer",
          `at index ${s},`,
          `got ${JSON.stringify(r)}`
        ],
        i
      );
    if (r.length === 0)
      throw new CsvError(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a non empty string or buffer",
          `at index ${s},`,
          `got ${JSON.stringify(r)}`
        ],
        i
      );
    return typeof r == "string" && (r = Buffer$1.from(r, i.encoding)), r;
  }), typeof i.relax_column_count != "boolean")
    if (i.relax_column_count === void 0 || i.relax_column_count === null)
      i.relax_column_count = !1;
    else
      throw new Error(
        `Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(i.relax_column_count)}`
      );
  if (typeof i.relax_column_count_less != "boolean")
    if (i.relax_column_count_less === void 0 || i.relax_column_count_less === null)
      i.relax_column_count_less = !1;
    else
      throw new Error(
        `Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(i.relax_column_count_less)}`
      );
  if (typeof i.relax_column_count_more != "boolean")
    if (i.relax_column_count_more === void 0 || i.relax_column_count_more === null)
      i.relax_column_count_more = !1;
    else
      throw new Error(
        `Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(i.relax_column_count_more)}`
      );
  if (typeof i.relax_quotes != "boolean")
    if (i.relax_quotes === void 0 || i.relax_quotes === null)
      i.relax_quotes = !1;
    else
      throw new Error(
        `Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(i.relax_quotes)}`
      );
  if (typeof i.skip_empty_lines != "boolean")
    if (i.skip_empty_lines === void 0 || i.skip_empty_lines === null)
      i.skip_empty_lines = !1;
    else
      throw new Error(
        `Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(i.skip_empty_lines)}`
      );
  if (typeof i.skip_records_with_empty_values != "boolean")
    if (i.skip_records_with_empty_values === void 0 || i.skip_records_with_empty_values === null)
      i.skip_records_with_empty_values = !1;
    else
      throw new Error(
        `Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(i.skip_records_with_empty_values)}`
      );
  if (typeof i.skip_records_with_error != "boolean")
    if (i.skip_records_with_error === void 0 || i.skip_records_with_error === null)
      i.skip_records_with_error = !1;
    else
      throw new Error(
        `Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(i.skip_records_with_error)}`
      );
  if (i.rtrim === void 0 || i.rtrim === null || i.rtrim === !1)
    i.rtrim = !1;
  else if (i.rtrim !== !0)
    throw new Error(
      `Invalid Option: rtrim must be a boolean, got ${JSON.stringify(i.rtrim)}`
    );
  if (i.ltrim === void 0 || i.ltrim === null || i.ltrim === !1)
    i.ltrim = !1;
  else if (i.ltrim !== !0)
    throw new Error(
      `Invalid Option: ltrim must be a boolean, got ${JSON.stringify(i.ltrim)}`
    );
  if (i.trim === void 0 || i.trim === null || i.trim === !1)
    i.trim = !1;
  else if (i.trim !== !0)
    throw new Error(
      `Invalid Option: trim must be a boolean, got ${JSON.stringify(i.trim)}`
    );
  if (i.trim === !0 && o.ltrim !== !1 ? i.ltrim = !0 : i.ltrim !== !0 && (i.ltrim = !1), i.trim === !0 && o.rtrim !== !1 ? i.rtrim = !0 : i.rtrim !== !0 && (i.rtrim = !1), i.to === void 0 || i.to === null)
    i.to = -1;
  else if (typeof i.to == "string" && /\d+/.test(i.to) && (i.to = parseInt(i.to)), Number.isInteger(i.to)) {
    if (i.to <= 0)
      throw new Error(
        `Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(o.to)}`
      );
  } else
    throw new Error(
      `Invalid Option: to must be an integer, got ${JSON.stringify(o.to)}`
    );
  if (i.to_line === void 0 || i.to_line === null)
    i.to_line = -1;
  else if (typeof i.to_line == "string" && /\d+/.test(i.to_line) && (i.to_line = parseInt(i.to_line)), Number.isInteger(i.to_line)) {
    if (i.to_line <= 0)
      throw new Error(
        `Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(o.to_line)}`
      );
  } else
    throw new Error(
      `Invalid Option: to_line must be an integer, got ${JSON.stringify(o.to_line)}`
    );
  return i;
}, isRecordEmpty = function(o) {
  return o.every(
    (i) => i == null || i.toString && i.toString().trim() === ""
  );
}, cr = 13, nl = 10, boms = {
  utf8: Buffer$1.from([239, 187, 191]),
  utf16le: Buffer$1.from([255, 254])
}, transform = function(o = {}) {
  const i = {
    bytes: 0,
    comment_lines: 0,
    empty_lines: 0,
    invalid_field_length: 0,
    lines: 1,
    records: 0
  }, e = normalize_options(o);
  return {
    info: i,
    original_options: o,
    options: e,
    state: init_state(e),
    __needMoreData: function(r, s, a) {
      if (a)
        return !1;
      const { encoding: c, escape: l, quote: h } = this.options, { quoting: d, needMoreDataSize: f, recordDelimiterMaxLength: p } = this.state, m = s - r - 1, y = Math.max(
        f,
        p === 0 ? Buffer$1.from(`\r
`, c).length : p,
        d ? (l === null ? 0 : l.length) + h.length : 0,
        d ? h.length + p : 0
      );
      return m < y;
    },
    parse: function(r, s, a, c) {
      const {
        bom: l,
        comment_no_infix: h,
        encoding: d,
        from_line: f,
        ltrim: p,
        max_record_size: m,
        raw: y,
        relax_quotes: x,
        rtrim: v,
        skip_empty_lines: S,
        to: E,
        to_line: b
      } = this.options;
      let { comment: w, escape: M, quote: P, record_delimiter: D } = this.options;
      const { bomSkipped: L, previousBuf: O, rawBuffer: F, escapeIsQuote: k } = this.state;
      let V;
      if (O === void 0)
        if (r === void 0) {
          c();
          return;
        } else
          V = r;
      else
        O !== void 0 && r === void 0 ? V = O : V = Buffer$1.concat([O, r]);
      if (L === !1)
        if (l === !1)
          this.state.bomSkipped = !0;
        else if (V.length < 3) {
          if (s === !1) {
            this.state.previousBuf = V;
            return;
          }
        } else {
          for (const z in boms)
            if (boms[z].compare(V, 0, boms[z].length) === 0) {
              const $ = boms[z].length;
              this.state.bufBytesStart += $, V = V.slice($), this.options = normalize_options({
                ...this.original_options,
                encoding: z
              }), { comment: w, escape: M, quote: P } = this.options;
              break;
            }
          this.state.bomSkipped = !0;
        }
      const N = V.length;
      let U;
      for (U = 0; U < N && !this.__needMoreData(U, N, s); U++) {
        if (this.state.wasRowDelimiter === !0 && (this.info.lines++, this.state.wasRowDelimiter = !1), b !== -1 && this.info.lines > b) {
          this.state.stop = !0, c();
          return;
        }
        this.state.quoting === !1 && D.length === 0 && this.__autoDiscoverRecordDelimiter(
          V,
          U
        ) && (D = this.options.record_delimiter);
        const z = V[U];
        if (y === !0 && F.append(z), (z === cr || z === nl) && this.state.wasRowDelimiter === !1 && (this.state.wasRowDelimiter = !0), this.state.escaping === !0)
          this.state.escaping = !1;
        else {
          if (M !== null && this.state.quoting === !0 && this.__isEscape(V, U, z) && U + M.length < N)
            if (k) {
              if (this.__isQuote(V, U + M.length)) {
                this.state.escaping = !0, U += M.length - 1;
                continue;
              }
            } else {
              this.state.escaping = !0, U += M.length - 1;
              continue;
            }
          if (this.state.commenting === !1 && this.__isQuote(V, U))
            if (this.state.quoting === !0) {
              const j = V[U + P.length], Y = v && this.__isCharTrimable(V, U + P.length), H = w !== null && this.__compareBytes(w, V, U + P.length, j), W = this.__isDelimiter(
                V,
                U + P.length,
                j
              ), q = D.length === 0 ? this.__autoDiscoverRecordDelimiter(V, U + P.length) : this.__isRecordDelimiter(j, V, U + P.length);
              if (M !== null && this.__isEscape(V, U, z) && this.__isQuote(V, U + M.length))
                U += M.length - 1;
              else if (!j || W || q || H || Y) {
                this.state.quoting = !1, this.state.wasQuoting = !0, U += P.length - 1;
                continue;
              } else if (x === !1) {
                const Z = this.__error(
                  new CsvError(
                    "CSV_INVALID_CLOSING_QUOTE",
                    [
                      "Invalid Closing Quote:",
                      `got "${String.fromCharCode(j)}"`,
                      `at line ${this.info.lines}`,
                      "instead of delimiter, record delimiter, trimable character",
                      "(if activated) or comment"
                    ],
                    this.options,
                    this.__infoField()
                  )
                );
                if (Z !== void 0)
                  return Z;
              } else
                this.state.quoting = !1, this.state.wasQuoting = !0, this.state.field.prepend(P), U += P.length - 1;
            } else if (this.state.field.length !== 0) {
              if (x === !1) {
                const j = this.__infoField(), Y = Object.keys(boms).map(
                  (W) => boms[W].equals(this.state.field.toString()) ? W : !1
                ).filter(Boolean)[0], H = this.__error(
                  new CsvError(
                    "INVALID_OPENING_QUOTE",
                    [
                      "Invalid Opening Quote:",
                      `a quote is found on field ${JSON.stringify(j.column)} at line ${j.lines}, value is ${JSON.stringify(this.state.field.toString(d))}`,
                      Y ? `(${Y} bom)` : void 0
                    ],
                    this.options,
                    j,
                    {
                      field: this.state.field
                    }
                  )
                );
                if (H !== void 0)
                  return H;
              }
            } else {
              this.state.quoting = !0, U += P.length - 1;
              continue;
            }
          if (this.state.quoting === !1) {
            const j = this.__isRecordDelimiter(
              z,
              V,
              U
            );
            if (j !== 0) {
              if (this.state.commenting && this.state.wasQuoting === !1 && this.state.record.length === 0 && this.state.field.length === 0)
                this.info.comment_lines++;
              else {
                if (this.state.enabled === !1 && this.info.lines + (this.state.wasRowDelimiter === !0 ? 1 : 0) >= f) {
                  this.state.enabled = !0, this.__resetField(), this.__resetRecord(), U += j - 1;
                  continue;
                }
                if (S === !0 && this.state.wasQuoting === !1 && this.state.record.length === 0 && this.state.field.length === 0) {
                  this.info.empty_lines++, U += j - 1;
                  continue;
                }
                this.info.bytes = this.state.bufBytesStart + U;
                const W = this.__onField();
                if (W !== void 0)
                  return W;
                this.info.bytes = this.state.bufBytesStart + U + j;
                const q = this.__onRecord(a);
                if (q !== void 0)
                  return q;
                if (E !== -1 && this.info.records >= E) {
                  this.state.stop = !0, c();
                  return;
                }
              }
              this.state.commenting = !1, U += j - 1;
              continue;
            }
            if (this.state.commenting)
              continue;
            if (w !== null && (h === !1 || this.state.record.length === 0 && this.state.field.length === 0) && this.__compareBytes(w, V, U, z) !== 0) {
              this.state.commenting = !0;
              continue;
            }
            const Y = this.__isDelimiter(V, U, z);
            if (Y !== 0) {
              this.info.bytes = this.state.bufBytesStart + U;
              const H = this.__onField();
              if (H !== void 0)
                return H;
              U += Y - 1;
              continue;
            }
          }
        }
        if (this.state.commenting === !1 && m !== 0 && this.state.record_length + this.state.field.length > m)
          return this.__error(
            new CsvError(
              "CSV_MAX_RECORD_SIZE",
              [
                "Max Record Size:",
                "record exceed the maximum number of tolerated bytes",
                `of ${m}`,
                `at line ${this.info.lines}`
              ],
              this.options,
              this.__infoField()
            )
          );
        const $ = p === !1 || this.state.quoting === !0 || this.state.field.length !== 0 || !this.__isCharTrimable(V, U), G = v === !1 || this.state.wasQuoting === !1;
        if ($ === !0 && G === !0)
          this.state.field.append(z);
        else {
          if (v === !0 && !this.__isCharTrimable(V, U))
            return this.__error(
              new CsvError(
                "CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE",
                [
                  "Invalid Closing Quote:",
                  "found non trimable byte after quote",
                  `at line ${this.info.lines}`
                ],
                this.options,
                this.__infoField()
              )
            );
          $ === !1 && (U += this.__isCharTrimable(V, U) - 1);
          continue;
        }
      }
      if (s === !0)
        if (this.state.quoting === !0) {
          const z = this.__error(
            new CsvError(
              "CSV_QUOTE_NOT_CLOSED",
              [
                "Quote Not Closed:",
                `the parsing is finished with an opening quote at line ${this.info.lines}`
              ],
              this.options,
              this.__infoField()
            )
          );
          if (z !== void 0)
            return z;
        } else if (this.state.wasQuoting === !0 || this.state.record.length !== 0 || this.state.field.length !== 0) {
          this.info.bytes = this.state.bufBytesStart + U;
          const z = this.__onField();
          if (z !== void 0)
            return z;
          const $ = this.__onRecord(a);
          if ($ !== void 0)
            return $;
        } else
          this.state.wasRowDelimiter === !0 ? this.info.empty_lines++ : this.state.commenting === !0 && this.info.comment_lines++;
      else
        this.state.bufBytesStart += U, this.state.previousBuf = V.slice(U);
      this.state.wasRowDelimiter === !0 && (this.info.lines++, this.state.wasRowDelimiter = !1);
    },
    __onRecord: function(r) {
      const {
        columns: s,
        group_columns_by_name: a,
        encoding: c,
        info: l,
        from: h,
        relax_column_count: d,
        relax_column_count_less: f,
        relax_column_count_more: p,
        raw: m,
        skip_records_with_empty_values: y
      } = this.options, { enabled: x, record: v } = this.state;
      if (x === !1)
        return this.__resetRecord();
      const S = v.length;
      if (s === !0) {
        if (y === !0 && isRecordEmpty(v)) {
          this.__resetRecord();
          return;
        }
        return this.__firstLineToColumns(v);
      }
      if (s === !1 && this.info.records === 0 && (this.state.expectedRecordLength = S), S !== this.state.expectedRecordLength) {
        const E = s === !1 ? new CsvError(
          "CSV_RECORD_INCONSISTENT_FIELDS_LENGTH",
          [
            "Invalid Record Length:",
            `expect ${this.state.expectedRecordLength},`,
            `got ${S} on line ${this.info.lines}`
          ],
          this.options,
          this.__infoField(),
          {
            record: v
          }
        ) : new CsvError(
          "CSV_RECORD_INCONSISTENT_COLUMNS",
          [
            "Invalid Record Length:",
            `columns length is ${s.length},`,
            `got ${S} on line ${this.info.lines}`
          ],
          this.options,
          this.__infoField(),
          {
            record: v
          }
        );
        if (d === !0 || f === !0 && S < this.state.expectedRecordLength || p === !0 && S > this.state.expectedRecordLength)
          this.info.invalid_field_length++, this.state.error = E;
        else {
          const b = this.__error(E);
          if (b)
            return b;
        }
      }
      if (y === !0 && isRecordEmpty(v)) {
        this.__resetRecord();
        return;
      }
      if (this.state.recordHasError === !0) {
        this.__resetRecord(), this.state.recordHasError = !1;
        return;
      }
      if (this.info.records++, h === 1 || this.info.records >= h) {
        const { objname: E } = this.options;
        if (s !== !1) {
          const b = {};
          for (let w = 0, M = v.length; w < M; w++)
            s[w] === void 0 || s[w].disabled || (a === !0 && b[s[w].name] !== void 0 ? Array.isArray(b[s[w].name]) ? b[s[w].name] = b[s[w].name].concat(v[w]) : b[s[w].name] = [b[s[w].name], v[w]] : b[s[w].name] = v[w]);
          if (m === !0 || l === !0) {
            const w = Object.assign(
              { record: b },
              m === !0 ? { raw: this.state.rawBuffer.toString(c) } : {},
              l === !0 ? { info: this.__infoRecord() } : {}
            ), M = this.__push(
              E === void 0 ? w : [b[E], w],
              r
            );
            if (M)
              return M;
          } else {
            const w = this.__push(
              E === void 0 ? b : [b[E], b],
              r
            );
            if (w)
              return w;
          }
        } else if (m === !0 || l === !0) {
          const b = Object.assign(
            { record: v },
            m === !0 ? { raw: this.state.rawBuffer.toString(c) } : {},
            l === !0 ? { info: this.__infoRecord() } : {}
          ), w = this.__push(
            E === void 0 ? b : [v[E], b],
            r
          );
          if (w)
            return w;
        } else {
          const b = this.__push(
            E === void 0 ? v : [v[E], v],
            r
          );
          if (b)
            return b;
        }
      }
      this.__resetRecord();
    },
    __firstLineToColumns: function(r) {
      const { firstLineToHeaders: s } = this.state;
      try {
        const a = s === void 0 ? r : s.call(null, r);
        if (!Array.isArray(a))
          return this.__error(
            new CsvError(
              "CSV_INVALID_COLUMN_MAPPING",
              [
                "Invalid Column Mapping:",
                "expect an array from column function,",
                `got ${JSON.stringify(a)}`
              ],
              this.options,
              this.__infoField(),
              {
                headers: a
              }
            )
          );
        const c = normalize_columns_array(a);
        this.state.expectedRecordLength = c.length, this.options.columns = c, this.__resetRecord();
        return;
      } catch (a) {
        return a;
      }
    },
    __resetRecord: function() {
      this.options.raw === !0 && this.state.rawBuffer.reset(), this.state.error = void 0, this.state.record = [], this.state.record_length = 0;
    },
    __onField: function() {
      const { cast: r, encoding: s, rtrim: a, max_record_size: c } = this.options, { enabled: l, wasQuoting: h } = this.state;
      if (l === !1)
        return this.__resetField();
      let d = this.state.field.toString(s);
      if (a === !0 && h === !1 && (d = d.trimRight()), r === !0) {
        const [f, p] = this.__cast(d);
        if (f !== void 0)
          return f;
        d = p;
      }
      this.state.record.push(d), c !== 0 && typeof d == "string" && (this.state.record_length += d.length), this.__resetField();
    },
    __resetField: function() {
      this.state.field.reset(), this.state.wasQuoting = !1;
    },
    __push: function(r, s) {
      const { on_record: a } = this.options;
      if (a !== void 0) {
        const c = this.__infoRecord();
        try {
          r = a.call(null, r, c);
        } catch (l) {
          return l;
        }
        if (r == null)
          return;
      }
      s(r);
    },
    __cast: function(r) {
      const { columns: s, relax_column_count: a } = this.options;
      if (Array.isArray(s) === !0 && a && this.options.columns.length <= this.state.record.length)
        return [void 0, void 0];
      if (this.state.castField !== null)
        try {
          const l = this.__infoField();
          return [void 0, this.state.castField.call(null, r, l)];
        } catch (l) {
          return [l];
        }
      if (this.__isFloat(r))
        return [void 0, parseFloat(r)];
      if (this.options.cast_date !== !1) {
        const l = this.__infoField();
        return [void 0, this.options.cast_date.call(null, r, l)];
      }
      return [void 0, r];
    },
    __isCharTrimable: function(r, s) {
      return ((c, l) => {
        const { timchars: h } = this.state;
        e:
          for (let d = 0; d < h.length; d++) {
            const f = h[d];
            for (let p = 0; p < f.length; p++)
              if (f[p] !== c[l + p])
                continue e;
            return f.length;
          }
        return 0;
      })(r, s);
    },
    __isFloat: function(r) {
      return r - parseFloat(r) + 1 >= 0;
    },
    __compareBytes: function(r, s, a, c) {
      if (r[0] !== c)
        return 0;
      const l = r.length;
      for (let h = 1; h < l; h++)
        if (r[h] !== s[a + h])
          return 0;
      return l;
    },
    __isDelimiter: function(r, s, a) {
      const { delimiter: c, ignore_last_delimiters: l } = this.options;
      if (l === !0 && this.state.record.length === this.options.columns.length - 1)
        return 0;
      if (l !== !1 && typeof l == "number" && this.state.record.length === l - 1)
        return 0;
      e:
        for (let h = 0; h < c.length; h++) {
          const d = c[h];
          if (d[0] === a) {
            for (let f = 1; f < d.length; f++)
              if (d[f] !== r[s + f])
                continue e;
            return d.length;
          }
        }
      return 0;
    },
    __isRecordDelimiter: function(r, s, a) {
      const { record_delimiter: c } = this.options, l = c.length;
      e:
        for (let h = 0; h < l; h++) {
          const d = c[h], f = d.length;
          if (d[0] === r) {
            for (let p = 1; p < f; p++)
              if (d[p] !== s[a + p])
                continue e;
            return d.length;
          }
        }
      return 0;
    },
    __isEscape: function(r, s, a) {
      const { escape: c } = this.options;
      if (c === null)
        return !1;
      const l = c.length;
      if (c[0] === a) {
        for (let h = 0; h < l; h++)
          if (c[h] !== r[s + h])
            return !1;
        return !0;
      }
      return !1;
    },
    __isQuote: function(r, s) {
      const { quote: a } = this.options;
      if (a === null)
        return !1;
      const c = a.length;
      for (let l = 0; l < c; l++)
        if (a[l] !== r[s + l])
          return !1;
      return !0;
    },
    __autoDiscoverRecordDelimiter: function(r, s) {
      const { encoding: a } = this.options, c = [
        Buffer$1.from(`\r
`, a),
        Buffer$1.from(`
`, a),
        Buffer$1.from("\r", a)
      ];
      e:
        for (let l = 0; l < c.length; l++) {
          const h = c[l].length;
          for (let d = 0; d < h; d++)
            if (c[l][d] !== r[s + d])
              continue e;
          return this.options.record_delimiter.push(c[l]), this.state.recordDelimiterMaxLength = c[l].length, c[l].length;
        }
      return 0;
    },
    __error: function(r) {
      const { encoding: s, raw: a, skip_records_with_error: c } = this.options, l = typeof r == "string" ? new Error(r) : r;
      if (c) {
        this.state.recordHasError = !0, this.options.on_skip !== void 0 && this.options.on_skip(
          l,
          a ? this.state.rawBuffer.toString(s) : void 0
        );
        return;
      } else
        return l;
    },
    __infoDataSet: function() {
      return {
        ...this.info,
        columns: this.options.columns
      };
    },
    __infoRecord: function() {
      const { columns: r, raw: s, encoding: a } = this.options;
      return {
        ...this.__infoDataSet(),
        error: this.state.error,
        header: r === !0,
        index: this.state.record.length,
        raw: s ? this.state.rawBuffer.toString(a) : void 0
      };
    },
    __infoField: function() {
      const { columns: r } = this.options, s = Array.isArray(r);
      return {
        ...this.__infoRecord(),
        column: s === !0 ? r.length > this.state.record.length ? r[this.state.record.length].name : null : this.state.record.length,
        quoting: this.state.wasQuoting
      };
    }
  };
}, parse = function(o, i = {}) {
  typeof o == "string" && (o = Buffer$1.from(o));
  const e = i && i.objname ? {} : [], r = transform(i), s = (h) => {
    r.options.objname === void 0 ? e.push(h) : e[h[0]] = h[1];
  }, a = () => {
  }, c = r.parse(o, !1, s, a);
  if (c !== void 0)
    throw c;
  const l = r.parse(void 0, !0, s, a);
  if (l !== void 0)
    throw l;
  return e;
}, lt = class extends JSONDataSource {
  constructor(i) {
    super(i), this.type = "CSVDataSource";
  }
  async _convertStreamingDataToObjectData(i) {
    return await i.text();
  }
  _convertObjectDataToJSONData(i) {
    return parse(i, {
      columns: !0,
      skip_empty_lines: !0
    });
  }
};
let CSVDataSource = lt;
_(CSVDataSource, "fromURL", async function(i, e) {
  let r = new lt(e);
  return await r.load(i), r;
}), _(CSVDataSource, "fromUrl", async function(i, e) {
  return console.warn("CSVDataSource.fromUrl is deprecated, please use CSVDataSource.fromURL instead."), await this.fromURL(i, e);
}), _(CSVDataSource, "fromCSVString", function(i, e) {
  let r = new lt(e);
  return r.setData(i), r;
});
new Euler(0, 0, 0, "ZXY");
new Vector3$1();
const _changeEvent = { type: "change" }, _lockEvent = { type: "lock" }, _unlockEvent = { type: "unlock" };
class PointerLockControls extends EventDispatcher {
  constructor(i, e) {
    super(), e === void 0 && (console.warn('THREE.PointerLockControls: The second parameter "domElement" is now mandatory.'), e = document.body), this.domElement = e, this.camera = i, this.isLocked = !1, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1;
    const r = this;
    function s(l) {
      r.isLocked !== !1 && (r.controller && r.controller.handleMouseMove(r.camera, l), r.dispatchEvent(_changeEvent));
    }
    function a() {
      r.domElement.ownerDocument.pointerLockElement === r.domElement ? (r.dispatchEvent(_lockEvent), r.isLocked = !0) : (r.dispatchEvent(_unlockEvent), r.isLocked = !1);
    }
    function c() {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }
    this.connect = function() {
      r.domElement.ownerDocument.addEventListener("mousemove", s), r.domElement.ownerDocument.addEventListener("pointerlockchange", a), r.domElement.ownerDocument.addEventListener("pointerlockerror", c);
    }, this.disconnect = function() {
      r.domElement.ownerDocument.removeEventListener("mousemove", s), r.domElement.ownerDocument.removeEventListener("pointerlockchange", a), r.domElement.ownerDocument.removeEventListener("pointerlockerror", c);
    }, this.dispose = function() {
      this.disconnect();
    }, this.getObject = function() {
      return i;
    }, this.getDirection = function() {
      const l = new Vector3$1(0, 0, -1);
      return function(h) {
        return h.copy(l).applyQuaternion(i.quaternion);
      };
    }(), this.moveForward = function(l) {
      this.controller && this.controller.moveForward(this.camera, l);
    }, this.moveRight = function(l) {
      this.controller && this.controller.moveRight(this.camera, l);
    }, this.moveUp = function(l) {
      this.controller && this.controller.moveUp(this.camera, l);
    }, this.lock = function() {
      this.domElement.requestPointerLock();
    }, this.unlock = function() {
      r.domElement.ownerDocument.exitPointerLock();
    }, this.connect();
  }
}
class Scene3DController {
  constructor(i, e = 1) {
    this.ellipsoidCamera = i, this.pointerSpeed = e;
  }
  handleMouseMove(i, e) {
    const r = e.movementX || e.mozMovementX || e.webkitMovementX || 0, s = e.movementY || e.mozMovementY || e.webkitMovementY || 0, a = 2e-3 * this.pointerSpeed;
    r > 0 && this.ellipsoidCamera.lookRight(r * a), r < 0 && this.ellipsoidCamera.lookLeft(-r * a), s > 0 && this.ellipsoidCamera.lookDown(s * a), s < 0 && this.ellipsoidCamera.lookUp(-s * a);
  }
  moveForward(i, e) {
    this.ellipsoidCamera.moveForward(e);
  }
  moveRight(i, e) {
    this.ellipsoidCamera.moveRight(e);
  }
  moveUp(i, e) {
    this.ellipsoidCamera.moveUp(e);
  }
}
const _euler = new Euler(0, 0, 0, "ZXY"), _vector = new Vector3$1(), _PI_2 = Math.PI / 2;
class ColumbusController {
  constructor(i = 1) {
    this.pointerSpeed = i, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI;
  }
  handleMouseMove(i, e) {
    const r = e.movementX || e.mozMovementX || e.webkitMovementX || 0, s = e.movementY || e.mozMovementY || e.webkitMovementY || 0, a = 2e-3 * this.pointerSpeed;
    _euler.setFromQuaternion(i.quaternion), _euler.z -= r * a, _euler.x -= s * a, _euler.x = Math.max(_PI_2 - this.maxPolarAngle, Math.min(_PI_2 - this.minPolarAngle, _euler.x)), i.quaternion.setFromEuler(_euler);
  }
  moveForward(i, e) {
    _vector.setFromMatrixColumn(i.matrix, 0), _vector.crossVectors(i.up, _vector), i.position.addScaledVector(_vector, e);
  }
  moveRight(i, e) {
    _vector.setFromMatrixColumn(i.matrix, 0), i.position.addScaledVector(_vector, e);
  }
  moveUp(i, e) {
    i.position.z += e;
  }
}
class PointerLockControl extends PointerLockControls {
  constructor(e) {
    super(e.camera, e.map.container);
    _(this, "_enableKeyboardEvent", !1);
    _(this, "_moveForward", !1);
    _(this, "_moveBackward", !1);
    _(this, "_moveLeft", !1);
    _(this, "_moveRight", !1);
    _(this, "_moveTop", !1);
    _(this, "_moveBottom", !1);
    _(this, "_prevTime");
    _(this, "_velocity", new Vector3$1());
    _(this, "_direction", new Vector3$1());
    _(this, "handleKeyDownEvent", (e) => {
      switch (e.keyCode) {
        case 87:
          this._moveForward = !0;
          break;
        case 83:
          this._moveBackward = !0;
          break;
        case 65:
          this._moveLeft = !0;
          break;
        case 68:
          this._moveRight = !0;
          break;
        case 81:
          this._moveTop = !0;
          break;
        case 69:
          this._moveBottom = !0;
          break;
        case 76:
          !this.isLocked && this.lock();
      }
    });
    _(this, "animationMove", () => {
      if (!this._enableKeyboardEvent)
        return;
      const e = performance.now();
      requestAnimationFrame(this.animationMove);
      const r = (e - this._prevTime) / 1e3;
      this._velocity.x -= this._velocity.x * 10 * r, this._velocity.z -= this._velocity.z * 10 * r, this._velocity.y -= this._velocity.y * 10 * r, this._direction.z = Number(this._moveForward) - Number(this._moveBackward), this._direction.x = Number(this._moveRight) - Number(this._moveLeft), this._direction.y = Number(this._moveTop) - Number(this._moveBottom), this._direction.normalize(), (this._moveForward || this._moveBackward) && (this._velocity.z -= this._direction.z * this.forwardStepSize * r), (this._moveLeft || this._moveRight) && (this._velocity.x -= this._direction.x * this.rightStepSize * r), (this._moveTop || this._moveBottom) && (this._velocity.y -= this._direction.y * this.topStepSize * r), this.moveRight(-this._velocity.x), this.moveForward(-this._velocity.z), this.moveUp(-this._velocity.y), this._prevTime = e;
    });
    _(this, "handleKeyUpEvent", (e) => {
      switch (e.keyCode) {
        case 87:
          this._moveForward = !1;
          break;
        case 83:
          this._moveBackward = !1;
          break;
        case 65:
          this._moveLeft = !1;
          break;
        case 68:
          this._moveRight = !1;
          break;
        case 81:
          this._moveTop = !1;
          break;
        case 69:
          this._moveBottom = !1;
          break;
      }
    });
    this._engine = e, this.isGlobe = e.map.isGlobe, this._engine.camera.up.set(0, 0, 1), this.stepSize = 10, this.controller = this.createController(), this.addEventListener("change", (r) => {
      e.requestRender();
    });
  }
  createController() {
    if (this.isGlobe) {
      const e = this._engine.map.map._ellipsoidCamera;
      return new Scene3DController(e);
    }
    return new ColumbusController();
  }
  dispose() {
    super.dispose(), this.enableKeyboardEvent = !1;
  }
  get forwardStepSize() {
    return this._forwardStepSize;
  }
  set forwardStepSize(e) {
    this._forwardStepSize = e;
  }
  get rightStepSize() {
    return this._rightStepSize;
  }
  set rightStepSize(e) {
    this._rightStepSize = e;
  }
  get topStepSize() {
    return this._topStepSize;
  }
  set topStepSize(e) {
    this._topStepSize = e;
  }
  set stepSize(e) {
    this.forwardStepSize = e, this.rightStepSize = e, this.topStepSize = e;
  }
  set enableKeyboardEvent(e) {
    e !== this._enableKeyboardEvent && (this._enableKeyboardEvent = e, e ? (this._prevTime = performance.now(), requestAnimationFrame(this.animationMove), window.addEventListener("keydown", this.handleKeyDownEvent), window.addEventListener("keyup", this.handleKeyUpEvent)) : (window.removeEventListener("keydown", this.handleKeyDownEvent), window.removeEventListener("keyup", this.handleKeyUpEvent)));
  }
}
const VIEW_MODEL_MAP = {
  FOLLOW: "follow",
  LOCK: "lock",
  UNLOCK: "unlock",
  KEYFRAME: "keyFrame",
  ACTIVEFRAME: "activeFrame"
}, Easing = {
  linear: (o) => o,
  "ease-in": (o) => o * o,
  "ease-out": (o) => o * (2 - o),
  "ease-in-out": (o) => o < 0.5 ? 2 * o * o : -1 + (4 - 2 * o) * o
}, positionScratch$2 = new Vector3$1(), directionScratch = new Vector3$1(), upScratch = new Vector3$1(), rightScratch = new Vector3$1(), scaledPositionScratch = new Vector3$1(), objectEuler = new Euler();
class TrackerAbstract extends Object3D {
  constructor(e = {}) {
    super();
    _(this, "_isRunning", !1);
    _(this, "_isPause", !1);
    _(this, "_pauseTime", 0);
    _(this, "_pauseTimestamp", 0);
    _(this, "_animationStartTime", 0);
    _(this, "_animationDuration", 0);
    _(this, "_animationTransform", {});
    _(this, "_animationCurrenState", null);
    _(this, "_track", null);
    _(this, "_frameInfo", null);
    _(this, "onStart", null);
    _(this, "onFinish", null);
    _(this, "onUpdate", null);
    _(this, "_runtime", {});
    _(this, "_withoutTrack", !1);
    _(this, "_repeatCount", 1);
    _(this, "_completedCount", 0);
    _(this, "_debug", !1);
    _(this, "_trackPoint", null);
    _(this, "_trackLists", []);
    _(this, "_startPoint", null);
    _(this, "_startLists", []);
    _(this, "_stratIndex", -1);
    _(this, "_lockView", !1);
    _(this, "_viewFollow", !0);
    _(this, "_keepRunning", !1);
    _(this, "_easingFn", Easing.linear);
    _(this, "_currentEasingFn", Easing.linear);
    _(this, "update", () => {
      if (!this._isRunning || this._isPause)
        return;
      const r = this._engine.rendering.renderState.time - this._pauseTime - this._animationStartTime;
      if (r < this._delay)
        return;
      const s = r - this._delay;
      let a = 1;
      if (this._animationDuration > 0) {
        const d = s / this._animationDuration;
        if (this._repeatCount === 1 / 0)
          a = d % 1;
        else {
          const f = this._animationDuration * this._repeatCount;
          if (s >= f)
            a = 1;
          else {
            const p = Math.floor(s / this._animationDuration);
            this._completedCount = p, a = s % this._animationDuration / this._animationDuration;
          }
        }
      }
      let c = a;
      this._direction === "reverse" ? c = 1 - a : this._direction === "alternate" ? Math.floor(s / this._animationDuration) % 2 === 1 && (c = 1 - a) : this._direction === "alternate-reverse" && Math.floor(s / this._animationDuration) % 2 === 0 && (c = 1 - a);
      const l = this._currentEasingFn(c), h = this.updatePositionByPercentage(l);
      if (this._animationCurrenState = h, this.updateObject(h), this._updateDebug(h.point), this.viewFollow && this.updateCamera(h), this.onUpdate && h && this.onUpdate(h), this._repeatCount !== 1 / 0) {
        const d = this._animationDuration * this._repeatCount;
        s >= d && this.stop();
      }
    });
    e.easing && (this._easingFn = this._resolveEasing(e.easing), this._currentEasingFn = this._easingFn);
  }
  _resolveEasing(e) {
    return typeof e == "string" && e in Easing ? Easing[e] : typeof e == "function" ? e : (console.warn(`Unknown easing "${e}", fallback to linear`), Easing.linear);
  }
  onBeforeScenePrepareRender(e, r, s, a) {
    this.update();
  }
  afterAddToEngine(e) {
    if (this._engine = e, this._debug) {
      this._trackPoint = e.add(new SimplePoint({
        color: "green",
        size: 8
      }));
      const r = GeoJSONDataSource.fromGeoJSON([]);
      this._trackPoint.dataSource = r, this._startPoint = e.add(new SimplePoint({
        color: "red",
        size: 20
      }));
      const s = GeoJSONDataSource.fromGeoJSON([]);
      this._startPoint.dataSource = s;
    }
  }
  updatePositionByPercentage(e) {
    throw new Error("updatePositionByPercentage method must be implemented by subclass");
  }
  start(e = {}) {
    const {
      duration: r = 1e3,
      heading: s = 0,
      pitch: a = 60,
      range: c = 100,
      easing: l,
      repeatCount: h,
      delay: d = 0,
      direction: f = "normal"
    } = e;
    if (!this._withoutTrack && !this.track)
      return;
    if (this._isPause) {
      this._pauseTime += new Date().valueOf() - this._pauseTimestamp, this._isPause = !1;
      return;
    }
    if (this._isRunning)
      return;
    if (this._debug && (this._stratIndex += 1), this._isRunning = !0, this._animationDuration = r, this._animationTransform = {
      heading: s,
      pitch: a,
      range: c
    }, this._currentEasingFn = l ? this._resolveEasing(l) : this._easingFn, this._frameInfo && this._frameInfo.length && this._frameInfo.every((m) => m.time || m.time === 0)) {
      this._animationTransform = {
        heading: 0,
        pitch: 0,
        range: c
      };
      let m = 0;
      this._frameInfo.forEach((y) => {
        const { time: x } = y;
        m += x;
      }), this._animationDuration = m;
    }
    const p = e.keepRunning ? e.keepRunning : this._keepRunning;
    defined$2(h) ? this._repeatCount = h === 1 / 0 ? 1 / 0 : Math.max(1, h) : this._repeatCount = p ? 1 / 0 : 1, this._completedCount = 0, this._delay = Math.max(0, d), this._direction = f, this._animationStartTime = new Date().getTime(), this.onStart && this.onStart();
  }
  pause() {
    return this._isPause = !0, this._pauseTimestamp = new Date().valueOf(), this._animationCurrenState;
  }
  stop() {
    !this._isRunning || (this._isRunning = !1, this._isPause = !1, this._pauseTimestamp = 0, this._pauseTime = 0, this._animationCurrenState = null, this._arcInfo = {}, this.onFinish && this.onFinish());
  }
  dirUpToHPR(e, r, s) {
    s || (s = new Vector3$1(0, 0, 1));
    const a = this._engine, c = a.map;
    if (c.isGlobe) {
      const m = c.map;
      positionScratch$2.fromArray(c.projectArrayCoordinate(r)), m._ellipsoid.scaleToGeodeticSurface(positionScratch$2, scaledPositionScratch), m._ellipsoid.geodeticSurfaceNormal(scaledPositionScratch, upScratch);
      const y = {
        direction: e,
        up: upScratch
      }, x = a.map.map._ellipsoidCamera, v = {};
      directionUpToHeadingPitchRoll(
        x,
        positionScratch$2,
        y,
        v
      );
      let S = -(v.heading - Math.PI * 2);
      return v.heading = MathUtils.radToDeg(S), v.pitch = MathUtils.radToDeg(v.pitch), v.roll = MathUtils.radToDeg(v.roll), v;
    }
    directionScratch.copy(e), upScratch.copy(s), rightScratch.crossVectors(directionScratch, upScratch);
    const h = getHeading(directionScratch, upScratch), d = getPitch(directionScratch), f = getRoll(directionScratch, upScratch, rightScratch);
    let p = -(h - Math.PI * 2);
    return {
      heading: MathUtils.radToDeg(p),
      pitch: MathUtils.radToDeg(d),
      roll: MathUtils.radToDeg(f)
    };
  }
  updateObject(e) {
    if (!this.object)
      return;
    const r = this._engine.map, { point: s, hpr: a } = e, c = r.projectArrayCoordinate(s);
    this.object.position.fromArray(c);
    const l = r.isGlobe, {
      heading: h,
      pitch: d,
      roll: f
    } = a;
    if (l) {
      const p = {
        heading: Math.PI * 2 - MathUtils.degToRad(h) - Math.PI / 2,
        pitch: MathUtils.degToRad(d),
        roll: MathUtils.degToRad(f)
      };
      positionScratch$2.fromArray(c);
      const m = Transforms.headingPitchRollToFixedFrame(positionScratch$2, p), y = objectEuler.setFromRotationMatrix(m);
      this.object.rotation.x = y.x, this.object.rotation.y = y.y, this.object.rotation.z = y.z;
    } else {
      const p = MathUtils.degToRad(h) + Math.PI / 2, m = MathUtils.degToRad(-d), y = MathUtils.degToRad(f), x = new Euler(y, m, p, "ZXY"), v = new Quaternion$1().setFromEuler(x);
      this.object.quaternion.copy(v);
    }
  }
  updateCamera(e) {
    var h, d;
    const r = this._engine.map, { point: s, hpr: a } = e, c = this._lockView && (h = a == null ? void 0 : a.heading) != null ? h : r.getHeading(), l = this._lockView && (d = a == null ? void 0 : a.pitch) != null ? d : r.getPitch();
    a.heading = c, a.pitch = l, r.mapType === "blank" ? this._computeCameraMatrixBlank(s, a) : this._computeCameraMatrix(s, a);
  }
  _updateDebug(e) {
    if (this._debug) {
      this._trackLists.push(e);
      const r = this._trackLists.map((c) => ({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: c
        }
      }));
      this._trackPoint.dataSource.setData(r), this._startLists[this._stratIndex] || this._startLists.push(e);
      const a = this._startLists.map((c) => ({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: c
        }
      }));
      this._startPoint.dataSource.setData(a);
    }
  }
  distanceToZoom(e) {
    const r = this._engine.map, s = this._engine._container.clientHeight, a = e / (s / 2) * Math.tan(r.fov / 2 * Math.PI / 180);
    return r.getZoomByZoomUnits(a);
  }
  _computeCameraMatrixBlank(e, r) {
    const s = this._animationTransform.range, a = this.distanceToZoom(s);
    let c = r.heading, l = r.pitch;
    if (this.lockView) {
      const {
        heading: h,
        pitch: d
      } = this._animationTransform;
      c = r.heading + h, l = r.pitch + d;
    }
    this._engine.map.lookAt(e, {
      heading: c,
      pitch: l,
      zoom: a
    });
  }
  _computeCameraMatrix(e, r) {
    const s = this._engine, a = this._animationTransform;
    let c = r.heading, l = r.pitch;
    if (this.lockView) {
      const {
        heading: d,
        pitch: f
      } = this._animationTransform;
      c = r.heading + d, l = r.pitch + f;
    }
    const h = a.range;
    s.map.lookAt(e, {
      heading: c,
      pitch: l,
      range: h
    });
  }
  set viewMode(e) {
    switch (this._viewMode = e, e) {
      case VIEW_MODEL_MAP.FOLLOW:
        this.lockView = !1, this.viewFollow = !0;
        break;
      case VIEW_MODEL_MAP.LOCK:
        this.lockView = !0, this.viewFollow = !0;
        break;
      case VIEW_MODEL_MAP.UNLOCK:
        this.lockView = !1, this.viewFollow = !1;
        break;
      default:
        this.lockView = !0, this.viewFollow = !0;
        break;
    }
  }
  get viewMode() {
    return this._viewMode;
  }
  get currentState() {
    return this._animationCurrenState;
  }
  get isRunning() {
    return this._isRunning;
  }
  get isPaused() {
    return this._isPause;
  }
  set lockView(e) {
    this._lockView = e;
  }
  get lockView() {
    return this._lockView;
  }
  set viewFollow(e) {
    this._viewFollow = e;
  }
  get viewFollow() {
    return this._viewFollow;
  }
  set object(e) {
    this._object = e;
  }
  get object() {
    return this._object;
  }
}
class PathTracker extends TrackerAbstract {
  constructor() {
    super(...arguments);
    _(this, "_sampledPath", []);
    _(this, "_arcInfo", {});
    _(this, "_interpolateDirectThreshold", 10);
    _(this, "_interpolateDirectThresholdPercent", 0.4);
  }
  updatePositionByPercentage(e) {
    return !this._sampledPath || this._sampledPath.length === 0 ? void 0 : this._interpolatePath(e);
  }
  _interpolatePath(e) {
    const r = this._sampledPath.length, {
      last: s,
      current: a,
      next: c,
      lastFrame: l,
      currentFrame: h,
      segmentPercent: d,
      isStart: f,
      isEnd: p
    } = this._getSegment(e, r), { isTransition: m, transPercent: y } = this._computeTransition(d, s, a, c, f, p), x = this._updatePositionAndDirection(s, a, d, m, y);
    return this._viewMode === VIEW_MODEL_MAP.KEYFRAME || this._viewMode === VIEW_MODEL_MAP.ACTIVEFRAME ? this._handleFrame(
      l,
      h,
      s,
      a,
      c,
      x.point,
      y,
      d,
      e
    ) : x;
  }
  _handleFrame(e, r, s, a, c, l, h, d, f) {
    const p = this._engine.map;
    let m = p.projectArrayCoordinate(l);
    const y = h / 2;
    let x, v, S, E = {
      heading: 0,
      pitch: 0,
      roll: 0
    };
    switch (this._viewMode) {
      case VIEW_MODEL_MAP.KEYFRAME:
        if (!e || !r)
          break;
        if (e.aim) {
          const { aim: b } = e, w = p.projectArrayCoordinate(b), [M, P, D] = w;
          x = new Vector3$1(M - m[0], P - m[1], D - m[2]).normalize(), E = this.dirUpToHPR(x, l);
        } else
          S = e.yaw + (r.yaw - e.yaw) * y, S = CesiumMath.zeroToTwoPi(S - Math.PI / 2), v = e.pitch + (r.pitch - e.pitch) * y, E.heading = MathUtils.radToDeg(S), E.pitch = MathUtils.radToDeg(v);
        break;
      case VIEW_MODEL_MAP.ACTIVEFRAME:
        if (this._pointHandle === "curve") {
          let b;
          this._frameInfo && this._frameInfo.length && this._frameInfo.every((w) => w.speed) ? b = this.curvePath.getPointAt(f) : b = this.curvePath.getPoint(f), l = this._engine.map.unprojectArrayCoordinate([b.x, b.y, b.z]), m = [b.x, b.y, b.z];
        }
        if (e && r && defined$2(e.yaw) && defined$2(r.yaw))
          S = e.yaw + (r.yaw - e.yaw) * d, S = CesiumMath.zeroToTwoPi(S - Math.PI / 2), v = e.pitch + (r.pitch - e.pitch) * d, E.heading = MathUtils.radToDeg(S), E.pitch = MathUtils.radToDeg(v);
        else {
          if (c) {
            const b = new Vector3$1(...a.direction).normalize(), w = new Vector3$1(...c.direction).normalize();
            x = slerpVectors(b, w, d).normalize();
          } else
            x = new Vector3$1(...a.direction).normalize();
          E = this.dirUpToHPR(x, l);
        }
        break;
    }
    return {
      point: l,
      hpr: E,
      direction: x
    };
  }
  _getSegment(e, r) {
    const s = this._sampledPath.findIndex((p) => p.percent >= e), a = s === 0, c = s === r - 1;
    let l = this._sampledPath[s], h = this._sampledPath[s - 1], d = this._sampledPath[s + 1];
    a && (h = l, l = d);
    const f = (e - h.percent) / (l.percent - h.percent);
    return {
      last: h,
      current: l,
      next: d,
      isStart: a,
      isEnd: c,
      segmentPercent: f,
      lastFrame: this._frameInfo[s - 1],
      currentFrame: this._frameInfo[s]
    };
  }
  _computeTransition(e, r, s, a, c, l) {
    let h = 0, d = !1, f = this._arcInfo.endRatio && e < this._arcInfo.endRatio;
    if (a) {
      const p = s.distance - r.distance, m = a.distance - s.distance, y = Math.min(p, m), x = this.interpolateDirectThreshold / y, v = x < 0.5 ? x : this._interpolateDirectThresholdPercent, S = v * y / p, E = v * y / m;
      if (c || (d = e < S), l || (d = e > 1 - S), d || f) {
        d && (this._arcInfo.line1 = [r.position, s.position, S], this._arcInfo.line2 = [s.position, a.position, E], this._arcInfo.endRatio = E);
        const b = (e - (1 - S)) / S, w = e / this._arcInfo.endRatio, M = d ? b : w;
        h = d ? M : 1 + M;
      }
    } else
      f && (h = 1 + e / this._arcInfo.endRatio);
    return {
      isTransition: d || f,
      transPercent: h
    };
  }
  _updatePositionAndDirection(e, r, s, a, c) {
    const l = this._engine.map, h = intepolateArray3(e.position, r.position, s), d = l.unprojectArrayCoordinate(h), [f, p, m] = r.position, [y, x, v] = e.position;
    let S = new Vector3$1(f - y, p - x, m - v).normalize();
    if (a) {
      const { line1: b, line2: w } = this._arcInfo, M = getRadiusCenter3D(b, w, c), P = M.point, D = M.direction, L = l.unprojectArrayCoordinate(P);
      P && (d[0] = L[0], d[1] = L[1], l.isGlobe && (d[2] = L[2])), S.fromArray(D);
    }
    const E = this.dirUpToHPR(S, d);
    return {
      point: d,
      hpr: E
    };
  }
  _findCurrentSegment(e) {
    const r = this._sampledPath.findIndex((f) => f.percent >= e);
    if (r === -1)
      return null;
    const s = this._frameInfo ? this._frameInfo[r - 1] : null, a = this._frameInfo ? this._frameInfo[r] : null;
    let c = this._sampledPath[r], l = this._sampledPath[r - 1], h = this._sampledPath[r + 1], d = 0;
    return r === 0 && (l = c, c = h), d = (e - l.percent) / (c.percent - l.percent), {
      last: l,
      current: c,
      next: h,
      percent: d,
      lastFrame: s,
      currentFrame: a,
      index: r
    };
  }
  _calculateLocation(e, r, s) {
    const a = intepolateArray3(e.point, r.point, s), c = new Vector3$1(
      r.position[0] - e.position[0],
      r.position[1] - e.position[1],
      r.position[2] - e.position[2]
    ).normalize();
    return {
      point: a,
      direction: c
    };
  }
  _createSampledPath(e) {
    const r = this._engine.map;
    if (!e)
      return;
    let s = 0, a = [0], c = [], l = [], h = 0, d = [0], f = new Vector3$1();
    for (let m = 1; m < e.length; m++) {
      const y = e[m], x = e[m - 1], v = e[m + 1], S = this._engine.map.projectArrayCoordinate(y), E = this._engine.map.projectArrayCoordinate(x), b = getDistance(E, S);
      if (a[m] = b + s, s += b, this._frameInfo && this._frameInfo.length && this._frameInfo.every((w) => w.speed)) {
        const w = this._frameInfo[m - 1], M = b / w.speed * 1e3;
        this._frameInfo[m - 1].time = M, !v && (this._frameInfo[m].time = 0), d[m] = M + h, h += M;
      } else if (this._frameInfo && this._frameInfo.length && this._frameInfo.every((w) => w.time)) {
        const w = this._frameInfo[m - 1];
        d[m] = w.time + h, h += w.time;
      }
      if (m === 1 && (c[0] = getDirection3(E, S, f).toArray(), l[0] = this._getRadians(x, y)), !v)
        c[m] = getDirection3(E, S, f).toArray(), l[m] = this._getRadians(x, y);
      else {
        const w = this._engine.map.projectArrayCoordinate(v), M = getDirection3(E, S, f).toArray(), P = getDirection3(S, w, f).toArray(), D = intepolateArray3(M, P, 0.5);
        c[m] = D;
        const L = this._getRadians(x, y), O = this._getRadians(y, v);
        l[m] = intepolateScalar(L, O, 0.5);
      }
    }
    const p = [];
    for (let m = 0; m < e.length; m++) {
      const y = e[m][2] ? e[m] : [e[m][0], e[m][1], 0], x = {
        percent: (a[m] / s).toFixed(6),
        point: y,
        position: r.projectArrayCoordinate(y),
        distance: a[m],
        direction: c[m],
        pitch: l[m]
      };
      h && d && (x.percent = (d[m] / h).toFixed(6)), p.push(x);
    }
    return p.sort((m, y) => m.percent - y.percent), this._sampledPath = p, p;
  }
  _getRadians(e, r) {
    const s = new Vector3$1(r[0] - e[0], r[1] - e[1], r[2] - e[2]).normalize();
    return Math.PI / 2 - Math.acos(MathUtils.clamp(s.z, -1, 1));
  }
  _parseCoordinateArray(e) {
    if (Array.isArray(e) && e.length >= 2 && Array.isArray(e[0]) && typeof e[0][0] == "number")
      return {
        track: e,
        frameInfo: []
      };
  }
  _parseGeoJSON(e) {
    var r, s;
    if (((r = e.geometry) == null ? void 0 : r.type) === "LineString" && Array.isArray(e.geometry.coordinates))
      return {
        track: e.geometry.coordinates,
        frameInfo: ((s = e.properties) == null ? void 0 : s.frameInfo) || []
      };
  }
  _parseFrameArray(e) {
    if (Array.isArray(e) && e.length > 0 && typeof e[0] == "object" && "x" in e[0]) {
      const r = e.map(({ x: a, y: c, z: l }) => [a, c, l]), s = e.map(({ pitch: a, yaw: c, aim: l, speed: h, time: d }) => ({ pitch: a, yaw: c, aim: l, speed: h, time: d }));
      return {
        track: r,
        frameInfo: s
      };
    }
  }
  set track(e) {
    if (!e) {
      this._track = null, this._frameInfo = null;
      return;
    }
    const r = [
      this._parseCoordinateArray,
      this._parseGeoJSON,
      this._parseFrameArray
    ];
    for (const s of r) {
      const a = s.call(this, e);
      if (a) {
        this._track = a.track, this._frameInfo = a.frameInfo, this._createSampledPath(this._track);
        return;
      }
    }
    throw new Error("Unsupported track format");
  }
  get track() {
    return this._track;
  }
  set interpolateDirectThreshold(e) {
    this._interpolateDirectThreshold = e, this._createSampledPath(this.track);
  }
  get interpolateDirectThreshold() {
    return this._interpolateDirectThreshold;
  }
  set pointHandle(e) {
    if (this._pointHandle = e, e === "curve") {
      const r = this._track.map((s) => new Vector3$1().fromArray(
        this._engine.map.projectArrayCoordinate(s)
      ));
      this.curvePath = new CatmullRomCurve3(r);
    }
  }
  get pointHandle() {
    return this._pointHandle;
  }
}
const _box = new Box3(), _sphere = new Sphere(), _center = new Vector3$1(), hQuat = new Quaternion$1(), pQuat = new Quaternion$1(), _axisX = new Vector3$1(1, 0, 0), _axisZ = new Vector3$1(0, 0, 1);
class RotateTracker extends TrackerAbstract {
  constructor(e = {}) {
    super(e);
    _(this, "_keepRunning", !1);
    _(this, "_withoutTrack", !0);
    this._trackedObject = null, this._runConfig = null, this.viewMode = "lock";
  }
  start(e = {}) {
    const {
      duration: r = 1e4,
      heading: s = 0,
      pitch: a = 0,
      range: c = 0,
      easing: l,
      object: h = null,
      center: d = null,
      projectedCenter: f = null,
      radius: p = 100,
      startAngle: m = 0,
      endAngle: y = 360,
      loopMode: x = "repeat",
      keepRunning: v = !0,
      useWorldAxis: S = !1,
      height: E = 0,
      ...b
    } = e;
    if (!h && !d && !f) {
      console.warn("RotateTracker \u8BF7\u4F20\u5165 object\u3001center \u6216 projectedCenter");
      return;
    }
    this._trackedObject = h instanceof Object3D ? h : null, this._runConfig = {
      center: d,
      projectedCenter: f,
      radius: p,
      startAngle: MathUtils.degToRad(m),
      endAngle: MathUtils.degToRad(y),
      loopMode: x,
      heading: MathUtils.degToRad(s),
      pitch: MathUtils.degToRad(a),
      useWorldAxis: S,
      height: E
    }, super.start({
      heading: 0,
      pitch: 0,
      roll: 0,
      duration: r,
      range: c,
      easing: l,
      keepRunning: v,
      loopMode: x,
      ...b
    });
  }
  _computeLocalAxes(e) {
    const r = this._engine.map.isGlobe, s = this._engine.map.map._ellipsoid;
    if (!this._runConfig.useWorldAxis && r) {
      const c = Transforms.eastNorthUpToFixedFrame(e, s), l = new Vector3$1().setFromMatrixColumn(c, 0).normalize(), h = new Vector3$1().setFromMatrixColumn(c, 2).normalize();
      return { east: l, up: h };
    }
    return {
      east: _axisX,
      up: _axisZ
    };
  }
  _computeOrbitAxes(e, r, s, a) {
    const c = pQuat.setFromAxisAngle(e, a), l = r.clone().applyQuaternion(c), h = hQuat.setFromAxisAngle(r, s), d = l.applyQuaternion(h).normalize();
    let f = new Vector3$1().crossVectors(d, r);
    if (f.lengthSq() < 1e-8) {
      const m = new Vector3$1().crossVectors(r, e).normalize();
      f.copy(e.clone().negate()).multiplyScalar(Math.cos(-s)).add(m.multiplyScalar(Math.sin(-s))).normalize();
    } else
      f.normalize();
    const p = f.negate();
    return { orbitNormal: d, startVector: p };
  }
  updatePositionByPercentage(e) {
    const r = this._runConfig;
    if (!r)
      throw new Error("\u8BF7\u5148\u8C03\u7528 start()");
    let s;
    if (this._trackedObject) {
      this._trackedObject.updateMatrixWorld(!0);
      const w = _box.setFromObject(this._trackedObject).getBoundingSphere(_sphere);
      s = _center.copy(w.center);
    } else if (r.projectedCenter)
      s = _center.fromArray(r.projectedCenter);
    else {
      const b = this._engine.map.projectArrayCoordinate(r.center || [0, 0, 0]);
      s = _center.fromArray(b);
    }
    const { east: a, up: c } = this._computeLocalAxes(s), { orbitNormal: l, startVector: h } = this._computeOrbitAxes(
      a,
      c,
      r.heading,
      r.pitch
    ), d = r.endAngle - r.startAngle, f = r.startAngle + e * d, p = new Quaternion$1().setFromAxisAngle(l, f), m = h.clone().applyQuaternion(p).normalize().multiplyScalar(r.radius), y = l.clone().multiplyScalar(r.height || 0), x = s.clone().add(m).add(y), v = this._engine.map.unprojectArrayCoordinate([x.x, x.y, x.z]), S = s.clone().sub(x).normalize(), E = this.dirUpToHPR(S, v);
    return E.pitch += 89, { point: v, hpr: E, direction: S };
  }
}
const rotationMatrix = new Matrix4(), headingPitchRoll = new Euler(), tmpV3A = new Vector3$1(), tmpV3B = new Vector3$1(), tmpQuat = new Quaternion$1(), tmpScale = new Vector3$1();
class ObjectTracker extends TrackerAbstract {
  constructor() {
    super(...arguments);
    _(this, "_trackObject", null);
    _(this, "_trackConfig", {});
    _(this, "_lastState", null);
    _(this, "_keepRunning", !0);
  }
  track(e, r = {}) {
    var a, c, l, h, d;
    this._trackObject = e, this._trackConfig = {
      lock: (a = r.lock) != null ? a : !0,
      extraDir: r.extraDir,
      height: r.height
    }, this.lockView = !!this._trackConfig.lock, this.viewFollow = !0;
    const s = r.radius !== void 0 ? r.radius : r.range !== void 0 ? r.range : 0;
    this.start({
      duration: (c = r.duration) != null ? c : 0,
      easing: (l = r.easing) != null ? l : "linear",
      range: s,
      pitch: (h = r.pitch) != null ? h : 0,
      heading: (d = r.heading) != null ? d : 0
    });
  }
  stop() {
    super.stop(), this._trackObject = null, this._trackConfig = {}, this._lastState = null;
  }
  updatePositionByPercentage() {
    if (!this._trackObject)
      return null;
    const e = this._computeTargetState(this._trackObject, this._trackConfig);
    return this.onTrackFrame(this._lastState, e), this._lastState = e, e;
  }
  onTrackFrame() {
  }
  _computeTargetState(e, r) {
    const { worldCenter: s, targetEuler: a } = this._sampleTargetWorldPose(e, r), c = this._engine.map.isGlobe;
    let l = 0, h = 0;
    if (c) {
      rotationMatrix.makeRotationFromEuler(a);
      const y = Transforms.eastNorthUpToFixedFrame(s).invert().multiply(rotationMatrix);
      headingPitchRoll.setFromRotationMatrix(y), l = (headingPitchRoll.z - Math.PI / 2) * 180 / Math.PI, h = MathUtils.radToDeg(headingPitchRoll.x - Math.PI / 2);
    } else
      l = (a.z - Math.PI / 2) * 180 / Math.PI, h = 0;
    const d = [];
    return typeof this._engine.map.unprojectArrayCoordinate == "function" ? this._engine.map.unprojectArrayCoordinate(
      [s.x, s.y, s.z || 0],
      d
    ) : (d[0] = s.x, d[1] = s.y, d[2] = s.z || 0), { point: d, hpr: {
      heading: l,
      pitch: 0,
      roll: h
    } };
  }
  _sampleTargetWorldPose(e, r) {
    let s = tmpV3A.set(0, 0, 0), a = new Euler();
    if (e && e.instance && e.instanceIndex !== void 0) {
      const c = e.instance.getEntityByIndex(e.instanceIndex);
      if (c && c.matrix) {
        const l = new Matrix4();
        l.elements = c.matrix, l.decompose(tmpV3A, tmpQuat, tmpScale), a.setFromQuaternion(tmpQuat), a.y = a.z;
        const [h, d, f] = e.instance.position.toArray();
        s = new Vector3$1(h + tmpV3A.x, d + tmpV3A.y, f + tmpV3A.z);
      }
    } else if (e instanceof Object3D) {
      e.updateMatrixWorld(!0);
      const l = new Box3().setFromObject(e).getBoundingSphere(new Sphere());
      s.copy(l.center), e.matrixWorld.decompose(tmpV3B, tmpQuat, tmpScale), a.setFromQuaternion(tmpQuat, "ZYX");
    } else
      e instanceof Vector3$1 ? s.copy(e) : Array.isArray(e) && s.set(e[0], e[1], e[2] || 0);
    return r && typeof r.extraDir == "number" && (a.z -= r.extraDir * Math.PI / 180), { worldCenter: s, targetEuler: a };
  }
  updateCamera(e) {
    var r, s, a;
    if (super.updateCamera(e), !((s = (r = this._engine) == null ? void 0 : r.map) != null && s.isGlobe) && ((a = this._trackConfig) == null ? void 0 : a.height)) {
      const c = this._engine.camera;
      c.position.z += this._trackConfig.height, c.updateMatrixWorld();
    }
  }
  static computeTransformedBoundingBox(e, r) {
    const s = [
      new Vector3$1(e.min.x, e.min.y, e.min.z),
      new Vector3$1(e.max.x, e.min.y, e.min.z),
      new Vector3$1(e.min.x, e.max.y, e.min.z),
      new Vector3$1(e.max.x, e.max.y, e.min.z),
      new Vector3$1(e.min.x, e.min.y, e.max.z),
      new Vector3$1(e.max.x, e.min.y, e.max.z),
      new Vector3$1(e.min.x, e.max.y, e.max.z),
      new Vector3$1(e.max.x, e.max.y, e.max.z)
    ].map((c) => c.applyMatrix4(r));
    return new Box3().setFromPoints(s);
  }
}
new Raycaster();
new Plane(new Vector3$1(0, 0, 1), 0);
const _tempVector3$3 = new Vector3$1(), _matrix4$1 = new Matrix4();
class DOMOverlay extends Object3D {
  constructor(e = {}) {
    super(e);
    _(this, "_container");
    _(this, "_point");
    _(this, "_dom");
    _(this, "_div");
    _(this, "_visible");
    _(this, "_offset");
    _(this, "_stopPropagation", !1);
    _(this, "_enableDragging", !1);
    _(this, "handleMouseDown", (e) => {
      e.preventDefault();
      const r = this.engine.rendering.canvas.getBoundingClientRect();
      this._sub = new Vector2$1().set(this._screenPos.x - e.x + r.left, this._screenPos.y - e.y + r.top), (this.stopPropagation || this.enableDragging) && e.stopPropagation(), isSupportPointerEvent ? (e.target.setPointerCapture(e.pointerId), document.addEventListener(EVENTS.MOVE, this.handleMouseMove), document.addEventListener(EVENTS.UP, this.handleMouseUp)) : (document.addEventListener(EVENTS.MOVE, this.handleMouseMove), document.addEventListener(EVENTS.UP, this.handleMouseUp));
    });
    _(this, "handleMouseUp", (e) => {
      document.removeEventListener(EVENTS.MOVE, this.handleMouseMove), document.removeEventListener(EVENTS.UP, this.handleMouseUp), isSupportPointerEvent && e.target.releasePointerCapture && e.target.releasePointerCapture(e.pointerId);
    });
    _(this, "handleMouseMove", (e) => {
      e.preventDefault();
      const r = this.engine, s = r.rendering.canvas.getBoundingClientRect(), a = e.clientX + this._sub.x - s.left, c = e.clientY + this._sub.y - s.top;
      _tempVector3$3.copy(r.rendering.picking.pickSeaLevelWorldPosition({
        x: a,
        y: c
      }));
      const l = [_tempVector3$3.x, _tempVector3$3.y, _tempVector3$3.z], h = r.map.unprojectArrayCoordinate(l);
      this.point = [h[0], h[1], this.point[2] || 0], this.dispatchEvent({
        type: "dragmove",
        target: this,
        point: h
      }), r.requestRender();
    });
    _(this, "handleWheel", (e) => {
      e.preventDefault(), e.stopPropagation();
      const r = new WheelEvent("wheel", {
        bubbles: !1,
        cancelable: !0,
        clientX: e.clientX,
        clientY: e.clientY,
        screenX: e.screenX,
        screenY: e.screenY,
        deltaX: e.deltaX,
        deltaY: e.deltaY,
        deltaZ: e.deltaZ,
        deltaMode: e.deltaMode
      });
      this.engine.map.projectionName === PROJECTION_ECEF ? this.engine.rendering.renderer.domElement.dispatchEvent(r) : this.engine.container.dispatchEvent(r);
    });
    this.isDOMOverlay = !0, this.parameters = e;
  }
  afterAddToEngine(e) {
    this.engine = e;
    const r = e.container, s = r instanceof HTMLElement || r && typeof r == "object" && r.nodeType === 1 && typeof r.nodeName == "string";
    this._container = s ? r : r.container || r._container;
    let a = !1;
    const c = e.map._mapType, l = "-overlay-" + e.id, h = CSS_NAMESPACE + l, d = this._container.children;
    if (d && (a = Array.from(d).some((f) => f.id === h)), a)
      this._div = Array.from(d).find((f) => f.id === h);
    else if (this._div = document.createElement("div"), this._div.id = h, addClass(this._div, `${CSS_NAMESPACE}-overlay-pane`), c === "bmapgl") {
      const f = r == null ? void 0 : r.container;
      f && f instanceof HTMLElement && r.container.appendChild(this._div);
    } else
      r instanceof HTMLElement ? r.appendChild(this._div) : c === "mapbox" && r._container.appendChild(this._div);
    this.dom = this.initDom(), this.point = this.parameters.point || [], this.offset = this.parameters.offset || [0, 0], this.className = this.parameters.className || "", this.enableDragging = this._enableDragging || !1, this.visible = this.parameters.visible || !0, this.afterInit();
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  initDom() {
    if (!this.parameters.dom) {
      console.warn("`DOMOverlay` must contain a property `dom`.");
      return;
    }
    return this.parameters.dom;
  }
  afterInit() {
  }
  onBeforeScenePrepareRender(e, r, s) {
    if (!!this.dom && this.visible) {
      this.camera = s, this.renderer = e.renderer;
      let a = new Vector2$1();
      e.renderer.getSize(a), _matrix4$1.multiplyMatrices(s.matrixWorldInverse, this.matrixWorld), _matrix4$1.multiplyMatrices(s.projectionMatrix, _matrix4$1);
      const c = new Vector4(0, 0, 0, 1);
      c.applyMatrix4(_matrix4$1), c.divideScalar(c.w), c.z > 1 || c.z < -1 ? addClass(this.dom, `${CSS_NAMESPACE}-hidden`) : removeClass(this.dom, `${CSS_NAMESPACE}-hidden`);
      const l = (1 + c.x) * a.x / 2, h = (1 - c.y) * a.y / 2, d = this.dom.clientWidth, f = this.dom.clientHeight;
      let p = l - d / 2 + this.offset[0], m, y = l + d / 2 + this.offset[0], x;
      if (this.isPopup ? (m = h - f + this.offset[1], x = h + this.offset[1]) : (m = h - f / 2 + this.offset[1], x = h + f / 2 + this.offset[1]), y < 0 || p > a.x || x < 0 || m > a.y) {
        this.dom.style.visibility !== "hidden" && (this.dom.style.visibility = "hidden");
        return;
      }
      this.dom.style.position = "absolute", this.dom.style.visibility === "hidden" && (this.dom.style.visibility = "visible"), this.dom.style.left = p + "px", this.dom.style.top = m + "px";
      const S = new Vector3$1(
        this.matrixWorld.elements[12],
        this.matrixWorld.elements[13],
        this.matrixWorld.elements[14]
      ).clone().project(s), E = (1 + S.x) * a.x / 2, b = (1 - S.y) * a.y / 2;
      this._screenPos = new Vector2$1().set(E, b), this.dom.ondragstart = () => !1, this.enableDragging ? this.dom.style.touchAction = "auto" : this.dom.style.touchAction = "none";
    }
  }
  onDispose() {
  }
  dispose() {
    this.onDispose(), this.enableDragging && (this._dom.removeEventListener(EVENTS.DOWN, this.handleMouseDown), this._dom.removeEventListener(EVENTS.UP, this.handleMouseUp), document.removeEventListener(EVENTS.MOVE, this.handleMouseMove), document.removeEventListener(EVENTS.UP, this.handleMouseUp)), this._dom.removeEventListener("wheel", this.handleWheel), this._dom.remove(), this._dom = null, this._div.childElementCount === 0 && this._div.remove();
  }
  get dom() {
    return this._dom;
  }
  set dom(e) {
    if (this._dom && (this.enableDragging && (this._dom.removeEventListener(EVENTS.DOWN, this.handleMouseDown), this._dom.removeEventListener(EVENTS.UP, this.handleMouseUp)), this._div.removeChild(this._dom)), typeof e == "string") {
      const r = document.createElement("div");
      addClass(r, `${CSS_NAMESPACE}-dom-overlay-custom`);
      const a = new DOMParser().parseFromString(e, "text/html").body.children;
      for (let c = 0; c < a.length; c++)
        r.appendChild(a.item(c));
      this._dom = r;
    } else
      this._dom = e;
    this._div.appendChild(this._dom), this._dom.style.visibility = "hidden", this._dom.setAttribute("draggable", "false"), this._dom.ondragstart = () => !1, this.enableDragging && (this._dom.addEventListener(EVENTS.DOWN, this.handleMouseDown), this._dom.addEventListener(EVENTS.UP, this.handleMouseUp), this._dom.style.cursor = "pointer"), this._dom.addEventListener("wheel", this.handleWheel);
  }
  get point() {
    return this._point;
  }
  set point(e) {
    Array.isArray(e) && e.length > 1 ? (this._point = e, this.engine && this.position.set(...this.engine.map.projectArrayCoordinate(e))) : (e.isVector2 || e.isVector3) && (this._point = [e.x, e.y, e.z || 0], this.engine && this.position.copy(this.engine.map.projectCoordinate(e)));
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    e !== this._visible && (this._visible = e);
  }
  get offset() {
    return this._offset;
  }
  set offset(e) {
    this._offset = e;
  }
  get stopPropagation() {
    return this._stopPropagation;
  }
  set stopPropagation(e) {
    this._stopPropagation = e;
  }
  get enableDragging() {
    return this._enableDragging;
  }
  set enableDragging(e) {
    this._enableDragging !== e && (this._enableDragging = e, this.dom && (e ? (this.dom.addEventListener(EVENTS.DOWN, this.handleMouseDown), this.dom.addEventListener(EVENTS.UP, this.handleMouseUp), this.dom.style.cursor = "pointer") : (this.dom.removeEventListener(EVENTS.DOWN, this.handleMouseDown), this.dom.removeEventListener(EVENTS.UP, this.handleMouseUp), this.dom.style.cursor = "auto")));
  }
  get className() {
    return this._className;
  }
  set className(e) {
    e !== this._className && (this.dom && (this._className && removeClass(this.dom, this._className), addClass(this.dom, e)), this._className = e);
  }
}
class Popup extends DOMOverlay {
  constructor(e) {
    super(e);
    _(this, "_titleDiv");
    _(this, "_contentDiv");
    _(this, "_title");
    _(this, "_content");
    _(this, "_closePopup");
    _(this, "click", () => {
      this.visible = !1, this.dispatchEvent({
        type: "close",
        target: this
      });
    });
    this.isPopup = !0;
  }
  initDom() {
    const e = document.createElement("div");
    addClass(e, `${CSS_NAMESPACE}-popup`);
    const r = document.createElement("div");
    addClass(r, "frame");
    const s = this._titleDiv = document.createElement("div");
    addClass(s, "title"), s.innerText = this.title;
    const a = this._closePopup = document.createElement("div");
    addClass(a, "close"), a.innerText = "x", a.addEventListener("click", this.click);
    const c = this._contentDiv = document.createElement("div");
    addClass(c, "content"), c.innerText = this.content, r.appendChild(a), r.appendChild(s), r.appendChild(c);
    const l = document.createElement("div");
    return addClass(l, "triangle"), e.appendChild(r), e.appendChild(l), e;
  }
  afterInit() {
    this.title = this.parameters.title || "title", this.content = this.parameters.content || "content";
  }
  onDispose() {
    this._closePopup.removeEventListener("click", this.click);
  }
  get title() {
    return this._title;
  }
  set title(e) {
    e && (this._title = e, this._titleDiv && (this._titleDiv.innerText = e));
  }
  get content() {
    return this._content;
  }
  set content(e) {
    this._content = e, this._contentDiv && (this._contentDiv.innerText = e);
  }
}
class Marker extends DOMOverlay {
  constructor(e = {}) {
    super(e);
    _(this, "_icon");
    _(this, "_width");
    _(this, "_height");
    _(this, "_title");
    this.isMarker = !0, this._title = e.title || "", this._icon = e.icon || getAssetUrl("assets/images/marker_red.png"), this._width = e.width || 25, this._height = e.height || 25;
  }
  initDom() {
    let e = document.createElement("img");
    return addClass(e, `${CSS_NAMESPACE}-marker`), e;
  }
  afterInit() {
    this.icon = this._icon, this.width = this._width, this.height = this._height;
  }
  get icon() {
    return this._icon;
  }
  set icon(e) {
    this.dom && (this.dom.src = e), this._icon = e;
  }
  get width() {
    return this._width;
  }
  set width(e) {
    this.dom && (this.dom.width = e), this._width = e;
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this.dom && (this.dom.height = e), this._height = e;
  }
  set title(e) {
    this.dom && (this.dom.title = e), this._title = e;
  }
  get title() {
    return this._title;
  }
}
const API_SOURCE_BAIDU = "baidu", API_SOURCE_TIANDITU = "tdt";
let apiSource = API_SOURCE_BAIDU;
function setApiSource(o) {
  apiSource = o;
}
function getApiSource() {
  return apiSource;
}
const http$7 = location.protocol === "https:" ? "https" : "http";
let DataMgr = {
  request: async function(o) {
    o.indexOf("v=") === -1 && (o += "&v=three");
    const e = "jsonp" + Math.ceil(Math.random() * 1e5);
    return o = o + "&callback=" + e, o = DataMgr.getSeckeyAndSign(o), await jsonp(o, {}, { autoCallback: !1, callbackName: e });
  },
  getSeckeyAndSign: function(o) {
    let i = decodeURIComponent(o), e = new Date().getTime(), r = window.___abvk ? window.___abvk : DataMgr.getSeckeyCidItem("SECKEY_ABVK"), s = DataMgr.getSeckeyCidItem("BMAP_SECKEY"), a = encodeURIComponent(r + "," + s), c = r + "," + s;
    return o += "&seckey=" + a + "&timeStamp=" + e, i += "&seckey=" + c + "&timeStamp=" + e, o += appendSign(i), o;
  },
  getSeckeyCidItem: function(o) {
    if (localStorage)
      return localStorage.getItem(o) ? localStorage.getItem(o) : -1;
    if (sessionStorage)
      return sessionStorage.getItem(o) ? sessionStorage.getItem(o) : -1;
  }
}, SearchRequestMgr = {
  request: async function(o, i, e, r) {
    e = e || "";
    let s;
    if (i && i.useEncodeURI ? s = jsonToQuery(o, encodeURI) : s = jsonToQuery(o, encodeURIComponent), !BaiduMapConfig.ak)
      throw new Error("BaiduMapConfig.ak is not set");
    let c = `${`${http$7}://api.map.baidu.com`}/${e}?${s}&ie=utf-8&oue=1&fromproduct=jsapi&ak=${BaiduMapConfig.ak}`;
    r || (c += "&res=api");
    let l = await DataMgr.request(c);
    return l.result && l.result.error !== 0 && console.error("BaiduRequest request failed:", l.result.error_msg), l;
  }
};
function jsonToQuery(o, i) {
  let e = [];
  i = i || function(r) {
    return r;
  };
  for (let r in o)
    Object.prototype.hasOwnProperty.call(o, r) && e.push(r + "=" + i(o[r]));
  return e.join("&");
}
const BMAP_ROUTE_TYPE_TRANSIT = 1, BMAP_ROUTE_TYPE_WALKING = 2, BMAP_ROUTE_TYPE_DRIVING = 3, BMAP_ROUTE_TYPE_RIDING = 6, QUERY_TYPE_CENTER = "cen", QUERY_TYPE_POI_SEARCH = "s", QUERY_TYPE_POI_SEARCH_CON = "con", QUERY_TYPE_SEARCH_INBOUNDS = "bd", QUERY_TYPE_SEARCH_NEARBY = "nb", QUERY_TYPE_TRANSIT = "bt", QUERY_TYPE_DRIVING = "nav", QUERY_TYPE_WALKING = "walk", QUERY_TYPE_GEOCODER = "gc", QUERY_TYPE_REVERSE_GEOCODER = "rgc", QUERY_TYPE_SEARCH_INBOUNDS_MULTIKEY = "bda", QUERY_TYPE_SEARCH_MULTIKEY = "sa", QUERY_TYPE_SEARCH_NEARBY_MULTIKEY = "nba", QUERY_TYPE_EXT = "ext", QUERY_TYPE_EXTS = "exts", QUERY_TYPE_RIDING = "ride", QUERY_TYPE_DIRECTION = "drct", RETURN_TYPE_CURRENT_CITY = 2, RETURN_TYPE_CENTER = 4, RETURN_TYPE_CITY_LIST = 7, RETURN_TYPE_POI_SEARCH = 11, RETURN_TYPE_SEARCH_NEARBY = 12, RETURN_TYPE_TRANSIT = 14, RETURN_TYPE_DRIVING = 20, RETURN_TYPE_SEARCH_INBOUNDS = 21, RETURN_TYPE_SPECIAL_REGION = 26, RETURN_TYPE_NODATA_REGION = 28, RETURN_TYPE_WALKING = 31, RETURN_TYPE_GEOCODER = 35, RETURN_TYPE_REVERSE_GEOCODER = 44, RETURN_TYPE_SEARCH_INBOUNDS_MULTIKEY = 45, RETURN_TYPE_SEARCH_MULTIKEY = 46, RETURN_TYPE_SEARCH_NEARBY_MULTIKEY = 47, BMAP_POI_TYPE_NORMAL = 0, BMAP_POI_TYPE_BUSSTOP = 1, BMAP_POI_TYPE_SUBSTOP = 3, DIRECTION_RETURN_TYPE_CLEAR = 2, BMAP_TRANSIT_TYPE_IN_CITY = 0, BMAP_TRANSIT_TYPE_CROSS_CITY = 1, BMAP_VEHICLE_TYPE_BUS = 3, BMAP_VEHICLE_TYPE_DRIVING = 4, BMAP_VEHICLE_TYPE_TRAIN = 1, BMAP_VEHICLE_TYPE_AIRPLANE = 2, BMAP_VEHICLE_TYPE_WALKING = 5, BMAP_VEHICLE_TYPE_COACH = 6, BMAP_LINE_TYPE_BUS = 0, BMAP_LINE_TYPE_SUBWAY = 1, BMAP_LINE_TYPE_TRAIN = 3, BMAP_LINE_TYPE_AIRPLANE = 4, BMAP_LINE_TYPE_COACH = 5, _tempVec3Scratch = new Vector3$1(), _tempVec3Scratch1 = new Vector3$1(), _tempVec3Scratch2 = new Vector3$1();
class Geocoder_Bd {
  constructor(i = {}) {
    this.options = i, this._baiduMercatorProjection = getProjection(PROJECTION_BD_MERCATOR);
  }
  getPoint(i, e, r) {
    if (r = r || "", !/^[ \s]*$/.test(i))
      return SearchRequestMgr.request({
        qt: QUERY_TYPE_GEOCODER,
        wd: i,
        cn: r
      }).then((a) => {
        if (a && a.result && a.result.type === RETURN_TYPE_GEOCODER) {
          let c = a.result, l = a.content, h = null, d = null;
          if (c && c.error === 0 && l && l.coord) {
            let f = l.coord.x, p = l.coord.y, m = l.cn, y = l.sc, x = l.wd, v = l.prc, S = l.fuzzy_score, E = l.catalog;
            _tempVec3Scratch.set(f, p, 0), h = this._baiduMercatorProjection.unprojectCoordinate(_tempVec3Scratch), d = {
              city: m,
              citycode: y,
              address: x,
              precise: v,
              confidence: S,
              level: E
            };
          }
          return e && e(h, d), h;
        }
      });
  }
  getLocation(i, e, r) {
    let s = null, a = null, c = null;
    if (i instanceof Vector2$1 ? (s = i.x, a = i.y, c = 0) : Array.isArray(i) ? (s = i[0], a = i[1], c = i[2] || 0) : i instanceof Vector3$1 && (s = i.x, a = i.y, c = i.z), !(s && a) && e) {
      e(null);
      return;
    }
    _tempVec3Scratch1.set(s, a, c), i = this._baiduMercatorProjection.projectCoordinate(_tempVec3Scratch1), s = i.x, a = i.y, c = i.z, r = r || {};
    let l = r.poiRadius || 100, h = r.numPois || 10;
    return SearchRequestMgr.request({
      qt: QUERY_TYPE_REVERSE_GEOCODER,
      x: s,
      y: a,
      dis_poi: l,
      poi_num: h,
      latest_admin: "1",
      language: "zh"
    }).then((d) => {
      let f = null;
      if (d && d.result && d.result.type === RETURN_TYPE_REVERSE_GEOCODER) {
        let p = d.result, m = d.content, y = {}, x = [], v;
        if (p.error === 0 && m) {
          let S = m.address_detail, E = S.city;
          S && (y.streetNumber = S.street_number, y.street = S.street, y.district = S.district, y.city = E, y.province = S.province), v = m.point, _tempVec3Scratch2.set(+v.x, +v.y, c);
          let b = this._baiduMercatorProjection.unprojectCoordinate(_tempVec3Scratch2), w = m.surround_poi;
          if (w && w.length)
            for (let M = 0, P = w.length; M < P; M++) {
              let D = {}, L = w[M];
              D.title = L.name, D.uid = L.uid, _tempVec3Scratch2.set(+L.point.x, +L.point.y, c);
              let O = this._baiduMercatorProjection.unprojectCoordinate(_tempVec3Scratch2);
              D.point = O, D.city = E, D._poiType = L.poiType, D.type = BMAP_POI_TYPE_NORMAL, D.address = L.addr, D.postcode = L.zip || null, D.phoneNumber = L.tel || null;
              let F = D._poiType;
              F.length !== 0 && (D.tags = F.split(",")), x.push(D);
            }
          f = {
            point: b,
            address: m.address,
            addressComponents: y,
            surroundingPois: x,
            business: m.business,
            content: m
          };
        }
      }
      return e && e(f), f;
    });
  }
}
const http$6 = location.protocol === "https:" ? "https" : "http";
class ScriptLoader {
  constructor() {
    this.objName = "tdt_loadResult", this.win = window, this.charset = "utf-8", this.src = null, this.callback = null, this.oScript = null, this.running = !1;
  }
  static async request(i) {
    return new Promise((e, r) => {
      if (!i) {
        r(new Error("\u5929\u5730\u56FEAPI URL\u4E0D\u80FD\u4E3A\u7A7A"));
        return;
      }
      const s = ScriptLoader.getObject();
      let a = TiandituConfig.tk || "\u60A8\u7684\u5BC6\u94A5";
      i.indexOf("tk=") === -1 && (i += "&tk=" + a), i = encodeURIComponent(i);
      let c = `${http$6}://api.tianditu.gov.cn/apiserver/ajaxproxy?proxyReqUrl=${i}`;
      s.loadScript(c, "utf-8", this, (l) => {
        e(l);
      });
    });
  }
  loadScript(i, e, r, s) {
    if (!i)
      return;
    this.src = i, this.charset = e || "utf-8", this.callback = s ? ScriptLoader.createCallback(r, s) : null, this.oScript = document.createElement("script"), this.oScript.type = "text/javascript", this.oScript.async = !0, this.oScript.charset = this.charset, this.oScript.src = this.src, this.running = !0;
    const a = this;
    this.oScript.onload = this.oScript.onreadystatechange = function() {
      (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") && (this.onload = this.onreadystatechange = null, a.handleLoadComplete());
    }, this.win.document.body.insertBefore(this.oScript, this.win.document.body.firstChild);
  }
  handleLoadComplete() {
    const i = this.win;
    let e = "";
    i[this.objName] && (e = i[this.objName], i[this.objName] = null), this.callback && this.callback(e), this.cleanupScriptElement(), this.running = !1;
  }
  cleanupScriptElement() {
    !document.all && this.oScript && this.oScript.parentNode === this.win.document.body && (this.oScript.removeAttribute("src"), this.win.document.body.removeChild(this.oScript), this.oScript = null);
  }
  static getObject(i = window) {
    i.scriptLoader_obj || (i.scriptLoader_obj = []);
    for (let r = 0; r < i.scriptLoader_obj.length; r++)
      if (!i.scriptLoader_obj[r].running) {
        const s = i.scriptLoader_obj[r];
        return s.running = !0, s;
      }
    const e = new ScriptLoader();
    return i.scriptLoader_obj.push(e), e;
  }
  static getElementWindow(i) {
    return i && i.ownerDocument && i.ownerDocument.parentWindow ? i.ownerDocument.parentWindow : window;
  }
  static processEventArguments(i) {
    return i || (i = []), i[0] || (i[0] = ScriptLoader.getElementWindow().event), i[0] && !i[0].target && i[0].srcElement && (i[0].target = i[0].srcElement), i;
  }
  static createCallback(i, e) {
    return function(...r) {
      e.apply(i, ScriptLoader.processEventArguments(r));
    };
  }
}
const http$5 = location.protocol === "https:" ? "https" : "http";
class Geocoder_Tdt {
  constructor(i = {}) {
    this.options = i;
  }
  getPoint(i, e, r) {
    if (/^[ \s]*$/.test(i))
      return;
    let a = `${http$5}://api.tianditu.gov.cn/geocoder?ds={"keyWord":"${i}"}`;
    return ScriptLoader.request(a).then((c) => {
      if (c && c.status === "0" && c.msg === "ok") {
        let l = c.location, h = null, d = null;
        if (l) {
          let f = +l.lon, p = +l.lat, m = l.keyWord, y = l.score, x = l.level;
          h = new Vector3$1(f, p, 0), d = {
            address: m,
            confidence: y,
            level: x
          };
        }
        return e && e(h, d), h;
      }
    });
  }
  getLocation(i, e) {
    let r = null, s = null;
    if (i instanceof Vector2$1 ? (r = i.x, s = i.y) : Array.isArray(i) ? (r = i[0], s = i[1], i[2]) : i instanceof Vector3$1 && (r = i.x, s = i.y, i.z), !(r && s) && e) {
      e(null);
      return;
    }
    let a = `${http$5}://api.tianditu.gov.cn/geocoder?postStr={'lon':${r},'lat':${s},'ver':1}&type=geocode`;
    return ScriptLoader.request(a).then((c) => {
      let l = null;
      if (c && c.status === "0" && c.msg === "ok") {
        let h = c.result;
        if (h) {
          let d = +h.location.lon, f = +h.location.lat;
          l = {
            address: h.formatted_address,
            addressComponents: h.addressComponent,
            point: new Vector3$1(d, f, 0)
          };
        }
      }
      return e && e(l), l;
    });
  }
}
class Geocoder {
  constructor(i = {}) {
    this.options = i, this.apiSource = i.apiSource || getApiSource(), this._gc = this._createInstance(i);
  }
  _createInstance(i) {
    const r = {
      [API_SOURCE_BAIDU]: Geocoder_Bd,
      [API_SOURCE_TIANDITU]: Geocoder_Tdt
    }[this.apiSource] || Geocoder_Bd;
    return new r(i);
  }
  getPoint(i, e, r) {
    return this._gc.getPoint(i, e, r);
  }
  getLocation(i, e, r) {
    return this._gc.getLocation(i, e, r);
  }
}
const GEO_TYPE_AREA = 0, GEO_TYPE_LINE = 1, GEO_TYPE_POINT = 2, baiduMercatorProjection = getProjection(PROJECTION_BD_MERCATOR), SUtil = {
  unique: function(o) {
    let i = [], e = {};
    for (let r = 0, s = o.length; r < s; r++)
      e[o[r]] || (e[o[r]] = !0, i.push(o[r]));
    return i;
  },
  parseGeo: function(o, i) {
    if (typeof o != "string" || !o)
      return;
    let e = o.split("|"), r, s, a;
    if (e.length === 1)
      r = decode_geo_diff(o);
    else if (r = decode_geo_diff(e[2]), s = decode_geo_diff(e[0]), a = decode_geo_diff(e[1]), !i)
      return r;
    let c = { type: r.geoType };
    if (i)
      switch (c.type) {
        case GEO_TYPE_POINT:
          const l = new Vector2$1(r.geo[0][0], r.geo[0][1]), h = baiduMercatorProjection.unprojectCoordinate(l);
          c.point = h, c.points = [h];
          break;
        case GEO_TYPE_LINE:
          c.points = [];
          const d = r.geo[0];
          for (let f = 0, p = d.length - 1; f < p; f += 2) {
            let m = new Vector2$1(d[f], d[f + 1]);
            m = baiduMercatorProjection.unprojectCoordinate(m), c.points.push(m);
          }
          s = new Vector3$1(s.geo[0][0], s.geo[0][1], -100), a = new Vector3$1(a.geo[0][0], a.geo[0][1], 100), s = baiduMercatorProjection.unprojectCoordinate(s), a = baiduMercatorProjection.unprojectCoordinate(a), c.bounds = new Box3(s, a);
          break;
      }
    return c;
  },
  pathToPoints: function(o) {
    let i = [];
    if (typeof o != "string")
      return i;
    let e = o.split(";");
    for (let r = 0; r < e.length; r++) {
      let s = e[r].split(",");
      i.push([+s[0], +s[1]]);
    }
    return i;
  },
  pointsToString: function(o) {
    let i = "";
    if (typeof o != "object")
      return o;
    if (Array.isArray(o) && (typeof o[0] == "number" || typeof o[0] == "string"))
      return o.join(",");
    for (let e = 0; e < o.length; e++) {
      let r = this.getY(o[e]) + "," + this.getX(o[e]);
      e !== o.length - 1 ? i = i + r + "|" : i = i + r;
    }
    return i;
  },
  getX: function(o) {
    return o.isVector2 || o.isVector3 ? o.x : Array.isArray(o) ? o[0] : typeof o == "object" && o.lng && o.lat ? o.lng : o;
  },
  getY: function(o) {
    return o.isVector2 || o.isVector3 ? o.y : Array.isArray(o) ? o[1] : typeof o == "object" && o.lng && o.lat ? o.lat : o;
  }
}, _EXT_CHARS_ = ["=", ".", "-", "*"], _MAX_DELTA_ = 1 << 23;
function decode_geo_diff(o) {
  let i = _decode_type(o.charAt(0)), e = o.substr(1), r = 0, s = e.length, a = [], c = [], l = [];
  for (; r < s; )
    if (e.charAt(r) === _EXT_CHARS_[0]) {
      if (s - r < 13 || (l = _decode_6byte_(e.substr(r, 13), a), l < 0))
        return 0;
      r += 13;
    } else if (e.charAt(r) === ";")
      c.push(a.slice(0)), a.length = 0, ++r;
    else {
      if (s - r < 8 || (l = _decode_4byte_(e.substr(r, 8), a), l < 0))
        return 0;
      r += 8;
    }
  for (let h = 0, d = c.length; h < d; h++)
    for (let f = 0, p = c[h].length; f < p; f++)
      c[h][f] /= 100;
  return { geoType: i, geo: c };
}
function _decode_type(o) {
  let i = -1;
  return o === _EXT_CHARS_[1] ? i = GEO_TYPE_POINT : o === _EXT_CHARS_[2] ? i = GEO_TYPE_LINE : o === _EXT_CHARS_[3] && (i = GEO_TYPE_AREA), i;
}
function _decode_6byte_(o, i) {
  let e = 0, r = 0, s = 0;
  for (let a = 0; a < 6; a++) {
    if (s = _char2num_(o.substr(1 + a, 1)), s < 0)
      return -1 - a;
    if (e += s << 6 * a, s = _char2num_(o.substr(7 + a, 1)), s < 0)
      return -7 - a;
    r += s << 6 * a;
  }
  return i.push(e), i.push(r), 0;
}
function _decode_4byte_(o, i) {
  let e = i.length;
  if (e < 2)
    return -1;
  let r = 0, s = 0, a = 0;
  for (let c = 0; c < 4; c++) {
    if (a = _char2num_(o.substr(c, 1)), a < 0)
      return -1 - c;
    if (r += a << 6 * c, a = _char2num_(o.substr(4 + c, 1)), a < 0)
      return -5 - c;
    s += a << 6 * c;
  }
  return r > _MAX_DELTA_ && (r = _MAX_DELTA_ - r), s > _MAX_DELTA_ && (s = _MAX_DELTA_ - s), i.push(i[e - 2] + r), i.push(i[e - 1] + s), 0;
}
function _char2num_(o) {
  let i = o.charCodeAt(0);
  return o >= "A" && o <= "Z" ? i - "A".charCodeAt(0) : o >= "a" && o <= "z" ? 26 + i - "a".charCodeAt(0) : o >= "0" && o <= "9" ? 52 + i - "0".charCodeAt(0) : o === "+" ? 62 : o === "/" ? 63 : -1;
}
class LocalResult {
  constructor(i = {}) {
    this.keyword = i.keyword || "", this.pageIndex = i.pageIdx || 0, this.currentNumPois = i.count || 0, this.total = i.total || 0, this.numPages = Math.ceil(i.total / i.pc), this.center = i.center, this.radius = i.radius, this.bounds = i.bounds, this.city = i.city, this.province = i.province, this.pois = i.pois && i.pois.slice(0) || [];
  }
}
const _tempVec3$2 = new Vector3$1();
class LocalSearch_Bd {
  constructor(i = {}) {
    _(this, "_isReqDataMap", (i, e) => !(!i || typeof e > "u" || i === QUERY_TYPE_POI_SEARCH && e !== RETURN_TYPE_POI_SEARCH && e !== RETURN_TYPE_CITY_LIST && e !== RETURN_TYPE_CURRENT_CITY && e !== RETURN_TYPE_SPECIAL_REGION && e !== RETURN_TYPE_NODATA_REGION || i === QUERY_TYPE_SEARCH_NEARBY && e !== RETURN_TYPE_SEARCH_NEARBY || i === QUERY_TYPE_SEARCH_INBOUNDS && e !== RETURN_TYPE_SEARCH_INBOUNDS || i === QUERY_TYPE_SEARCH_INBOUNDS_MULTIKEY && e !== RETURN_TYPE_SEARCH_INBOUNDS_MULTIKEY || i === QUERY_TYPE_SEARCH_MULTIKEY && e !== RETURN_TYPE_SEARCH_MULTIKEY || i === QUERY_TYPE_SEARCH_NEARBY_MULTIKEY && e !== RETURN_TYPE_SEARCH_NEARBY_MULTIKEY));
    _(this, "_formatAddr", (i, e) => (e = e || BMAP_POI_TYPE_NORMAL, e === BMAP_POI_TYPE_BUSSTOP || e === BMAP_POI_TYPE_SUBSTOP ? SUtil.unique(i.split(";")).join("; ") : i));
    this.options = i, this._baiduMercatorProjection = getProjection(PROJECTION_BD_MERCATOR);
  }
  async search(i, e) {
    let r = 1;
    if (this._engine) {
      const v = this._baiduMercatorProjection.projectCoordinate(
        _tempVec3$2.fromArray(this._engine.map.getCenter())
      ).toArray(), S = e.zoom || this._engine.map.getZoom();
      let E = await SearchRequestMgr.request({
        qt: QUERY_TYPE_CENTER,
        b: v[0] + "," + v[1] + ";" + v[0] + "," + v[1],
        l: S
      });
      E && E.result && E.result.type === RETURN_TYPE_CENTER && (r = E.content ? E.content.uid : 1);
    }
    const s = e.forceLocal ? QUERY_TYPE_POI_SEARCH_CON : QUERY_TYPE_POI_SEARCH;
    let a = await SearchRequestMgr.request({
      qt: s,
      c: r,
      wd: i,
      rn: e.pageCapacity,
      pn: e.pageNum
    });
    const c = a.result;
    if (c.error !== 0 || !this._isReqDataMap(s, c.type))
      return;
    const l = a.content, h = a.current_city, d = c.page_num || 0, f = c.count - (d === 0 && c.spec_dispnum || 0), p = c.total < 760 ? c.total : 760, m = d === 0 && c.spec_dispnum || 0, y = [];
    for (let v = m; v < c.count; v++)
      if (l && l[v]) {
        let S = l[v];
        if (S.addr === null)
          continue;
        let E = this._formatAddr(S.addr, S.poiType), b = [];
        if (S.cla && S.cla.length > 0) {
          let P = S.cla.length;
          for (; P--; ) {
            let D = S.cla[P][1];
            D = D.replace("<b>", "").replace("</b>", ""), b.unshift(D);
          }
        }
        let w = [];
        S.std_tag && S.std_tag.length > 0 && (w = S.std_tag.split(";"));
        let M = {
          title: S.name,
          uid: S.uid,
          adcode: S.admin_info ? S.admin_info.area_id : "",
          point: SUtil.parseGeo(S.geo, !0).point,
          address: E,
          city: S.admin_info ? S.admin_info.city_name : "",
          province: S.admin_info ? S.admin_info.province_name : "",
          areaname: S.admin_info ? S.admin_info.area_name : "",
          phoneNumber: S.tel,
          postcode: S.zip,
          type: S.poiType || BMAP_POI_TYPE_NORMAL,
          isAccurate: !!(S.acc_flag && S.acc_flag === 1),
          std_tag: w
        };
        b.length > 0 && (M.tags = b), y.push(M);
      }
    return new LocalResult({
      keyword: i,
      count: f,
      total: p,
      pageIdx: d,
      pc: e.pageCapacity,
      city: h.name,
      ccode: h.code,
      province: h.up_province_name || "",
      pois: y
    });
  }
}
const http$4 = location.protocol === "https:" ? "https" : "http";
class LocalSearch_Tdt {
  constructor(i = {}) {
    this.options = i;
  }
  async search(i, e) {
    var c, l, h;
    const r = {
      keyWord: i,
      level: 12,
      mapBound: "116.02524,39.83833,116.65592,39.99185",
      queryType: 1,
      start: e.pageNum,
      count: e.pageCapacity
    };
    if (this._engine) {
      const d = this._engine.map.getBounds(), f = e.zoom || this._engine.map.getZoom();
      r.mapBound = `${d.min.x},${d.min.y},${d.max.x},${d.max.y}`, r.level = Math.floor(f);
    }
    let s = `${http$4}://api.tianditu.gov.cn/v2/search?postStr=${JSON.stringify(r)}&type=query`, a = await ScriptLoader.request(s);
    if (a && a.status && a.status.infocode === 1e3 && a.pois) {
      const d = a.pois, f = +a.count, p = d.length || 0, m = ((h = (l = (c = a.prompt) == null ? void 0 : c[0]) == null ? void 0 : l.admins) == null ? void 0 : h[0]) || {}, y = [];
      for (let v = 0; v < p; v++) {
        const S = d[v], E = S.lonlat.split(","), b = new Vector3$1(+E[0], +E[1], 0), w = {
          title: S.name,
          uid: S.hotPointID,
          point: b,
          address: S.address,
          phoneNumber: S.phone,
          type: +S.poiType || 101,
          source: +S.source || 0,
          province: S.province || "",
          city: S.city || "",
          areaname: S.county || ""
        };
        y.push(w);
      }
      return new LocalResult({
        keyword: a.keyWord,
        count: p,
        total: f,
        pageIdx: e.pageNum,
        pc: e.pageCapacity,
        city: m.adminName,
        ccode: m.adminCode,
        province: "",
        pois: y
      });
    }
  }
}
const Xe = class {
  constructor(i = {}) {
    _(this, "result", null);
    _(this, "_markers", []);
    _(this, "_popup", null);
    i.renderOptions = i.renderOptions || {}, this.options = i, this.apiSource = i.apiSource || getApiSource(), this._local = this._createInstance(i), i.renderOptions.engine && (this._engine = i.renderOptions.engine, this._local._engine = this._engine), this.setPageCapacity(i.pageCapacity), this.setPageNum(i.pageNum);
  }
  _createInstance(i) {
    const r = {
      [API_SOURCE_BAIDU]: LocalSearch_Bd,
      [API_SOURCE_TIANDITU]: LocalSearch_Tdt
    }[this.apiSource] || LocalSearch_Bd;
    return new r(i);
  }
  async search(i, e = {}) {
    this.clearResult(), e.pageCapacity = e.pageCapacity || this.getPageCapacity(), e.pageNum = e.pageNum || this.getPageNum();
    const r = await this._local.search(i, e);
    return this.result = r, this._engine && this.renderMap(r), r;
  }
  gotoPage(i) {
    this.result && (this.setPageNum(i), this.search(this.result.keyword, {
      pageCapacity: this.getPageCapacity(),
      pageNum: this.getPageNum()
    }));
  }
  renderMap(i) {
    const e = this._engine;
    this.clearMap(), this._popup = e.add(new Popup({
      point: i.pois[0].point,
      title: i.pois[0].title,
      content: i.pois[0].address,
      offset: [0, -16]
    }));
    for (let r = 0; r < i.pois.length; r++) {
      const s = i.pois[r];
      let a;
      r < 10 ? a = e.add(new Marker({
        point: s.point,
        icon: getAssetUrl(`assets/images/markers/mkr_red_${r + 1}.png`),
        width: 42 / 2,
        height: 66 / 2
      })) : a = e.add(new Marker({
        point: s.point,
        width: 23,
        height: 25
      })), a.dom.addEventListener("click", () => {
        this.setPopupByIndex(r);
      }), this._markers.push(a);
    }
    if (this.options.renderOptions.autoViewport) {
      const r = i.pois.map((s) => s.point);
      e.map.setViewport(r, {
        range: 0
      });
    }
  }
  setPopupByIndex(i) {
    const e = this.result.pois[i];
    this._popup.point = e.point, this._popup.title = e.title, this._popup.content = e.address, this._popup.visible = !0;
  }
  clearMap() {
    if (this._engine) {
      const i = this._engine;
      for (let e = 0; e < this._markers.length; e++) {
        const r = this._markers[e];
        i.remove(r);
      }
      this._markers = [], this._popup && (i.remove(this._popup), this._popup = null);
    }
  }
  setPageCapacity(i) {
    typeof i == "number" && !isNaN(i) ? this.options.pageCapacity = i < 1 || i > Xe.MAX_PAGE_CAPACITY ? Xe.DEFAULT_PAGE_CAPACITY : i : this.options.pageCapacity = Xe.DEFAULT_PAGE_CAPACITY;
  }
  getPageCapacity() {
    return this.options.pageCapacity;
  }
  setPageNum(i) {
    typeof i == "number" && !isNaN(i) ? this.options.pageNum = i < 0 ? Xe.DEFAULT_PAGE_NUM : i : this.options.pageNum = Xe.DEFAULT_PAGE_NUM;
  }
  getPageNum() {
    return this.options.pageNum;
  }
  getResult() {
    return this.result;
  }
  clearResult() {
    this.result = null;
  }
};
let LocalSearch = Xe;
_(LocalSearch, "DEFAULT_PAGE_CAPACITY", 10), _(LocalSearch, "MIN_PAGE_CAPACITY", 1), _(LocalSearch, "MAX_PAGE_CAPACITY", 100), _(LocalSearch, "DEFAULT_RADIUS", 2e3), _(LocalSearch, "MAX_RADIUS", 1e5), _(LocalSearch, "DEFAULT_PAGE_NUM", 0);
const _tempVec3$1 = new Vector3$1();
class AutoComplete_Bd extends EventDispatcher {
  constructor(i = {}) {
    super(), this.options = {
      debounceTime: 100,
      minKeywordLength: 1,
      maxResults: 10,
      showSuggestion: !0,
      containerClassName: "autocomplete-suggestion-container",
      customStyles: {},
      ...i
    }, this._isInitialized = !1, this._exIndex = -1, this._json = null, this._typeIds = [], this._cityId = 0, this._results = null, this._word = "", this._currentRequest = null, this.oldValue = "", this.keyValue = "", this.pickValue = "", this.mousedownView = !1, this.stopCircleTemporary = !1, this.defaultIptValue = "", this.circleTimer = null, this.requestTimer = 0, this._baiduMercatorProjection = getProjection(PROJECTION_BD_MERCATOR), this.TYPES_COLLECTION = {
      ALL: "0",
      CITY: "1"
    };
  }
  initialize() {
    this._isInitialized || (this._exIndex = -1, this._json = null, this._typeIds = [], this._cityId = 0, this._results = this._createEmptyResult(), this._getTypesId(), this._getCityId(), this._initTangramStyle(), this._isInitialized = !0);
  }
  _initTangramStyle() {
    const i = this._getInputElement();
    !i || (i.setAttribute("autocomplete", "off"), this._startPolling(i));
  }
  setPickValue(i) {
    this.pickValue = i;
  }
  _startPolling(i) {
    this.circleTimer = setInterval(() => {
      if (this.stopCircleTemporary)
        return;
      if (!i || !i.parentNode) {
        this.dispose();
        return;
      }
      const e = i.value;
      e === this.oldValue && e !== "" && e !== this.keyValue && e !== this.pickValue ? this.requestTimer === 0 && (this.requestTimer = setTimeout(() => {
        this._dispatchNeedData(e);
      }, this.options.debounceTime)) : (clearTimeout(this.requestTimer), this.requestTimer = 0, e === "" && this.oldValue !== "" && (this.pickValue = ""), this.oldValue = e, e !== this.pickValue && (this.defaultIptValue = e), this.keyValue !== i.value && (this.keyValue = ""));
    }, 10);
  }
  _dispatchNeedData(i) {
    this.dispatchEvent({
      type: "needData",
      keyword: i,
      target: this
    }), this._sendAutocompleteRequest(i);
  }
  _getInputElement() {
    return typeof this.options.input == "string" ? document.getElementById(this.options.input) : this.options.input;
  }
  search(i) {
    this._sendAutocompleteRequest(i);
  }
  _sendAutocompleteRequest(i) {
    if (!i.trim())
      return;
    this._cancelCurrentRequest(), this._word = i, this._exIndex = -1, this._results = this._createEmptyResult();
    const e = this._shouldLimitCity(), r = {
      qt: "placesug",
      query: i,
      region: e ? this._cityId : 1,
      city_limit: e,
      output: "json"
    };
    this._currentRequest = SearchRequestMgr.request(r).then((s) => {
      this._handleAutocompleteResponse(s);
    }).catch((s) => {
      this._handleRequestError(s);
    });
  }
  _handleAutocompleteResponse(i) {
    try {
      if (!this._validateResponse(i))
        return;
      i.result && i.result.query && (this._word = i.result.query);
      const e = this._formatResponseData(i);
      this._results = this._createAutocompleteResult(this._json), this.dispatchEvent({
        type: "searchComplete",
        results: this._results,
        keyword: this._word,
        rawData: i,
        target: this
      });
    } catch (e) {
      this._handleRequestError(e);
    }
  }
  _cancelCurrentRequest() {
    this._currentRequest = null;
  }
  getResults() {
    return this._results;
  }
  dispose() {
    this.circleTimer && (clearInterval(this.circleTimer), this.circleTimer = null), this.requestTimer && (clearTimeout(this.requestTimer), this.requestTimer = 0), this._cancelCurrentRequest(), this._isInitialized = !1;
  }
  _validateResponse(i) {
    return !(!i || !i.result || i.status !== 0 || i.result.error !== void 0 && i.result.error !== 0);
  }
  _formatResponseData(i) {
    var c, l, h, d;
    const e = ((c = i.content) == null ? void 0 : c.poi_list) || ((l = i.result) == null ? void 0 : l.poi_list) || [], r = Math.min(e.length, this.options.maxResults), s = {
      keyword: ((h = i.result) == null ? void 0 : h.query) || this._word,
      count: r,
      status: ((d = i.result) == null ? void 0 : d.error) === 0 ? "SUCCESS" : "SERVICE_UNAVAILABLE",
      items: []
    }, a = [];
    for (let f = 0; f < r; f++) {
      const p = this._formatSingleItem(e[f]);
      s.items.push(p.value), a.push(p);
    }
    return this._json = s, {
      data: a,
      word: s.keyword
    };
  }
  _formatSingleItem(i) {
    return {
      value: {
        province: i.province || i.prov || "",
        city: i.city || i.cityname || "",
        district: i.district || i.area || "",
        street: i.name || i.street || "",
        streetNumber: i.street_number || "",
        business: i.business || "",
        address: i.address || i.addr || "",
        tag: i.tag || i.catalog || "",
        location: i.location ? new Vector3$1(i.location.lng || i.location.x, i.location.lat || i.location.y, 0) : i.point ? new Vector3$1(i.point.x, i.point.y, 0) : null
      }
    };
  }
  _handleRequestError(i) {
    console.error("AutoComplete request failed:", i), this.dispatchEvent({
      type: "error",
      message: i.message || "Request failed",
      target: this
    });
  }
  setTypes(i) {
    this.options.types = i, this._getTypesId();
  }
  _shouldLimitCity() {
    const i = this._typeIds.split(",");
    return i.length >= 1 && Number(i[0]) === 1;
  }
  _getTypesId() {
    const i = this.options.types, e = [];
    typeof i == "string" ? e.push(this.TYPES_COLLECTION[i.toUpperCase()] || "0") : Array.isArray(i) && i.forEach((r) => {
      e.push(this.TYPES_COLLECTION[r.toUpperCase()] || "0");
    }), this._typeIds = e.length > 0 ? e.join(",") : "0";
  }
  async _getCityId() {
    const i = this.options.location;
    let e = 1;
    if (i) {
      const s = this._baiduMercatorProjection.projectCoordinate(
        _tempVec3$1.fromArray(i)
      ).toArray(), a = await SearchRequestMgr.request({
        qt: QUERY_TYPE_CENTER,
        b: s[0] + "," + s[1] + ";" + s[0] + "," + s[1],
        l: 18
      });
      a && a.result && a.result.type === RETURN_TYPE_CENTER && (e = a.content ? a.content.uid : 1);
    }
    this._cityId = e;
  }
  _createEmptyResult() {
    return {
      keyword: this._word || "",
      total: 0,
      pois: []
    };
  }
  _createAutocompleteResult(i) {
    if (!i)
      return this._createEmptyResult();
    const e = i.items.map((r) => r.value || r);
    return {
      keyword: i.keyword,
      total: i.count,
      pois: e
    };
  }
}
class AutoComplete extends EventDispatcher {
  constructor(i = {}) {
    super(), this.options = {
      input: null,
      types: [],
      location: null,
      maxResults: 10,
      debounceTime: 100,
      apiSource: getApiSource(),
      ...i
    }, this.apiSource = this.options.apiSource || getApiSource(), this._ac = this._createInstance(this.options), this._isInitialized = !1, this.initialize();
  }
  _createInstance(i) {
    const r = {
      [API_SOURCE_BAIDU]: AutoComplete_Bd
    }[this.apiSource] || AutoComplete_Bd;
    return this.apiSource === API_SOURCE_BAIDU ? AutoComplete_Bd.create ? AutoComplete_Bd.create(i) : new r(i) : new r(i);
  }
  _bindEvents() {
    this._ac.addEventListener("searchComplete", (i) => {
      this.dispatchEvent({
        type: "searchComplete",
        results: i.results,
        keyword: i.keyword,
        target: this
      });
    }), this._ac.addEventListener("error", (i) => {
      this.dispatchEvent({
        type: "error",
        message: i.message,
        target: this
      });
    }), this._ac.addEventListener("needData", (i) => {
      this.dispatchEvent({
        type: "needData",
        keyword: i.keyword,
        target: this
      });
    });
  }
  initialize() {
    return this._isInitialized || (this._ac.initialize(), this._bindEvents(), this._isInitialized = !0), this;
  }
  setPickValue(i) {
    this._ac.setPickValue(i);
  }
  search(i) {
    return this._ac.search && this._ac.search(i), this;
  }
  setTypes(i) {
    return this._ac.setTypes && this._ac.setTypes(i), this;
  }
  getResults() {
    return this._ac.getResults ? this._ac.getResults() : null;
  }
  dispose() {
    this._ac && (this._ac.dispose(), this._ac = null), this._isInitialized = !1;
  }
  getInstance() {
    return this._ac;
  }
}
const Taiwanboundary = [
  [
    [119.590757, 23.808251],
    [119.268804, 23.41408],
    [119.422881, 23.163397],
    [119.758632, 23.201668],
    [119.726437, 23.588002],
    [119.70804, 23.763808],
    [119.645949, 23.797671]
  ],
  [
    [121.642055, 25.312114],
    [121.752439, 25.169879],
    [121.945611, 25.186621],
    [121.991604, 25.052618],
    [122.055995, 24.985561],
    [121.872022, 24.834547],
    [121.88122, 24.624496],
    [121.899617, 24.498294],
    [121.798432, 24.270807],
    [121.697247, 24.135805],
    [121.642055, 23.958396],
    [121.504076, 23.288798],
    [121.439685, 23.178281],
    [121.310904, 22.991042],
    [121.255712, 22.812068],
    [121.053342, 22.624316],
    [120.933759, 22.290847],
    [121.016547, 21.990891],
    [120.86017, 21.887901],
    [120.648601, 21.947988],
    [120.584211, 22.376429],
    [120.289854, 22.51325],
    [120.11508, 22.939931],
    [120.013895, 23.118734],
    [119.9771, 23.543483],
    [120.372642, 24.11892],
    [120.694595, 24.641313],
    [121.126931, 25.119638],
    [121.559268, 25.337197],
    [121.623658, 25.345557]
  ],
  [
    [120.38414, 22.372151],
    [120.423234, 22.355038],
    [120.372642, 22.307967],
    [120.347346, 22.329365],
    [120.351945, 22.355038],
    [120.356544, 22.363595]
  ],
  [
    [121.506375, 22.696888],
    [121.552369, 22.660607],
    [121.517874, 22.611506],
    [121.469581, 22.64353],
    [121.464981, 22.690486],
    [121.492577, 22.701155]
  ],
  [
    [121.589163, 22.100236],
    [121.600661, 22.050934],
    [121.623658, 22.012338],
    [121.637456, 21.939406],
    [121.596062, 21.93726],
    [121.550069, 22.014483],
    [121.499476, 22.044502],
    [121.501776, 22.102379],
    [121.54087, 22.102379]
  ],
  [
    [122.08819, 25.668005],
    [122.110037, 25.488627],
    [121.911116, 25.435387],
    [122.027249, 25.658625],
    [122.057144, 25.669047]
  ],
  [
    [123.686455, 25.955273],
    [123.730149, 25.909524],
    [123.58527, 25.699264],
    [123.454189, 25.743012],
    [123.557674, 25.817972],
    [123.594468, 25.84711]
  ],
  [
    [124.589072, 25.924082],
    [124.60172, 25.894964],
    [124.564926, 25.902244],
    [124.567226, 25.929282],
    [124.571825, 25.930321]
  ],
  [
    [115.973388, 21.36321],
    [116.152762, 21.298566],
    [116.152762, 21.164878],
    [116.148163, 21.039704],
    [116.056176, 21.000836],
    [115.863004, 21.035386],
    [115.835409, 21.143304],
    [115.830809, 21.26839],
    [115.844607, 21.358902],
    [115.922796, 21.36321]
  ],
  [
    [118.474702, 24.527161],
    [118.4862, 24.509276],
    [118.491949, 24.487706],
    [118.498848, 24.46771],
    [118.501148, 24.448764],
    [118.501148, 24.435079],
    [118.492524, 24.422972],
    [118.481026, 24.411916],
    [118.467228, 24.406125],
    [118.443082, 24.39928],
    [118.41721, 24.386643],
    [118.378116, 24.379797],
    [118.314301, 24.369264],
    [118.28728, 24.371898],
    [118.247035, 24.378217],
    [118.230363, 24.377164],
    [118.202192, 24.376111],
    [118.182645, 24.375584],
    [118.167122, 24.375584],
    [118.159073, 24.378744],
    [118.156199, 24.389802],
    [118.160223, 24.397174],
    [118.167697, 24.407178],
    [118.17862, 24.424024],
    [118.194718, 24.434026],
    [118.210241, 24.444027],
    [118.232088, 24.457185],
    [118.254509, 24.472972],
    [118.275206, 24.488232],
    [118.289579, 24.497702],
    [118.316025, 24.506646],
    [118.35052, 24.521375],
    [118.368918, 24.529791],
    [118.386165, 24.537154],
    [118.405137, 24.540836],
    [118.425834, 24.543465],
    [118.449981, 24.541888],
    [118.460904, 24.53768]
  ]
];
class Boundary_Bd {
  constructor(i = {}) {
    this.options = i;
  }
  _isBohai(i) {
    return i.lng >= 117.546263 && i.lng <= 118.711042 && i.lat >= 38.697981 && i.lat <= 38.91302;
  }
  _isMacao(i) {
    return i.lng >= 113.576516 && i.lng <= 113.638822 && i.lat >= 22.146067 && i.lat <= 22.156645;
  }
  _dealHainan(i, e, r, s) {
    i.lng > 109 && i.lng < 113 && i.lat > 15 && i.lat < 19 && (i.lng - e.lng > 1 && i.lat - e.lat < -1 && (s.hainanLine = !0, s.hainanIndexA = r / 2), i.lng - e.lng < -1 && i.lat - e.lat > 1 && (s.hainanLine = !0, s.hainanIndexB = r / 2));
  }
  _processCoordinateRecord(i, e) {
    const r = i.length - 1, s = [], a = {
      hainanLine: !1,
      hainanIndexA: 0,
      hainanIndexB: 0
    };
    for (let c = 0; c < r; c += 2) {
      const l = i[c], h = i[c + 1], d = MercatorProjection.convertMC2LL({
        lng: l,
        lat: h
      });
      let f = null;
      if (c < r - 3) {
        const p = i[c + 2], m = i[c + 3];
        f = MercatorProjection.convertMC2LL({
          lng: p,
          lat: m
        });
      }
      if (e.indexOf("\u5168\u56FD") > -1 || e.indexOf("\u4E2D\u56FD") > -1 || e.indexOf("\u4E2D\u534E\u4EBA\u6C11\u5171\u548C\u56FD") > -1) {
        if (this._isBohai(d) || this._isMacao(d))
          return [];
        f && this._dealHainan(d, f, c, a);
      }
      e.indexOf("\u6D77\u5357") > -1 && f && this._dealHainan(d, f, c, a), s.push([Number(d.lng), Number(d.lat)]);
    }
    return a.hainanLine ? this._splitHainanBoundary(s, a) : s.length > 0 ? [s] : [];
  }
  _splitHainanBoundary(i, e) {
    let { hainanIndexA: r, hainanIndexB: s } = e;
    if (r > s) {
      const h = r;
      r = s, s = h;
    }
    const a = i, c = i.splice(r + 1), l = c.splice(s - r);
    return a.push(...l), [a, c];
  }
  get(i, e) {
    const r = { boundaries: [] };
    if (["\u4E2D\u56FD", "\u5168\u56FD", "\u4E2D\u534E\u4EBA\u6C11\u5171\u548C\u56FD"].includes(i)) {
      e && e(r);
      return;
    }
    if (i === "\u53F0\u6E7E\u7701" || i === "\u53F0\u6E7E") {
      for (let s = 0; s < 6; s++)
        r.boundaries[s] = Taiwanboundary[s];
      r.boundaries[6] = Taiwanboundary[9], e && e(r);
      return;
    }
    if (i === "\u9493\u9C7C\u5C9B") {
      r.boundaries[0] = Taiwanboundary[6], e && e(r);
      return;
    }
    if (i === "\u8D64\u5C3E\u5C7F") {
      r.boundaries[0] = Taiwanboundary[7], e && e(r);
      return;
    }
    SearchRequestMgr.request({ qt: QUERY_TYPE_POI_SEARCH, wd: i }).then((s) => {
      if (!(s && s.content && s.content.uid || i)) {
        e && e(r);
        return;
      }
      const a = s.content && s.content.uid ? s.content.uid : "";
      SearchRequestMgr.request({
        qt: QUERY_TYPE_EXT,
        num: 1e3,
        l: 10,
        uid: a,
        adname: i
      }).then((c) => {
        this._processBoundariesResponse(c, i, r), e && e(r);
      });
    });
  }
  _processBoundariesResponse(i, e, r) {
    if (!i || !i.content || !i.content.geo)
      return;
    const s = SUtil.parseGeo(i.content.geo, !1);
    if (!(!s.geo || s.geo.length === 0)) {
      for (const a of s.geo) {
        if (!a || a.length === 0)
          continue;
        const c = this._processCoordinateRecord(a, e);
        r.boundaries.push(...c);
      }
      if ((e === "\u4E2D\u56FD" || e === "\u5168\u56FD" || e === "\u4E2D\u534E\u4EBA\u6C11\u5171\u548C\u56FD") && r.boundaries.length > 0) {
        const a = r.boundaries.length;
        for (let c = 0; c < Taiwanboundary.length - 1; c++)
          r.boundaries[a + c] = Taiwanboundary[c];
      }
    }
  }
  toString() {
    return "Boundary_Bd";
  }
}
const http$3 = location.protocol === "https:" ? "https" : "http";
class Boundary_Tdt {
  constructor(i = {}) {
    this.options = i;
  }
  _parseWktBoundary(i) {
    const e = parseWkt(i), r = [];
    return e && (e.type === "Polygon" ? e.coordinates.forEach((s) => {
      r.push(s.map((a) => [Number(a[0]), Number(a[1])]));
    }) : e.type === "MultiPolygon" && e.coordinates.forEach((s) => {
      s.forEach((a) => {
        r.push(a.map((c) => [Number(c[0]), Number(c[1])]));
      });
    })), r;
  }
  get(i, e) {
    const r = `${http$3}://api.tianditu.gov.cn/v2/administrative?keyword=${encodeURIComponent(i)}&childLevel=0&extensions=true`;
    ScriptLoader.request(r).then((s) => {
      const a = { boundaries: [] };
      s && s.data && s.data.length > 0 && s.data.forEach((c) => {
        c.boundary && (Array.isArray(c.boundary) ? c.boundary : [c.boundary]).forEach((h) => {
          const d = this._parseWktBoundary(h);
          a.boundaries.push(...d);
        });
      }), e && e(a);
    }).catch(() => {
      e && e({ boundaries: [] });
    });
  }
  toString() {
    return "Boundary_Tdt";
  }
}
class Boundary {
  constructor(i = {}) {
    this.options = i, this.apiSource = i.apiSource || getApiSource(), this._boundary = this._createInstance(i);
  }
  _createInstance(i) {
    const r = {
      [API_SOURCE_BAIDU]: Boundary_Bd,
      [API_SOURCE_TIANDITU]: Boundary_Tdt
    }[this.apiSource] || Boundary_Bd;
    return new r(i);
  }
  get(i, e) {
    return this._boundary.get(i, e);
  }
  toString() {
    return "Boundary";
  }
}
class DistrictLayer_Bd {
  constructor(i = {}) {
    this.options = { ...i }, this._map = null, this._layer = null, this._data = null;
  }
  setOptions(i) {
    this.options = {
      ...this.options,
      ...i
    };
  }
  setName(i) {
    this.options.name = i;
  }
  setKind(i) {
    this.options.kind = i;
  }
  async _loadDistrict() {
    var a;
    const i = this.options.name || "", e = (a = this.options.kind) != null ? a : 0, r = await SearchRequestMgr.request({ qt: QUERY_TYPE_EXTS, adnames: i, level: e }), s = this._parseGeoData(r);
    return this.geojsonCoordConvert(s), this._data = s, s;
  }
  _parseGeoData(i) {
    let e = {
      type: "FeatureCollection",
      features: []
    };
    if (i && i.content && i.content.geometry) {
      let r = i.content.geometry;
      for (let s = 0; s < r.length; s++) {
        let a = r[s], c = a.slice(6, 8);
        a = a.slice(8, a.length) + c, a = atob(a), a = parseWkt(a);
        let l = {
          type: "Feature",
          geometry: a,
          properties: {
            index: s
          }
        };
        e.features.push(l);
      }
    }
    return e;
  }
  geojsonCoordConvert(i) {
    let e = this.options.kind || 0;
    for (let r = 0; r < i.features.length; r++) {
      let s = i.features[r];
      e === 1 && r === 0 && (s.geometry.coordinates = s.geometry.coordinates.filter((c, l) => l !== 0));
      const a = s.geometry.coordinates.length;
      for (let c = 0; c < a; c++) {
        const l = s.geometry.coordinates[c];
        s.geometry.coordinates[c] = l.map((h) => h.map((d) => {
          const f = MercatorProjection.convertMC2LL({
            lng: d[0],
            lat: d[1]
          });
          return [Number(f.lng), Number(f.lat)];
        }));
      }
    }
  }
  geojson2boundaries(i) {
    let e = {
      boundaries: []
    }, r = 0;
    for (let s = 0; s < i.features.length; s++) {
      r += i.features[s].geometry.coordinates.length;
      for (let a = 0; a < i.features[s].geometry.coordinates.length; a++) {
        let c = i.features[s].geometry.coordinates[a];
        const l = [];
        for (let h = 0; h < c[0].length; h++) {
          const d = MercatorProjection.convertMC2LL({
            lng: c[0][h][0],
            lat: c[0][h][1]
          });
          l.push([
            d.lng,
            d.lat
          ]);
        }
        e.boundaries.push(l);
      }
    }
    return e;
  }
  searchBoundary(i, e) {
    const r = i.name || this.options.name || "", s = i.kind || this.options.kind || 0;
    SearchRequestMgr.request({ qt: QUERY_TYPE_EXTS, adnames: r, level: s }).then((a) => {
      const c = this._parseGeoData(a), l = this.geojson2boundaries(c);
      e && e(l);
    });
  }
}
const http$2 = location.protocol === "https:" ? "https" : "http";
class DistrictLayer_Tdt {
  constructor(i = {}) {
    this.options = { ...i }, this._data = null;
  }
  setOptions(i) {
    this.options = {
      ...this.options,
      ...i
    };
  }
  setName(i) {
    this.options.name = i;
  }
  setKind(i) {
    this.options.kind = i;
  }
  async _loadDistrict() {
    var a;
    const i = this.options.name || "", e = (a = this.options.kind) != null ? a : 0, r = await this._requestDistrictData(i, e), s = this._parseGeoData(r);
    return this.geojsonCoordConvert(s), this._data = s, s;
  }
  async _requestDistrictData(i, e) {
    const r = `${http$2}://api.tianditu.gov.cn/v2/administrative?keyword=${encodeURIComponent(i)}&childLevel=${e}&extensions=true`;
    try {
      return await ScriptLoader.request(r);
    } catch (s) {
      return console.error("\u5929\u5730\u56FE\u884C\u653F\u533A\u5212\u8BF7\u6C42\u5931\u8D25:", s), { data: [] };
    }
  }
  _parseGeoData(i) {
    let e = {
      type: "FeatureCollection",
      features: []
    };
    return i && i.data && i.data.length > 0 && i.data.forEach((r, s) => {
      r.boundary && (Array.isArray(r.boundary) ? r.boundary : [r.boundary]).forEach((c) => {
        const l = parseWkt(c);
        if (l) {
          let h = {
            type: "Feature",
            geometry: l,
            properties: {
              index: s,
              name: r.name || ""
            }
          };
          e.features.push(h);
        }
      });
    }), e;
  }
  geojsonCoordConvert(i) {
    for (let e = 0; e < i.features.length; e++) {
      let r = i.features[e];
      r.geometry && r.geometry.coordinates && (r.geometry.type === "Polygon" ? r.geometry.coordinates = r.geometry.coordinates.map((s) => s.map((a) => [Number(a[0]), Number(a[1])])) : r.geometry.type === "MultiPolygon" && (r.geometry.coordinates = r.geometry.coordinates.map((s) => s.map((a) => a.map((c) => [Number(c[0]), Number(c[1])])))));
    }
  }
  geojson2boundaries(i) {
    let e = {
      boundaries: []
    };
    for (let r = 0; r < i.features.length; r++) {
      let s = i.features[r];
      s.geometry && s.geometry.coordinates && (s.geometry.type === "Polygon" ? s.geometry.coordinates.forEach((a) => {
        e.boundaries.push(a);
      }) : s.geometry.type === "MultiPolygon" && s.geometry.coordinates.forEach((a) => {
        a.forEach((c) => {
          e.boundaries.push(c);
        });
      }));
    }
    return e;
  }
  searchBoundary(i, e) {
    const r = i.name || this.options.name || "", s = i.kind || this.options.kind || 0;
    this._requestDistrictData(r, s).then((a) => {
      const c = this._parseGeoData(a), l = this.geojson2boundaries(c);
      e && e(l);
    });
  }
}
function pushInBatches(o, i, e = 1e4) {
  for (let r = 0; r < i.length; r += e)
    o.push(...i.slice(r, r + e));
}
function createEdgePoint(o, i) {
  const e = [];
  for (let r = 0; r < i.length; r++) {
    const s = i[r], [a, c] = s;
    r === 0 && e.push(o[a]), e.push(o[c]);
  }
  return e;
}
function dedupPoints(o) {
  let i = {}, e = {}, r = [], s = 0;
  for (let a = 0; a < o.length; a++) {
    const c = o[a], l = c[2] || 0, h = `${c[0]},${c[1]},${l}`;
    i[h] !== void 0 ? s++ : (i[h] = a - s, r.push(c));
    const d = i[h];
    e[a] = d;
  }
  return {
    indexMap: e,
    points: r
  };
}
function dedupEdges(o, i) {
  let e = [], r = {}, s = 0;
  for (let a = 0; a < o.length; a++) {
    const c = o[a];
    if (c[0] = i[c[0]], c[1] = i[c[1]], c[0] === c[1])
      continue;
    const l = `${c[0]},${c[1]}`;
    r[l] !== void 0 ? s++ : (r[l] = a - s, e.push(c));
  }
  return e;
}
function isClockWise(o) {
  let i = o.length, e = 0;
  for (let r = i - 1, s = 0; s < i; r = s++)
    e += o[r][0] * o[s][1] - o[s][0] * o[r][1];
  return e < 0;
}
const defaultColor = [1, 1, 0, 1];
let positionVec3$1 = new Vector3$1(), positionTemp$1 = new Vector3$1();
const subdivisionV0Scratch = new Vector3$1(), subdivisionV1Scratch = new Vector3$1(), subdivisionV2Scratch = new Vector3$1(), subdivisionS0Scratch = new Vector3$1(), subdivisionS1Scratch = new Vector3$1(), subdivisionS2Scratch = new Vector3$1(), subdivisionMidScratch = new Vector3$1(), subdivisionT0Scratch = new Vector2$1(), subdivisionT1Scratch = new Vector2$1(), subdivisionT2Scratch = new Vector2$1(), scaleToGeodeticHeightN1$1 = new Vector3$1(), scaleToGeodeticHeightN2$1 = new Vector3$1(), scaleToGeodeticHeightP1 = new Vector3$1(), scaleToGeodeticHeightP2$1 = new Vector3$1(), scratchCartesian3Position1$1 = new Vector3$1(), scratchCartesian3Position4$1 = new Vector3$1(), scratchRotatePoint = new Vector2$1(), scratchPrevPoint = [0, 0, 0], scratchPoint = [0, 0, 0], scratchNextPoint = [0, 0, 0], subdivideHeightsScratchArray$1 = [], subdivideHeights$1 = (o, i, e) => {
  const r = subdivideHeightsScratchArray$1;
  r.length = o;
  let s = 0;
  if (i === e) {
    for (s = 0; s < o; s++)
      r[s] = i;
    return r;
  }
  const c = (e - i) / o;
  for (let l = 0; l < o; l++) {
    const h = i + l * c;
    r[l] = h;
  }
  return r;
}, distanceScratch$1 = new Vector3$1(), getPointAtDistance$1 = (o, i, e, r) => (Cartesian3.subtract(i, o, distanceScratch$1), Cartesian3.multiplyByScalar(
  distanceScratch$1,
  e / r,
  distanceScratch$1
), Cartesian3.add(o, distanceScratch$1, distanceScratch$1), [distanceScratch$1.x, distanceScratch$1.y, distanceScratch$1.z]), p1Scratch$2 = new Vector3$1(), p2Scratch$1 = new Vector3$1(), computeSubdivision = (o, i, e, r, s, a, c, l = !0) => {
  c = c || CesiumMath.RADIANS_PER_DEGREE;
  const h = !!a, d = r.slice(0);
  let f = 0;
  const p = i.length, m = new Array(p * 3), y = new Array(p * 2), x = new Array(p);
  let v = 0, S = 0, E = 0;
  for (f = 0; f < p; f++) {
    const O = i[f];
    if (m[v++] = O.x, m[v++] = O.y, m[v++] = O.z, h) {
      const F = a[f];
      y[S++] = F.x, y[S++] = F.y;
    }
    x[E++] = e[f];
  }
  const b = [], w = {}, M = {}, P = o.maximumRadius, D = CesiumMath.chordLength(c, P), L = D * D;
  for (; d.length > 0; ) {
    const O = d.pop(), F = d.pop(), k = d.pop(), V = subdivisionV0Scratch.fromArray(m, k * 3), N = subdivisionV1Scratch.fromArray(m, F * 3), U = subdivisionV2Scratch.fromArray(m, O * 3), z = x[k], $ = x[F], G = x[O];
    let j, Y, H;
    h && (j = subdivisionT0Scratch.fromArray(y, k * 2), Y = subdivisionT1Scratch.fromArray(y, F * 2), H = subdivisionT2Scratch.fromArray(y, O * 2));
    const W = Cartesian3.multiplyByScalar(
      Cartesian3.normalize(V, subdivisionS0Scratch),
      P,
      subdivisionS0Scratch
    ), q = Cartesian3.multiplyByScalar(
      Cartesian3.normalize(N, subdivisionS1Scratch),
      P,
      subdivisionS1Scratch
    ), Z = Cartesian3.multiplyByScalar(
      Cartesian3.normalize(U, subdivisionS2Scratch),
      P,
      subdivisionS2Scratch
    ), X = Cartesian3.magnitudeSquared(Cartesian3.subtract(W, q, subdivisionMidScratch)), K = Cartesian3.magnitudeSquared(Cartesian3.subtract(q, Z, subdivisionMidScratch)), ee = Cartesian3.magnitudeSquared(Cartesian3.subtract(Z, W, subdivisionMidScratch)), ie = Math.max(X, K, ee);
    let re, ne, J, oe;
    l && ie > L ? X === ie ? (re = `${Math.min(k, F)} ${Math.max(k, F)}`, f = w[re], f == null ? (ne = Cartesian3.add(V, N, subdivisionMidScratch), Cartesian3.multiplyByScalar(ne, 0.5, ne), m.push(ne.x, ne.y, ne.z), f = m.length / 3 - 1, w[re] = f, oe = (z + $) * 0.5, x.push(oe), M[re] = oe, h && (J = Cartesian2.add(j, Y, subdivisionMidScratch), Cartesian2.multiplyByScalar(J, 0.5, J), y.push(J.x, J.y))) : oe = M[re], d.push(k, f, O), d.push(f, F, O)) : K === ie ? (re = `${Math.min(F, O)} ${Math.max(F, O)}`, f = w[re], f ? oe = M[re] : (ne = Cartesian3.add(N, U, subdivisionMidScratch), Cartesian3.multiplyByScalar(ne, 0.5, ne), m.push(ne.x, ne.y, ne.z), f = m.length / 3 - 1, w[re] = f, oe = ($ + G) * 0.5, x.push(oe), M[re] = oe, h && (J = Cartesian2.add(Y, H, subdivisionMidScratch), Cartesian2.multiplyByScalar(J, 0.5, J), y.push(J.x, J.y))), d.push(F, f, k), d.push(f, O, k)) : ee === ie && (re = `${Math.min(O, k)} ${Math.max(O, k)}`, f = w[re], f ? oe = M[re] : (ne = Cartesian3.add(U, V, subdivisionMidScratch), Cartesian3.multiplyByScalar(ne, 0.5, ne), m.push(ne.x, ne.y, ne.z), f = m.length / 3 - 1, w[re] = f, oe = (G + z) * 0.5, x.push(oe), M[re] = oe, h && (J = Cartesian2.add(H, j, subdivisionMidScratch), Cartesian2.multiplyByScalar(J, 0.5, J), y.push(J.x, J.y))), d.push(O, f, F), d.push(f, k, F)) : (b.push(k + s), b.push(F + s), b.push(O + s));
  }
  return {
    subdividedPositions: m,
    subdividedTexcoords: y,
    subdividedIndices: b,
    subdividedHeights: x
  };
};
class PolygonGeometry extends BufferGeometry {
  constructor(e) {
    super();
    _(this, "isPolygonGeometry", !0);
    _(this, "_useUV", !1);
    _(this, "_useEarCut", !1);
    _(this, "_sideUVNormalized", !1);
    _(this, "_sideUVReversed", !1);
    _(this, "_sideUVUseHeight", !1);
    _(this, "_rectangle", null);
    _(this, "triangulate", (e, r) => {
      const s = e.reduce((a, c) => a.concat(c.toArray()), []);
      return earcut(s, r);
    });
    _(this, "addGeoPolygonToVertices", (e, r, s = 0, a = 0, c, l, h, d, f, p, m, y, x, v, S = !1) => {
      let E = e.vertices;
      const b = e.dimensions;
      Array.isArray(m) || (m = defaultColor);
      let w = 1 / 0, M = 1 / 0, P = -1 / 0, D = -1 / 0;
      for (let V = 0, N = E.length - b + 1; V < N; V += b)
        w = E[V] < w ? E[V] : w, M = E[V + 1] < M ? E[V + 1] : M, P = E[V] > P ? E[V] : P, D = E[V + 1] > D ? E[V + 1] : D;
      const L = new Vector2$1((P + w) / 2, (D + M) / 2), O = new Vector3$1(), F = new Vector3$1();
      let k = [];
      for (let V = 0; V <= r.length - b; V += b) {
        let N = [];
        for (let z = 0; z < 3; z++) {
          const G = r[V + z] * b;
          let j;
          b === 2 || S && !this.perPositionHeight ? j = new Vector3$1(E[G], E[G + 1], s) : j = new Vector3$1(E[G], E[G + 1], E[G + 2] + s), N.push(j), c.push(j.x, j.y, j.z), p.push(m[0], m[1], m[2], m[3]), this._pushHeightAndConcave(v, s, -1), rotatePoint(
            scratchRotatePoint.set(E[G], E[G + 1]),
            L,
            f
          ), d.push(scratchRotatePoint.x - w, scratchRotatePoint.y - M), y.push(x), k.push(a + V + z);
        }
        let U = [0, 0, 1];
        b !== 2 && (O.subVectors(N[2], N[1]), F.subVectors(N[0], N[1]), O.cross(F), O.normalize(), U = O.toArray()), h.push(
          ...U,
          ...U,
          ...U
        );
      }
      S ? l.push(...k.reverse()) : l.push(...k);
    });
    _(this, "_encodeConcave", (e, r, s) => {
      let a = 0;
      return e && (a |= 1), r && (a |= 2), s && (a |= 4), a;
    });
    _(this, "_pushHeightAndConcave", (e, r, s, a, c, l, h) => {
      if (s === -1) {
        e.push(r, this._encodeConcave(!1, !1, !1));
        return;
      }
      const d = isAOConcaveAngle(a, c, l), f = Array.isArray(e);
      s === 0 ? f ? e.push(
        0,
        this._encodeConcave(!0, d, !1),
        r,
        this._encodeConcave(!1, d, !1)
      ) : (e.bottom.push(0, this._encodeConcave(!0, d, !1)), e.top.push(r, this._encodeConcave(!1, d, !1))) : s === h - 1 ? f ? e.push(
        r,
        this._encodeConcave(!1, d, !0),
        0,
        this._encodeConcave(!0, d, !0)
      ) : (e.bottom.push(
        0,
        this._encodeConcave(!0, d, !0)
      ), e.top.push(
        r,
        this._encodeConcave(!1, d, !0)
      )) : f ? e.push(
        r,
        this._encodeConcave(!1, d, !0),
        0,
        this._encodeConcave(!0, d, !0),
        0,
        this._encodeConcave(!0, d, !1),
        r,
        this._encodeConcave(!1, d, !1)
      ) : (e.bottom.push(
        0,
        this._encodeConcave(!0, d, !0),
        0,
        this._encodeConcave(!0, d, !1)
      ), e.top.push(
        r,
        this._encodeConcave(!1, d, !0),
        r,
        this._encodeConcave(!1, d, !1)
      ));
    });
    _(this, "_pushPosition", (e, r, s, a) => {
      const c = this._calculateHeights(r, s, a);
      e.push(
        r[0],
        r[1],
        c.bottom,
        r[0],
        r[1],
        c.top,
        s[0],
        s[1],
        c.nextTop,
        s[0],
        s[1],
        c.nextBottom
      );
    });
    _(this, "_pushNormal", (e, r, s) => {
      const a = this._calculateNormal(r, s);
      e.push(...a, ...a, ...a, ...a);
    });
    _(this, "_pushUV", (e, r, s, a, c) => {
      let h = 0, d = 0, f = s[0] - r[0], p = s[1] - r[1];
      const m = Math.sqrt(f * f + p * p);
      return this._sideUVUseHeight ? (h = a * 1, d = a * 1) : (h = 0, d = a * 1, this._sideUVNormalized && (d = 1), this._sideUVReversed && (h = d, d = 0)), e.push(
        c * 1,
        h,
        c * 1,
        d
      ), c += m, e.push(
        c * 1,
        d,
        c * 1,
        h
      ), c;
    });
    _(this, "_pushColor", (e, r, s = 4) => {
      for (let a = 0; a < s; a++)
        e.push(r[0], r[1], r[2], r[3]);
    });
    _(this, "_pushObjectIndex", (e, r) => {
      e.push(r, r, r, r);
    });
    _(this, "addSideFace", (e, r, s, a, c, l, h, d, f, p, m, y) => {
      let x = s;
      isClockWise(e) && e.reverse(), Array.isArray(f) || (f = defaultColor);
      const v = e.length;
      let S = 0;
      for (let E = 0, b = v; E < b; E++) {
        let w = E === 0 ? e.length - 2 : E - 1, M = E === e.length - 1 ? 1 : E + 1, P = e[w], D = e[E], L = e[M];
        this._pushHeightAndConcave(
          y,
          r,
          E,
          P,
          D,
          L,
          v
        ), E !== e.length - 1 && (M = (E + 1) % v, L = e[M], this._pushPosition(a, D, L, r), this._pushNormal(l, D, L), this._pushColor(d, f), this._pushObjectIndex(p, m), S = this._pushUV(h, D, L, r, S), x = s + E * 4, c.push(
          x,
          x + 2,
          x + 1,
          x,
          x + 3,
          x + 2
        ));
      }
    });
    _(this, "subdivideLineCount", (e, r, s) => {
      const c = e.distanceTo(r) / s, l = Math.max(0, Math.ceil(Math.log2(c)));
      return Math.pow(2, l);
    });
    _(this, "subdivideLine", (e, r, s, a, c, l, h, d, f, p, m) => {
      const y = this.subdivideLineCount(e, r, l), x = e.distanceTo(r), v = x / y;
      this.extrude && this._extrudeValue > 0;
      let S = Cartesian3.clone(e, new Vector3$1()), E = Cartesian3.clone(r, new Vector3$1()), b = new Vector3$1(), w = new Vector3$1(), M = s, P = a;
      const D = h.scaleToGeodeticSurface(S);
      h.geodeticSurfaceNormal(S, b);
      const L = h.scaleToGeodeticSurface(E);
      h.geodeticSurfaceNormal(E, w), M += this._zOffset, P += this._zOffset, this.extrude && (M += d, P += d), Cartesian3.multiplyByScalar(b, M, b), Cartesian3.add(D, b, S), Cartesian3.multiplyByScalar(w, P, w), Cartesian3.add(L, w, E), p || (p = []), m || (m = []);
      const O = new Vector3$1(), F = new Vector3$1();
      let k = [], V, N;
      V = h.cartesianToCartographic(S, F).z, N = h.cartesianToCartographic(E, F).z, k = subdivideHeights$1(y, V, N);
      const U = scaleToGeodeticHeightN1$1;
      let z = scaleToGeodeticHeightN2$1, $ = scaleToGeodeticHeightP2$1, G = 0, j = 0;
      for (let Y = 0; Y < y; Y++) {
        const H = O.fromArray(
          getPointAtDistance$1(S, E, v * Y, x)
        );
        j = k[Y], h.geodeticSurfaceNormal(H, U), $ = h.scaleToGeodeticSurface(H, $), z = Cartesian3.multiplyByScalar(U, this._zOffset + c, z), z = Cartesian3.add($, z, z), m[G] = z.x, m[G + 1] = z.y, m[G + 2] = z.z, Y > 0 && f.bottom.push(0, this._encodeConcave(!0, !1, !1)), this.perPositionHeight ? ($ = Cartesian2.clone(H, $), z = Cartesian3.clone($, z)) : (z = Cartesian3.multiplyByScalar(U, j, z), z = Cartesian3.add($, z, z)), p[G] = z.x, p[G + 1] = z.y, p[G + 2] = z.z, Y > 0 && f.top.push(d, this._encodeConcave(!0, !1, !1)), G += 3;
      }
      return h.geodeticSurfaceNormal(E, U), $ = h.scaleToGeodeticSurface(E, $), z = Cartesian3.multiplyByScalar(U, this._zOffset + c, z), z = Cartesian3.add($, z, z), m[G] = z.x, m[G + 1] = z.y, m[G + 2] = z.z, this.perPositionHeight ? z = Cartesian2.clone(E, z) : (z = Cartesian3.multiplyByScalar(U, N, z), z = Cartesian3.add($, z, z)), p[G] = z.x, p[G + 1] = z.y, p[G + 2] = z.z, {
        topPositions: p,
        bottomPositions: m
      };
    });
    _(this, "crossVectors3", (e, r) => {
      const s = [];
      return s[0] = e[1] * r[2] - e[2] * r[1], s[1] = e[2] * r[0] - e[0] * r[2], s[2] = e[0] * r[1] - e[1] * r[0], s;
    });
    this.parameters = e, this._needsUpdate = !1, this._extrude = defaultValue$1(e.extrude, !1), this._extrudeValue = defaultValue$1(e.extrudeValue, 0), this._enableBottomFace = defaultValue$1(e.enableBottomFace, !1), this.perPositionHeight = defaultValue$1(e.perPositionHeight, !1), this._zOffset = defaultValue$1(e.zOffset, 0), this.cachedPositions = [], this.cachedObjectIndices = [];
  }
  setData(e) {
    this._needsUpdate = !0, this.cachedData = e, this.updateGeometry();
  }
  updateGeometry() {
    this.engine.map.isGlobe ? this.updateGeometry3D() : this.updateGeometryColumbus();
  }
  updateGeometry3D() {
    const e = this.cachedData, r = this.engine.map.map.ellipsoid || Ellipsoid.WGS84, s = [], a = [], c = [], l = [], h = [], d = [], f = [];
    let p = 0;
    const m = [], y = [], x = [], v = [], S = [], E = [], b = [];
    let w = 0;
    const M = scaleToGeodeticHeightN1$1;
    let P = scaleToGeodeticHeightN2$1;
    const D = scaleToGeodeticHeightP1;
    let L = scaleToGeodeticHeightP2$1;
    for (let F = 0; F < e.position.length; F++) {
      const k = e.position[F], V = e.index[F], N = this.parameters.vertexHeights ? e.height[F] : this.extrudeValue, U = e.color ? colorToArr4(e.color[F]) : defaultColor, z = arrayRemoveDuplicates(k[0], !0), $ = extractHeights$1(z, r).map((se) => se), G = 0;
      if (z.length < 3)
        continue;
      for (let se = 0; se < z.length; se++) {
        let pe = z[se];
        r.scaleToGeodeticSurface(positionVec3$1.fromArray(pe), positionTemp$1), z[se] = positionTemp$1.toArray();
      }
      const j = computeRectangleFromPositions(z, r), Y = createProjectTo2D(
        j,
        z,
        r
      ), H = [];
      let W = Number.POSITIVE_INFINITY, q = Number.POSITIVE_INFINITY;
      W = Math.min(...Y.map((se) => se.x)), q = Math.min(...Y.map((se) => se.y));
      for (let se = 0; se < Y.length; se++) {
        const pe = Y[se], fe = pe.x - W, Ce = pe.y - q;
        H.push(
          new Vector2$1(fe, Ce)
        );
      }
      const Z = this.triangulate(Y), X = z.map((se) => new Vector3$1(...se));
      let K = this.parameters.granularity;
      const ee = this.extrude && this._enableBottomFace, ie = !(this.extrude && this.perPositionHeight), re = ee || ie, {
        subdividedPositions: ne,
        subdividedTexcoords: J,
        subdividedIndices: oe,
        subdividedHeights: _e
      } = computeSubdivision(
        r,
        X,
        $,
        Z,
        p,
        H,
        K,
        re
      );
      let le = ne.length;
      const de = h.length, ce = [];
      let Re = 0;
      if (ie) {
        for (let se = 0; se < le; se += 3)
          D.fromArray(ne, se), r.geodeticSurfaceNormal(D, M), L = r.scaleToGeodeticSurface(D, L), Re = _e[se / 3], this.extrudeValue && !this.perPositionHeight && (Re = 0), P = Cartesian3.multiplyByScalar(M, this._zOffset + N + Re, P), P = Cartesian3.add(L, P, P), ce[se] = P.x, ce[se + 1] = P.y, ce[se + 2] = P.z, h[se + de] = M.x, h[se + 1 + de] = M.y, h[se + 2 + de] = M.z, a.push(N, this._encodeConcave(!1, !1, !1));
        pushInBatches(s, ce), pushInBatches(c, oe), pushInBatches(d, J);
      } else {
        for (let se = 0; se < X.length; se++) {
          const pe = X[se], fe = H[se];
          r.geodeticSurfaceNormal(pe, M), h[se * 3 + de] = M.x, h[se * 3 + 1 + de] = M.y, h[se * 3 + 2 + de] = M.z, L = Cartesian3.clone(pe, L), P = Cartesian3.multiplyByScalar(M, this._zOffset + $[se] + N, P), P = Cartesian3.add(L, P, P), ce[se * 3] = P.x, ce[se * 3 + 1] = P.y, ce[se * 3 + 2] = P.z, a.push(N, this._encodeConcave(!1, !1, !1)), d.push(fe.x, fe.y);
        }
        s.push(...ce), c.push(...Z);
      }
      const Ee = h.length;
      if (ee)
        for (let se = 0; se < le; se += 3)
          D.fromArray(ne, se), r.geodeticSurfaceNormal(D, M), L = r.scaleToGeodeticSurface(D, L), P = Cartesian3.multiplyByScalar(M, this._zOffset + G, P), P = Cartesian3.add(L, P, P), ne[se] = P.x, ne[se + 1] = P.y, ne[se + 2] = P.z, h[se + Ee] = -M.x, h[se + 1 + Ee] = -M.y, h[se + 2 + Ee] = -M.z, a.push(0, this._encodeConcave(!0, !1, !1));
      let Le = ce.length / 3;
      this.extrude && this._enableBottomFace && (s.push(...ne), Le += ne.length / 3);
      for (let se = 0; se < Le; se++)
        f.push(V);
      if (p += Le, this.extrude && this._enableBottomFace) {
        const se = [], pe = ce.length / 3, fe = oe.length - 1;
        for (let Ce = 0; Ce <= fe; Ce++)
          se.push(oe[Ce] + pe);
        pushInBatches(d, J), pushInBatches(c, se.reverse());
      }
      const ke = Array.from({ length: Le }, () => U).flat();
      if (pushInBatches(l, ke), this.extrude) {
        isClockWise(Y.map((Se) => Se.toArray())) && (X.reverse(), Y.reverse());
        const {
          edgePositions: pe,
          edgeHeightAndConcaves: fe,
          edgeIndices: Ce,
          edgeNormals: He,
          edgeUvs: Me
        } = this.computeWallGeometry3D(
          X,
          Y,
          r,
          CesiumMath.RADIANS_PER_DEGREE,
          w,
          N,
          $,
          G
        ), Be = Array.from({ length: pe.length / 3 }, () => U).flat();
        for (let Se = 0; Se < pe.length / 3; Se++)
          b.push(V);
        pushInBatches(m, pe), pushInBatches(y, fe), pushInBatches(x, Ce), pushInBatches(v, He), pushInBatches(S, Be), pushInBatches(E, Me), w += pe.length / 3;
      }
    }
    const O = c.length;
    this.extrude && (x.forEach((F, k) => x[k] = F + p), pushInBatches(s, m), pushInBatches(a, y), pushInBatches(c, x), pushInBatches(h, v), pushInBatches(l, S), pushInBatches(d, E), pushInBatches(f, b)), this.cachedPositions = s, this.cachedObjectIndices = f, this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("heightAndConcave", new Float32BufferAttribute(a, 2)), this.parameters.vertexColors && this.setAttribute("aColor", new Float32BufferAttribute(l, 4)), this.setAttribute("uv", new Float32BufferAttribute(d, 2)), this.setAttribute("normal", new Float32BufferAttribute(h, 3)), this.setAttribute("objectIndex", new Float32BufferAttribute(f, 1)), this.setIndex(c), this.clearGroups(), this.addGroup(0, O, 1), this.extrude && this.addGroup(O, c.length - O, 0), this.computeBoundingSphere(), this._needsUpdate = !1;
  }
  updateGeometryColumbus() {
    let e = this.cachedData, r = null, s = null;
    const a = [], c = [], l = [], h = [], d = [];
    let f = [];
    const p = [], m = [], y = [], x = [], v = [], S = [], E = [], b = [], w = e.position && e.position.length || 0;
    for (let D = 0; D < w; D++) {
      const L = e.position[D], O = e.index[D], F = e.color ? colorToArr4(e.color[D]) : defaultColor, k = this.parameters.vertexHeights ? e.height[D] : this.extrudeValue, V = this._useUV && e.uvRotation ? e.uvRotation[D] : 0;
      let N = !1;
      const { points: U, edges: z } = flattenRingsAndEdges(L), {
        indexMap: $,
        points: G
      } = dedupPoints(U), j = dedupEdges(z, $);
      r = earcut.flatten([G]);
      const Y = createEdgePoint(G, j);
      try {
        s = cdt2d(G, j, {
          interior: !0,
          exterior: !1
        }).flat(), N = s.length === 0, (N || this._useEarCut) && (r = earcut.flatten(L), s = earcut(r.vertices, r.holes, r.dimensions));
      } catch {
        s = earcut(r.vertices, r.holes, r.dimensions);
      }
      this.extrude && this._enableBottomFace && this.addGeoPolygonToVertices(
        r,
        s,
        this._zOffset,
        a.length / 3,
        a,
        f,
        c,
        l,
        V,
        p,
        F,
        h,
        O,
        d,
        !0
      ), this.addGeoPolygonToVertices(
        r,
        s,
        this._zOffset + k,
        a.length / 3,
        a,
        f,
        c,
        l,
        V,
        p,
        F,
        h,
        O,
        d
      ), this.extrude && k > 0 && this.addSideFace(
        Y,
        k,
        m.length / 3,
        m,
        b,
        y,
        x,
        E,
        F,
        v,
        O,
        S
      );
    }
    const M = f.length;
    let P = a.length / 3;
    for (let D = 0; D < b.length; D++)
      b[D] += P;
    pushInBatches(a, m), pushInBatches(c, y), pushInBatches(p, E), pushInBatches(l, x), pushInBatches(d, S), pushInBatches(f, b), pushInBatches(h, v), this.cachedPositions = a, this.cachedObjectIndices = h, this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.parameters.vertexColors && this.setAttribute("aColor", new Float32BufferAttribute(p, 4)), this._useUV ? this.setAttribute("uv", new Float32BufferAttribute(l, 2)) : this.deleteAttribute("uv"), this.setAttribute("heightAndConcave", new Float32BufferAttribute(d, 2)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setIndex(f), this.clearGroups(), this.addGroup(0, M, 1), this.extrude && this.addGroup(M, f.length - M, 0), this.computeBoundingSphere(), this._needsUpdate = !1;
  }
  _calculateHeights(e, r, s) {
    const [a, c] = [e[2] || 0, r[2] || 0], l = this._zOffset || 0, h = this.perPositionHeight;
    return {
      bottom: l + (h ? a : 0),
      nextBottom: l + (h ? c : 0),
      top: a + l + s,
      nextTop: c + l + s
    };
  }
  _calculateNormal(e, r) {
    const s = r[0] - e[0], a = r[1] - e[1], c = Math.hypot(s, a);
    return [a / c, -s / c, 0];
  }
  computeWallGeometry3D(e, r, s, a, c, l, h, d) {
    let f, p, m, y, x, v = e.length;
    const S = CesiumMath.chordLength(
      a,
      s.maximumRadius
    );
    let E = 0;
    for (m = 0; m < v; m++)
      E += this.subdivideLineCount(
        e[m],
        e[(m + 1) % v],
        S
      );
    const b = E + v;
    p = b * 3, f = new Array(p * 2);
    const w = [], M = [], P = {
      bottom: [],
      top: []
    };
    let D = 0, L = 0;
    for (m = 0; m < v + 1; m++) {
      y = e[m], x = e[(m + 1) % v], this.perPositionHeight && (D = h[m], L = h[(m + 1) % v]);
      let W = m === 0 ? v - 1 : m - 1, q = m === v ? 0 : m, Z = m === v - 1 ? 0 : q + 1;
      if (r[W].toArray(scratchPrevPoint), r[q].toArray(scratchPoint), r[Z].toArray(scratchNextPoint), this._pushHeightAndConcave(
        P,
        l,
        m,
        scratchPrevPoint,
        scratchPoint,
        scratchNextPoint,
        v + 1
      ), m === v)
        continue;
      const {
        topPositions: X,
        bottomPositions: K
      } = this.subdivideLine(
        y,
        x,
        D,
        L,
        d,
        S,
        s,
        l,
        P
      );
      w.push(...K), M.push(...X);
    }
    f = [...w, ...w];
    const O = [...P.top, ...P.bottom];
    v = f.length;
    let F = [], k = 0;
    for (v /= 6, m = 0; m < v; m++) {
      const W = m, q = W + 1, Z = W + v, X = Z + 1;
      y = p1Scratch$2.fromArray(f, W * 3), x = p2Scratch$1.fromArray(f, q * 3), !Cartesian3.equalsEpsilon(
        y,
        x,
        CesiumMath.EPSILON10,
        CesiumMath.EPSILON10
      ) && (F[k++] = W + c, F[k++] = Z + c, F[k++] = q + c, F[k++] = q + c, F[k++] = Z + c, F[k++] = X + c);
    }
    f = [...M, ...w], v = M.length / 3;
    const V = [];
    V.length = f.length;
    const N = [];
    N.length = v * 4;
    let U = new Vector3$1(), z = new Vector3$1(), $ = new Vector3$1(), G = !0, j = new Vector3$1();
    const Y = [];
    let H = 0;
    for (m = 0; m < b; m++) {
      U.fromArray(M, m * 3), z.fromArray(w, m * 3), $.fromArray(M, (m + 1) * 3);
      const W = s.cartesianToCartographic(U).z, q = s.cartesianToCartographic(z).z;
      let Z = m * 2, X = (m + p / 3) * 2;
      if ($.x === void 0 ? (N[Z] = H, N[Z + 1] = W, N[X] = H, N[X + 1] = q) : (Y.push(U.distanceTo($)), N[Z] = H, N[Z + 1] = W, N[X] = H, N[X + 1] = q, H += Y[m]), (Cartesian3.equalsEpsilon(
        U,
        $,
        CesiumMath.EPSILON10
      ) || m === b - 1) && (G = !1), G) {
        const ie = Cartesian3.subtract(
          $,
          U,
          scratchCartesian3Position4$1
        ), re = Cartesian3.subtract(
          z,
          U,
          scratchCartesian3Position1$1
        );
        j = Cartesian3.normalize(
          Cartesian3.cross(re, ie, j),
          j
        );
      }
      let K = m * 3, ee = m * 3 + p;
      V[K] = j.x, V[K + 1] = j.y, V[K + 2] = j.z, V[ee] = j.x, V[ee + 1] = j.y, V[ee + 2] = j.z, G = !0;
    }
    return {
      edgePositions: f,
      edgeIndices: F,
      edgeNormals: V,
      edgeUvs: N,
      edgeHeightAndConcaves: O,
      totalDistance: Array.from({ length: b * 2 }, () => H)
    };
  }
  get extrude() {
    return this._extrude;
  }
  set extrude(e) {
    const r = !!e;
    r !== this._extrude && (this._extrude = r, this._needsUpdate = !0);
  }
  get extrudeValue() {
    return this._extrudeValue;
  }
  set extrudeValue(e) {
    !isNaN(e) && e >= 0 && e !== this._extrudeValue && (this._extrudeValue = e, this._needsUpdate = !0);
  }
  get sideUVNormalized() {
    return this._sideUVNormalized;
  }
  set sideUVNormalized(e) {
    e !== this._sideUVNormalized && (this._extrude && (this._needsUpdate = !0), this._sideUVNormalized = e);
  }
  get sideUVReversed() {
    return this._sideUVReversed;
  }
  set sideUVReversed(e) {
    e !== this._sideUVReversed && (this._extrude && (this._needsUpdate = !0), this._sideUVReversed = e);
  }
  get sideUVUseHeight() {
    return this._sideUVUseHeight;
  }
  set sideUVUseHeight(e) {
    e !== this._sideUVUseHeight && (this._extrude && (this._needsUpdate = !0), this._sideUVUseHeight = e);
  }
  get useUV() {
    return this._useUV;
  }
  set useUV(e) {
    e !== this._useUV && (this._needsUpdate = !0, this._useUV = e);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  set useEarCut(e) {
    this._useEarCut !== e && (this._useEarCut = e);
  }
}
function flattenRingsAndEdges(o) {
  const i = [], e = [];
  let r = 0;
  for (let s = 0; s < o.length; s++) {
    const a = o[s], c = r;
    for (let l = 0; l < a.length; l++)
      i.push(a[l]), l > 0 && e.push([r + l - 1, r + l]);
    e.push([r + a.length - 1, c]), r += a.length;
  }
  return { points: i, edges: e };
}
const vertexShader$f = `#define GLSLIFY 1
#include <common>
#include <fog_pars_vertex>

#ifdef USE_MAP
    varying vec2 vUv;
    uniform float mapScale;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
    varying vec4 vColor;
#endif

uniform float normalOffset;

#if defined(USE_AO) || defined(MVT_HEIGHT_EXTRUSION)
attribute vec2 heightAndConcave;
#endif

#ifdef USE_AO
varying float v_concave;
varying float v_h;
varying float v_ground;
#endif

#ifdef MVT_HEIGHT_EXTRUSION
uniform float heightExtrusion;
uniform vec3 zNormal;
#endif

#include <normal_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>

void main() {

    #include <mvt_selective_vertex>

    #ifdef USE_MAP
        vUv = uv / mapScale;
    #endif

     #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #endif

    #include <begin_vertex>

    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #if defined(USE_AO) || defined(MVT_HEIGHT_EXTRUSION)
    float encodeConcave = heightAndConcave.y;
    float ground = mod(encodeConcave, 2.0);
    #if defined(MVT_HEIGHT_EXTRUSION)
    if (ground < 0.5) {
        transformed.xyz += zNormal * heightExtrusion;
    }
    #endif
    #endif

    vec4 viewCoord = modelViewMatrix * vec4( transformed, 1.0 );
    viewCoord.xyz += normalize(transformedNormal) * 0.0;

    #ifdef USE_AO
    v_h = heightAndConcave.x;
    v_ground = ground;
    float concave = mod(floor(encodeConcave * 0.5), 2.0);
    float start = mod(floor(encodeConcave * 0.25), 2.0);
    concave = pow(concave, 2.2);
    v_concave = mix(concave, -concave, start);
    #endif

    gl_Position = projectionMatrix * viewCoord;
    #include <fog_vertex>
    #include <logdepthbuf_vertex>

}

`, fragmentShader$d = `#define GLSLIFY 1
#include <common>

#ifdef USE_MAP
    varying vec2 vUv;
    uniform sampler2D map;
    uniform vec2 mapLength;
#endif
#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif

uniform float opacity;
uniform vec4 backgroundColor;

#ifdef USE_AO
uniform float concaveIntensity;
uniform float heightIntensity;

varying float v_concave;
varying float v_ground;
varying float v_h;
#endif

#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {

    vec4 mapColor = vec4(1.0);
    #ifdef USE_MAP
        mapColor = texture2D(map, vUv / mapLength);
    #endif

    vec4 baseColor;

    #ifdef MVT_USE_VERTEX_COLOR
        baseColor = vColor;
    #else
        baseColor = vec4(color, 1.0);
    #endif

    gl_FragColor = mapColor * baseColor;

    vec4 fg = gl_FragColor;
    vec4 bg = backgroundColor;

    float outA = fg.a + bg.a * (1.0 - fg.a);

    vec3 outRGB = (fg.rgb * fg.a + bg.rgb * bg.a * (1.0 - fg.a)) / max(outA, 1e-5);

    gl_FragColor = vec4(outRGB, outA);

    gl_FragColor.a *= opacity;

    if (gl_FragColor.a <= 0.) {
        discard;
    }

    #if ( NUM_DIR_LIGHTS > 0 )
        // \u6839\u636E\u65B9\u5411\u5149\u7684\u65B9\u5411\u4E0E\u6CD5\u5411\uFF0C\u6765\u8BA1\u7B97\u989C\u8272\u8870\u51CF\u7A0B\u5EA6\uFF0C\u503C\u8303\u56F4\u4E3A-1~1\uFF0C\u7ED9\u91CD\u6620\u5C04\u52300.8~1\u7684\u8303\u56F4
        float normalLightIntensity = dot(vNormal, directionalLights[0].direction);
        gl_FragColor = vec4(gl_FragColor.rgb * (normalLightIntensity / 10.0 + 0.9), gl_FragColor.a);
    #endif

    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #ifdef USE_AO
    float ao_shade = 1.0;
    float concave = v_concave * v_concave;
    float intensity = concaveIntensity;
    float x_shade = mix(1.0, mix(0.6, 0.75, min(0.01, 1.0)), intensity) + 0.1 * intensity;
    ao_shade *= mix(1.0, x_shade * x_shade * x_shade, concave);

    intensity = heightIntensity;
    float h_floors = v_h / 3.0;
    float y_shade = 1.0 - 0.9 * intensity * min(v_ground, 1.0);
    ao_shade *= (1.0 - 0.08 * intensity) * (y_shade + (1.0 - y_shade) * (1.0 - pow(1.0 - min(h_floors / 16.0, 1.0), 16.0))) + 0.08 * intensity * min(h_floors / 160.0, 1.0);

    gl_FragColor.rgb *= ao_shade;
    #endif

    #include <mvt_selective_fragment>
    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}

`, textureLoader$4 = new TextureLoader(), uniforms$g = UniformsUtils.merge([
  UniformsLib.fog,
  UniformsLib.lights,
  selectiveUniforms,
  emissiveUniforms,
  {
    isEmissive: { value: !1 },
    opacity: { value: 1 },
    color: { value: [1, 1, 1] },
    vertexColors: { value: !1 },
    map: { value: void 0 },
    mapLength: { value: new Vector2$1(1, 1) },
    mapSrc: { value: "" },
    mapScale: { value: 1 },
    normalOffset: { value: 0 },
    concaveIntensity: { value: 0.2 },
    heightIntensity: { value: 0.4 },
    backgroundColor: { value: new Vector4(0, 0, 0, 0) },
    heightExtrusion: { value: 0 },
    zNormal: { value: new Vector3$1(0, 0, 1) }
  }
]);
class PolygonMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "PolygonMaterial", this.isPolygonMaterial = !0, this.lights = !0, this.fog = !0, this.fragmentShader = fragmentShader$d, this.vertexShader = vertexShader$f, this.autoLength = i.autoLength || !0, Object.defineProperty(this, "mapSrc", {
      get: function() {
        return this.uniforms.map.value;
      },
      set: function(e) {
        const r = this.mapSrc, s = this.userData[this.urlCacheKey], a = this;
        if (s !== e) {
          if (r && r.dispose(), !e) {
            this.uniforms.map.value = null, delete this.defines.USE_MAP, delete this.userData[this.urlCacheKey];
            return;
          }
          textureLoader$4.load(e, function(c) {
            c.colorSpace = SRGBColorSpace, c.wrapS = c.wrapT = RepeatWrapping, a.uniforms.map.value = c, a.autoLength && a.uniforms.mapLength.value.set(c.image.naturalWidth, c.image.naturalHeight), a.userData[a.urlCacheKey] = e, a.defines.USE_MAP = !0, a.needsUpdate = !0;
          });
        }
      }
    }), Object.assign(this.uniforms, UniformsUtils.clone(uniforms$g)), i.mapSrc && (this.mapSrc = i.mapSrc, delete i.mapSrc), defineMaterialNormalProperties(this, [
      "opacity",
      "mapScale",
      "isEmissive",
      "normalOffset",
      "concaveIntensity",
      "heightIntensity",
      "heightExtrusion",
      "zNormal"
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["useAO", "USE_AO"],
      ["useHeightExtrusion", "MVT_HEIGHT_EXTRUSION"]
    ]), defineMaterialSelectiveProperties(this), defineMaterialEmissiveProperties(this), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(i);
  }
  get backgroundColor() {
    return this.uniforms.backgroundColor.value;
  }
  set backgroundColor(i) {
    const e = colorToArr4(i);
    this.uniforms.backgroundColor.value.set(e[0], e[1], e[2], e[3]);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
const vertexShader$e = `#define GLSLIFY 1
#include <common>
#include <fog_pars_vertex>

#ifdef USE_MAP
    varying vec4 vSouthWestCorner;
    varying vec2 vInversePlaneExtents;

    uniform float mapScale;
    uniform vec4 rectBounds;
#else
    #ifdef MVT_USE_VERTEX_COLOR
        attribute vec4 aColor;
        varying vec4 vColor;
    #endif
#endif

uniform float normalOffset;

#include <normal_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>

// \u6A21\u62DFglDepthClamp,\u89E3\u51B3ZFail\u7684\u8FDC\u5E73\u9762\u88AB\u89C6\u9525\u4F53\u6240\u88C1\u526A\u7684\u95EE\u9898
#if !defined( USE_LOGDEPTHBUF )
    varying float vWindowZ;
#endif

vec4 depthClamp(vec4 coords) {
    #if !defined( USE_LOGDEPTHBUF )
        vWindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;

        coords.z = 0.0; 
    #else 
        coords.z = min(coords.z, coords.w);
    #endif

    return coords;
}

void main() {

    #include <mvt_selective_vertex>

    #ifdef USE_MAP
        float eastExtend = rectBounds.z - rectBounds.x;
        float northExtend = rectBounds.w - rectBounds.y;

        vInversePlaneExtents = vec2(1.0 / eastExtend, 1.0 / northExtend);
        vSouthWestCorner = modelMatrix * vec4(rectBounds.xy, 0.0, 1.0);
    #else
        #ifdef MVT_USE_VERTEX_COLOR
            vColor = aColor;
        #endif
    #endif

    #include <begin_vertex>

    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    vec4 viewCoord = modelViewMatrix * vec4( transformed, 1.0 );
    viewCoord.xyz += normalize(transformedNormal) * normalOffset;

    gl_Position = projectionMatrix * viewCoord;
    #include <fog_vertex>
    #include <logdepthbuf_vertex>

    gl_Position = depthClamp(gl_Position);

}`, fragmentShader$c = `#define GLSLIFY 1
#include <common>

#include <packing>

varying vec4 vSouthWestCorner;
varying vec2 vInversePlaneExtents;
uniform mat4 inverseProjection;
uniform sampler2D depthTexture;
uniform vec2 resolution;
uniform float cameraNear;
uniform float cameraFar;
uniform mat4 viewInverseMatrix;
uniform float pixelRatio;

#ifdef USE_MAP
    uniform sampler2D map;
#endif

float linearize_depth(in float depth, in float cameraNear, in float cameraFar){
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float reconstruct_depth(sampler2D tDepth, const in vec2 uv, in float cameraNear, in float cameraFar){
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float getDepthFromTexture(sampler2D tDepth, vec2 uv) {
    #if defined( USE_LOGDEPTHBUF )
        return linearize_depth(reconstruct_depth(tDepth, uv, cameraNear, cameraFar), cameraNear, cameraFar);
    #else
        return texture2D(tDepth, uv).x;
    #endif
}

vec3 getWorldPositionFromDepth(float depth, vec2 vUV) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(vUV * 2.0 - 1.0, z, 1.0);

    vec4 viewSpacePosition = inverseProjection * clipSpacePosition;
    
    vec4 worldSpacePosition = viewInverseMatrix * viewSpacePosition;

    return worldSpacePosition.xyz / worldSpacePosition.w;
}

#ifdef USE_NORMAL

    vec3 vectorFromOffset(vec3 worldCoordinate, vec2 positiveOffset) {
        vec2 glFragCoordXY = gl_FragCoord.xy;
        // Sample depths at both offset and negative offset
        float upOrRightLogDepth = getDepthFromTexture(depthTexture, (glFragCoordXY + positiveOffset) / resolution.xy / pixelRatio);
        float downOrLeftLogDepth = getDepthFromTexture(depthTexture, (glFragCoordXY - positiveOffset) / resolution.xy / pixelRatio);
        // Explicitly evaluate both paths
        // Necessary for multifrustum and for edges of the screen
        bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, resolution.xy * pixelRatio);
        float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y);
        float useDownOrLeft = float(useUpOrRight == 0.0);

        vec3 upOrRightEC = getWorldPositionFromDepth(upOrRightLogDepth, (glFragCoordXY + positiveOffset) / resolution.xy / pixelRatio);
        vec3 downOrLeftEC = getWorldPositionFromDepth(downOrLeftLogDepth, (glFragCoordXY - positiveOffset) / resolution.xy / pixelRatio);
        return (upOrRightEC - worldCoordinate.xyz) * useUpOrRight + (worldCoordinate.xyz - downOrLeftEC) * useDownOrLeft;
    }

#endif

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif

uniform float opacity;

// \u6A21\u62DFglDepthClamp
#if !defined( USE_LOGDEPTHBUF )
varying float vWindowZ;

void writeDepthClamp() {
    
    gl_FragDepthEXT = clamp(vWindowZ * gl_FragCoord.w, 0.0, 1.0);
    
}
#endif

#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {
    vec2 coordUV = gl_FragCoord.xy / resolution / pixelRatio;
    float depth = getDepthFromTexture(depthTexture, coordUV);
    vec3 worldCoordinate = getWorldPositionFromDepth(depth, coordUV);

    #ifdef MVT_USE_VERTEX_COLOR
        gl_FragColor = vColor;
    #else
        gl_FragColor = vec4(color, 1.0);
    #endif

    #ifdef USE_MAP

        vec2 fragUv = vec2(0.0);
        fragUv.x = (worldCoordinate.x - vSouthWestCorner.x) * vInversePlaneExtents.x;
        fragUv.y = (worldCoordinate.y - vSouthWestCorner.y) * vInversePlaneExtents.y;

        vec4 mapColor = texture2D(map, fragUv);

        vec3 fragColor = vec3(0.0);
        #ifdef MVT_USE_VERTEX_COLOR
            mapColor *= vColor;
        #else
            mapColor *= vec4(color, 1.0);
        #endif

        gl_FragColor = mapColor;
    #endif

    #ifdef USE_NORMAL
        // Compute normal by sampling adjacent pixels in 2x2 block in screen space
        vec3 downUp = vectorFromOffset(worldCoordinate, vec2(0.0, 1.0));
        vec3 leftRight = vectorFromOffset(worldCoordinate, vec2(1.0, 0.0));
        vec3 normalWC = normalize(cross(leftRight, downUp));
    #endif

    gl_FragColor.a *= opacity;
    if (gl_FragColor.a <= 0.) {
        discard;
    }

    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #if !defined( USE_LOGDEPTHBUF ) 
        vFragDepth = writeDepthClamp();
    #endif

    #include <mvt_selective_fragment>
    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>

}`, textureLoader$3 = new TextureLoader(), uniforms$f = UniformsUtils.merge([
  UniformsLib.fog,
  UniformsLib.lights,
  selectiveUniforms,
  emissiveUniforms,
  {
    isEmissive: { value: !1 },
    opacity: { value: 1 },
    color: { value: new Vector3$1(1, 1, 1) },
    vertexColors: { value: !1 },
    useNormal: { value: !1 },
    map: { value: void 0 },
    mapLength: { value: new Vector2$1() },
    mapSrc: { value: "" },
    mapScale: { value: 1 },
    normalOffset: { value: 0 },
    rectBounds: { value: new Vector4(0, 0, 0, 0) },
    inverseProjection: { value: new Matrix4() },
    depthTexture: { value: null },
    cameraNear: { value: 0 },
    cameraFar: { value: 0 },
    viewInverseMatrix: { value: new Matrix4() },
    cameraProjectionMatrix: { value: new Matrix4() }
  }
]);
class ShadowVolumeMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "ShadowVolumeMaterial", this.isShadowMaterial = !0, this.lights = !0, this.fog = !0, this.fragmentShader = fragmentShader$c, this.vertexShader = vertexShader$e, Object.defineProperty(this, "mapSrc", {
      get: function() {
        return this.uniforms.map.value;
      },
      set: function(e) {
        const r = this.mapSrc, s = this.userData[this.urlCacheKey], a = this;
        if (s !== e) {
          if (r && r.dispose(), !e) {
            this.uniforms.map.value = null, delete this.defines.USE_MAP, delete this.userData[this.urlCacheKey];
            return;
          }
          textureLoader$3.load(e, function(c) {
            c.colorSpace = SRGBColorSpace, a.uniforms.map.value = c, a.uniforms.mapLength.value = new Vector2$1(c.image.naturalWidth, c.image.naturalHeight), a.userData[a.urlCacheKey] = e, a.defines.USE_MAP = !0, a.needsUpdate = !0;
          });
        }
      }
    }), Object.assign(this.uniforms, UniformsUtils.clone(uniforms$f)), i.mapSrc && (this.mapSrc = i.mapSrc, delete i.mapSrc), defineMaterialNormalProperties(this, [
      "opacity",
      "mapScale",
      "isEmissive",
      "normalOffset",
      "rectBounds"
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["useNormal", "USE_NORMAL"]
    ]), defineMaterialSelectiveProperties(this), defineMaterialEmissiveProperties(this), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(i);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
const sharedResources = {}, _tempCenter = new Vector3$1(), _tempNormal = new Vector3$1();
class Polygon extends GeoMesh {
  constructor(e = {}) {
    super();
    _(this, "isEventEntitySupported", !0);
    _(this, "geometry");
    _(this, "material");
    _(this, "extrude");
    _(this, "extrudeValue");
    _(this, "color");
    _(this, "vertexColors");
    _(this, "emissive");
    _(this, "opacity");
    _(this, "mapScale");
    this.isPolygon = !0, this.parameters = e, this._nearScale = e.nearScale || 5, this.isGroundPrimitive = e.isGroundPrimitive, this.isDynamic = e.isDynamic || !1, this.needReMapUv = this.isGroundPrimitive, this.excludeElements = e.excludeElements || [], this._sharedResourcesId = this.getSharedResourceFromExcludeElement(this.excludeElements), this.renderOrder = e.renderOrder || 0, this.defineGeometryProxyProperties([
      "extrude",
      "extrudeValue",
      "vertexHeights",
      "enableBottomFace",
      "zOffset",
      "perPositionHeight"
    ]), this.defineMaterialProxyProperties([
      "transparent",
      "opacity",
      "color",
      "vertexColors",
      "emissive",
      "mapScale",
      "side",
      "depthWrite",
      "colorWrite",
      "stencilWrite",
      "stencilFunc",
      "stencilZFail",
      "stencilZPass",
      "normalOffset",
      "useNormal",
      "useAO",
      "concaveIntensity",
      "heightIntensity"
    ]);
  }
  initObject() {
    const { extrude: e, extrudeValue: r, vertexHeights: s, enableBottomFace: a, zOffset: c, ...l } = this.parameters, h = this.geometry = new PolygonGeometry(this.parameters);
    h.engine = this.engine;
    let d = null;
    if (this.isGroundPrimitive) {
      if (d = this.material = new ShadowVolumeMaterial(l), this.needReMapUv) {
        const f = this._sharedResourcesId, p = sharedResources[f];
        if (p) {
          const { depthTexture: m, depthRenderTarget: y } = p;
          p.refCount++, this.depthRenderTarget = y, d.uniforms.depthTexture.value = m;
        } else {
          const m = this.engine.rendering.resolution, y = this.engine.rendering.pixelRatio, x = this.depthRenderTarget = new WebGLRenderTarget(m.x * y, m.y * y), v = new DepthTexture();
          v.type = UnsignedInt248Type, x.depthTexture = v, d.uniforms.depthTexture.value = v, sharedResources[f] = {
            depthRenderTarget: x,
            depthTexture: v,
            refCount: 1,
            lastRenderFrame: -1
          };
        }
      }
    } else
      d = this.material = new PolygonMaterial(l);
    d.setCommonUniforms(this.engine.rendering.uniforms);
  }
  onBeforeSceneRenderHook(e, r, s, a) {
    if (!this.needReMapUv)
      return;
    const c = a.frameCount, l = sharedResources[this._sharedResourcesId];
    if (l) {
      if (l.lastRenderFrame !== c) {
        const h = e.renderer;
        h.setRenderTarget(this.depthRenderTarget);
        let d = [];
        r.traverse((p) => {
          (p.isGroundPrimitive || this.excludeElements.includes(p)) && (p.originVisible = p.visible, p.visible = !1, d.push(p));
        });
        let f = s.near;
        s.near = f * this.nearScale, s.updateProjectionMatrix(), h.render(r, s);
        for (let p = 0; p < d.length; p++)
          d[p].visible = d[p].originVisible;
        this.material.uniforms.cameraNear.value = s.near, this.material.uniforms.cameraFar.value = s.far, this.material.uniforms.viewInverseMatrix.value.copy(s.matrixWorld), this.material.uniforms.pixelRatio.value = e.rendering.pixelRatio, this.material.uniforms.inverseProjection.value.copy(s.projectionMatrixInverse.clone()), s.near = f, s.updateProjectionMatrix(), h.setRenderTarget(null);
      } else {
        let h = s.near;
        s.near = h * this.nearScale, s.updateProjectionMatrix(), this.material.uniforms.cameraNear.value = s.near, this.material.uniforms.cameraFar.value = s.far, this.material.uniforms.viewInverseMatrix.value.copy(s.matrixWorld), this.material.uniforms.pixelRatio.value = e.rendering.pixelRatio, this.material.uniforms.inverseProjection.value.copy(s.projectionMatrixInverse.clone()), s.near = h, s.updateProjectionMatrix();
      }
      l.lastRenderFrame = c;
    }
  }
  _updateData() {
    let e = this.dataSource.data;
    if (this.geometry.setData(e), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), this.needsUpdate = !1, this.needReMapUv) {
      const r = this.computeRectangleBounds();
      this.material.rectBounds.fromArray(r);
    }
    if (this.material.zNormal) {
      const r = this.getNormal();
      this.material.zNormal.copy(r);
    }
    this.needsUpdate = !1;
  }
  getNormal() {
    if (this.engine.map.isGlobe) {
      const s = _tempCenter.fromArray(this._cachedRtc);
      Ellipsoid.WGS84.geodeticSurfaceNormal(s, _tempNormal);
    } else
      _tempNormal.set(0, 0, 1);
    return _tempNormal;
  }
  computeRectangleBounds() {
    const r = this.geometry.attributes.position.array, s = r.length;
    let a = Number.POSITIVE_INFINITY, c = Number.NEGATIVE_INFINITY, l = Number.POSITIVE_INFINITY, h = Number.NEGATIVE_INFINITY;
    for (let d = 0; d < s; d += 3) {
      const f = r[d], p = r[d + 1];
      a = Math.min(a, f), l = Math.min(l, p), c = Math.max(c, f), h = Math.max(h, p);
    }
    return [
      a,
      l,
      c,
      h
    ];
  }
  afterGeometryUpdate() {
    this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox();
  }
  getEntityIndexByFace(e, r) {
    return this.geometry.cachedObjectIndices[r];
  }
  getSharedResourceFromExcludeElement(e) {
    let r = "";
    return e.length > 0 && (r = e.map((a) => a.uuid).join("-")), r;
  }
  dispose() {
    if (this.needReMapUv) {
      const e = sharedResources[this._sharedResourcesId];
      if (e && (e.refCount--, e.refCount === 0)) {
        const {
          depthRenderTarget: r,
          depthTexture: s
        } = e;
        r.dispose(), s.dispose(), delete sharedResources[this._sharedResourcesId];
      }
    }
    super.dispose();
  }
  get nearScale() {
    return this._nearScale;
  }
  set nearScale(e) {
    this._nearScale = e;
  }
  get mapSrc() {
    return this.material.mapSrc;
  }
  set mapSrc(e) {
    this.material.mapSrc = e, this.geometry && e && (this.geometry.useUV = !0);
  }
}
Polygon.prototype.raycast = Mesh.prototype.raycast;
Polygon.prototype._computeIntersections = Mesh.prototype._computeIntersections;
Polygon.prototype.getVertexPosition = Mesh.prototype.getVertexPosition;
class DistrictLayer extends EventDispatcher {
  constructor(i = {}) {
    super();
    const e = i.renderOptions || {};
    this.renderOptions = e, this.apiSource = i.apiSource || getApiSource(), this.options = i, this.autoViewport = e.autoViewport || !1, this._distrctLayer = this._createInstance(i), e.engine && (this._engine = e.engine, this._fillColor = e.fillColor || "#ff0", this._fillOpacity = e.fillOpacity || 0.6), this._loadDistrict();
  }
  async _loadDistrict() {
    this._distrctLayer && this._distrctLayer._loadDistrict && (this._data = await this._distrctLayer._loadDistrict(), this._engine && (this.renderMap(), this.dispatchEvent({
      type: "renderComplete",
      results: this._data,
      target: this
    }), this.autoViewport && this._data && this._flyToDistrict()));
  }
  _calculateBounds() {
    if (!this._data || !this._data.features)
      return null;
    let i = 1 / 0, e = -1 / 0, r = 1 / 0, s = -1 / 0;
    return this._data.features.forEach((l) => {
      if (l.geometry && l.geometry.coordinates) {
        const h = l.geometry.coordinates;
        this._flattenCoordinates(h).forEach(([d, f]) => {
          i = Math.min(i, d), e = Math.max(e, d), r = Math.min(r, f), s = Math.max(s, f);
        });
      }
    }), { center: [(i + e) / 2, (r + s) / 2], bounds: { minLng: i, maxLng: e, minLat: r, maxLat: s } };
  }
  _flattenCoordinates(i) {
    const e = [];
    function r(s) {
      for (const a of s)
        Array.isArray(a[0]) ? r(a) : e.push(a);
    }
    return r(i), e;
  }
  _flyToDistrict() {
    const i = this._calculateBounds();
    if (!i || !this._engine.map || !this._engine.map.flyTo)
      return;
    const { center: e, bounds: r } = i, s = [
      [r.minLng, r.minLat],
      [r.maxLng, r.maxLat],
      [r.minLng, r.maxLat],
      [r.maxLng, r.minLat]
    ];
    this._engine.map.setViewport(s, {
      range: 0
    });
  }
  renderMap() {
    var l;
    const i = this._data;
    if (this._layer) {
      this._layer.dataSource.setData(i);
      return;
    }
    const { engine: e, fillColor: r, fillOpacity: s, autoViewport: a, ...c } = this.renderOptions;
    if (this._fillColor !== null) {
      const h = e.add(new Polygon({
        vertexColors: !0,
        transparent: !0,
        opacity: (l = this._fillOpacity) != null ? l : 1,
        ...c
      })), d = GeoJSONDataSource.fromGeoJSON(i);
      d.defineAttribute("color", (f) => {
        if (Array.isArray(this._fillColor)) {
          const p = Math.floor(Math.random() * this._fillColor.length);
          return this._fillColor[p];
        }
        return this._fillColor;
      }), h.dataSource = d, this._layer = h;
    }
  }
  reset() {
    this._layer && (this._engine.remove(this._layer), this._layer = null);
  }
  setName(i) {
    this._distrctLayer.setName(i), this._loadDistrict();
  }
  setKind(i) {
    this._distrctLayer.setKind(i), this._loadDistrict();
  }
  setOptions(i) {
    this._distrctLayer.setOptions(i), this._loadDistrict();
  }
  _createInstance(i) {
    const r = {
      [API_SOURCE_BAIDU]: DistrictLayer_Bd,
      [API_SOURCE_TIANDITU]: DistrictLayer_Tdt
    }[this.apiSource] || DistrictLayer_Bd;
    return new r(i);
  }
  searchBoundary(i, e) {
    this._distrctLayer.searchBoundary && this._distrctLayer.searchBoundary(i, e);
  }
}
class BaseRoute {
  constructor(i = {}) {
    _(this, "result", null);
    _(this, "_polylines", []);
    _(this, "_markers", []);
    i.renderOptions = i.renderOptions || {}, this.options = i;
  }
  async search(i, e, r) {
    if (this.clearResult(), !!this._dw)
      return this.result = await this._dw.search(i, e, r), this._engine && this.renderMap(this.result), this.result;
  }
  renderMap(i) {
    const e = this._engine;
    if (this.clearMap(), this.renderPly(i), this.renderMkr(i), this.options.renderOptions.autoViewport) {
      const r = [];
      for (let s = 0; s < i.paths.length; s++) {
        const a = i.paths[s];
        r.push(...a);
      }
      for (let s = 0; s < i.walkingPaths.length; s++) {
        const a = i.walkingPaths[s];
        r.push(...a);
      }
      e.map.setViewport(r, {
        range: 0
      });
    }
  }
  renderPly(i) {
    const e = this._engine;
    for (let r = 0; r < i.paths.length; r++) {
      const s = i.paths[r], a = e.add(new Polyline({
        flat: !0,
        color: 7846399,
        lineWidth: 6,
        keepSize: !0,
        depthTest: !1
      }));
      a.renderOrder = 100;
      const c = new DataSource();
      c.add(new DataItem(s)), a.dataSource = c, this._polylines.push(a);
    }
    for (let r = 0; r < i.walkingPaths.length; r++) {
      const s = i.walkingPaths[r], a = e.add(new Polyline({
        flat: !0,
        color: 57088,
        lineWidth: 6,
        keepSize: !0,
        depthTest: !1
      }));
      a.renderOrder = 100;
      const c = new DataSource();
      c.add(new DataItem(s)), a.dataSource = c, this._polylines.push(a);
    }
  }
  renderMkr(i) {
    const e = this._engine, r = e.add(new Marker({
      point: i.start.point,
      icon: getAssetUrl("assets/images/markers/mkr_start.png"),
      width: 52 / 2,
      height: 82 / 2,
      offset: [0, -16]
    })), s = e.add(new Marker({
      point: i.end.point,
      icon: getAssetUrl("assets/images/markers/mkr_end.png"),
      width: 52 / 2,
      height: 82 / 2,
      offset: [0, -16]
    }));
    this._markers.push(r, s);
    for (let a = 0; a < i.waypoints.length; a++) {
      const c = i.waypoints[a], l = e.add(new Marker({
        point: c.point,
        icon: getAssetUrl("assets/images/markers/mkr_waypoint.png"),
        width: 52 / 2,
        height: 82 / 2,
        offset: [0, -16]
      }));
      this._markers.push(l);
    }
  }
  clearMap() {
    if (this._engine) {
      const i = this._engine;
      for (let e = 0; e < this._polylines.length; e++) {
        const r = this._polylines[e];
        i.remove(r);
      }
      for (let e = 0; e < this._markers.length; e++) {
        const r = this._markers[e];
        i.remove(r);
      }
      this._markers = [], this._polylines = [];
    }
  }
  getResult() {
    return this.result;
  }
  clearResult() {
    this.result = null;
  }
}
class RouteResult {
  constructor(i = {}) {
    this.start = i.start || {}, this.end = i.end || {}, this.waypoints = i.waypoints || [], this.distance = i.distance || 0, this.duration = i.duration || 0, this.steps = i.steps || [], this.paths = i.paths || [], this.walkingPaths = i.walkingPaths || [], this.type = i.type || "";
  }
}
const _tempVec3 = new Vector3$1();
class DWRoute_Bd {
  constructor(i = {}) {
    _(this, "_formatCoordYXString", (i, e) => {
      let r;
      return e = e || {}, typeof i == "string" ? r = i : i.isVector2 || i.isVector3 ? r = i.y.toFixed(6) + "," + i.x.toFixed(6) : Array.isArray(i) ? r = i[1].toFixed(6) + "," + i[0].toFixed(6) : i.point && (r = this._formatCoordYXString(i.point, e)), r;
    });
    _(this, "_isUid", (i) => /^[0-9a-f]{24}$/.test(i));
    this.options = i, this._baiduMercatorProjection = getProjection(PROJECTION_BD_MERCATOR), this._d = {
      plys: [],
      viaPts: [],
      viaPtsInfo: [],
      dragOverlays: [],
      tipLbl: null,
      sliderMkr: null,
      dragReqFlag: !1,
      cbkDragPt: null,
      cbkPly: null,
      isSearchByDrag: !1,
      curDragPly: null,
      dragSrcCityCode: 1,
      dragEndCityCode: 1,
      mouseOnViaMkr: !1,
      cxtMenu: []
    };
  }
  async search(i, e, r) {
    this._d.isSearchByDrag = !1;
    const s = this.route;
    r = r || {}, this._searchOpts = r;
    let a = r.waypoints;
    Array.isArray(a) || (a = []), this.waypoints = SUtil.pointsToString(a);
    let c = 1;
    if (this._engine) {
      const m = this._baiduMercatorProjection.projectCoordinate(
        _tempVec3.fromArray(this._engine.map.getCenter())
      ).toArray(), y = r.zoom || this._engine.map.getZoom();
      let x = await SearchRequestMgr.request({
        qt: QUERY_TYPE_CENTER,
        b: m[0] + "," + m[1] + ";" + m[0] + "," + m[1],
        l: y
      });
      x && x.result && x.result.type === RETURN_TYPE_CENTER && (c = x.content ? x.content.uid : 1);
    }
    let l = {
      qt: QUERY_TYPE_DIRECTION,
      output: "json",
      coord_type: "bd09ll",
      ret_coordtype: "bd09ll"
    }, h = {
      start: i,
      end: e
    }, d = "";
    if (this._isUid(r.start_uid) && (l.origin_uid = r.start_uid), this._isUid(r.end_uid) && (l.destination_uid = r.end_uid), s.QUERY_TYPE === QUERY_TYPE_WALKING)
      l.origin = this._formatCoordYXString(i), l.destination = this._formatCoordYXString(e), l.region = c, l.mode = "walking";
    else if (s.QUERY_TYPE === QUERY_TYPE_DRIVING) {
      if (typeof e == "string" || typeof i == "string")
        return;
      l.origin = this._formatCoordYXString(i), l.destination = this._formatCoordYXString(e), l.mode = "driving", l.waypoints = this.waypoints, l.tactics = this.options.policy || 0, h.policy = l.tactics;
    } else
      s.QUERY_TYPE === QUERY_TYPE_RIDING && (l.origin = this._formatCoordYXString(i), l.destination = this._formatCoordYXString(e), l.region = c, l.mode = "riding");
    let f = await SearchRequestMgr.request(l, h, d);
    const p = this._processRaw(f, h);
    return this._d.isSearchByDrag = !1, p;
  }
  _processRaw(i, e) {
    const r = this.route;
    let a = i.content.result, c = {}, l = {};
    typeof e.start == "object" && !(e.start.isVector2 || e.start.isVector3 || Array.isArray(e.start)) ? Object.assign(c, e.start) : r.QUERY_TYPE === QUERY_TYPE_WALKING || r.QUERY_TYPE === QUERY_TYPE_RIDING ? (c.title = a.origin.wd || "\u8D77\u70B9", c.uid = a.origin.uid, c.point = new Vector3$1(a.origin.originPt.lng, a.origin.originPt.lat, 0), c.city = a.origin.cname) : r.QUERY_TYPE === QUERY_TYPE_DRIVING && (c.title = "\u8D77\u70B9", c.point = new Vector3$1(a.routes[0].origin.lng, a.routes[0].origin.lat, 0)), typeof e.end == "object" && !(e.end.isVector2 || e.end.isVector3 || Array.isArray(e.end)) ? Object.assign(l, e.end) : r.QUERY_TYPE === QUERY_TYPE_WALKING || r.QUERY_TYPE === QUERY_TYPE_RIDING ? (l.title = a.destination.wd || "\u7EC8\u70B9", l.uid = a.destination.uid, l.point = new Vector3$1(a.destination.destinationPt.lng, a.destination.destinationPt.lat, 0), l.city = a.destination.cname) : r.QUERY_TYPE === QUERY_TYPE_DRIVING && (l.title = "\u7EC8\u70B9", l.point = new Vector3$1(a.routes[0].destination.lng, a.routes[0].destination.lat, 0));
    let h = [], d = [];
    this._d.viaPtsInfo.length = 0, this._d.viaPts.length = 0, this._d.plys.length = 0;
    let f = 1;
    if (a.waypoints)
      for (let v = 0; v < a.waypoints.length; v++) {
        let S = a.waypoints[v];
        if (S && S.pos) {
          let E = S.pos.split(",");
          E = new Vector3$1(+E[0], +E[1], 0), E.if_wp = 1, h.push(E), this._d.viaPtsInfo.push({
            title: "\u9014\u7ECF\u70B9" + f,
            curNo: f,
            point: E
          }), f++;
        }
      }
    let p = [], m = [], y = a.routes, x = {};
    if (r.QUERY_TYPE === QUERY_TYPE_WALKING || r.QUERY_TYPE === QUERY_TYPE_RIDING) {
      let v = y[0], S = v.steps;
      for (let E = 0; E < S.length; E++) {
        let b = new Vector3$1(
          S[E].stepOriginLocation.lng,
          S[E].stepOriginLocation.lat,
          0
        ), w = E, M = S[E].instructions, P = S[E].distance, D = {
          point: b,
          index: w,
          description: M,
          distance: P
        };
        p.push(D);
        let L = SUtil.pathToPoints(S[E].path);
        L.unshift([b.x, b.y]), L.push([
          S[E].stepDestinationLocation.lng,
          S[E].stepDestinationLocation.lat
        ]), m.push(...L);
      }
      this._d.plys.push(m), x = new RouteResult({
        start: c,
        end: l,
        waypoints: this._d.viaPtsInfo,
        distance: v.distance,
        duration: v.duration,
        steps: p,
        paths: [m],
        type: r.ROUTE_TYPE
      }), r.QUERY_TYPE === QUERY_TYPE_WALKING && (x.walkingPaths = [m], x.paths = []);
    } else if (r.QUERY_TYPE === QUERY_TYPE_DRIVING) {
      let v = y[0], S = v.steps;
      for (let w = 0; w < S.length; w++) {
        let M = new Vector3$1(
          S[w].start_location.lng,
          S[w].start_location.lat,
          0
        ), P = w, D = "", L = S[w].distance, O = S[w].leg_index, F = {
          point: M,
          index: P,
          description: D,
          distance: L
        };
        p.push(F);
        let k = SUtil.pathToPoints(S[w].path);
        m.push(...k), d[O] || (d[O] = []), d[O].push(...k);
      }
      for (let w = 0; w < d.length; w++) {
        let M = d[w];
        M.stNo = w, M.edNo = w + 1, M.legIndex = w, this._d.plys.push(M);
      }
      let E = c.point;
      this._d.viaPts.push(E);
      for (let w = 0, M = h.length; w < M; w++) {
        let P = h[w];
        this._d.viaPts.push(P);
      }
      let b = l.point;
      this._d.viaPts.push(b), x = new RouteResult({
        start: c,
        end: l,
        waypoints: this._d.viaPtsInfo,
        distance: v.distance,
        duration: v.duration,
        steps: p,
        paths: d,
        type: r.ROUTE_TYPE
      });
    }
    return x;
  }
}
const http$1 = location.protocol === "https:" ? "https" : "http";
class DWRoute_Tdt {
  constructor(i = {}) {
    this.options = i;
  }
  async search(i, e, r) {
    const s = this.route;
    r = r || {}, this._searchOpts = r;
    const a = {
      mid: this._pointsToString(r.waypoints),
      orig: this._pointsToString(i),
      dest: this._pointsToString(e),
      style: 0
    };
    let c = `${http$1}://api.tianditu.gov.cn/drive/?postStr=${JSON.stringify(a)}&type=search`, l = await ScriptLoader.request(c);
    if (l && l.result) {
      const h = l.result, d = h.orig.split(","), f = h.dest.split(","), p = {
        point: new Vector3$1(d[0], d[1], 0),
        title: "\u8D77\u70B9"
      }, m = {
        point: new Vector3$1(f[0], f[1], 0),
        title: "\u7EC8\u70B9"
      }, y = h.mid.split(";");
      let x = [];
      if (h.mid) {
        let b = 1;
        for (let w = 0; w < y.length; w++) {
          if (!y[w])
            continue;
          const [M, P] = y[w].split(",");
          x.push({
            point: new Vector3$1(+M, +P, 0),
            title: "\u9014\u7ECF\u70B9" + b,
            curNo: b
          }), b++;
        }
      }
      const v = [], S = h.routelatlon.split(";");
      for (let b = 0; b < S.length; b++) {
        const w = S[b];
        if (!w)
          continue;
        const M = w.split(","), P = [+M[0], +M[1]];
        v.push(P);
      }
      return new RouteResult({
        start: p,
        end: m,
        waypoints: x,
        distance: h.distance,
        duration: h.duration,
        steps: h.routes.item,
        paths: [v],
        type: s.ROUTE_TYPE
      });
    }
  }
  _pointsToString(i) {
    let e = "";
    if (typeof i != "object")
      return i;
    if (Array.isArray(i) && (typeof i[0] == "number" || typeof i[0] == "string"))
      return i.join(",");
    if (i.isVector2 || i.isVector3)
      return i.x + "," + i.y;
    for (let r = 0; r < i.length; r++) {
      let s = SUtil.getX(i[r]) + "," + SUtil.getY(i[r]);
      r !== i.length - 1 ? e = e + s + ";" : e = e + s;
    }
    return e;
  }
}
class DrivingRoute extends BaseRoute {
  constructor(e = {}) {
    super(e);
    _(this, "QUERY_TYPE", QUERY_TYPE_DRIVING);
    _(this, "RETURN_TYPE", RETURN_TYPE_DRIVING);
    _(this, "ROUTE_TYPE", BMAP_ROUTE_TYPE_DRIVING);
    _(this, "name", "DrivingRoute");
    _(this, "apiSource");
    _(this, "_dw");
    _(this, "_engine");
    this.apiSource = e.apiSource || getApiSource(), this._dw = this._createInstance(e), this._dw.route = this, this.options.renderOptions.engine && (this._engine = this.options.renderOptions.engine, this._dw._engine = this._engine);
  }
  _createInstance(e) {
    const s = {
      [API_SOURCE_BAIDU]: DWRoute_Bd,
      [API_SOURCE_TIANDITU]: DWRoute_Tdt
    }[this.apiSource] || DWRoute_Bd;
    return new s(e);
  }
}
class RidingRoute extends BaseRoute {
  constructor(e = {}) {
    super(e);
    _(this, "QUERY_TYPE", QUERY_TYPE_RIDING);
    _(this, "ROUTE_TYPE", BMAP_ROUTE_TYPE_RIDING);
    _(this, "name", "RidingRoute");
    _(this, "_dw");
    _(this, "_engine");
    this._dw = new DWRoute_Bd(e), this._dw.route = this, this.options.renderOptions.engine && (this._engine = this.options.renderOptions.engine, this._dw._engine = this._engine);
  }
}
new Vector3$1();
const ht = class {
  constructor(i = {}) {
    _(this, "_formatCoordYXString", (i, e) => {
      let r;
      return e = e || {}, typeof i == "string" ? r = i : i.isVector2 || i.isVector3 ? r = i.y.toFixed(6) + "," + i.x.toFixed(6) : Array.isArray(i) ? r = i[1].toFixed(6) + "," + i[0].toFixed(6) : i.point && (r = this._formatCoordYXString(i.point, e)), r;
    });
    _(this, "_isUid", (i) => /^[0-9a-f]{24}$/.test(i));
    _(this, "_getLineType", (i, e) => {
      let r = 0, s = "";
      switch (e ? r = ht.LINE_TYPE_MAPPING_CROSS_CITY[i] : r = ht.LINE_TYPE_MAPPING[i], r) {
        case BMAP_LINE_TYPE_SUBWAY:
          s = "subway";
          break;
        case BMAP_LINE_TYPE_TRAIN:
          s = "train";
          break;
        case BMAP_LINE_TYPE_AIRPLANE:
          s = "airplane";
          break;
        case BMAP_LINE_TYPE_COACH:
        case BMAP_LINE_TYPE_BUS:
        default:
          s = "bus";
          break;
      }
      return s;
    });
    this.options = i, this._baiduMercatorProjection = getProjection(PROJECTION_BD_MERCATOR);
  }
  async search(i, e, r) {
    if (typeof e == "string" || typeof i == "string")
      return;
    r = r || {};
    let s;
    s = {
      qt: QUERY_TYPE_DIRECTION,
      mode: "transit",
      output: "json",
      coord_type: "bd09ll",
      ret_coordtype: "bd09ll"
    }, s.origin = this._formatCoordYXString(i), s.destination = this._formatCoordYXString(e), s.tactics_incity = this.options.policy || 0, s.trans_type_intercity = this.options.transitTypePolicy || 0, s.tactics_intercity = this.options.intercityPolicy || 0, this._isUid(r.start_uid) && (s.origin_uid = r.start_uid), this._isUid(r.end_uid) && (s.destination_uid = r.end_uid);
    let a = {
      start: i,
      end: e,
      _from: "search",
      policy: s.tactics_incity,
      intercityPolicy: s.tactics_intercity,
      transitTypePolicy: s.trans_type_intercity
    }, c = await SearchRequestMgr.request(s, a), l = c.result, h = c.content || {};
    if (l.error === 0 && h.status === 0 && h.type === DIRECTION_RETURN_TYPE_CLEAR) {
      let d = h.result;
      return d.routes === null || d.routes.length === 0 ? void 0 : d.origin.city_id === d.destination.city_id || d.origin.city_name === d.destination.city_name ? (c.content.transitType = BMAP_TRANSIT_TYPE_IN_CITY, this._processRawInCity(c, a)) : (c.content.transitType = BMAP_TRANSIT_TYPE_CROSS_CITY, this._processRawCrossCity(c, a));
    }
  }
  _processRawInCity(i, e) {
    const r = this.route;
    let s = i.content, a = s.result, c = {}, l = {};
    typeof e.start == "object" && !(e.start.isVector2 || e.start.isVector3 || Array.isArray(e.start)) ? Object.assign(c, e.start) : (c.title = "\u8D77\u70B9", c.city = a.origin.city_name, c.point = new Vector3$1(a.origin.location.lng, a.origin.location.lat, 0)), typeof e.end == "object" && !(e.end.isVector2 || e.end.isVector3 || Array.isArray(e.end)) ? Object.assign(l, e.end) : (l.title = "\u7EC8\u70B9", l.city = a.destination.city_name, l.point = new Vector3$1(a.destination.location.lng, a.destination.location.lat, 0));
    let d = s.result.routes[0], f = d.distance, p = d.duration, m = d.steps, y = 0, x = [], v = [], S = [];
    for (let E = 0; E < m.length; E++) {
      let b = m[E][0], w = [];
      if (w.push([+b.start_location.lng, +b.start_location.lat]), w = w.concat(SUtil.pathToPoints(b.path)), w.push([+b.end_location.lng, +b.end_location.lat]), b.vehicle_info.type === BMAP_VEHICLE_TYPE_WALKING) {
        let M = {
          distance: b.distance,
          points: w,
          rt: BMAP_ROUTE_TYPE_WALKING,
          index: y,
          planIndex: 0
        };
        y++, x.push(M), v.push(w);
      } else if (b.vehicle_info.type === BMAP_VEHICLE_TYPE_BUS) {
        let M = b.vehicle_info.detail, P = {
          title: M.on_station,
          point: new Vector3$1(b.start_location.lng, b.start_location.lat, 0)
        }, D = {
          title: M.off_station,
          point: new Vector3$1(b.end_location.lng, b.end_location.lat, 0)
        }, L = {
          title: M.name,
          distance: b.distance,
          points: w,
          stops: [
            P,
            D
          ],
          rt: BMAP_ROUTE_TYPE_TRANSIT,
          type: this._getLineType(M.type, !1),
          numViaStops: M.stop_num
        };
        x.push(L), S.push(w);
      }
    }
    return new RouteResult({
      start: c,
      end: l,
      distance: f,
      duration: p,
      steps: x,
      paths: S,
      walkingPaths: v,
      type: r.ROUTE_TYPE,
      transitType: i.content.transitType,
      intercityPolicy: e.intercityPolicy,
      transitTypePolicy: e.transitTypePolicy,
      policy: e.policy
    });
  }
  _processRawCrossCity(i, e) {
    const r = this.route;
    let s = i.content, a = s.result, c = {}, l = {};
    typeof e.start == "object" && !(e.start.isVector2 || e.start.isVector3 || Array.isArray(e.start)) ? Object.assign(c, e.start) : (c.title = "\u8D77\u70B9", c.city = a.origin.city_name, c.point = new Vector3$1(a.origin.location.lng, a.origin.location.lat, 0)), typeof e.end == "object" && !(e.end.isVector2 || e.end.isVector3 || Array.isArray(e.end)) ? Object.assign(l, e.end) : (l.title = "\u7EC8\u70B9", l.city = a.destination.city_name, l.point = new Vector3$1(a.destination.location.lng, a.destination.location.lat, 0));
    let d = s.result.routes[0], f = d.distance, p = d.duration, m = d.steps, y = 0, x = [], v = [], S = [];
    for (let E = 0; E < m.length; E++)
      for (let b = 0; b < m[E].length; b++) {
        let w = m[E][b], M = [];
        if (M.push([+w.start_location.lng, +w.start_location.lat]), M = M.concat(SUtil.pathToPoints(w.path)), M.push([+w.end_location.lng, +w.end_location.lat]), w.vehicle_info.type === BMAP_VEHICLE_TYPE_WALKING) {
          let P = {
            distance: w.distance,
            points: M,
            rt: BMAP_ROUTE_TYPE_WALKING,
            index: y,
            planIndex: 0
          };
          y++, x.push(P), v.push(M);
        } else if (w.vehicle_info.type === BMAP_VEHICLE_TYPE_BUS) {
          let P = w.vehicle_info.detail, D = {
            title: P.on_station,
            point: new Vector3$1(w.start_location.lng, w.start_location.lat, 0)
          }, L = {
            title: P.off_station,
            point: new Vector3$1(w.end_location.lng, w.end_location.lat, 0)
          }, O = {
            title: P.name,
            distance: w.distance,
            points: M,
            stops: [
              D,
              L
            ],
            rt: BMAP_ROUTE_TYPE_TRANSIT,
            type: this._getLineType(P.type),
            numViaStops: P.stop_num
          };
          x.push(O), S.push(M);
        } else if (w.vehicle_info.type === BMAP_VEHICLE_TYPE_TRAIN) {
          let P = w.vehicle_info.detail, D = {
            title: P.departure_station,
            point: new Vector3$1(w.start_location.lng, w.start_location.lat, 0)
          }, L = {
            title: P.arrive_station,
            point: new Vector3$1(w.end_location.lng, w.end_location.lat, 0)
          }, O = {
            title: P.name,
            distance: w.distance,
            points: M,
            stops: [
              D,
              L
            ],
            rt: BMAP_ROUTE_TYPE_TRANSIT,
            type: this._getLineType(w.vehicle_info.type, !0)
          };
          x.push(O), S.push(M);
        } else if (w.vehicle_info.type === BMAP_VEHICLE_TYPE_AIRPLANE) {
          let P = w.vehicle_info.detail, D = {
            title: P.departure_station,
            point: new Vector3$1(w.start_location.lng, w.start_location.lat, 0)
          }, L = {
            title: P.arrive_station,
            point: new Vector3$1(w.end_location.lng, w.end_location.lat, 0)
          }, O = {
            title: P.name,
            distance: w.distance,
            points: M,
            stops: [
              D,
              L
            ],
            rt: BMAP_ROUTE_TYPE_TRANSIT,
            type: this._getLineType(w.vehicle_info.type, !0)
          };
          x.push(O), S.push(M);
        } else if (w.vehicle_info.type === BMAP_VEHICLE_TYPE_COACH) {
          let P = w.vehicle_info.detail, D = {
            title: P.departure_station,
            point: new Vector3$1(w.start_location.lng, w.start_location.lat, 0)
          }, L = {
            title: P.arrive_station,
            point: new Vector3$1(w.end_location.lng, w.end_location.lat, 0)
          }, O = {
            title: P.name,
            distance: w.distance,
            points: M,
            stops: [
              D,
              L
            ],
            rt: BMAP_ROUTE_TYPE_TRANSIT,
            type: this._getLineType(w.vehicle_info.type, !0)
          };
          x.push(O), S.push(M);
        } else if (w.vehicle_info.type === BMAP_VEHICLE_TYPE_DRIVING) {
          let P = {
            distance: w.distance,
            points: M,
            rt: BMAP_ROUTE_TYPE_DRIVING,
            index: y,
            planIndex: 0
          };
          y++, x.push(P), S.push(M);
        }
      }
    return new RouteResult({
      start: c,
      end: l,
      distance: f,
      duration: p,
      steps: x,
      paths: S,
      walkingPaths: v,
      type: r.ROUTE_TYPE,
      transitType: i.content.transitType,
      policy: e.policy,
      intercityPolicy: e.intercityPolicy,
      transitTypePolicy: e.transitTypePolicy
    });
  }
};
let TransitRoute_Bd = ht;
_(TransitRoute_Bd, "LINE_TYPE_MAPPING", [
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  0,
  0,
  1,
  1,
  1
]), _(TransitRoute_Bd, "LINE_TYPE_MAPPING_CROSS_CITY", [
  0,
  3,
  4,
  0,
  0,
  0,
  5
]);
const http = location.protocol === "https:" ? "https" : "http";
class TransitRoute_Tdt {
  constructor(i = {}) {
    this.options = i;
  }
  async search(i, e, r) {
    const s = this.route;
    r = r || {}, this._searchOpts = r;
    const a = {
      startposition: this._pointsToString(i),
      endposition: this._pointsToString(e),
      linetype: 1
    };
    let c = `${http}://api.tianditu.gov.cn/transit?postStr=${JSON.stringify(a)}&type=busline`, l = await ScriptLoader.request(c);
    if (l && l.resultCode === 0) {
      const h = {
        title: "\u8D77\u70B9"
      }, d = {
        title: "\u7EC8\u70B9"
      }, p = l.results[0].lines[0];
      let m = [], y = [], x = [];
      for (let v = 0; v < p.segments.length; v++) {
        const S = p.segments[v];
        if (v === 0) {
          let P = S.stationStart.lonlat.split(",");
          h.point = new Vector3$1(+P[0], +P[1], 0);
        }
        if (v === p.segments.length - 1) {
          let P = S.stationEnd.lonlat.split(",");
          d.point = new Vector3$1(+P[0], +P[1], 0);
        }
        const E = this._getSegmentType(S.segmentType);
        let b = {
          type: E
        }, w = [];
        const M = S.segmentLine[0].linePoint.split(";");
        for (let P = 0; P < M.length; P++) {
          const D = M[P];
          if (!D)
            continue;
          const L = D.split(","), O = [+L[0], +L[1]];
          w.push(O);
        }
        if (E === "walking")
          b.rt = BMAP_ROUTE_TYPE_WALKING, y.push(w);
        else if (E === "bus" || E === "subway") {
          b.rt = BMAP_ROUTE_TYPE_TRANSIT, b.title = S.segmentLine[0].lineName;
          let P = {
            title: S.stationStart.name,
            point: new Vector3$1(
              +S.stationStart.lonlat.split(",")[0],
              +S.stationStart.lonlat.split(",")[1],
              0
            )
          }, D = {
            title: S.stationEnd.name,
            point: new Vector3$1(
              +S.stationEnd.lonlat.split(",")[0],
              +S.stationEnd.lonlat.split(",")[1],
              0
            )
          };
          b.stops = [
            P,
            D
          ], m.push(w);
        }
        x.push(b);
      }
      return new RouteResult({
        start: h,
        end: d,
        steps: x,
        paths: m,
        walkingPaths: y,
        type: s.ROUTE_TYPE
      });
    }
  }
  _pointsToString(i) {
    let e = "";
    if (typeof i != "object")
      return i;
    if (Array.isArray(i) && (typeof i[0] == "number" || typeof i[0] == "string"))
      return i.join(",");
    if (i.isVector2 || i.isVector3)
      return i.x + "," + i.y;
    for (let r = 0; r < i.length; r++) {
      let s = SUtil.getX(i[r]) + "," + SUtil.getY(i[r]);
      r !== i.length - 1 ? e = e + s + ";" : e = e + s;
    }
    return e;
  }
  _getSegmentType(i) {
    let e = "";
    switch (i) {
      case 1:
        e = "walking";
        break;
      case 2:
        e = "bus";
        break;
      case 3:
        e = "subway";
        break;
      case 4:
      default:
        e = "walking";
        break;
    }
    return e;
  }
}
class TransitRoute extends BaseRoute {
  constructor(e = {}) {
    super(e);
    _(this, "QUERY_TYPE", QUERY_TYPE_TRANSIT);
    _(this, "RETURN_TYPE", RETURN_TYPE_TRANSIT);
    _(this, "ROUTE_TYPE", BMAP_ROUTE_TYPE_TRANSIT);
    _(this, "name", "TransitRoute");
    _(this, "apiSource");
    _(this, "_dw");
    _(this, "_engine");
    this.apiSource = e.apiSource || getApiSource(), this._dw = this._createInstance(e), this._dw.route = this, this.options.renderOptions.engine && (this._engine = this.options.renderOptions.engine, this._dw._engine = this._engine);
  }
  _createInstance(e) {
    const s = {
      [API_SOURCE_BAIDU]: TransitRoute_Bd,
      [API_SOURCE_TIANDITU]: TransitRoute_Tdt
    }[this.apiSource] || TransitRoute_Bd;
    return new s(e);
  }
  renderMkr(e) {
    const r = this._engine, s = r.add(new Marker({
      point: e.start.point,
      icon: getAssetUrl("assets/images/markers/mkr_start.png"),
      width: 52 / 2,
      height: 82 / 2,
      offset: [0, -16]
    })), a = r.add(new Marker({
      point: e.end.point,
      icon: getAssetUrl("assets/images/markers/mkr_end.png"),
      width: 52 / 2,
      height: 82 / 2,
      offset: [0, -16]
    }));
    this._markers.push(s, a);
    for (let c = 0; c < e.steps.length; c++) {
      const l = e.steps[c];
      if (l.rt === BMAP_ROUTE_TYPE_TRANSIT)
        for (let h = 0; h < l.stops.length; h++) {
          const d = l.stops[h], f = r.add(new Marker({
            point: d.point,
            icon: getAssetUrl(`assets/images/markers/mkr_transit_${l.type}.png`),
            width: 44 / 2,
            height: 44 / 2
          }));
          this._markers.push(f);
        }
    }
  }
}
class WalkingRoute extends BaseRoute {
  constructor(e = {}) {
    super(e);
    _(this, "QUERY_TYPE", QUERY_TYPE_WALKING);
    _(this, "RETURN_TYPE", RETURN_TYPE_WALKING);
    _(this, "ROUTE_TYPE", BMAP_ROUTE_TYPE_WALKING);
    _(this, "name", "WalkingRoute");
    _(this, "_dw");
    _(this, "_engine");
    this._dw = new DWRoute_Bd(e), this._dw.route = this, this.options.renderOptions.engine && (this._engine = this.options.renderOptions.engine, this._dw._engine = this._engine);
  }
}
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Geocoder,
  LocalSearch,
  AutoComplete,
  Boundary,
  DistrictLayer,
  DrivingRoute,
  RidingRoute,
  TransitRoute,
  WalkingRoute,
  setApiSource,
  getApiSource,
  API_SOURCE_BAIDU,
  API_SOURCE_TIANDITU
}, Symbol.toStringTag, { value: "Module" }));
class InstancedPlaneBufferGeometry extends CustomInstancedBufferGeometry {
  constructor() {
    super();
    _(this, "setModelData", () => {
      const e = [
        -0.5,
        -0.5,
        0,
        -0.5,
        0.5,
        0,
        0.5,
        0.5,
        0,
        0.5,
        -0.5,
        0
      ], r = [
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0
      ], s = [
        0,
        2,
        1,
        0,
        3,
        2
      ];
      this.setAttribute("position", new Float32BufferAttribute(e, 3)), this.setAttribute("uv", new Float32BufferAttribute(r, 2)), this.setIndex(s);
    });
    this.setModelData();
  }
}
class GeoInstancedPointMesh extends GeoInstancedMesh {
  constructor() {
    super(...arguments);
    _(this, "isInstancedPointMesh", !0);
    _(this, "getInstanceLocalMatrix", (e, r, s) => {
      const { vertexSizes: a } = this.parameters, c = this.dataSource && this.dataSource.data && this.dataSource.data.size;
      if (a && c) {
        const l = new Matrix4();
        return l.makeScale(c[s], c[s], c[s]), l;
      }
      return null;
    });
    _(this, "addCustomAttributes", () => {
      const { vertexColors: e } = this.parameters, { color: r } = this.dataSource.data, s = [];
      e && r && r.forEach((a) => {
        const c = colorToArr4(a);
        s.push(c[0], c[1], c[2]);
      }), this.instanceColor = new InstancedBufferAttribute(new Float32Array(s), 3);
    });
  }
  computeInstanceMorphMatrix(e) {
    const { vertexSizes: r } = this.parameters, s = this.dataSource && this.dataSource.data, { size: a } = s || {};
    if (r && a)
      return defaultValue$1.EMPTY_MAT4;
    super.computeInstanceMorphMatrix(e);
  }
}
const uniforms$e = UniformsUtils.merge([
  UniformsLib.fog,
  commonUniforms,
  animationUnifroms,
  selectiveUniforms,
  keepSizeUniforms,
  {
    isCesium: { value: !1 }
  }
]);
class InstancedEffectPointMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.type = "InstancedEffectPointMaterial", this.isInstancedEffectPointMaterial = !0, this.lights = !1, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$e)), defineCommonProperties(this), defineAnimationProperties(this), defineMaterialSelectiveProperties(this), defineMaterialKeepSizeProperties(this);
  }
}
const vertexShader$d = `#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;

#ifdef IS_GLOBE
    attribute mat4 ecefMatrix;
#endif
#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif

uniform float height;
uniform float size;
uniform float elapsedTime;
uniform bool animationEffect;
uniform float animationEffectPeriod;
uniform float duration;

varying vec2 vPosition;
varying float vEffectRatio;
varying vec2 vUV;

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() {

    vUV = uv;

    #include <mvt_selective_vertex>
    vPosition = position.xy;
    vec3 transformed = vec3(position);

    float animationRotatePeriod = duration;
    float animationJumpPeriod = duration;
    float animationPeriod = duration;

    #include <mvt_animation_vertex>

    #ifndef MVT_USE_VERTEX_SIZE
        transformed *= size;
    #endif

    mat4 currentInstanceMatrix = instanceMatrix;
    #ifdef IS_GLOBE
        // instanceMatrix\u7684\u504F\u79FB\u503C\u662Fecef\u5750\u6807(\u51CF\u53BB\u4E2D\u5FC3\u504F\u79FB), \u6240\u4EE5\u9700\u8981\u5148ecefMatrix * instanceMatrixRotation\u8F6C\u6362\u5230ecef\u5750\u6807\u7136\u540E\u518D\u52A0\u4E0A\u504F\u79FB\u503C
        mat3 rot = mat3(ecefMatrix) * mat3(instanceMatrix);
        vec4 col0 = vec4(rot[0], 0.0);
        vec4 col1 = vec4(rot[1], 0.0);
        vec4 col2 = vec4(rot[2], 0.0);
        vec4 col3 = instanceMatrix[3];

        currentInstanceMatrix = mat4(col0, col1, col2, col3);
    #endif

    float pixelSize = getPixelSize(vec3(modelMatrix * currentInstanceMatrix * vec4(0., 0., 0., 1.)));
    if (keepSize) {
        transformed *= pixelSize;
    }
    // Breath\u90E8\u5206\u903B\u8F91, \u4EC5\u652F\u6301breath
    #ifdef MVT_USE_BREATH
    if (animationEffect) {
        vEffectRatio = mod(elapsedTime, duration) / duration;
        if (animationPeriodOffset) {
            vEffectRatio += instancedRandomFactor;
        }
        vEffectRatio = mod(vEffectRatio, 1.0);
        transformed *= vEffectRatio;
    } else {
        vEffectRatio = 1.0;
    }
    #endif

    vec4 worldPosition = modelMatrix * currentInstanceMatrix * vec4(transformed, 1.0);
    worldPosition.z += height;

    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)
        vColor = vec4(instanceColor.xyz, 1.0);
    #endif

    gl_Position = projectionMatrix * viewMatrix * worldPosition;
    #include <logdepthbuf_vertex>
}`, fragmentShaderFan = `#define GLSLIFY 1
// #include <common>

#ifdef MVT_USE_VERTEX_COLOR
  varying vec4 vColor;
#else
  uniform vec3 color;
#endif
// uniform vec3 color;
uniform float opacity;
uniform bool animationEffect;

varying float vEffectRatio;
varying vec2 vPosition;

// #include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
   
    #ifndef MVT_USE_VERTEX_COLOR
      vec4 vColor = vec4(color, 1.0);
    #endif
    float bb = atan(vPosition.y, vPosition.x) + 3.15;

    float pi = 3.14 * 1.;
    // bb = mod(bb, 6.28);
    if (bb > pi) {
        discard;
    } else { 
        float aa = mod(bb / pi, 1.0);
        float dis = distance(vPosition, vec2(0, 0));
        if (dis > 0.5) {
            discard;
        } else {
            gl_FragColor = vec4(vColor.rgb, 1.0);
            gl_FragColor.a *= aa;
        }
    }

    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
    // #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
}`, fragmentShaderRadarRotate = `#define GLSLIFY 1
uniform float segmentAngle;
#ifdef MVT_USE_VERTEX_COLOR
  varying vec4 vColor;
#else
  uniform vec3 color;
#endif
// uniform vec3 color;
uniform float opacity;
varying vec2 vPosition;

#define PI 3.1415926
#define radius .5
#include <logdepthbuf_pars_fragment>

float cros(vec2 line1, vec2 line2){
    return line1.x * line2.y - line2.x * line1.y;
}

void main() {
    #ifndef MVT_USE_VERTEX_COLOR
      vec4 vColor = vec4(color, 1.0);
    #endif
    bool crossNPI = false;
    float wholeAng = abs(mod(segmentAngle , PI * 2.));
    float dis = length(vec2(vPosition.xy - vec2(0.0)));

    // if(wholeAng < -1.0*PI){
    //     crossNPI = true;
    //     wholeAng = 2.0*PI + endAng-startAng;
    // }
    if (dis<radius) {
        vec2 nV = normalize(vPosition.xy);
        float angle = 0.0;
        if(nV.x > 0.0 && abs(nV.y) < 0.01) {
            angle = 0.5*PI;
        }
        else if (nV.x<0.0 && abs(nV.y) < 0.01) {
            angle = -0.5*PI;
        }
        else {
            angle = atan(nV.x,nV.y);
        }

        if (angle<.0) {
            angle = 2. * PI + angle;
        }

        float alpha = 0.1;

        if (angle > 0. && angle < wholeAng) {
            // alpha = 1.1 - (endAng-angle)/wholeAng;
            alpha = 1.1 - (1. - (wholeAng-angle) / wholeAng);
        }
        
        gl_FragColor = vec4(vColor.rgb, 1.0);
        gl_FragColor.a = alpha * opacity;
        #ifdef OPAQUE
            gl_FragColor.a = 1.0;
        #endif
    }
    else {
        discard;
    }
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <logdepthbuf_fragment>
}`, fragmentShaderRadarLaryeredRotate = `#define GLSLIFY 1
#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))
#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )
#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )
#define M_PI 3.1415926535897932384626433832795

// #define blue1 vec4(0.74,0.95,1.00,1.)
// #define blue2 vec4(0.87,0.98,1.00,1.)
// #define blue3 vec4(0.35,0.76,0.83,1.)
// #define blue4 vec4(0.953,0.969,0.89,1.)
// #define red   vec4(1.00,0.38,0.227,1.)

#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))
// #define elapsedTime 0.01
uniform float elapsedTime;
// uniform float speed;
uniform float duration;
varying vec2 vPosition;
#ifdef MVT_USE_VERTEX_COLOR
  varying vec4 vColor;
#else
  uniform vec3 color;
#endif
uniform vec3 sideColor;
uniform float opacity;
uniform float sideOpacity;
#include <logdepthbuf_pars_fragment>
float movingLine(vec2 uv, vec2 center, float radius)
{
    //angle of the line
    float t = mod((elapsedTime / duration), duration);
    float theta0 = 90.0 * t * 5.0;
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    if(r<radius)
    {
        //compute the distance to the line theta=theta0
        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),
            -sin(theta0*M_PI/180.0));
        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) )* 500.;
        d = normalize(d);
        //compute gradient based on angle difference to theta0
        float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);
        float gradient = clamp(1.0-theta/90.0,0.3,1.0);
        return SMOOTH(l,1.0)+0.5*gradient;
    }
    else return 0.0;
}
    
    float circle(vec2 uv, vec2 center, float radius, float width)
{
    float r = length(uv - center);
    return smoothstep(radius-width,radius,r)-smoothstep(radius,radius+width,r);
    // return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
}

float circle2(vec2 uv, vec2 center, float radius, float width, float opening)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    if( abs(d.y) > opening )
        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
    else
        return 0.0;
}
float circle3(vec2 uv, vec2 center, float radius, float width)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    float theta = 180.0*(atan(d.y,d.x)/M_PI);
    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *
        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *
        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));
}
    
float triangles(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))
         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))
         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))
         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));
}
    
float _cross(vec2 uv, vec2 center, float radius)
{
    vec2 d = uv - center;
    int x = int(d.x * 100.);
    int y = int(d.y * 100.);
    float r = sqrt( dot( d, d ) );
    if( (r<radius) && ( (x==y) || (x==-y) ) )
        return 1.0;
    else return 0.0;
}

void main() {
    #ifndef MVT_USE_VERTEX_COLOR
      vec4 vColor = vec4(color, 1.0);
    #endif
    vec4 finalColor = vec4(0.0, .0, .0, .0);
    vec4 diffuseColor = vec4(vColor.rgb, 1.0);
    vec4 side = vec4(sideColor, sideOpacity);
    vec2 uv = vPosition.xy;
    #include <logdepthbuf_fragment>
    //center of the image
    vec2 c = vec2(0.0, 0.0);
    finalColor += 0.3*_cross( vPosition.xy, c, .5);
    finalColor += ( circle(uv, c, .3, .01)
                  + circle(uv, c, .4, .01) ) * diffuseColor;
    finalColor += (circle(uv, c, .5, .02) ) * side;//+ dots(uv,c,240.0)) * blue4;
    // finalColor += circle3(uv, c, 313.0, 4.0) * blue1;
    // finalColor += triangles(uv, c, 315.0 + 30.0*sin(elapsedTime * speed *.0006)) * blue2;
    finalColor += movingLine(uv, c, .5) * diffuseColor;
    finalColor += circle(uv, c, .05, .01) * diffuseColor;
    // finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(elapsedTime * speed *.0006)) * blue3;
    if( length(uv-c) < .5 ) {
        if( length(finalColor)<0.2) {
            discard;
        }
    }
    else{
        discard;
    }

    finalColor.a *= opacity;
    if (finalColor.a <= 0.) {
        discard;
    }
    gl_FragColor = finalColor;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`, fragmentShaderSpread = `#define GLSLIFY 1
#include <common>

varying vec2 vUV;
#ifdef MVT_USE_VERTEX_COLOR
  varying vec4 vColor;
#else
  uniform vec3 color;
#endif
uniform float speed;
uniform float elapsedTime;
uniform float duration;

vec3 RadarPing(in vec2 uv, in vec2 center, in float innerTail, 
    in float frontierBorder, in float timeResetSeconds, 
    in float radarPingSpeed, in float fadeDistance, float t) {
    vec2 diff = center-uv;
    float r = length(diff);
    float time = mod(t, timeResetSeconds) * radarPingSpeed;
    
    float circle;
    circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder,time, r);
    circle *= smoothstep(fadeDistance, 0.25, r); // fade to 0 after fadeDistance
            
    return vec3(circle);
}
#include <logdepthbuf_pars_fragment>
void main() {
    #ifndef MVT_USE_VERTEX_COLOR
      vec4 vColor = vec4(color, 1.0);
    #endif
    // gl_FragColor = vec4(1.,.0,.0,1.);
    //normalize coordinates 
    vec2 uv = vUV; //move coordinates to 0..1
    uv = uv.xy*2.; // translate to the center
    uv += vec2(-1.0, -1.0);
    #include <logdepthbuf_fragment>
    vec3 color1;
    // generate some radar pings
    float fadeDistance = 1.3;
    float resetTimeSec = 5.0;
    float radarPingSpeed = 0.2;
    vec2 greenPing = vec2(0.0, 0.0);
    float t = mod((elapsedTime / duration), duration);
    color1 += RadarPing(uv, greenPing, 0.12, 0.00025, resetTimeSec,
        radarPingSpeed, fadeDistance, t * 5.0) * vec3(vColor.rgb);
    // color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec,
    //    radarPingSpeed, fadeDistance, elapsedTime * speed * .0006 + 1.) * uColor;
    color1 += RadarPing(uv, greenPing, 0.12, 0.00025, resetTimeSec,
        radarPingSpeed, fadeDistance, t * 5.0 + 2.) * vec3(vColor.rgb);
    //return the new color
    if(length(color1)<0.001){
        discard;
    }else{
        gl_FragColor = vec4(color1,clamp(length(color1),0.0,1.0));
    }
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`, fragmentShaderBubble = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
  varying vec4 vColor;
#else
  uniform vec3 color;
#endif
uniform float opacity;
uniform bool animationEffect;
uniform float elapsedTime;
uniform float duration;
uniform float center;
uniform float radius;

varying float vEffectRatio;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }

    #ifndef MVT_USE_VERTEX_COLOR
      vec4 vColor = vec4(color, 1.0);
    #endif
    float range = mod(elapsedTime, duration);
    float percent = 0.0;
    if (range <= duration) {
      percent = range / duration * 2.0;
    } else {
      percent = 1.0;
    }
    float r = radius * percent;
    
    float vColorAlpha = vColor.a;
    // \u4E2D\u5FC3\u70B9
    if (d <= center){
      if(d > 0.99 * center && d <= center) {
        vColorAlpha = 1.0 - smoothstep(0.99 * center, center, d);
      }
    }
    else {
      if (d < r) {
        vColorAlpha = smoothstep(0.1, 0.9, pow(d / r, 2.0) * 0.9);
        // \u8FB9\u7F18\u6297\u952F\u9F7F
        if (d >= 0.99 * r && d <= r) {
          vColorAlpha *= 1.0 - smoothstep(0.99, 1.0, d / r);
        }
        // \u62D6\u5C3E\u6E10\u9690
        if (range > duration) {
          vColorAlpha *= 1.0 - (range - duration);
        }
      }
      else {
        vColorAlpha = 0.0;
      }
      
    }
    gl_FragColor = vec4(vColor.rgb, vColorAlpha);
    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif
    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}`, fragmentShaderBreath = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
  varying vec4 vColor;
#else
  uniform vec3 color;
#endif
uniform float opacity;
uniform bool animationEffect;

varying float vEffectRatio;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    #ifndef MVT_USE_VERTEX_COLOR
      vec4 vColor = vec4(color, 1.0);
    #endif
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }

    gl_FragColor = vColor;

    if (animationEffect) {
        if (vEffectRatio > 0.7) {
            gl_FragColor.a *= (1.0 - vEffectRatio) / 0.3;
        }
    }

    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif
    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}`, fragmentShaderWave = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
  varying vec4 vColor;
#else
  uniform vec3 color;
#endif
uniform float opacity;
uniform bool animationEffect;
uniform float elapsedTime;
uniform float duration;
uniform float radiusDiff;
uniform float center;
uniform float radius;

varying float vEffectRatio;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > radius) {
        discard;
    }
    #ifndef MVT_USE_VERTEX_COLOR
      vec4 vColor = vec4(color, 1.0);
    #endif

    float vColorAlpha = vColor.a;
    
    float alpha = sin((radiusDiff - d) / radiusDiff * 2.0  * 3.14 + elapsedTime / duration * 10.);
    // \u4E2D\u5FC3\u70B9
    if (d <= center){
      if (d > 0.9 * center && d <= center) {
        if (alpha >= 0.5) {
          vColorAlpha = 1.0;
        } else {
          vColorAlpha = 1.0 - smoothstep(center - 0.0001, center, d);
        }
      }
    }
    else {
      if (alpha >= 0.6) {
        vColorAlpha = 1.0 - d / radius;
        if (alpha >= 0.5 && alpha <= 0.6) {
            vColorAlpha *= smoothstep(0.0, 0.1, alpha - 0.5);
        }
        
        if (d >= 0.8 * radiusDiff && d <= radiusDiff) {
            vColorAlpha *= 1.0 - smoothstep(0.9, 1.0, d / radiusDiff);
        }
        
      }
      else {
        vColorAlpha = 0.0;
      }
    }
    gl_FragColor = vec4(vColor.rgb, vColorAlpha);
    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif
    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}`;
let uniforms$d = UniformsUtils.merge([
  {
    size: { value: 100 },
    color: { value: [1, 0, 0] },
    duration: { value: 5e3 },
    center: { value: 0.1 },
    radius: { value: 0.5 },
    radiusDiff: { value: 0.08 },
    isEmissive: { value: !1 },
    keepSize: { value: !0 },
    segmentAngle: { value: 0.25 * Math.PI },
    sideOpacity: { value: 1 },
    sideColor: { value: [0.87, 0.98, 1] }
  }
]);
class InstancedEffectMaterial extends InstancedEffectPointMaterial {
  constructor(e = {}) {
    super();
    _(this, "name", "InstancedEffectPointMaterial");
    _(this, "isInstancedEffectPointMaterial", !0);
    this.depthTest = !0, this.depthWrite = !1, this.transparent = !0;
    const { type: r } = e, s = r === "Breath", a = r === "Wave", c = r === "Fan", l = r === "Radar", h = r === "RadarLayered", d = r === "RadarSpread";
    this.vertexShader = vertexShader$d, c ? this.fragmentShader = fragmentShaderFan : l ? this.fragmentShader = fragmentShaderRadarRotate : h ? this.fragmentShader = fragmentShaderRadarLaryeredRotate : d ? this.fragmentShader = fragmentShaderSpread : s ? this.fragmentShader = fragmentShaderBreath : a ? this.fragmentShader = fragmentShaderWave : this.fragmentShader = fragmentShaderBubble, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$d)), defineMaterialNormalProperties(this, [
      "speed",
      "sideOpacity",
      "isEmissive",
      "segmentAngle",
      "duration"
    ]), defineMaterialColorProperties(this, [
      "sideColor"
    ]), defineMaterialBoolDefineProperties(this, [
      ["isGlobe", "IS_GLOBE"],
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexSizes", "MVT_USE_VERTEX_SIZE"],
      ["isBreath", "MVT_USE_BREATH"]
    ]), this.isBreath = s, this.noAnimation = h || d, this.animationRotate = l, this.setValues(e);
  }
}
class EffectPoint extends GeoInstancedPointMesh {
  constructor(e) {
    super(e);
    _(this, "geometry");
    _(this, "material");
    _(this, "color");
    _(this, "size");
    _(this, "duration");
    _(this, "type");
    this.parameters = e, this.defineMaterialProxyProperties([
      "color",
      "size",
      "duration",
      "size3",
      "height",
      "opacity",
      "vertexColors",
      "segmentAngle",
      "sideColor",
      "vertexSizes"
    ]);
  }
  initObject() {
    this.geometry = new InstancedPlaneBufferGeometry(), this.material = new InstancedEffectMaterial(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  clone() {
    const e = new this.constructor(this.parameters);
    return e.getInstanceLocalMatrix = this.getInstanceLocalMatrix, e;
  }
}
class InstancedBallonBufferGeometry extends CustomInstancedBufferGeometry {
  constructor() {
    super();
    _(this, "setModelData", () => {
      const e = [
        -1,
        0,
        0,
        -1,
        0,
        2,
        1,
        0,
        2,
        1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        2,
        1,
        0,
        2,
        1,
        0,
        0
      ], r = [
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2
      ], s = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0
      ], a = [
        0,
        2,
        1,
        0,
        3,
        2,
        4,
        6,
        5,
        4,
        7,
        6
      ];
      this.setAttribute("position", new Float32BufferAttribute(e, 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2)), this.setAttribute("gType", new Float32BufferAttribute(r, 1)), this.setIndex(a);
    });
    _(this, "setData", (e) => {
      const {
        positions: r,
        randomFactors: s,
        aObjectIndices: a
      } = e;
      this.setAttribute("instancedPosition", new InstancedBufferAttribute(new Float32Array(r), 3)), this.setAttribute("objectIndex", new InstancedBufferAttribute(new Float32Array(a), 1));
    });
    this.setModelData();
  }
}
const vertexShader$c = `#define GLSLIFY 1
#include <common>

attribute vec3 instancedPosition;
attribute float instancedRandomFactor;
attribute float gType;
// attribute vec2 uv;

uniform float height;
uniform float size;
uniform float stringWidth;
uniform vec2 resolution;
uniform float time;
uniform bool keepSize;

varying float vGType;
varying vec3 vPosition;
varying vec2 vUv;

uniform bool animationPeriodOffset;
#ifdef ENABLE_ANIMATION_ROTATE
uniform float animationRotatePeriod;
#endif

#ifdef ENABLE_ANIMATION_JUMP
uniform float animationJumpPeriod;
uniform float animationJumpHeight;
#endif

#define MVT_KEEP_PROJECTION_POSITION

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

uniform float iconFillRatio;
void main() {
    vGType = gType;
    #include <mvt_selective_vertex>
    vec4 mvp_projectPosition;

    vec3 cameraRight = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);
    vec3 cameraUp    = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);

    mat4 faceCameraMatrix = mat4(
        vec4(cameraRight, 0.0),
        vec4(cameraUp,    0.0),
        vec4(0.0,         0.0, 1.0, 0.0),
        vec4(0.0,         0.0, 0.0, 1.0)
    );

    vUv = uv;

    vec3 worldPosition = (modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    float pixelSize = getPixelSize(worldPosition);

    vec3 transformed = position;

    if (gType == 1.) {
        transformed.x *= stringWidth * pixelSize / 2.0;
        if (keepSize) {
            transformed.z *= height * pixelSize / 2.0;
        }
        else {
            transformed.z *= height / 2.0;
        }
        vec4 projectionPosition = projectionMatrix * modelViewMatrix * instanceMatrix * faceCameraMatrix * vec4(transformed, 1.0);
        mvp_projectPosition = vec4(projectionPosition);

        gl_Position = projectionPosition;

    }
    else if (gType == 2.) {
        vPosition = position;
        vUv = uv;
        float uvScale = 1.0 / iconFillRatio;
        // vUv = uv * uvScale - (uvScale - 1.0) * 0.5;

        transformed.x *= size * pixelSize / 2.0;
        transformed.z = transformed.z * (size * pixelSize / 2.0);
        if (keepSize) {
            transformed.z += height * pixelSize;
        } else {
            transformed.z += height;
        }

        vec4 projectionPosition = projectionMatrix * modelViewMatrix * instanceMatrix * faceCameraMatrix * vec4(transformed, 1.0);
        mvp_projectPosition = vec4(projectionPosition);

        gl_Position = projectionPosition;
    }
    
    #ifdef ENABLE_ANIMATION_JUMP
        float jumpRatio = mod(time, animationJumpPeriod) / animationJumpPeriod;
        if (animationPeriodOffset) {
            jumpRatio = mod(jumpRatio + instancedRandomFactor, 1.0);
        }
        if (jumpRatio <= 0.5) {
            jumpRatio *= 2.0;
            jumpRatio = jumpRatio * jumpRatio * jumpRatio;
        } else {
            jumpRatio = (1.0 - jumpRatio) * 2.0;
            jumpRatio = jumpRatio * jumpRatio * jumpRatio;
        }
        gl_Position.y += jumpRatio * height * 2.0 / resolution.y;
    #endif
    #include <logdepthbuf_vertex>
}`, fragmentShader$b = `#define GLSLIFY 1
#include <common>

uniform float size;
uniform vec3 color;
uniform float shape;
uniform vec4 stringColor;
uniform sampler2D iconTexture;
uniform float opacity;
uniform float iconFillRatio;
uniform float pixelRatio;

varying float vGType;
varying vec3 vPosition;
varying vec2 vUv;

mat2 rotate(float rad) {
    float c = cos(rad);
    float s = sin(rad);
    return mat2(
        c, s,
        -s, c
    );
}

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
void main() {
    if (vGType == 1.) {
        #ifdef USE_DASH
            vec2 rotatedCoord = rotate(1.570796327) * gl_FragCoord.xy;
            float dash = fract(rotatedCoord.x / (8.0 * pixelRatio));
            if (dash > 0.5) {
                discard;
            }
        #endif
        gl_FragColor = stringColor;
    } else if (vGType == 2.) {
       
        gl_FragColor = vec4(color, 1.0);
        
        vec2 newUv = vUv;
        // float uvScale = 1.0 / iconFillRatio;
        // vec2 newUv = vUv * uvScale - (uvScale - 1.0) * 0.5;
        // newUv.x -= 0.25;
        // newUv.y -= 0.25;
        vec4 textureColor = texture2D(iconTexture, newUv);
        gl_FragColor = mix(gl_FragColor, textureColor, textureColor.a);

        if (shape == 1.) {
            float d = distance(vec2(vPosition.x, vPosition.z), vec2(0, 1));
            if (d > 1.) {
                discard;
            }
        }
    }

    if (gl_FragColor.a < 0.001) {
        discard;
    }
    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif
    
    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}`, uniforms$c = UniformsUtils.merge([
  selectiveUniforms,
  {
    stringWidth: { value: 2 },
    resolution: { value: [1, 1] },
    stringColor: { value: [1, 0, 0, 1] },
    iconTexture: { value: null },
    shape: { value: 1 },
    height: { value: 100 },
    iconFillRatio: { value: 0.8 },
    keepSize: { value: !0 },
    size: { value: 10 }
  }
]);
class InstancedBallonMaterial extends InstancedEffectPointMaterial {
  constructor(i) {
    super(), this.name = "InstancedBallonMaterial", this.isInstancedBallonMaterial = !0, this.vertexShader = vertexShader$c, this.fragmentShader = fragmentShader$b, this.side = DoubleSide, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$c)), this.textureLoader = new TextureLoader();
    let e = null;
    defineMaterialNormalProperties(this, [
      "resolution",
      "shape",
      "stringColor",
      "stringWidth",
      "iconFillRatio",
      "isEmissive"
    ]), defineMaterialBoolDefineProperties(this, [
      ["dashed", "USE_DASH"]
    ]), Object.defineProperties(this, {
      iconSrc: {
        get: function() {
          return e;
        },
        set: function(r) {
          if (e === r)
            return;
          e = r, this.uniforms.iconTexture.value && (this.uniforms.iconTexture.value.dispose(), this.uniforms.iconTexture.value = null);
          const s = this.textureLoader.load(r);
          s.colorSpace = SRGBColorSpace, s.wrapS = s.wrapT = RepeatWrapping, this.uniforms.iconTexture.value = s;
        }
      }
    }), this.setValues(i);
  }
  dispose() {
    this.uniforms.iconTexture.value && this.uniforms.iconTexture.value.dispose(), super.dispose();
  }
}
class BallonPoint extends GeoInstancedMesh {
  constructor(e) {
    super(e);
    _(this, "getBallonIconSrc", (e) => {
      if (e)
        return e;
    });
    this.parameters = e, this.defineMaterialProxyProperties([
      "color",
      "size",
      "size3",
      "height",
      "opacity",
      "dashed"
    ]);
  }
  getDefaultParams() {
    return {
      iconSrc: "car"
    };
  }
  initObject() {
    this.geometry = new InstancedBallonBufferGeometry(), this.material = new InstancedBallonMaterial({
      iconSrc: this.getBallonIconSrc(this.parameters.iconSrc),
      ...this.parameters
    }), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
}
const vertexShader$b = `#define GLSLIFY 1
#include <common>

attribute float pIndex;
attribute float aMapIndex;

uniform float pixelRatio;
uniform float width;
uniform float height;
uniform float uScale;
uniform float ulength;
uniform vec2 resolution;
uniform vec2 offset;
uniform bool uFlat;
uniform bool keepSize;
uniform float elapsedTime;

#ifdef IS_GLOBE
attribute mat3 aInstanceRotationMatrix;
#endif

varying vec2 vUv;
varying vec4 vColor;

#ifdef MVT_USE_VERTEX_ROTATEZ
    attribute float aRotateZ;
# else
    uniform float uRotateZ;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec3 color;
#endif

#ifdef USE_ANIMATION
uniform float jumpHeight;
uniform float jumpSpeed;
#endif

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

vec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {
    float x = coord.x;
    float y = coord.y;
    if (corner == 1.0) {
        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);
    } else if (corner == 2.0) {
        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else if (corner == 3.0) {
        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else {
        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);
    }
    return vec3(x, y, coord.z);
}

void main() { 
    #include <mvt_selective_vertex>

    mat4 currentInstanceMatrix = mat4(1.0);
    vec3 currentPosition = position;
    #ifdef IS_GLOBE
        currentInstanceMatrix = mat4(
            vec4(aInstanceRotationMatrix[0], 0.0),
            vec4(aInstanceRotationMatrix[1], 0.0),
            vec4(aInstanceRotationMatrix[2], 0.0),
            vec4(position, 1.0)
        );

        currentPosition = vec3(0.0, 0.0, 0.0);
    #endif

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = vec4(color, 1.0);
    #endif

    float rotateZ;
    #ifdef MVT_USE_VERTEX_ROTATEZ
        rotateZ = aRotateZ;
    # else
        rotateZ = uRotateZ;
    #endif

    vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));
    float pixelSize = getPixelSize(worldPosition.xyz);
    if (uFlat) {
        float hw = width * 0.5;
        float hh = height * 0.5;
        if (keepSize) {
            hw *= pixelSize;
            hh *= pixelSize;
        }

        vec3 current = transformCoord(currentPosition, vec2(hw, hh), pIndex, -rotateZ);
        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);
    }
    else {
        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0);
        float w = gl_Position.w;
        gl_Position /= w;

        float hw = width / resolution.x * uScale;
        float hh = height / resolution.y * uScale;
        vec2 o = offset;
        if (!keepSize) {
            hw /= pixelSize;
            hh /= pixelSize;
            o /= pixelSize;
        }

        gl_Position.x += o.x * 2. / resolution.x;
        gl_Position.y -= o.y * 2. / resolution.y;

        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }

        #ifdef USE_ANIMATION
            float bounce = abs(sin(elapsedTime / 1000.0 * jumpSpeed)) * jumpHeight;
            gl_Position.y += (bounce * 2. / resolution.y);
        #endif

        gl_Position *= w;
    }

    vUv = uv;

    #include <logdepthbuf_vertex>
}`, fragmentShader$a = `#define GLSLIFY 1
#include <common>

uniform float opacity;

uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;
uniform float width;
uniform float height;

varying vec2 vUv;
varying vec4 vColor;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));
    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);

    if (gl_FragColor.a <= 0.) {
        discard;
    }
    gl_FragColor *= vColor;

    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`, textureLoader$2 = new TextureLoader(), uniforms$b = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  keepSizeUniforms,
  {
    emissive: { value: [0, 0, 0] },
    isEmissive: { value: !1 },
    width: { value: 12 },
    height: { value: 12 },
    offset: { value: [0, 0] },
    ulength: { value: 1 },
    useCanvasMap: { value: !1 },
    vertexIcons: { value: !1 },
    opacity: { value: 1 },
    map: { value: null },
    useMap: { value: !1 },
    uScale: { value: 1 },
    uFlat: { value: !1 },
    keepSize: { value: !0 },
    color: { value: [1, 1, 1] },
    vertexColors: { value: !1 },
    jumpHeight: { value: 0 },
    jumpSpeed: { value: 0 },
    uRotateZ: { value: 0 }
  }
]);
class IconMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "IconMaterial", this.vertexShader = vertexShader$b, this.fragmentShader = fragmentShader$a, this.isIconMaterial = !0, this.transparent = !0, this._fallback = getAssetUrl("assets/images/fallbackIcon.png"), this._fallbackTexture = textureLoader$2.load(this.fallback), this._fallbackTexture.wrapS = this._fallbackTexture.wrapT = ClampToEdgeWrapping, this._fallbackTexture.colorSpace = SRGBColorSpace, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$b)), defineMaterialKeepSizeProperties(this), defineMaterialSelectiveProperties(this), defineMaterialNormalProperties(this, [
      "width",
      "height",
      "offset",
      "opacity",
      "emissive",
      "isEmissive",
      "jumpHeight",
      "jumpSpeed"
    ]), defineMaterialAliasProperties(this, [
      ["scale", "uScale"],
      ["flat", "uFlat"],
      ["rotateZ", "uRotateZ"]
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexRotateZs", "MVT_USE_VERTEX_ROTATEZ"],
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["animationJump", "USE_ANIMATION"],
      ["isGlobe", "IS_GLOBE"]
    ]), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const r = this.mapSrc, s = this.userData[this.urlCacheKey], a = this;
          if (s !== e) {
            if (r && r.dispose(), !e && !this.fallback) {
              this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[this.urlCacheKey];
              return;
            }
            textureLoader$2.load(e, function(c) {
              c.wrapS = c.wrapT = ClampToEdgeWrapping, c.colorSpace = SRGBColorSpace, a.uniforms.map.value = c, a.userData[a.urlCacheKey] = e, a.uniforms.useMap.value = !0, a.uniforms.useCanvasMap.value = !1;
            }, void 0, (c) => {
              a.uniforms.map.value = this._fallbackTexture, a.userData[a.urlCacheKey] = e, a.uniforms.useMap.value = !0, a.uniforms.useCanvasMap.value = !1;
            });
          }
        }
      },
      mapTexture: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          if (!e) {
            this.uniforms.map.value = null, this.uniforms.useCanvasMap.value = !1;
            return;
          }
          e.wrapS = e.wrapT = ClampToEdgeWrapping, e.colorSpace = SRGBColorSpace, this.uniforms.map.value = e, this.uniforms.useMap.value = !1, this.uniforms.useCanvasMap.value = !0, delete this.userData[this.urlCacheKey];
        }
      }
    }), this.setValues(i);
  }
  set fallback(i) {
    this._fallback = i, this._fallbackTexture = textureLoader$2.load(i), this._fallbackTexture.wrapS = this._fallbackTexture.wrapT = ClampToEdgeWrapping, this._fallbackTexture.colorSpace = SRGBColorSpace;
  }
  get fallback() {
    return this._fallback;
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
class IconGeometry extends BufferGeometry {
  constructor(i) {
    super(i), this.parameters = i;
  }
  setData(i) {
    const { aPositions: e, aObjectIndices: r, aUvs: s, aColors: a, pIndices: c, rotateZs: l, indices: h } = i;
    this.setAttribute("position", new Float32BufferAttribute(e, 3)), this.setAttribute("pIndex", new Float32BufferAttribute(c, 1)), this.setAttribute("objectIndex", new Float32BufferAttribute(r, 1)), this.setAttribute("uv", new Float32BufferAttribute(s, 2)), this.parameters.vertexColors && this.setAttribute("aColor", new Float32BufferAttribute(a, 4)), this.parameters.vertexRotateZs && this.setAttribute("aRotateZ", new Float32BufferAttribute(l, 1)), i.aInstanceMatrices && this.setAttribute("aInstanceRotationMatrix", new Float32BufferAttribute(i.aInstanceMatrices, 9)), this.setIndex(h), this.cachedObjectIndices = r;
  }
}
const _tempVector3$2 = new Vector3$1(), _tempVector4$2 = new Vector4(), _tempMatrix4$2 = new Matrix4(), _tempMatrix3 = new Matrix3(), _tempA = new Vector3$1(), _morphA = new Vector3$1();
class Icon extends GeoMesh {
  constructor(e = {}) {
    super(e);
    _(this, "isEventEntitySupported", !0);
    _(this, "_padding");
    _(this, "oldMapTextureRes", /* @__PURE__ */ new Map());
    _(this, "texture");
    _(this, "geometry");
    _(this, "material");
    _(this, "canvas");
    _(this, "ctx");
    _(this, "iconUrlHash", /* @__PURE__ */ new Map());
    _(this, "boxHash", /* @__PURE__ */ new Map());
    _(this, "gap", [2, 2]);
    _(this, "getTextureAndHash", (e, r, s, a, c) => {
      const l = this.iconUrlHash;
      if (!c && this.oldMapTextureRes)
        return this.oldMapTextureRes;
      if (!e[0] || !e[0][r])
        return { texture: this.texture, iconUrlHash: l };
      let h = l.size, d = l.size, f = /* @__PURE__ */ new Map();
      for (let m = 0; m < e.length; m++) {
        const y = e[m][r];
        l.get(y) === void 0 && (l.set(y, h), f.set(y, h), h++);
      }
      return d === l.size ? this.oldMapTextureRes : Array.from(l.entries()).map(([m, y]) => new Promise((x, v) => {
        url2canvas(m, (S) => {
          l.set(m, S), x(m);
        }, () => {
          if (this.material.fallback) {
            let S = new Image();
            S.crossOrigin = "anonymous", S.onload = function() {
              let E = S.width, b = S.height, w = document.createElement("canvas");
              w.width = E, w.height = b, w.getContext("2d").drawImage(S, 0, 0, E, b), l.set(m, w), x(m);
            }, S.src = this.material.fallback;
          }
        });
      }));
    });
    this.parameters = e, this._padding = this.parameters.padding !== void 0 ? this.parameters.padding : [2, 2];
    const r = this.canvas = document.createElement("canvas");
    r.width = r.height = 1, this.ctx = r.getContext("2d"), this.texture = new CanvasTexture(r), this.parameters.mapSrc || (this.parameters.mapSrc = ""), this.defineMaterialProxyProperties([
      "width",
      "height",
      "offset",
      "map",
      "mapSrc",
      "transparent",
      "opacity",
      "flat",
      "keepSize",
      "color",
      "vertexColors",
      "animationJump",
      "jumpHeight",
      "jumpSpeed",
      "fallback"
    ]), this.boxes = [], this.boxSize = e.boxSize || 100;
  }
  initObject() {
    let { vertexIcons: e, ...r } = this.parameters;
    this.geometry = new IconGeometry(this.parameters), this.material = new IconMaterial(r), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  getDefaultParams() {
    return {
      width: 12,
      height: 12
    };
  }
  collisionTest(e) {
    return {
      width: this.width,
      height: this.height
    };
  }
  createTexture() {
    if (!this.canvas)
      return this.oldMapTextureRes;
    const e = this.ctx, r = this.iconUrlHash;
    for (let [a, c] of r) {
      const l = a, h = r.get(l);
      if (typeof h == "string")
        continue;
      const d = this.boxes.findIndex((x) => x.key === a);
      if (d >= 0) {
        const x = this.boxes.splice(d, 1);
        this.boxes.unshift(x[0]);
        continue;
      }
      const f = h.width, p = h.height, m = f + this.gap[0], y = p + this.gap[1];
      this.boxes.unshift({
        w: m,
        h: y,
        width: f,
        height: p,
        key: a,
        icon: h
      });
    }
    for (let a = 0; a < this.boxes.length; a++) {
      const c = this.boxes[a];
      this.boxHash.set(c.key, c);
    }
    return createSprite(this.boxes, e, this.canvas, {
      fillStyle: this._fillStyle,
      fontSize: this.parameters.fontSize,
      gap: this.gap,
      padding: this.padding,
      dpr: this.engine.rendering.pixelRatio
    }) ? (this.texture.dispose(), this.texture = new CanvasTexture(this.canvas)) : this.texture.needsUpdate = !0, this.oldMapTextureRes = { texture: this.texture, iconUrlHash: r }, { texture: this.texture, iconUrlHash: r };
  }
  async _updateData() {
    const e = this.engine.map.isGlobe, {
      vertexIcons: r,
      inconPropName: s = "icon",
      width: a,
      height: c
    } = this.parameters;
    let l = [];
    this._enableCollision && this._collisionData ? l = this._collisionData : l = this.dataSource.userData;
    const h = [], d = [], f = [], p = [], m = [], y = [], x = [], v = [];
    let S = "", E = {};
    const b = new Matrix4();
    if (r) {
      let P = this.getTextureAndHash(l, s, a, c, !0), D;
      Array.isArray(P) ? (await Promise.all(P), D = this.createTexture()) : D = P, S = D.texture, E = D.iconUrlHash || {}, this.material.mapTexture = S, this.material.uniforms.ulength.value = E.size;
      for (let L = 0; L < l.length; L++) {
        const O = l[L].position, F = l[L].index, k = l[L][s], V = l[L].rotateZ || 0, N = this.boxHash.get(k);
        if (!N)
          continue;
        const U = l[L].color;
        let z;
        this.parameters.vertexColors && (U ? z = colorToArr4(U) : z = [1, 1, 1, 1]), this.parameters.vertexRotateZs && x.push(V, V, V, V), e && (this._calculateTransform(O, b), _tempMatrix3.setFromMatrix4(b));
        for (let W = 0; W < 4; W++)
          h.push(...O), d.push(W), f.push(F), z && y.push(...z), e && v.push(..._tempMatrix3.elements);
        const $ = N.x / this.canvas.width, G = (N.x + N.w) / this.canvas.width, j = (N.y + N.h) / this.canvas.height, Y = N.y / this.canvas.height;
        p.push(
          $,
          j,
          $,
          Y,
          G,
          Y,
          G,
          j
        );
        const H = L * 4;
        m.push(
          H,
          H + 2,
          H + 1,
          H,
          H + 3,
          H + 2
        );
      }
    } else
      for (let P = 0; P < l.length; P++) {
        const D = l[P].position, L = l[P].index, O = l[P].color, F = l[P].rotateZ || 0;
        let k;
        this.parameters.vertexColors && (O ? k = colorToArr4(O) : k = [1, 1, 1, 1]), this.parameters.vertexRotateZs && x.push(F, F, F, F), e && (this._calculateTransform(D, b), _tempMatrix3.setFromMatrix4(b));
        for (let N = 0; N < 4; N++)
          h.push(...D), d.push(N), f.push(L), k && y.push(...k), e && v.push(..._tempMatrix3.elements);
        p.push(0, 1, 0, 0, 1, 0, 1, 1);
        const V = P * 4;
        m.push(
          V,
          V + 2,
          V + 1,
          V,
          V + 3,
          V + 2
        );
      }
    const w = e ? v : null;
    this.geometry.setData({
      aColors: y,
      aPositions: h,
      pIndices: d,
      aObjectIndices: f,
      aUvs: p,
      aInstanceMatrices: w,
      rotateZs: x,
      indices: m
    }), this.geometry.computeBoundingSphere();
    const M = this.geometry.boundingSphere.center;
    this.originCenter = new Vector3$1().copy(M), this.makeGeometryOffsetPosition(this.geometry, h), this.needsUpdate = !1, this.engine.requestRender();
  }
  _calculateTransform(e, r) {
    return this.engine.map.isGlobe ? (r || (r = new Matrix4()), Transforms.eastNorthUpToFixedFrame(_tempVector3$2.fromArray(e), null, r), r) : defaultValue$1.EMPTY_MAT4;
  }
  getEntityByIndex(e) {
    const r = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const s = {
      index: e,
      value: r.getDataItem(e),
      itemIndex: r.getDataItemIndex(e),
      pairs: {}
    }, a = r.data;
    for (const c of Object.keys(a))
      s.pairs[c] = a[c][e];
    return s;
  }
  raycast(e, r) {
    const s = this.flat;
    if (!this.visible)
      return;
    if (s) {
      this.geometry.boundingSphere === null && this.geometry.computeBoundingSphere();
      const { width: k, height: V } = this.parameters;
      let N = Math.max(k, V) / 2;
      this.keepSize && (N *= this.material.uniforms.zoomUnits.value), this.geometry.boundingSphere.radius += N, Mesh.prototype.raycast.call(this, e, r), this.geometry.boundingSphere.radius -= N;
      return;
    }
    const a = this.geometry, c = a.getAttribute("position");
    if (!c || !c.array || !c.array.length === 0)
      return;
    const l = a.getAttribute("offset");
    let h = [];
    l && (h = l.array);
    let d = e.camera;
    d || (d = this.engine.camera);
    const f = e.mouse;
    if (!f)
      return;
    const p = this.material.uniforms.resolution.value, m = f.x, y = f.y;
    let x = this.width / p.x, v = this.height / p.y;
    const S = x, E = v;
    let b = 0, w = 0, M = 0, P = 0, D = 0, L = 0;
    _tempMatrix4$2.multiplyMatrices(d.projectionMatrix, d.matrixWorldInverse), _tempMatrix4$2.multiplyMatrices(_tempMatrix4$2, this.matrixWorld);
    const O = c.array;
    let F = 0;
    for (let k = 0, V = O.length - 11; k < V; k += 12) {
      if (_tempVector4$2.set(O[k], O[k + 1], O[k + 2], 1), _tempVector4$2.applyMatrix4(_tempMatrix4$2), _tempVector4$2.divideScalar(_tempVector4$2.w), this.parameters.vertexOffsets ? (F = k / 12 * 8, D = h[F] || 0, L = h[F + 1] || 0) : (D = this.material.uniforms.offset.value ? this.material.uniforms.offset.value[0] : 0, L = this.material.uniforms.offset.value ? this.material.uniforms.offset.value[1] : 0), _tempVector4$2.x += D * 2 / p.x, _tempVector4$2.y -= L * 2 / p.y, !this.keepSize) {
        const { x: N, y: U, z } = this.originCenter, $ = this.getPixelSize(
          new Vector3$1(O[k] + N, O[k + 1] + U, O[k + 2] + z)
        );
        x = S / $, v = E / $, D /= $, L /= $;
      }
      if (b = _tempVector4$2.x - x, M = _tempVector4$2.x + x, w = _tempVector4$2.y - v, P = _tempVector4$2.y + v, b <= m && M >= m && w <= y && P >= y) {
        _tempVector3$2.set(O[k], O[k + 1], O[k + 2]), _tempVector3$2.applyMatrix4(this.matrixWorld);
        const N = {
          instanceId: k / 12,
          object: this,
          point: _tempVector3$2.clone(),
          distance: _tempVector3$2.distanceTo(d.position)
        };
        r.push(N);
      }
    }
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
  set padding(e) {
    this._padding = e;
  }
  get padding() {
    return this._padding;
  }
  getVertexPosition(e, r) {
    const s = this.geometry, a = s.attributes.position, c = s.morphAttributes.position, l = s.morphTargetsRelative;
    r.fromBufferAttribute(a, e);
    const h = e % 4;
    let d = this.parameters.width / 2, f = this.parameters.height / 2;
    if (this.keepSize) {
      const m = this.originCenter, y = this.getPixelSize(new Vector3$1().addVectors(m, r));
      d *= y, f *= y;
    }
    h === 1 ? d = -d : h === 2 || (h === 3 ? f = -f : (f = -f, d = -d)), r.x += d, r.y += f;
    const p = this.morphTargetInfluences;
    if (c && p) {
      _morphA.set(0, 0, 0);
      for (let m = 0, y = c.length; m < y; m++) {
        const x = p[m], v = c[m];
        x !== 0 && (_tempA.fromBufferAttribute(v, e), l ? _morphA.addScaledVector(_tempA, x) : _morphA.addScaledVector(_tempA.sub(r), x));
      }
      r.add(_morphA);
    }
    return r;
  }
  getPixelSize(e) {
    const { camera: r, rendering: s } = this.engine;
    return r.isOrthographicCamera ? this.material.uniforms.zoomUnits.value : 0.2 * r.projectionMatrix.elements[5] / s.resolution.y * r.position.distanceTo(e);
  }
  getEntityIndexByFace(e, r) {
    return this.geometry.cachedObjectIndices[r];
  }
}
Icon.prototype._computeIntersections = Mesh.prototype._computeIntersections;
const _vector4 = new Vector4(), _matrix4 = new Matrix4(), _screenSize = new Vector2$1();
class DOMPoint extends GeoObject {
  constructor(e) {
    super(e);
    _(this, "isDOMPoint", !0);
    _(this, "frustumCulled", !1);
    _(this, "_visible", !0);
    _(this, "onBeforeScenePrepareRenderHook", (e, r, s) => {
      this.container = e.map.container;
      let a = e.renderer;
      const c = this.points, l = this.nodes;
      a.getSize(_screenSize), _matrix4.multiplyMatrices(s.matrixWorldInverse, this.matrixWorld), _matrix4.multiplyMatrices(s.projectionMatrix, _matrix4);
      for (let h = 0; h < c.length; h++) {
        _vector4.set(c[h][0], c[h][1], c[h][2], 1), _vector4.applyMatrix4(_matrix4), _vector4.divideScalar(_vector4.w);
        const d = (_vector4.x + 1) / 2 * _screenSize.x, f = (-_vector4.y + 1) / 2 * _screenSize.y;
        if (!l[h])
          return;
        _vector4.x > 1 || _vector4.x < -1 || _vector4.y > 1 || _vector4 < -1 || _vector4.z > 1 || _vector4 < -1 ? addClass(l[h], `${CSS_NAMESPACE}-hidden`) : removeClass(l[h], `${CSS_NAMESPACE}-hidden`), l[h].style.left = d + this.offset[0] + "px", l[h].style.top = f + this.offset[1] + "px";
      }
    });
    this.points = [], this.nodes = [], this.offset = [0, 0], this.parameters = e;
  }
  renderItem(e) {
    const r = document.createElement("div");
    return r.style.position = "absolute", r.style.width = "60px", r.style.height = "40px", r.style.background = "#FFFFFF", r;
  }
  clone() {
    const e = super.clone();
    return e.parameters = this.parameters, e.renderItem = this.renderItem, e;
  }
  _updateData() {
    const e = this.engine, r = e.camera, s = e.renderer, { offset: a = [0, 0] } = this.parameters;
    for (let h = 0; h < this.nodes.length; h++)
      this.nodes[h].remove();
    this.nodes = [], this.points = [];
    const c = this.dataSource;
    if (!c)
      return;
    c.needsUpdate && c.update(), s.getSize(_screenSize), _matrix4.multiplyMatrices(r.matrixWorldInverse, this.matrixWorld), _matrix4.multiplyMatrices(r.projectionMatrix, _matrix4);
    const l = c.data && c.data.position || [];
    for (let h = 0, d = c.size; h < d; h++) {
      const f = l[h];
      this.points.push(f);
      const p = this.renderItem(c.getDataItem(h));
      _vector4.set(f[0], f[1], f[2], 1), _vector4.applyMatrix4(_matrix4), _vector4.divideScalar(_vector4.w);
      const m = (_vector4.x + 1) / 2 * _screenSize.x, y = (-_vector4.y + 1) / 2 * _screenSize.y;
      _vector4.x > 1 || _vector4.x < -1 || _vector4.y > 1 || _vector4 < -1 || _vector4.z > 1 || _vector4 < -1 ? addClass(p, `${CSS_NAMESPACE}-hidden`) : removeClass(p, `${CSS_NAMESPACE}-hidden`), addClass(p, `${CSS_NAMESPACE}-dom-points`), p.style.left = m + a[0] + "px", p.style.top = y + a[1] + "px", p.style.visibility = this.visible === !0 ? "" : "hidden", this.nodes.push(p), this.container.appendChild(p);
    }
    this.offset = a, this.needsUpdate = !1, this.engine && this.engine.requestRender();
  }
  onDispose() {
    this.nodes && this.nodes.length && this.nodes.forEach((e) => {
      e.remove();
    }), this.points = [], this.nodes = [];
  }
  set visible(e) {
    if (this._visible === e)
      return;
    this._visible = e;
    let r = e ? "" : "hidden";
    this.nodes && this.nodes.length && this.nodes.forEach((s) => {
      s.style.visibility = r;
    });
  }
  get visible() {
    return this._visible;
  }
}
const vertexShader$a = `#define GLSLIFY 1
#include <common>

attribute float pIndex;
attribute float aMapIndex;

uniform float pixelRatio;
uniform float width;
uniform float height;
uniform float ulength;
uniform vec2 resolution;
uniform vec2 offset;
uniform vec3 positionOffset;
uniform bool uFlat;
uniform bool keepSize;
uniform float scaleRatio;

#ifdef MVT_USE_VERTEX_SIZE
    attribute vec2 aSize;
#endif

#ifdef MVT_USE_VERTEX_POSITION_OFFSET
    attribute vec3 aPositionOffsets;
#endif

varying vec2 vUv;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() {
    #include <mvt_selective_vertex>
    float setWidth = width;
    float setHeight = height;

    #ifdef MVT_USE_VERTEX_SIZE
        setWidth = aSize.x * scaleRatio;
        setHeight = aSize.y * scaleRatio;
    #endif

    vec2 o = offset * scaleRatio;
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);
    if (uFlat) {
        float hw = setWidth * 0.5;
        float hh = setHeight * 0.5;
        if (keepSize) {
            hw *= pixelSize;
            hh *= pixelSize;
            o *= pixelSize;
        }
        if (pIndex == 1.0) {
            hw = -hw;
        } else if (pIndex == 2.0) {

        } else if (pIndex == 3.0) {
            hh = -hh;
        } else {
            hw = -hw;
            hh = -hh;
        }
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);
    }
    else {
        vec3 setPositionOffset = positionOffset;
        #ifdef MVT_USE_VERTEX_POSITION_OFFSET
            setPositionOffset = aPositionOffsets;
        #endif
        worldPosition.x += setPositionOffset.x;
        worldPosition.y += setPositionOffset.y;
        worldPosition.z += setPositionOffset.z;

        gl_Position = projectionMatrix * viewMatrix * worldPosition;
        float w = gl_Position.w;
        gl_Position /= w;

        float hw = setWidth / resolution.x;
        float hh = setHeight / resolution.y;
        if (!keepSize) {
            hw /= pixelSize;
            hh /= pixelSize;
            o /= pixelSize;
        }

        gl_Position.x += o.x * 2. / resolution.x;
        gl_Position.y -= o.y * 2. / resolution.y;

        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }

        gl_Position *= w;
    }

    vUv = uv;

    #include <logdepthbuf_vertex>
}`, fragmentShader$9 = `#define GLSLIFY 1
#include <common>

uniform float opacity;

uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;
uniform float width;
uniform float height;

varying vec2 vUv;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));
    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);

    if (gl_FragColor.a <= 0.) {
        discard;
    }
    gl_FragColor.a *= clamp(opacity, 0.0, 1.0);
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
    #include <colorspace_fragment>
}`, textureLoader$1 = new TextureLoader(), uniforms$a = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  keepSizeUniforms,
  {
    emissive: { value: [0, 0, 0] },
    isEmissive: { value: !1 },
    width: { value: 12 },
    height: { value: 12 },
    offset: { value: [0, 0] },
    positionOffset: { value: [0, 0, 0] },
    ulength: { value: 1 },
    useCanvasMap: { value: !1 },
    vertexIcons: { value: !1 },
    opacity: { value: 1 },
    map: { value: null },
    useMap: { value: !1 },
    uFlat: { value: !1 },
    keepSize: { value: !0 },
    scaleRatio: { value: 1 }
  }
]);
class LabelMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "LabelMaterial", this.vertexShader = vertexShader$a, this.fragmentShader = fragmentShader$9, this.isLabelMaterial = !0, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$a)), defineMaterialKeepSizeProperties(this), defineMaterialSelectiveProperties(this), defineMaterialAliasProperties(this, [
      ["flat", "uFlat"]
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexBackgroundCanvas", "MVT_USE_VERTEX_SIZE"],
      ["vertexBackgrounds", "MVT_USE_VERTEX_SIZE"],
      ["vertexPositionOffsets", "MVT_USE_VERTEX_POSITION_OFFSET"]
    ]), defineMaterialNormalProperties(this, [
      "width",
      "height",
      "offset",
      "positionOffset",
      "opacity",
      "emissive",
      "isEmissive",
      "scaleRatio"
    ]), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const r = this.mapSrc, s = this.userData[this.urlCacheKey], a = this;
          if (s !== e) {
            if (r && r.dispose(), !e) {
              this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[this.urlCacheKey];
              return;
            }
            textureLoader$1.load(e, function(c) {
              c.wrapS = c.wrapT = ClampToEdgeWrapping, c.colorSpace = SRGBColorSpace, a.uniforms.map.value = c, a.userData[a.urlCacheKey] = e, a.uniforms.useMap.value = !0, a.uniforms.useCanvasMap.value = !1;
            });
          }
        }
      },
      mapTexture: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          if (!e) {
            this.uniforms.map.value = null, this.uniforms.useCanvasMap.value = !1;
            return;
          }
          e.wrapS = e.wrapT = ClampToEdgeWrapping, e.colorSpace = SRGBColorSpace, this.uniforms.map.value = e, this.uniforms.useMap.value = !1, this.uniforms.useCanvasMap.value = !0, delete this.userData[this.urlCacheKey];
        }
      }
    }), this.setValues(i);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
class LabelGeometry extends BufferGeometry {
  constructor(i) {
    super(i), this.parameters = i;
  }
  setData(i) {
    const { vertexBackgrounds: e, vertexBackgroundCanvas: r, vertexPositionOffsets: s } = this.parameters, { aPositions: a, aObjectIndices: c, aUvs: l, pIndices: h, indices: d, aSize: f, aPositionOffsets: p } = i;
    this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("pIndex", new Float32BufferAttribute(h, 1)), this.setAttribute("objectIndex", new Float32BufferAttribute(c, 1)), this.setAttribute("uv", new Float32BufferAttribute(l, 2)), (e || r) && this.setAttribute("aSize", new Float32BufferAttribute(f, 2)), s && this.setAttribute("aPositionOffsets", new Float32BufferAttribute(p, 3)), this.setIndex(d);
  }
}
const _tempVector3$1 = new Vector3$1(), _tempVector4$1 = new Vector4(), _tempMatrix4$1 = new Matrix4();
class TwinLabel extends GeoMesh {
  constructor(e) {
    super(e);
    _(this, "isEventEntitySupported", !0);
    _(this, "isLabel", !0);
    _(this, "geometry");
    _(this, "material");
    _(this, "canvas");
    _(this, "ctx");
    _(this, "texture");
    _(this, "iconUrlHash", /* @__PURE__ */ new Map());
    _(this, "canvasHash", /* @__PURE__ */ new Map());
    _(this, "boxHash", /* @__PURE__ */ new Map());
    _(this, "gap", [2, 2]);
    _(this, "_padding");
    _(this, "_fillStyle");
    _(this, "oldMapTextureRes", {});
    _(this, "_instanceIds", []);
    _(this, "labelHash");
    this.parameters = e, this._padding = [0, 0, 0, 0], this.parameters.padding && (this.padding = this.parameters.padding), this._fillStyle = this.parameters.fillStyle || "#fff", this.labelHash = /* @__PURE__ */ new Map();
    const r = this.canvas = document.createElement("canvas");
    r.width = r.height = 1;
    const s = this.ctx = r.getContext("2d");
    s.textAlign = "start", this.texture = new CanvasTexture(r), this.widthPropName = e.widthPropName || "width", this.heightPropName = e.heightPropName || "height", this.defineMaterialProxyProperties([
      "width",
      "height",
      "offset",
      "transparent",
      "opacity",
      "flat",
      "keepSize",
      "positionOffset"
    ]), this.boxes = [], this.boxSize = e.boxSize || 100, e.labelTest && (document.body.append(r), r.style.cssText = "position: absolute; z-index: 111; top: 10px; left: 10px; background: #fff");
  }
  initObject() {
    const {
      background: e,
      fontSize: r,
      padding: s,
      fillStyle: a,
      vertexVisible: c,
      visiblePropName: l,
      backgroundCanvasPropName: h,
      maxCacheSize: d,
      ...f
    } = this.parameters;
    this.geometry = new LabelGeometry(this.parameters), this.material = new LabelMaterial(f), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  clone() {
    return new this.constructor(this.parameters);
  }
  getDefaultParams() {
    return {
      width: 12,
      height: 12,
      fontSize: 14
    };
  }
  collisionTest(e) {
    return {
      width: this.width,
      height: this.height
    };
  }
  createLabelTexture(e) {
    const {
      backgroundCanvas: r,
      backgroundCanvasPropName: s
    } = e, a = this.labelHash, c = this.iconUrlHash, l = this.canvasHash, h = this.ctx;
    let d;
    this.boxes = [];
    for (let [p, m] of a.entries()) {
      const y = JSON.parse(p), { icon: x, text: v, id: S } = y, E = S ? l.get(p) : c.get(x);
      if (typeof E == "string" || E === void 0)
        continue;
      const b = this.boxes.findIndex((L) => L.key === p);
      if (b >= 0) {
        const L = this.boxes.splice(b, 1);
        this.boxes.unshift(L[0]);
        continue;
      }
      const w = E.width, M = E.height, P = w + this.gap[0], D = M + this.gap[1];
      this.boxes.unshift({
        w: P,
        h: D,
        width: w,
        height: M,
        key: p,
        icon: E,
        text: v
      });
    }
    for (let p = 0; p < this.boxes.length; p++) {
      const m = this.boxes[p];
      this.boxHash.set(m.key, m);
    }
    return createSprite(this.boxes, h, this.canvas, {
      fillStyle: this._fillStyle,
      fontSize: this.parameters.fontSize,
      gap: this.gap,
      padding: this.padding,
      dpr: this.engine.rendering.pixelRatio,
      drawText: !(s || r),
      textAlign: this.parameters.textAlign
    }) ? (this.texture.dispose(), this.texture = new CanvasTexture(this.canvas)) : this.texture.needsUpdate = !0, d = this.texture, d;
  }
  async _updateData() {
    const {
      vertexSizes: e,
      vertexBackgrounds: r,
      vertexBackgroundCanvas: s,
      vertexPositionOffsets: a,
      vertexVisible: c = !1,
      background: l,
      bgPropName: h = "background",
      textPropName: d = "text",
      visiblePropName: f = "visible",
      backgroundCanvas: p,
      backgroundCanvasPropName: m
    } = this.parameters;
    let y = [];
    this._enableCollision && this._collisionData ? y = this._collisionData : y = this.dataSource.userData, y.length > (this.parameters.maxCacheSize || 2e3) && console.warn(`Label\u6570\u91CF\u8D85\u8FC7\u4E86\u6700\u5927\u9650\u5236\uFF0C\u8BF7\u66F4\u65B0maxCacheSize\u53C2\u6570\uFF1B\u5F53\u524D\u6700\u5927\u503C\u4E3A${this.parameters.maxCacheSize || 2e3}`);
    let x = this.labelHash;
    const v = this.iconUrlHash, S = this.canvasHash;
    S.clear(), x.clear();
    let E = x.size, b = x.size, w = [];
    if (p || m)
      for (let U = 0; U < y.length; U++) {
        let z = this.parameters.vertexBackgroundCanvas ? y[U][m] : p;
        const $ = y[U][d], G = JSON.stringify({
          id: y[U].id || y[U].index,
          text: String($)
        });
        z instanceof Promise ? w.push(z.then((j) => {
          S.get(G) === void 0 && S.set(G, j);
        })) : S.get(G) === void 0 && S.set(G, z), x.get(G) === void 0 && (x.set(G, E), E++);
      }
    else {
      for (let U = 0; U < y.length; U++) {
        const z = this.parameters.vertexBackgrounds ? y[U][h] : l, $ = y[U][d], G = JSON.stringify({
          icon: z,
          text: String($)
        });
        v.get(z) === void 0 && v.set(z, z), x.get(G) === void 0 && (x.set(G, E), E++);
      }
      w = Array.from(v.entries()).filter((U) => typeof U[1] == "string").map(([U, z]) => new Promise(($, G) => {
        this.url2canvas(U, (j) => {
          v.set(U, j), $(U);
        });
      }));
    }
    w.length > 0 && await Promise.all(w);
    let M;
    if (b === E && this.oldTexture && (M = this.oldTexture), M || (M = this.createLabelTexture({
      backgroundCanvasPropName: m,
      backgroundCanvas: p
    }), this.oldTexture = M), !M)
      return;
    this.material.mapTexture = M, this.material.uniforms.ulength.value = x.size, this._instanceIds = [];
    const P = [], D = [], L = [], O = [], F = [], k = [], V = [];
    let N = 0;
    for (let U = 0; U < y.length; U++) {
      let z = y[U].position;
      const $ = y[U].index, G = y[U][d], j = y[U][f];
      if (c && j === !1)
        continue;
      this._instanceIds.push(U);
      const Y = p || m ? JSON.stringify({
        id: y[U].id || y[U].index,
        text: String(G)
      }) : JSON.stringify({
        icon: r ? y[U][h] : l,
        text: String(G)
      }), H = this.boxHash.get(Y);
      if (!H)
        continue;
      for (let ee = 0; ee < 4; ee++)
        P.push(...z), D.push(ee), L.push($), a && V.push(...y[U].positionOffset);
      const W = H.x / this.canvas.width, q = (H.x + H.w) / this.canvas.width, Z = (H.y + H.h) / this.canvas.height, X = H.y / this.canvas.height;
      O.push(
        W,
        Z,
        W,
        X,
        q,
        X,
        q,
        Z
      );
      const K = N * 4;
      if (F.push(
        K,
        K + 2,
        K + 1,
        K,
        K + 3,
        K + 2
      ), N++, r || s) {
        let ee = H.width, ie = H.height;
        const { originWidth: re, originHeight: ne } = H.icon;
        ne && re && (ee = re, ie = ne), e && (ee = y[U][this.widthPropName], ie = y[U][this.heightPropName]), k.push(
          ee,
          ie,
          ee,
          ie,
          ee,
          ie,
          ee,
          ie
        );
      }
    }
    this.geometry.setData({
      aPositions: P,
      pIndices: D,
      aObjectIndices: L,
      aUvs: O,
      indices: F,
      aSize: k,
      aPositionOffsets: V
    }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, P), this.needsUpdate = !1, this.engine.requestRender();
  }
  url2canvas(e, r) {
    if (typeof e == "object")
      r(e);
    else {
      let s = new Image();
      s.crossOrigin = "anonymous", s.onload = function() {
        let a = s.width, c = s.height, l = document.createElement("canvas");
        l.width = a, l.height = c, l.getContext("2d").drawImage(s, 0, 0, a, c), r(l);
      }, s.onerror = function() {
        let a = document.createElement("canvas");
        a.width = 20, a.height = 40;
        let c = a.getContext("2d");
        c.fillStyle = "red", c.beginPath(), c.lineTo(0, 0), c.lineTo(20, 0), c.lineTo(10, 40), c.closePath(), c.fill(), r(a);
      }, s.src = e;
    }
  }
  getEntityByIndex(e) {
    const r = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const s = {
      index: e,
      value: r.getDataItem(e),
      itemIndex: r.getDataItemIndex(e),
      pairs: {}
    }, a = r.data;
    for (const c of Object.keys(a))
      s.pairs[c] = a[c][e];
    return s;
  }
  raycast(e, r) {
    const s = this.flat;
    if (!this.visible || s)
      return;
    const a = this.geometry, c = a.getAttribute("position");
    if (!c || !c.array || !c.array.length === 0)
      return;
    const l = a.getAttribute("offset");
    let h = [];
    l && (h = l.array);
    let d = e.camera;
    d || (d = this.engine.camera);
    const f = e.mouse;
    if (!f)
      return;
    const p = this.material.uniforms.resolution.value, m = f.x, y = f.y;
    let x = this.width / p.x, v = this.height / p.y, S = [];
    const E = a.getAttribute("aSize");
    E && (S = E.array);
    let b = [];
    const w = a.getAttribute("aPositionOffsets");
    b = w ? w.array : [];
    let M = 0, P = 0, D = 0, L = 0, O = 0, F = 0;
    _tempMatrix4$1.multiplyMatrices(d.projectionMatrix, d.matrixWorldInverse), _tempMatrix4$1.multiplyMatrices(_tempMatrix4$1, this.matrixWorld);
    const k = c.array;
    let V = 0, N = 0, U = 1;
    this.keepSize || (U = this.material.uniforms.zoomUnits.value);
    for (let z = 0, $ = k.length - 11; z < $; z += 12) {
      const G = this.material.positionOffset || [0, 0, 0];
      if (this.parameters.vertexPositionOffsets && (G[0] = b[z], G[1] = b[z + 1], G[2] = b[z + 2]), _tempVector4$1.set(
        k[z] + G[0],
        k[z + 1] + G[1],
        k[z + 2] + G[2],
        1
      ), _tempVector4$1.applyMatrix4(_tempMatrix4$1), _tempVector4$1.divideScalar(_tempVector4$1.w), this.parameters.vertexOffsets ? (V = z / 12 * 8, O = h[V] || 0, F = h[V + 1] || 0) : (O = this.material.uniforms.offset.value ? this.material.uniforms.offset.value[0] : 0, F = this.material.uniforms.offset.value ? this.material.uniforms.offset.value[1] : 0), _tempVector4$1.x += O * 2 / p.x / U, _tempVector4$1.y -= F * 2 / p.y / U, (this.parameters.vertexSizes || this.parameters.vertexBackgrounds || this.parameters.vertexBackgroundCanvas) && (N = z / 12 * 8, x = S[N] / p.x, v = S[N + 1] / p.y), M = _tempVector4$1.x - x / U, D = _tempVector4$1.x + x / U, P = _tempVector4$1.y - v / U, L = _tempVector4$1.y + v / U, M <= m && D >= m && P <= y && L >= y) {
        _tempVector3$1.set(k[z], k[z + 1], k[z + 2]), _tempVector3$1.applyMatrix4(this.matrixWorld);
        const j = z / 12, H = {
          instanceId: this._instanceIds[j],
          object: this,
          distance: _tempVector3$1.distanceTo(d.position)
        };
        r.push(H);
      }
    }
  }
  set padding(e) {
    e.length === 2 ? this._padding = [e[0], e[1], e[0], e[1]] : e.length === 3 ? this._padding = [e[0], e[1], e[2], e[1]] : e.length >= 4 && (this._padding = [e[0], e[1], e[2], e[3]]);
  }
  get padding() {
    return this._padding;
  }
  onDispose() {
    this.texture && this.texture.dispose(), this.canvas && (this.canvas = null), this.iconUrlHash.clear(), this.labelHash.clear(), this.boxHash.clear();
  }
}
const defaultOptions = {
  minZoom: 0,
  maxZoom: 16,
  radius: 40,
  extent: 512,
  nodeSize: 64,
  log: !1,
  generateId: !1,
  reduce: null,
  map: (o) => o
};
class Supercluster {
  constructor(i) {
    this.options = extend(Object.create(defaultOptions), i), this.trees = new Array(this.options.maxZoom + 1);
  }
  convertDataItemsToGeoJSON(i) {
    return i.map((e) => ({
      type: "Feature",
      properties: e.attributes,
      geometry: {
        type: "Point",
        coordinates: e.coordinates
      }
    }));
  }
  load(i) {
    const { log: e, minZoom: r, maxZoom: s, nodeSize: a } = this.options;
    e && console.time("total time");
    const c = `prepare ${i.length} points`;
    e && console.time(c), this.points = this.convertDataItemsToGeoJSON(i);
    let l = [];
    for (let h = 0; h < this.points.length; h++) {
      const d = this.points[h];
      !Array.isArray(d) && !d.geometry || l.push(createPointCluster(d, h));
    }
    this.trees[s + 1] = new KDBush(l, getX, getY, a, Float32Array), e && console.timeEnd(c);
    for (let h = s; h >= r; h--)
      l = this._cluster(l, h), this.trees[h] = new KDBush(l, getX, getY, a, Float32Array);
    return e && console.timeEnd("total time"), this;
  }
  getClusters(i, e) {
    let r = ((i[0] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, i[1]));
    let a = i[2] === 180 ? 180 : ((i[2] + 180) % 360 + 360) % 360 - 180;
    const c = Math.max(-90, Math.min(90, i[3]));
    if (i[2] - i[0] >= 360)
      r = -180, a = 180;
    else if (r > a) {
      const f = this.getClusters([r, s, 180, c], e), p = this.getClusters([-180, s, a, c], e);
      return f.concat(p);
    }
    const l = this.trees[this._limitZoom(e)], h = l.range(lngX(r), latY(c), lngX(a), latY(s)), d = [];
    for (const f of h) {
      const p = l.points[f];
      d.push(p.numPoints ? getClusterJSON(p) : this.points[p.index]);
    }
    return d;
  }
  getChildren(i) {
    const e = this._getOriginId(i), r = this._getOriginZoom(i), s = "No cluster with the specified id.", a = this.trees[r];
    if (!a)
      throw new Error(s);
    const c = a.points[e];
    if (!c)
      throw new Error(s);
    const l = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), h = a.within(c.x, c.y, l), d = [];
    for (const f of h) {
      const p = a.points[f];
      p.parentId === i && d.push(p.numPoints ? getClusterJSON(p) : this.points[p.index]);
    }
    if (d.length === 0)
      throw new Error(s);
    return d;
  }
  getLeaves(i, e, r) {
    e = e || 10, r = r || 0;
    const s = [];
    return this._appendLeaves(s, i, e, r, 0), s;
  }
  getTile(i, e, r) {
    const s = this.trees[this._limitZoom(i)], a = Math.pow(2, i), { extent: c, radius: l } = this.options, h = l / c, d = (r - h) / a, f = (r + 1 + h) / a, p = {
      features: []
    };
    return this._addTileFeatures(
      s.range((e - h) / a, d, (e + 1 + h) / a, f),
      s.points,
      e,
      r,
      a,
      p
    ), e === 0 && this._addTileFeatures(
      s.range(1 - h / a, d, 1, f),
      s.points,
      a,
      r,
      a,
      p
    ), e === a - 1 && this._addTileFeatures(
      s.range(0, d, h / a, f),
      s.points,
      -1,
      r,
      a,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(i) {
    let e = this._getOriginZoom(i) - 1;
    for (; e <= this.options.maxZoom; ) {
      const r = this.getChildren(i);
      if (e++, r.length !== 1)
        break;
      i = r[0].properties.cluster_id;
    }
    return e;
  }
  _appendLeaves(i, e, r, s, a) {
    const c = this.getChildren(e);
    for (const l of c) {
      const h = l.properties;
      if (h && h.cluster ? a + h.point_count <= s ? a += h.point_count : a = this._appendLeaves(i, h.cluster_id, r, s, a) : a < s ? a++ : i.push(l), i.length === r)
        break;
    }
    return a;
  }
  _addTileFeatures(i, e, r, s, a, c) {
    for (const l of i) {
      const h = e[l], d = h.numPoints, f = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (h.x * a - r)),
          Math.round(this.options.extent * (h.y * a - s))
        ]],
        tags: d ? getClusterProperties(h) : this.points[h.index].properties
      };
      let p;
      d ? p = h.id : this.options.generateId ? p = h.index : this.points[h.index].id && (p = this.points[h.index].id), p !== void 0 && (f.id = p), c.features.push(f);
    }
  }
  _limitZoom(i) {
    return Math.max(this.options.minZoom, Math.min(i, this.options.maxZoom + 1));
  }
  _cluster(i, e) {
    const r = [], { radius: s, extent: a, reduce: c } = this.options, l = s / (a * Math.pow(2, e));
    for (let h = 0; h < i.length; h++) {
      const d = i[h];
      if (d.zoom <= e)
        continue;
      d.zoom = e;
      const f = this.trees[e + 1], p = f.within(d.x, d.y, l);
      let m = d.numPoints || 1, y = d.x * m, x = d.y * m, v = c && m > 1 ? this._map(d, !0) : null;
      const S = (h << 5) + (e + 1) + this.points.length;
      for (const E of p) {
        const b = f.points[E];
        if (b.zoom <= e)
          continue;
        b.zoom = e;
        const w = b.numPoints || 1;
        y += b.x * w, x += b.y * w, m += w, b.parentId = S, c && (v || (v = this._map(d, !0)), c(v, this._map(b)));
      }
      m === 1 ? r.push(d) : (d.parentId = S, r.push(createCluster(y / m, x / m, S, m, v)));
    }
    return r;
  }
  _getOriginId(i) {
    return i - this.points.length >> 5;
  }
  _getOriginZoom(i) {
    return (i - this.points.length) % 32;
  }
  _map(i, e) {
    if (i.numPoints)
      return e ? extend({}, i.properties) : i.properties;
    const r = this.points[i.index].properties, s = this.options.map(r);
    return e && s === r ? extend({}, s) : s;
  }
}
function createCluster(o, i, e, r, s) {
  return {
    x: o,
    y: i,
    zoom: 1 / 0,
    id: e,
    parentId: -1,
    numPoints: r,
    properties: s
  };
}
function createPointCluster(o, i) {
  const [e, r] = Array.isArray(o) ? o : o.geometry.coordinates;
  return {
    x: lngX(e),
    y: latY(r),
    zoom: 1 / 0,
    index: i,
    parentId: -1
  };
}
function getClusterJSON(o) {
  return {
    type: "Feature",
    id: o.id,
    properties: getClusterProperties(o),
    geometry: {
      type: "Point",
      coordinates: [xLng(o.x), yLat(o.y)]
    }
  };
}
function getClusterProperties(o) {
  const i = o.numPoints, e = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? `${Math.round(i / 100) / 10}k` : i;
  return extend(extend({}, o.properties), {
    cluster: !0,
    cluster_id: o.id,
    point_count: i,
    point_count_abbreviated: e
  });
}
function lngX(o) {
  return o / 360 + 0.5;
}
function latY(o) {
  const i = Math.sin(o * Math.PI / 180), e = 0.5 - 0.25 * Math.log((1 + i) / (1 - i)) / Math.PI;
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function xLng(o) {
  return (o - 0.5) * 360;
}
function yLat(o) {
  const i = (180 - o * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(i)) / Math.PI - 90;
}
function extend(o, i) {
  for (const e in i)
    o[e] = i[e];
  return o;
}
function getX(o) {
  return o.x;
}
function getY(o) {
  return o.y;
}
class PointGroup extends GeoObject {
  constructor() {
    super(...arguments);
    _(this, "isEventEntitySupported", !0);
  }
  addComponent(e) {
    if (!e.isGeoObject) {
      console.warn("Only GeoObject can be added");
      return;
    }
    e.__eventProxyByParent = !0, this.add(e), e.afterAddToEngine(this.engine);
    const r = this.getChildDataSource(e);
    return r && (e.dataSource = r), this.needsUpdate = !0, e;
  }
  removeComponent(e) {
    this.remove(e), e.__eventProxyByParent = !1, e.dataSource = null, e.beforeRemoveFromEngine(this.engine), this.needsUpdate = !0;
  }
  getChildDataSource(e) {
    return this.dataSource;
  }
  onBeforeScenePrepareRender(e, r, s, a) {
    super.onBeforeScenePrepareRender && super.onBeforeScenePrepareRender(e, r, s, a);
    for (const c of this.children)
      c.onBeforeScenePrepareRender && c.onBeforeScenePrepareRender(e, r, s, a);
  }
  onBeforeSceneRender(e, r, s, a) {
    super.onBeforeSceneRender && super.onBeforeSceneRender(e, r, s, a);
    for (const c of this.children)
      c.onBeforeSceneRender && c.onBeforeSceneRender(e, r, s, a);
  }
  setDataSource(e) {
    super.setDataSource(e);
    for (const r of this.children)
      r.setDataSource(this.getChildDataSource(r));
  }
  _updateData() {
    for (const e of this.children)
      e.needsUpdate && e._updateData();
    this.needsUpdate = !1;
  }
  dispose() {
    for (const e of this.children)
      this.removeComponent(e);
  }
}
const defaultIconOptions = {
  width: 30,
  height: 30,
  mapSrc: "https://bj.bcebos.com/v1/yanpan-screen-attachment/resources/image/yinlianPOC/djiudian.png"
}, defaultTextOptions = {
  fillStyle: "#ccc",
  fontSize: 16,
  flat: !1
}, defaultClusterOptions = {
  maxZoom: 18,
  minZoom: 5,
  radius: 50
};
class ClusterPoint extends PointGroup {
  constructor(e = {}) {
    super(e);
    _(this, "_ready");
    _(this, "_cluster");
    _(this, "_clusterDataSource");
    _(this, "_icon");
    _(this, "_label");
    _(this, "_minUpdateInterval");
    _(this, "isEventEntitySupported", !0);
    _(this, "_minUpdateInterval", 300);
    _(this, "_lastUpdateTime", 0);
    _(this, "_updateTimeoutHandler", null);
    _(this, "_clusterData", []);
    _(this, "_updateRenderingData", () => {
      const { map: e } = this.engine, r = e.getBoundingBox(), s = Math.round(e.getZoom()), a = this._cluster.getClusters([...r.min, ...r.max], s);
      this._clusterData = a, this._clusterDataSource.objects.length > 0 && this._clusterDataSource.setData(a), this._clusterDataSource.update();
      for (const c of this.children)
        c._updateData();
    });
    this.parameters = e, this._ready = !1, this._cluster = new Supercluster(Object.assign({}, defaultClusterOptions, e.cluster)), this._cluster.load([]), (this._clusterDataSource = new GeoJSONDataSource()).defineAttribute("size").defineAttribute("icon").defineAttribute("text", (s) => (s && s.cluster ? s.point_count : 0) + "");
  }
  initObject() {
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e);
    const r = this.parameters;
    r.icon && (this._icon = this.addComponent(new Icon(Object.assign({}, defaultIconOptions, r.icon)))), r.label && (this._label = this.addComponent(new TwinLabel(Object.assign({}, defaultTextOptions, r.label)))), this._ready = !0;
  }
  _updateData() {
    let e = this.dataSource.data;
    this.cachedData = e, this._cluster.load(this.dataSource.dataItems), this.needsUpdate = !1;
  }
  onBeforeScenePrepareRender(e, r, s, a) {
    if (!this._ready || !this.dataSource)
      return;
    this._needsUpdate && this._updateRenderingData(), clearTimeout(this._updateTimeoutHandler);
    const c = a.time;
    if (c - this._lastUpdateTime > this._minUpdateInterval) {
      this._updateRenderingData(), this._lastUpdateTime = c;
      return;
    }
    this._updateTimeoutHandler = setTimeout(() => {
      this._updateRenderingData(), e.requestRender();
    }, this._minUpdateInterval), super.onBeforeScenePrepareRender(e, r, s, a);
  }
  getChildDataSource() {
    return this._clusterDataSource;
  }
  getEntityByIndex(e) {
    const r = this._clusterDataSource;
    if (!r)
      return;
    const s = {
      index: e,
      value: r.getDataItem(e),
      itemIndex: r.getDataItemIndex(e),
      pairs: {}
    }, a = r.data;
    for (const c of Object.keys(a))
      s.pairs[c] = a[c][e];
    return s;
  }
  get minUpdateInterval() {
    return this._minUpdateInterval;
  }
  set minUpdateInterval(e) {
    e < 16 && (e = 16), this._minUpdateInterval = e;
  }
  get clusterDataSource() {
    return this._clusterDataSource;
  }
  get clusterData() {
    return this._clusterData;
  }
}
const vertexShader$9 = `#define GLSLIFY 1
#include <common>

uniform float height;
#if defined(USE_SIZE3)
    uniform vec3 size3;
#else
    uniform float size;
#endif
#ifdef IS_GLOBE
    attribute mat4 ecefMatrix;
#endif

uniform float elapsedTime;
attribute float instancedRandomFactor;

#if defined(VERTEX_COLOR4)
    attribute vec4 color;
    varying vec4 vColor;
#elif defined(VERTEX_COLOR3)
    attribute vec3 color;
    varying vec3 vColor;
#endif

#if defined(MVT_USE_VERTEX_COLOR)
    varying vec3 vInstanceColor;
#endif

#ifdef USE_MAP
    varying vec2 vUv;
#endif

#include <mvt_animation_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

#define MVT_KEEP_PROJECTION_POSITION

#include <logdepthbuf_pars_vertex>
vec3 transformPosition(vec3 p, mat4 im) {
    vec3 transformed = vec3(p);

    #include <mvt_animation_vertex>

    #ifndef MVT_USE_VERTEX_SIZE
        #if defined(USE_SIZE3)
            transformed *= size3;
        #else
            transformed *= size;
        #endif
    #endif
    transformed.z += height;

    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));
    float pixelSize = getPixelSize(vec3(modelMatrix * im * vec4(0., 0., 0., 1.)));
    if (keepSize) {
        transformed *= pixelSize;
    }

    return transformed;
}
void main() {
    #ifdef USE_MAP
        vUv = uv;
    #endif
    
    #if defined(VERTEX_COLOR4)
        vColor = vec4(color);
    #elif defined(VERTEX_COLOR3)
        vColor = vec3(color);
    #endif

    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)
        vInstanceColor = instanceColor.xyz;
    #endif

    #include <mvt_selective_vertex>
    vec4 mvp_projectPosition;

    mat4 currentInstanceMatrix = instanceMatrix;
    #ifdef IS_GLOBE
        currentInstanceMatrix = instanceMatrix * ecefMatrix;
    #endif
    vec3 transformed = transformPosition(position, currentInstanceMatrix);
    
    gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(transformed, 1.0);
    
    mvp_projectPosition = gl_Position;

    #include <logdepthbuf_vertex>
}`, fragmentShader$8 = `#define GLSLIFY 1
#include <common>
#include <map_pars_fragment>

#if defined(MVT_USE_VERTEX_COLOR)
    varying vec3 vInstanceColor;
#endif

#if defined(VERTEX_COLOR4)
    varying vec4 vColor;
#elif defined(VERTEX_COLOR3)
    varying vec3 vColor;
#else
    uniform vec3 color;
#endif

uniform float opacity;
uniform vec3 emissive;

#ifdef USE_MAP
    varying vec2 vUv;
#endif

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#define MVT_EMISSIVE_SHADER
void main() {

    #include <logdepthbuf_fragment> 

    #if defined(VERTEX_COLOR4)
        gl_FragColor = vColor;
    #elif defined(VERTEX_COLOR3)
        gl_FragColor = vec4(vColor, 1.0);
    #elif defined(USE_MAP)
        gl_FragColor = texture2D( map, vUv );
    #else
        gl_FragColor = vec4(color, 1.0);
    #endif

    #if defined(MVT_USE_VERTEX_COLOR)
        gl_FragColor.rgb *= vInstanceColor;
    #endif
      
    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif
    vec4 out_emissive = vec4(emissive, 1.0);
    #include <mvt_selective_fragment>

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`, uniforms$9 = UniformsUtils.merge([
  {
    emissive: {
      value: [0, 0, 0]
    },
    isEmissive: {
      value: !1
    },
    map: {
      value: null
    }
  }
]);
class InstancedEffectModelMaterial extends InstancedEffectPointMaterial {
  constructor(i) {
    super(), this.name = "InstancedEffectModelMaterial", this.isInstancedEffectModelMaterial = !0, this.vertexShader = vertexShader$9, this.fragmentShader = fragmentShader$8, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$9)), this.defines = {}, defineMaterialNormalProperties(this, [
      "emissive",
      "isEmissive"
    ]), defineMaterialBoolDefineProperties(this, [
      ["isGlobe", "IS_GLOBE"],
      ["useVertexColors", "MVT_USE_VERTEX_COLOR"],
      ["useVertexSizes", "MVT_USE_VERTEX_SIZE"]
    ]), Object.defineProperty(this, "map", {
      get: function() {
        return this.uniforms.map.value;
      },
      set: function(e) {
        this.uniforms.map.value = e;
      }
    }), this.setValues(i);
  }
  get vertexColors4() {
    return this.defines.VERTEX_COLOR4 = !0;
  }
  set vertexColors4(i) {
    i !== this.defines.VERTEX_COLOR4 && (this.defines.VERTEX_COLOR4 = !!i, this.needsUpdate = !0);
  }
  get vertexColors3() {
    return this.defines.VERTEX_COLOR3 = !0;
  }
  set vertexColors3(i) {
    i !== this.defines.VERTEX_COLOR3 && (this.defines.VERTEX_COLOR3 = !!i, this.needsUpdate = !0);
  }
}
const defaultParameters = {
  normalize: !0,
  rotateToZUp: !0,
  keepSize: !0
};
class EffectModelPoint extends GeoObject {
  constructor(e) {
    super();
    _(this, "_model");
    _(this, "_normalize");
    _(this, "_rotateToZUp");
    _(this, "_keepSize");
    _(this, "_size");
    _(this, "_size3");
    _(this, "_useSize3");
    _(this, "_height");
    _(this, "_animationRotate");
    _(this, "_animationRotatePeriod");
    _(this, "_animationJump");
    _(this, "_animationJumpPeriod");
    _(this, "_animationJumpHeight");
    _(this, "isEventEntitySupported", !0);
    _(this, "_model", null);
    _(this, "_normalize", !0);
    _(this, "_rotateToZUp", !0);
    _(this, "_keepSize", !0);
    _(this, "_size", 1);
    _(this, "_size3", [1, 1, 1]);
    _(this, "_useSize3", !1);
    _(this, "_height", 0);
    _(this, "_animationRotate", !1);
    _(this, "_animationRotatePeriod", 3e3);
    _(this, "_animationJump", !1);
    _(this, "_animationJumpPeriod", 3e3);
    _(this, "_animationJumpHeight", 30);
    _(this, "_updateModel", () => {
      this._cleanOldMesh();
      const e = parseScene(this._model, this._normalize, this._rotateToZUp), { normalize: r, rotateToZUp: s, ...a } = this.parameters;
      for (const c of e) {
        const l = c.material;
        let h = new InstancedEffectModelMaterial();
        h.isGlobe = this.engine.map.isGlobe, h.useVertexColors = a.vertexColors, h.useVertexSizes = a.vertexSizes, h.setCommonUniforms(this.engine.rendering.uniforms), h.transparent = l.transparent, h.opacity = l.opacity, h.side = l.side, h.depthWrite = l.depthWrite, h.depthTest = l.depthTest, h.depthFunc = l.depthFunc, h.blendDst = l.blendDst, h.blendDstAlpha = l.blendDstAlpha, h.blendEquation = l.blendEquation, h.blendEquationAlpha = l.blendEquationAlpha, h.blending = l.blending, h.blendSrc = l.blendSrc, h.blendSrcAlpha = l.blendSrcAlpha, h.premultipliedAlpha = l.premultipliedAlpha, h.color = l.color, h.colorWrite = l.colorWrite, h.emissive = l.emissive, h.map = l.map, h.keepSize = this._keepSize, h.size = this._size, h.size3 = this._size3, h.useSize3 = this._useSize3, h.height = this._height, h.animationRotate = this._animationRotate, h.animationRotatePeriod = this._animationRotatePeriod, h.animationJump = this._animationJump, h.animationJumpPeriod = this._animationJumpPeriod, h.animationJumpHeight = this._animationJumpHeight;
        const d = c.geometry, f = d.getAttribute("color");
        f && (f.itemSize === 4 ? h.vertexColors4 = !0 : f.itemSize === 3 && (h.vertexColors3 = !0));
        const p = new GeoInstancedPointMesh(d, h, this.parameters);
        p.engine = this.engine, p.dataAutoUpdate = !1, p.__eventProxyByParent = !0, this.dataSource && (p.dataSource = this.dataSource), this.add(p);
      }
      this.needsUpdate = !0;
    });
    _(this, "_cleanOldMesh", () => {
      const e = this.children;
      for (let r = e.length - 1; r >= 0; r--) {
        const s = e[r];
        this.remove(s), s.geometry && s.geometry.dispose(), s.material && (s.material.map && s.material.map.dispose(), s.material.dispose());
      }
    });
    _(this, "_defineChildrenMaterialProperty", (e) => {
      Object.defineProperty(this, e, {
        get: function() {
          return this["_" + e];
        },
        set: function(r) {
          this["_" + e] = r;
          for (const s of this.children)
            s.material[e] = r;
        }
      });
    });
    e = Object.assign({}, defaultParameters, e), this._normalize = e.normalize, this._rotateToZUp = e.rotateToZUp, this.parameters = e, [
      "size",
      "size3",
      "useSize3",
      "height",
      "keepSize",
      "animationRotate",
      "animationRotatePeriod",
      "animationJump",
      "animationJumpPeriod",
      "animationJumpHeight"
    ].forEach((r) => {
      e[r] !== void 0 && (this["_" + r] = e[r]), this._defineChildrenMaterialProperty(r);
    });
  }
  initObject() {
    this._initDefaultModel();
  }
  _initDefaultModel() {
    if (!this._model)
      if (EffectModelPoint.defaultModel)
        this._model = EffectModelPoint.defaultModel.clone(!0), this._updateModel();
      else if (EffectModelPoint.defaultModelLoading)
        EffectModelPoint.defaultModelLoading.then((e) => {
          this._model || (this._model = e.clone(!0), this._updateModel());
        });
      else {
        const e = gltfLoader.loadAsync(getAssetUrl("assets/models/effect/diamond.glb")).then((r) => {
          const s = r.scene;
          return EffectModelPoint.defaultModel = s, s;
        });
        EffectModelPoint.defaultModelLoading = e, e.then((r) => {
          this._model || (this._model = r.clone(!0), this._updateModel());
        }).catch((r) => {
          console.error("Failed to load default model:", r);
        });
      }
  }
  _updateData() {
    const e = this.dataSource;
    for (const r of this.children)
      r.dataSource = e, r._updateData();
    this.needsUpdate = !1;
  }
  onDispose() {
    this._cleanOldMesh();
  }
  set model(e) {
    e !== this._model && (this._model = e, this._updateModel());
  }
  get model() {
    return this._model;
  }
}
const vertexShader$8 = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif

#ifndef MVT_USE_VERTEX_SIZE
    uniform float size;
#endif

#ifdef IS_GLOBE
    attribute mat4 ecefMatrix;
#endif

varying vec2 vPosition;
varying float vScale;

#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() {

    #include <mvt_selective_vertex>
    vPosition = position.xy;

    vec3 transformed = vec3(position);
    #ifdef MVT_USE_VERTEX_SIZE
        vScale = instanceMatrix[0][0];
    #else
        vScale = size;
        transformed *= size;
    #endif

    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));
    float pixelSize = getPixelSize(vec3(modelMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));
    if (keepSize) {
        transformed *= pixelSize;
    }

    #ifdef IS_GLOBE
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * ecefMatrix * vec4(transformed, 1.0);
    #else
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
    #endif
    #include <logdepthbuf_vertex>

    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)
        vColor.xyz = instanceColor.xyz;
        vColor.a = 1.0;
    #endif
}`, fragmentShader$7 = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif
uniform vec3 borderColor;
uniform float opacity;
uniform float borderOpacity;
uniform float fillOpacity;
uniform float radius;
uniform float borderWidth;

varying vec2 vPosition;
varying float vScale;

#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {
    float dis = distance(vPosition, vec2(0, 0));

    // \u7528\u6765\u4FDD\u6301\u8FB9\u6846\u7684\u5BBD\u5EA6\u4E0D\u4F1A\u968F\u7740\u7F29\u653E\u800C\u53D8\u5316
    float radius2 = radius - (borderWidth / vScale) * radius;

    // \u7528\u4E8E\u6297\u952F\u9F7F
    float blur = 0.001;
    float pct = (1.0 - smoothstep(radius - blur, radius + blur, dis));
    vec4 border = vec4(borderColor, borderOpacity);
    #ifdef MVT_USE_VERTEX_COLOR
        vec4 currentColor = mix(vec4(vColor.rgb, fillOpacity), border, smoothstep( radius2 - blur,radius2 + blur, dis));
    #else
        vec4 currentColor = mix(vec4(color, fillOpacity), border, smoothstep( radius2 - blur,radius2 + blur, dis));
    #endif

    // \u8BBE\u7F6E\u7684\u81EA\u8EAB\u989C\u8272\u7684\u900F\u660E\u5EA6\u4F18\u5148\u7EA7\u9AD8\u4E8E\u8BBE\u7F6E\u7684opacity\u4F18\u5148\u7EA7
    gl_FragColor = vec4(currentColor.rgb, pct * currentColor.a);
    if (gl_FragColor.a < 0.001) {
        discard;
    }
    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment>
    #include <colorspace_fragment>
}`, fragmentShaderGradient = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif
uniform float radius;
uniform float opacity;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }
    vec4 fillColor;
    #ifdef MVT_USE_VERTEX_COLOR
        fillColor = vColor;
    #else
        fillColor = vec4(color, 1.0);
    #endif
    
    fillColor.a = smoothstep(0.0, 1.0, pow(d / radius, 2.0));
    // \u8FB9\u7F18\u6297\u952F\u9F7F
    if(d > -0.99 * radius) {
        fillColor.a *= 1.0 - smoothstep(0.99, 1.0, d / radius); 
    }
    fillColor.a *= opacity;
    gl_FragColor = fillColor;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment>   
    #include <colorspace_fragment>
}`;
let uniforms$8 = UniformsUtils.merge([
  emissiveUniforms,
  {
    color: { value: [1, 0.5, 0] },
    borderColor: { value: [0, 1, 0] },
    borderOpacity: { value: 1 },
    fillOpacity: { value: 1 },
    opacity: { value: 1 },
    radius: { value: 0.5 },
    borderWidth: { value: 1 },
    isEmissive: { value: !1 }
  }
]);
class InstancedCircleMaterial extends InstancedEffectPointMaterial {
  constructor(e) {
    super();
    _(this, "name", "CircleMaterial");
    _(this, "isCircleMaterial", !0);
    this.depthTest = !1, this.depthWrite = !1, e.vertexSizes || (uniforms$8 = UniformsUtils.merge([
      uniforms$8,
      {
        size: { value: 100 }
      }
    ])), Object.assign(this.uniforms, UniformsUtils.clone(uniforms$8)), defineMaterialNormalProperties(this, [
      "borderWidth",
      "borderOpacity",
      "fillOpacity",
      "isEmissive"
    ]), defineMaterialColorProperties(this, [
      "borderColor"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexSizes", "MVT_USE_VERTEX_SIZE"],
      ["isGlobe", "IS_GLOBE"]
    ]), defineMaterialEmissiveProperties(this), this.vertexShader = vertexShader$8, e.type === "Gradient" ? this.fragmentShader = fragmentShaderGradient : this.fragmentShader = fragmentShader$7, this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(e);
  }
}
class Circle extends GeoInstancedPointMesh {
  constructor(e) {
    super(e);
    _(this, "geometry");
    _(this, "material");
    _(this, "color");
    _(this, "size");
    _(this, "opacity");
    _(this, "type");
    _(this, "borderColor");
    _(this, "borderWidth");
    _(this, "borderOpacity");
    _(this, "fillOpacity");
    this.parameters = e, this.defineMaterialProxyProperties([
      "color",
      "size",
      "size3",
      "opacity",
      "borderWidth",
      "borderColor",
      "borderOpacity",
      "fillOpacity",
      "radius",
      "keepSize",
      "transparent"
    ]);
  }
  initObject() {
    const e = this.engine.map.isGlobe;
    this.geometry = new InstancedPlaneBufferGeometry(), this.material = new InstancedCircleMaterial(this.parameters), this.material.isGlobe = e, this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  collisionTest(e) {
    let r = 0;
    return this.material.keepSize && (this.parameters.vertexSizes && e.size ? r = e.size : r = this.size), {
      width: r,
      height: r
    };
  }
}
class BasePillarGeometry extends BufferGeometry {
  constructor(e) {
    var r, s, a, c, l, h;
    super(e);
    _(this, "_needsUpdate", !1);
    _(this, "setModelData", () => {
      this._needsUpdate = !0, this.updateGeometry();
    });
    this.parameters = {
      ...e,
      radiusTop: (s = (r = e.radiusTop) != null ? r : e.radius) != null ? s : 6,
      radiusBottom: (c = (a = e.radiusBottom) != null ? a : e.radius) != null ? c : 6,
      height: (l = e.height) != null ? l : 1,
      openEnded: defaultValue$1(e.openEnded, !0),
      color: (h = e.color) != null ? h : [80, 20, 170, 0.8]
    }, this.parameters.radialSegments = e.radialSegments ? Math.floor(e.radialSegments) : 4, this.parameters.heightSegments = e.heightSegments ? Math.floor(e.heightSegments) : 1, this.setModelData();
  }
  updateGeometry() {
    const e = [], r = [], s = [], a = [], c = [];
    let l = {
      index: 0,
      indexArray: [],
      halfHeight: 0,
      groupStart: 0
    };
    this.generateTorso(e, r, s, a, c, l), this.parameters.radiusTop > 0 && this.generateCap(!0, e, r, s, a, c, l), this.parameters.openEnded === !1 && this.parameters.radiusBottom > 0 && this.generateCap(!1, e, r, s, a, c, l), this.addCustomGeometry(e, r, s, a, c, l), this.setIndex(e), this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("normal", new Float32BufferAttribute(s, 3)), this.setAttribute("uv", new Float32BufferAttribute(a, 2)), this.addCustomAttribute(c), this._needsUpdate = !1;
  }
  addCustomGeometry() {
  }
  addCustomAttribute() {
  }
  generateCap(e, r, s, a, c, l, h) {
  }
  generateTorso(e, r, s, a, c, l) {
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
}
class PillarGeometry extends BasePillarGeometry {
  constructor(i) {
    i.shape = defaultValue$1(i.shape, "pillar"), super(i), this.type = "PillarGeometry";
  }
  isCone() {
    return this.parameters.shape === "cone";
  }
  addRadiusFunc(i) {
    return 1 - Math.sqrt(i);
  }
  generateTorso(i, e, r, s, a, c) {
    const l = new Vector3$1(), h = new Vector3$1();
    let d = 0;
    for (let f = 0; f <= this.parameters.heightSegments; f++) {
      const p = [], m = f / this.parameters.heightSegments;
      let y;
      this.isCone() ? (y = this.addRadiusFunc(m), this.parameters.vertexSizes || (y *= this.parameters.size)) : y = (1 - m) * this.parameters.radiusBottom + m * this.parameters.radiusTop;
      for (let x = 0; x <= this.parameters.radialSegments; x++) {
        const v = x / this.parameters.radialSegments, S = v * 2 * Math.PI, E = Math.sin(S), b = Math.cos(S);
        if (l.x = y * E, l.y = y * b, l.z = this.parameters.vertexHeights ? m : m * this.parameters.height, e.push(l.x, l.y, l.z), this.isCone()) {
          const w = this.parameters.radiusBottom / this.parameters.height;
          h.set(E, b, w).normalize();
        } else {
          const w = (this.parameters.radiusBottom - this.parameters.radiusTop) / this.parameters.height;
          h.set(E, b, w).normalize();
        }
        r.push(h.x, h.y, h.z), s.push(v, m), p.push(c.index++);
      }
      c.indexArray.push(p);
    }
    for (let f = 0; f < this.parameters.radialSegments; f++)
      for (let p = 0; p < this.parameters.heightSegments; p++) {
        const m = c.indexArray[p][f], y = c.indexArray[p + 1][f], x = c.indexArray[p + 1][f + 1], v = c.indexArray[p][f + 1];
        i.push(m, y, v), i.push(y, x, v), d += 6;
      }
    this.addGroup(c.groupStart, d, 0), c.groupStart += d;
  }
  generateCap(i, e, r, s, a, c, l) {
    if (this.isCone() && i)
      return;
    const h = l.index, d = new Vector3$1();
    let f = 0;
    const p = this.isCone() ? this.parameters.vertexSizes ? 1 : this.parameters.size : i ? this.parameters.radiusTop : this.parameters.radiusBottom, m = i ? 1 : 0, y = i ? 1 : -1;
    for (let v = 1; v <= this.parameters.radialSegments; v++) {
      const S = this.parameters.vertexHeights ? m : m * this.parameters.height;
      r.push(0, 0, S), s.push(0, 0, y), a.push(0.5, m), l.index++;
    }
    const x = l.index;
    for (let v = 0; v <= this.parameters.radialSegments; v++) {
      const E = v / this.parameters.radialSegments * 2 * Math.PI, b = Math.cos(E), w = Math.sin(E);
      d.x = p * w, d.y = p * b, d.z = this.parameters.vertexHeights ? m : m * this.parameters.height, r.push(d.x, d.y, d.z), s.push(0, 0, y), a.push(0.5, m), l.index++;
    }
    for (let v = 0; v < this.parameters.radialSegments; v++) {
      const S = h + v, E = x + v;
      i ? e.push(E + 1, E, S) : e.push(E, E + 1, S), f += 3;
    }
    this.addGroup(l.groupStart, f, i ? 1 : 2), l.groupStart += f;
  }
  generateTopSphere(i, e, r, s, a, c) {
    this.parameters.sphereIndex = c.index;
  }
  addCustomGeometry(i, e, r, s, a, c) {
    this.generateTopSphere(i, e, r, s, a, c);
  }
}
const vertexShader$7 = `#define GLSLIFY 1
#include <common>

uniform float maxHeight;
uniform bool heatmap;
varying vec2 vUv;

#ifdef IS_GLOBE
    attribute mat4 ecefMatrix;
#endif

#include <logdepthbuf_pars_vertex>
void main() {

    #ifdef IS_GLOBE
        mat4 adjustedInstanceMatrix = instanceMatrix;
        float height = adjustedInstanceMatrix[2][2];
        adjustedInstanceMatrix[2][2] = 1.0;
        vec4 transformed = vec4(position.x, position.y, position.z * height, 1.0);
        gl_Position = projectionMatrix * modelViewMatrix * adjustedInstanceMatrix * ecefMatrix * transformed;
    #else
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);
    #endif

    #ifdef MVT_USE_VERTEX_HEIGHT
        float instanceHeight = instanceMatrix[2][2];
        if (heatmap) {
            vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));
        }
        else {
            vUv = vec2(uv.x, uv.y);
        }
    #else
        vUv = uv;
    #endif

    #include <logdepthbuf_vertex>
}`, fragmentShaderPillar = `#define GLSLIFY 1
#include <common>

uniform sampler2D gradientMap;
uniform float opacity;

varying vec2 vUv;

#include <logdepthbuf_pars_fragment>
void main() {
    gl_FragColor = texture2D(gradientMap, vUv.yx);
    gl_FragColor.a *= opacity;

    #include <logdepthbuf_fragment>
    #include <colorspace_fragment>
}`, fragmentShaderCone = `#define GLSLIFY 1
#include <common>

uniform sampler2D gradientMap;
uniform float opacity;

varying vec2 vUv;

#include <logdepthbuf_pars_fragment>
void main() {
    gl_FragColor = texture2D(gradientMap, vUv.yx);
    gl_FragColor.a *= opacity;

    #include <logdepthbuf_fragment>
    #include <colorspace_fragment>
}`, DEFAULT_GRADIENT = {
  0: "rgba(0,0,255,1)",
  0.3: "rgba(0,255,0,1)",
  0.6: "rgba(255,255,0,1)",
  1: "rgba(255,0,0,1)"
}, DEFAULT_BAND = [
  "rgba(0,0,255,1)",
  "rgba(0,255,0,1)",
  "rgba(255,255,0,1)",
  "rgba(255,0,0,1)"
];
function createDefaultGradientTexture(o = 64, i = 2) {
  return createGradientTexture(DEFAULT_GRADIENT, o, i);
}
function createGradientTexture(o = {}, i = 64, e = 2) {
  const r = document.createElement("canvas");
  r.width = i, r.height = e;
  const s = r.getContext("2d"), a = s.createLinearGradient(0, 0, i, 0), c = Object.keys(o).map((l) => parseFloat(l)).filter((l) => !isNaN(l) && l >= 0 && l <= 1).sort((l, h) => l - h);
  if (c.length === 0)
    return console.warn("No valid gradient stops provided. Skipping texture creation."), new CanvasTexture(r);
  for (const l of c)
    a.addColorStop(l, o[l]);
  return s.fillStyle = a, s.fillRect(0, 0, i, e), new CanvasTexture(r);
}
function updateGradientTexture(o, i, e = 64, r = 2) {
  if (!o || !i || Object.prototype.toString.call(i) !== "[object Object]")
    return;
  const a = o.image.getContext("2d");
  a.clearRect(0, 0, e, r);
  const c = a.createLinearGradient(0, 0, e, 0);
  for (const l in i)
    Object.hasOwnProperty.call(i, l) && c.addColorStop(parseFloat(l), i[l]);
  a.fillStyle = c, a.fillRect(0, 0, e, r), o.needsUpdate = !0;
}
function createBandTexture(o = DEFAULT_BAND, i = 64, e = 2) {
  const r = document.createElement("canvas");
  r.width = i, r.height = e;
  const s = r.getContext("2d");
  s.imageSmoothingEnabled = !1;
  const a = o.length, c = Math.floor(i / a);
  for (let l = 0; l < a; l++) {
    s.fillStyle = o[l];
    const h = l * c, d = l === a - 1 ? i - h : c;
    s.fillRect(h, 0, d, e);
  }
  return new CanvasTexture(r);
}
function updateBandTexture(o, i = [], e = 64, r = 2) {
  if (!o || !Array.isArray(i) || i.length === 0) {
    console.warn("Invalid input for updateBandTexture.");
    return;
  }
  const a = o.image.getContext("2d");
  a.imageSmoothingEnabled = !1, a.clearRect(0, 0, e, r);
  const c = i.length, l = Math.floor(e / c);
  for (let h = 0; h < c; h++) {
    a.fillStyle = i[h];
    const d = h * l, f = h === c - 1 ? e - d : l;
    a.fillRect(d, 0, f, r);
  }
  o.needsUpdate = !0;
}
const uniforms$7 = UniformsUtils.merge([
  {
    gradientMap: { value: null },
    maxHeight: { value: 1 },
    vertexHeights: { value: !1 },
    isEmissive: { value: !1 },
    heatmap: { value: !0 }
  }
]);
class PillarMaterial extends InstancedEffectPointMaterial {
  constructor(e) {
    super();
    _(this, "name", "PillarMaterial");
    _(this, "isPillarMaterial", !0);
    this.vertexShader = vertexShader$7;
    const { shape: r } = e;
    r === "cone" ? this.fragmentShader = fragmentShaderCone : this.fragmentShader = fragmentShaderPillar, this.transparent = !0, defineMaterialNormalProperties(this, [
      "maxHeight",
      "sphereIndex",
      "isEmissive",
      "heatmap"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexHeights", "MVT_USE_VERTEX_HEIGHT"],
      ["isGlobe", "IS_GLOBE"]
    ]), Object.assign(this.uniforms, UniformsUtils.clone(uniforms$7)), this._cachedGradient = null, this._cachedBandColors = null, this._colorMode = defaultValue$1(e.colorMode, "gradient"), Object.defineProperties(this, {
      gradient: {
        get: function() {
          return this._cachedGradient;
        },
        set: function(s) {
          this._cachedGradient = s, this.updateGradientMap();
        }
      },
      bandColors: {
        get: () => this._cachedBandColors,
        set: (s) => {
          this._cachedBandColors = s, this._colorMode === "band" && this.updateBandMap();
        }
      }
    }), this._colorMode === "band" ? (this._cachedBandMap || this.createBandMap(), this.uniforms.gradientMap.value = this._cachedBandMap) : (this._cachedGradientMap || this.createGradientMap(), this.uniforms.gradientMap.value = this._cachedGradientMap), this.setValues(e);
  }
  createGradientMap() {
    this._cachedGradientMap = createDefaultGradientTexture();
  }
  createBandMap() {
    this._cachedBandMap = createBandTexture();
  }
  updateGradientMap() {
    const e = this._cachedGradientMap;
    if (!e)
      return;
    const r = this._cachedGradient;
    updateGradientTexture(e, r), e.needsUpdate = !0;
  }
  updateBandMap() {
    const e = this._cachedBandMap;
    if (!e)
      return;
    const r = this._cachedBandColors;
    updateBandTexture(e, r), e.needsUpdate = !0;
  }
  dispose() {
    this._cachedGradientMap && this._cachedGradientMap.dispose(), this._cachedBandMap && this._cachedBandMap.dispose(), super.dispose();
  }
}
class Pillar extends GeoInstancedPointMesh {
  constructor(e) {
    super(e);
    _(this, "geometry");
    _(this, "material");
    _(this, "opacity");
    _(this, "height");
    _(this, "radiusSegments");
    _(this, "radius");
    _(this, "gradient");
    _(this, "vertexHeights");
    _(this, "openEnded");
    _(this, "colorMode");
    _(this, "heatmap");
    _(this, "getInstanceLocalMatrix", (e, r, s) => {
      const { vertexHeights: a, vertexSizes: c } = this.parameters, { height: l, size: h } = this.dataSource.data;
      let d = new Matrix4();
      if (a && l) {
        const f = new Matrix4();
        f.makeScale(1, 1, l[s]), d.multiply(f);
      }
      if (c && h) {
        const f = new Matrix4();
        f.makeScale(h[s], h[s], 1), d.multiply(f);
      }
      return d;
    });
    _(this, "addCustomAttributes", () => {
      const { vertexHeights: e } = this.parameters, { height: r } = this.dataSource.data;
      let s = -1;
      if (!e || !r)
        return s;
      for (let a = 0; a < r.length; a++)
        s < r[a] && (s = r[a]);
      this.material.uniforms.maxHeight.value = s;
    });
    this.parameters = e;
  }
  initObject() {
    const {
      radius: e,
      height: r,
      radialSegments: s,
      heightSegments: a,
      openEnded: c,
      ...l
    } = this.parameters;
    this.geometry = new PillarGeometry(this.parameters), this.material = new PillarMaterial(l), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  computeInstanceMorphMatrix(e) {
    return defaultValue$1.EMPTY_MAT4;
  }
  getSphereIndex() {
    const { sphereIndex: e } = this.geometry.parameters;
    this.material.uniforms.sphereIndex.value = e;
  }
}
const vertexShader$6 = `#define GLSLIFY 1
#include <common>
uniform sampler2D gradientMap;

varying vec2 vUv;

#include <logdepthbuf_pars_vertex>
void main() { 
    
    gl_Position = vec4(position, 1.0);
    // vUv = position.xy;
    vUv = vec2((position.x + 1.0) * 0.5, (position.y + 1.0) * 0.5);
    // vec4 gray = texture2D(gradientMap, vUv);

    // vec4 m0 = matrixWorldInverse * vec4(gl_Position.xy, 0.0, 1.0);
    // vec4 m1 = matrixWorldInverse * vec4(gl_Position.xy, 1.0, 1.0);
    // m0 /= m0.w;
    // m1 /= m1.w;
    // vec4 pixel = m0 + (-m0.z / (m1.z - m0.z)) * (m1 - m0);
    // pixel.z = 100. * gray.a;

    // gl_Position = projectionMatrix * pixelToViewMatrix * vec4(pixel.xyz, 1.0);
    #include <logdepthbuf_vertex>
}`, fragmentShader$6 = `#define GLSLIFY 1
#include <common>

uniform sampler2D heatmap;
uniform sampler2D gradientMap;
uniform sampler2D heatmapDepth;
uniform float opacity;
uniform vec2 resolution;

varying vec2 vUv;

#include <packing>

#include <logdepthbuf_pars_fragment>

void main() {
    vec4 color = texture2D(heatmap, vUv);
    
    if (color.a <= 0.) {
        discard;
    }
    gl_FragColor = texture2D(gradientMap, vec2(color.a, 0.5));
    float addAlpha = 1.0;
    if (color.a < 0.3) {
        addAlpha = color.a * 3.3;
    }
    // if (color.a < 0.3) {
    //     gl_FragColor.a = color.a * 3.3;
    // } else {
    //     gl_FragColor.a = 1.0;
    // }
    gl_FragColor.a *= color.a;
    gl_FragColor.a *= opacity;

    #if defined( USE_LOGDEPTHBUF ) 
        gl_FragDepthEXT = texture2D(heatmapDepth, vUv).r;
    #endif
    #include <colorspace_fragment>
}`, uniforms$6 = UniformsUtils.merge([
  UniformsLib.fog,
  {
    heatmap: { value: null },
    heatmapDepth: { value: null },
    gradientMap: { value: null },
    opacity: { value: 1 },
    isEmissive: { value: !1 }
  }
]);
class HeatmapMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "HeatmapMaterial", this.isHeatmapMaterial = !0, this.fog = !0, this.lights = !1, this.transparent = !0, this.fragmentShader = fragmentShader$6, this.vertexShader = vertexShader$6, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$6)), defineMaterialNormalProperties(this, [
      "opacity",
      "resolution",
      "isEmissive"
    ]), defineMaterialAliasProperties(this, []), defineMaterialBoolDefineProperties(this, []), this._cachedGradient = null, Object.defineProperties(this, {
      gradient: {
        get: function() {
          return this._cachedGradient;
        },
        set: function(e) {
          this._cachedGradient = e, this.updateGradientMap();
        }
      }
    }), this.createGradientMap(), this.uniforms.gradientMap.value = this._cachedGradientMap, this.setValues(i);
  }
  createGradientMap() {
    this._cachedGradientMap = createDefaultGradientTexture();
  }
  updateGradientMap() {
    const i = this._cachedGradientMap, e = this._cachedGradient;
    updateGradientTexture(i, e), i.needsUpdate = !0;
  }
  dispose() {
    this._cachedGradientMap && this._cachedGradientMap.dispose(), super.dispose();
  }
}
const vertexShader$5 = `#define GLSLIFY 1
#include <common>

attribute float instancedWeight;

uniform float radius;
uniform float maxValue;
uniform float minValue;
uniform bool keepSize;
uniform float attenuateMValueFactor;
uniform float pixelRatio;
uniform vec2 resolution;

varying vec2 vUv;
varying float vWeight;

#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 

    float range = (maxValue - minValue) * attenuateMValueFactor;

    vec4 worldPosition = (modelMatrix * instanceMatrix * vec4(position, 1.0));
    float pixelSize = getPixelSize(worldPosition.xyz);

    if (keepSize) {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize, 1.0);
        range *= pixelSize;
    } else {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius, 1.0);
    }
    
    // gl_Position = vec4(position, 1.0);
    // vZDepth = (gl_Position.z / gl_Position.w + 1.0) * 0.5;
   
    vUv = vec2(position.x + 0.5, position.y + 0.5);
    
    vWeight = (instancedWeight - minValue) / (maxValue + range - minValue);

    #include <logdepthbuf_vertex>
}`, fragmentShader$5 = `#define GLSLIFY 1
#include <common>

uniform sampler2D circleMap;

varying vec2 vUv;
varying float vWeight;
varying float vZDepth;
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    gl_FragColor.a = texture2D(circleMap, vUv).a * vWeight;
    // gl_FragColor.a = 1.;
    //#if defined( USE_LOGDEPTHBUF )
        // gl_FragColor = vec4(vec3(gl_FragDepthEXT), 1.0);
        // int d = int(gl_FragDepthEXT * 16581375.0);
        // gl_FragColor.r = float((d & 0xff0000) >> 16) / 255.0;
        // gl_FragColor.g = float((d & 0x00ff00) >> 8) / 255.0;
        // gl_FragColor.b = float(d & 0x0000ff) / 255.0;
        // gl_FragColor.r = gl_FragDepthEXT; // a
        // gl_FragColor.g = mod(gl_FragDepthEXT * 10.0, 1.0);
        // gl_FragColor.b = mod(gl_FragDepthEXT * 1000.0, 1.0);
        // int d = int(gl_FragDepthEXT * 10000000.0);
        // gl_FragColor.r = (d & 0xff000 >> 16) / 255.0; 
        // gl_FragColor.g = (d & 0x00ff00 >> 8) / 255.0; 
        // gl_FragColor.b = (d & 0x0000ff ) / 255.0; 
        // gl_FragColor.r = gl_FragDepthEXT;
        // gl_FragColor.r = gl_FragCoord.z;

        // float depthVal = gl_FragCoord.z * (256.0*256.0 - 1.0) / (256.0*256.0);
        // vec3 encode = fract( depthVal * vec3(1.0, 256.0, 256.0*256.0) );
        // encode.xy = encode.xy - encode.yz / 256.0 + 1.0/512.0;
        // gl_FragColor.rgb = encode;

    // #else 
    //     gl_FragColor.r = gl_FragCoord.z;
    // #endif
    // gl_FragColor.r = 1.0;
    // gl_FragColor.a = gl_FragCoord.z;
}`, uniforms$5 = UniformsUtils.merge([
  UniformsLib.fog,
  {
    radius: { value: 30 },
    circleMap: { value: null },
    minValue: { value: 0 },
    maxValue: { value: 100 },
    keepSize: { value: !1 },
    attenuateMValueFactor: { value: 0 }
  }
]);
class HeatmapTextureMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(i), this.type = "HeatmapTextureMaterial", this.isHeatmapTextureMaterial = !0, this.fog = !0, this.lights = !1, this.transparent = !0, this.depthTest = !1, this.fragmentShader = fragmentShader$5, this.vertexShader = vertexShader$5, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$5)), defineMaterialNormalProperties(this, [
      "radius",
      "minValue",
      "maxValue",
      "keepSize",
      "attenuateMValueFactor"
    ]), defineMaterialAliasProperties(this, []), defineMaterialBoolDefineProperties(this, []);
    const e = this.createCircleMap();
    this.uniforms.circleMap.value = e, this.setValues(i), this.blending = CustomBlending, this.blendSrc = OneFactor, this.blendDst = ZeroFactor, this.blendSrcAlpha = OneFactor, this.blendDstAlpha = OneFactor;
  }
  createCircleMap() {
    let i = document.createElement("canvas");
    i.width = 64, i.height = 64;
    let e = i.getContext("2d"), r = e.createRadialGradient(32, 32, 0, 32, 32, 32);
    return r.addColorStop(0, "rgba(0,0,0,1)"), r.addColorStop(1, "rgba(0,0,0,0)"), e.fillStyle = r, e.arc(32, 32, 32, 0, Math.PI * 2, !1), e.fill(), new CanvasTexture(i);
  }
  dispose() {
    this.uniforms.circleMap.value && this.uniforms.circleMap.value.dispose(), super.dispose();
  }
}
class InstancedPointGeometry extends InstancedBufferGeometry {
  constructor() {
    super();
    const i = this.geometry = new PlaneGeometry();
    this.setAttribute("position", i.attributes.position), this.setAttribute("uv", i.attributes.uv), this.setIndex(i.index);
  }
  dispose() {
    this.geometry.dispose();
  }
}
class Heatmap extends GeoMesh {
  constructor(e) {
    super(e);
    _(this, "isHeatmap", !0);
    _(this, "frustumCulled", !1);
    _(this, "geometry");
    _(this, "material");
    _(this, "scene");
    _(this, "pointMesh");
    _(this, "pointMaterial");
    _(this, "pointGeometry");
    _(this, "renderTarget");
    _(this, "depthMaterial");
    _(this, "depthRenderTarget");
    this.parameters = e, this.defineMaterialProxyProperties([
      "resolution"
    ]);
  }
  getDefaultParams() {
    return {
      radius: 100,
      maxValue: 1,
      gradient: {
        0: "rgba(0,0,255,1)",
        0.3: "rgba(0,255,0,1)",
        0.6: "rgba(255,255,0,1)",
        1: "rgba(255,0,0,1)"
      }
    };
  }
  initObject() {
    let e = this.parameters;
    const r = this.geometry = new BufferGeometry();
    r.setAttribute("position", new BufferAttribute(new Float32Array([
      -1,
      1,
      0,
      1,
      1,
      0,
      -1,
      -1,
      0,
      1,
      -1,
      0
    ]), 3)), r.setAttribute("uv", new BufferAttribute(new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      1,
      0
    ]), 2)), r.setIndex([0, 2, 1, 2, 3, 1]), (this.material = new HeatmapMaterial({})).setCommonUniforms(this.engine.rendering.uniforms);
    const [a, c] = this.resolution || [], l = this.scene = new Scene();
    this.renderTarget = new WebGLRenderTarget(a, c), this.depthRenderTarget = new WebGLRenderTarget(a, c, {});
    const h = new DepthTexture(a, c);
    h.format = DepthFormat, h.type = UnsignedInt248Type, this.depthRenderTarget.depthTexture = h, this.depthMaterial = new HeatmapTextureMaterial({
      depthTest: !0,
      depthWrite: !0,
      colorWrite: !1
    });
    const d = this.pointGeometry = new InstancedPointGeometry(), f = this.pointMaterial = new HeatmapTextureMaterial({
      depthTest: !1,
      depthWrite: !1
    });
    f.setCommonUniforms(this.engine.rendering.uniforms), this.depthMaterial.setCommonUniforms(this.engine.rendering.uniforms);
    const p = this.pointMesh = new GeoInstancedMesh(d, f);
    p.engine = this.engine, this.pointMesh.matrixAutoUpdate = !0, p.frustumCulled = !1, l.add(p), this.material.uniforms.heatmap.value = this.renderTarget.texture, this.material.uniforms.heatmapDepth.value = this.depthRenderTarget.depthTexture, e.gradient !== void 0 && (this.gradient = e.gradient), e.radius !== void 0 && (this.radius = e.radius), e.minValue !== void 0 && (this.minValue = e.minValue), e.maxValue !== void 0 && (this.maxValue = e.maxValue), e.opacity !== void 0 && (this.opacity = e.opacity), e.keepSize !== void 0 && (this.keepSize = e.keepSize), e.attenuateMValueFactor !== void 0 && (this.attenuateMValueFactor = e.attenuateMValueFactor);
  }
  onBeforeSceneRenderHook(e, r, s, a) {
    let c = e.renderer;
    const l = a.cameraOffset;
    this.scene.position.set(-l.x, -l.y, -l.z), c.setRenderTarget(this.renderTarget), c.autoClear === !1 && c.clear(), c.render(this.scene, s), c.setRenderTarget(this.depthRenderTarget), c.autoClear === !1 && c.clear(), this.scene.overrideMaterial = this.depthMaterial, c.render(this.scene, s), this.scene.overrideMaterial = null, c.setRenderTarget(null);
  }
  set dataSource(e) {
    this.pointMesh.dataSource = e, this.needsUpdate = !0;
  }
  get dataSource() {
    return this.pointMesh.dataSource;
  }
  _updateData() {
    this.pointMesh.dataSource && (this.pointMesh.addCustomAttributes = (e, r) => {
      let s = r.data, a = [];
      for (let c = 0; c < s.position.length; c++) {
        const l = s.count[c] ? s.count[c] : 1;
        a.push(l);
      }
      e.setAttribute(
        "instancedWeight",
        new InstancedBufferAttribute(new Float32Array(a), 1)
      );
    }, this.pointMesh._updateData());
  }
  dispose() {
    this.material.dispose(), this.geometry.dispose(), this.pointGeometry.dispose(), this.pointMaterial.dispose(), this.renderTarget.dispose(), this.depthMaterial.dispose(), this.depthRenderTarget.dispose();
  }
  set gradient(e) {
    Object.prototype.toString.call(e) === "[object Object]" && (this.material.gradient = e);
  }
  set radius(e) {
    !isNaN(e) && e > 0 && (this.pointMaterial.radius = e, this.depthMaterial.radius = e);
  }
  get radius() {
    return this.pointMaterial.radius;
  }
  set minValue(e) {
    isNaN(e) || (this.pointMaterial.minValue = e);
  }
  get minValue() {
    return this.pointMaterial.minValue;
  }
  set maxValue(e) {
    isNaN(e) || (this.pointMaterial.maxValue = e);
  }
  get maxValue() {
    return this.pointMaterial.maxValue;
  }
  set opacity(e) {
    isNaN(e) || (this.material.opacity = e);
  }
  get opacity() {
    return this.material.opacity;
  }
  set keepSize(e) {
    this.pointMaterial.keepSize = e, this.depthMaterial.keepSize = e;
  }
  get keepSize() {
    return this.pointMaterial.keepSize;
  }
  set attenuateMValueFactor(e) {
    this.pointMaterial.attenuateMValueFactor = e;
  }
}
const vertexShader$4 = `#define GLSLIFY 1
#include <common>

uniform float heightRatio;
uniform sampler2D map;

varying vec2 vUv;

#include <logdepthbuf_pars_vertex>
void main() { 

    vUv = vec2(uv.x, 1. - uv.y);
    #include <begin_vertex>

    transformed.z = texture2D(map, vUv).a * heightRatio;

    #include <project_vertex>
    #include <logdepthbuf_vertex>
}`, fragmentShader$4 = `#define GLSLIFY 1
#include <common>

uniform sampler2D map;
uniform float opacity;
uniform vec2 resolution;

varying vec2 vUv;
#include <logdepthbuf_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vUv);
    gl_FragColor.a *= opacity;

    #include <logdepthbuf_fragment> 
    #include <colorspace_fragment>

}`, uniforms$4 = UniformsUtils.merge([
  UniformsLib.fog,
  {
    heightRatio: { value: 100 },
    opacity: { value: 1 },
    map: { value: null },
    isEmissive: { value: !1 }
  }
]);
class Heatmap3DMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "Heatmap3DMaterial", this.isHeatmapMaterial = !0, this.fog = !0, this.lights = !1, this.side = DoubleSide, this.forceSinglePass = !1, this.transparent = !0, this.depthWrite = !0, this.depthTest = !0, this.fragmentShader = fragmentShader$4, this.vertexShader = vertexShader$4, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$4)), defineMaterialNormalProperties(this, [
      "heightRatio",
      "resolution",
      "opacity",
      "map",
      "isEmissive"
    ]), this.setValues(i);
  }
}
new Vector3$1();
const rotationMatrixScratch = new Matrix4();
function Canvas(o, i) {
  let e = document.createElement("canvas");
  return o && (e.width = o), i && (e.height = i), e;
}
let positionVec3 = new Vector3$1(), positionTemp = new Vector3$1();
class Heatmap3D extends GeoMesh {
  constructor(e) {
    super(e);
    _(this, "_gradient");
    _(this, "_radius");
    _(this, "_maxValue");
    _(this, "isHeatmap3D", !0);
    _(this, "frustumCulled", !1);
    _(this, "geometry");
    _(this, "material");
    _(this, "opacity");
    _(this, "heightRatio");
    this.parameters = e, this._gradient = this.parameters.gradient !== void 0 ? this.parameters.gradient : {
      0.4: "rgba(0,0,255,1)",
      0.6: "rgba(0,255,0,1)",
      0.8: "rgba(255,255,0,1)",
      1: "rgba(255,0,0,1)"
    }, this._radius = this.parameters.radius !== void 0 ? this.parameters.radius : 100, this._maxValue = this.parameters.maxValue !== void 0 ? this.parameters.maxValue : 1, this.defineMaterialProxyProperties([
      "resolution",
      "opacity",
      "heightRatio"
    ]);
  }
  initObject() {
    const { radius: e, maxValue: r, ...s } = this.parameters;
    this.geometry = new PlaneGeometry(), (this.material = new Heatmap3DMaterial(s)).setCommonUniforms(this.engine.rendering.uniforms);
  }
  _updateData() {
    let e = this.dataSource.data;
    const r = this.engine.map.isGlobe, s = this.engine.map.map.ellipsoid || Ellipsoid.WGS84;
    let a = 1 / 0, c = 1 / 0, l = -1 / 0, h = -1 / 0, d = [];
    if (r) {
      const M = [];
      for (let N = 0; N < e.position.length; N++) {
        const U = e.position[N];
        s.scaleToGeodeticSurface(positionVec3.fromArray(U), positionTemp), M[N] = positionTemp.toArray();
      }
      const P = M.map((N) => new Vector3$1(...N)), D = createTangentPlane(M, s), L = D.projectPointsOntoPlane(P);
      for (let N = 0; N < L.length; N++) {
        const U = L[N];
        a = Math.min(a, U.x), l = Math.max(l, U.x), c = Math.min(c, U.y), h = Math.max(h, U.y);
      }
      const O = D._origin, F = O.clone().add(D._xAxis.multiplyScalar((l + a) / 2)).add(D._yAxis.multiplyScalar((h + c) / 2));
      for (let N = 0; N < L.length; N++) {
        const U = L[N], z = e.count ? e.count[N] : 1;
        d.push([U.x - a + this._radius, U.y - c + this._radius, z]);
      }
      this.position.copy(F);
      const k = Transforms.eastNorthUpToFixedFrame(O), V = rotationMatrixScratch.extractRotation(k);
      this.rotation.setFromRotationMatrix(V);
    } else {
      let M = 1 / 0, P = -1 / 0;
      for (let L = 0; L < e.position.length; L++) {
        const O = e.position[L], F = e.count ? e.count[L] : 1;
        a = Math.min(O[0], a), c = Math.min(O[1], c), M = Math.min(O[2], M), l = Math.max(O[0], l), h = Math.max(O[1], h), P = Math.max(O[2], P), d.push([O[0], O[1], F]);
      }
      let D = [(a + l) / 2, (c + h) / 2, (M + P) / 2];
      this.position.set(...D), d.forEach((L) => {
        L[0] = L[0] - a + this._radius, L[1] = L[1] - c + this._radius;
      });
    }
    let f = Math.ceil(l - a) + this._radius * 2, p = Math.ceil(h - c) + this._radius * 2;
    const m = 4e4;
    let y = Math.min(f * p / m, 2048), x = y / 2, v = new Canvas(y, y), S = simpleheat(v), E = S._ctx;
    E.save(), E.scale(y / f, y / p), S.data(d).radius(this._radius).max(this._maxValue).gradient(this._gradient).draw(), E.restore(), this.geometry && this.geometry.dispose();
    const b = this.geometry = new PlaneGeometry(f, p, x, x);
    b.computeBoundingSphere(), b.computeBoundingBox(), this.texture && this.texture.dispose();
    let w = this.texture = new CanvasTexture(v);
    this.material.uniforms.map.value = w, this.needsUpdate = !1;
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
  get gradient() {
    return this._gradient;
  }
  set gradient(e) {
    this._gradient = e;
  }
  get radius() {
    return this._radius;
  }
  set radius(e) {
    this._radius = e;
  }
  get maxValue() {
    return this._maxValue;
  }
  set maxValue(e) {
    this._maxValue = e;
  }
}
const vertexShader$3 = `#define GLSLIFY 1
#include <common>

uniform float positionOffsetX;
uniform float positionOffsetY;
uniform float pixelOffsetX;
uniform float pixelOffsetY;
uniform float positionOffsetZ;
uniform bool uFlat;
#ifdef RENDER_IN_POSTPROCESS
    uniform float cameraFar;
#endif

attribute float pIndex;
attribute vec2 wh;

#ifdef IS_GLOBE
    attribute mat4 instanceMatrix;
#endif

#ifdef MVT_USE_VERTEX_ROTATEZ
    attribute float aRotateZ;
# else
    uniform float uRotateZ;
#endif

varying vec2 vUv;

#ifdef RENDER_IN_POSTPROCESS
    varying vec2 vClipSpacePosition;
    varying float vLogDepth;
#endif
#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

vec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {
    float x = coord.x;
    float y = coord.y;
    if (corner == 1.0) {
        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);
    } else if (corner == 2.0) {
        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else if (corner == 3.0) {
        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else {
        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);
    }
    return vec3(x, y, coord.z);
}

void main() {
    #include <mvt_selective_vertex>
    // float x = position.x;
    // float y = position.y;
    vUv = uv;

    float rotateZ;
    #ifdef MVT_USE_VERTEX_ROTATEZ
        rotateZ = aRotateZ;
    # else
        rotateZ = uRotateZ;
    #endif

    mat4 currentInstanceMatrix = mat4(1.0);
    vec3 currentPosition = position;
    #ifdef IS_GLOBE
        currentInstanceMatrix = instanceMatrix;

        currentInstanceMatrix[3][0] = position.x;
        currentInstanceMatrix[3][1] = position.y;
        currentInstanceMatrix[3][2] = position.z;

        currentPosition = vec3(0.0, 0.0, 0.0);
    #endif

    vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));

    #ifdef RENDER_IN_POSTPROCESS
    vec4 clipSpacePosition = projectionMatrix * viewMatrix * worldPosition;
    vClipSpacePosition.xy = ((clipSpacePosition.xy / clipSpacePosition.w) + 1.0) / 2.0;

    float fcoef = 1.0 / log2(cameraFar + 1.0);
    float logDepth = log2(max(1e-6, 1.0 + clipSpacePosition.w)) * fcoef;
    vLogDepth = logDepth;
    #endif

    if (uFlat) {
        // viewMatrix[0]\u8868\u793A\u76F8\u673A\u7684\u53F3\u65B9\u5411\uFF0C\u4E0D\u7BA1\u76F8\u673A\u5982\u4F55\u503E\u659Ctilt\uFF0C\u6CD5\u5411\u91CF\u90FD\u6307\u5411\u6B63\u5317\u65B9\u5411\uFF0C\u6B63\u597D\u53EF\u4EE5\u7528\u6765\u8BA1\u7B97\u548C\u6587\u5B57\u7684\u5939\u89D2
        mat4 localViewMatrix = viewMatrix * currentInstanceMatrix;
        vec4 right = localViewMatrix[0];
        float theta = dot(vec2(sin(rotateZ), cos(rotateZ)), vec2(-right.y, right.x));
        if (theta < 0.0) {
            rotateZ += PI;
        }
        // TODO \u652F\u6301offset
        float hw = wh.x * 0.5;
        float hh = wh.y * 0.5;
        if (keepSize) {
            float pixelSize = getPixelSize(worldPosition.xyz);
            hw = hw * pixelSize;
            hh = hh * pixelSize;
        }

        vec3 current = transformCoord(currentPosition, vec2(hw, hh), pIndex, -rotateZ);
        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);

        // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    }
    else {
        // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);
        worldPosition.x += positionOffsetX;
        worldPosition.y += positionOffsetY;
        worldPosition.z += positionOffsetZ;
        vec4 pos = projectionMatrix * viewMatrix * worldPosition;
        float w = pos.w;
        vec3 screen = pos.xyz / w;
        
        float hw = wh.x / resolution.x;
        float hh = wh.y / resolution.y;
        if (!keepSize) {
            float pixelSize = getPixelSize(worldPosition.xyz);
            hw = hw / pixelSize;
            hh = hh / pixelSize;
        }

        vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -rotateZ);
        gl_Position = vec4(current, 1.0);

        gl_Position.x += pixelOffsetX * 2. / resolution.x;
        gl_Position.y += pixelOffsetY * 2. / resolution.y;

        gl_Position *= w;
    }
    #include <logdepthbuf_vertex>
    // gl_PointSize = size * pixelRatio;
    // vSize = size;
    // vOffset = offset;
}`, fragmentShader$3 = `#define GLSLIFY 1
#include <common>

uniform sampler2D map;
uniform sampler2D depthTexture;
uniform vec4 backgroundColor;
uniform float opacity;
uniform float lineHeight;

#ifdef RENDER_IN_POSTPROCESS
    uniform float cameraFar;
#endif

varying vec2 vUv;

#ifdef RENDER_IN_POSTPROCESS
    varying vec2 vClipSpacePosition;
    varying float vLogDepth;
#endif

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <tonemapping_pars_fragment>
#include <output_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    // gl_FragColor = vec4(1., 0, 0, 1.);
    gl_FragColor = texture2D(map, vec2(vUv.x, 1.0 - vUv.y));

    #ifdef RENDER_IN_POSTPROCESS
    float depthValue = texture2D(depthTexture, vClipSpacePosition).r;
    float bias = 0.001; // \u907F\u514D\u8BBE\u7F6E\u4E00\u4E2A\u9608\u503C\uFF0C\u7CBE\u5EA6\u8BEF\u5DEE\u9020\u6210\u6587\u5B57\u7ED8\u5236\u4E0D\u7A33\u5B9A
    if (vLogDepth > depthValue + bias) {
        discard;
    }
    #endif

    if (backgroundColor.a > 0.0) {
        gl_FragColor = mix(backgroundColor, gl_FragColor, gl_FragColor.a);
    }

    if (gl_FragColor.a <= 0.0) {
        discard;
    }
    gl_FragColor.a *= opacity;

    #include <mvt_selective_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
    #include <output_fragment>
}`, uniforms$3 = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  emissiveUniforms,
  {
    map: {
      value: null
    },
    pixelRatio: {
      value: 1
    },
    lineHeight: {
      value: 14
    },
    pixelOffsetX: {
      value: 0
    },
    pixelOffsetY: {
      value: 0
    },
    positionOffsetX: {
      value: 0
    },
    positionOffsetZ: {
      value: 0
    },
    positionOffsetY: {
      value: 0
    },
    backgroundColor: {
      value: [1, 1, 0, 0]
    },
    uFlat: {
      value: !1
    },
    opacity: {
      value: 1
    },
    isEmissive: {
      value: !1
    },
    uRotateZ: {
      value: 0
    },
    keepSize: {
      value: !0
    },
    depthTexture: {
      value: null
    },
    cameraFar: {
      value: 0
    }
  }
]);
class DefaultTextMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "DefaultTextMaterial", this.vertexShader = vertexShader$3, this.fragmentShader = fragmentShader$3, this.isDefaultTextMaterial = !0, this.transparent = !0, this.depthTest = !1, this.depthWrite = !1, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$3)), defineMaterialSelectiveProperties(this), defineMaterialKeepSizeProperties(this), defineMaterialNormalProperties(this, [
      "lineHeight",
      "pixelRatio",
      "map",
      "depthTexture",
      "cameraFar",
      "pixelOffsetX",
      "pixelOffsetY",
      "positionOffsetX",
      "positionOffsetY",
      "positionOffsetZ",
      "backgroundColor",
      "resolution",
      "opacity",
      "isEmissive"
    ]), defineMaterialAliasProperties(this, [
      ["flat", "uFlat"],
      ["rotateZ", "uRotateZ"]
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexRotateZs", "MVT_USE_VERTEX_ROTATEZ"],
      ["isGlobe", "IS_GLOBE"],
      ["isRenderInPostprocess", "RENDER_IN_POSTPROCESS"]
    ]), defineMaterialEmissiveProperties(this), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(i);
  }
}
let curStyleId$1;
const _tempVector3 = new Vector3$1(), _tempVector4 = new Vector4(), _tempMatrix4 = new Matrix4();
class Text extends GeoMesh {
  constructor(e) {
    super(e);
    _(this, "isEventEntitySupported", !0);
    _(this, "_fontSize");
    _(this, "_fontFamily");
    _(this, "_fillStyle");
    _(this, "_padding");
    _(this, "_strokeStyle");
    _(this, "_shouldStroke");
    _(this, "_collisionBoxCache", {});
    _(this, "isRenderInPostprocess", !1);
    _(this, "geometry");
    _(this, "material");
    _(this, "cachedData", []);
    _(this, "drawingData");
    _(this, "canvas");
    _(this, "ctx");
    _(this, "texture");
    _(this, "matrixAutoUpdate", !0);
    _(this, "sortByStyle", (e) => this.parameters.vertexStyles ? e.sort((r, s) => s.styleId - r.styleId) : e);
    _(this, "getStrictStyleId", (e) => {
      if (this.parameters.vertexStyles) {
        let {
          fontSize: r,
          fontWeight: s,
          lineWidth: a,
          fillStyle: c = [],
          strokeStyle: l = []
        } = e;
        return `${r}_${s}_${a}_${c[0]}_${c[1]}_${c[2]}_${c[3]}_${l[0]}_${l[1]}_${l[2]}_${l[3]}`;
      }
      return 0;
    });
    _(this, "updateRenderingData", () => {
      const e = this.engine.rendering.pixelRatio, r = this.engine.map.isGlobe, s = this.canvas, a = this.ctx, c = this._fontSize, l = this._fontFamily, h = this._fillStyle, d = this._padding, f = this.cachedData || [], p = potpack(f);
      f.length === 0 && (p.w = 1, p.h = 1);
      let m = p.w, y = p.h;
      s.width = m * e, s.height = y * e, a.save(), a.scale(e, e), a.textBaseline = "top", a.fillStyle = h, this._shouldStroke && (a.strokeStyle = this._strokeStyle, this._lineWidth > 0 && (a.lineWidth = this._lineWidth)), a.font = c + "px " + l, this.shadowColor && (a.shadowColor = this.shadowColor, a.shadowOffsetX = this.shadowOffsetX || 0, a.shadowOffsetY = this.shadowOffsetY || 0, a.shadowBlur = this.shadowBlur || 0);
      const x = [], v = [], S = [], E = [], b = [], w = [], M = [], P = [];
      let D = c, L = 1 / 0, O = 1 / 0, F = 1 / 0, k = -1 / 0, V = -1 / 0, N = -1 / 0;
      for (let H = 0; H < f.length; H++) {
        const W = f[H].position, [q, Z, X = 0] = W;
        q < L && (L = q), q > k && (k = q), Z < O && (O = Z), Z > V && (V = Z), X < F && (F = X), X > N && (N = X);
      }
      let U = (L + k) / 2, z = (O + V) / 2, $ = (F + N) / 2;
      U = Number.isNaN(U) ? 0 : U, z = Number.isNaN(z) ? 0 : z, $ = Number.isNaN($) ? 0 : $;
      let G = [U, z, $], j = new Matrix4();
      for (let H = 0, W = f.length; H < W; ++H) {
        const q = f[H], Z = this.getStrictStyleId(q);
        if (this.parameters.vertexStyles && curStyleId$1 !== Z) {
          curStyleId$1 = Z;
          let { fontWeight: le, fontSize: de, fillStyle: ce, strokeStyle: Re, lineWidth: Ee } = q;
          le >= 10 && le % 10 === 0 ? a.font = le * 10 + " " + de + "px " + l : a.font = de + "px " + l, D = de, Ee > 0 && (a.lineWidth = Ee, a.strokeStyle = "rgba(" + Re.join(",") + ")"), a.fillStyle = "rgba(" + ce.join(",") + ")";
        }
        let X = String(q.text).split("\\");
        for (let le = 0; le < X.length; le++)
          (this._shouldStroke || this.parameters.vertexStyles) && a.strokeText(X[le], q.x + d[0], q.y + d[1] + le * D), a.fillText(X[le], q.x + d[0], q.y + d[1] + le * D);
        let [K, ee, ie = 0] = q.position;
        if (r) {
          j = Transforms.eastNorthUpToFixedFrame(
            new Vector3$1(K, ee, ie),
            null,
            j
          ), j.elements[12] = 0, j.elements[13] = 0, j.elements[14] = 0;
          for (let le = 0; le < 4; le++)
            for (let de = 0; de < 16; de++)
              P.push(j.elements[de]);
        }
        K -= G[0], ee -= G[1], ie -= G[2], x.push(
          K,
          ee,
          ie,
          K,
          ee,
          ie,
          K,
          ee,
          ie,
          K,
          ee,
          ie
        ), S.push(0, 1, 2, 3), b.push(
          q.w,
          q.h,
          q.w,
          q.h,
          q.w,
          q.h,
          q.w,
          q.h
        );
        const re = H * 4;
        E.push(
          re,
          re + 2,
          re + 1,
          re,
          re + 3,
          re + 2
        );
        const ne = q.x / m, J = (q.x + q.w) / m, oe = (q.y + q.h) / y, _e = q.y / y;
        v.push(
          ne,
          oe,
          ne,
          _e,
          J,
          _e,
          J,
          oe
        ), w.push(q.index, q.index, q.index, q.index), this.parameters.vertexRotateZs && M.push(q.rotateZ, q.rotateZ, q.rotateZ, q.rotateZ);
      }
      a.restore();
      const Y = this.geometry;
      Y.setAttribute("position", new Float32BufferAttribute(x, 3)), Y.setAttribute("pIndex", new Float32BufferAttribute(S, 1)), Y.setAttribute("wh", new Float32BufferAttribute(b, 2)), Y.setAttribute("uv", new Float32BufferAttribute(v, 2)), r && Y.setAttribute("instanceMatrix", new Float32BufferAttribute(P, 16)), this.parameters.vertexRotateZs && Y.setAttribute("aRotateZ", new Float32BufferAttribute(M, 1)), Y.setIndex(E), Y.computeBoundingSphere(), this.makeMeshPositionOffset(G), x.length > 0 && (this.texture && this.texture.dispose(), this.texture = new CanvasTexture(this.canvas), this.texture.minFilter = LinearFilter, this.texture.magFilter = LinearFilter, this.texture.generateMipmaps = !1, this.material.uniforms.map.value = this.texture), this.needsUpdate = !1, curStyleId$1 = null;
    });
    this.parameters = e, this._fontSize = this.parameters.fontSize !== void 0 ? this.parameters.fontSize : 16, this._fontFamily = this.parameters.fontFamily !== void 0 ? this.parameters.fontFamily : "Microsoft Yahei", this._fillStyle = this.parameters.fillStyle !== void 0 ? this.parameters.fillStyle : "#ff0", this._padding = this.parameters.padding !== void 0 ? this.parameters.padding : [2, 2], this.strokeStyle = this.parameters.strokeStyle, this._lineWidth = this.parameters.lineWidth, this.isRenderInPostprocess = this.parameters.isRenderInPostprocess || !1, this.cachedData = [], this.drawingData = [];
    const r = this.canvas = document.createElement("canvas");
    r.width = r.height = 1;
    const s = this.ctx = r.getContext("2d");
    s.textAlign = "start", s.textBaseline = "top", this.defineMaterialProxyProperties([
      "lineHeight",
      "map",
      "pixelOffsetX",
      "pixelOffsetY",
      "positionOffsetX",
      "positionOffsetY",
      "positionOffsetZ",
      "backgroundColor",
      "resolution",
      "opacity",
      "flat",
      "emissive",
      "keepSize"
    ]);
  }
  initObject() {
    let {
      padding: e,
      fillStyle: r,
      strokeStyle: s,
      lineWidth: a,
      fontSize: c,
      fontFamily: l,
      vertexStyles: h,
      ...d
    } = this.parameters;
    const f = this.engine.map.isGlobe;
    this.geometry = new BufferGeometry(this.parameters), this.material = new DefaultTextMaterial(d), this.material.isGlobe = f, this.material.setCommonUniforms(this.engine.rendering.uniforms), this.texture = new CanvasTexture(this.canvas), this.texture.minFilter = LinearFilter, this.texture.magFilter = LinearFilter, this.texture.generateMipmaps = !1, this.material.uniforms.map.value = this.texture;
  }
  _updateData() {
    this._enableCollision && this._collisionData ? (this.cachedData = this.sortByStyle(this._collisionData), curStyleId$1 = null) : (this.cachedData = this.sortByStyle(this.dataSource.userData).map((e) => {
      let r = this.collisionTest(e);
      return {
        ...e,
        w: r.width,
        h: r.height
      };
    }), curStyleId$1 = null), this.update();
  }
  onBeforeScenePrepareRenderHook(e, r, s) {
    const a = e.rendering.main.sceneRendering.depthTexture;
    this.material.uniforms.depthTexture.value = a, this.material.uniforms.cameraFar.value = e.rendering.camera.far;
  }
  update() {
    this.updateRenderingData();
  }
  collisionTest(e) {
    const r = this.ctx, s = this.engine.rendering.pixelRatio, a = this._fontSize, c = this._fontFamily, l = this._padding;
    r.save(), r.scale(s, s), r.textBaseline = "top";
    let h = "";
    if (this.parameters.vertexStyles) {
      let { text: E, fontWeight: b, fontSize: w, lineWidth: M } = e;
      h += `${E}_${w}_${b}_${M}`;
    } else
      h += `${e.text}_${a}`;
    if (this._collisionBoxCache[h])
      return this._collisionBoxCache[h];
    let d = a;
    const f = this.getStrictStyleId(e);
    if (this.parameters.vertexStyles && f !== curStyleId$1) {
      let { fontWeight: E, fontSize: b, lineWidth: w } = e;
      E >= 10 && E % 10 === 0 ? r.font = E * 10 + " " + b + "px " + c : r.font = b + "px " + c, d = b, w > 0 && (r.lineWidth = w);
    } else
      r.font = a + "px " + c;
    let p = String(e.text).split("\\");
    const m = p.map((E) => r.measureText(E).width);
    let y = Math.max(...m), x = d * p.length;
    const v = y + 2 * l[0], S = x + 2 * l[1];
    return r.restore(), this._collisionBoxCache[h] = {
      width: v,
      height: S
    }, {
      width: v,
      height: S
    };
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
  getEntityByIndex(e) {
    const r = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const s = {
      index: e,
      value: r.getDataItem(e),
      itemIndex: r.getDataItemIndex(e),
      pairs: {}
    }, a = r.data;
    for (const c of Object.keys(a))
      s.pairs[c] = a[c][e];
    return s;
  }
  raycast(e, r) {
    const s = this.flat;
    if (!this.visible || s)
      return;
    const a = this.geometry, c = a.getAttribute("position");
    if (!c || !c.array || !c.array.length === 0)
      return;
    let l = e.camera;
    l || (l = this.engine.camera);
    const h = e.mouse;
    if (!h)
      return;
    const d = this.material.uniforms.resolution.value, f = h.x, p = h.y;
    let m = [];
    const y = a.getAttribute("wh");
    y && (m = y.array);
    let x = 0, v = 0, S = 0, E = 0, b = 0, w = 0;
    _tempMatrix4.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse), _tempMatrix4.multiplyMatrices(_tempMatrix4, this.matrixWorld);
    const M = c.array;
    let P = 0, D = 1;
    this.keepSize || (D = this.material.uniforms.zoomUnits.value);
    for (let L = 0, O = M.length - 11; L < O; L += 12)
      if (_tempVector4.set(
        M[L],
        M[L + 1],
        M[L + 2],
        1
      ), _tempVector4.applyMatrix4(_tempMatrix4), _tempVector4.divideScalar(_tempVector4.w), P = L / 12 * 8, b = m[P] / d.x, w = m[P + 1] / d.y, x = _tempVector4.x - b / D, S = _tempVector4.x + b / D, v = _tempVector4.y - w / D, E = _tempVector4.y + w / D, x <= f && S >= f && v <= p && E >= p) {
        _tempVector3.set(M[L], M[L + 1], M[L + 2]), _tempVector3.applyMatrix4(this.matrixWorld);
        const k = {
          instanceId: L / 12,
          object: this,
          distance: _tempVector3.distanceTo(l.position)
        };
        r.push(k);
      }
  }
  set fontSize(e) {
    this._fontSize !== e && (this._fontSize = e, this._collisionBoxCache = {}, this.needsUpdate = !0, this.engine.requestRender());
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this._collisionBoxCache = {}, this.needsUpdate = !0, this.engine.requestRender());
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fillStyle(e) {
    this._fillStyle = e, this.needsUpdate = !0, this.engine.requestRender();
  }
  get fillStyle() {
    return this._fillStyle;
  }
  set strokeStyle(e) {
    this._shouldStroke = !!e, this._strokeStyle = e, this.needsUpdate = !0, this.engine && this.engine.requestRender();
  }
  get strokeStyle() {
    return this._strokeStyle;
  }
  set lineWidth(e) {
    this._lineWidth = e, this.needsUpdate = !0, this.engine.requestRender();
  }
  get lineWidth() {
    return this._lineWidth;
  }
  set padding(e) {
    this._padding !== e && (this._padding = e, this._collisionBoxCache = {}, this.needsUpdate = !0, this.engine.requestRender());
  }
  get padding() {
    return this._padding;
  }
}
const vertexShader$2 = `#define GLSLIFY 1
#include <common>

uniform float positionOffsetX;
uniform float positionOffsetY;
uniform float pixelOffsetX;
uniform float pixelOffsetY;
uniform float positionOffsetZ;
uniform bool uFlat;

attribute float pIndex;
attribute vec4 iconFrame;
attribute vec2 wh;
attribute vec4 strokeStyle;
attribute vec3 fillStyle;
attribute vec4 sizeAndOffset;

#ifdef IS_ALIGN_ROTATE
attribute float verticalOffsets;
#endif

varying vec4 vStrokeStyle;
varying vec3 vFillStyle;
varying float vFontSize;

#ifdef IS_GLOBE
    attribute mat4 ecefMatrix;
#endif

#ifdef MVT_USE_VERTEX_ROTATEZ
    attribute float aRotateZ;
# else
    uniform float uRotateZ;
#endif

uniform float elapsedTime;
#ifdef MVT_ENABLE_FADE
    attribute float fadeOpacity;
    attribute float fadeSince;
    uniform float fadeDuration;
    varying float vFadeOpacity;
#endif

varying vec2 vUv;
#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

vec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {
    float x = coord.x;
    float y = coord.y;
    if (corner == 1.0) {
        // \u5DE6\u4E0A
        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);
    } else if (corner == 2.0) {
        // \u53F3\u4E0A
        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else if (corner == 3.0) {
        // \u53F3\u4E0B
        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else {
        // \u5DE6\u4E0B
        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);
    }
    return vec3(x, y, coord.z);
}

void main() {
    #include <mvt_selective_vertex>
    // float x = position.x;
    // float y = position.y;
    vUv = uv;

    float rotateZ;
    #ifdef MVT_USE_VERTEX_ROTATEZ
        rotateZ = aRotateZ;
    # else
        rotateZ = uRotateZ;
    #endif

    mat4 currentInstanceMatrix = mat4(1.0);
    vec3 currentPosition = position;
    #ifdef IS_GLOBE
        currentInstanceMatrix = ecefMatrix;

        currentInstanceMatrix[3][0] = position.x;
        currentInstanceMatrix[3][1] = position.y;
        currentInstanceMatrix[3][2] = position.z;

        currentPosition = vec3(0.0, 0.0, 0.0);
    #endif

    float width = iconFrame.z;
    float height = iconFrame.w;
    float scale = sizeAndOffset.x / height;

    currentPosition.x += positionOffsetX;
    currentPosition.y += positionOffsetY;
    currentPosition.z += positionOffsetZ;
   vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));
    if (uFlat) {
        // viewMatrix[0]\u8868\u793A\u76F8\u673A\u7684\u53F3\u65B9\u5411\uFF0C\u4E0D\u7BA1\u76F8\u673A\u5982\u4F55\u503E\u659Ctilt\uFF0C\u6CD5\u5411\u91CF\u90FD\u6307\u5411\u6B63\u5317\u65B9\u5411\uFF0C\u6B63\u597D\u53EF\u4EE5\u7528\u6765\u8BA1\u7B97\u548C\u6587\u5B57\u7684\u5939\u89D2
        mat4 localViewMatrix = viewMatrix * currentInstanceMatrix;
        vec4 right = localViewMatrix[0];
        float cosTheta = dot(vec2(sin(rotateZ), cos(rotateZ)), vec2(-right.y, right.x));

        float rotateOffset = 0.0;
        #ifdef IS_ALIGN_ROTATE
        // \u7528\u4E8E\u5224\u65AD\u65B9\u5411
        float sinTheta = sin(rotateZ) * right.x - cos(rotateZ) * -right.y;

        // [-\u03C0, \u03C0] + 0.25 PI
        float theta = atan(sinTheta, cosTheta) + PI * 0.25;
        if (theta < 0.0) {
            theta += 2.0 * PI;
        }

        float deg = degrees(theta);

        float isVertical = 0.0;
        // \u6839\u636E theta \u5212\u5206\u8C61\u9650
        if (deg >= 90.0 && deg < 180.0) {
            rotateOffset = -PI * 0.5;
            rotateZ += PI;
            isVertical = 1.0;
        } else if (deg >= 180.0 && deg < 270.0) {
            rotateZ += PI;
        } else if (deg >= 270.0){
            rotateOffset = -PI * 0.5;
            isVertical = 1.0;
        }
        #else
        if (cosTheta < 0.0) {
            rotateZ += PI;
        }
        #endif

        // TODO \u652F\u6301offset
        float hw = width * 0.5 * scale;
        float hh = height * 0.5 * scale;

        float pixelSize = 1.0;
        if (keepSize) {
            pixelSize = getPixelSize(worldPosition.xyz);
            // pixelSize = pixelSize * 2.0;
            hw = hw * pixelSize;
            hh = hh * pixelSize;

        }

        vec3 current = currentPosition;

        #ifdef IS_ALIGN_ROTATE
        float xOffset = isVertical == 1.0 ? ((verticalOffsets - sizeAndOffset.w) * pixelSize * scale) : sizeAndOffset.z * pixelSize * scale;
        float yOffset = isVertical == 1.0 ? 0.0 : sizeAndOffset.w * pixelSize * scale;
        #else
        float xOffset = sizeAndOffset.z * pixelSize * scale;
        float yOffset = sizeAndOffset.w * pixelSize * scale;
        #endif

        xOffset += pixelOffsetX * scale;
        yOffset += pixelOffsetY * scale;

        current = transformCoord(current, vec2(hw, hh), pIndex, -rotateZ + rotateOffset);
        current = transformCoord(current, vec2(xOffset, yOffset), 2.0, -rotateZ);

        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);

        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    }
    else {
        // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);
        vec4 pos = projectionMatrix * viewMatrix * worldPosition;
        float w = pos.w;
       
        vec3 screen = pos.xyz / w;

        float hw = width / resolution.x * scale;
        float hh = height / resolution.y * scale;

        float pixelSize = 1.0;
        if (!keepSize) {
            pixelSize = getPixelSize(worldPosition.xyz);
            pixelSize = pixelSize * 2.0;

            hw /= pixelSize;
            hh /= pixelSize;
        }

        vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -rotateZ);
        current.x += sizeAndOffset.z * 2.0 / resolution.x * scale / pixelSize + pixelOffsetX / resolution.x;
        current.y += sizeAndOffset.w * 2.0 / resolution.y * scale / pixelSize + pixelOffsetY / resolution.y;
        gl_Position = vec4(current, 1.0);

        gl_Position *= w;
    }

    #ifdef MVT_ENABLE_FADE
        float fadeDiff = (elapsedTime - fadeSince) / fadeDuration;
        if (fadeOpacity > 2.0) {
            fadeDiff = clamp(fadeDiff, 0.0, 1.0);
            vFadeOpacity = fadeOpacity - fadeDiff - 2.0;
            vFadeOpacity = vFadeOpacity * vFadeOpacity;
        } else {
            vFadeOpacity = fadeOpacity + fadeDiff;
            vFadeOpacity = sqrt(vFadeOpacity);
        }
        vFadeOpacity = clamp(vFadeOpacity, 0.0, 1.0);
    #endif

    vStrokeStyle = strokeStyle;
    vFillStyle = fillStyle;

    vFontSize = sizeAndOffset.y;

    #include <logdepthbuf_vertex>
    // gl_PointSize = size * pixelRatio;
    // vSize = size;
    // vOffset = offset;
}`, fragmentShader$2 = `#define GLSLIFY 1
#include <common>

#define SDF_BUFFER 6.0
#define SDF_PX 8.0

uniform sampler2D map;
uniform vec4 backgroundColor;
uniform float opacity;
uniform float lineHeight;
uniform vec3 color;
uniform float sdfBuffer;
uniform float pixelRatio;
uniform float isHalo;
varying vec2 vUv;

varying vec4 vStrokeStyle;
varying vec3 vFillStyle;
varying float vgamma_scale;
varying float vFontSize;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

#ifdef MVT_ENABLE_FADE
    varying float vFadeOpacity;
#endif
void main() {
    #include <logdepthbuf_fragment>

    float fontScale = vFontSize / 24.0;
    float gamma = (0.105 / pixelRatio) / fontScale;
    float buff = (256.0 - 64.0) / 256.0;

    vec3 outColor = vFillStyle;

    if (isHalo > 0.0) {
        if (vStrokeStyle.w > 0.0) {
          outColor = vStrokeStyle.xyz;
          buff = (SDF_BUFFER - vStrokeStyle.w / fontScale) / SDF_PX;
        }
    }

    float distance = texture2D(map, vec2(vUv.x, vUv.y)).r;
    float alpha = smoothstep(buff - gamma, buff + gamma, distance);

    alpha = clamp(alpha * 1.5, 0.0, 1.0);

    gl_FragColor = vec4(outColor, alpha);

    #ifdef MVT_ENABLE_FADE
        gl_FragColor.a *= vFadeOpacity;
    #endif
    
    #include <mvt_selective_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}`, uniforms$2 = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  emissiveUniforms,
  {
    map: {
      value: null
    },
    pixelRatio: {
      value: 1
    },
    lineHeight: {
      value: 14
    },
    pixelOffsetX: {
      value: 0
    },
    pixelOffsetY: {
      value: 0
    },
    positionOffsetX: {
      value: 0
    },
    positionOffsetZ: {
      value: 0
    },
    positionOffsetY: {
      value: 0
    },
    backgroundColor: {
      value: [1, 1, 0, 0]
    },
    uFlat: {
      value: !1
    },
    opacity: {
      value: 1
    },
    isEmissive: {
      value: !1
    },
    uRotateZ: {
      value: 0
    },
    keepSize: {
      value: !0
    },
    outlineBuffer: {
      value: 0
    },
    outlineColor: {
      value: new Color(0)
    },
    color: {
      value: new Color(16777215)
    },
    sdfBuffer: {
      value: 0.75
    },
    gamma: {
      value: 0.1
    },
    isHalo: {
      value: 0
    },
    fadeDuration: {
      value: 300
    }
  }
]);
class SDFTextMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "SDFTextMaterial", this.vertexShader = vertexShader$2, this.fragmentShader = fragmentShader$2, this.isSDFTextMaterial = !0, this.transparent = !0, this.depthTest = !1, this.depthWrite = !1, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$2)), defineMaterialSelectiveProperties(this), defineMaterialKeepSizeProperties(this), defineMaterialNormalProperties(this, [
      "lineHeight",
      "pixelRatio",
      "map",
      "pixelOffsetX",
      "pixelOffsetY",
      "positionOffsetX",
      "positionOffsetY",
      "positionOffsetZ",
      "backgroundColor",
      "resolution",
      "opacity",
      "isEmissive",
      "isHalo",
      "fadeDuration"
    ]), defineMaterialAliasProperties(this, [
      ["flat", "uFlat"],
      ["rotateZ", "uRotateZ"]
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexRotateZs", "MVT_USE_VERTEX_ROTATEZ"],
      ["isGlobe", "IS_GLOBE"],
      ["alignRotate", "IS_ALIGN_ROTATE"],
      ["enableFade", "MVT_ENABLE_FADE"]
    ]), defineMaterialEmissiveProperties(this), defineMaterialColorProperties(this, [
      "color"
    ]), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(i);
  }
}
class GeoGroup extends GeoObject {
  constructor() {
    super(...arguments);
    _(this, "isGroup", !0);
  }
}
let curStyleId;
const TEXT_ALIGN = {
  center: 0,
  left: 1,
  right: -1
}, getPixelSize = (o, i, e) => 0.2 * Math.tan(i / 2) * o / e * 10, SDF_SCALE = 2, fontSettings = {
  fontSize: 24 * SDF_SCALE,
  buffer: 3 * SDF_SCALE,
  radius: 8 * SDF_SCALE
}, positionScratch$1 = new Vector3$1(), defaultTextStyle = {
  fontSize: 16,
  fontWeight: "400",
  fillStyle: [1, 1, 0],
  strokeStyle: [0, 0, 0],
  lineWidth: 0
};
class SDFText extends GeoGroup {
  constructor(e) {
    super(e);
    _(this, "frustumCulled", !0);
    _(this, "_needsUpdate", !1);
    _(this, "_enableFade", !1);
    _(this, "texture", null);
    _(this, "_padding", [0, 0]);
    _(this, "_characterSet", getDefaultCharacterSet());
    _(this, "_collisionBoxCache", {});
    _(this, "_sdfTextureNeedUpdate", !1);
    _(this, "updateRenderingData", () => {
      const [e, r] = this.material.resolution || [], s = this.engine.map.isGlobe;
      let a = new Matrix4();
      if (isNaN(e) || e <= 0 || isNaN(r) || r <= 0) {
        console.warn("resolution is invalid");
        return;
      }
      const c = 1, l = "break-word", h = -1, d = [], f = [], p = [], m = [], y = [], x = [], v = [], S = [], E = [], b = [], w = [], M = [], P = [], {
        mapping: D,
        width: L,
        height: O
      } = this.fontAtalasManager.atlas || {};
      let F = [0], k = 0, V = null;
      for (let U = 0; U < this.cachedData.length; U++) {
        V = this.cachedData[U];
        const z = V.position;
        V.index;
        const $ = V.text, G = V.textStyle, {
          fontSize: j = this._fontSize,
          fontWeight: Y = this._fontWeight,
          lineWidth: H = this._lineWidth,
          strokeStyle: W = this._strokeStyle,
          fillStyle: q = this._fillStyle,
          rotateZ: Z = 0,
          hOffset: X = 0,
          vOffset: K = 0,
          offset: ee = [0, 0]
        } = G || {}, ie = Array.from($).map((fe) => fe + Y), re = this._letterSpacing * this._fontSettings.fontSize, {
          x: ne,
          y: J,
          rowWidth: oe,
          rowNum: _e,
          heightSize: le,
          textHeights: de,
          size: [ce, Re]
        } = transformParagraph(
          $,
          ie,
          c,
          l,
          h * j,
          D,
          re
        ), Ee = ne.length;
        k = k + F[U];
        const Le = Array.from($);
        let ke = 0, se = 0;
        const pe = le / 2;
        for (let fe = 0; fe < Ee; fe++) {
          const Ce = Le[fe];
          if (Ce === "\\")
            continue;
          const He = D[Ce + Y];
          if (!He)
            return;
          if (s) {
            a = Transforms.eastNorthUpToFixedFrame(
              positionScratch$1.fromArray(z),
              null,
              a
            ), a.elements[12] = 0, a.elements[13] = 0, a.elements[14] = 0;
            for (let Te = 0; Te < 4; Te++)
              for (let ye = 0; ye < 16; ye++)
                S.push(a.elements[ye]);
          }
          if (p.push(0, 1, 2, 3), this.alignRotate) {
            const Te = de[fe], ye = se + Te / 2 - pe;
            se += Te, w.push(
              ye,
              ye,
              ye,
              ye
            );
          }
          const Me = (k + ke) * 4;
          m.push(
            Me,
            Me + 2,
            Me + 1,
            Me,
            Me + 3,
            Me + 2
          ), d.push(
            ...z,
            ...z,
            ...z,
            ...z
          );
          let { x: Be, y: Se, width: Oe, height: Ie } = He;
          Oe += this._fontSettings.buffer * 2, f.push(
            Be,
            Se,
            Oe,
            Ie,
            Be,
            Se,
            Oe,
            Ie,
            Be,
            Se,
            Oe,
            Ie,
            Be,
            Se,
            Oe,
            Ie
          );
          const ze = Be / L, $e = Se / O, We = ze + Oe / L, st = $e + Ie / O;
          y.push(
            ze,
            st,
            ze,
            $e,
            We,
            $e,
            We,
            st
          );
          const ut = (1 - TEXT_ALIGN[this.textAlign]) * (ce - oe[fe]) / 2, dt = ee[0] * j + X, ft = ee[1] * j + K, Fe = (0 - 1) * ce / 2 + ut + ne[fe] + dt, Ne = Re / _e * (_e - 1) / 2 - J[fe] + ft, Ve = j * (Ie / this._fontSettings.fontSize);
          if (b.push(
            Ve,
            j,
            Fe,
            Ne,
            Ve,
            j,
            Fe,
            Ne,
            Ve,
            j,
            Fe,
            Ne,
            Ve,
            j,
            Fe,
            Ne
          ), x.push(
            W[0],
            W[1],
            W[2],
            H,
            W[0],
            W[1],
            W[2],
            H,
            W[0],
            W[1],
            W[2],
            H,
            W[0],
            W[1],
            W[2],
            H
          ), v.push(
            q[0],
            q[1],
            q[2],
            q[0],
            q[1],
            q[2],
            q[0],
            q[1],
            q[2],
            q[0],
            q[1],
            q[2]
          ), this.parameters.vertexRotateZs && E.push(Z, Z, Z, Z), this._enableFade) {
            const Te = V.fadeOpacity || 1e-3, ye = V.fadeSince || 0;
            M.push(Te, Te, Te, Te), P.push(ye, ye, ye, ye);
          }
          ke++;
        }
        F.push(ke);
      }
      const N = this.geometry;
      N.setAttribute("position", new Float32BufferAttribute(d, 3)), N.setAttribute("pIndex", new Float32BufferAttribute(p, 1)), N.setAttribute("sizeAndOffset", new Float32BufferAttribute(b, 4)), N.setAttribute("iconFrame", new Float32BufferAttribute(f, 4)), N.setAttribute("uv", new Float32BufferAttribute(y, 2)), N.setAttribute("strokeStyle", new Float32BufferAttribute(x, 4)), N.setAttribute("fillStyle", new Float32BufferAttribute(v, 3)), this.alignRotate && N.setAttribute("verticalOffsets", new Float32BufferAttribute(w, 1)), s && N.setAttribute("ecefMatrix", new Float32BufferAttribute(S, 16)), this.parameters.vertexRotateZs && N.setAttribute("aRotateZ", new Float32BufferAttribute(E, 1)), this._enableFade && (N.setAttribute("fadeOpacity", new Float32BufferAttribute(M, 1)), N.setAttribute("fadeSince", new Float32BufferAttribute(P, 1))), N.setIndex(m), N.computeBoundingSphere(), this.makeGeometryOffsetPosition(N, d), this.needsUpdate = !1, this._enableFade && (this.material[0].fadeDuration = this._fadeData.fadeDuration, this.material[1].fadeDuration = this._fadeData.fadeDuration);
    });
    _(this, "getStrictStyleId", (e) => {
      if (this.parameters.vertexStyles) {
        let {
          fontSize: r,
          fontWeight: s,
          lineWidth: a,
          fillStyle: c = [],
          strokeStyle: l = []
        } = e;
        return `${r}_${s}_${a}_${c[0]}_${c[1]}_${c[2]}_${l[0]}_${l[1]}_${l[2]}`;
      }
      return 0;
    });
    this.parameters = e, this._flat = defaultValue$1(this.parameters.flat, !1), this._fontSize = defaultValue$1(this.parameters.fontSize, defaultTextStyle.fontSize), this._fontWeight = defaultValue$1(this.parameters.fontWeight, defaultTextStyle.fontWeight), this._letterSpacing = defaultValue$1(this.parameters.letterSpacing, 0);
    const r = defaultValue$1(this.parameters.fillStyle, defaultTextStyle.fillStyle);
    Array.isArray(r) ? this._fillStyle = r : this._fillStyle = colorToArr4(r), this._lineWidth = defaultValue$1(this.parameters.lineWidth, defaultTextStyle.lineWidth), this.outlineWidth = defaultValue$1(this.parameters.lineWidth, defaultTextStyle.lineWidth);
    const s = defaultValue$1(this.parameters.strokeStyle, defaultTextStyle.strokeStyle);
    Array.isArray(s) ? this._strokeStyle = s : this._strokeStyle = colorToArr4(s), this._fontFamily = defaultValue$1(this.parameters.fontFamily, "Microsoft Yahei"), this._padding = defaultValue$1(this.parameters.padding, [2, 2]), this._margin = defaultValue$1(this.parameters.margin, [0, 0]), this.textAlign = defaultValue$1(this.parameters.textAlign, "center"), this.alignRotate = defaultValue$1(this.parameters.alignRotate, !1), this._enableFade = defaultValue$1(this.parameters.enableFade, !1), this.cachedData = [], this.shouldUpdateRenderingData = !1, this.drawingData = [], this._fadeData = new FadeData();
    const a = this.canvas = document.createElement("canvas");
    a.width = a.height = 1;
    const c = this.ctx = a.getContext("2d");
    c.textAlign = "start", c.textBaseline = "top", this.matrixAutoUpdate = !0;
  }
  initObject() {
    const {
      fillStyle: e,
      strokeStyle: r,
      fontFamily: s,
      vertexStyles: a,
      ...c
    } = this.parameters;
    this.geometry = new BufferGeometry(this.parameters);
    const l = new SDFTextMaterial(c);
    l.setCommonUniforms(this.engine.rendering.uniforms), l.isHalo = 0, l.enableFade = this._enableFade;
    const h = new SDFTextMaterial(c);
    h.setCommonUniforms(this.engine.rendering.uniforms), h.isHalo = 1, h.enableFade = this._enableFade, this.material = [l, h], this.defineMaterialProperties([
      "lineHeight",
      "pixelRatio",
      "map",
      "pixelOffsetX",
      "pixelOffsetY",
      "positionOffsetX",
      "positionOffsetY",
      "positionOffsetZ",
      "backgroundColor",
      "resolution",
      "opacity",
      "flat",
      "isGlobe",
      "alignRotate"
    ]), this.add(new Mesh(this.geometry, h)), this.add(new Mesh(this.geometry, l));
    const d = this.engine.map.isGlobe;
    this.material.isGlobe = d;
    const f = `${this.fontFamily} ${this._fontWeight}`;
    this.fontStack = f;
    const p = new FontAtlasManager();
    this.fontAtalasManager = p;
  }
  onBeforeSceneRender(e, r, s, a) {
    super.onBeforeSceneRender(e, r, s, a), this._enableFade && !this._fadeData.isStable(a.elapsedTime) && e.requestRender();
  }
  update() {
    this.updateRenderingData();
  }
  updateSdfTexture() {
    if (this._sdfTextureNeedUpdate) {
      this._fontSettings = {
        fontFamily: this._fontFamily,
        fontWeight: "400",
        characterSet: this._characterSet,
        sdf: !0,
        ...fontSettings
      }, this.fontAtalasManager.setProps(this._fontSettings);
      const {
        textureData: e,
        width: r,
        height: s
      } = this.fontAtalasManager.atlas;
      if (!this.texture) {
        const a = new Uint8Array(r * s);
        this.texture = new DataTexture(a, r, s), this.texture.minFilter = this.texture.magFilter = LinearFilter, this.texture.format = RedFormat;
      }
      this.texture.image.data.set(e), this.texture.needsUpdate = !0, this.material.map = this.texture, this._sdfTextureNeedUpdate = !1;
    }
  }
  _updateData() {
    this._enableCollision && this._collisionData ? this.cachedData = this._collisionData : this.cachedData = this.dataSource.userData.map((l) => {
      let h = this.collisionTest(l);
      return {
        ...l,
        w: h.width,
        h: h.height
      };
    }), this._enableFade && (this._fadeData.update(this.cachedData, this.engine.rendering.uniforms.elapsedTime.value), this.cachedData = this._fadeData.data);
    let e = {};
    this.fontAtalasManager && this.fontAtalasManager.mapping && (e = this.fontAtalasManager.mapping);
    let r = /* @__PURE__ */ new Map(), s = !1;
    const a = this.cachedData, c = a.length;
    for (let l = 0; l < c; l++) {
      const h = a[l], d = h.text, f = h.textStyle || {}, p = {
        fontSize: defaultValue$1(f.fontSize, this._fontSize),
        fontWeight: defaultValue$1(f.fontWeight, this._fontWeight),
        lineWidth: defaultValue$1(f.lineWidth, this._lineWidth),
        fillStyle: defaultValue$1(f.fillStyle, this._fillStyle),
        strokeStyle: defaultValue$1(f.strokeStyle, this._strokeStyle)
      }, m = Array.from(d);
      for (let y = 0, x = m.length; y < x; y++) {
        const v = m[y], S = v + p.fontWeight;
        r.set(S, {
          char: v,
          textStyle: p
        }), e[S] || (s = !0);
      }
    }
    s && (this._sdfTextureNeedUpdate = !0, this._characterSet = r.values()), this.updateSdfTexture(this._characterSet), this.update();
  }
  _setupCanvas(e, r) {
    e.save(), e.scale(r, r), e.textBaseline = "top";
  }
  _calculateTransform(e, r) {
    return this.engine.map.isGlobe ? (r || (r = new Matrix4()), Transforms.eastNorthUpToFixedFrame(positionScratch$1.fromArray(e), null, r), r.extractRotation(r), r) : defaultValue$1.EMPTY_MAT4;
  }
  _processTextStyle(e = {}) {
    return {
      fontSize: defaultValue$1(e.fontSize, this._fontSize),
      fontWeight: defaultValue$1(e.fontWeight, this._fontWeight),
      lineWidth: defaultValue$1(e.lineWidth, this._lineWidth),
      fillStyle: defaultValue$1(e.fillStyle, this._fillStyle),
      strokeStyle: defaultValue$1(e.strokeStyle, this._strokeStyle),
      rotateZ: defaultValue$1(e.rotateZ, 0)
    };
  }
  _generateCacheName(e, r) {
    let s = "";
    if (this._flat) {
      const c = e.position.join("_");
      s += c;
    }
    if (this.parameters.vertexStyles) {
      const { fontWeight: a, fontSize: c, lineWidth: l } = r;
      s += `${e.text}_${c}_${a}_${l}`;
    } else
      s += `${e.text}_${this._fontSize}`;
    return s;
  }
  _calculateRotation(e, r, s) {
    const a = new Matrix4();
    a.multiplyMatrices(e, r);
    const c = a.elements[0], l = a.elements[1], h = Math.sin(s), d = Math.cos(s);
    return h * -l + d * c;
  }
  _calculateCharInfo(e, r, s, a, c, l) {
    const d = r.measureText(e).width;
    return {
      char: e,
      width: d + 2 * l[0],
      height: s,
      offsetX: a + d / 2,
      offsetY: c
    };
  }
  _calculatePixelSize(e, r) {
    const a = this._rendering.renderState.cameraOffset;
    r.sub(a);
    const c = e.position.distanceTo(r), l = e.fov * Math.PI / 180, h = this._rendering.resolution.y;
    return getPixelSize(c, l, h);
  }
  _processTextLayout(e, r, s) {
    const a = this.ctx, c = this._padding, l = String(e).split("\\"), d = -(r * l.length) / 2;
    return l.map((f, p) => {
      const m = [];
      let y = 0;
      for (let v = 0; v < f.length; v++) {
        const S = f[v], b = a.measureText(S).width;
        m.push({
          char: S,
          width: b,
          height: r,
          offsetX: 0,
          offsetY: -(d + r / 2 + p * r)
        }), y += b;
      }
      let x = -y / 2;
      for (let v = 0; v < m.length; v++) {
        const S = m[v];
        x += S.width / 2, S.offsetX = x, x += S.width / 2, S.width += 2 * c[0];
      }
      return m;
    });
  }
  _applyRotateZ(e, r, s) {
    const a = this.engine.camera.matrixWorld;
    return this._calculateRotation(a, s, r) < 0 && (r += Math.PI), e.map((l) => {
      const h = l.offsetX, d = l.offsetY;
      return {
        ...l,
        offsetX: h * Math.cos(r) - d * Math.sin(r),
        offsetY: h * Math.sin(r) + d * Math.cos(r)
      };
    });
  }
  collisionTest(e) {
    const r = this.ctx, s = this.engine.rendering.pixelRatio, a = this._fontSize, c = this._fontFamily, l = this._padding, h = this._processTextStyle(e.textStyle);
    this._setupCanvas(r, s);
    const d = this._generateCacheName(e, h);
    if (this._collisionBoxCache[d]) {
      const w = this._collisionBoxCache[d], M = w.chars;
      if (M) {
        const P = w.rotationMatrix, D = this._applyRotateZ(M, h.rotateZ, P);
        return {
          ...this._collisionBoxCache[d],
          chars: D
        };
      }
      return w;
    }
    let f = a;
    const p = this.getStrictStyleId(h);
    if (p === curStyleId) {
      let { fontWeight: w, fontSize: M, lineWidth: P } = h;
      w >= 10 && w % 10 === 0 ? r.font = w * 10 + " " + M + "px " + c : r.font = M + "px " + c, f = M, P > 0 && (r.lineWidth = P);
    } else
      r.font = a + "px " + c, curStyleId = p;
    if (this._flat) {
      const w = this._calculateTransform(e.position), P = this._processTextLayout(e.text, f, h).flat();
      return this._collisionBoxCache[d] = {
        chars: P,
        rotationMatrix: w
      }, {
        chars: this._applyRotateZ(P, h.rotateZ, w),
        rotationMatrix: w
      };
    }
    let y = String(e.text).split("\\");
    const x = y.map((w) => r.measureText(w).width);
    let v = Math.max(...x), S = f * y.length;
    const E = v + 2 * l[0], b = S + 2 * l[1];
    return r.restore(), this._collisionBoxCache[d] = {
      width: E,
      height: b
    }, {
      width: E,
      height: b
    };
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  set fontSize(e) {
    this._fontSize !== e && (this._fontSize = e, this._collisionBoxCache = {}, this._sdfTextureNeedUpdate = !0);
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this._collisionBoxCache = {}, this._sdfTextureNeedUpdate = !0);
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fillStyle(e) {
    this._fillStyle = e;
  }
  get fillStyle() {
    return this._fillStyle;
  }
  set padding(e) {
    this._padding !== e && (this._padding = e, this._collisionBoxCache = {});
  }
  get padding() {
    return this._padding;
  }
  set strokeStyle(e) {
    this._shouldStroke = !!e, this._strokeStyle = e;
  }
  get strokeStyle() {
    return this._strokeStyle;
  }
  get enableFade() {
    return this._enableFade;
  }
  set enableFade(e) {
    this._enableFade = e, this.material[0].enableFade = e, this.material[1].enableFade = e;
  }
  defineMaterialProperties(e = []) {
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      Object.defineProperty(this.material, s, {
        get: function() {
          return this && this[0][s];
        },
        set: function(a) {
          this.forEach((c) => {
            c[s] = a;
          });
        }
      });
    }
    this.defineMaterialProxyProperties(e);
  }
}
class GeoLine extends GeoObject {
  constructor() {
    super(...arguments);
    _(this, "isLine", !0);
    _(this, "isLineSegments", !0);
  }
}
class SparkGeometry extends BufferGeometry {
  constructor(i) {
    super(i), this.parameters = i;
  }
  setData(i) {
    const { vertexColors: e, vertexHeights: r } = this.parameters, { aPositions: s, indices: a, aColors: c, aHeights: l, aLengths: h } = i;
    this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("aLength", new Float32BufferAttribute(h, 1)), e && this.setAttribute("aColor", new Float32BufferAttribute(c, 4)), r && this.setAttribute("aHeight", new Float32BufferAttribute(l, 1)), this.setIndex(a);
  }
}
const vertexShader$1 = `#define GLSLIFY 1
#include <common>

attribute float aLength;

uniform float elapsedTime;
uniform float tailLength;
uniform float speed;
uniform float idle;

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec3 color;
#endif

#ifdef MVT_USE_VERTEX_HEIGHT
    attribute float aHeight;
#else
    uniform float height;
#endif

varying float vOpacity;
varying vec4 vColor;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() {
    #include <mvt_selective_vertex>

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = vec4(color, 1.0);
    #endif

    #include <begin_vertex>
    #include <project_vertex>

    #ifdef MVT_USE_VERTEX_HEIGHT
        float total = aHeight + tailLength;
    #else
        float total = height + tailLength;
    #endif
    float currentHeight = mod(elapsedTime * speed, total + idle * speed);
    vOpacity = (aLength - (currentHeight - tailLength)) / tailLength;
    // vOpacity = 1.;

    #include <logdepthbuf_vertex>
}`, fragmentShader$1 = `#define GLSLIFY 1
#include <common>

varying vec4 vColor;
varying float vOpacity;
uniform float opacity;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {
    if (vOpacity > 1.0 || vOpacity < 0.0) {
        discard;
    }
    gl_FragColor = vec4(vColor.rgb, vColor.a * vOpacity);
    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <colorspace_fragment>
}
`, uniforms$1 = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  emissiveUniforms,
  {
    isEmissive: { value: !1 },
    color: { value: [1, 1, 0] },
    height: { value: 100 },
    vertexColors: { value: !1 },
    vertexHeights: { value: !1 },
    tailLength: { value: 50 },
    speed: { value: 1 },
    opacity: { value: 1 },
    idle: { value: 2e3 }
  }
]);
class SparkMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "SparkMaterial", this.isSparkMaterial = !0, this.vertexShader = vertexShader$1, this.fragmentShader = fragmentShader$1, this.transparent = !0, Object.assign(this.uniforms, UniformsUtils.clone(uniforms$1)), defineMaterialSelectiveProperties(this), defineMaterialNormalProperties(this, [
      "isEmissive",
      "height",
      "tailLength",
      "speed",
      "idle",
      "opacity"
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexHeights", "MVT_USE_VERTEX_HEIGHT"]
    ]), defineMaterialEmissiveProperties(this), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(i);
  }
}
const positionScratch = new Vector3$1(), surfaceNormalScratch = new Vector3$1();
class Spark extends GeoLine {
  constructor(e) {
    super(e);
    _(this, "geometry");
    _(this, "material");
    _(this, "color");
    _(this, "vertexColors");
    _(this, "height");
    _(this, "vertexHeights");
    _(this, "speed");
    _(this, "tailLength");
    _(this, "idle");
    _(this, "emissive");
    this.parameters = e, this.defineMaterialProxyProperties([
      "color",
      "height",
      "tailLength",
      "speed",
      "idle",
      "emissive",
      "vertexColors",
      "vertexHeights"
    ]);
  }
  getDefaultParams() {
    return {
      height: 100
    };
  }
  initObject() {
    this.geometry = new SparkGeometry(this.parameters), this.material = new SparkMaterial(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  _updateData() {
    const e = this.engine.map.isGlobe, r = this.dataSource.data, s = [], a = [], c = [], l = [], h = [];
    for (let d = 0; d < r.position.length; d++) {
      let f = r.position[d];
      if (s.push(f[0], f[1], f[2]), e && this.engine.map.map._ellipsoid.geodeticSurfaceNormal(positionScratch.fromArray(f), surfaceNormalScratch), this.parameters.vertexHeights && r.height) {
        if (e) {
          const p = surfaceNormalScratch.multiplyScalar(r.height[d]);
          s.push(
            f[0] + p.x,
            f[1] + p.y,
            f[2] + p.z
          );
        } else
          s.push(f[0], f[1], f[2] + r.height[d]);
        c.push(r.height[d], r.height[d]), l.push(0, r.height[d]);
      } else {
        if (e) {
          const p = surfaceNormalScratch.multiplyScalar(r.height[d]);
          s.push(
            f[0] + p.x,
            f[1] + p.y,
            f[2] + p.z
          );
        } else
          s.push(f[0], f[1], f[2] + this.parameters.height);
        l.push(0, this.parameters.height);
      }
      if (this.parameters.vertexColors && r.color) {
        let p = colorToArr4(r.color[d]);
        a.push(
          p[0],
          p[1],
          p[2],
          p[3],
          p[0],
          p[1],
          p[2],
          p[3]
        );
      }
      h.push(d * 2, d * 2 + 1);
    }
    this.geometry.setData({
      aPositions: s,
      aColors: a,
      aHeights: c,
      aLengths: l,
      indices: h
    }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, s), this.needsUpdate = !1;
  }
}
const scaleFirst = new Vector3$1(), carto1 = new Vector3$1(), cartesian = new Vector3$1(), tempTrans = new Vector3$1(), lastPoint = new Vector3$1(), p0Scratch = new Vector3$1(), p1Scratch$1 = new Vector3$1();
function numberOfPoints(o, i, e) {
  let r;
  return o.isVector3 ? r = o.distanceTo(i) : r = getDistance(o, i), Math.ceil(r / e);
}
const cartoScratch = new Vector3$1(), cartesianScratch = new Vector3$1();
function extractHeights(o, i) {
  const e = o.length, r = new Array(e);
  for (let s = 0; s < e; s++)
    cartesianScratch.fromArray(o[s]), r[s] = i.cartesianToCartographic(cartesianScratch, cartoScratch).z;
  return r;
}
class SimpleLineGeometry extends BufferGeometry {
  constructor(i) {
    super(i), this._granularity = i.granularity || CesiumMath.RADIANS_PER_DEGREE, this._height = i.height || 0, this.parameters = i;
  }
  setData(i) {
    this._needsUpdate = !0, this.engine.map.isGlobe ? this.updateGeometry3D(i) : this.updateGeometryColumbus(i), this._needsUpdate = !1;
  }
  updateGeometryColumbus(i) {
    const { vertexColors: e } = this.parameters, r = [], s = [], a = [], c = [];
    let l = 0;
    for (let h = 0; h < i.position.length; h++) {
      const d = i.position[h], f = i.index[h];
      for (let p = 0; p < d.length - 1; p++) {
        const m = d[p], y = d[p + 1];
        if (r.push(
          m[0],
          m[1],
          m[2],
          y[0],
          y[1],
          y[2]
        ), c.push(l, l + 1), s.push(f, f), e && i.color) {
          let x = colorToArr4(i.color[h]);
          a.push(x[0], x[1], x[2], x[3]), a.push(x[0], x[1], x[2], x[3]);
        }
        l += 2;
      }
    }
    this.cachedPositions = r, this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("objectIndex", new Float32BufferAttribute(s, 1)), e && this.setAttribute("color", new Float32BufferAttribute(a, 4)), this.setIndex(c);
  }
  updateGeometry3D(i) {
    const { vertexColors: e } = this.parameters, r = [], s = [], a = [], c = [];
    let l = 0;
    const h = this._granularity, d = this.engine.map.map.ellipsoid || Ellipsoid.WGS84, f = CesiumMath.chordLength(
      h,
      d.maximumRadius
    );
    for (let p = 0; p < i.position.length; p++) {
      const m = i.position[p], y = i.index[p], x = i.color && i.color[p], v = extractHeights(m, d).map((b) => b + this._height), S = this.generateArc({
        positions: m,
        minDistance: f,
        ellipsoid: d,
        height: v
      }), E = S.length / 3;
      for (let b = 0; b < E - 1; b++) {
        if (r.push(
          S[b * 3],
          S[b * 3 + 1],
          S[b * 3 + 2],
          S[(b + 1) * 3],
          S[(b + 1) * 3 + 1],
          S[(b + 1) * 3 + 2]
        ), s.push(y, y), c.push(l, l + 1), e && x) {
          let w = colorToArr4(x);
          a.push(w[0], w[1], w[2], w[3]), a.push(w[0], w[1], w[2], w[3]);
        }
        l += 2;
      }
    }
    this.cachedPositions = r, this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("objectIndex", new Float32BufferAttribute(s, 1)), e && this.setAttribute("color", new Float32BufferAttribute(a, 4)), this.setIndex(c);
  }
  generateArc(i) {
    i || (i = {});
    const e = i.positions, r = e.length, s = i.ellipsoid || Ellipsoid.WGS84;
    let a = i.height || 0;
    const c = Array.isArray(a);
    if (r < 1)
      return [];
    if (r === 1) {
      tempTrans.fromArray(e[0]);
      const S = s.scaleToGeodeticSurface(tempTrans, scaleFirst);
      if (a = c ? a[0] : a, a !== 0) {
        const E = s.geodeticSurfaceNormal(S, cartesian);
        Cartesian3.multiplyByScalar(E, a, E), Cartesian3.add(S, E, S);
      }
      return [S.x, S.y, S.z];
    }
    let l = i.minDistance;
    defined$2(l) || (l = CesiumMath.chordLength(this._granularity, s.maximumRadius));
    let h = 0, d;
    for (let S = 0; S < r - 1; S++)
      h += numberOfPoints(e[S], e[S + 1], l);
    const f = (h + 1) * 3, p = new Array(f);
    let m = 0;
    const y = new Vector3$1();
    for (d = 0; d < r - 1; d++) {
      p0Scratch.fromArray(e[d]), p1Scratch$1.fromArray(e[d + 1]), y.crossVectors(p0Scratch, p1Scratch$1).normalize();
      const S = c ? a[d] : a, E = c ? a[d + 1] : a;
      m = generateCartesianArc(
        p0Scratch,
        p1Scratch$1,
        l,
        s,
        S,
        E,
        p,
        m
      );
    }
    lastPoint.set(...e[r - 1]);
    const x = s.cartesianToCartographic(lastPoint, carto1);
    return x.z = c ? a[r - 1] : a, s.cartographicToCartesian(x, cartesian).toArray(p, m), m += 3, p;
  }
}
class SimpleLine extends GeoLine {
  constructor(e) {
    super(e);
    _(this, "geometry");
    _(this, "material");
    _(this, "color");
    this.parameters = e, this.defineGeometryProxyProperties([
      "granularity"
    ]), this.defineMaterialColorProxyProperties([
      "color"
    ]);
  }
  initObject() {
    this.geometry = new SimpleLineGeometry(this.parameters), this.geometry.engine = this.engine, this.material = new LineBasicMaterial(this.parameters);
  }
  _updateData() {
    const e = this.dataSource.data;
    this.geometry.setData(e), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.needsUpdate = !1;
  }
}
class FatLine extends Polyline {
  constructor(i) {
    console.warn("FatLine is deprecated, use Polyline with flat=true instead."), super({
      ...i,
      flat: !0
    });
  }
}
const distanceScratch = new Vector3$1(), p1Scratch = new Vector3$1(), p2Scratch = new Vector3$1(), scaleToGeodeticHeightN1 = new Vector3$1(), scaleToGeodeticHeightN2 = new Vector3$1();
new Vector3$1();
const scaleToGeodeticHeightP2 = new Vector3$1(), scratchCartesian3Position1 = new Vector3$1(), scratchCartesian3Position4 = new Vector3$1(), createGeometryFromPositionsExtrudedPositions = [], getPointAtDistance = (o, i, e, r) => (Cartesian3.subtract(i, o, distanceScratch), Cartesian3.multiplyByScalar(
  distanceScratch,
  e / r,
  distanceScratch
), Cartesian3.add(o, distanceScratch, distanceScratch), [distanceScratch.x, distanceScratch.y, distanceScratch.z]), subdivideHeightsScratchArray = [], subdivideHeights = (o, i, e) => {
  const r = subdivideHeightsScratchArray;
  r.length = o;
  let s = 0;
  if (i === e) {
    for (s = 0; s < o; s++)
      r[s] = i;
    return r;
  }
  const c = (e - i) / o;
  for (let l = 0; l < o; l++) {
    const h = i + l * c;
    r[l] = h;
  }
  return r;
}, subdivideLineCount = (o, i, e) => {
  const r = o.distanceTo(i);
  return Math.ceil(r / e);
};
class WallGeometry extends BufferGeometry {
  constructor(e) {
    super();
    _(this, "isWallGeometry", !0);
    _(this, "_needsUpdate", !1);
    _(this, "isClockWise", (e) => {
      let r = e.length, s = 0;
      for (let a = r - 1, c = 0; c < r; a = c++)
        s += e[a][0] * e[c][1] - e[c][0] * e[a][1];
      return s < 0;
    });
    _(this, "subdivideLine", (e, r, s, a, c, l) => {
      const h = subdivideLineCount(e, r, s), d = e.distanceTo(r), f = d / h;
      c || (c = []), l || (l = []);
      const p = new Vector3$1(), m = new Vector3$1(), y = a.cartesianToCartographic(e, m).z, x = a.cartesianToCartographic(r, m).z, v = subdivideHeights(h, y, x), S = scaleToGeodeticHeightN1;
      let E = scaleToGeodeticHeightN2, b = scaleToGeodeticHeightP2, w = 0;
      for (let M = 0; M < h; M++) {
        const P = p.fromArray(getPointAtDistance(e, r, f * M, d));
        a.geodeticSurfaceNormal(P, S), b = a.scaleToGeodeticSurface(P, b), E = Cartesian3.multiplyByScalar(S, v[M], E), E = Cartesian3.add(b, E, E), l[w] = E.x, l[w + 1] = E.y, l[w + 2] = E.z, E = Cartesian3.multiplyByScalar(S, v[M] + this._height, E), E = Cartesian3.add(b, E, E), c[w] = E.x, c[w + 1] = E.y, c[w + 2] = E.z, w += 3;
      }
      return a.geodeticSurfaceNormal(r, S), b = a.scaleToGeodeticSurface(r, b), E = Cartesian3.multiplyByScalar(S, x, E), E = Cartesian3.add(b, E, E), l[w] = E.x, l[w + 1] = E.y, l[w + 2] = E.z, E = Cartesian3.multiplyByScalar(S, x + this._height, E), E = Cartesian3.add(b, E, E), c[w] = E.x, c[w + 1] = E.y, c[w + 2] = E.z, {
        topPositions: c,
        bottomPositions: l
      };
    });
    this._height = e.height || 100, this.parameters = e;
  }
  setData(e) {
    this._needsUpdate = !0, this.cachedData = e, this.updateGeometry();
  }
  computeWallGeometry3D(e, r, s, a) {
    let c, l, h, d, f, p = e.length;
    const m = CesiumMath.chordLength(
      s,
      r.maximumRadius
    );
    let y = 0;
    for (h = 0; h < p - 1; h++)
      y += subdivideLineCount(
        e[h],
        e[(h + 1) % p],
        m
      );
    const x = y + p - 1;
    l = x * 3, c = new Array(l * 2);
    const v = [], S = [];
    for (h = 0; h < p - 1; h++) {
      d = e[h], f = e[(h + 1) % p];
      const {
        topPositions: N,
        bottomPositions: U
      } = this.subdivideLine(
        d,
        f,
        m,
        r
      );
      v.push(...U), S.push(...N);
    }
    c = [
      ...v,
      ...v
    ], p = c.length;
    let E = [], b = 0;
    for (p /= 6, h = 0; h < p - 1; h++) {
      const N = h, U = N + 1, z = N + p, $ = z + 1;
      d = p1Scratch.fromArray(c, N * 3), f = p2Scratch.fromArray(c, U * 3), !Cartesian3.equalsEpsilon(
        d,
        f,
        CesiumMath.EPSILON10,
        CesiumMath.EPSILON10
      ) && (E[b++] = N + a, E[b++] = z + a, E[b++] = U + a, E[b++] = U + a, E[b++] = z + a, E[b++] = $ + a);
    }
    c = [
      ...S,
      ...v
    ], p = S.length / 3;
    const w = [];
    w.length = c.length;
    const M = [];
    M.length = p * 4;
    let P = new Vector3$1(), D = new Vector3$1(), L = new Vector3$1();
    new Vector3$1();
    let O = !0, F = new Vector3$1();
    const k = [];
    let V = 0;
    for (h = 0; h < x; h++) {
      P.fromArray(S, h * 3), L.fromArray(S, (h + 1) * 3);
      let N = h * 2, U = (h + l / 3) * 2;
      if (L.x === void 0) {
        M[N] = V, M[N + 1] = 1, M[U] = V, M[U + 1] = 0;
        continue;
      }
      k.push(P.distanceTo(L)), M[N] = V, M[N + 1] = 1, M[U] = V, M[U + 1] = 0, V += k[h];
    }
    for (h = 0; h < x; h++) {
      if (P.fromArray(S, h * 3), D.fromArray(v, h * 3), L.fromArray(S, (h + 1) * 3), (Cartesian3.equalsEpsilon(
        P,
        L,
        CesiumMath.EPSILON10
      ) || h === x - 1) && (O = !1), O) {
        const z = Cartesian3.subtract(
          L,
          P,
          scratchCartesian3Position4
        ), $ = Cartesian3.subtract(
          D,
          P,
          scratchCartesian3Position1
        );
        F = Cartesian3.normalize(
          Cartesian3.cross($, z, F),
          F
        ), k.push(P.distanceTo(L));
      }
      let N = h * 3, U = h * 3 + l;
      w[N] = F.x, w[N + 1] = F.y, w[N + 2] = F.z, w[U] = F.x, w[U + 1] = F.y, w[U + 2] = F.z, O = !0;
    }
    return {
      edgePositions: c,
      edgeIndices: E,
      edgeNormals: w,
      edgeUvs: M,
      totalDistance: Array.from({ length: x * 2 }, () => V)
    };
  }
  updateGeometry3D() {
    let e = this.cachedData;
    const r = this.engine.map.map.ellipsoid || Ellipsoid.WGS84, s = [], a = [], c = [], l = [], h = [];
    let d = 0, f = 0, p = e.position.length;
    for (d = 0; d < p; d++) {
      const m = e.position[d];
      this.parameters.vertexColors && colorToArr4(e.color[d]);
      const y = m.map((L) => new Vector3$1().fromArray(L));
      let v = EllipsoidTangentPlane.fromPoints(y, r).projectPointsOntoPlane(
        y,
        createGeometryFromPositionsExtrudedPositions
      );
      this.isClockWise(v.map((L) => L.toArray())) && y.reverse();
      const E = CesiumMath.RADIANS_PER_DEGREE, {
        edgePositions: b,
        edgeIndices: w,
        edgeNormals: M,
        edgeUvs: P,
        totalDistance: D
      } = this.computeWallGeometry3D(y, r, E, f);
      s.push(...b), a.push(...w), c.push(...M), l.push(...P), h.push(...D), f += b.length / 3;
    }
    this.cachedPositions = s, this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(l, 2)), this.setAttribute("totalDistance", new Float32BufferAttribute(h, 1)), this.setIndex(a);
  }
  updateGeometryColumbus() {
    let e = this.cachedData;
    const r = [], s = [], a = [], c = [], l = [], h = [], d = [];
    for (let f = 0; f < e.position.length; f++) {
      const p = e.position[f];
      e.index[f];
      const m = this.parameters.vertexColors ? colorToArr4(e.color[f]) : [1, 1, 1, 1], y = this.parameters.vertexHeights ? e.height[f] : this._height;
      let x = 0;
      const v = p.length;
      let S = r.length / 3, E = 0;
      for (let b = 0; b < v; b++) {
        const w = p[b], M = b < v - 1 ? p[b + 1] : null;
        if (M && isPointEqual(w, M))
          continue;
        const P = [w[0], w[1], w[2] + y];
        if (E > 0 && (x += getDistance(p[b - 1], w)), r.push(...w, ...P), h.push(...m, ...m), a.push(E / (v - 1), E / (v - 1)), l.push(x, x), s.push(x, 0, x, 1), E > 0) {
          const D = S + 2 * (E - 1);
          c.push(
            D,
            D + 1,
            D + 2,
            D + 2,
            D + 1,
            D + 3
          );
        }
        E++;
      }
      for (let b = 0; b < v; b++)
        d.push(x, x);
      S += v * 2;
    }
    this.cachedPositions = r, this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2)), this.setAttribute("counter", new Float32BufferAttribute(a, 1)), this.setAttribute("distances", new Float32BufferAttribute(l, 1)), this.setAttribute("totalDistance", new Float32BufferAttribute(d, 1)), this.parameters.vertexColors && this.setAttribute("aColor", new Float32BufferAttribute(h, 4)), this.setIndex(c);
  }
  updateGeometry() {
    this.engine.map.isGlobe ? this.updateGeometry3D() : this.updateGeometryColumbus(), this.computeBoundingSphere(), this._needsUpdate = !1;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this._height = e;
  }
}
const vertexShader = `#define GLSLIFY 1
#include <common>
#include <bsdfs>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec3 color;
#endif

attribute float counter;
attribute float totalDistance;
attribute float distances;

uniform float elapsedTime;
uniform bool vertexColors;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vDistance;
varying float vTotalDistance;

uniform vec2 mapScale;

#ifdef USE_ANIMATION
uniform float animationSpeed;
uniform float animationTailType;
// varying float vAnimationTailType;
uniform float animationTailRatio;
uniform float animationTailLength;
uniform float animationIdle;
varying float vAnimationOpacity;
#endif

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = vec4(color, 1.0);
    #endif

    vUV = uv / mapScale;
    vCounter = counter;
    vDistance = distances;
    vTotalDistance = totalDistance;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    #ifdef USE_ANIMATION
        if (animationTailType < 3.0) {
            float tailLength = animationTailType == 1.0 ? totalDistance * animationTailRatio : animationTailLength;
            float currentLength = mod(elapsedTime * animationSpeed, totalDistance + tailLength + animationIdle * animationSpeed);
            vAnimationOpacity = (distances - (currentLength - tailLength)) / tailLength;
        }
        else if (animationTailType == 3.0) {
            vAnimationOpacity = 1.0 - mod(elapsedTime * animationSpeed / 1000.0, 1.0) + uv.y;
        } 
        // else if (animationTailType == 4.0) {
        //     vAnimationTailType = animationTailType;
        // }
    #endif

    #include <beginnormal_vertex>
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    #include <fog_vertex>

    #include <logdepthbuf_vertex>
}`, fragmentShader = `#define GLSLIFY 1
#include <common>
#include <bsdfs>
#include <fog_pars_fragment>

#include <logdepthbuf_pars_fragment>
varying vec3 vLightFront;
varying vec3 vIndirectFront;

uniform sampler2D map;
uniform bool useMap;
uniform float minOpacity;
uniform float maxOpacity;
uniform float opacity;
uniform float elapsedTime;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vDistance;
varying float vTotalDistance;

#ifdef USE_ANIMATION
uniform float animationRatio;
uniform float animationBales;
uniform float animationSpeed;
varying float vAnimationOpacity;
uniform float animationTailType;
#endif

void main() {

    vec4 c = vColor;

    if(useMap) {
        vec4 texture = texture2D(map, vec2(vUV.x / vTotalDistance, vUV.y));
        c *= texture;
    }

    #ifdef USE_ANIMATION
        if (vAnimationOpacity > 1.0 || vAnimationOpacity < 0.0) {
            c.a = 0.0;
        }

        if(animationTailType == 4.) {
            float ratio = animationRatio;
            float bales = animationBales;
            if(animationRatio > 1.) {
                ratio = 1.;
            }
            if(animationRatio < .0) {
                ratio = .0;
            }
            if(animationBales < 1.) {
                bales = 1.;
            }
            if(mod((vUV.y - elapsedTime * animationSpeed * .0001), 1./bales) < ratio / bales) {
                c.a = (1. - vUV.y) * maxOpacity;
            } else {
                c.a = minOpacity;
            }
        } else {
            c.a *= vAnimationOpacity;
        }
    #endif

    gl_FragColor = c;
    gl_FragColor.a *= opacity;

    if (maxOpacity > minOpacity) {
        gl_FragColor.a = clamp(gl_FragColor.a, minOpacity, maxOpacity);
    }
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
}`, textureLoader = new TextureLoader(), uniforms = UniformsUtils.merge([
  UniformsLib.fog,
  selectiveUniforms,
  emissiveUniforms,
  {
    map: { value: null },
    mapScale: { value: [1, 1] },
    useMap: { value: !1 },
    color: { value: [0, 1, 1] },
    minOpacity: { value: 0 },
    maxOpacity: { value: 1 },
    opacity: { value: 1 },
    vertexColors: { value: !1 },
    elapsedTime: { value: 0 },
    enableAnimation: { value: !1 },
    animationSpeed: { value: 1 },
    animationTailType: { value: 3 },
    animationTailRatio: { value: 0.2 },
    animationTailLength: { value: 100 },
    animationIdle: { value: 1e3 },
    animationRatio: { value: 0.5 },
    animationBales: { value: 5 },
    isEmissive: { value: !1 }
  }
]);
class WallMaterial extends CommonShaderMaterial {
  constructor(i) {
    super(), this.name = "WallMaterial", this.isWallMaterial = !0, this.fog = !0, this.side = DoubleSide, this.forceSinglePass = !1, this.fragmentShader = fragmentShader, this.vertexShader = vertexShader, Object.assign(this.uniforms, UniformsUtils.clone(uniforms)), defineMaterialNormalProperties(this, [
      "map",
      "minOpacity",
      "maxOpacity",
      "opacity",
      "elapsedTime",
      "animationSpeed",
      "animationTailType",
      "animationTailRatio",
      "animationTailLength",
      "animationIdle",
      "animationBales",
      "animationRatio",
      "isEmissive"
    ]), defineMaterialColorProperties(this, [
      "color"
    ]), defineMaterialBoolDefineProperties(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["enableAnimation", "USE_ANIMATION"]
    ]), defineMaterialEmissiveProperties(this), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const r = this.mapSrc, s = "url_map";
          if (this.userData[s] === e)
            return;
          if (r && r.dispose(), !e) {
            this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[s];
            return;
          }
          const c = textureLoader.load(e);
          c.wrapS = c.wrapT = RepeatWrapping, c.colorSpace = SRGBColorSpace, this.uniforms.map.value = c, this.userData[s] = e, this.uniforms.useMap.value = !0;
        }
      },
      mapScale: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          typeof e == "number" ? this.uniforms.mapScale.value = [e, e] : this.uniforms.mapScale.value = e;
        }
      }
    }), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(i);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
class Wall extends GeoMesh {
  constructor(e) {
    super();
    _(this, "geometry");
    _(this, "material");
    _(this, "height");
    _(this, "color");
    _(this, "vertexColors");
    _(this, "map");
    _(this, "opacity");
    _(this, "minOpacity");
    _(this, "maxOpacity");
    _(this, "enableAnimation");
    _(this, "animationSpeed");
    _(this, "animationTailType");
    _(this, "animationTailRatio");
    _(this, "animationTailLength");
    _(this, "animationIdle");
    _(this, "animationRatio");
    _(this, "animationBales");
    this.parameters = e, this.defineGeometryUpdateProxyProperties([
      "height"
    ]), this.defineMaterialProxyProperties([
      "color",
      "vertexColors",
      "emissive",
      "map",
      "mapScale",
      "transparent",
      "opacity",
      "minOpacity",
      "maxOpacity",
      "enableAnimation",
      "animationSpeed",
      "animationTailType",
      "animationTailRatio",
      "animationTailLength",
      "animationIdle",
      "animationBales",
      "animationRatio"
    ]);
  }
  getDefaultParams() {
    return {
      height: 100
    };
  }
  initObject() {
    const { height: e, ...r } = this.parameters, s = this.geometry = new WallGeometry(this.parameters);
    s.engine = this.engine, (this.material = new WallMaterial(r)).setCommonUniforms(this.engine.rendering.uniforms);
  }
  _updateData() {
    const e = this.dataSource.data;
    this.geometry.setData(e), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.needsUpdate = !1;
  }
}
injectStyle(styleSheet);
window.MAPVTHREE_VERSION = "1.4.1";
window._disable_hmt || (window._hmt = window._hmt || [], function() {
  let o = document.createElement("script");
  o.src = "https://hm.baidu.com/hm.js?1baab79677df9b34e5e6db4315726094";
  let i = document.getElementsByTagName("script")[0];
  i.parentNode.insertBefore(o, i);
}());
export {
  AnimationModel,
  Baidu09ImageryTileProvider,
  BaiduMapConfig,
  BaiduTrafficTileProvider,
  BaiduVectorTileProvider,
  BallonPoint,
  BingImageryTileProvider,
  CSVDataSource,
  CesiumConfig,
  CesiumTerrainTileProvider,
  Circle,
  ClusterPoint,
  DOMOverlay,
  DOMPoint,
  DataItem,
  DataSource,
  Default3DTiles,
  DefaultSky,
  DynamicSky,
  DynamicWeather,
  EffectModelPoint,
  EffectPoint,
  EmptySky,
  Engine,
  FastTileLoaderStrategy,
  FatLine,
  GEOMETRY_TYPE_LINE,
  GEOMETRY_TYPE_POINT,
  GEOMETRY_TYPE_POLYGON,
  GLTFLoader$1 as GLTFLoader,
  GeoInstancedMesh,
  GeoJSONDataSource,
  Heatmap,
  Heatmap3D,
  HierarchicalTileLoaderStrategy,
  Icon,
  ImageryTileProvider,
  JSONDataSource,
  LODModel,
  Label,
  MapView,
  MapboxConfig,
  MapboxVectorTileProvider,
  Marker,
  OSMImageryTileProvider,
  ObjectTracker,
  PROJECTION_BD_MERCATOR,
  PROJECTION_ECEF,
  PROJECTION_EQUAL_EARTH,
  PROJECTION_GEO,
  PROJECTION_SCREEN_PIXEL,
  PROJECTION_UTM,
  PROJECTION_WEB_MERCATOR,
  PathTracker,
  Pillar,
  PlaneTerrainTileProvider,
  PointerLockControl,
  Polygon,
  Polyline,
  Popup,
  RENDER_STAGE_BLOOM,
  RENDER_STAGE_FEATURES,
  RENDER_STAGE_POSTPROCESSING,
  RENDER_STAGE_PREPARE,
  RENDER_STAGE_SCENE,
  RasterSurface,
  RotateTracker,
  SDFText,
  index as Services,
  SimpleLine,
  SimpleModel,
  SimplePoint,
  Spark,
  StadiaImageryTileProvider,
  StaticSky,
  TerrainTileProvider,
  Text,
  TiandituConfig,
  TiandituImageryTileProvider,
  TileProvider,
  VectorSurface,
  VectorTileProvider,
  WMSImageryTileProvider,
  WMTSImageryTileProvider,
  Wall,
  WaterMaterial,
  XYZImageryTileProvider,
  colorUtils,
  geojsonUtils,
  gltfLoader,
  constants as mapViewConstants,
  model as modelUtils,
  object as objectUtils,
  request$1 as requestUtils,
  index as services,
  urlUtils
};
