import * as dat from 'dat.gui';
import * as THREE from 'three';
let mapvthree = null;
export const createGui = mt => {
    mapvthree = mt;
    return new dat.GUI();
};

function updateUrlParam(paramName, paramValue) {
    // 创建 URL 对象解析当前页面地址‌:ml-citation{ref="3,4" data="citationList"}
    const url = new URL(window.location.href);
    // 通过 URLSearchParams 管理查询参数‌:ml-citation{ref="3,4" data="citationList"}
    const searchParams = new URLSearchParams(url.search);
    // 自动覆盖已有参数或添加新参数‌:ml-citation{ref="3,4" data="citationList"}
    searchParams.set(paramName, paramValue);
    // 重构完整URL(保留路径和哈希)‌:ml-citation{ref="3,4" data="citationList"}
    const newSearch = searchParams.toString();
    const newUrl = `${url.pathname}${newSearch ? '?' + newSearch : ''}${url.hash}`;
    window.location.href = newUrl;
}

/**
 * 给 dat.gui 的 controller 增加日期时间选择功能
 * @param {dat.GUI} gui dat.gui 实例
 * @param {object} obj 存放数据的对象
 * @param {string} prop 对象的属性名（必须是 Date 类型）
 * @returns {dat.controllers.Controller}
 */
function addDateTimeController(gui, obj, prop, listen = false) {
    // 初始化时把 Date 转换成 HTML input 能识别的字符串
    const toInputValue = date => {
        if (!(date instanceof Date)) {
            return '';
        }
        const pad = n => String(n).padStart(2, '0');
        return (
            date.getFullYear()
            + '-' + pad(date.getMonth() + 1)
            + '-' + pad(date.getDate())
            + 'T' + pad(date.getHours())
            + ':' + pad(date.getMinutes())
            + ':' + pad(date.getSeconds())
        );
    };

    const fromInputValue = value =>
        new Date(value);

    // 如果属性值不是 Date，先转成 Date
    if (!(obj[prop] instanceof Date)) {
        obj[prop] = new Date(obj[prop]);
    }

    // 临时存成字符串以便 dat.gui 渲染
    const proxy = {value: toInputValue(obj[prop])};

    const controller = gui.add(proxy, 'value').name(prop);

    // 转换 input 类型
    const input = controller.domElement.querySelector('input');
    input.setAttribute('type', 'datetime-local');

    // 当用户修改 input 时，更新原始对象为 Date
    input.addEventListener('change', e => {
        obj[prop] = fromInputValue(e.target.value);
        console.log(`[dat.gui datetime] ${prop} =`, obj[prop]);
    });

    // 当外部代码修改 Date 时，刷新 dat.gui 控件
    controller.onChange(val => {
        obj[prop] = fromInputValue(val);
    });

    // 外部修改 obj[prop] → 反映到 dat.gui
    if (listen) {
        controller.listen();
    }
    controller.updateDisplay = function () {
        proxy.value = toInputValue(obj[prop]);
        input.value = proxy.value; // 更新 input 显示
    };

    return controller;
}

export const createEngineConfigs = (gui, engine) => {
    const requestRender = () => engine.requestRender();
    const rendering = engine.rendering;

    const config = {
        printStats: () => {
            console.log(rendering.stats.printString());
        },
        forceLoseAndRestoreContext: () => {
            engine.renderer.forceContextLoss();
            setTimeout(() => {
                engine.renderer.forceContextRestore();
            }, 1000);
        },
        projection: '',
    };

    if (gui.__folders && Object.keys(gui.__folders).includes('rendering')) {
        gui.removeFolder(gui.__folders.rendering);
    }
    const folderRendering = gui.addFolder('rendering');

    const folderPrimary = folderRendering.addFolder('primary');
    folderPrimary.add(rendering, 'useMrt').onChange(requestRender);
    folderPrimary.add(rendering, 'useHighPrecisionBuffer').onChange(requestRender);
    folderPrimary.add(rendering, 'autoOffsetRelativeCenter').onChange(requestRender);
    folderPrimary.add(rendering, 'clampCameraNearFar').onChange(requestRender);
    folderPrimary.add(rendering.renderer, 'outputColorSpace', ['srgb-linear', 'srgb']).onChange(requestRender);
    folderPrimary.add(rendering.renderer, 'toneMapping', [
        THREE.NoToneMapping,
        THREE.LinearToneMapping,
        THREE.ReinhardToneMapping,
        THREE.CineonToneMapping,
        THREE.ACESFilmicToneMapping,
        THREE.AgXToneMapping,
        THREE.NeutralToneMapping,
    ]).listen().onChange(v => {
        rendering.renderer.toneMapping = parseInt(v, 10);
    });
    folderPrimary.add(engine.renderer, 'toneMappingExposure', 0.0, 10.0).listen().onChange(requestRender);
    folderPrimary.add(rendering.main, 'useFastEmissiveMethod').onChange(requestRender);

    const folderAnimation = folderRendering.addFolder('animation');
    folderAnimation.add(rendering, 'enableAnimationLoop').onChange(requestRender);
    folderAnimation.add(rendering, 'animationLoopFrameTime', 16, 1000).onChange(requestRender);

    const folderClock = folderRendering.addFolder('clock');
    folderClock.add(engine.clock, 'tickMode', [0, 1, 2, 3]).onChange(v => {
        engine.clock.tickMode = parseInt(v, 10);
        requestRender();
    });
    addDateTimeController(folderClock, engine.clock, 'startTime');
    addDateTimeController(folderClock, engine.clock, 'stopTime');
    folderClock.add(engine.clock, 'speed').onChange(requestRender);
    folderClock.add(engine.clock, 'timeZoneOffset', -12, 12).onChange(requestRender);
    addDateTimeController(folderClock, engine.clock, 'currentTime');
    addDateTimeController(folderClock, engine.clock, 'currentTime', true).name('displayTime');

    const folderFeatures = folderRendering.addFolder('features');

    const folderAntialias = folderFeatures.addFolder('antialias');
    folderAntialias.add(rendering.features.antialias, 'enabled').onChange(requestRender);
    folderAntialias.add(rendering.features.antialias, 'method', ['msaa', 'fxaa', 'smaa', 'taa'])
        .onChange(requestRender);

    const folderAo = folderFeatures.addFolder('ao');
    folderAo.add(rendering.features.ao, 'enabled').onChange(requestRender);
    folderAo.add(rendering.features.ao, 'method', ['ssao', 'sao']).onChange(requestRender);
    folderAo.add(rendering.features.ao, 'ssaoIntensity').onChange(requestRender);
    folderAo.add(rendering.features.ao, 'ssaoMinDistance').onChange(requestRender);
    folderAo.add(rendering.features.ao, 'ssaoMaxDistance').onChange(requestRender);
    folderAo.add(rendering.features.ao, 'ssaoKernelRadius').onChange(requestRender);

    const folderReflection = folderFeatures.addFolder('reflection');
    folderReflection.add(rendering.features.reflection, 'enabled').onChange(requestRender);
    folderReflection.add(rendering.features.reflection, 'method', ['ssr']).onChange(requestRender);

    const folderShadow = folderFeatures.addFolder('shadow');
    folderShadow.add(rendering.shadow, 'enabled').onChange(requestRender);
    folderShadow.add(rendering.shadow, 'method', ['default', 'csm']).onChange(requestRender);
    folderShadow.add(rendering.shadow, 'shadowMapSize', [512, 1024, 2048, 4096, 8192]).onChange(requestRender);
    folderShadow.add(rendering.shadow, 'maxDistance').onChange(requestRender);
    // folderShadow.add(rendering.shadow._csmShadow, 'shadowBias').onChange(requestRender);
    // folderShadow.add(rendering.shadow._csmShadow, 'showHelper').onChange(requestRender);

    const folderBloom = folderFeatures.addFolder('bloom');
    folderBloom.add(rendering.bloom, 'enabled').onChange(requestRender);
    folderBloom.add(rendering.bloom, 'strength', 0.0, 10.0).onChange(requestRender);
    folderBloom.add(rendering.bloom, 'threshold', 0.0, 3.0, 0.05).onChange(requestRender);
    folderBloom.add(rendering.bloom, 'radius', 0.0, 1.0).onChange(requestRender);

    const folderColorAdjustment = folderFeatures.addFolder('colorAdjustment');
    folderColorAdjustment.add(rendering.colorAdjustment, 'enabled').onChange(requestRender);
    folderColorAdjustment.add(rendering.colorAdjustment, 'saturation', -1.0, 1.0, 0.05).onChange(requestRender);
    folderColorAdjustment.add(rendering.colorAdjustment, 'brightness', -1.0, 1.0, 0.05).onChange(requestRender);
    folderColorAdjustment.add(rendering.colorAdjustment, 'contrast', -1.0, 1.0, 0.05).onChange(requestRender);

    const folderController = folderRendering.addFolder('controller');
    folderController.add(engine.controller, 'enabled').onChange(requestRender);
    folderController.add(engine.controller, 'enableRotate').onChange(requestRender);
    folderController.add(engine.controller, 'enableZoom').onChange(requestRender);
    folderController.add(engine.controller, 'enablePan').onChange(requestRender);
    folderController.add(engine.controller, 'enableTilt').onChange(requestRender);
    folderController.add(engine.controller, 'inertiaDragging', 0, 1).onChange(requestRender);
    folderController.add(engine.controller, 'inertiaZoom', 0, 1).onChange(requestRender);

    const folderPicking = folderRendering.addFolder('picking');
    folderPicking.add(rendering.picking, 'useDepthPicking').onChange(requestRender);

    const folderHDR = folderFeatures.addFolder('hdr');
    folderHDR.add(rendering.features.hdr, 'enabled').onChange(requestRender);
    folderHDR.add(rendering.features.hdr, 'exposure', 0.0, 10.0).onChange(requestRender);

    const folderMap = folderRendering.addFolder('map');
    const map = engine.map;
    folderMap.add(map.map, 'fov', 0, 180).onChange(requestRender);
    if (map.map.isBlankMap) {
        folderMap.add(map.map, 'far').onChange(requestRender);

        folderMap.add(map.map.control, 'minPitch', 0, 180).onChange(requestRender);
        folderMap.add(map.map.control, 'maxPitch', 0, 180).onChange(requestRender);
        folderMap.add(map.map.control, 'zoomSpeed', 0, 0.02).onChange(requestRender);
    }

    const debugFolder = folderRendering.addFolder('debug');
    debugFolder.add(rendering, 'debugMode', [0, 1, 2, 3, 4]).onChange(requestRender);
    debugFolder.add(rendering, 'wireframe').onChange(requestRender);
    const infoFolder = debugFolder.addFolder('info');
    infoFolder.add(engine.rendering.renderer.info.render, 'frame').listen();
    infoFolder.add(engine.rendering.renderer.info.memory, 'geometries').listen();
    infoFolder.add(engine.rendering.renderer.info.memory, 'textures').listen();
    infoFolder.add(engine.rendering.renderer.info.programs, 'length').name('programs').listen();
    infoFolder.add(engine.rendering.renderer.info.render, 'lines').listen();
    infoFolder.add(engine.rendering.renderer.info.render, 'points').listen();
    infoFolder.add(engine.rendering.renderer.info.render, 'calls').listen();
    infoFolder.add(engine.rendering.renderer.info.render, 'triangles').listen();

    debugFolder.add(config, 'projection', [
        'EPSG:3857',
        'EPSG:4326',
        'EPSG:4978',
        ...Object.keys(mapvthree.projectionDefs),
    ]).onChange(value => {
        updateUrlParam('projection', value);
    });

    debugFolder.add(config, 'forceLoseAndRestoreContext');
    debugFolder.add(config, 'printStats');
    debugFolder.add(rendering, 'showCurrentViewFrustum');
    debugFolder.add(rendering, 'removeCurrentViewFrustum');
    debugFolder.add(rendering.features.stats, 'enabled').name('stats').onChange(requestRender);
    debugFolder.add(rendering.features.bufferView, 'enabled').name('bufferView').onChange(requestRender);
    debugFolder.add(rendering.features.bufferView, 'offset').name('bufferOffset').onChange(requestRender);

    return folderRendering;
};

export const createSkyConfigs = (gui, engine) => {
    const requestRender = () => engine.requestRender();
    const sky = engine.rendering.sky;
    if (!sky) {
        return;
    }
    const config = {
        groundColor: '#FFFFFF',
    };
    if (gui.__folders && Object.keys(gui.__folders).includes('sky')) {
        gui.removeFolder(gui.__folders.sky);
    }
    const folderSky = gui.addFolder('sky');
    folderSky.add(sky, 'time', 0, 86400).onChange(requestRender);
    folderSky.add(sky, 'sunLightIntensity', 0.0, 10.0, 0.1).listen().onChange(requestRender);
    folderSky.add(sky, 'skyLightIntensity', 0.0, 10.0).listen().onChange(requestRender);
    folderSky.add(sky, 'envLightIntensity').onChange(requestRender);
    folderSky.add(sky, 'affectWorld').onChange(requestRender);

    if (sky instanceof mapvthree.PhysicalSky || sky instanceof mapvthree.DynamicSky) {
        folderSky.add(sky, 'enableAtmospherePass').onChange(requestRender);
        folderSky.add(sky, 'enableCloudsPass').onChange(requestRender);
        folderSky.add(sky, 'cloudsCoverage', 0, 1, 0.01).onChange(requestRender);
        folderSky.add(sky, 'cloudsSpeed', 0, 100., 0.1).onChange(requestRender);
        folderSky.add(sky, 'cloudsBaseHeight', 0, 10000, 100).onChange(requestRender);
    }
    if (sky instanceof mapvthree.DynamicSky) {
        // folderSky.add(sky, 'shaderIndex', [
        //     0, 1, 2, 3,
        // ]).onChange(requestRender);
        folderSky.add(sky, 'clipUnderground').onChange(requestRender);
        folderSky.add(sky, 'cloudDensity', 0, 1).onChange(requestRender);
        folderSky.add(sky, 'cloudShapeBaseScale').onChange(requestRender);
        folderSky.add(sky, 'cloudShapeDetailScale').onChange(requestRender);
        folderSky.add(sky, 'cloudMarchSteps').onChange(requestRender);
        folderSky.add(sky, 'cloudSelfShadowSteps').onChange(requestRender);
    }
    else if (sky instanceof mapvthree.PhysicalSky) {
        folderSky.add(sky, 'enableCloudsShadow').onChange(requestRender);
    }
};

export const createWeatherConfigs = (gui, engine) => {
    const requestRender = () => engine.requestRender();
    const weather = engine.rendering.weather;
    // const config
    if (gui.__folders && Object.keys(gui.__folders).includes('weather')) {
        gui.removeFolder(gui.__folders.weather);
    }
    const folderWeather = gui.addFolder('weather');
    folderWeather.add(weather, 'weather', [
        'clear',
        'partlyCloudy',
        'cloudy',
        'overcast',
        'foggy',
        'rainy',
        'stormy',
        'snowy',
        'thunderstorm',
    ]).onChange(requestRender);

    // if (weather._sky.isDynamicSky || weather._sky.isDynamicSky) {
    //     folderWeather.add(weather, 'cloudIntensity', 0.0, 3.0).listen().onChange(requestRender);
    //     folderWeather.add(weather, 'mixGrayFactor', 0.0, 1.0).listen().onChange(requestRender);
    //     // folderWeather.add(weather, 'sunIntensityScale', 0.0, 2.0).listen().onChange(requestRender);
    //     folderWeather.add(weather, 'skyLightIntensity', 0.0, 2.0).listen().onChange(requestRender);
    //     folderWeather.add(weather, 'coverageIntensity', 0.0, 2.0).listen().onChange(requestRender);
    // }
};

export const createCesium3DTilesConfigs = (gui, engine, tiles, name) => {
    const requestRender = () => engine.requestRender();
    if (gui.__folders && Object.keys(gui.__folders).includes(name || '3DTiles')) {
        gui.removeFolder(gui.__folders[name || '3DTiles']);
    }
    const folderTiles = gui.addFolder(name || '3DTiles');
    const config = {
        zoomTo: () => {
            engine.map.zoomTo(tiles);
        },
    };
    folderTiles.add(config, 'zoomTo');
    folderTiles.add(tiles, 'visible').onChange(requestRender);

    const statsFolder = folderTiles.addFolder('Stats');
    statsFolder.add(tiles.statistics, 'selected').listen();
    statsFolder.add(tiles.statistics, 'numberOfLoadedTilesTotal').listen();
    statsFolder.add(tiles.statistics, 'numberOfPendingRequests').listen();
    statsFolder.add(tiles.statistics, 'numberOfTilesCulledWithChildrenUnion').listen();
    statsFolder.add(tiles.statistics, 'numberOfTilesTotal').listen();
    statsFolder.add(tiles.statistics, 'totalByteLength').listen();

    const debugFolder = folderTiles.addFolder('Debug');
    debugFolder.add(tiles, 'debug').onChange(requestRender);
    debugFolder.add(tiles, 'displayBoxBounds').onChange(requestRender);
    debugFolder.add(tiles, 'displayRegionBounds').onChange(requestRender);
};

export const create3DTilesConfigs = (gui, engine, tiles, name) => {
    const requestRender = () => engine.requestRender();
    if (gui.__folders && Object.keys(gui.__folders).includes(name || '3DTiles')) {
        gui.removeFolder(gui.__folders[name || '3DTiles']);
    }
    const folderTiles = gui.addFolder(name || '3DTiles');
    const config = {
        material: 'realistic',
        zoomTo: () => {
            engine.map.zoomTo(tiles);
        },
    };
    folderTiles.add(config, 'zoomTo');
    folderTiles.add(tiles, 'visible').onChange(requestRender);
    folderTiles.add(config, 'material', [
        'default',
        'realistic',
        'identity',
        'wireframe',
        'randomColor',
    ]).onChange(value => {
        if (value === 'realistic') {
            tiles.materialManager = new mapvthree.Realistic3DTilesMaterialManager();
        }
        else if (value === 'wireframe') {
            tiles.materialManager = new mapvthree.Wireframe3DTilesMaterialManager();
        }
        else if (value === 'identity') {
            tiles.materialManager = new mapvthree.Identity3DTilesMaterialManager();
        }
        else if (value === 'randomColor') {
            tiles.materialManager = new mapvthree.RandomColor3DTilesMaterialManager();
        }
        else {
            tiles.materialManager = null;
        }
        requestRender();
    });

    // folderTiles.add(tiles, 'identityType', [
    //     1,
    //     2,
    // ]).onChange(requestRender);

    if (tiles.materialManager && tiles.materialManager.isRealistic3DTilesMaterialManager) {
        folderTiles.add(tiles.materialManager, 'autoTimingLight').onChange(requestRender);
        folderTiles.add(tiles.materialManager, 'nightLightDensity', 0, 1).onChange(requestRender);
    }

    folderTiles.add(tiles, 'castShadow').onChange(requestRender);
    folderTiles.add(tiles, 'receiveShadow').onChange(requestRender);
    folderTiles.add(tiles, 'raycastMethod', [0, 1, 2]).onChange(requestRender);
    folderTiles.add(tiles, 'forceUnlit').onChange(requestRender);

    if (tiles.isHDMap3DTiles) {
        const editFolder = folderTiles.addFolder('Edit');
        editFolder.add(tiles.edit, 'enabled').onChange(requestRender);
    }

    const instanceFolder = folderTiles.addFolder('Instance');
    // instanceFolder.add(tiles.instancedElementManager, 'treeEnabled').onChange(requestRender);
    // instanceFolder.add(tiles.instancedElementManager, 'labelEnabled').onChange(requestRender);

    const debugFolder = folderTiles.addFolder('Debug');
    debugFolder.add(tiles, 'freezeUpdate').onChange(requestRender);
    // debugFolder.add(tiles, 'viewFar').onChange(requestRender);
    debugFolder.add(tiles, 'loadSiblings').onChange(requestRender);
    // debugFolder.add(tiles, 'displayActiveTiles').onChange(requestRender);
    // debugFolder.add(tiles, 'autoDisableRendererCulling').onChange(requestRender);
    debugFolder.add(tiles, 'errorTarget').onChange(requestRender);
    debugFolder.add(tiles, 'showDebug').onChange(requestRender);
    // debugFolder.add(tiles, 'checkIntersectByBox').onChange(requestRender);
    debugFolder.add(tiles, 'lockCameraViewport').onChange(requestRender);
    debugFolder.add(tiles, 'releaseCameraViewport').onChange(requestRender);
    // debugFolder.add(tiles, 'enabledSchedule').onChange(requestRender);
    // debugFolder.add(tiles, 'deferOutSideFrustum').onChange(requestRender);
    // debugFolder.add(tiles, 'deferLoadDepth').onChange(requestRender);
    debugFolder.add(tiles, 'cullWithChildrenBounds').onChange(requestRender);
    debugFolder.add(tiles, 'cullRequestsWhileMoving').onChange(requestRender);
    debugFolder.add(tiles, 'cullRequestsWhileMovingMultiplier').onChange(requestRender);
    debugFolder.add(tiles, 'dynamicScreenSpaceError').onChange(requestRender);
    debugFolder.add(tiles, 'dynamicScreenSpaceErrorFactor').onChange(requestRender);
    debugFolder.add(tiles, 'dynamicScreenSpaceErrorHeightFalloff').onChange(requestRender);
    debugFolder.add(tiles, 'dynamicScreenSpaceHeightScale').onChange(requestRender);
    debugFolder.add(tiles, 'dynamicScreenSpaceErrorDensity').onChange(requestRender);
    debugFolder.add(tiles, 'foveatedScreenSpaceError').onChange(requestRender);
    debugFolder.add(tiles, 'foveatedConeSize').onChange(requestRender);
    // debugFolder.add(tiles, 'cacheDepth').onChange(requestRender);
    // debugFolder.add(tiles, 'maxCacheChildren').onChange(requestRender);

    return folderTiles;
};


export const createWaterConfigs = (gui, engine, waterMaterial, name = 'water') => {
    const config = {
        sunColor: '#ffffff',
        waterColor: '#001e0f',
        reflectionColor: '#001e0f',
        finalColor: '#bfd9ff',
        crestFoamColor: '#9292CD',
    };
    const requestRender = () => engine.requestRender();

    if (gui.__folders && Object.keys(gui.__folders).includes(name)) {
        gui.removeFolder(gui.__folders[name]);
    }

    const folder = gui.addFolder(name);

    folder.add(waterMaterial, 'autoScale').onChange(requestRender);
    folder.add(waterMaterial, 'size', 0.1, 10.0).onChange(requestRender);
    folder.add(waterMaterial, 'alpha', 0, 1).onChange(requestRender);
    folder.add(waterMaterial, 'distortionScale', 0.0, 20.0).onChange(requestRender);
    folder.add(waterMaterial, 'timeScaleFactor', 0.0, 0.01).onChange(requestRender);
    folder.add(waterMaterial, 'foamSpeed', 0.0, 4).onChange(requestRender);
    folder.add(waterMaterial, 'depthSoftness', 0.0, 100.0).onChange(requestRender);
    folder.add(waterMaterial, 'foamDepthSoftness', 0.0, 10.0).onChange(requestRender);
    folder.add(waterMaterial, 'foamSoftness', 0.0, 10.0).onChange(requestRender);
    folder.add(waterMaterial, 'foamScale', 10.0, 500.0).onChange(requestRender);
    folder.add(waterMaterial, 'uvScale', 100.0, 10000.0).onChange(requestRender);

    folder.addColor(config, 'sunColor').onChange(value => {
        waterMaterial.uniforms.sunColor.value.set(value);
        requestRender();
    });
    folder.addColor(config, 'waterColor').onChange(value => {
        const color = new THREE.Color(value);
        waterMaterial.waterColor = color.toArray();
        requestRender();
    });
    folder.addColor(config, 'reflectionColor').onChange(value => {
        waterMaterial.uniforms.reflectionColor.value.set(value);
        requestRender();
    });
    folder.addColor(config, 'finalColor').onChange(value => {
        waterMaterial.uniforms.finalColor.value.set(value);
        requestRender();
    });

    folder.add(waterMaterial, 'offsetScale', 1.0, 100.0).onChange(value => {
        waterMaterial.offsetScale = value;
        requestRender();
    });

    folder.add(waterMaterial, 'crestFoam', 0.0, 1.0).onChange(value => {
        waterMaterial.crestFoam = value;
        requestRender();
    });

    folder.add(waterMaterial, 'specularStrength', 1, 10).onChange(value => {
        waterMaterial.specularStrength = value;
        requestRender();
    });


    folder.addColor(config, 'crestFoamColor').onChange(value => {
        const color = new THREE.Color(value);
        waterMaterial.crestFoamColor = color.toArray();
        requestRender();
    });

    // folder.add(waterMaterial, 'style', ['river', 'lake', 'ocean']).onChange(requestRender);
};

export const createHeightMaterialConfigs = (gui, engine, material, name = 'heightMaterial') => {
    const requestRender = () => engine.requestRender();

    if (gui.__folders && Object.keys(gui.__folders).includes(name)) {
        gui.removeFolder(gui.__folders[name]);
    }
    const folderWater = gui.addFolder(name);

    folderWater.add(material, 'minAltitude').onChange(requestRender);
    folderWater.add(material, 'maxAltitude').onChange(requestRender);
    folderWater.add(material, 'noiseUvScale').onChange(requestRender);
    folderWater.add(material, 'noiseScale').onChange(requestRender);
    folderWater.add(material, 'noiseBais').onChange(requestRender);
};

export const createTerrainConfigs = (gui, engine, terrain, name = 'terrain') => {
    const requestRender = () => engine.requestRender();
    const folderTerrain = gui.addFolder(name);

    folderTerrain.add(terrain, 'visible').onChange(requestRender);
    folderTerrain.add(terrain.mapView.lod, 'lodOffset').onChange(requestRender);

    if (terrain.mapView.overrideMaterial && terrain.mapView.overrideMaterial.isMeshHeightMaterial) {
        createHeightMaterialConfigs(folderTerrain, engine, terrain.mapView.overrideMaterial);
    }
    return folderTerrain;
};


export const createQuadMapConfigs = (gui, engine, quadMap) => {
    const requestRender = () => engine.requestRender();
    if (gui.__folders && Object.keys(gui.__folders).includes('QuadMap')) {
        gui.removeFolder(gui.__folders.QuadMap);
    }
    const folderQuadMap = gui.addFolder('QuadMap');
    folderQuadMap.add(quadMap, 'visible').onChange(requestRender);
    folderQuadMap.add(quadMap, 'lodScaleFactor').onChange(requestRender);
    folderQuadMap.add(quadMap, 'cameraFarRatio').onChange(requestRender);

    // const tileManagerFolder = folderQuadMap.addFolder('TileManager');
    // tileManagerFolder.add(quadMap.tileManager, 'maxDisplaySize').onChange(requestRender);
    // tileManagerFolder.add(quadMap.tileManager, 'displayTileAfterAllSiblingsReady').onChange(requestRender);
    // tileManagerFolder.add(quadMap.tileManager, 'displayParentTileWhileNotAllSiblingsReady').onChange(requestRender);
    // tileManagerFolder.add(quadMap.tileManager, 'maxCacheSize').onChange(requestRender);

    // const debugFolder = folderQuadMap.addFolder('Debug');
    // debugFolder.add(quadMap, 'freezeUpdate').onChange(requestRender);
    // debugFolder.add(quadMap, 'showDebugGrid').onChange(requestRender);

    // const infoFolder = folderQuadMap.addFolder('info');
    // infoFolder.add(quadMap.statistics, 'visited').listen();
    // infoFolder.add(quadMap.statistics, 'selected').listen();
    // infoFolder.add(quadMap.statistics, 'rendered').listen();

    return folderQuadMap;
};

export const createMapViewConfigs = (gui, engine, mapView) => {
    const requestRender = () => engine.requestRender();
    if (gui.__folders && Object.keys(gui.__folders).includes('MapView')) {
        gui.removeFolder(gui.__folders.MapView);
    }
    const folderMapView = gui.addFolder('MapView');
    folderMapView.add(mapView, 'visible').onChange(requestRender);
    // folderMapView.add(mapView, 'printSurfacesStatistics');

    const debugFolder = folderMapView.addFolder('Debug');
    debugFolder.add(mapView, 'freezeUpdate').onChange(requestRender);
    debugFolder.add(mapView, 'printSurfacesStatistics').onChange(requestRender);
    debugFolder.add(mapView, 'showCameraFrustum').onChange(requestRender);
    debugFolder.add(mapView, 'destroyCameraHelper').onChange(requestRender);

    const surfaces = mapView.surfaces;
    for (let i = 0; i < surfaces.length; i++) {
        const surface = surfaces[i];
        const surfaceFolder = folderMapView.addFolder(`Surface ${i}`);
        surfaceFolder.add(surface, 'visible').onChange(requestRender);
        surfaceFolder.add(surface, 'freezeUpdate').onChange(requestRender);
        surfaceFolder.add(surface, 'loadSiblings').onChange(requestRender);
        surfaceFolder.add(surface, 'showTileBoundingBox').onChange(requestRender);
        surfaceFolder.add(surface, 'showTileDebugLabel').onChange(requestRender);
        surfaceFolder.add(surface, 'enableHorizonCulling').onChange(requestRender);
        surfaceFolder.add(surface, '_lodScaleFactor').onChange(requestRender);
        surfaceFolder.add(surface, 'sseFactor').onChange(requestRender);
        surfaceFolder.add(surface, 'showLoadLogInOneFrame').onChange(requestRender);
        surfaceFolder.add(surface, 'showGroundWireframe').onChange(requestRender);
        surfaceFolder.add(surface.statistics, 'visited').listen();
        surfaceFolder.add(surface.statistics, 'used').listen();
        surfaceFolder.add(surface.statistics, 'rendered').listen();
        surfaceFolder.add(surface.statistics, 'request').listen();
        surfaceFolder.add(surface.tileManager, 'pendingCount').listen();

        if (surface.isMapVectorSurface) {
            const vectorSurface = surface;
            const vectorSurfaceFolder = surfaceFolder.addFolder('VectorSurface');
        }
        else if (surface.isMapRasterSurface) {
            const rasterSurface = surface;
            const terrainProvider = rasterSurface.terrainProvider;
            if (terrainProvider) {
                const terrainProviderFolder = surfaceFolder.addFolder('TerrainProvider');
                terrainProviderFolder.add(terrainProvider, 'maxParallelRequestNum').onChange(requestRender);
                terrainProviderFolder.add(terrainProvider, 'cacheMaxSize').onChange(requestRender);
                terrainProviderFolder.add(terrainProvider, 'enablePeriodRequestLog').onChange(requestRender);

            }
            const imageryProviders = rasterSurface.imageryProviders;
            for (let i = 0, last = imageryProviders.length; i < last; i++) {
                const imageryProvider = imageryProviders[i];
                const imageryProviderFolder = surfaceFolder.addFolder(`ImageryProvider_${i}`);
                imageryProviderFolder.add(imageryProvider, 'visible').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider, 'addDebugLabel').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider, 'opacity').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider.colorTint, 0).name('colorTint0').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider.colorTint, 1).name('colorTint1').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider.colorTint, 2).name('colorTint2').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider, 'randomColorTint').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider, 'maxParallelRequestNum').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider, 'cacheMaxSize').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider, 'enablePeriodRequestLog').onChange(requestRender);
                imageryProviderFolder.add(imageryProvider.statistics, 'loading').listen();
                imageryProviderFolder.add(imageryProvider.statistics, 'cached').listen();
            }

        }
    }

    return folderMapView;
};