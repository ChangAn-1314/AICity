var __defProp=Object.defineProperty,__defNormalProp=(e,t,i)=>t in e?__defProp(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,__publicField=(e,t,i)=>(__defNormalProp(e,"symbol"!=typeof t?t+"":t,i),i);!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).mapvthree={},e.THREE)}(this,(function(exports,three){"use strict";const CSS_NAMESPACE="mapv";function addClass(e,t){if(void 0===e.className)e.className=t;else if(e.className!==t){const i=e.className.split(/ +/);-1===i.indexOf(t)&&(i.push(t),e.className=i.join(" ").replace(/^\s+/,"").replace(/\s+$/,""))}return e}function removeClass(e,t){if(t)if(e.className===t)e.removeAttribute("class");else{const i=e.className.split(/ +/),n=i.indexOf(t);-1!==n&&(i.splice(n,1),e.className=i.join(" "))}else e.className=void 0;return e}const isStyleInjected={};function injectStyle(t,i){if(isStyleInjected[t])return;const n=i||document,r=document.createElement("style");r.type="text/css",r.innerHTML=t;const s=n.getElementsByTagName("head")[0];try{s.appendChild(r),isStyleInjected[t]=!0}catch(e){}}const styleSheet='.mapv-widgets-pane{position:absolute;z-index:15;bottom:0;left:0;right:0}.mapv-widgets-pane .bottom-right-anchor{position:absolute;width:52px;bottom:40px;right:20px}.mapv-widgets-pane .bottom-left-anchor{position:absolute;bottom:60px;left:20px}.mapv-widgets-pane .compass{width:52px;height:54px;margin-top:10px;visibility:visible;position:relative;background-size:266px;background-repeat:no-repeat;background-position:0 0}.mapv-widgets-pane .compass .compass-up{position:absolute;left:20px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-widgets-pane .compass .compass-up:hover{fill:#2c82ff}.mapv-widgets-pane .compass .compass-down{position:absolute;left:20px;bottom:2px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-widgets-pane .compass .compass-down:hover{fill:#2c82ff}.mapv-widgets-pane .compass .compass-left{cursor:pointer;position:absolute;top:5px;left:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px}.mapv-widgets-pane .compass .compass-left:hover{background-position:-89px -5px}.mapv-widgets-pane .compass .compass-right{cursor:pointer;position:absolute;top:5px;right:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px;transform:rotateY(180deg);-ms-transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-o-transform:rotateY(180deg);-moz-transform:rotateY(180deg)}.mapv-widgets-pane .compass .compass-right:hover{background-position:-89px -5px}.mapv-widgets-pane .compass .compass-center{cursor:pointer;position:absolute;top:11px;left:19px;width:14px;height:32px;background-size:266px;background-repeat:no-repeat;background-position:-56px -10px;transform:rotate(0)}.mapv-widgets-pane .zoom{width:26px;height:54px;visibility:visible;margin-left:13px;margin-top:10px}.mapv-widgets-pane .zoom .zoom-add{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:2px 2px 0 0;background-position:0 0}.mapv-widgets-pane .zoom .zoom-add:hover .zoom-add-tag{background-position:20px 0}.mapv-widgets-pane .zoom .zoom-add-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px}.mapv-widgets-pane .zoom .zoom-sub{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:0 0 2px 2px}.mapv-widgets-pane .zoom .zoom-sub:hover .zoom-sub-tag{background-position:10px 0}.mapv-widgets-pane .zoom .zoom-sub-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px;background-position:-10px 0}.mapv-widgets-pane .scale{position:absolute;bottom:10px;left:100px;visibility:visible;width:90px;height:26px}.mapv-widgets-pane .scale .scale-text{width:100%;font-size:10px;text-align:center;user-select:none;transition:width .3s}.mapv-widgets-pane .scale .scale-line{position:relative;width:100%;height:8px;user-select:none}.mapv-widgets-pane .scale .scale-line-mid{position:absolute;left:2px;right:2px;top:3px;bottom:2px;background-color:#333;overflow:hidden}.mapv-widgets-pane .scale .scale-line-left{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden}.mapv-widgets-pane .scale .scale-line-right{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden;right:0}.mapv-widgets-pane .drawer{position:absolute;right:31px;bottom:164px;margin:2px;cursor:pointer}.mapv-widgets-pane .drawer .drawer-btn{background-color:#fff;padding:5px 5px 0;border-radius:2px}.mapv-widgets-pane .drawer .drawer-btn:hover{background-color:#f3f3f3}.mapv-widgets-pane .drawer .drawer-icon{height:16px;width:16px;fill:#797979}.mapv-widgets-pane .drawer .drawer-list{position:absolute;right:32px;top:0;display:none;list-style:none;background-color:#fff;box-shadow:0 0 20px #00000026;white-space:nowrap;border-radius:2px}.mapv-widgets-pane .drawer .drawer-item{display:flex;align-items:center;padding:0 16px;height:24px;line-height:24px}.mapv-widgets-pane .drawer .drawer-item-check{margin:0}.mapv-widgets-pane .drawer .drawer-item-name{margin-left:6px;font-size:12px}.mapv-widgets-pane .drawer .drawer-arrow{width:0;height:0;border-width:4px;border-style:solid;border-color:transparent transparent transparent #fff;position:absolute;top:11px;right:-7px}.mapv-widgets-pane .mouse-location{position:absolute;bottom:10px;right:20px;visibility:visible;padding:2px 6px;background-color:#fff;font-size:14px;border-radius:2px}.mapv-widgets-pane .logo{position:absolute;width:81px;height:27px;bottom:10px;left:5px;visibility:visible}.mapv-widgets-pane .geo-locate{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-widgets-pane .fullscreen{background-color:#fff;height:26px;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc}.mapv-widgets-pane .export-image{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-widgets-pane .geo-locate:hover .widgets-group-svg,.mapv-widgets-pane .fullscreen:hover .widgets-group-svg,.mapv-widgets-pane .export-image:hover .widgets-group-svg{fill:#2c82ff}.mapv-widgets-pane .widgets-group-svg{margin:5px;height:16px;width:16px;fill:#999}.mapv-overlay-pane{position:absolute;z-index:10}.mapv-overlay-pane .mapv-marker{z-index:10}.mapv-overlay-pane .mapv-marker:hover{cursor:pointer}.mapv-overlay-pane .mapv-popup{width:250px;height:130px;z-index:20}.mapv-overlay-pane .mapv-popup .frame{width:248px;height:118px;background:white;border-radius:4px;border:1px solid #e6e1e1}.mapv-overlay-pane .mapv-popup .title{height:30px;border-bottom:1px solid #e6e1e1;line-height:30px;padding:2px 0 2px 10px;font-weight:500}.mapv-overlay-pane .mapv-popup .close{width:20px;height:31px;position:absolute;font-size:20px;text-align:center;right:5px;cursor:pointer}.mapv-overlay-pane .mapv-popup .triangle{width:0;height:0;border-top:10px solid white;border-left:12px solid transparent;border-right:12px solid transparent;margin-left:112px}.mapv-overlay-pane .mapv-popup .content{padding:5px 10px}.mapv-dom-points{position:absolute;z-index:10;user-select:none}.mapv-measure-pane{display:inline-block;position:absolute;height:30px;border-radius:5px;padding:0 5px;line-height:30px;background-color:#797774;color:#fff;transform:translate(-50%,-130%);overflow:visible;white-space:nowrap}.mapv-measure-pane:after{content:"";position:absolute;width:0;height:0;left:50%;bottom:0;border:6px solid transparent;border-top:6px solid #797774;background-color:transparent;transform:translate(-50%,10px)}.mapv-container{touch-action:none}.mapv-hidden{display:none!important}\n',extra_vertex_utils="#define GLSLIFY 1\nuniform float zoomUnits;\n\n// position为world coord\nfloat getPixelSize(vec3 position) {\n    if (isOrthographic) {\n        return zoomUnits;\n    }\n    else {\n        // projectionMatrix第5位含义为tan(fov / 2) = 2 * near / (top - bottom)\n        return 0.2 * projectionMatrix[1][1] / resolution.y * distance(cameraPosition, position);\n    }\n}\n",selective_pars_vertex="#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nattribute float objectIndex;\nuniform float selectedObjectIndex;\nvarying float isSelected;\n#endif",selective_vertex="#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nif (objectIndex == selectedObjectIndex) {\n\tisSelected = 1.0;\n} else {\n\tisSelected = 0.0;\n}\n#endif",selective_pars_fragment="#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nvarying float isSelected;\nuniform vec4 selectedObjectColor;\nuniform float selectedObjectColorMode;\n#endif",selective_fragment="#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nif (isSelected == 1.0) {\n\tif (selectedObjectColorMode == 1.) {\n\t\tgl_FragColor = selectedObjectColor;\n\t} else {\n\t\tgl_FragColor.rgb = selectedObjectColor.rgb * selectedObjectColor.a + gl_FragColor.rgb * (1.0 - selectedObjectColor.a);\n\t}\n\t\n}\n#endif",keepsize_pars_vertex="#define GLSLIFY 1\nuniform bool keepSize;\nuniform float pixelRatio;\nuniform vec2 resolution;\n",keepsize_vertex="#define GLSLIFY 1\nvec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\nfloat pixelSize = getPixelSize(worldPosition.xyz);\nif (keepSize) {\n    transformed *= pixelSize;\n}\n",uniform_zoomunits_pars="#define GLSLIFY 1\n",emissive_pars_fragment="#define GLSLIFY 1\n#define MVT_EMISSIVE_SHADER\n\nuniform vec3 emissive;",emissive_fragment="#define GLSLIFY 1\n#ifdef MVT_EMISSIVE_SHADER\n    vec4 out_emissive = vec4(emissive.rgb, 1.0);\n#endif",override_standard_emissivemap_pars_fragment="#define GLSLIFY 1\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif",override_standard_emissivemap_fragment="#define GLSLIFY 1\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\t// emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n    \n#endif\n\nif (isEmissive) {\n    gl_FragColor = vec4(totalEmissiveRadiance, 1.0);\n\t#if defined( TONE_MAPPING )\n\t    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n    #endif\n    return;\n}",override_basic_color_pars_fragment="#define GLSLIFY 1\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif",override_basic_color_fragment="#define GLSLIFY 1\nif (isEmissive) {\n    gl_FragColor = vec4(emissive, 1.0);\n    #if defined( TONE_MAPPING )\n\t    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n    #endif\n    return;\n}\n#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif",animation_vertex="#define GLSLIFY 1\n#ifdef ENABLE_ANIMATION_ROTATE\n    float rotateRatio = mod(elapsedTime, animationRotatePeriod) / animationRotatePeriod;\n    if (animationPeriodOffset) {\n        rotateRatio = mod(rotateRatio + instancedRandomFactor, 1.0);\n    }\n    float rotation = rotateRatio * 6.28;\n    vec2 rotatedPosition;\n    rotatedPosition.x = cos( rotation ) * transformed.x - sin( rotation ) * transformed.y;\n    rotatedPosition.y = sin( rotation ) * transformed.x + cos( rotation ) * transformed.y;\n    transformed.xy = rotatedPosition;\n#endif\n\n#ifdef ENABLE_ANIMATION_JUMP\n    float jumpRatio = mod(elapsedTime, animationJumpPeriod) / animationJumpPeriod;\n    if (animationPeriodOffset) {\n        jumpRatio = mod(jumpRatio + instancedRandomFactor, 1.0);\n    }\n    if (jumpRatio <= 0.5) {\n        jumpRatio *= 2.0;\n        jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n    } else {\n        jumpRatio = (1.0 - jumpRatio) * 2.0;\n        jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n    }\n    #ifdef USE_SIZE3\n        transformed.z += jumpRatio * animationJumpHeight / size3.z;\n    #else\n        transformed.z += jumpRatio * animationJumpHeight / size;\n    #endif\n#endif\n\n#ifdef ENABLE_ANIMATION_SCALE\n    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;\n    if (animationPeriodOffset) {\n        scaleRatio = mod(scaleRatio + instancedRandomFactor, 1.0);\n    }\n\n    vScale *= 1.0 + (targetScale - 1.0) * scaleRatio;\n\n    if (opacityGradient) {\n        if (targetScale > 1.0) {\n            opacityRatio = 1.0 - (targetScale - 1.0) * scaleRatio;\n        } else {\n            opacityRatio = 1.0 + (targetScale - 1.0) * scaleRatio;\n        }\n    }\n\n#endif\n\n#ifdef ENABLE_ANIMATION_BREATH\n    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;\n    if (animationPeriodOffset) {\n        scaleRatio = mod(scaleRatio + instancedRandomFactor, 1.0);\n    }\n    float repeatNum = scaleRatio / 0.25;\n    float scaleFactor = mod(scaleRatio, 0.25) / 0.25;\n    float scaleNum = scaleFactor * (maxScale - 1.0);\n    float balance = (maxScale + minScale) / 2.0;\n\n    if (repeatNum > 1.0 && repeatNum < 3.0) {\n        // 下降\n        if (repeatNum < 2.0) {\n            scaleNum = (1.0 - scaleFactor) * (maxScale - balance);\n        } else {\n            scaleNum = -scaleFactor * (balance - minScale);\n        }\n    } else if (repeatNum >= 3.0) {\n        scaleNum = -(1.0 - scaleFactor) * (balance - minScale);\n    }\n\n    vScale *= balance + scaleNum;\n\n    if (opacityGradient) {\n        opacityRatio = (balance + scaleNum) / maxScale;\n    }\n\n#endif",animation_pars_vertex="#define GLSLIFY 1\nuniform bool animationPeriodOffset;\n\n#ifdef ENABLE_ANIMATION_ROTATE\nuniform float animationRotatePeriod;\n#endif\n\n#ifdef ENABLE_ANIMATION_JUMP\nuniform float animationJumpPeriod;\nuniform float animationJumpHeight;\n#endif\n\n#ifdef ENABLE_ANIMATION_SCALE\nuniform float animationPeriod;\nuniform float targetScale;\nuniform bool opacityGradient;\n#endif\n\n#ifdef ENABLE_ANIMATION_BREATH\nuniform float animationPeriod;\nuniform float maxScale;\nuniform float minScale;\nuniform bool opacityGradient;\n#endif",animation_label_vertex="#define GLSLIFY 1\n// 对非instance对象添加动画\n#ifdef ENABLE_ANIMATION_SCALE\n    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;\n    if (animationPeriodOffset) {\n        scaleRatio = mod(scaleRatio, 1.0);\n    }\n\n    vScale *= 1.0 + (targetScale - 1.0) * scaleRatio;\n\n    if (opacityGradient) {\n        if (targetScale > 1.0) {\n            opacityRatio = 1.0 - (targetScale - 1.0) * scaleRatio;\n        } else {\n            opacityRatio = 1.0 + (targetScale - 1.0) * scaleRatio;\n        }\n    }\n\n#endif\n\n#ifdef ENABLE_ANIMATION_JUMP\n    float jumpRatio = mod(elapsedTime, animationJumpPeriod) / animationJumpPeriod;\n    if (animationPeriodOffset) {\n        jumpRatio = mod(jumpRatio, 1.0);\n    }\n    if (jumpRatio <= 0.5) {\n        jumpRatio *= 2.0;\n        jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n    } else {\n        jumpRatio = (1.0 - jumpRatio) * 2.0;\n        jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n    }\n\n    float jumpHeight = jumpRatio * animationJumpHeight;\n#endif\n\n#ifdef ENABLE_ANIMATION_ROTATE\n    float rotateRatio = mod(elapsedTime, animationRotatePeriod) / animationRotatePeriod;\n    if (animationPeriodOffset) {\n        rotateRatio = mod(rotateRatio, 1.0);\n    }\n    float rotation = rotateRatio * 6.28;\n#endif\n\n#ifdef ENABLE_ANIMATION_BREATH\n    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;\n    if (animationPeriodOffset) {\n        scaleRatio = mod(scaleRatio, 1.0);\n    }\n    float repeatNum = scaleRatio / 0.25;\n    float scaleFactor = mod(scaleRatio, 0.25) / 0.25;\n    float scaleNum = scaleFactor * (maxScale - 1.0);\n    float balance = (maxScale + minScale) / 2.0;\n\n    if (repeatNum > 1.0 && repeatNum < 3.0) {\n        // 下降\n        if (repeatNum < 2.0) {\n            scaleNum = (1.0 - scaleFactor) * (maxScale - balance);\n        } else {\n            scaleNum = -scaleFactor * (balance - minScale);\n        }\n    } else if (repeatNum >= 3.0) {\n        scaleNum = -(1.0 - scaleFactor) * (balance - minScale);\n    }\n\n    vScale *= balance + scaleNum;\n\n    if (opacityGradient) {\n        opacityRatio = (balance + scaleNum) / maxScale;\n    }\n#endif",mrt_output_pars_fragment="#define GLSLIFY 1\n#ifndef DISABLE_MRT\n    // layout(location = 1) out highp vec4 pc_fragColor1;\n    // layout(location = 2) out highp vec4 pc_fragColor2;\n    // layout(location = 3) out highp vec4 pc_fragColor3;\n    // layout(location = 4) out highp vec4 pc_fragColor4;\n    // layout(location = 5) out highp vec4 pc_fragColor5;\n    // layout(location = 6) out highp vec4 pc_fragColor6;\n    // layout(location = 7) out highp vec4 pc_fragColor7;\n    #if defined(MVT_MRT_OUT_EMISSIVE)\n        layout(location = MVT_MRT_OUT_EMISSIVE) out highp vec4 mvt_pc_emissive;\n    #endif\n\n    #if defined(MVT_MRT_OUT_NORMAL)\n        layout(location = MVT_MRT_OUT_NORMAL) out highp vec4 mvt_pc_normal;\n    #endif\n\n    #if defined(MVT_MRT_OUT_METALLICROUGH)\n        layout(location = MVT_MRT_OUT_METALLICROUGH) out highp vec4 mvt_pc_metallicRough;\n    #endif\n#endif\n\n#if defined(MVT_EMISSIVE_UNIFORM)\n// 发光颜色自定义\n    #if defined(MVT_EMISSIVE_COLOR)\n        uniform vec3 mvt_emissive;\n    #endif  \n    uniform float mvt_emissiveIntensity;\n#endif",mrt_output_fragment="#define GLSLIFY 1\n#ifndef DISABLE_MRT\n    // 自定义发光颜色，完全由着色器控制 在着色器中输出 vec4 out_emissive;\n    #ifdef MVT_MRT_OUT_EMISSIVE\n        #if defined(MVT_EMISSIVE_SHADER)\n            mvt_pc_emissive = out_emissive;\n        #elif defined(STANDARD)\n            mvt_pc_emissive.rgb = totalEmissiveRadiance;\n            mvt_pc_emissive.a = pc_fragColor.a;\n        #elif defined(PHONG)\n            mvt_pc_emissive.rgb = totalEmissiveRadiance;\n            mvt_pc_emissive.a = pc_fragColor.a;\n        #elif defined(BASIC)\n            mvt_pc_emissive.rgb = emissive;\n            mvt_pc_emissive.a = pc_fragColor.a;\n        // 通过传入的uniform变量颜色自发光\n        #elif defined(MVT_EMISSIVE_UNIFORM)\n            // 发光颜色自定义\n            #if defined(MVT_EMISSIVE_COLOR)\n                mvt_pc_emissive.rgb = mvt_emissive * mvt_emissiveIntensity;\n                mvt_pc_emissive.a = pc_fragColor.a;\n            #else  \n                mvt_pc_emissive = pc_fragColor * mvt_emissiveIntensity;\n            #endif\n        #else\n            mvt_pc_emissive = vec4(0.0, 0.0, 0.0, 0.0);\n        #endif  \n    #endif\n\n    #ifdef MVT_MRT_OUT_NORMAL\n        #if defined(STANDARD)\n            #ifndef FLAT_SHADED\n                mvt_pc_normal = vec4(packNormalToRGB(vNormal), gl_FragCoord.z);\n            #else\n                mvt_pc_normal = vec4(0.0, 0.0, 0.0, 0.0);\n            #endif\n        #else\n            #if defined(MVT_FRAG_NORMAL)\n                mvt_pc_normal = vec4(packNormalToRGB(mvt_frag_normal), 1.0);\n            #else\n                mvt_pc_normal = vec4(0.0, 0.0, 0.0, 0.0);\n            #endif\n        #endif\n    #endif\n\n    #ifdef MVT_MRT_OUT_METALLICROUGH\n        #if defined(STANDARD)\n            mvt_pc_metallicRough = vec4(1.0 - material.roughness, 0.0, 0.0, 1.0);\n        #else\n            float temp_reflectionFactor = 0.0;\n            #if defined(MVT_FRAG_REFLECTION_FACTOR)\n                temp_reflectionFactor = mvt_frag_reflectionFactor;\n            #endif\n            mvt_pc_metallicRough = vec4(temp_reflectionFactor, 0.0, 0.0, 0.0);\n        #endif\n    #endif\n    \n    // pc_fragColor4 = vec4(1.0, 0.0, 1.0, 1.0);\n    // pc_fragColor5 = vec4(0.0, 1.0, 0.0, 1.0);\n    // pc_fragColor6 = vec4(0.0, 1.0, 0.0, 1.0);\n    // pc_fragColor7 = vec4(0.0, 1.0, 0.0, 1.0);\n#endif\n",nmrt_output_pars_fragment="#define GLSLIFY 1\n#if defined(MVT_EMISSIVE_UNIFORM)\n    // 发光颜色自定义\n    #if defined(MVT_EMISSIVE_COLOR)\n        uniform vec3 mvt_emissive;\n    #endif  \n    uniform float mvt_emissiveIntensity;\n#endif\nuniform bool isEmissive;",nmrt_output_fragment="#define GLSLIFY 1\n// if (isEmissive) {\n#if defined(MVT_MODE_EMISSIVE)\n    #if defined(MVT_EMISSIVE_SHADER)\n        gl_FragColor = out_emissive;\n    #elif defined(STANDARD)\n        gl_FragColor.rgb = totalEmissiveRadiance;\n    #elif defined(PHONG)\n        gl_FragColor.rgb = totalEmissiveRadiance;\n    #elif defined(BASIC)\n        gl_FragColor.rgb = emissive;\n    // 通过传入的uniform变量颜色自发光\n    #elif defined(MVT_EMISSIVE_UNIFORM)\n        // 发光颜色自定义\n        #if defined(MVT_EMISSIVE_COLOR)\n            gl_FragColor.rgb = mvt_emissive * mvt_emissiveIntensity;\n        #else\n            gl_FragColor = gl_FragColor * mvt_emissiveIntensity;\n        #endif\n    #else\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    #endif\n#endif\n//}",extra_meshbasic_frag_pars="#define GLSLIFY 1\n#define BASIC\nuniform vec3 emissive;",clip_pars_vertex="#define GLSLIFY 1\n#ifdef USE_CLIP\n    varying vec3 clip_position;\n    varying mat4 clip_modelMat4;\n    #ifdef IS_INSTANCE\n        varying mat4 clip_instanceMat4;\n    #endif\n#endif",clip_vertex="#define GLSLIFY 1\n#ifdef USE_CLIP\n    clip_position = position;\n    clip_modelMat4 = modelMatrix;\n    #ifdef IS_INSTANCE\n        clip_instanceMat4 = instanceMatrix;\n    #endif\n#endif\n",clip_pars_fragment="#define GLSLIFY 1\n#ifdef USE_CLIP\n\n    varying vec3 clip_position;\n    varying mat4 clip_modelMat4;\n    #ifdef IS_INSTANCE\n        varying mat4 clip_instanceMat4;\n    #endif\n\n    struct ClipParameters {\n        vec2 u_polygon[20];\n        vec4 polygonBounds;\n        int clip_type;\n        bool clip_inside;\n        vec2 clip_point;\n        float clip_radius;\n        float clip_maxDiff;\n        vec2 clip_size;\n    };\n\n    uniform ClipParameters mvt_clipParameters;\n\n    int areIntersecting(\n        float v1x1, float v1y1, float v1x2, float v1y2,\n        float v2x1, float v2y1, float v2x2, float v2y2\n    ) {\n        float d1, d2;\n        float a1, a2, b1, b2, c1, c2;\n\n        a1 = v1y2 - v1y1;\n        b1 = v1x1 - v1x2;\n        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);\n\n        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;\n        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;\n\n        if (d1 > 0.0 && d2 > 0.0) return 0;\n        if (d1 <= 0.0 && d2 <= 0.0) return 0;\n\n        a2 = v2y2 - v2y1;\n        b2 = v2x1 - v2x2;\n        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);\n\n        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;\n        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;\n\n        if (d1 > 0.0 && d2 > 0.0) return 0;\n        if (d1 < 0.0 && d2 < 0.0) return 0;\n\n        if ((a1 * b2) - (a2 * b1) == 0.0) return 2;\n\n        return 1;\n    }\n\n    bool pointInPolygon(vec2 p) {\n        vec4 polygonBounds = mvt_clipParameters.polygonBounds;\n        float minX = polygonBounds.x;\n        float minY = polygonBounds.y;\n        float maxX = polygonBounds.z;\n        float maxY = polygonBounds.w;\n        if (p.x > maxX || p.x < minX || p.y > maxY || p.y < minY)\n        {\n            return false;\n        }\n\n        vec2 points[20] = mvt_clipParameters.u_polygon;\n        float maxDiff = mvt_clipParameters.clip_maxDiff;\n        int intersectCount = 0;\n\n        #ifdef USE_CLIPCOUNT\n            for (int i = 0; i < USE_CLIPCOUNT; i++) {\n                vec2 vertex = points[i];\n\n                vec2 vertex2;\n                if (i == USE_CLIPCOUNT - 1) {\n                    vertex2 = points[0];\n                }\n                else {\n                    vertex2 = points[i + 1];\n                }\n\n                bool intersection = areIntersecting(p.x, p.y, p.x + maxDiff * 2.0, p.y, vertex.x, vertex.y, vertex2.x, vertex2.y) != 0;\n                if (intersection) {\n                    intersectCount++;\n                }\n            }\n            return (intersectCount % 2) == 1;\n        #else\n            return false;\n        #endif\n    }\n\n    bool pointInCircle(vec2 point) {\n        float distance = length(point - mvt_clipParameters.clip_point);\n        return distance < mvt_clipParameters.clip_radius;\n    }\n\n    bool pointInRect(vec2 point) {\n        return (point.x > mvt_clipParameters.clip_point.x \n            && point.x < mvt_clipParameters.clip_point.x + mvt_clipParameters.clip_size.x\n            && point.y > mvt_clipParameters.clip_point.y \n            && point.y < mvt_clipParameters.clip_point.y + mvt_clipParameters.clip_size.y);\n    }\n\n#endif",clip_fragment="#define GLSLIFY 1\n#ifdef USE_CLIP\n    vec4 worldCoord;\n\n    #ifdef CUSTOM_WORLD_COORD\n        worldCoord = vec4(vMP, 1.0);\n    #else\n        #ifdef IS_INSTANCE\n            worldCoord = clip_modelMat4 * clip_instanceMat4 * vec4(clip_position, 1.0);\n        #else\n            worldCoord = clip_modelMat4 * vec4(clip_position, 1.0);\n        #endif\n    #endif\n    bool isInside = false;\n    if (mvt_clipParameters.clip_type == 0) {\n        isInside = pointInPolygon(worldCoord.xy / worldCoord.w);\n    }\n    else if (mvt_clipParameters.clip_type == 1) {\n        isInside = pointInCircle(worldCoord.xy / worldCoord.w);\n    }\n    else if (mvt_clipParameters.clip_type == 2) {\n        isInside = pointInRect(worldCoord.xy / worldCoord.w);\n    }\n    \n    bool clipInside = mvt_clipParameters.clip_inside;\n    if (clipInside) {\n        if (isInside) {\n            discard;\n        }\n    }\n    else {\n        if (!isInside) {\n            discard;\n        }\n    }\n#endif",depth_packing="#define GLSLIFY 1\nfloat mvt_linearize_depth(in float depth, in float cameraNear, in float cameraFar){\n    float a = cameraFar / (cameraFar - cameraNear);\n    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n    return a + b / depth;\n}\n\nfloat mvt_reconstruct_depth(sampler2D tDepth, const in vec2 uv, in float cameraNear, in float cameraFar){\n    float depth = texture2D(tDepth, uv).x;\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat mvtGetDepthFromTexture(sampler2D tDepth, vec2 uv, in float cameraNear, in float cameraFar) {\n    #if defined( USE_LOGDEPTHBUF )\n        return mvt_linearize_depth(mvt_reconstruct_depth(tDepth, uv, cameraNear, cameraFar), cameraNear, cameraFar);\n    #else\n        return texture2D(tDepth, uv).x;\n    #endif\n}\nvec3 mvtGetWorldPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix, mat4 viewInverseMatrix) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);\n\n    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];\n    // clipSpacePosition *= clipW;\n    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;\n    \n    // viewSpacePosition /= viewSpacePosition.w;\n    // return viewSpacePosition.xyz;\n    vec4 worldSpacePosition = viewInverseMatrix * viewSpacePosition;\n\n    return worldSpacePosition.xyz / worldSpacePosition.w;\n}\n\nvec3 mvtGetViewPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);\n\n    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];\n    // clipSpacePosition *= clipW;\n    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;\n    \n    viewSpacePosition /= viewSpacePosition.w;\n    return viewSpacePosition.xyz;\n\n}\n",depth_range_pars_fragment="#define GLSLIFY 1\n#ifdef MVT_USE_DEPTH_RANGE\n\nuniform vec2 depthRange;\n\nlayout(location = 1) out highp vec4 pc_fragColor1;\n\nfloat mvt_remapDepth(float depth) {\n    return depth * (depthRange.y - depthRange.x) + depthRange.x;\n}\n#endif\n\n#if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)\n    varying float vLayerIndex;\n#endif\n\n",depth_range_fragment="#define GLSLIFY 1\n#ifdef MVT_USE_DEPTH_RANGE\n    // 真实的深度：生成深度图\n    #ifdef OPAQUE\n        pc_fragColor1 = packDepthToRGBA(gl_FragDepthEXT);\n        // pc_fragColor1 = vec4(gl_FragDepthEXT, 0., 0., 1);\n    #else\n        // 禁止半透明区域混合深度\n        pc_fragColor1 = vec4(1., 1., 1., 0);\n    #endif\n    // pc_fragColor = packDepthToRGBA(gl_FragDepthEXT);\n\n    // layerIndex算的假深度：存到深度数据里\n    #if defined(MVT_USE_VERTEX_ZINDEX)\n        gl_FragDepthEXT = mvt_remapDepth(1.0 - vLayerIndex);\n    #elif defined(MVT_USE_VERTEX_ZINDEX_LEGACY)\n        gl_FragDepthEXT = mvt_remapDepth(gl_FragDepthEXT - vLayerIndex * 0.01);\n    #else\n        gl_FragDepthEXT = mvt_remapDepth(gl_FragDepthEXT);\n    #endif\n#endif",output_pars_fragment="#define GLSLIFY 1\nuniform bool srgbTransformer;\nuniform bool isLinearToneMapping;\nuniform bool isReinhardToneMapping;\nuniform bool isCineonToneMapping;\nuniform bool isACESFilmicToneMapping;",output_fragment="#define GLSLIFY 1\nif (isLinearToneMapping) {\n    gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );\n}\nelse if (isReinhardToneMapping) {\n    gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );\n}\n// else if (isCineonToneMapping) {\n//     gl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );\n// }\nelse if (isACESFilmicToneMapping) {\n    gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );\n}\n\nif (srgbTransformer) {\n    gl_FragColor = sRGBTransferOETF( gl_FragColor );\n}",addNMrtSupportFragmentShader=e=>{let t=e;t=t.replace("void main() {","#include <mvt_nmrt_output_pars_fragment>\nvoid main() {");const i=t.lastIndexOf("}");return t=t.substring(0,i),t+="#include <mvt_nmrt_output_fragment>\n}",t},addExtraCodeToShader=(e,t,i,n)=>{if((t||i)&&(e=e.replace("void main()",(t||"")+"void main()\n"+(i||""))),n){const t=e.lastIndexOf("}");e=e.substring(0,t),e+=n+"}"}return e},shader_vertex_editable_beforeMainStart="\nattribute float _tileEditableValue;\n",shader_vertex_editable_beforeMainEnd="\nif (_tileEditableValue == 1.0) {\n    gl_Position = vec4(-1.0, -1.0, -1.0, -1.0);\n}\n",addEditableToVertexShader=e=>addExtraCodeToShader(e,shader_vertex_editable_beforeMainStart,null,shader_vertex_editable_beforeMainEnd),addClipableToVertexShader=e=>{const t="void main()",i=(e=e.replace(t,"#include <mvt_clip_pars_vertex>\n"+t)).indexOf(t),n=i+11+e.slice(i+11).indexOf("{")+1;return e=e.slice(0,n)+"\n    #include <mvt_clip_vertex>\n"+e.slice(n)},addClipableToFragmentShader=e=>{const t="void main()",i=(e=e.replace(t,"#include <mvt_clip_pars_fragment>\n"+t)).indexOf(t),n=i+11+e.slice(i+11).indexOf("{")+1;return e=e.slice(0,n)+"\n    #include <mvt_clip_fragment>\n"+e.slice(n)},overridePresetMaterials=()=>{three.MeshBasicMaterial.prototype.emissiveIntensity=1,three.ShaderLib.basic.uniforms.emissive={value:new three.Color(0)},three.ShaderLib.basic.uniforms.isEmissive={value:!1}},addExtraShaderChunks=()=>{three.ShaderChunk.mvt_uniform_zoomunits_pars=uniform_zoomunits_pars,three.ShaderChunk.mvt_extra_vertex_utils=extra_vertex_utils,three.ShaderChunk.mvt_selective_pars_vertex=selective_pars_vertex,three.ShaderChunk.mvt_selective_vertex=selective_vertex,three.ShaderChunk.mvt_selective_pars_fragment=selective_pars_fragment,three.ShaderChunk.mvt_selective_fragment=selective_fragment,three.ShaderChunk.mvt_keepsize_pars_vertex=keepsize_pars_vertex,three.ShaderChunk.mvt_keepsize_vertex=keepsize_vertex,three.ShaderChunk.mvt_emissive_pars_fragment=emissive_pars_fragment,three.ShaderChunk.mvt_emissive_fragment=emissive_fragment,three.ShaderChunk.mvt_override_standard_emissivemap_pars_fragment=override_standard_emissivemap_pars_fragment,three.ShaderChunk.mvt_override_standard_emissivemap_fragment=override_standard_emissivemap_fragment,three.ShaderChunk.mvt_override_basic_color_pars_fragment=override_basic_color_pars_fragment,three.ShaderChunk.mvt_override_basic_color_fragment=override_basic_color_fragment,three.ShaderChunk.mvt_animation_pars_vertex=animation_pars_vertex,three.ShaderChunk.mvt_animation_vertex=animation_vertex,three.ShaderChunk.mvt_animation_label_vertex=animation_label_vertex,three.ShaderChunk.mvt_mrt_output_pars_fragment=mrt_output_pars_fragment,three.ShaderChunk.mvt_mrt_output_fragment=mrt_output_fragment,three.ShaderChunk.mvt_nmrt_output_pars_fragment=nmrt_output_pars_fragment,three.ShaderChunk.mvt_nmrt_output_fragment=nmrt_output_fragment,three.ShaderChunk.mvt_extra_meshbasic_frag_pars=extra_meshbasic_frag_pars,three.ShaderChunk.mvt_clip_pars_vertex=clip_pars_vertex,three.ShaderChunk.mvt_clip_vertex=clip_vertex,three.ShaderChunk.mvt_clip_pars_fragment=clip_pars_fragment,three.ShaderChunk.mvt_clip_fragment=clip_fragment,three.ShaderChunk.mvt_depth_packing=depth_packing,three.ShaderChunk.mvt_depth_range_pars_fragment=depth_range_pars_fragment,three.ShaderChunk.mvt_depth_range_fragment=depth_range_fragment,three.ShaderChunk.output_fragment=output_fragment,three.ShaderChunk.output_pars_fragment=output_pars_fragment},overrideShaders=function(){addExtraShaderChunks(),overridePresetMaterials()};var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function getAugmentedNamespace(e){var t=e.default;if("function"==typeof t){var i=function(){return t.apply(this,arguments)};i.prototype=t.prototype}else i={};return Object.defineProperty(i,"__esModule",{value:!0}),Object.keys(e).forEach((function(t){var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(i,t,n.get?n:{enumerable:!0,get:function(){return e[t]}})})),i}var urlJoin$1={exports:{}},module2,context,definition;module2=urlJoin$1,context=commonjsGlobal,definition=function(){return function(){return function(e){var t=[];if(0===e.length)return"";if("string"!=typeof e[0])throw new TypeError("Url must be a string. Received "+e[0]);if(e[0].match(/^[^/:]+:\/*$/)&&e.length>1){var i=e.shift();e[0]=i+e[0]}e[0].match(/^file:\/\/\//)?e[0]=e[0].replace(/^([^/:]+):\/*/,"$1:///"):e[0]=e[0].replace(/^([^/:]+):\/*/,"$1://");for(var n=0;n<e.length;n++){var r=e[n];if("string"!=typeof r)throw new TypeError("Url must be a string. Received "+r);""!==r&&(n>0&&(r=r.replace(/^[\/]+/,"")),r=n<e.length-1?r.replace(/[\/]+$/,""):r.replace(/[\/]+$/,"/"),t.push(r))}var s=t.join("/"),a=(s=s.replace(/\/(\?|&|#[^!])/g,"$1")).split("?");return a.shift()+(a.length>0?"?":"")+a.join("&")}("object"==typeof arguments[0]?arguments[0]:[].slice.call(arguments))}},module2.exports?module2.exports=definition():context.urljoin=definition();const urlJoin=urlJoin$1.exports;var URI={exports:{}},punycode={exports:{}},hasRequiredPunycode;function requirePunycode(){return hasRequiredPunycode||(hasRequiredPunycode=1,function(e,t){!function(i){var n=t&&!t.nodeType&&t,r=e&&!e.nodeType&&e,s="object"==typeof commonjsGlobal&&commonjsGlobal;s.global!==s&&s.window!==s&&s.self!==s||(i=s);var a,o,l=2147483647,c=36,h=/^xn--/,u=/[^\x20-\x7E]/,d=/[\x2E\u3002\uFF0E\uFF61]/g,p={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},m=Math.floor,f=String.fromCharCode;function g(e){throw new RangeError(p[e])}function _(e,t){for(var i=e.length,n=[];i--;)n[i]=t(e[i]);return n}function A(e,t){var i=e.split("@"),n="";return i.length>1&&(n=i[0]+"@",e=i[1]),n+_((e=e.replace(d,".")).split("."),t).join(".")}function v(e){for(var t,i,n=[],r=0,s=e.length;r<s;)(t=e.charCodeAt(r++))>=55296&&t<=56319&&r<s?56320==(64512&(i=e.charCodeAt(r++)))?n.push(((1023&t)<<10)+(1023&i)+65536):(n.push(t),r--):n.push(t);return n}function y(e){return _(e,(function(e){var t="";return e>65535&&(t+=f((e-=65536)>>>10&1023|55296),e=56320|1023&e),t+=f(e)})).join("")}function x(e,t){return e+22+75*(e<26)-((0!=t)<<5)}function b(e,t,i){var n=0;for(e=i?m(e/700):e>>1,e+=m(e/t);e>455;n+=c)e=m(e/35);return m(n+36*e/(e+38))}function S(e){var t,i,n,r,s,a,o,h,u,d,p,f=[],_=e.length,A=0,v=128,x=72;for((i=e.lastIndexOf("-"))<0&&(i=0),n=0;n<i;++n)e.charCodeAt(n)>=128&&g("not-basic"),f.push(e.charCodeAt(n));for(r=i>0?i+1:0;r<_;){for(s=A,a=1,o=c;r>=_&&g("invalid-input"),((h=(p=e.charCodeAt(r++))-48<10?p-22:p-65<26?p-65:p-97<26?p-97:c)>=c||h>m((l-A)/a))&&g("overflow"),A+=h*a,!(h<(u=o<=x?1:o>=x+26?26:o-x));o+=c)a>m(l/(d=c-u))&&g("overflow"),a*=d;x=b(A-s,t=f.length+1,0==s),m(A/t)>l-v&&g("overflow"),v+=m(A/t),A%=t,f.splice(A++,0,v)}return y(f)}function C(e){var t,i,n,r,s,a,o,h,u,d,p,_,A,y,S,C=[];for(_=(e=v(e)).length,t=128,i=0,s=72,a=0;a<_;++a)(p=e[a])<128&&C.push(f(p));for(n=r=C.length,r&&C.push("-");n<_;){for(o=l,a=0;a<_;++a)(p=e[a])>=t&&p<o&&(o=p);for(o-t>m((l-i)/(A=n+1))&&g("overflow"),i+=(o-t)*A,t=o,a=0;a<_;++a)if((p=e[a])<t&&++i>l&&g("overflow"),p==t){for(h=i,u=c;!(h<(d=u<=s?1:u>=s+26?26:u-s));u+=c)S=h-d,y=c-d,C.push(f(x(d+S%y,0))),h=m(S/y);C.push(f(x(h,0))),s=b(i,A,n==r),i=0,++n}++i,++t}return C.join("")}if(a={version:"1.3.2",ucs2:{decode:v,encode:y},decode:S,encode:C,toASCII:function(e){return A(e,(function(e){return u.test(e)?"xn--"+C(e):e}))},toUnicode:function(e){return A(e,(function(e){return h.test(e)?S(e.slice(4).toLowerCase()):e}))}},n&&r)if(e.exports==n)r.exports=a;else for(o in a)a.hasOwnProperty(o)&&(n[o]=a[o]);else i.punycode=a}(commonjsGlobal)}(punycode,punycode.exports)),punycode.exports}var IPv6={exports:{}},hasRequiredIPv6;
/*!
   * URI.js - Mutating URLs
   * IPv6 Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   */function requireIPv6(){return hasRequiredIPv6||(hasRequiredIPv6=1,function(e){var t,i;t=commonjsGlobal,i=function(e){var t=e&&e.IPv6;return{best:function(e){var t,i,n=e.toLowerCase().split(":"),r=n.length,s=8;for(""===n[0]&&""===n[1]&&""===n[2]?(n.shift(),n.shift()):""===n[0]&&""===n[1]?n.shift():""===n[r-1]&&""===n[r-2]&&n.pop(),-1!==n[(r=n.length)-1].indexOf(".")&&(s=7),t=0;t<r&&""!==n[t];t++);if(t<s)for(n.splice(t,1,"0000");n.length<s;)n.splice(t,0,"0000");for(var a=0;a<s;a++){i=n[a].split("");for(var o=0;o<3&&"0"===i[0]&&i.length>1;o++)i.splice(0,1);n[a]=i.join("")}var l=-1,c=0,h=0,u=-1,d=!1;for(a=0;a<s;a++)d?"0"===n[a]?h+=1:(d=!1,h>c&&(l=u,c=h)):"0"===n[a]&&(d=!0,u=a,h=1);h>c&&(l=u,c=h),c>1&&n.splice(l,c,""),r=n.length;var p="";for(""===n[0]&&(p=":"),a=0;a<r&&(p+=n[a],a!==r-1);a++)p+=":";return""===n[r-1]&&(p+=":"),p},noConflict:function(){return e.IPv6===this&&(e.IPv6=t),this}}},e.exports?e.exports=i():t.IPv6=i(t)}(IPv6)),IPv6.exports}var SecondLevelDomains={exports:{}},hasRequiredSecondLevelDomains;
/*!
   * URI.js - Mutating URLs
   * Second Level Domain (SLD) Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   */function requireSecondLevelDomains(){return hasRequiredSecondLevelDomains||(hasRequiredSecondLevelDomains=1,function(e){var t,i;t=commonjsGlobal,i=function(e){var t=e&&e.SecondLevelDomains,i={list:{ac:" com gov mil net org ",ae:" ac co gov mil name net org pro sch ",af:" com edu gov net org ",al:" com edu gov mil net org ",ao:" co ed gv it og pb ",ar:" com edu gob gov int mil net org tur ",at:" ac co gv or ",au:" asn com csiro edu gov id net org ",ba:" co com edu gov mil net org rs unbi unmo unsa untz unze ",bb:" biz co com edu gov info net org store tv ",bh:" biz cc com edu gov info net org ",bn:" com edu gov net org ",bo:" com edu gob gov int mil net org tv ",br:" adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",bs:" com edu gov net org ",bz:" du et om ov rg ",ca:" ab bc mb nb nf nl ns nt nu on pe qc sk yk ",ck:" biz co edu gen gov info net org ",cn:" ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",co:" com edu gov mil net nom org ",cr:" ac c co ed fi go or sa ",cy:" ac biz com ekloges gov ltd name net org parliament press pro tm ",do:" art com edu gob gov mil net org sld web ",dz:" art asso com edu gov net org pol ",ec:" com edu fin gov info med mil net org pro ",eg:" com edu eun gov mil name net org sci ",er:" com edu gov ind mil net org rochest w ",es:" com edu gob nom org ",et:" biz com edu gov info name net org ",fj:" ac biz com info mil name net org pro ",fk:" ac co gov net nom org ",fr:" asso com f gouv nom prd presse tm ",gg:" co net org ",gh:" com edu gov mil org ",gn:" ac com gov net org ",gr:" com edu gov mil net org ",gt:" com edu gob ind mil net org ",gu:" com edu gov net org ",hk:" com edu gov idv net org ",hu:" 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",id:" ac co go mil net or sch web ",il:" ac co gov idf k12 muni net org ",in:" ac co edu ernet firm gen gov i ind mil net nic org res ",iq:" com edu gov i mil net org ",ir:" ac co dnssec gov i id net org sch ",it:" edu gov ",je:" co net org ",jo:" com edu gov mil name net org sch ",jp:" ac ad co ed go gr lg ne or ",ke:" ac co go info me mobi ne or sc ",kh:" com edu gov mil net org per ",ki:" biz com de edu gov info mob net org tel ",km:" asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",kn:" edu gov net org ",kr:" ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",kw:" com edu gov net org ",ky:" com edu gov net org ",kz:" com edu gov mil net org ",lb:" com edu gov net org ",lk:" assn com edu gov grp hotel int ltd net ngo org sch soc web ",lr:" com edu gov net org ",lv:" asn com conf edu gov id mil net org ",ly:" com edu gov id med net org plc sch ",ma:" ac co gov m net org press ",mc:" asso tm ",me:" ac co edu gov its net org priv ",mg:" com edu gov mil nom org prd tm ",mk:" com edu gov inf name net org pro ",ml:" com edu gov net org presse ",mn:" edu gov org ",mo:" com edu gov net org ",mt:" com edu gov net org ",mv:" aero biz com coop edu gov info int mil museum name net org pro ",mw:" ac co com coop edu gov int museum net org ",mx:" com edu gob net org ",my:" com edu gov mil name net org sch ",nf:" arts com firm info net other per rec store web ",ng:" biz com edu gov mil mobi name net org sch ",ni:" ac co com edu gob mil net nom org ",np:" com edu gov mil net org ",nr:" biz com edu gov info net org ",om:" ac biz co com edu gov med mil museum net org pro sch ",pe:" com edu gob mil net nom org sld ",ph:" com edu gov i mil net ngo org ",pk:" biz com edu fam gob gok gon gop gos gov net org web ",pl:" art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",pr:" ac biz com edu est gov info isla name net org pro prof ",ps:" com edu gov net org plo sec ",pw:" belau co ed go ne or ",ro:" arts com firm info nom nt org rec store tm www ",rs:" ac co edu gov in org ",sb:" com edu gov net org ",sc:" com edu gov net org ",sh:" co com edu gov net nom org ",sl:" com edu gov net org ",st:" co com consulado edu embaixada gov mil net org principe saotome store ",sv:" com edu gob org red ",sz:" ac co org ",tr:" av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",tt:" aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",tw:" club com ebiz edu game gov idv mil net org ",mu:" ac co com gov net or org ",mz:" ac co edu gov org ",na:" co com ",nz:" ac co cri geek gen govt health iwi maori mil net org parliament school ",pa:" abo ac com edu gob ing med net nom org sld ",pt:" com edu gov int net nome org publ ",py:" com edu gov mil net org ",qa:" com edu gov mil net org ",re:" asso com nom ",ru:" ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",rw:" ac co com edu gouv gov int mil net ",sa:" com edu gov med net org pub sch ",sd:" com edu gov info med net org tv ",se:" a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",sg:" com edu gov idn net org per ",sn:" art com edu gouv org perso univ ",sy:" com edu gov mil net news org ",th:" ac co go in mi net or ",tj:" ac biz co com edu go gov info int mil name net nic org test web ",tn:" agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",tz:" ac co go ne or ",ua:" biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",ug:" ac co go ne or org sc ",uk:" ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",us:" dni fed isa kids nsn ",uy:" com edu gub mil net org ",ve:" co com edu gob info mil net org web ",vi:" co com k12 net org ",vn:" ac biz com edu gov health info int name net org pro ",ye:" co com gov ltd me net org plc ",yu:" ac co edu gov org ",za:" ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",zm:" ac co com edu gov net org sch ",com:"ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",net:"gb jp se uk ",org:"ae",de:"com "},has:function(e){var t=e.lastIndexOf(".");if(t<=0||t>=e.length-1)return!1;var n=e.lastIndexOf(".",t-1);if(n<=0||n>=t-1)return!1;var r=i.list[e.slice(t+1)];return!!r&&r.indexOf(" "+e.slice(n+1,t)+" ")>=0},is:function(e){var t=e.lastIndexOf(".");if(t<=0||t>=e.length-1)return!1;if(e.lastIndexOf(".",t-1)>=0)return!1;var n=i.list[e.slice(t+1)];return!!n&&n.indexOf(" "+e.slice(0,t)+" ")>=0},get:function(e){var t=e.lastIndexOf(".");if(t<=0||t>=e.length-1)return null;var n=e.lastIndexOf(".",t-1);if(n<=0||n>=t-1)return null;var r=i.list[e.slice(t+1)];return r?r.indexOf(" "+e.slice(n+1,t)+" ")<0?null:e.slice(n+1):null},noConflict:function(){return e.SecondLevelDomains===this&&(e.SecondLevelDomains=t),this}};return i},e.exports?e.exports=i():t.SecondLevelDomains=i(t)}(SecondLevelDomains)),SecondLevelDomains.exports}
/*!
   * URI.js - Mutating URLs
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   */!function(t){var i,n;i=commonjsGlobal,n=function(t,i,n,r){var s=r&&r.URI;function a(e,t){var i=arguments.length>=1;if(!(this instanceof a))return i?arguments.length>=2?new a(e,t):new a(e):new a;if(void 0===e){if(i)throw new TypeError("undefined is not a valid argument for URI");e="undefined"!=typeof location?location.href+"":""}if(null===e&&i)throw new TypeError("null is not a valid argument for URI");return this.href(e),void 0!==t?this.absoluteTo(t):this}a.version="1.19.11";var o=a.prototype,l=Object.prototype.hasOwnProperty;function c(e){return e.replace(/([.*+?^=!:${}()|[\]\/\\])/g,"\\$1")}function h(e){return void 0===e?"Undefined":String(Object.prototype.toString.call(e)).slice(8,-1)}function u(e){return"Array"===h(e)}function d(e,t){var i,n,r={};if("RegExp"===h(t))r=null;else if(u(t))for(i=0,n=t.length;i<n;i++)r[t[i]]=!0;else r[t]=!0;for(i=0,n=e.length;i<n;i++)(r&&void 0!==r[e[i]]||!r&&t.test(e[i]))&&(e.splice(i,1),n--,i--);return e}function p(e,t){var i,n;if(u(t)){for(i=0,n=t.length;i<n;i++)if(!p(e,t[i]))return!1;return!0}var r=h(t);for(i=0,n=e.length;i<n;i++)if("RegExp"===r){if("string"==typeof e[i]&&e[i].match(t))return!0}else if(e[i]===t)return!0;return!1}function m(e,t){if(!u(e)||!u(t))return!1;if(e.length!==t.length)return!1;e.sort(),t.sort();for(var i=0,n=e.length;i<n;i++)if(e[i]!==t[i])return!1;return!0}function f(e){return e.replace(/^\/+|\/+$/g,"")}function g(e){return escape(e)}function _(e){return encodeURIComponent(e).replace(/[!'()*]/g,g).replace(/\*/g,"%2A")}a._parts=function(){return{protocol:null,username:null,password:null,hostname:null,urn:null,port:null,path:null,query:null,fragment:null,preventInvalidHostname:a.preventInvalidHostname,duplicateQueryParameters:a.duplicateQueryParameters,escapeQuerySpace:a.escapeQuerySpace}},a.preventInvalidHostname=!1,a.duplicateQueryParameters=!1,a.escapeQuerySpace=!0,a.protocol_expression=/^[a-z][a-z0-9.+-]*$/i,a.idn_expression=/[^a-z0-9\._-]/i,a.punycode_expression=/(xn--)/i,a.ip4_expression=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,a.ip6_expression=/^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,a.find_uri_expression=/\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/gi,a.findUri={start:/\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,end:/[\s\r\n]|$/,trim:/[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,parens:/(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g},a.leading_whitespace_expression=/^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/,a.ascii_tab_whitespace=/[\u0009\u000A\u000D]+/g,a.defaultPorts={http:"80",https:"443",ftp:"21",gopher:"70",ws:"80",wss:"443"},a.hostProtocols=["http","https"],a.invalid_hostname_characters=/[^a-zA-Z0-9\.\-:_]/,a.domAttributes={a:"href",blockquote:"cite",link:"href",base:"href",script:"src",form:"action",img:"src",area:"href",iframe:"src",embed:"src",source:"src",track:"src",input:"src",audio:"src",video:"src"},a.getDomAttribute=function(e){if(e&&e.nodeName){var t=e.nodeName.toLowerCase();if("input"!==t||"image"===e.type)return a.domAttributes[t]}},a.encode=_,a.decode=decodeURIComponent,a.iso8859=function(){a.encode=escape,a.decode=unescape},a.unicode=function(){a.encode=_,a.decode=decodeURIComponent},a.characters={pathname:{encode:{expression:/%(24|26|2B|2C|3B|3D|3A|40)/gi,map:{"%24":"$","%26":"&","%2B":"+","%2C":",","%3B":";","%3D":"=","%3A":":","%40":"@"}},decode:{expression:/[\/\?#]/g,map:{"/":"%2F","?":"%3F","#":"%23"}}},reserved:{encode:{expression:/%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/gi,map:{"%3A":":","%2F":"/","%3F":"?","%23":"#","%5B":"[","%5D":"]","%40":"@","%21":"!","%24":"$","%26":"&","%27":"'","%28":"(","%29":")","%2A":"*","%2B":"+","%2C":",","%3B":";","%3D":"="}}},urnpath:{encode:{expression:/%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/gi,map:{"%21":"!","%24":"$","%27":"'","%28":"(","%29":")","%2A":"*","%2B":"+","%2C":",","%3B":";","%3D":"=","%40":"@"}},decode:{expression:/[\/\?#:]/g,map:{"/":"%2F","?":"%3F","#":"%23",":":"%3A"}}}},a.encodeQuery=function(e,t){var i=a.encode(e+"");return void 0===t&&(t=a.escapeQuerySpace),t?i.replace(/%20/g,"+"):i},a.decodeQuery=function(t,i){t+="",void 0===i&&(i=a.escapeQuerySpace);try{return a.decode(i?t.replace(/\+/g,"%20"):t)}catch(e){return t}};var A,v={encode:"encode",decode:"decode"},y=function(t,i){return function(n){try{return a[i](n+"").replace(a.characters[t][i].expression,(function(e){return a.characters[t][i].map[e]}))}catch(e){return n}}};for(A in v)a[A+"PathSegment"]=y("pathname",v[A]),a[A+"UrnPathSegment"]=y("urnpath",v[A]);var x=function(e,t,i){return function(n){var r;r=i?function(e){return a[t](a[i](e))}:a[t];for(var s=(n+"").split(e),o=0,l=s.length;o<l;o++)s[o]=r(s[o]);return s.join(e)}};function b(e){return function(t,i){return void 0===t?this._parts[e]||"":(this._parts[e]=t||null,this.build(!i),this)}}function S(e,t){return function(i,n){return void 0===i?this._parts[e]||"":(null!==i&&(i+="").charAt(0)===t&&(i=i.substring(1)),this._parts[e]=i,this.build(!n),this)}}a.decodePath=x("/","decodePathSegment"),a.decodeUrnPath=x(":","decodeUrnPathSegment"),a.recodePath=x("/","encodePathSegment","decode"),a.recodeUrnPath=x(":","encodeUrnPathSegment","decode"),a.encodeReserved=y("reserved","encode"),a.parse=function(e,t){var i;return t||(t={preventInvalidHostname:a.preventInvalidHostname}),(i=(e=(e=e.replace(a.leading_whitespace_expression,"")).replace(a.ascii_tab_whitespace,"")).indexOf("#"))>-1&&(t.fragment=e.substring(i+1)||null,e=e.substring(0,i)),(i=e.indexOf("?"))>-1&&(t.query=e.substring(i+1)||null,e=e.substring(0,i)),"//"===(e=(e=e.replace(/^(https?|ftp|wss?)?:+[/\\]*/i,"$1://")).replace(/^[/\\]{2,}/i,"//")).substring(0,2)?(t.protocol=null,e=e.substring(2),e=a.parseAuthority(e,t)):(i=e.indexOf(":"))>-1&&(t.protocol=e.substring(0,i)||null,t.protocol&&!t.protocol.match(a.protocol_expression)?t.protocol=void 0:"//"===e.substring(i+1,i+3).replace(/\\/g,"/")?(e=e.substring(i+3),e=a.parseAuthority(e,t)):(e=e.substring(i+1),t.urn=!0)),t.path=e,t},a.parseHost=function(e,t){e||(e="");var i,n,r=(e=e.replace(/\\/g,"/")).indexOf("/");if(-1===r&&(r=e.length),"["===e.charAt(0))i=e.indexOf("]"),t.hostname=e.substring(1,i)||null,t.port=e.substring(i+2,r)||null,"/"===t.port&&(t.port=null);else{var s=e.indexOf(":"),o=e.indexOf("/"),l=e.indexOf(":",s+1);-1!==l&&(-1===o||l<o)?(t.hostname=e.substring(0,r)||null,t.port=null):(n=e.substring(0,r).split(":"),t.hostname=n[0]||null,t.port=n[1]||null)}return t.hostname&&"/"!==e.substring(r).charAt(0)&&(r++,e="/"+e),t.preventInvalidHostname&&a.ensureValidHostname(t.hostname,t.protocol),t.port&&a.ensureValidPort(t.port),e.substring(r)||"/"},a.parseAuthority=function(e,t){return e=a.parseUserinfo(e,t),a.parseHost(e,t)},a.parseUserinfo=function(e,t){var i=e;-1!==e.indexOf("\\")&&(e=e.replace(/\\/g,"/"));var n,r=e.indexOf("/"),s=e.lastIndexOf("@",r>-1?r:e.length-1);return s>-1&&(-1===r||s<r)?(n=e.substring(0,s).split(":"),t.username=n[0]?a.decode(n[0]):null,n.shift(),t.password=n[0]?a.decode(n.join(":")):null,e=i.substring(s+1)):(t.username=null,t.password=null),e},a.parseQuery=function(e,t){if(!e)return{};if(!(e=e.replace(/&+/g,"&").replace(/^\?*&*|&+$/g,"")))return{};for(var i,n,r,s={},o=e.split("&"),c=o.length,h=0;h<c;h++)i=o[h].split("="),n=a.decodeQuery(i.shift(),t),r=i.length?a.decodeQuery(i.join("="),t):null,"__proto__"!==n&&(l.call(s,n)?("string"!=typeof s[n]&&null!==s[n]||(s[n]=[s[n]]),s[n].push(r)):s[n]=r);return s},a.build=function(e){var t="",i=!1;return e.protocol&&(t+=e.protocol+":"),e.urn||!t&&!e.hostname||(t+="//",i=!0),t+=a.buildAuthority(e)||"","string"==typeof e.path&&("/"!==e.path.charAt(0)&&i&&(t+="/"),t+=e.path),"string"==typeof e.query&&e.query&&(t+="?"+e.query),"string"==typeof e.fragment&&e.fragment&&(t+="#"+e.fragment),t},a.buildHost=function(e){var t="";return e.hostname?(a.ip6_expression.test(e.hostname)?t+="["+e.hostname+"]":t+=e.hostname,e.port&&(t+=":"+e.port),t):""},a.buildAuthority=function(e){return a.buildUserinfo(e)+a.buildHost(e)},a.buildUserinfo=function(e){var t="";return e.username&&(t+=a.encode(e.username)),e.password&&(t+=":"+a.encode(e.password)),t&&(t+="@"),t},a.buildQuery=function(e,t,i){var n,r,s,o,c="";for(r in e)if("__proto__"!==r&&l.call(e,r))if(u(e[r]))for(n={},s=0,o=e[r].length;s<o;s++)void 0!==e[r][s]&&void 0===n[e[r][s]+""]&&(c+="&"+a.buildQueryParameter(r,e[r][s],i),!0!==t&&(n[e[r][s]+""]=!0));else void 0!==e[r]&&(c+="&"+a.buildQueryParameter(r,e[r],i));return c.substring(1)},a.buildQueryParameter=function(e,t,i){return a.encodeQuery(e,i)+(null!==t?"="+a.encodeQuery(t,i):"")},a.addQuery=function(e,t,i){if("object"==typeof t)for(var n in t)l.call(t,n)&&a.addQuery(e,n,t[n]);else{if("string"!=typeof t)throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");if(void 0===e[t])return void(e[t]=i);"string"==typeof e[t]&&(e[t]=[e[t]]),u(i)||(i=[i]),e[t]=(e[t]||[]).concat(i)}},a.setQuery=function(e,t,i){if("object"==typeof t)for(var n in t)l.call(t,n)&&a.setQuery(e,n,t[n]);else{if("string"!=typeof t)throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");e[t]=void 0===i?null:i}},a.removeQuery=function(e,t,i){var n,r,s;if(u(t))for(n=0,r=t.length;n<r;n++)e[t[n]]=void 0;else if("RegExp"===h(t))for(s in e)t.test(s)&&(e[s]=void 0);else if("object"==typeof t)for(s in t)l.call(t,s)&&a.removeQuery(e,s,t[s]);else{if("string"!=typeof t)throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");void 0!==i?"RegExp"===h(i)?!u(e[t])&&i.test(e[t])?e[t]=void 0:e[t]=d(e[t],i):e[t]!==String(i)||u(i)&&1!==i.length?u(e[t])&&(e[t]=d(e[t],i)):e[t]=void 0:e[t]=void 0}},a.hasQuery=function(e,t,i,n){switch(h(t)){case"String":break;case"RegExp":for(var r in e)if(l.call(e,r)&&t.test(r)&&(void 0===i||a.hasQuery(e,r,i)))return!0;return!1;case"Object":for(var s in t)if(l.call(t,s)&&!a.hasQuery(e,s,t[s]))return!1;return!0;default:throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter")}switch(h(i)){case"Undefined":return t in e;case"Boolean":return i===Boolean(u(e[t])?e[t].length:e[t]);case"Function":return!!i(e[t],t,e);case"Array":return!!u(e[t])&&(n?p:m)(e[t],i);case"RegExp":return u(e[t])?!!n&&p(e[t],i):Boolean(e[t]&&e[t].match(i));case"Number":i=String(i);case"String":return u(e[t])?!!n&&p(e[t],i):e[t]===i;default:throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter")}},a.joinPaths=function(){for(var e=[],t=[],i=0,n=0;n<arguments.length;n++){var r=new a(arguments[n]);e.push(r);for(var s=r.segment(),o=0;o<s.length;o++)"string"==typeof s[o]&&t.push(s[o]),s[o]&&i++}if(!t.length||!i)return new a("");var l=new a("").segment(t);return""!==e[0].path()&&"/"!==e[0].path().slice(0,1)||l.path("/"+l.path()),l.normalize()},a.commonPath=function(e,t){var i,n=Math.min(e.length,t.length);for(i=0;i<n;i++)if(e.charAt(i)!==t.charAt(i)){i--;break}return i<1?e.charAt(0)===t.charAt(0)&&"/"===e.charAt(0)?"/":"":("/"===e.charAt(i)&&"/"===t.charAt(i)||(i=e.substring(0,i).lastIndexOf("/")),e.substring(0,i+1))},a.withinString=function(e,t,i){i||(i={});var n=i.start||a.findUri.start,r=i.end||a.findUri.end,s=i.trim||a.findUri.trim,o=i.parens||a.findUri.parens,l=/[a-z0-9-]=["']?$/i;for(n.lastIndex=0;;){var c=n.exec(e);if(!c)break;var h=c.index;if(i.ignoreHtml){var u=e.slice(Math.max(h-3,0),h);if(u&&l.test(u))continue}for(var d=h+e.slice(h).search(r),p=e.slice(h,d),m=-1;;){var f=o.exec(p);if(!f)break;var g=f.index+f[0].length;m=Math.max(m,g)}if(!((p=m>-1?p.slice(0,m)+p.slice(m).replace(s,""):p.replace(s,"")).length<=c[0].length||i.ignore&&i.ignore.test(p))){var _=t(p,h,d=h+p.length,e);void 0!==_?(_=String(_),e=e.slice(0,h)+_+e.slice(d),n.lastIndex=h+_.length):n.lastIndex=d}}return n.lastIndex=0,e},a.ensureValidHostname=function(e,i){var n=!!e,r=!1;if(!!i&&(r=p(a.hostProtocols,i)),r&&!n)throw new TypeError("Hostname cannot be empty, if protocol is "+i);if(e&&e.match(a.invalid_hostname_characters)){if(!t)throw new TypeError('Hostname "'+e+'" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');if(t.toASCII(e).match(a.invalid_hostname_characters))throw new TypeError('Hostname "'+e+'" contains characters other than [A-Z0-9.-:_]')}},a.ensureValidPort=function(e){if(e){var t=Number(e);if(!(/^[0-9]+$/.test(t)&&t>0&&t<65536))throw new TypeError('Port "'+e+'" is not a valid port')}},a.noConflict=function(e){if(e){var t={URI:this.noConflict()};return r.URITemplate&&"function"==typeof r.URITemplate.noConflict&&(t.URITemplate=r.URITemplate.noConflict()),r.IPv6&&"function"==typeof r.IPv6.noConflict&&(t.IPv6=r.IPv6.noConflict()),r.SecondLevelDomains&&"function"==typeof r.SecondLevelDomains.noConflict&&(t.SecondLevelDomains=r.SecondLevelDomains.noConflict()),t}return r.URI===this&&(r.URI=s),this},o.build=function(e){return!0===e?this._deferred_build=!0:(void 0===e||this._deferred_build)&&(this._string=a.build(this._parts),this._deferred_build=!1),this},o.clone=function(){return new a(this)},o.valueOf=o.toString=function(){return this.build(!1)._string},o.protocol=b("protocol"),o.username=b("username"),o.password=b("password"),o.hostname=b("hostname"),o.port=b("port"),o.query=S("query","?"),o.fragment=S("fragment","#"),o.search=function(e,t){var i=this.query(e,t);return"string"==typeof i&&i.length?"?"+i:i},o.hash=function(e,t){var i=this.fragment(e,t);return"string"==typeof i&&i.length?"#"+i:i},o.pathname=function(e,t){if(void 0===e||!0===e){var i=this._parts.path||(this._parts.hostname?"/":"");return e?(this._parts.urn?a.decodeUrnPath:a.decodePath)(i):i}return this._parts.urn?this._parts.path=e?a.recodeUrnPath(e):"":this._parts.path=e?a.recodePath(e):"/",this.build(!t),this},o.path=o.pathname,o.href=function(e,t){var i;if(void 0===e)return this.toString();this._string="",this._parts=a._parts();var n=e instanceof a,r="object"==typeof e&&(e.hostname||e.path||e.pathname);if(e.nodeName&&(e=e[a.getDomAttribute(e)]||"",r=!1),!n&&r&&void 0!==e.pathname&&(e=e.toString()),"string"==typeof e||e instanceof String)this._parts=a.parse(String(e),this._parts);else{if(!n&&!r)throw new TypeError("invalid input");var s=n?e._parts:e;for(i in s)"query"!==i&&l.call(this._parts,i)&&(this._parts[i]=s[i]);s.query&&this.query(s.query,!1)}return this.build(!t),this},o.is=function(e){var t=!1,i=!1,r=!1,s=!1,o=!1,l=!1,c=!1,h=!this._parts.urn;switch(this._parts.hostname&&(h=!1,i=a.ip4_expression.test(this._parts.hostname),r=a.ip6_expression.test(this._parts.hostname),o=(s=!(t=i||r))&&n&&n.has(this._parts.hostname),l=s&&a.idn_expression.test(this._parts.hostname),c=s&&a.punycode_expression.test(this._parts.hostname)),e.toLowerCase()){case"relative":return h;case"absolute":return!h;case"domain":case"name":return s;case"sld":return o;case"ip":return t;case"ip4":case"ipv4":case"inet4":return i;case"ip6":case"ipv6":case"inet6":return r;case"idn":return l;case"url":return!this._parts.urn;case"urn":return!!this._parts.urn;case"punycode":return c}return null};var C=o.protocol,T=o.port,E=o.hostname;o.protocol=function(e,t){if(e&&!(e=e.replace(/:(\/\/)?$/,"")).match(a.protocol_expression))throw new TypeError('Protocol "'+e+"\" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]");return C.call(this,e,t)},o.scheme=o.protocol,o.port=function(e,t){return this._parts.urn?void 0===e?"":this:(void 0!==e&&(0===e&&(e=null),e&&(":"===(e+="").charAt(0)&&(e=e.substring(1)),a.ensureValidPort(e))),T.call(this,e,t))},o.hostname=function(e,t){if(this._parts.urn)return void 0===e?"":this;if(void 0!==e){var i={preventInvalidHostname:this._parts.preventInvalidHostname};if("/"!==a.parseHost(e,i))throw new TypeError('Hostname "'+e+'" contains characters other than [A-Z0-9.-]');e=i.hostname,this._parts.preventInvalidHostname&&a.ensureValidHostname(e,this._parts.protocol)}return E.call(this,e,t)},o.origin=function(e,t){if(this._parts.urn)return void 0===e?"":this;if(void 0===e){var i=this.protocol();return this.authority()?(i?i+"://":"")+this.authority():""}var n=a(e);return this.protocol(n.protocol()).authority(n.authority()).build(!t),this},o.host=function(e,t){if(this._parts.urn)return void 0===e?"":this;if(void 0===e)return this._parts.hostname?a.buildHost(this._parts):"";if("/"!==a.parseHost(e,this._parts))throw new TypeError('Hostname "'+e+'" contains characters other than [A-Z0-9.-]');return this.build(!t),this},o.authority=function(e,t){if(this._parts.urn)return void 0===e?"":this;if(void 0===e)return this._parts.hostname?a.buildAuthority(this._parts):"";if("/"!==a.parseAuthority(e,this._parts))throw new TypeError('Hostname "'+e+'" contains characters other than [A-Z0-9.-]');return this.build(!t),this},o.userinfo=function(e,t){if(this._parts.urn)return void 0===e?"":this;if(void 0===e){var i=a.buildUserinfo(this._parts);return i?i.substring(0,i.length-1):i}return"@"!==e[e.length-1]&&(e+="@"),a.parseUserinfo(e,this._parts),this.build(!t),this},o.resource=function(e,t){var i;return void 0===e?this.path()+this.search()+this.hash():(i=a.parse(e),this._parts.path=i.path,this._parts.query=i.query,this._parts.fragment=i.fragment,this.build(!t),this)},o.subdomain=function(e,t){if(this._parts.urn)return void 0===e?"":this;if(void 0===e){if(!this._parts.hostname||this.is("IP"))return"";var i=this._parts.hostname.length-this.domain().length-1;return this._parts.hostname.substring(0,i)||""}var n=this._parts.hostname.length-this.domain().length,r=this._parts.hostname.substring(0,n),s=new RegExp("^"+c(r));if(e&&"."!==e.charAt(e.length-1)&&(e+="."),-1!==e.indexOf(":"))throw new TypeError("Domains cannot contain colons");return e&&a.ensureValidHostname(e,this._parts.protocol),this._parts.hostname=this._parts.hostname.replace(s,e),this.build(!t),this},o.domain=function(e,t){if(this._parts.urn)return void 0===e?"":this;if("boolean"==typeof e&&(t=e,e=void 0),void 0===e){if(!this._parts.hostname||this.is("IP"))return"";var i=this._parts.hostname.match(/\./g);if(i&&i.length<2)return this._parts.hostname;var n=this._parts.hostname.length-this.tld(t).length-1;return n=this._parts.hostname.lastIndexOf(".",n-1)+1,this._parts.hostname.substring(n)||""}if(!e)throw new TypeError("cannot set domain empty");if(-1!==e.indexOf(":"))throw new TypeError("Domains cannot contain colons");if(a.ensureValidHostname(e,this._parts.protocol),!this._parts.hostname||this.is("IP"))this._parts.hostname=e;else{var r=new RegExp(c(this.domain())+"$");this._parts.hostname=this._parts.hostname.replace(r,e)}return this.build(!t),this},o.tld=function(e,t){if(this._parts.urn)return void 0===e?"":this;if("boolean"==typeof e&&(t=e,e=void 0),void 0===e){if(!this._parts.hostname||this.is("IP"))return"";var i=this._parts.hostname.lastIndexOf("."),r=this._parts.hostname.substring(i+1);return!0!==t&&n&&n.list[r.toLowerCase()]&&n.get(this._parts.hostname)||r}var s;if(!e)throw new TypeError("cannot set TLD empty");if(e.match(/[^a-zA-Z0-9-]/)){if(!n||!n.is(e))throw new TypeError('TLD "'+e+'" contains characters other than [A-Z0-9]');s=new RegExp(c(this.tld())+"$"),this._parts.hostname=this._parts.hostname.replace(s,e)}else{if(!this._parts.hostname||this.is("IP"))throw new ReferenceError("cannot set TLD on non-domain host");s=new RegExp(c(this.tld())+"$"),this._parts.hostname=this._parts.hostname.replace(s,e)}return this.build(!t),this},o.directory=function(e,t){if(this._parts.urn)return void 0===e?"":this;if(void 0===e||!0===e){if(!this._parts.path&&!this._parts.hostname)return"";if("/"===this._parts.path)return"/";var i=this._parts.path.length-this.filename().length-1,n=this._parts.path.substring(0,i)||(this._parts.hostname?"/":"");return e?a.decodePath(n):n}var r=this._parts.path.length-this.filename().length,s=this._parts.path.substring(0,r),o=new RegExp("^"+c(s));return this.is("relative")||(e||(e="/"),"/"!==e.charAt(0)&&(e="/"+e)),e&&"/"!==e.charAt(e.length-1)&&(e+="/"),e=a.recodePath(e),this._parts.path=this._parts.path.replace(o,e),this.build(!t),this},o.filename=function(e,t){if(this._parts.urn)return void 0===e?"":this;if("string"!=typeof e){if(!this._parts.path||"/"===this._parts.path)return"";var i=this._parts.path.lastIndexOf("/"),n=this._parts.path.substring(i+1);return e?a.decodePathSegment(n):n}var r=!1;"/"===e.charAt(0)&&(e=e.substring(1)),e.match(/\.?\//)&&(r=!0);var s=new RegExp(c(this.filename())+"$");return e=a.recodePath(e),this._parts.path=this._parts.path.replace(s,e),r?this.normalizePath(t):this.build(!t),this},o.suffix=function(e,t){if(this._parts.urn)return void 0===e?"":this;if(void 0===e||!0===e){if(!this._parts.path||"/"===this._parts.path)return"";var i,n,r=this.filename(),s=r.lastIndexOf(".");return-1===s?"":(i=r.substring(s+1),n=/^[a-z0-9%]+$/i.test(i)?i:"",e?a.decodePathSegment(n):n)}"."===e.charAt(0)&&(e=e.substring(1));var o,l=this.suffix();if(l)o=e?new RegExp(c(l)+"$"):new RegExp(c("."+l)+"$");else{if(!e)return this;this._parts.path+="."+a.recodePath(e)}return o&&(e=a.recodePath(e),this._parts.path=this._parts.path.replace(o,e)),this.build(!t),this},o.segment=function(e,t,i){var n=this._parts.urn?":":"/",r=this.path(),s="/"===r.substring(0,1),a=r.split(n);if(void 0!==e&&"number"!=typeof e&&(i=t,t=e,e=void 0),void 0!==e&&"number"!=typeof e)throw new Error('Bad segment "'+e+'", must be 0-based integer');if(s&&a.shift(),e<0&&(e=Math.max(a.length+e,0)),void 0===t)return void 0===e?a:a[e];if(null===e||void 0===a[e])if(u(t)){a=[];for(var o=0,l=t.length;o<l;o++)(t[o].length||a.length&&a[a.length-1].length)&&(a.length&&!a[a.length-1].length&&a.pop(),a.push(f(t[o])))}else(t||"string"==typeof t)&&(t=f(t),""===a[a.length-1]?a[a.length-1]=t:a.push(t));else t?a[e]=f(t):a.splice(e,1);return s&&a.unshift(""),this.path(a.join(n),i)},o.segmentCoded=function(e,t,i){var n,r,s;if("number"!=typeof e&&(i=t,t=e,e=void 0),void 0===t){if(u(n=this.segment(e,t,i)))for(r=0,s=n.length;r<s;r++)n[r]=a.decode(n[r]);else n=void 0!==n?a.decode(n):void 0;return n}if(u(t))for(r=0,s=t.length;r<s;r++)t[r]=a.encode(t[r]);else t="string"==typeof t||t instanceof String?a.encode(t):t;return this.segment(e,t,i)};var M=o.query;return o.query=function(e,t){if(!0===e)return a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);if("function"==typeof e){var i=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace),n=e.call(this,i);return this._parts.query=a.buildQuery(n||i,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace),this.build(!t),this}return void 0!==e&&"string"!=typeof e?(this._parts.query=a.buildQuery(e,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace),this.build(!t),this):M.call(this,e,t)},o.setQuery=function(e,t,i){var n=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);if("string"==typeof e||e instanceof String)n[e]=void 0!==t?t:null;else{if("object"!=typeof e)throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");for(var r in e)l.call(e,r)&&(n[r]=e[r])}return this._parts.query=a.buildQuery(n,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace),"string"!=typeof e&&(i=t),this.build(!i),this},o.addQuery=function(e,t,i){var n=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);return a.addQuery(n,e,void 0===t?null:t),this._parts.query=a.buildQuery(n,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace),"string"!=typeof e&&(i=t),this.build(!i),this},o.removeQuery=function(e,t,i){var n=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);return a.removeQuery(n,e,t),this._parts.query=a.buildQuery(n,this._parts.duplicateQueryParameters,this._parts.escapeQuerySpace),"string"!=typeof e&&(i=t),this.build(!i),this},o.hasQuery=function(e,t,i){var n=a.parseQuery(this._parts.query,this._parts.escapeQuerySpace);return a.hasQuery(n,e,t,i)},o.setSearch=o.setQuery,o.addSearch=o.addQuery,o.removeSearch=o.removeQuery,o.hasSearch=o.hasQuery,o.normalize=function(){return this._parts.urn?this.normalizeProtocol(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build():this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build()},o.normalizeProtocol=function(e){return"string"==typeof this._parts.protocol&&(this._parts.protocol=this._parts.protocol.toLowerCase(),this.build(!e)),this},o.normalizeHostname=function(e){return this._parts.hostname&&(this.is("IDN")&&t?this._parts.hostname=t.toASCII(this._parts.hostname):this.is("IPv6")&&i&&(this._parts.hostname=i.best(this._parts.hostname)),this._parts.hostname=this._parts.hostname.toLowerCase(),this.build(!e)),this},o.normalizePort=function(e){return"string"==typeof this._parts.protocol&&this._parts.port===a.defaultPorts[this._parts.protocol]&&(this._parts.port=null,this.build(!e)),this},o.normalizePath=function(e){var t,i=this._parts.path;if(!i)return this;if(this._parts.urn)return this._parts.path=a.recodeUrnPath(this._parts.path),this.build(!e),this;if("/"===this._parts.path)return this;var n,r,s="";for("/"!==(i=a.recodePath(i)).charAt(0)&&(t=!0,i="/"+i),"/.."!==i.slice(-3)&&"/."!==i.slice(-2)||(i+="/"),i=i.replace(/(\/(\.\/)+)|(\/\.$)/g,"/").replace(/\/{2,}/g,"/"),t&&(s=i.substring(1).match(/^(\.\.\/)+/)||"")&&(s=s[0]);-1!==(n=i.search(/\/\.\.(\/|$)/));)0!==n?(-1===(r=i.substring(0,n).lastIndexOf("/"))&&(r=n),i=i.substring(0,r)+i.substring(n+3)):i=i.substring(3);return t&&this.is("relative")&&(i=s+i.substring(1)),this._parts.path=i,this.build(!e),this},o.normalizePathname=o.normalizePath,o.normalizeQuery=function(e){return"string"==typeof this._parts.query&&(this._parts.query.length?this.query(a.parseQuery(this._parts.query,this._parts.escapeQuerySpace)):this._parts.query=null,this.build(!e)),this},o.normalizeFragment=function(e){return this._parts.fragment||(this._parts.fragment=null,this.build(!e)),this},o.normalizeSearch=o.normalizeQuery,o.normalizeHash=o.normalizeFragment,o.iso8859=function(){var e=a.encode,t=a.decode;a.encode=escape,a.decode=decodeURIComponent;try{this.normalize()}finally{a.encode=e,a.decode=t}return this},o.unicode=function(){var e=a.encode,t=a.decode;a.encode=_,a.decode=unescape;try{this.normalize()}finally{a.encode=e,a.decode=t}return this},o.readable=function(){var e=this.clone();e.username("").password("").normalize();var i="";if(e._parts.protocol&&(i+=e._parts.protocol+"://"),e._parts.hostname&&(e.is("punycode")&&t?(i+=t.toUnicode(e._parts.hostname),e._parts.port&&(i+=":"+e._parts.port)):i+=e.host()),e._parts.hostname&&e._parts.path&&"/"!==e._parts.path.charAt(0)&&(i+="/"),i+=e.path(!0),e._parts.query){for(var n="",r=0,s=e._parts.query.split("&"),o=s.length;r<o;r++){var l=(s[r]||"").split("=");n+="&"+a.decodeQuery(l[0],this._parts.escapeQuerySpace).replace(/&/g,"%26"),void 0!==l[1]&&(n+="="+a.decodeQuery(l[1],this._parts.escapeQuerySpace).replace(/&/g,"%26"))}i+="?"+n.substring(1)}return i+=a.decodeQuery(e.hash(),!0)},o.absoluteTo=function(e){var t,i,n,r=this.clone(),s=["protocol","username","password","hostname","port"];if(this._parts.urn)throw new Error("URNs do not have any generally defined hierarchical components");if(e instanceof a||(e=new a(e)),r._parts.protocol)return r;if(r._parts.protocol=e._parts.protocol,this._parts.hostname)return r;for(i=0;n=s[i];i++)r._parts[n]=e._parts[n];return r._parts.path?(".."===r._parts.path.substring(-2)&&(r._parts.path+="/"),"/"!==r.path().charAt(0)&&(t=(t=e.directory())||(0===e.path().indexOf("/")?"/":""),r._parts.path=(t?t+"/":"")+r._parts.path,r.normalizePath())):(r._parts.path=e._parts.path,r._parts.query||(r._parts.query=e._parts.query)),r.build(),r},o.relativeTo=function(e){var t,i,n,r,s,o=this.clone().normalize();if(o._parts.urn)throw new Error("URNs do not have any generally defined hierarchical components");if(e=new a(e).normalize(),t=o._parts,i=e._parts,r=o.path(),s=e.path(),"/"!==r.charAt(0))throw new Error("URI is already relative");if("/"!==s.charAt(0))throw new Error("Cannot calculate a URI relative to another relative URI");if(t.protocol===i.protocol&&(t.protocol=null),t.username!==i.username||t.password!==i.password)return o.build();if(null!==t.protocol||null!==t.username||null!==t.password)return o.build();if(t.hostname!==i.hostname||t.port!==i.port)return o.build();if(t.hostname=null,t.port=null,r===s)return t.path="",o.build();if(!(n=a.commonPath(r,s)))return o.build();var l=i.path.substring(n.length).replace(/[^\/]*$/,"").replace(/.*?\//g,"../");return t.path=l+t.path.substring(n.length)||"./",o.build()},o.equals=function(e){var t,i,n,r,s,o=this.clone(),c=new a(e),h={};if(o.normalize(),c.normalize(),o.toString()===c.toString())return!0;if(n=o.query(),r=c.query(),o.query(""),c.query(""),o.toString()!==c.toString())return!1;if(n.length!==r.length)return!1;for(s in t=a.parseQuery(n,this._parts.escapeQuerySpace),i=a.parseQuery(r,this._parts.escapeQuerySpace),t)if(l.call(t,s)){if(u(t[s])){if(!m(t[s],i[s]))return!1}else if(t[s]!==i[s])return!1;h[s]=!0}for(s in i)if(l.call(i,s)&&!h[s])return!1;return!0},o.preventInvalidHostname=function(e){return this._parts.preventInvalidHostname=!!e,this},o.duplicateQueryParameters=function(e){return this._parts.duplicateQueryParameters=!!e,this},o.escapeQuerySpace=function(e){return this._parts.escapeQuerySpace=!!e,this},a},t.exports?t.exports=n(requirePunycode(),requireIPv6(),requireSecondLevelDomains()):i.URI=n(i.punycode,i.IPv6,i.SecondLevelDomains,i)}(URI);const Uri=URI.exports;function isObject(e){return e&&"object"==typeof e&&!Array.isArray(e)}function isNumber(e){return!isNaN(e)&&null!==e&&!Array.isArray(e)}function defined$2(e){return null!=e}function defaultValue$1(e,t){return null!=e?e:t}function deepMerge(e,...t){if(!t.length)return e;const i=t.shift();if(isObject(e)&&isObject(i))for(const n in i)isObject(i[n])&&i[n].constructor===Object?(e[n]||Object.assign(e,{[n]:{}}),deepMerge(e[n],i[n])):Object.assign(e,{[n]:i[n]});return deepMerge(e,...t)}function clone$2(e,t=!1){if(null===e||"object"!=typeof e)return e;const i=new e.constructor;for(const n in e)if(e.hasOwnProperty(n)){let r=e[n];t&&(r=clone$2(r,t)),i[n]=r}return i}function combine$1(e,t,i){i=defaultValue$1(i,!1);const n={},r=defined$2(e),s=defined$2(t);let a,o,l;if(r)for(a in e)e.hasOwnProperty(a)&&(o=e[a],s&&i&&"object"==typeof o&&t.hasOwnProperty(a)?(l=t[a],n[a]="object"==typeof l?combine$1(o,l,i):o):n[a]=o);if(s)for(a in t)t.hasOwnProperty(a)&&!n.hasOwnProperty(a)&&(l=t[a],n[a]=l);return n}defaultValue$1.EMPTY_OBJECT=Object.freeze({}),defaultValue$1.EMPTY_MAT4=Object.freeze(new three.Matrix4);const object$1=Object.freeze(Object.defineProperty({__proto__:null,isObject:isObject,isNumber:isNumber,defined:defined$2,defaultValue:defaultValue$1,deepMerge:deepMerge,clone:clone$2,combine:combine$1},Symbol.toStringTag,{value:"Module"}));let baseUrl=null;function getBaseUrl(){if(null!==baseUrl)return baseUrl;let e="";if(e="string"==typeof MAPV_BASE_URL?MAPV_BASE_URL:getBaseUrlFromScript(),!e)throw new Error("Unable to determine base URL automatically, try defining a global variable called MAPV_BASE_URL.");return baseUrl=e,e}const mapvScriptRegex=/((?:.*\/)|^)mapvthree(\.bmap)?\.(es|umd)\.js(?:\?|\#|$)/;function getBaseUrlFromScript(){if("undefined"==typeof document)return;let e=document.getElementsByTagName("script");for(let t=0,i=e.length;t<i;++t){let i=e[t].getAttribute("src"),n=mapvScriptRegex.exec(i);if(null!==n)return n[1]}}function getAssetUrl(...e){return urlJoin(getBaseUrl(),...e)}function getAbsoluteUri(e,t){let i;if("undefined"!=typeof document&&(i=document),!defined$2(t)){if(void 0===i)return e;t=defaultValue$1(i.baseURI,i.location.href)}const n=new Uri(e);return""!==n.scheme()?n.toString():n.absoluteTo(t).toString()}function getExtensionFromUri(e){const t=new Uri(e);t.normalize();let i=t.path(),n=i.lastIndexOf("/");return-1!==n&&(i=i.substr(n+1)),n=i.lastIndexOf("."),i=-1===n?"":i.substr(n+1),i}function getBaseUri(e,t){let i="";const n=e.lastIndexOf("/");return-1!==n&&(i=e.substring(0,n+1)),t?(0!==(e=new Uri(e)).query().length&&(i+=`?${e.query()}`),0!==e.fragment().length&&(i+=`#${e.fragment()}`),i):i}const urlUtils=Object.freeze(Object.defineProperty({__proto__:null,getBaseUrl:getBaseUrl,getAssetUrl:getAssetUrl,getAbsoluteUri:getAbsoluteUri,getExtensionFromUri:getExtensionFromUri,getBaseUri:getBaseUri},Symbol.toStringTag,{value:"Module"}));class GradientColorLerp{constructor(e){if(!e||0===e.length)throw new Error("points is required");const t=e[0][1];t.isColor?this._isColorFormat=!0:t.isVector3&&(this._isVectorFormat=!0),this._points=e}lerp(e,t){if(e<=0)return this._points[0][1];if(e>=1)return this._points[this._points.length-1][1];let i=0;for(;i<this._points.length&&!(e<=this._points[i][0]);i++);if(e>this._points[this._points.length-1][0])return this._points[this._points.length-1][1];const[n,r]=this._points[i-1],[s,a]=this._points[i],o=(e-n)/(s-n);if(this._isVectorFormat){const e=r.x+(a.x-r.x)*o,i=r.y+(a.y-r.y)*o,n=r.z+(a.z-r.z)*o;return t||(t=new three.Vector3),t.set(e,i,n),t}if(this._isColorFormat){const e=r.r+(a.r-r.r)*o,i=r.g+(a.g-r.g)*o,n=r.b+(a.b-r.b)*o;return t||(t=new three.Color),t.set(e,i,n),t}return r+(a-r)*o}}class EmptySky extends three.Group{constructor(e={}){super(),__publicField(this,"isEmptySky",!0),__publicField(this,"name","EmptySky"),__publicField(this,"_addDefaultEnvMap",!1),__publicField(this,"_time",-1),__publicField(this,"_timeRatio",10/24),__publicField(this,"_skyLightIntensity",1.2),__publicField(this,"_sunLightIntensity",2.2),__publicField(this,"_skyLightAttenuationRatio",.2),__publicField(this,"_sunIntensityBias",0),__publicField(this,"_sunIntensityScale",.8),__publicField(this,"_envLightIntensity",.2),__publicField(this,"_weather","partlyCloudy"),__publicField(this,"_timeChangedListeners",[]),__publicField(this,"_sunDirection",new three.Vector3),__publicField(this,"_localSunDirection",new three.Vector3),__publicField(this,"_sunLightColorDay",new three.Color(16777215)),__publicField(this,"_sunLightColorSunset",new three.Color(15090944)),__publicField(this,"_sunLightColorCurrent",new three.Color(16777215)),__publicField(this,"_sunRadian",null),__publicField(this,"_skyLightColorDay",new three.Color(16777215)),__publicField(this,"_skyLightColorNight",new three.Color(16777215)),__publicField(this,"_groundLightColorDay",new three.Color(16777215)),__publicField(this,"_groundLightColorNight",new three.Color(16758093)),__publicField(this,"_lightNeedsUpdate",!0),__publicField(this,"_sunNeedsUpdate",!1),__publicField(this,"_affectWorld",!1),__publicField(this,"_presetWeatherProperties",{clear:{sunLightIntensity:2.5,skyLightIntensity:1.2},partlyCloudy:{sunLightIntensity:2.2,skyLightIntensity:1.2},cloudy:{sunLightIntensity:0,skyLightIntensity:1.5},overcast:{sunLightIntensity:0,skyLightIntensity:1.5},foggy:{sunLightIntensity:0,skyLightIntensity:1.5},rainy:{sunLightIntensity:0,skyLightIntensity:1.5},snowy:{sunLightIntensity:0,skyLightIntensity:1.5},stormy:{sunLightIntensity:0,skyLightIntensity:1.5}}),__publicField(this,"updateSunLightShadowCamera",(()=>{const e=this.engine;if(!e.renderer.shadowMap.enabled){const e=this.sunLight;return e.position.copy(this._sunDirection),e.target.position.set(0,0,0),e.updateMatrix(),e.updateMatrixWorld(),e.target.updateMatrix(),void e.target.updateMatrixWorld()}e.rendering.shadow.updateShadow(this.sunLight,this._sunDirection,this)}));const t=this.sunLight=new three.DirectionalLight(16777215,.6),i=this.skyLight=new three.AmbientLight(16755200,this._skyLightIntensity);i.position.set(0,0,1),t.castShadow=!0,t.shadow.mapSize=new three.Vector2(2048,2048),t.shadow.bias=-1e-4,this.add(t),this.add(t.target),this.add(i),t.matrixAutoUpdate=!1,t.target.matrixAutoUpdate=!1,this._sunLightGradientColorLerp=new GradientColorLerp([[0,new three.Color("#395e8c")],[5.5/24,new three.Color("#395e8c")],[.25,new three.Color("#ff0000")],[6.5/24,new three.Color("#fad277")],[.3125,new three.Color("#ffffff")],[.5,new three.Color("#ffffff")]]),this.envLightIntensity=.1,void 0!==e.time&&(this._time=e.time)}afterAddToEngine(e){if(this.engine=e,!this.isDynamicSky&&!this.isStaticSky&&this._addDefaultEnvMap){const t=(new three.TextureLoader).load(getAssetUrl("assets/textures/sky/partlyCloudy_default.jpg"));t.mapping=three.EquirectangularReflectionMapping,t.colorSpace=three.SRGBColorSpace,e.rendering.scene.environment=t}this.envLightIntensity=this._envLightIntensity}_syncTimeFromClock(){const e=this.engine.clock.currentTime,t=this._time;this._time=3600*e.getHours()+60*e.getMinutes()+e.getSeconds(),this._timeRatio=this._time/86400,this._timeChanged=t!==this._time}beforeRemoveFromEngine(e){this.dispose()}onBeforeScenePrepareRender(){if(this._syncTimeFromClock(),(this._timeChanged||this._lightNeedsUpdate)&&(this.updateLight(),this._lightNeedsUpdate=!1),this.updateSunLightShadowCamera(),this._timeChanged){this._updateSunDirection(),this.onTimeChanged(this._time);for(const e of this._timeChangedListeners)e(this.time);this._timeChanged=!1}}updateLight(){this.sunLight.intensity=this._sunLightIntensity,this.isCustomStaticSky?this.skyLight.intensity=0:(this.skyLight.intensity=this._skyLightIntensity,this.skyLight.color.copy(this._skyLightColorDay)),this._sunLightColorCurrent=this._sunLightGradientColorLerp.lerp(this._timeRatio>.5?1-this._timeRatio:this._timeRatio),this.sunLight.color.copy(this._sunLightColorCurrent)}_updateSunDirection(){const e=this._time;if(this.engine&&this.engine.map.isGlobe){const t=this._sunRadian=(e/86400+.25)*Math.PI*2,i=Math.cos(t),n=Math.sin(t);this._sunDirection.set(i,-n,0),this._localSunDirection.set(-i,-n,0)}else{const t=(e/86400-.25)*Math.PI*2,i=Math.cos(t),n=Math.sin(t);this._localSunDirection.set(i,n,0),this._sunDirection.set(i,0,n),n<-.1&&this._sunDirection.negate()}}addTimeChangedListener(e){-1===this._timeChangedListeners.indexOf(e)&&this._timeChangedListeners.push(e)}removeTimeChangedListener(e){const t=this._timeChangedListeners.indexOf(e);-1!==t&&this._timeChangedListeners.splice(t,1)}onTimeChanged(e){}onWeatherChanged(e){}getPresetWeatherProperties(e){return this._presetWeatherProperties[e]}dispose(){}get time(){return this._time}set time(e){console.warn("Sky.time is deprecated, please use engine.clock.currentTime instead"),this.engine.clock._setTimeLegacy(e)}get sunIntensityBias(){return this._sunIntensityBias}set sunIntensityBias(e){this._sunIntensityBias=e,this._lightNeedsUpdate=!0}get sunIntensityScale(){return this._sunIntensityScale}set sunIntensityScale(e){this._sunIntensityScale=e,this._lightNeedsUpdate=!0}get sunLightIntensity(){return this._sunLightIntensity}set sunLightIntensity(e){this._sunLightIntensity=e,this._lightNeedsUpdate=!0}get skyLightIntensity(){return this._skyLightIntensity}set skyLightIntensity(e){this._skyLightIntensity=e,this._lightNeedsUpdate=!0}get skyLightAttenuationRatio(){return this._skyLightAttenuationRatio}set skyLightAttenuationRatio(e){this._skyLightAttenuationRatio=e,this._lightNeedsUpdate=!0}get sunDirection(){return this._sunDirection}get localSunDirection(){return this._localSunDirection}get affectWorld(){return this._affectWorld}get envLightIntensity(){return this._envLightIntensity}set envLightIntensity(e){this._envLightIntensity=e,this.engine&&(this.engine.renderer.envMapIntensity=e)}}class Pass$1{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const _camera$1=new three.OrthographicCamera(-1,1,1,-1,0,1);class FullscreenTriangleGeometry extends three.BufferGeometry{constructor(){super(),this.setAttribute("position",new three.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new three.Float32BufferAttribute([0,2,0,0,2,0],2))}}const _geometry=new FullscreenTriangleGeometry;class FullScreenQuad{constructor(e){this._mesh=new three.Mesh(_geometry,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,_camera$1)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}const CopyShader={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"},bufferVertexShader="#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}",mainVertShader$1="#define GLSLIFY 1\nvarying vec3 vWorldPosition;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    //vWorldPosition = normalize(vec3(modelMatrix * vec4(position, 1.0)) - cameraPosition);\n    vWorldPosition = normalize(vec3(position.x, position.y, position.z));\n    // vWorldPosition = normalize(position);\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    gl_Position.z = gl_Position.w;\n}\n",commonFragShader$1="#define GLSLIFY 1\nconst float PI = 3.14159265358;\n\n// Units are in megameters.\nconst float groundRadiusMM = 6.371 * 1.0;\nconst float atmosphereRadiusMM = 6.471 * 1.0;\nconst float maxSampleLength = 2.267;\n\nconst vec2 tLUTRes = vec2(256.0, 64.0)*1.;\nconst vec2 msLUTRes = vec2(32.0, 32.0)*1.;\nconst vec2 skyLUTRes = vec2(200.0, 200.0)*2.;\n\nconst vec3 groundAlbedo = vec3(0.1);\n\n// These are per megameter.\nconst vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);\nconst float rayleighAbsorptionBase = 0.0;\n\nconst float mieScatteringBase = 3.996;\nconst float mieAbsorptionBase = 4.4;\n\nconst vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);\n\n// Quality\nconst float sunTransmittanceSteps = 40.0;\nconst float mulScattSteps = 20.0;\nconst int sqrtSamples = 8;\n\nconst int numScatteringSteps = 16;\n\nuniform float altitude;\nuniform float viewHeight;\n/*\n * Animates the sun movement.\n */\nfloat getSunAltitude(float time)\n{\n    const float periodSec = 10.0;\n    return (PI)*time/periodSec - PI/24.;\n}\nvec3 getSunDir(float time)\n{\n    // float altitude = getSunAltitude(time);\n    // altitude = 2.8;\n    return normalize(vec3(cos(altitude), sin(altitude), 0.0));\n    // return normalize(vec3(0.0, sin(altitude), -cos(altitude)));\n\n}\n\n/* Animate camera */\nvec3 getViewPos(float time){\n\n    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0000 + viewHeight, 0.0);\n\n    // anything beyond about 7 falls apart because the skyview lut doesn't have enough resolution\n    float alt_range = 50.0;\n\n    // viewPos.y += (sin(time/10.0 - PI/2.)*.5+.5) * (atmosphereRadiusMM - groundRadiusMM) * alt_range;\n\n    return viewPos;\n}\n\nfloat getMiePhase(float cosTheta) {\n    const float g = 0.8;\n    const float scale = 3.0/(8.0*PI);\n\n    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);\n    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);\n\n    return scale*num/denom;\n}\n\nfloat getRayleighPhase(float cosTheta) {\n    const float k = 3.0/(16.0*PI);\n    return k*(1.0+cosTheta*cosTheta);\n}\n\nvoid getScatteringValues(vec3 pos,\n                         out vec3 rayleighScattering,\n                         out float mieScattering,\n                         out vec3 extinction) {\n    float altitudeKM = (length(pos)-groundRadiusMM)*1000.0;\n    // Note: Paper gets these switched up.\n    float rayleighDensity = exp(-altitudeKM/8.0);\n    float mieDensity = exp(-altitudeKM/1.2);\n\n    rayleighScattering = rayleighScatteringBase*rayleighDensity;\n    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;\n\n    mieScattering = mieScatteringBase*mieDensity;\n    float mieAbsorption = mieAbsorptionBase*mieDensity;\n\n    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);\n\n    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;\n}\n\nfloat safeacos(const float x) {\n    return acos(clamp(x, -1.0, 1.0));\n}\n\n// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.\nfloat rayIntersectSphere(vec3 ro, vec3 rd, float rad) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad*rad;\n    if (c > 0.0 && b > 0.0) return -1.0;\n    float discr = b*b - c;\n    if (discr < 0.0) return -1.0;\n    // Special case: inside sphere, use far discriminant\n    if (discr > b*b) return (-b + sqrt(discr));\n    return -b - sqrt(discr);\n}\n\n// From https://www.shadertoy.com/view/wlBXWK\nvec2 rayIntersectSphere2D(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n/*\n * Same parameterization here.\n */\nvec3 getValFromTLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {\n    float height = length(pos);\n    vec3 up = pos / height;\n\tfloat sunCosZenithAngle = dot(sunDir, up);\n    vec2 uv = vec2(tLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),\n                   tLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));\n    uv /= bufferRes;\n    // return pos;\n    return texture2D(tex, uv).rgb;\n}\nvec3 getValFromMultiScattLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {\n    float height = length(pos);\n    vec3 up = pos / height;\n\tfloat sunCosZenithAngle = dot(sunDir, up);\n    vec2 uv = vec2(msLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),\n                   msLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));\n    uv /= bufferRes;\n    return texture2D(tex, uv).rgb;\n}\n\n/* \n * Do raymarching : builds skyview lut inside atmoshpere, raymarches directly outside atmosphere\n*/\n\nvec3 raymarchScattering(sampler2D TLUT, vec2 TLUT_size, sampler2D MSLUT, vec2 MSLUT_size,\n                              vec3 viewPos,\n                              vec3 rayDir,\n                              vec3 sunDir,\n                              float numSteps,\n                              float maxDistance) {\n                              \n                              \n    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);\n    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);\n\n    float mindist, maxdist;\n\n    if (atmos_intercept.x < atmos_intercept.y){\n        // there is an atmosphere intercept!\n        // start at the closest atmosphere intercept\n        // trace the distance between the closest and farthest intercept\n        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;\n\t\tmaxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;\n    } else {\n        // no atmosphere intercept means no atmosphere!\n        return vec3(0.0);\n    }\n\n    // if in the atmosphere start at the camera\n    if (length(viewPos) < atmosphereRadiusMM) mindist=0.0;\n\n    // if there's a terra intercept that's closer than the atmosphere one,\n    // use that instead!\n    if (terra_intercept > 0.0){ // confirm valid intercepts\t\t\t\n        maxdist = terra_intercept;\n    }\n\n    // start marching at the min dist\n    vec3 pos = viewPos + mindist * rayDir;\n\n    float cosTheta = dot(rayDir, sunDir);\n\n\tfloat miePhaseValue = getMiePhase(cosTheta);\n\tfloat rayleighPhaseValue = getRayleighPhase(-cosTheta);\n\n    float diff = maxdist - mindist;\n\n    diff = min((maxDistance - mindist), diff);\n\n    vec3 lum = vec3(0.0);\n    vec3 transmittance = vec3(1.0);\n    float t = 0.0;\n\n    // 最小采样数设置为numSteps / 2.0,因为采样数越小,增加采样点效果变化越大\n    float steps = max(numSteps / 2.0, floor(numSteps * (diff / maxSampleLength)));\n    for (int fi = 0; fi < 100; fi++) {\n        float i = float(fi);\n        if (i >= steps) break;\n\n        float newT = ((i + 0.3)/steps)*diff;\n        float dt = newT - t;\n        t = newT;\n\n        vec3 newPos = pos + t*rayDir;\n\n        vec3 rayleighScattering, extinction;\n        float mieScattering;\n        \n        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n        vec3 sampleTransmittance = exp(-dt*extinction);\n\n        vec3 sunTransmittance = getValFromTLUT(TLUT, TLUT_size, newPos, sunDir);\n        vec3 psiMS = getValFromMultiScattLUT(MSLUT, MSLUT_size, newPos, sunDir);\n\n        vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);\n        vec3 mieInScattering = mieScattering*(miePhaseValue*sunTransmittance + psiMS);\n        vec3 inScattering = (rayleighInScattering + mieInScattering);\n\n        // Integrated scattering within path segment.\n        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;\n\n        lum += scatteringIntegral*transmittance;\n\n        transmittance *= sampleTransmittance;\n    }\n    return lum;\n}\n\nvec3 getValFromSkyLUT(sampler2D viewTexture, vec3 viewPos, vec3 rayDir, vec3 sunDir) {\n\n    float height = length(viewPos);\n    vec3 up = viewPos / height;\n\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);\n    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2\n    float azimuthAngle; // Between 0 and 2*PI\n\n    vec3 right = cross(sunDir, up);\n    vec3 forward = cross(up, right);\n\n    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));\n    float sinTheta = dot(projectedDir, right);\n    float cosTheta = dot(projectedDir, forward);\n    azimuthAngle = atan(sinTheta, cosTheta) + PI;\n\n    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.\n    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);\n    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);\n    // uv *= skyLUTRes;\n    // uv /= viewResolution.xy;\n\n    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);;\n    return texture2D(viewTexture, uv).rgb;\n}\n\nvec3 jodieReinhardTonemap(vec3 c) {\n    // From: https://www.shadertoy.com/view/tdSXzD\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec4 toLinear(vec4 sRGB) {\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    // return mix(higher, lower, cutoff);\n    // 使用条件操作符替代 mix 函数\n    return vec4(\n        cutoff.x ? lower.x : higher.x,\n        cutoff.y ? lower.y : higher.y,\n        cutoff.z ? lower.z : higher.z,\n        cutoff.w ? lower.w : higher.w\n    );\n}\n\nvec4 colorSpaceTransform(vec4 color) {\n    #ifdef USE_OPAQUE_POST_STAGE\n        return toLinear(color);\n    #else\n        return color;\n    #endif\n}",mainFragShader$1="#define GLSLIFY 1\n/*\n * Modified version of Andrew Helmer's https://www.shadertoy.com/view/slSXRW \n * implementation of Sebastian Hillare's Unreal engine sky-atmosphere\n * ... still doesn't implement aerial perspective lut, just makes space views possible\n * TODO: replace sunflare with something new that works\n        allow density profiles, and thicker atmospheres (fails beyond 7.1 right now)\n */\n\n/*\n * Final output basically looks up the value from the skyLUT, and then adds a sun on top,\n * does some tonemapping.\n */\n#include <common>\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nuniform sampler2D transmittanceTexture;\nuniform vec2 transmittanceResolution;\nuniform sampler2D viewTexture;\nuniform vec2 viewResolution;\nuniform sampler2D scatteringTexture;\nuniform vec2 scatteringResolution;\nuniform vec2 iResolution;\nuniform vec3 cameraDirection;\nuniform vec3 upDirection;\nuniform float uTime;\nuniform bool uStarVisible;\nuniform sampler2D uMoonMap;\n\nconst int star_iterations = 10;\nconst vec3 col_star = vec3( .8, 0.8, 0.7 );\n\nconst vec3 grayColor = vec3(0.5, 0.5, 0.5);\n\nvec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {\n    const float sunSolidAngle = 0.01*PI/180.0;\n    const float minSunCosTheta = cos(sunSolidAngle);\n\n    float cosTheta = dot(rayDir, sunDir);\n    if (cosTheta >= minSunCosTheta) return vec3(1.0);\n\n    float offset = minSunCosTheta - cosTheta;\n    float gaussianBloom = exp(-offset*50000.0)*0.5;\n    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;\n    return vec3(gaussianBloom+invBloom);\n}\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nvec2 rotate( in vec2 uv, float a) {\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nfloat noise( in vec3 p ) {\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t ) {\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nfloat fbmByTexture( vec2 p ) {\n    return 0.5000 * texture2D( uMoonMap, p * 1.00 ).x + \n        0.2500 * texture2D( uMoonMap, p * 2.02 ).x + \n        0.1250 * texture2D( uMoonMap, p * 4.03 ).x + \n        0.0625 * texture2D( uMoonMap, p * 8.04 ).x;\n}\n\n// moon\nvec3 moonWithBloom(vec3 rayDir, vec3 moonDir) {\n    const float sunSolidAngle = .6 * PI / 180.0;\n    const float minSunCosTheta = cos(sunSolidAngle);\n\n    float cosTheta = dot(rayDir, moonDir);\n    vec3 differ = rayDir - moonDir;\n    if (cosTheta >= minSunCosTheta) {\n        vec3 moon = vec3(0.98,0.97,0.95);\n        // 月球耀斑\n        moon *= (0.30 + 0.4 * fbmByTexture(vec2(1.0) + vec2(0.2 + differ.xz + differ.yx)));\n\n        return moon;\n    }\n\n    float offset = minSunCosTheta - cosTheta;\n    float gaussianBloom = exp(-offset * 50000.0) * 0.5;\n    float invBloom = 1.0 / (0.05 + offset * 300.0) * 0.01;\n    return vec3(gaussianBloom+invBloom);\n}\n\n// 星空背景\nvec3 doBackgroundStars( in vec3 dir ) {\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: \n            ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n                                        dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i ) {\n        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 10. * uv.x * uv.y + uTime;\n        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.534, 0.535, u.x * u.y );\n    }\n    \n    return f * col_star;\n}\n\nvec3 render( in vec2 uv, mat3 m ) {\n    //create view ray\n    vec3 rd  = m * normalize( vec3( uv, 1.0 ) );\n    \n    // background stars\n    vec3 c = doBackgroundStars( rd );\n    return c;\n}\n\n// vec4 toLinear(vec4 sRGB) {\n//     bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n//     vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n//     vec4 lower = sRGB/vec4(12.92);\n\n//     // return mix(higher, lower, cutoff);\n//     // 使用条件操作符替代 mix 函数\n//     return vec4(\n//         cutoff.x ? lower.x : higher.x,\n//         cutoff.y ? lower.y : higher.y,\n//         cutoff.z ? lower.z : higher.z,\n//         cutoff.w ? lower.w : higher.w\n//     );\n// }\n\nvoid main() {\n    vec3 sunDir = getSunDir(0.);\n    vec3 viewPos = getViewPos(0.);\n\n    vec3 camDir = normalize(cameraDirection);\n    float camFOVWidth = PI/3.0;\n    // vec2 iResolution = vec2(1102, 1246);\n    float camWidthScale = 2.0*tan(camFOVWidth/2.0);\n    float camHeightScale = camWidthScale*iResolution.y/iResolution.x;\n\n    vec3 camRight = normalize(cross(camDir, upDirection));\n    vec3 camUp = normalize(cross(camRight, camDir));\n\n    // camRight = viewMatrix[0].xzy;\n    // camUp = viewMatrix[1].xzy;\n    // camDir = viewMatrix[2].xzy;\n    // vec2 xy = 2.0 * vWorldPosition.xy; // 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    vec2 xy = vWorldPosition.xy; // 2.0 * (gl_FragCoord.xy / iResolution.xy / 2.0) - 1.0;\n    // vec3 rayDir = normalize(camDir + camRight*xy.x*camWidthScale + camUp*xy.y*camHeightScale);\n    vec3 rayDir = normalize(vWorldPosition.xzy);\n    vec3 lum;\n\n    if (length(viewPos) < atmosphereRadiusMM * 1.0){\n        lum = getValFromSkyLUT(viewTexture, viewPos, rayDir, sunDir);\n    } else {\n    \n        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere\n        lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,\n                                scatteringTexture, scatteringResolution.xy,\n                                viewPos, rayDir, sunDir, float(numScatteringSteps), 10e5);\n        \n        // This little bit of red helps to debug when the rendering switches to pure raymarching\n        // lum += vec3(1e-3,0.0,0.0);\n    }\n\n    // Tonemapping and gamma. Super ad-hoc, probably a better way to do this.\n    lum *= 100.0;\n    lum = jodieReinhardTonemap(lum);\n    lum = pow(lum, vec3(1.0/2.2));\n\n    // lum += sunWithBloom(rayDir, sunDir);\n    // Bloom should be added at the end, but this is subtle and works well.\n    vec3 sunLum = sunWithBloom(rayDir, sunDir);\n    // Use smoothstep to limit the effect, so it drops off to actual zero.\n    sunLum = smoothstep(0.002, 1.0, sunLum);\n    if (length(sunLum) > 0.0) {\n        if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {\n            sunLum *= 0.0;\n        } else {\n            // If the sun value is applied to this pixel, we need to calculate the transmittance to obscure it.\n            sunLum *= getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, viewPos, sunDir);\n        }\n    }\n    lum += sunLum;\n\n    if (sunDir.y < 0.0) {\n        vec2 uv = vUv - vec2(0.5);\n        \n        vec3 ww = normalize(vec3(1.04, 0.0, 2.628));\n        vec3 uu = normalize( cross( ww, vec3( 0.0, 1.0, 0.0 ) ) );\n        vec3 vv = normalize( cross( uu, ww ) );\n        mat3 m = mat3( uu, vv, ww );\n\n        // 星空\n        if (rayDir.y > 0.0 && uStarVisible) {\n            // 背景初始化颜色，渐变蓝黑色\n            lum += vec3( 0.035, 0.055, 0.085 );\n            lum += vec3( 0.02, 0.05, 0.15 ) * (1. - rayDir.y);\n\n            vec3 c = render( fract(uv * 30.0), m );\n\n            // c = pow( c, vec3( 0.4545 ) );\n\n            // 星空闪烁\n            float time = uTime / 20000.0;\n            float twinkle = sin((uv.x-time+cos(uv.y*20.+time))*20.);\n            twinkle *= cos((uv.y*.234-time*3.24+sin(uv.x*12.3+time*.243))*7.34);\n            twinkle = (twinkle + 1.)/2.;\n            lum += c * twinkle * (rayDir.y * 10.0) * (1.0 - pow(max(0.0, abs(-sunDir.y - 1.0) * 2.0 - 1.0), 2.0));\n        }\n\n        // 月亮\n        vec3 moonLum = moonWithBloom(rayDir, -sunDir) * 2.0;\n        if (length(moonLum) > 0.0) {\n            float alpha = clamp(smoothstep(0.0, 0.2, rayDir.y), 0.01, 1.0);\n            moonLum *= alpha;\n        }\n        lum += moonLum;\n\n    }\n\n    gl_FragColor = vec4(lum, 1.0);\n    gl_FragColor = toLinear(gl_FragColor);\n\n    // gl_FragColor.rgb = vWorldPosition;\n    // float viewDistance = sqrt(length(vec3(rayDir.x * 10., 0.1, rayDir.z * 10.)));\n    // vec2 cloudUV = rayDir.xz * viewDistance; //rayDir.xy * length(rayDir);\n    // // cloudUV *= mix(1., 10., clamp(sqrt(rayDir.x * rayDir.x + rayDir.y * rayDir.y), 0.0, 1.0));\n    // float cloudDensity = texture2D(tWeather, cloudUV * 10.0).x;\n    // gl_FragColor.xy = (rayDir.xy + 1.0) * 0.5;\n    // gl_FragColor.z += cloudDensity;\n    // Peek at the Transmittance LUT\n    // if (gl_FragCoord.x < skyLUTRes.x && gl_FragCoord.y < skyLUTRes.y) {\n        // gl_FragColor = vec4(8.*texture(viewTexture, gl_FragCoord.xy/skyLUTRes * 0.2).rgb,1.0);\n    // }\n    // fragColor = vec4(100.*texture(transmittanceTexture, fragCoord.xy/iResolution.xy).rgb,1.0);\n\n    // Peek at the Sky View LUT\n    // gl_FragColor = vec4(8.*texture(viewTexture, gl_FragCoord.xy/iResolution.xy / 2.).rgb,1.0);\n\n    // Peek at the Multiscattering LUT\n    // fragColor = vec4(100.*texture(scatteringTexture, fragCoord.xy/iResolution.xy).rgb,1.0);\n    // if (gl_FragCoord.x < msLUTRes.x && gl_FragCoord.y < msLUTRes.y) {\n    //     gl_FragColor = vec4(100.*texture(scatteringTexture, gl_FragCoord.xy/iResolution / 2.).rgb,1.0);\n    // }\n    // gl_FragColor = vec4(100.*texture(transmittanceTexture, gl_FragCoord.xy/transmittanceResolution * 0.1).rgb,1.0);\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}\n",transmittanceFragShader="#define GLSLIFY 1\n// Buffer A generates the Transmittance LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and\n// the value is the transmittance from that point to sun, through the atmosphere.\nvarying vec2 vUv;\nvec3 getSunTransmittance(vec3 pos, vec3 sunDir) {\n    if (rayIntersectSphere(pos, sunDir, groundRadiusMM) > 0.0) {\n        return vec3(0.0);\n    }\n\n    float atmoDist = rayIntersectSphere(pos, sunDir, atmosphereRadiusMM);\n    float t = 0.0;\n\n    vec3 transmittance = vec3(1.0);\n    for (float i = 0.0; i < sunTransmittanceSteps; i += 1.0) {\n        float newT = ((i + 0.3)/sunTransmittanceSteps)*atmoDist;\n        float dt = newT - t;\n        t = newT;\n\n        vec3 newPos = pos + t*sunDir;\n\n        vec3 rayleighScattering, extinction;\n        float mieScattering;\n        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n        transmittance *= exp(-dt*extinction);\n    }\n    return transmittance;\n}\n\nvoid main() {\n    // if (gl_FragCoord.x >= (tLUTRes.x+1.5) || gl_FragCoord.y >= (tLUTRes.y+1.5)) {\n    //     return;\n    // }\n    float u = vUv.x; // clamp(gl_FragCoord.x, 0.0, tLUTRes.x-1.0)/tLUTRes.x;\n    float v = vUv.y; // clamp(gl_FragCoord.y, 0.0, tLUTRes.y-1.0)/tLUTRes.y;\n\n    float sunCosTheta = 2.0*u - 1.0;\n    float sunTheta = safeacos(sunCosTheta);\n    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);\n\n    vec3 pos = vec3(0.0, height, 0.0);\n    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));\n\n    gl_FragColor = vec4(getSunTransmittance(pos, sunDir), 1.0);\n}\n",scatteringFragShader="#define GLSLIFY 1\n// Buffer B is the multiple-scattering LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and\n// the value is the multiple scattering approximation (Psi_ms from the paper, Eq. 10).\nvarying vec2 vUv;\nuniform sampler2D transmittanceTexture;\nuniform vec2 transmittanceResolution;\nvec3 getSphericalDir(float theta, float phi) {\n     float cosPhi = cos(phi);\n     float sinPhi = sin(phi);\n     float cosTheta = cos(theta);\n     float sinTheta = sin(theta);\n     return vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);\n}\n\n// Calculates Equation (5) and (7) from the paper.\nvoid getMulScattValues(vec3 pos, vec3 sunDir, out vec3 lumTotal, out vec3 fms) {\n    lumTotal = vec3(0.0);\n    fms = vec3(0.0);\n\n    float invSamples = 1.0/float(sqrtSamples*sqrtSamples);\n    for (int i = 0; i < sqrtSamples; i++) {\n        for (int j = 0; j < sqrtSamples; j++) {\n            // This integral is symmetric about theta = 0 (or theta = PI), so we\n            // only need to integrate from zero to PI, not zero to 2*PI.\n            float theta = PI * (float(i) + 0.5) / float(sqrtSamples);\n            float phi = safeacos(1.0 - 2.0*(float(j) + 0.5) / float(sqrtSamples));\n            vec3 rayDir = getSphericalDir(theta, phi);\n\n            float atmoDist = rayIntersectSphere(pos, rayDir, atmosphereRadiusMM);\n            float groundDist = rayIntersectSphere(pos, rayDir, groundRadiusMM);\n            float tMax = atmoDist;\n            if (groundDist > 0.0) {\n                tMax = groundDist;\n            }\n\n            float cosTheta = dot(rayDir, sunDir);\n\n            float miePhaseValue = getMiePhase(cosTheta);\n            float rayleighPhaseValue = getRayleighPhase(-cosTheta);\n\n            vec3 lum = vec3(0.0), lumFactor = vec3(0.0), transmittance = vec3(1.0);\n            float t = 0.0;\n            for (float stepI = 0.0; stepI < mulScattSteps; stepI += 1.0) {\n                float newT = ((stepI + 0.3)/mulScattSteps)*tMax;\n                float dt = newT - t;\n                t = newT;\n\n                vec3 newPos = pos + t*rayDir;\n\n                vec3 rayleighScattering, extinction;\n                float mieScattering;\n                getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n                vec3 sampleTransmittance = exp(-dt*extinction);\n\n                // Integrate within each segment.\n                vec3 scatteringNoPhase = rayleighScattering + mieScattering;\n                vec3 scatteringF = (scatteringNoPhase - scatteringNoPhase * sampleTransmittance) / extinction;\n                lumFactor += transmittance*scatteringF;\n\n                // This is slightly different from the paper, but I think the paper has a mistake?\n                // In equation (6), I think S(x,w_s) should be S(x-tv,w_s).\n                vec3 sunTransmittance = getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, newPos, sunDir);\n\n                vec3 rayleighInScattering = rayleighScattering*rayleighPhaseValue;\n                float mieInScattering = mieScattering*miePhaseValue;\n                vec3 inScattering = (rayleighInScattering + mieInScattering)*sunTransmittance;\n\n                // Integrated scattering within path segment.\n                vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;\n\n                lum += scatteringIntegral*transmittance;\n                transmittance *= sampleTransmittance;\n            }\n\n            if (groundDist > 0.0) {\n                vec3 hitPos = pos + groundDist*rayDir;\n                if (dot(pos, sunDir) > 0.0) {\n                    hitPos = normalize(hitPos)*groundRadiusMM;\n                    lum += transmittance*groundAlbedo*getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, hitPos, sunDir);\n                }\n            }\n\n            fms += lumFactor*invSamples;\n            lumTotal += lum*invSamples;\n        }\n    }\n}\n\nvoid main() {\n    // if (fragCoord.x >= (msLUTRes.x+1.5) || fragCoord.y >= (msLUTRes.y+1.5)) {\n    //     return;\n    // }\n    float u = vUv.x; // clamp(fragCoord.x, 0.0, msLUTRes.x-1.0)/msLUTRes.x;\n    float v = vUv.y; // clamp(fragCoord.y, 0.0, msLUTRes.y-1.0)/msLUTRes.y;\n\n    float sunCosTheta = 2.0*u - 1.0;\n    float sunTheta = safeacos(sunCosTheta);\n    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);\n\n    vec3 pos = vec3(0.0, height, 0.0);\n    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));\n\n    vec3 lum, f_ms;\n    getMulScattValues(pos, sunDir, lum, f_ms);\n\n    // Equation 10 from the paper.\n    vec3 psi = lum  / (1.0 - f_ms);\n    gl_FragColor = vec4(1. * psi, 1.0);\n    // gl_FragColor = vec4(vUv/ 1., 0.0, 1.0);\n}\n",viewFragShader="#define GLSLIFY 1\n// Buffer C calculates the actual sky-view! It's a lat-long map (or maybe altitude-azimuth is the better term),\n// but the latitude/altitude is non-linear to get more resolution near the horizon.\nvarying vec2 vUv;\nuniform sampler2D transmittanceTexture;\nuniform vec2 transmittanceResolution;\nuniform sampler2D scatteringTexture;\nuniform vec2 scatteringResolution;\nuniform float mixGrayFactor;\n\nvoid main() {\n    // if (fragCoord.x >= (skyLUTRes.x+1.5) || fragCoord.y >= (skyLUTRes.y+1.5)) {\n    //     return;\n    // }\n    float u = vUv.x; // clamp(fragCoord.x, 0.0, skyLUTRes.x-1.0)/skyLUTRes.x;\n    float v = vUv.y; // clamp(fragCoord.y, 0.0, skyLUTRes.y-1.0)/skyLUTRes.y;\n\n    float azimuthAngle = (u - 0.5)*2.0*PI;\n\n    // Non-linear mapping of altitude. See Section 5.3 of the paper.\n\n    float adjV;\n    if (v < 0.5) {\n\t\tfloat coord = 1.0 - 2.0*v;\n\t\tadjV = -coord*coord;\n\t} else {\n\t\tfloat coord = v*2.0 - 1.0;\n\t\tadjV = coord*coord;\n\t}\n\n    vec3 viewPos = getViewPos(0.);\n\n    float height = length(viewPos); vec3 up = viewPos / height;\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5*PI;\n    float altitudeAngle = adjV*0.5*PI - horizonAngle;\n\n    float cosAltitude = cos(altitudeAngle);\n    vec3 rayDir = vec3(cosAltitude*sin(azimuthAngle), sin(altitudeAngle), -cosAltitude*cos(azimuthAngle));\n\n    float sunAltitude = (0.5*PI) - acos(dot(getSunDir(0.), up));\n    vec3 sunDir = vec3(0.0, sin(sunAltitude), -cos(sunAltitude));\n\n    vec3 lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,\n                                  scatteringTexture, scatteringResolution.xy,\n                                  viewPos, rayDir, sunDir, float(numScatteringSteps), 10e5);\n    gl_FragColor = vec4(lum, 1.0);\n\n    if (mixGrayFactor > 0.0) {\n        lum = gl_FragColor.xyz;\n        vec3 gray = vec3((lum.x + lum.y + lum.z) / 3.0);\n        lum = mix(lum, gray, mixGrayFactor);\n        gl_FragColor = vec4(lum, 1.0);\n    }\n}\n",postprocessingFragShader="#define GLSLIFY 1\n#include <mvt_depth_packing>\n#include <packing>\n\nvarying vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\n#if defined(MVT_USE_NORMAL_TEXTURE)\n    uniform sampler2D tNormal;\n#endif\nuniform sampler2D tAtmosphere;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 projectionInverseMatrix;\nuniform mat4 viewInverseMatrix;\nuniform mat4 mvt_viewMatrix;\nuniform sampler2D transmittanceTexture;\nuniform vec2 transmittanceResolution;\nuniform sampler2D viewTexture;\nuniform vec2 viewResolution;\nuniform sampler2D scatteringTexture;\nuniform vec2 scatteringResolution;\nuniform vec2 resolution;\nuniform vec3 cameraDirection;\nuniform vec3 sunDirection;\nuniform bool isGlobe;\n// uniform vec3 upDirection;\nuniform vec2 fogDepthRange;\nuniform mat3 rotationMatrix;\n\nvec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {\n    const float sunSolidAngle = 0.01*PI/180.0;\n    const float minSunCosTheta = cos(sunSolidAngle);\n\n    float cosTheta = dot(rayDir, sunDir);\n    if (cosTheta >= minSunCosTheta) return vec3(1.0);\n\n    float offset = minSunCosTheta - cosTheta;\n    float gaussianBloom = exp(-offset*50000.0)*0.5;\n    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;\n    return vec3(gaussianBloom+invBloom);\n}\n\nvoid main() {\n    vec4 diffuse = texelFetch(tDiffuse, ivec2(gl_FragCoord.xy), 0);\n    float depthValue = texelFetch(tDepth, ivec2(gl_FragCoord), 0).x;\n    // gl_FragColor = diffuse;\n    // return;\n    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);\n    bool isTranslucent = diffuse.a < 1.0;\n    if (diffuse.a < 1.0) {\n        // // 透明度小于0.99，使用深度值\n        // depthValue = 1.0;\n        // depth = 1.0;\n    }\n    vec3 worldPosition = mvtGetWorldPositionByDepth(depth, vUv, projectionInverseMatrix, viewInverseMatrix); \n    vec3 viewPosition = mvtGetViewPositionByDepth(depth, vUv, projectionInverseMatrix);\n    float viewDistance = length(viewPosition) / 100000.0;\n    vec3 viewFrom = vec3(cameraPosition);\n\n    vec3 viewTo = vec3(worldPosition.xy, 0.002);\n\n    vec3 viewDir = normalize(viewTo - viewFrom);\n\n    vec3 sunDir = sunDirection;\n    vec3 viewPos = getViewPos(0.);\n\n    float maxDistance = length(viewPosition) / 1000000.0;\n\n    float camFOVWidth = 35.0 / 180.0 * PI;\n\n    float camHeightScale = tan(camFOVWidth / 2.0);\n    float camWidthScale = camHeightScale * resolution.x / resolution.y;\n\n    vec3 camRight   = vec3( viewInverseMatrix[0][0],  viewInverseMatrix[0][1],  viewInverseMatrix[0][2]);\n    vec3 camUp      = vec3( viewInverseMatrix[1][0],  viewInverseMatrix[1][1],  viewInverseMatrix[1][2]);\n\tvec3 camDir = vec3(-viewInverseMatrix[2][0], -viewInverseMatrix[2][1], -viewInverseMatrix[2][2]);\n\n    vec2 nxy = vUv.xy * 2.0 - 1.0;\n    vec3 rayDir = normalize(camDir + camRight * nxy.x * camWidthScale  + camUp * nxy.y * camHeightScale).xzy;\n\n    vec3 lum;\n    bool isInSpace = length(viewPos) > atmosphereRadiusMM * 1.0;\n    float atmoFactor = 0.0;\n    if (length(viewPos) < atmosphereRadiusMM * 1.0){\n        // 禁止半透明像素参与计算raymarching\n        if (depthValue < 0.99 && !isTranslucent) {\n            lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,\n                        scatteringTexture, scatteringResolution.xy,\n                        viewPos, rayDir, sunDir, float(numScatteringSteps), maxDistance);\n        }\n        else {\n            lum = getValFromSkyLUT(viewTexture, viewPos, rayDir, sunDir);\n        }\n        \n    } else {\n        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere\n        lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,\n                                scatteringTexture, scatteringResolution.xy,\n                                viewPos, rayDir, sunDir, float(numScatteringSteps), 10e5);\n        atmoFactor = clamp(lum.x * 30.0, 0.0, 1.0);\n    }\n    atmoFactor = clamp(lum.x * 30.0, 0.0, 1.0);\n    lum *= 20.0;\n    lum = jodieReinhardTonemap(lum);\n    lum = pow(lum, vec3(1.0/2.2));\n\n    if (depthValue > 0.99) {\n        vec3 sunLum = vec3(0.0);\n        sunLum = sunWithBloom(rayDir, sunDir);\n        // Use smoothstep to limit the effect, so it drops off to actual zero.\n        sunLum = smoothstep(0.002, 1.0, sunLum);\n        if (length(sunLum) > 0.0) {\n            if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {\n                sunLum *= 0.0;\n            }\n        }\n        lum += sunLum;\n    }\n\n    vec4 atmo = colorSpaceTransform(vec4(lum, 1.0));\n    gl_FragColor = atmo;\n \n    // 从50km高度到100km高度，大气层逐渐变淡\n    float cameraHeight = cameraPosition.z;\n    if (isGlobe) {\n        cameraHeight = length(cameraPosition) - 6371000.0;\n    }\n    float ratio = 1.0 - clamp((cameraHeight - 50000.0) / 50000.0, 0.0, 1.0);\n    ratio = 1.0;\n\n    float viewRatio = 1.0;\n    if (!isGlobe){\n        viewRatio = 1.0 - dot(normalize(vec3(viewInverseMatrix[2])), vec3(0.0, 0.0, 1));\n        viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);\n    }\n\n    float depthThreshold = mix(0.996, 0.992, clamp(cameraHeight / 100000.0, 0.0, 1.0));\n    if (depthValue < depthThreshold && ratio > 0.0 && !isTranslucent) {\n\n        float fogDepth = depthValue;\n        float fogDensity = 1.;\n        float fogStart = mix(0.8, 0.95, ratio);\n        fogDepth = clamp((fogDepth - fogStart) / (1.0 - fogStart), 0.0, 1.0);\n        \n        float atmoFinalFactor = 0.0;\n        if (isGlobe) {\n            if (isInSpace) {\n                atmoFinalFactor = atmoFactor;\n            }\n            else {\n                float heightRatio = 1.0 - clamp(viewHeight * 10.0, 0.0, 1.0);\n                heightRatio = heightRatio * heightRatio;\n                float viewDepth = clamp((depthValue - fogDepthRange.x) / (fogDepthRange.y - fogDepthRange.x), 0.0, 1.0);\n                viewDepth = 1.0 - exp(- 2.0 * viewDepth * viewDepth);\n                atmoFinalFactor = mix(atmoFactor, viewDepth, heightRatio);\n            }\n        }\n        else {\n            atmoFinalFactor = fogDepth * ratio * viewRatio;\n        }\n        #if defined(MVT_DEBUG_INTENSITY)\n            gl_FragColor = vec4(atmoFinalFactor, 0.0, 0.0, 1.0);\n        #else\n            gl_FragColor = mix(diffuse, atmo, atmoFinalFactor);\n        #endif\n    } \n    else {\n        // 有颜色的区域必须都尝试去混合，需要考虑部分depthTest关闭的物体也需要显示\n        if (diffuse.a > 0.001) {\n            #if defined(MVT_DEBUG_INTENSITY)\n                gl_FragColor = vec4(diffuse.a, 0.0, 0.0, 1.0);\n            #else\n                gl_FragColor.rgb = mix(gl_FragColor.rgb, diffuse.rgb / diffuse.a, diffuse.a);\n            #endif\n            // gl_FragColor.a = diffuse.a;\n            // gl_FragColor = vec4(0.0, 1.0, 0.0, diffuse.a);\n            // gl_FragColor = vec4(lum, 1.0);\n        }\n        else {\n            // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n        \n    }\n}",gradientFragShader="#define GLSLIFY 1\n#include <mvt_depth_packing>\n#include <packing>\n\nuniform vec3 highColor;\nuniform vec3 color;\nvarying vec2 vUv;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nuniform vec2 resolution;\nuniform bool isGlobe;\nuniform vec2 fogDepthRange;\nuniform mat4 viewInverseMatrix;\nuniform mat4 projectionInverseMatrix;\nvoid main() {\n    // float depthValue = texture2D(tDepth, vUv).x;\n    // 按像素精确采样深度值\n    float depthValue = texelFetch(tDepth, ivec2(gl_FragCoord), 0).x;\n    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);\n    vec3 viewPosition = mvtGetViewPositionByDepth(depth, vUv, projectionInverseMatrix);\n\n    float maxDistance = length(viewPosition) / 1000000.0;\n    vec4 diffuse = texture2D(tDiffuse, vUv);\n    bool isTranslucent = diffuse.a < 1.0;\n\n    vec3 viewPos = getViewPos(0.);\n\n    float cameraHeight = cameraPosition.z;\n\n    float camFOVWidth = 35.0 / 180.0 * PI;\n    float camHeightScale = tan(camFOVWidth / 2.0);\n    float camWidthScale = camHeightScale * resolution.x / resolution.y;\n\n    vec3 camRight   = vec3( viewInverseMatrix[0][0],  viewInverseMatrix[0][1],  viewInverseMatrix[0][2]);\n    vec3 camUp      = vec3( viewInverseMatrix[1][0],  viewInverseMatrix[1][1],  viewInverseMatrix[1][2]);\n\tvec3 camDir = vec3(-viewInverseMatrix[2][0], -viewInverseMatrix[2][1], -viewInverseMatrix[2][2]);\n\n    vec2 nxy = vUv.xy * 2.0 - 1.0;\n    vec3 rayDir = normalize(camDir + camRight * nxy.x * camWidthScale  + camUp * nxy.y * camHeightScale).xzy;\n\n    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);\n    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);\n\n    float mindist, maxdist;\n    float dist = 0.0;\n    if (atmos_intercept.x < atmos_intercept.y){\n        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;\n        maxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;\n    }\n    float height = length(viewPos);\n    if (height < atmosphereRadiusMM) mindist=0.0;\n    if (terra_intercept > 0.0){ // confirm valid intercepts\t\t\t\n        maxdist = terra_intercept;\n    }\n\n    float depthThreshold = mix(0.996, 0.992, clamp(cameraHeight / 100000.0, 0.0, 1.0));\n    float diff = maxdist - mindist;\n\n    float cosTheta = groundRadiusMM / atmosphereRadiusMM;\n    float cosRadians = acos(cosTheta);\n    float maxAtmosphereDist = atmosphereRadiusMM * sin(cosRadians);\n\n    float horizonDist = sqrt(height * height - groundRadiusMM * groundRadiusMM);\n    // float factor = diff / horizonDist;\n\n    // ratio用于取过渡颜色\n    // remappedRatio用于设置透明度(线性过渡颜色变化太大,用非线性变化)\n    // https://www.desmos.com/calculator/raytthuk1q?lang=zh-CN\n    float ratio;\n    float factor;\n    bool isInSpace = false;\n    float remappedRatio;\n    if (height < atmosphereRadiusMM) {\n        if (depthValue < depthThreshold && !isTranslucent) {\n            diff = min(maxDistance, maxdist) - mindist;\n        }\n        // 通过穿过大气的路径和从当前视点出发能够经过的最长路径的比值作为ratio\n        ratio = clamp(1.0 - cos((PI / 2.0) * (diff / (maxAtmosphereDist + horizonDist))), 0.0, 1.0);\n        remappedRatio = 1.0 - exp(-50.0 * ratio);\n        if (terra_intercept > 0.0) factor = diff / horizonDist;\n    }\n    else {\n        // 通过穿过大气的路径计算高度，利用高度得到ratio\n        isInSpace = true;\n        float halfDiff = diff * 0.5;\n        float sinTheta = halfDiff / atmosphereRadiusMM;\n        float sinRadians = asin(sinTheta);\n        float atmospherHeight = atmosphereRadiusMM - groundRadiusMM;\n        ratio = 1.0 - cos((PI / 2.0) * (diff / (maxAtmosphereDist * 2.0)));\n\n        float ratioScale = min(max((atmospherHeight / viewHeight), 0.8), 1.0);\n        float ratioScaled = (1.0 - ratioScale) * ratio + ratioScale;\n\n        // 随着高度的上升透明度从非线性变为线性过渡\n        float unlinearRatio = (1.0 - exp(-(10.0) * ratio));\n        float h = min(max(((atmospherHeight * 2.0 - viewHeight) / atmospherHeight), 0.0) ,1.0);\n        remappedRatio = (unlinearRatio * h + ratio * (1.0 - h)) * ratioScaled;\n        if (terra_intercept > 0.0) factor = diff / maxAtmosphereDist;\n    }\n\n    float ratioValue = 1.0 - ratio;\n    vec3 outColor;\n    if (ratioValue <= 0.0) {\n        outColor = color;\n    }\n    else if (ratioValue < 0.3) {\n        float t = smoothstep(0.0, 1.0, (ratioValue / 0.3));\n        outColor = mix(color, highColor, t);\n    }\n    else {\n        outColor = highColor;\n    }\n\n    vec3 outputColor;\n    if (terra_intercept > 0.0) {\n        // 如果和地球相交，使用底部颜色\n        outputColor = color * factor;\n    }\n    else {\n        outputColor = outColor * remappedRatio;\n    }\n\n    float viewRatio = 1.0;\n    if (isGlobe) {\n        // viewRatio = 1.0 - clamp(dot(normalize(vec3(viewInverseMatrix[2])), upDirection), 0.0, 1.0);\n        // viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);\n        // viewRatio = 1.;\n    }\n    else {\n        viewRatio = 1.0 - dot(normalize(vec3(viewInverseMatrix[2])), vec3(0.0, 0.0, 1));\n        viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);\n    }\n\n    outputColor = colorSpaceTransform(vec4(outputColor, 1.0)).rgb;\n\n    float atmoFactor = diff / maxAtmosphereDist;\n    if (depthValue < depthThreshold && ratio >= 0.0 && !isTranslucent) {\n        vec4 atmo = colorSpaceTransform(vec4(color, 1.0));\n        float fogDepth = depthValue;\n\n        float fogDensity = 1.;\n        float fogStart = mix(0.8, 0.95, ratio);\n        fogDepth = clamp((fogDepth - fogStart) / (1.0 - fogStart), 0.0, 1.0);\n\n        float atmoFinalFactor = 0.0;\n        if (isGlobe) {\n            if (isInSpace) {\n                atmoFinalFactor = atmoFactor;\n            }\n            else {\n                float heightRatio = 1.0 - clamp(viewHeight * 10.0, 0.0, 1.0);\n                heightRatio = heightRatio * heightRatio;\n                // float maxDistance = 0.5 + heightRatio * 2.0;\n                float viewDepth = clamp((depthValue - fogDepthRange.x) / (fogDepthRange.y - fogDepthRange.x), 0.0, 1.0);\n                viewDepth = 1.0 - exp(- 2.0 * viewDepth * viewDepth);\n                atmoFinalFactor = mix(atmoFactor, viewDepth, heightRatio);\n            }\n        }\n        else {\n            atmoFinalFactor = fogDepth * ratio * viewRatio;\n        }\n\n        atmoFinalFactor *= atmoFinalFactor;\n\n        gl_FragColor = mix(diffuse, atmo, atmoFinalFactor);\n    }\n    else {\n        gl_FragColor = vec4(outputColor, 1.0);\n\n        float t = abs(dot(rayDir, -viewPos));\n        float distanceToGlobeCenter = sqrt(height * height - t * t);\n        \n        if (rayDir.y < 0.0 && distanceToGlobeCenter < groundRadiusMM) {\n            gl_FragColor = colorSpaceTransform(vec4(color, 1.0)); \n        }\n\n        if (diffuse.a > 0.001) {\n            gl_FragColor.rgb = mix(gl_FragColor.rgb, diffuse.rgb / diffuse.a, diffuse.a);\n        }\n    }\n\n    gl_FragColor.a = 1.0;\n\n}",SkyAtmosphereShader={uniforms:{altitude:{value:2.8},transmittanceTexture:{value:null},transmittanceResolution:{value:[256,256]},scatteringTexture:{value:null},scatteringResolution:{value:[256,256]},viewTexture:{value:null},viewResolution:{value:[256,256]},cameraDirection:{value:new three.Vector3(0,.27,-1)},viewHeight:{value:2e-4},upDirection:{value:new three.Vector3(0,1,0)},tWeather:{value:null},mixGrayFactor:{value:0},isEmissive:{value:!1},uTime:{value:null},uStarVisible:{value:!0},uMoonMap:{value:null},isGlobe:{value:!1}},vertexShader:mainVertShader$1,fragmentShader:commonFragShader$1+"\n"+mainFragShader$1},SkyAtmosphereTransmittanceShader={uniforms:{altitude:{value:2.8},viewHeight:{value:2e-4}},vertexShader:bufferVertexShader,fragmentShader:commonFragShader$1+"\n"+transmittanceFragShader},SkyAtmosphereScatteringShader={uniforms:{altitude:{value:2.8},transmittanceTexture:{value:null},transmittanceResolution:{value:[256,256]},viewHeight:{value:2e-4}},vertexShader:bufferVertexShader,fragmentShader:commonFragShader$1+"\n"+scatteringFragShader},SkyAtmosphereViewShader={uniforms:{altitude:{value:2.8},transmittanceTexture:{value:null},transmittanceResolution:{value:[256,256]},scatteringTexture:{value:null},scatteringResolution:{value:[256,256]},viewHeight:{value:2e-4},mixGrayFactor:{value:0}},vertexShader:bufferVertexShader,fragmentShader:commonFragShader$1+"\n"+viewFragShader},SkyAtmospherePostprocessingShader={uniforms:{tDiffuse:{value:null},tDepth:{value:null},tNormal:{value:null},tAtmosphere:{value:null},cameraNear:{value:.1},cameraFar:{value:1e3},projectionInverseMatrix:{value:new three.Matrix4},viewInverseMatrix:{value:new three.Matrix4},mvt_viewMatrix:{value:new three.Matrix4},cameraPosition:{value:new three.Vector3},altitude:{value:2.8},viewHeight:{value:2e-4},transmittanceTexture:{value:null},transmittanceResolution:{value:[256,256]},scatteringTexture:{value:null},scatteringResolution:{value:[256,256]},viewTexture:{value:null},viewResolution:{value:[256,256]},resolution:{value:[256,256]},cameraDirection:{value:new three.Vector3(0,.27,-1)},sunDirection:{value:new three.Vector3(0,1,0)},upDirection:{value:new three.Vector3(0,0,1)},isGlobe:{value:!1},fogDepthRange:{value:new three.Vector2(0,1)},rotationMatrix:{value:new three.Matrix3}},fragmentShader:commonFragShader$1+"\n"+postprocessingFragShader},SkyAtmosphereGradientShader={uniforms:{tDiffuse:{value:null},tDepth:{value:null},cameraNear:{value:.1},cameraFar:{value:1e3},viewInverseMatrix:{value:new three.Matrix4},cameraPosition:{value:new three.Vector3},viewHeight:{value:2e-4},resolution:{value:[256,256]},cameraDirection:{value:new three.Vector3(0,.27,-1)},sunDirection:{value:new three.Vector3(0,1,0)},isGlobe:{value:!1},fogDepthRange:{value:new three.Vector2(0,1)},rotationMatrix:{value:new three.Matrix3},projectionInverseMatrix:{value:new three.Matrix4},color:{value:new three.Color},highColor:{value:new three.Color}},fragmentShader:commonFragShader$1+"\n"+gradientFragShader},scaleToGeodeticSurfaceIntersection=new three.Vector3,scaleToGeodeticSurfaceGradient=new three.Vector3;function scaleToGeodeticSurface(e,t,i,n,r){const s=e.x,a=e.y,o=e.z,l=t.x,c=t.y,h=t.z,u=s*s*l*l,d=a*a*c*c,p=o*o*h*h,m=u+d+p,f=Math.sqrt(1/m),g=scaleToGeodeticSurfaceIntersection.copy(e).multiplyScalar(f);if(m<n)return r||(r=new three.Vector3),isFinite(f)?r.copy(g):void 0;const _=i.x,A=i.y,v=i.z,y=scaleToGeodeticSurfaceGradient;y.x=g.x*_*2,y.y=g.y*A*2,y.z=g.z*v*2;let x,b,S,C,T,E,M,w,I,P,R,B=(1-f)*e.length()/(.5*y.length()),D=0;do{B-=D,S=1/(1+B*_),C=1/(1+B*A),T=1/(1+B*v),E=S*S,M=C*C,w=T*T,I=E*S,P=M*C,R=w*T,x=u*E+d*M+p*w-1,b=u*I*_+d*P*A+p*R*v,D=x/(-2*b)}while(Math.abs(x)>1e-12);return r?(r.x=s*S,r.y=a*C,r.z=o*T,r):new three.Vector3(s*S,a*C,o*T)}function defined$1(e){return null!=e}function defaultValue(e,t){return null!=e?e:t}function DeveloperError(t){let i;this.name="DeveloperError",this.message=t;try{throw new Error}catch(e){i=e.stack}this.stack=i}defaultValue.EMPTY_OBJECT=Object.freeze({}),defined$1(Object.create)&&(DeveloperError.prototype=Object.create(Error.prototype),DeveloperError.prototype.constructor=DeveloperError),DeveloperError.prototype.toString=function(){let e=this.name+": "+this.message;return defined$1(this.stack)&&(e+="\n"+this.stack.toString()),e},DeveloperError.throwInstantiationError=function(){throw new DeveloperError("This function defines an interface and should not be called directly.")};const _CesiumMath=class{static equalsEpsilon(e,t,i,n){i=defaultValue(i,0),n=defaultValue(n,i);const r=Math.abs(e-t);return r<=n||r<=i*Math.max(Math.abs(e),Math.abs(t))}static toRadians(e){return three.MathUtils.degToRad(e)}static clamp(e,t,i){return e<t?t:e>i?i:e}static acosClamped(e){return Math.acos(_CesiumMath.clamp(e,-1,1))}static asinClamped(e){return Math.asin(_CesiumMath.clamp(e,-1,1))}static sign(e){return Math.sign(e)}static zeroToTwoPi(e){if(e>=0&&e<=_CesiumMath.TWO_PI)return e;const t=_CesiumMath.mod(e,_CesiumMath.TWO_PI);return Math.abs(t)<_CesiumMath.EPSILON14&&Math.abs(e)>_CesiumMath.EPSILON14?_CesiumMath.TWO_PI:t}static mod(e,t){return _CesiumMath.sign(e)===_CesiumMath.sign(t)&&Math.abs(e)<Math.abs(t)?e:(e%t+t)%t}static chordLength(e,t){return 2*t*Math.sin(.5*e)}static negativePiToPi(e){if(!defined$1(e))throw new DeveloperError("angle is required.");return e>=-_CesiumMath.PI&&e<=_CesiumMath.PI?e:_CesiumMath.zeroToTwoPi(e+_CesiumMath.PI)-_CesiumMath.PI}static normalize(e,t,i){return 0===(i=Math.max(i-t,0))?0:_CesiumMath.clamp((e-t)/i,0,1)}};let CesiumMath=_CesiumMath;__publicField(CesiumMath,"EPSILON1",.1),__publicField(CesiumMath,"EPSILON2",.01),__publicField(CesiumMath,"EPSILON3",.001),__publicField(CesiumMath,"EPSILON4",1e-4),__publicField(CesiumMath,"EPSILON5",1e-5),__publicField(CesiumMath,"EPSILON6",1e-6),__publicField(CesiumMath,"EPSILON7",1e-7),__publicField(CesiumMath,"EPSILON8",1e-8),__publicField(CesiumMath,"EPSILON9",1e-9),__publicField(CesiumMath,"EPSILON10",1e-10),__publicField(CesiumMath,"EPSILON11",1e-11),__publicField(CesiumMath,"EPSILON12",1e-12),__publicField(CesiumMath,"EPSILON13",1e-13),__publicField(CesiumMath,"EPSILON14",1e-14),__publicField(CesiumMath,"EPSILON15",1e-15),__publicField(CesiumMath,"EPSILON16",1e-16),__publicField(CesiumMath,"EPSILON17",1e-17),__publicField(CesiumMath,"EPSILON18",1e-18),__publicField(CesiumMath,"EPSILON19",1e-19),__publicField(CesiumMath,"EPSILON20",1e-20),__publicField(CesiumMath,"EPSILON21",1e-21),__publicField(CesiumMath,"PI",Math.PI),__publicField(CesiumMath,"ONE_OVER_PI",1/Math.PI),__publicField(CesiumMath,"PI_OVER_TWO",Math.PI/2),__publicField(CesiumMath,"PI_OVER_THREE",Math.PI/3),__publicField(CesiumMath,"PI_OVER_FOUR",Math.PI/4),__publicField(CesiumMath,"PI_OVER_SIX",Math.PI/6),__publicField(CesiumMath,"THREE_PI_OVER_TWO",3*Math.PI/2),__publicField(CesiumMath,"TWO_PI",2*Math.PI),__publicField(CesiumMath,"ONE_OVER_TWO_PI",1/(2*Math.PI)),__publicField(CesiumMath,"RADIANS_PER_DEGREE",Math.PI/180);const mostOrthogonalAxisScratch=new three.Vector3;let scratchN$1=new three.Vector3,scratchK$1=new three.Vector3;const wgs84RadiiSquared=new three.Vector3(40680631590769,40680631590769,40408299984661.445),angleBetweenScratch$1=new three.Vector3,angleBetweenScratch2$1=new three.Vector3,_Cartesian3=class{constructor(){__publicField(this,"COLUMN0ROW0",0),__publicField(this,"COLUMN0ROW1",1),__publicField(this,"COLUMN0ROW2",2),__publicField(this,"COLUMN1ROW0",3),__publicField(this,"COLUMN1ROW1",4),__publicField(this,"COLUMN1ROW2",5),__publicField(this,"COLUMN2ROW0",6),__publicField(this,"COLUMN2ROW1",7),__publicField(this,"COLUMN2ROW2",8)}static clone(e,t){if(e)return t.copy(e),t}static equals(e,t){return!(!defined$1(e)||!defined$1(t))&&e.equals(t)}static normalize(e,t){return e===t?(e.normalize(),e):(t.copy(e),t.normalize(),t)}static add(e,t,i){return i||(i=new three.Vector3),i.addVectors(e,t)}static dot(e,t){return e.dot(t)}static cross(e,t,i){return i||(i=new three.Vector3),i.crossVectors(e,t),i}static magnitudeSquared(e){return e.lengthSq()}static multiplyByScalar(e,t,i){return i||(i=new three.Vector3),i.copy(e).multiplyScalar(t),i}static divideByScalar(e,t,i){return i||(i=new three.Vector3),i.x=e.x/t,i.y=e.y/t,i.z=e.z/t,i}static subtract(e,t,i){return i||(i=new three.Vector3),i.subVectors(e,t),i}static distance(e,t){return e.distanceTo(t)}static negate(e,t){return t||(t=new three.Vector3),t.copy(e),t.negate(),t}static multiplyComponents(e,t,i){return i||(i=new three.Vector3),i.multiplyVectors(e,t),i}static magnitude(e){return e.length()}static equalsEpsilon(e,t,i,n){return e===t||defined$1(e)&&defined$1(t)&&CesiumMath.equalsEpsilon(e.x,t.x,i,n)&&CesiumMath.equalsEpsilon(e.y,t.y,i,n)&&CesiumMath.equalsEpsilon(e.z,t.z,i,n)}static fromCartesian4(e,t){return t||(t=new three.Vector3),t.set(e.x,e.y,e.z),t}static fromElements(e,t,i,n){return n||(n=new three.Vector3),n.set(e,t,i),n}static fromRadians(e,t,i,n,r){i=defaultValue(i,0);const s=defined$1(n)?n.radiiSquared:wgs84RadiiSquared,a=Math.cos(t);scratchN$1.x=a*Math.cos(e),scratchN$1.y=a*Math.sin(e),scratchN$1.z=Math.sin(t),scratchN$1=_Cartesian3.normalize(scratchN$1,scratchN$1),_Cartesian3.multiplyComponents(s,scratchN$1,scratchK$1);const o=Math.sqrt(_Cartesian3.dot(scratchN$1,scratchK$1));return scratchK$1=_Cartesian3.divideByScalar(scratchK$1,o,scratchK$1),scratchN$1=_Cartesian3.multiplyByScalar(scratchN$1,i,scratchN$1),defined$1(r)||(r=new three.Vector3),_Cartesian3.add(scratchK$1,scratchN$1,r)}static angleBetween(e,t){_Cartesian3.normalize(e,angleBetweenScratch$1),_Cartesian3.normalize(t,angleBetweenScratch2$1);const i=_Cartesian3.dot(angleBetweenScratch$1,angleBetweenScratch2$1),n=_Cartesian3.magnitude(_Cartesian3.cross(angleBetweenScratch$1,angleBetweenScratch2$1,angleBetweenScratch$1));return Math.atan2(n,i)}static fromDegrees(e,t,i,n,r){return e=CesiumMath.toRadians(e),t=CesiumMath.toRadians(t),_Cartesian3.fromRadians(e,t,i,n,r)}};let Cartesian3=_Cartesian3;__publicField(Cartesian3,"ZERO",Object.freeze(new three.Vector3)),__publicField(Cartesian3,"UNIT_X",Object.freeze(new three.Vector3(1,0,0))),__publicField(Cartesian3,"UNIT_Y",Object.freeze(new three.Vector3(0,1,0))),__publicField(Cartesian3,"UNIT_Z",Object.freeze(new three.Vector3(0,0,1))),__publicField(Cartesian3,"abs",(function(e,t){return t.x=Math.abs(e.x),t.y=Math.abs(e.y),t.z=Math.abs(e.z),t})),__publicField(Cartesian3,"mostOrthogonalAxis",(function(e,t){const i=_Cartesian3.normalize(e,mostOrthogonalAxisScratch);return _Cartesian3.abs(i,i),t=i.x<=i.y?i.x<=i.z?_Cartesian3.clone(_Cartesian3.UNIT_X,t):_Cartesian3.clone(_Cartesian3.UNIT_Z,t):i.y<=i.z?_Cartesian3.clone(_Cartesian3.UNIT_Y,t):_Cartesian3.clone(_Cartesian3.UNIT_Z,t)}));const _inputVector3$1=new three.Vector3,_outputVector3$1=new three.Vector3;class Ellipsoid{constructor(e,t,i){this._radii=new three.Vector3(e,t,i),this._radiiSquared=new three.Vector3(e*e,t*t,i*i),this._radiiToTheFourth=new three.Vector3(e*e*e*e,t*t*t*t,i*i*i*i),this._oneOverRadii=new three.Vector3(0===e?0:1/e,0===t?0:1/t,0===i?0:1/i),this._oneOverRadiiSquared=new three.Vector3(0===e?0:1/(e*e),0===t?0:1/(t*t),0===i?0:1/(i*i)),this._minimumRadius=Math.min(e,t,i),this._maximumRadius=Math.max(e,t,i),this._centerToleranceSquared=.1,0!==this._radiiSquared.z&&(this._squaredXOverSquaredZ=this._radiiSquared.x/this._radiiSquared.z)}static fromCartesian3(e){return new Ellipsoid(e.x,e.y,e.z)}geodeticSurfaceNormalCartographic(e,t){t||(t=new three.Vector3);const i=e.x,n=e.y,r=Math.cos(n),s=r*Math.cos(i),a=r*Math.sin(i),o=Math.sin(n);return t.set(s,a,o),t.normalize(),t}cartographicDegreeToCartesian(e,t){return _inputVector3$1.set(three.MathUtils.degToRad(e.x),three.MathUtils.degToRad(e.y),e.z),this.cartographicToCartesian(_inputVector3$1,t)}cartographicToCartesian(e,t){const i=this.geodeticSurfaceNormalCartographic(e);t||(t=new three.Vector3),t.multiplyVectors(this._radiiSquared,i);const n=Math.sqrt(i.clone().dot(t));return t.divideScalar(n),i.multiplyScalar(e.z),t.add(i),t}cartesianToCartographicDegree(e,t){const i=this.cartesianToCartographic(e,t);if(i)return(t=i).x=three.MathUtils.radToDeg(t.x),t.y=three.MathUtils.radToDeg(t.y),t}scaleToGeodeticSurface(e,t){return scaleToGeodeticSurface(e,this._oneOverRadii,this._oneOverRadiiSquared,this._centerToleranceSquared,t)}scaleToGeocentricSurface(e,t){t||(t=new three.Vector3);const i=e.x,n=e.y,r=e.z,s=this._oneOverRadiiSquared,a=1/Math.sqrt(i*i*s.x+n*n*s.y+r*r*s.z);return t.copy(e).multiplyScalar(a)}cartesianToCartographic(e,t){const i=this.scaleToGeodeticSurface(e,_outputVector3$1);if(!i)return;const n=this.geodeticSurfaceNormal(i),r=e.clone();r.sub(i);const s=Math.atan2(n.y,n.x),a=Math.asin(n.z),o=Math.sign(r.dot(e))*r.length();return t||(t=new three.Vector3),t.set(s,a,o),t}geodeticSurfaceNormal(e,t){return defined$1(t)||(t=new three.Vector3),t.multiplyVectors(e,this._oneOverRadiiSquared),t.normalize(),t}getSurfaceNormalIntersectionWithZAxis(e,t,i){t=defaultValue(t,0);const n=this._squaredXOverSquaredZ;if(defined$1(i)||(i=new three.Vector3),i.x=0,i.y=0,i.z=e.z*(1-n),!(Math.abs(i.z)>=this._radii.z-t))return i}transformPositionToScaledSpace(e,t){return Cartesian3.multiplyComponents(e,this._oneOverRadii,t)}static clone(e,t){if(!e)return;const i=e._radii;return t?(Cartesian3.clone(i,t._radii),Cartesian3.clone(e._radiiSquared,t._radiiSquared),Cartesian3.clone(e._radiiToTheFourth,t._radiiToTheFourth),Cartesian3.clone(e._oneOverRadii,t._oneOverRadii),Cartesian3.clone(e._oneOverRadiiSquared,t._oneOverRadiiSquared),t._minimumRadius=e._minimumRadius,t._maximumRadius=e._maximumRadius,t._centerToleranceSquared=e._centerToleranceSquared,t):new Ellipsoid(i.x,i.y,i.z)}get radii(){return this._radii}get radiiSquared(){return this._radiiSquared}get radiiToTheFourth(){return this.radiiToTheFourth}get oneOverRadii(){return this._oneOverRadii}get oneOverRadiiSquared(){return this._oneOverRadiiSquared}get maximumRadius(){return this._maximumRadius}get minimumRadius(){return this._minimumRadius}}function GeographicProjection(e){this._ellipsoid=defaultValue(e,Ellipsoid.WGS84),this._semimajorAxis=this._ellipsoid.maximumRadius,this._oneOverSemimajorAxis=1/this._semimajorAxis}Ellipsoid.WGS84=Object.freeze(new Ellipsoid(6378137,6378137,6356752.314245179)),Object.defineProperties(GeographicProjection.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}}),GeographicProjection.prototype.project=function(e,t){const i=this._semimajorAxis,n=e.x*i,r=e.y*i,s=e.z;return defined$1(t)?(t.x=n,t.y=r,t.z=s,t):new three.Vector3(n,r,s)},GeographicProjection.prototype.unproject=function(e,t){if(!defined$1(e))throw new DeveloperError("cartesian is required");const i=this._oneOverSemimajorAxis,n=e.x*i,r=e.y*i,s=e.z;return defined$1(t)?(t.x=n,t.y=r,t.z=s,t):new three.Vector3(n,r,s)};const angleBetweenScratch=new three.Vector2,angleBetweenScratch2=new three.Vector2,_Cartesian2=class{static clone(e,t){return t.copy(e),t}static fromElements(e,t,i){return i||(i=new three.Vector2),i.set(e,t),i}static lerp(e,t,i,n){return n||(n=new three.Vector2),n.lerpVectors(e,t,i),n}static equalsEpsilon(e,t,i,n){return e===t||defined$1(e)&&defined$1(t)&&CesiumMath.equalsEpsilon(e.x,t.x,i,n)&&CesiumMath.equalsEpsilon(e.y,t.y,i,n)}static equals(e,t){return e.equals(t)}static dot(e,t){return e.dot(t)}static normalize(e,t){return e===t?(e.normalize(),e):(t.copy(e),t.normalize(),t)}static add(e,t,i){return i||(i=new three.Vector2),i.addVectors(e,t)}static multiplyByScalar(e,t,i){return i||(i=new three.Vector2),i.copy(e).multiplyScalar(t),i}static subtract(e,t,i){return i||(i=new three.Vector2),i.subVectors(e,t),i}static distance(e,t){return e.distanceTo(t)}static angleBetween(e,t){return _Cartesian2.normalize(e,angleBetweenScratch),_Cartesian2.normalize(t,angleBetweenScratch2),CesiumMath.acosClamped(_Cartesian2.dot(angleBetweenScratch,angleBetweenScratch2))}};let Cartesian2=_Cartesian2;__publicField(Cartesian2,"ZERO",new three.Vector2),Cartesian2.fromCartesian3=Cartesian2.clone,Cartesian2.fromCartesian4=Cartesian2.clone;class StaticMatrix3{static fromQuaternion(e,t){const i=e.x*e.x,n=e.x*e.y,r=e.x*e.z,s=e.x*e.w,a=e.y*e.y,o=e.y*e.z,l=e.y*e.w,c=e.z*e.z,h=e.z*e.w,u=e.w*e.w,d=i-a-c+u,p=2*(n-h),m=2*(r+l),f=2*(n+h),g=-i+a-c+u,_=2*(o-s),A=2*(r-l),v=2*(o+s),y=-i-a+c+u;return t||(t=new three.Matrix3),t.set(d,p,m,f,g,_,A,v,y),t}static getColumn(e,t,i){const n=e.elements,r=3*t,s=n[r],a=n[r+1],o=n[r+2];return i.x=s,i.y=a,i.z=o,i}static multiplyByVector(e,t,i){return i||(i=new three.Vector3),i.copy(t),i.applyMatrix3(e),i}static multiplyByScale(e,t,i){i||(i=new three.Matrix3);const n=i.elements,r=e.elements;return n[0]=r[0]*t.x,n[1]=r[1]*t.x,n[2]=r[2]*t.x,n[3]=r[3]*t.y,n[4]=r[4]*t.y,n[5]=r[5]*t.y,n[6]=r[6]*t.z,n[7]=r[7]*t.z,n[8]=r[8]*t.z,i}static transpose(e,t){return t||(t=new three.Matrix3),t.copy(e).transpose(),t}static fromScale(e,t){t||(t=new three.Matrix3);const i=t.elements;return i[0]=e.x,i[1]=0,i[2]=0,i[3]=0,i[4]=e.y,i[5]=0,i[6]=0,i[7]=0,i[8]=e.z,t}static multiply(e,t,i){i||(i=new three.Matrix3);const n=e.elements,r=t.elements,s=i.elements,a=n[0],o=n[3],l=n[6],c=n[1],h=n[4],u=n[7],d=n[2],p=n[5],m=n[8],f=r[0],g=r[3],_=r[6],A=r[1],v=r[4],y=r[7],x=r[2],b=r[5],S=r[8];return s[0]=a*f+o*A+l*x,s[3]=a*g+o*v+l*b,s[6]=a*_+o*y+l*S,s[1]=c*f+h*A+u*x,s[4]=c*g+h*v+u*b,s[7]=c*_+h*y+u*S,s[2]=d*f+p*A+m*x,s[5]=d*g+p*v+m*b,s[8]=d*_+p*y+m*S,i}static clone(e,t){if(defined$1(e))return defined$1(t)?(t.clone(e),t):new three.Matrix3(e[0],e[3],e[6],e[1],e[4],e[7],e[2],e[5],e[8])}static setColumn(e,t,i,n){const r=(n=StaticMatrix3.clone(e,n)).elements,s=3*t;return r[s]=i.x,r[s+1]=i.y,r[s+2]=i.z,n}}StaticMatrix3.ZERO=three.Matrix3.ZERO=Object.freeze(new three.Matrix3(0,0,0,0,0,0,0,0,0)),StaticMatrix3.COLUMN0ROW0=0,StaticMatrix3.COLUMN0ROW1=1,StaticMatrix3.COLUMN0ROW2=2,StaticMatrix3.COLUMN1ROW0=3,StaticMatrix3.COLUMN1ROW1=4,StaticMatrix3.COLUMN1ROW2=5,StaticMatrix3.COLUMN2ROW0=6,StaticMatrix3.COLUMN2ROW1=7,StaticMatrix3.COLUMN2ROW2=8;class StaticMatrix4{static clone(e,t){return t.copy(e),t}static inverseTransformation(e,t){return t.copy(e).invert(),t}static multiplyByPoint(e,t,i){const n=e.elements,r=t.x,s=t.y,a=t.z,o=n[0]*r+n[4]*s+n[8]*a+n[12],l=n[1]*r+n[5]*s+n[9]*a+n[13],c=n[2]*r+n[6]*s+n[10]*a+n[14];return i.x=o,i.y=l,i.z=c,i}static multiplyByPointAsVector(e,t,i){const n=e.elements,r=t.x,s=t.y,a=t.z,o=n[0]*r+n[4]*s+n[8]*a,l=n[1]*r+n[5]*s+n[9]*a,c=n[2]*r+n[6]*s+n[10]*a;return i.x=o,i.y=l,i.z=c,i}static computeViewportTransformation(e,t,i,n){defined$1(n)||(n=new three.Matrix4),e=defaultValue(e,defaultValue.EMPTY_OBJECT);const r=defaultValue(e.x,0),s=defaultValue(e.y,0),a=defaultValue(e.width,0),o=defaultValue(e.height,0);t=defaultValue(t,0);const l=.5*a,c=.5*o,h=.5*((i=defaultValue(i,1))-t),u=l,d=c,p=h,m=r+l,f=s+c,g=t+h,_=n.elements;return _[0]=u,_[1]=0,_[2]=0,_[3]=0,_[4]=0,_[5]=d,_[6]=0,_[7]=0,_[8]=0,_[9]=0,_[10]=p,_[11]=0,_[12]=m,_[13]=f,_[14]=g,_[15]=1,n}static equals(e,t){return e.equals(t)}static multiplyByVector(e,t,i){return i||(i=new three.Vector4),i.copy(t),i.applyMatrix4(e),i}static getColumn(e,t,i){const n=e.elements,r=4*t,s=n[r],a=n[r+1],o=n[r+2],l=n[r+3];return i.x=s,i.y=a,i.z=o,i.w=l,i}static fromTranslationQuaternionRotationScale(e,t,i,n){n||(n=new three.Matrix4);const r=i.x,s=i.y,a=i.z,o=t.x*t.x,l=t.x*t.y,c=t.x*t.z,h=t.x*t.w,u=t.y*t.y,d=t.y*t.z,p=t.y*t.w,m=t.z*t.z,f=t.z*t.w,g=t.w*t.w,_=o-u-m+g,A=2*(l-f),v=2*(c+p),y=2*(l+f),x=-o+u-m+g,b=2*(d-h),S=2*(c-p),C=2*(d+h),T=-o-u+m+g,E=n.elements;return E[0]=_*r,E[1]=y*r,E[2]=S*r,E[3]=0,E[4]=A*s,E[5]=x*s,E[6]=C*s,E[7]=0,E[8]=v*a,E[9]=b*a,E[10]=T*a,E[11]=0,E[12]=e.x,E[13]=e.y,E[14]=e.z,E[15]=1,n}}__publicField(StaticMatrix4,"IDENTITY",Object.freeze(new three.Matrix4)),StaticMatrix4.ZERO=Object.freeze(new three.Matrix4(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0));let scratchHPRQuaternion$1=new three.Quaternion,scratchHeadingQuaternion=new three.Quaternion,scratchPitchQuaternion=new three.Quaternion,scratchRollQuaternion=new three.Quaternion,fromAxisAngleScratch=new three.Vector3;class StaticQuaternion{static fromAxisAngle(e,t,i){return i||(i=new three.Quaternion),fromAxisAngleScratch.copy(e),fromAxisAngleScratch.normalize(),i.setFromAxisAngle(fromAxisAngleScratch,t),i}static multiply(e,t,i){return i||(i=new three.Quaternion),i.multiplyQuaternions(e,t),i}static fromHeadingPitchRoll(e,t){return scratchRollQuaternion=StaticQuaternion.fromAxisAngle(Cartesian3.UNIT_X,e.roll,scratchHPRQuaternion$1),scratchPitchQuaternion=StaticQuaternion.fromAxisAngle(Cartesian3.UNIT_Y,-e.pitch,t),t=StaticQuaternion.multiply(scratchPitchQuaternion,scratchRollQuaternion,scratchPitchQuaternion),scratchHeadingQuaternion=StaticQuaternion.fromAxisAngle(Cartesian3.UNIT_Z,-e.heading,scratchHPRQuaternion$1),StaticQuaternion.multiply(scratchHeadingQuaternion,t,t)}}class Rectangle{constructor(e,t,i,n){this.west=e||0,this.south=t||0,this.east=i||0,this.north=n||0}get width(){return Rectangle.computeWidth(this)}get height(){return Rectangle.computeHeight(this)}}Rectangle.fromDegrees=function(e,t,i,n,r){return e=three.MathUtils.degToRad(defaultValue(e,0)),t=three.MathUtils.degToRad(defaultValue(t,0)),i=three.MathUtils.degToRad(defaultValue(i,0)),n=three.MathUtils.degToRad(defaultValue(n,0)),defined$1(r)?(r.west=e,r.south=t,r.east=i,r.north=n,r):new Rectangle(e,t,i,n)},Rectangle.computeWidth=function(e){let t=e.east;const i=e.west;return t<i&&(t+=CesiumMath.TWO_PI),t-i},Rectangle.computeHeight=function(e){return e.north-e.south},Rectangle.clone=function(e,t){if(defined$1(e))return defined$1(t)?(t.west=e.west,t.south=e.south,t.east=e.east,t.north=e.north,t):new Rectangle(e.west,e.south,e.east,e.north)},Rectangle.southwest=function(e,t){return defined$1(t)?(t.x=e.west,t.y=e.south,t.z=0,t):new three.Vector3(e.west,e.south)},Rectangle.northeast=function(e,t){return defined$1(t)?(t.x=e.east,t.y=e.north,t.z=0,t):new three.Vector3(e.east,e.north)},Rectangle.southeast=function(e,t){return defined$1(t)?(t.x=e.east,t.y=e.south,t.z=0,t):new three.Vector3(e.east,e.south)},Rectangle.northwest=function(e,t){return defined$1(t)?(t.x=e.west,t.y=e.north,t.z=0,t):new three.Vector3(e.west,e.north)},Rectangle.center=function(e,t){let i=e.east;const n=e.west;i<n&&(i+=CesiumMath.TWO_PI);const r=CesiumMath.negativePiToPi(.5*(n+i)),s=.5*(e.south+e.north);return defined$1(t)?(t.x=r,t.y=s,t.z=0,t):new three.Vector3(r,s)},Rectangle.contains=function(e,t){let i=t.x;const n=t.y,r=e.west;let s=e.east;return s<r&&(s+=CesiumMath.TWO_PI,i<0&&(i+=CesiumMath.TWO_PI)),(i>r||CesiumMath.equalsEpsilon(i,r,CesiumMath.EPSILON14))&&(i<s||CesiumMath.equalsEpsilon(i,s,CesiumMath.EPSILON14))&&n>=e.south&&n<=e.north};const maxPI=Math.PI+1e-5,minPI=-Math.PI-1e-5,maxPIOverTwo=CesiumMath.PI_OVER_TWO+1e-5,minPIOverTwo=-CesiumMath.PI_OVER_TWO-1e-5;Rectangle.fromBox=function(e,t,i=!1){const n=e.min,r=e.max;let s=n.x/180*Math.PI,a=n.y/180*Math.PI,o=r.x/180*Math.PI,l=r.y/180*Math.PI;return i&&(s<minPI&&(s=-Math.PI),s>maxPI&&(s=Math.PI),a<minPIOverTwo&&(a=-CesiumMath.PI_OVER_TWO),a>maxPIOverTwo&&(a=CesiumMath.PI_OVER_TWO),o>maxPI&&(o=Math.PI),o<minPI&&(o=-Math.PI),l>maxPIOverTwo&&(l=CesiumMath.PI_OVER_TWO),l<minPIOverTwo&&(l=-CesiumMath.PI_OVER_TWO)),defined$1(t)?(t.west=s,t.south=a,t.east=o,t.north=l,t):new Rectangle(s,a,o,l)},Rectangle.MAX_VALUE=Object.freeze(new Rectangle(-Math.PI,-CesiumMath.PI_OVER_TWO,Math.PI,CesiumMath.PI_OVER_TWO));class HeadingPitchRange{constructor(e,t,i){this.heading=defaultValue(e,0),this.pitch=defaultValue(t,0),this.range=defaultValue(i,0)}clone(e,t){if(defined$1(e))return defined$1(t)||(t=new HeadingPitchRange),t.heading=e.heading,t.pitch=e.pitch,t.range=e.range,t}}const Transforms={},scratchHPRQuaternion=new three.Quaternion,scratchScale$2=new three.Vector3(1,1,1),scratchHPRMatrix4=new three.Matrix4,vectorProductLocalFrame={up:{south:"east",north:"west",west:"south",east:"north"},down:{south:"west",north:"east",west:"north",east:"south"},south:{up:"west",down:"east",west:"down",east:"up"},north:{up:"east",down:"west",west:"up",east:"down"},west:{up:"north",down:"south",north:"down",south:"up"},east:{up:"south",down:"north",north:"up",south:"down"}};let degeneratePositionLocalFrame={north:[-1,0,0],east:[0,1,0],up:[0,0,1],south:[1,0,0],west:[0,-1,0],down:[0,0,-1]},localFrameToFixedFrameCache={},scratchCalculateCartesian={east:new three.Vector3,north:new three.Vector3,up:new three.Vector3,west:new three.Vector3,south:new three.Vector3,down:new three.Vector3},scratchFirstCartesian=new three.Vector3,scratchSecondCartesian=new three.Vector3,scratchThirdCartesian=new three.Vector3;const defined=e=>void 0!==e,zeroVector3=new three.Vector3,mathSign=e=>0===(e=+e)?e:e>0?1:-1,scratchN=new three.Vector3,scratchK=new three.Vector3,radianToEcef=function(e,t,i=0,n){const r=new three.Vector3(40680631590769,40680631590769,40408299984661.445),s=Math.cos(t);scratchN.x=s*Math.cos(e),scratchN.y=s*Math.sin(e),scratchN.z=Math.sin(t),scratchN.normalize(),scratchK.multiplyVectors(r,scratchN);const a=Math.sqrt(scratchN.dot(scratchK));return scratchK.divideScalar(a),scratchN.multiplyScalar(i),defined(n)||(n=new three.Vector3),n.addVectors(scratchK,scratchN)},lnglatToEcef=(e,t,i=0,n)=>radianToEcef(e*Math.PI/180,t*Math.PI/180,i,n);function Interval(e,t){this.start=defaultValue(e,0),this.stop=defaultValue(t,0)}Transforms.lnglatToEcef=lnglatToEcef,Transforms.radianToEcef=radianToEcef,Transforms.localFrameToFixedFrameGenerator=function(e,t){if(!vectorProductLocalFrame.hasOwnProperty(e)||!vectorProductLocalFrame[e].hasOwnProperty(t))throw new Error("firstAxis and secondAxis must be east, north, up, west, south or down.");let i,n=vectorProductLocalFrame[e][t],r=e+t;return defined(localFrameToFixedFrameCache[r])?i=localFrameToFixedFrameCache[r]:(i=function(i,r,s){if(!defined(i))throw new Error("origin is required.");if(defined(s)||(s=new three.Matrix4),i.equals(zeroVector3))scratchFirstCartesian.fromArray(degeneratePositionLocalFrame[e]),scratchSecondCartesian.fromArray(degeneratePositionLocalFrame[t]),scratchThirdCartesian.fromArray(degeneratePositionLocalFrame[n]);else if(Math.abs(i.x)<1e-14&&Math.abs(i.y)<1e-14){let r=mathSign(i.z);scratchFirstCartesian.fromArray(degeneratePositionLocalFrame[e]),"east"!==e&&"west"!==e&&scratchFirstCartesian.multiplyScalar(r),scratchSecondCartesian.fromArray(degeneratePositionLocalFrame[t]),"east"!==t&&"west"!==t&&scratchSecondCartesian.multiplyScalar(r),scratchThirdCartesian.fromArray(degeneratePositionLocalFrame[n]),"east"!==n&&"west"!==n&&scratchThirdCartesian.multiplyScalar(r)}else{(r=r||Ellipsoid.WGS84).geodeticSurfaceNormal(i,scratchCalculateCartesian.up);let s=scratchCalculateCartesian.up,a=scratchCalculateCartesian.east;a.x=-i.y,a.y=i.x,a.z=0,scratchCalculateCartesian.east.copy(a).normalize(),scratchCalculateCartesian.north.crossVectors(s,a),scratchCalculateCartesian.down.copy(scratchCalculateCartesian.up).multiplyScalar(-1),scratchCalculateCartesian.west.copy(scratchCalculateCartesian.east).multiplyScalar(-1),scratchCalculateCartesian.south.copy(scratchCalculateCartesian.north).multiplyScalar(-1),scratchFirstCartesian=scratchCalculateCartesian[e],scratchSecondCartesian=scratchCalculateCartesian[t],scratchThirdCartesian=scratchCalculateCartesian[n]}const a=s.elements;return a[0]=scratchFirstCartesian.x,a[1]=scratchFirstCartesian.y,a[2]=scratchFirstCartesian.z,a[3]=0,a[4]=scratchSecondCartesian.x,a[5]=scratchSecondCartesian.y,a[6]=scratchSecondCartesian.z,a[7]=0,a[8]=scratchThirdCartesian.x,a[9]=scratchThirdCartesian.y,a[10]=scratchThirdCartesian.z,a[11]=0,a[12]=i.x,a[13]=i.y,a[14]=i.z,a[15]=1,s},localFrameToFixedFrameCache[r]=i),i},Transforms.eastNorthUpToFixedFrame=Transforms.localFrameToFixedFrameGenerator("east","north"),Transforms.headingPitchRollToFixedFrame=function(e,t,i,n,r){n=n||Transforms.eastNorthUpToFixedFrame;const s=StaticQuaternion.fromHeadingPitchRoll(t,scratchHPRQuaternion),a=StaticMatrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO,s,scratchScale$2,scratchHPRMatrix4);return(r=n(e,i,r)).multiply(a)},Transforms.northEastDownToFixedFrame=Transforms.localFrameToFixedFrameGenerator("north","east"),Transforms.northUpEastToFixedFrame=Transforms.localFrameToFixedFrameGenerator("north","up"),Transforms.northWestUpToFixedFrame=Transforms.localFrameToFixedFrameGenerator("north","west");var QuadraticRealPolynomial={};function addWithCancellationCheck$1(e,t,i){var n=e+t;return CesiumMath.sign(e)!==CesiumMath.sign(t)&&Math.abs(n/Math.max(Math.abs(e),Math.abs(t)))<i?0:n}QuadraticRealPolynomial.computeDiscriminant=function(e,t,i){if("number"!=typeof e)throw new DeveloperError("a is a required number.");if("number"!=typeof t)throw new DeveloperError("b is a required number.");if("number"!=typeof i)throw new DeveloperError("c is a required number.");return t*t-4*e*i},QuadraticRealPolynomial.computeRealRoots=function(e,t,i){if("number"!=typeof e)throw new DeveloperError("a is a required number.");if("number"!=typeof t)throw new DeveloperError("b is a required number.");if("number"!=typeof i)throw new DeveloperError("c is a required number.");var n;if(0===e)return 0===t?[]:[-i/t];if(0===t){if(0===i)return[0,0];var r=Math.abs(i),s=Math.abs(e);if(r<s&&r/s<CesiumMath.EPSILON14)return[0,0];if(r>s&&s/r<CesiumMath.EPSILON14)return[];if((n=-i/e)<0)return[];var a=Math.sqrt(n);return[-a,a]}if(0===i)return(n=-t/e)<0?[n,0]:[0,n];var o=addWithCancellationCheck$1(t*t,-(4*e*i),CesiumMath.EPSILON14);if(o<0)return[];var l=-.5*addWithCancellationCheck$1(t,CesiumMath.sign(t)*Math.sqrt(o),CesiumMath.EPSILON14);return t>0?[l/e,i/l]:[i/l,l/e]};var CubicRealPolynomial={};function computeRealRoots(e,t,i,n){var r,s,a=e,o=t/3,l=i/3,c=n,h=a*l,u=o*c,d=o*o,p=l*l,m=a*l-d,f=a*c-o*l,g=o*c-p,_=4*m*g-f*f;if(_<0){var A,v,y;d*u>=h*p?(A=a,v=m,y=-2*o*m+a*f):(A=c,v=g,y=-c*f+2*l*g);var x=-(y<0?-1:1)*Math.abs(A)*Math.sqrt(-_),b=(s=-y+x)/2,S=b<0?-Math.pow(-b,1/3):Math.pow(b,1/3),C=s===x?-S:-v/S;return r=v<=0?S+C:-y/(S*S+C*C+v),d*u>=h*p?[(r-o)/a]:[-c/(r+l)]}var T=m,E=-2*o*m+a*f,M=g,w=-c*f+2*l*g,I=Math.sqrt(_),P=Math.sqrt(3)/2,R=Math.abs(Math.atan2(a*I,-E)/3);r=2*Math.sqrt(-T);var B=Math.cos(R);s=r*B;var D=r*(-B/2-P*Math.sin(R)),F=s+D>2*o?s-o:D-o,O=a,L=F/O;R=Math.abs(Math.atan2(c*I,-w)/3);var N=-c,V=(s=(r=2*Math.sqrt(-M))*(B=Math.cos(R)))+(D=r*(-B/2-P*Math.sin(R)))<2*l?s+l:D+l,U=N/V,k=-F*V-O*N,G=(l*k-o*(F*N))/(-o*k+l*(O*V));return L<=G?L<=U?G<=U?[L,G,U]:[L,U,G]:[U,L,G]:L<=U?[G,L,U]:G<=U?[G,U,L]:[U,G,L]}CubicRealPolynomial.computeDiscriminant=function(e,t,i,n){if("number"!=typeof e)throw new DeveloperError("a is a required number.");if("number"!=typeof t)throw new DeveloperError("b is a required number.");if("number"!=typeof i)throw new DeveloperError("c is a required number.");if("number"!=typeof n)throw new DeveloperError("d is a required number.");var r=t*t,s=i*i;return 18*e*t*i*n+r*s-27*(e*e)*(n*n)-4*(e*s*i+r*t*n)},CubicRealPolynomial.computeRealRoots=function(e,t,i,n){if("number"!=typeof e)throw new DeveloperError("a is a required number.");if("number"!=typeof t)throw new DeveloperError("b is a required number.");if("number"!=typeof i)throw new DeveloperError("c is a required number.");if("number"!=typeof n)throw new DeveloperError("d is a required number.");var r,s;if(0===e)return QuadraticRealPolynomial.computeRealRoots(t,i,n);if(0===t){if(0===i){if(0===n)return[0,0,0];var a=(s=-n/e)<0?-Math.pow(-s,1/3):Math.pow(s,1/3);return[a,a,a]}return 0===n?0===(r=QuadraticRealPolynomial.computeRealRoots(e,0,i)).Length?[0]:[r[0],0,r[1]]:computeRealRoots(e,0,i,n)}return 0===i?0===n?(s=-t/e)<0?[s,0,0]:[0,0,s]:computeRealRoots(e,t,0,n):0===n?0===(r=QuadraticRealPolynomial.computeRealRoots(e,t,i)).length?[0]:r[1]<=0?[r[0],r[1],0]:r[0]>=0?[0,r[0],r[1]]:[r[0],0,r[1]]:computeRealRoots(e,t,i,n)};var QuarticRealPolynomial={};function original(e,t,i,n){var r=e*e,s=t-3*r/8,a=i-t*e/2+r*e/8,o=n-i*e/4+t*r/16-3*r*r/256,l=CubicRealPolynomial.computeRealRoots(1,2*s,s*s-4*o,-a*a);if(l.length>0){var c=-e/4,h=l[l.length-1];if(Math.abs(h)<CesiumMath.EPSILON14){var u=QuadraticRealPolynomial.computeRealRoots(1,s,o);if(2===u.length){var d,p=u[0],m=u[1];if(p>=0&&m>=0){var f=Math.sqrt(p),g=Math.sqrt(m);return[c-g,c-f,c+f,c+g]}if(p>=0&&m<0)return[c-(d=Math.sqrt(p)),c+d];if(p<0&&m>=0)return[c-(d=Math.sqrt(m)),c+d]}return[]}if(h>0){var _=Math.sqrt(h),A=(s+h-a/_)/2,v=(s+h+a/_)/2,y=QuadraticRealPolynomial.computeRealRoots(1,_,A),x=QuadraticRealPolynomial.computeRealRoots(1,-_,v);return 0!==y.length?(y[0]+=c,y[1]+=c,0!==x.length?(x[0]+=c,x[1]+=c,y[1]<=x[0]?[y[0],y[1],x[0],x[1]]:x[1]<=y[0]?[x[0],x[1],y[0],y[1]]:y[0]>=x[0]&&y[1]<=x[1]?[x[0],y[0],y[1],x[1]]:x[0]>=y[0]&&x[1]<=y[1]?[y[0],x[0],x[1],y[1]]:y[0]>x[0]&&y[0]<x[1]?[x[0],y[0],x[1],y[1]]:[y[0],x[0],y[1],x[1]]):y):0!==x.length?(x[0]+=c,x[1]+=c,x):[]}}return[]}function neumark(e,t,i,n){var r=e*e,s=-2*t,a=i*e+t*t-4*n,o=r*n-i*t*e+i*i,l=CubicRealPolynomial.computeRealRoots(1,s,a,o);if(l.length>0){var c,h,u,d,p,m,f=l[0],g=t-f,_=g*g,A=e/2,v=g/2,y=_-4*n,x=_+4*Math.abs(n),b=r-4*f,S=r+4*Math.abs(f);if(f<0||y*S<b*x){var C=Math.sqrt(b);c=C/2,h=0===C?0:(e*v-i)/C}else{var T=Math.sqrt(y);c=0===T?0:(e*v-i)/T,h=T/2}0===A&&0===c?(u=0,d=0):CesiumMath.sign(A)===CesiumMath.sign(c)?d=f/(u=A+c):u=f/(d=A-c),0===v&&0===h?(p=0,m=0):CesiumMath.sign(v)===CesiumMath.sign(h)?m=n/(p=v+h):p=n/(m=v-h);var E=QuadraticRealPolynomial.computeRealRoots(1,u,p),M=QuadraticRealPolynomial.computeRealRoots(1,d,m);if(0!==E.length)return 0!==M.length?E[1]<=M[0]?[E[0],E[1],M[0],M[1]]:M[1]<=E[0]?[M[0],M[1],E[0],E[1]]:E[0]>=M[0]&&E[1]<=M[1]?[M[0],E[0],E[1],M[1]]:M[0]>=E[0]&&M[1]<=E[1]?[E[0],M[0],M[1],E[1]]:E[0]>M[0]&&E[0]<M[1]?[M[0],E[0],M[1],E[1]]:[E[0],M[0],E[1],M[1]]:E;if(0!==M.length)return M}return[]}QuarticRealPolynomial.computeDiscriminant=function(e,t,i,n,r){if("number"!=typeof e)throw new DeveloperError("a is a required number.");if("number"!=typeof t)throw new DeveloperError("b is a required number.");if("number"!=typeof i)throw new DeveloperError("c is a required number.");if("number"!=typeof n)throw new DeveloperError("d is a required number.");if("number"!=typeof r)throw new DeveloperError("e is a required number.");var s=e*e,a=t*t,o=a*t,l=i*i,c=l*i,h=n*n,u=h*n,d=r*r;return a*l*h-4*o*u-4*e*c*h+18*e*t*i*u-27*s*h*h+256*(s*e)*(d*r)+r*(18*o*i*n-4*a*c+16*e*l*l-80*e*t*l*n-6*e*a*h+144*s*i*h)+d*(144*e*a*i-27*a*a-128*s*l-192*s*t*n)},QuarticRealPolynomial.computeRealRoots=function(e,t,i,n,r){if("number"!=typeof e)throw new DeveloperError("a is a required number.");if("number"!=typeof t)throw new DeveloperError("b is a required number.");if("number"!=typeof i)throw new DeveloperError("c is a required number.");if("number"!=typeof n)throw new DeveloperError("d is a required number.");if("number"!=typeof r)throw new DeveloperError("e is a required number.");if(Math.abs(e)<CesiumMath.EPSILON15)return CubicRealPolynomial.computeRealRoots(t,i,n,r);var s=t/e,a=i/e,o=n/e,l=r/e,c=s<0?1:0;switch(c+=a<0?c+1:c,c+=o<0?c+1:c,c+=l<0?c+1:c){case 0:case 3:case 4:case 6:case 7:case 9:case 10:case 12:case 13:case 14:case 15:return original(s,a,o,l);case 1:case 2:case 5:case 8:case 11:return neumark(s,a,o,l);default:return}};var IntersectionTests={rayPlane:function(e,t,i){if(!defined$1(e))throw new DeveloperError("ray is required.");if(!defined$1(t))throw new DeveloperError("plane is required.");defined$1(i)||(i=new three.Vector3);var n=e.origin,r=e.direction,s=t.normal,a=Cartesian3.dot(s,r);if(!(Math.abs(a)<CesiumMath.EPSILON15)){var o=(-t.constant-Cartesian3.dot(s,n))/a;if(!(o<0))return i=Cartesian3.multiplyByScalar(r,o,i),Cartesian3.add(n,i,i)}}},scratchEdge0=new three.Vector3,scratchEdge1=new three.Vector3,scratchPVec=new three.Vector3,scratchTVec=new three.Vector3,scratchQVec=new three.Vector3;IntersectionTests.rayTriangleParametric=function(e,t,i,n,r){if(!defined$1(e))throw new DeveloperError("ray is required.");if(!defined$1(t))throw new DeveloperError("p0 is required.");if(!defined$1(i))throw new DeveloperError("p1 is required.");if(!defined$1(n))throw new DeveloperError("p2 is required.");r=defaultValue(r,!1);var s,a,o,l,c,h=e.origin,u=e.direction,d=Cartesian3.subtract(i,t,scratchEdge0),p=Cartesian3.subtract(n,t,scratchEdge1),m=Cartesian3.cross(u,p,scratchPVec),f=Cartesian3.dot(d,m);if(r){if(f<CesiumMath.EPSILON6)return;if(s=Cartesian3.subtract(h,t,scratchTVec),(o=Cartesian3.dot(s,m))<0||o>f)return;if(a=Cartesian3.cross(s,d,scratchQVec),(l=Cartesian3.dot(u,a))<0||o+l>f)return;c=Cartesian3.dot(p,a)/f}else{if(Math.abs(f)<CesiumMath.EPSILON6)return;var g=1/f;if(s=Cartesian3.subtract(h,t,scratchTVec),(o=Cartesian3.dot(s,m)*g)<0||o>1)return;if(a=Cartesian3.cross(s,d,scratchQVec),(l=Cartesian3.dot(u,a)*g)<0||o+l>1)return;c=Cartesian3.dot(p,a)*g}return c},IntersectionTests.rayTriangle=function(e,t,i,n,r,s){var a=IntersectionTests.rayTriangleParametric(e,t,i,n,r);if(defined$1(a)&&!(a<0))return defined$1(s)||(s=new three.Vector3),Cartesian3.multiplyByScalar(e.direction,a,s),Cartesian3.add(e.origin,s,s)};var scratchLineSegmentTriangleRay=new three.Ray;function solveQuadratic(e,t,i,n){var r=t*t-4*e*i;if(!(r<0)){if(r>0){var s=1/(2*e),a=Math.sqrt(r),o=(-t+a)*s,l=(-t-a)*s;return o<l?(n.root0=o,n.root1=l):(n.root0=l,n.root1=o),n}var c=-t/(2*e);if(0!==c)return n.root0=n.root1=c,n}}IntersectionTests.lineSegmentTriangle=function(e,t,i,n,r,s,a){if(!defined$1(e))throw new DeveloperError("v0 is required.");if(!defined$1(t))throw new DeveloperError("v1 is required.");if(!defined$1(i))throw new DeveloperError("p0 is required.");if(!defined$1(n))throw new DeveloperError("p1 is required.");if(!defined$1(r))throw new DeveloperError("p2 is required.");var o=scratchLineSegmentTriangleRay;Cartesian3.clone(e,o.origin),Cartesian3.subtract(t,e,o.direction),Cartesian3.normalize(o.direction,o.direction);var l=IntersectionTests.rayTriangleParametric(o,i,n,r,s);if(!(!defined$1(l)||l<0||l>Cartesian3.distance(e,t)))return defined$1(a)||(a=new three.Vector3),Cartesian3.multiplyByScalar(o.direction,l,a),Cartesian3.add(o.origin,a,a)};var raySphereRoots={root0:0,root1:0};function raySphere(e,t,i){defined$1(i)||(i=new Interval);var n=e.origin,r=e.direction,s=t.center,a=t.radius*t.radius,o=Cartesian3.subtract(n,s,scratchPVec),l=solveQuadratic(Cartesian3.dot(r,r),2*Cartesian3.dot(r,o),Cartesian3.magnitudeSquared(o)-a,raySphereRoots);if(defined$1(l))return i.start=l.root0,i.stop=l.root1,i}IntersectionTests.raySphere=function(e,t,i){if(!defined$1(e))throw new DeveloperError("ray is required.");if(!defined$1(t))throw new DeveloperError("sphere is required.");if(defined$1(i=raySphere(e,t,i))&&!(i.stop<0))return i.start=Math.max(i.start,0),i};var scratchLineSegmentRay=new three.Ray;IntersectionTests.lineSegmentSphere=function(e,t,i,n){if(!defined$1(e))throw new DeveloperError("p0 is required.");if(!defined$1(t))throw new DeveloperError("p1 is required.");if(!defined$1(i))throw new DeveloperError("sphere is required.");var r=scratchLineSegmentRay;Cartesian3.clone(e,r.origin);var s=Cartesian3.subtract(t,e,r.direction),a=Cartesian3.magnitude(s);if(Cartesian3.normalize(s,s),!(!defined$1(n=raySphere(r,i,n))||n.stop<0||n.start>a))return n.start=Math.max(n.start,0),n.stop=Math.min(n.stop,a),n};var scratchQ=new three.Vector3,scratchW=new three.Vector3;function addWithCancellationCheck(e,t,i){var n=e+t;return CesiumMath.sign(e)!==CesiumMath.sign(t)&&Math.abs(n/Math.max(Math.abs(e),Math.abs(t)))<i?0:n}function quadraticVectorExpression(e,t,i,n,r){var s,a=n*n,o=r*r,l=(e[StaticMatrix3.COLUMN1ROW1]-e[StaticMatrix3.COLUMN2ROW2])*o,c=r*(n*addWithCancellationCheck(e[StaticMatrix3.COLUMN1ROW0],e[StaticMatrix3.COLUMN0ROW1],CesiumMath.EPSILON15)+t.y),h=e[StaticMatrix3.COLUMN0ROW0]*a+e[StaticMatrix3.COLUMN2ROW2]*o+n*t.x+i,u=o*addWithCancellationCheck(e[StaticMatrix3.COLUMN2ROW1],e[StaticMatrix3.COLUMN1ROW2],CesiumMath.EPSILON15),d=r*(n*addWithCancellationCheck(e[StaticMatrix3.COLUMN2ROW0],e[StaticMatrix3.COLUMN0ROW2])+t.z),p=[];if(0===d&&0===u){if(0===(s=QuadraticRealPolynomial.computeRealRoots(l,c,h)).length)return p;var m=s[0],f=Math.sqrt(Math.max(1-m*m,0));if(p.push(new three.Vector3(n,r*m,r*-f)),p.push(new three.Vector3(n,r*m,r*f)),2===s.length){var g=s[1],_=Math.sqrt(Math.max(1-g*g,0));p.push(new three.Vector3(n,r*g,r*-_)),p.push(new three.Vector3(n,r*g,r*_))}return p}var A=d*d,v=u*u,y=d*u,x=l*l+v,b=2*(c*l+y),S=2*h*l+c*c-v+A,C=2*(h*c-y),T=h*h-A;if(0===x&&0===b&&0===S&&0===C)return p;var E=(s=QuarticRealPolynomial.computeRealRoots(x,b,S,C,T)).length;if(0===E)return p;for(var M=0;M<E;++M){var w=s[M],I=w*w,P=Math.max(1-I,0),R=Math.sqrt(P),B=(CesiumMath.sign(l)===CesiumMath.sign(h)?addWithCancellationCheck(l*I+h,c*w,CesiumMath.EPSILON12):CesiumMath.sign(h)===CesiumMath.sign(c*w)?addWithCancellationCheck(l*I,c*w+h,CesiumMath.EPSILON12):addWithCancellationCheck(l*I+c*w,h,CesiumMath.EPSILON12))*addWithCancellationCheck(u*w,d,CesiumMath.EPSILON15);B<0?p.push(new three.Vector3(n,r*w,r*R)):B>0?p.push(new three.Vector3(n,r*w,r*-R)):0!==R?(p.push(new three.Vector3(n,r*w,r*-R)),p.push(new three.Vector3(n,r*w,r*R)),++M):p.push(new three.Vector3(n,r*w,r*R))}return p}IntersectionTests.rayEllipsoid=function(e,t){if(!defined$1(e))throw new DeveloperError("ray is required.");if(!defined$1(t))throw new DeveloperError("ellipsoid is required.");var i,n,r,s,a,o=t.oneOverRadii,l=Cartesian3.multiplyComponents(o,e.origin,scratchQ),c=Cartesian3.multiplyComponents(o,e.direction,scratchW),h=Cartesian3.magnitudeSquared(l),u=Cartesian3.dot(l,c);if(h>1){if(u>=0)return;var d=u*u;if(i=h-1,d<(r=(n=Cartesian3.magnitudeSquared(c))*i))return;if(d>r){s=u*u-r;var p=(a=-u+Math.sqrt(s))/n,m=i/a;return p<m?new Interval(p,m):{start:m,stop:p}}var f=Math.sqrt(i/n);return new Interval(f,f)}return h<1?(i=h-1,s=u*u-(r=(n=Cartesian3.magnitudeSquared(c))*i),new Interval(0,(a=-u+Math.sqrt(s))/n)):u<0?new Interval(0,-u/(n=Cartesian3.magnitudeSquared(c))):void 0};var firstAxisScratch=new three.Vector3,secondAxisScratch=new three.Vector3,thirdAxisScratch=new three.Vector3,referenceScratch=new three.Vector3,bCart=new three.Vector3,bScratch=new three.Matrix3,btScratch=new three.Matrix3,diScratch=new three.Matrix3,dScratch=new three.Matrix3,cScratch=new three.Matrix3,tempMatrix$2=new three.Matrix3,aScratch=new three.Matrix3,sScratch=new three.Vector3,closestScratch=new three.Vector3,surfPointScratch=new three.Vector3;IntersectionTests.grazingAltitudeLocation=function(e,t){if(!defined$1(e))throw new DeveloperError("ray is required.");if(!defined$1(t))throw new DeveloperError("ellipsoid is required.");var i=e.origin,n=e.direction;if(!Cartesian3.equals(i,Cartesian3.ZERO)){var r=t.geodeticSurfaceNormal(i,firstAxisScratch);if(Cartesian3.dot(n,r)>=0)return i}var s=defined$1(this.rayEllipsoid(e,t)),a=t.transformPositionToScaledSpace(n,firstAxisScratch),o=Cartesian3.normalize(a,a),l=Cartesian3.mostOrthogonalAxis(a,referenceScratch),c=Cartesian3.normalize(Cartesian3.cross(l,o,secondAxisScratch),secondAxisScratch),h=Cartesian3.normalize(Cartesian3.cross(o,c,thirdAxisScratch),thirdAxisScratch),u=bScratch;u[0]=o.x,u[1]=o.y,u[2]=o.z,u[3]=c.x,u[4]=c.y,u[5]=c.z,u[6]=h.x,u[7]=h.y,u[8]=h.z;var d=StaticMatrix3.transpose(u,btScratch),p=StaticMatrix3.fromScale(t.radii,diScratch),m=StaticMatrix3.fromScale(t.oneOverRadii,dScratch),f=cScratch;f[0]=0,f[1]=-n.z,f[2]=n.y,f[3]=n.z,f[4]=0,f[5]=-n.x,f[6]=-n.y,f[7]=n.x,f[8]=0;var g,_,A=StaticMatrix3.multiply(StaticMatrix3.multiply(d,m,tempMatrix$2),f,tempMatrix$2),v=StaticMatrix3.multiply(StaticMatrix3.multiply(A,p,aScratch),u,aScratch),y=StaticMatrix3.multiplyByVector(A,i,bCart),x=quadraticVectorExpression(v,Cartesian3.negate(y,firstAxisScratch),0,0,1),b=x.length;if(b>0){for(var S=Cartesian3.clone(Cartesian3.ZERO,closestScratch),C=Number.NEGATIVE_INFINITY,T=0;T<b;++T){g=StaticMatrix3.multiplyByVector(p,StaticMatrix3.multiplyByVector(u,x[T],sScratch),sScratch);var E=Cartesian3.normalize(Cartesian3.subtract(g,i,referenceScratch),referenceScratch),M=Cartesian3.dot(E,n);M>C&&(C=M,S=Cartesian3.clone(g,S))}var w=t.cartesianToCartographic(S,surfPointScratch);return C=CesiumMath.clamp(C,0,1),_=Cartesian3.magnitude(Cartesian3.subtract(S,i,referenceScratch))*Math.sqrt(1-C*C),_=s?-_:_,w.z=_,t.cartographicToCartesian(w,new three.Vector3)}};var lineSegmentPlaneDifference=new three.Vector3;IntersectionTests.lineSegmentPlane=function(e,t,i,n){if(!defined$1(e))throw new DeveloperError("endPoint0 is required.");if(!defined$1(t))throw new DeveloperError("endPoint1 is required.");if(!defined$1(i))throw new DeveloperError("plane is required.");defined$1(n)||(n=new three.Vector3);var r=Cartesian3.subtract(t,e,lineSegmentPlaneDifference),s=i.normal,a=Cartesian3.dot(s,r);if(!(Math.abs(a)<CesiumMath.EPSILON6)){var o=Cartesian3.dot(s,e),l=-(i.constant+o)/a;if(!(l<0||l>1))return Cartesian3.multiplyByScalar(r,l,n),Cartesian3.add(e,n,n),n}},IntersectionTests.trianglePlaneIntersection=function(e,t,i,n){if(!(defined$1(e)&&defined$1(t)&&defined$1(i)&&defined$1(n)))throw new DeveloperError("p0, p1, p2, and plane are required.");var r,s,a=n.normal,o=n.constant,l=Cartesian3.dot(a,e)+o<0,c=Cartesian3.dot(a,t)+o<0,h=Cartesian3.dot(a,i)+o<0,u=0;if(u+=l?1:0,u+=c?1:0,1!==(u+=h?1:0)&&2!==u||(r=new three.Vector3,s=new three.Vector3),1===u){if(l)return IntersectionTests.lineSegmentPlane(e,t,n,r),IntersectionTests.lineSegmentPlane(e,i,n,s),{positions:[e,t,i,r,s],indices:[0,3,4,1,2,4,1,4,3]};if(c)return IntersectionTests.lineSegmentPlane(t,i,n,r),IntersectionTests.lineSegmentPlane(t,e,n,s),{positions:[e,t,i,r,s],indices:[1,3,4,2,0,4,2,4,3]};if(h)return IntersectionTests.lineSegmentPlane(i,e,n,r),IntersectionTests.lineSegmentPlane(i,t,n,s),{positions:[e,t,i,r,s],indices:[2,3,4,0,1,4,0,4,3]}}else if(2===u){if(!l)return IntersectionTests.lineSegmentPlane(t,e,n,r),IntersectionTests.lineSegmentPlane(i,e,n,s),{positions:[e,t,i,r,s],indices:[1,2,4,1,4,3,0,3,4]};if(!c)return IntersectionTests.lineSegmentPlane(i,t,n,r),IntersectionTests.lineSegmentPlane(e,t,n,s),{positions:[e,t,i,r,s],indices:[2,0,4,2,4,3,1,3,4]};if(!h)return IntersectionTests.lineSegmentPlane(e,i,n,r),IntersectionTests.lineSegmentPlane(t,i,n,s),{positions:[e,t,i,r,s],indices:[0,1,4,0,4,3,2,3,4]}}};class StaticRay{static getPoint(e,t,i){return i||(i=new three.Vector3),i.copy(e.direction).multiplyScalar(t).add(e.origin),i}}const SceneMode={MORPHING:0,COLUMBUS_VIEW:1,SCENE2D:2,SCENE3D:3,getMorphTime:function(e){return e===SceneMode.SCENE3D?1:e!==SceneMode.MORPHING?0:void 0}},SceneMode$1=Object.freeze(SceneMode),MapMode2D={ROTATE:0,INFINITE_SCROLL:1};Object.freeze(MapMode2D);const cartesianToCartographicN=new three.Vector3,cartesianToCartographicP=new three.Vector3,cartesianToCartographicH=new three.Vector3,wgs84OneOverRadii=new three.Vector3(1/6378137,1/6378137,1/6356752.314245179),wgs84OneOverRadiiSquared=new three.Vector3(1/40680631590769,1/40680631590769,1/40408299984661.445),wgs84CenterToleranceSquared=CesiumMath.EPSILON1,_Cartographic=class{static fromRadians(e,t,i,n){return i=defaultValue(i,0),defined$1(n)?(n.x=e,n.y=t,n.z=i,n):new three.Vector3(e,t,i)}static fromDegrees(e,t,i,n){return e=CesiumMath.toRadians(e),t=CesiumMath.toRadians(t),_Cartographic.fromRadians(e,t,i,n)}static fromCartesian(e,t,i){const n=defined$1(t)?t.oneOverRadii:wgs84OneOverRadii,r=defined$1(t)?t.oneOverRadiiSquared:wgs84OneOverRadiiSquared,s=scaleToGeodeticSurface(e,n,r,defined$1(t)?t._centerToleranceSquared:wgs84CenterToleranceSquared,cartesianToCartographicP);if(!defined$1(s))return;let a=Cartesian3.multiplyComponents(s,r,cartesianToCartographicN);a=Cartesian3.normalize(a,a);const o=Cartesian3.subtract(e,s,cartesianToCartographicH),l=Math.atan2(a.y,a.x),c=Math.asin(a.z),h=CesiumMath.sign(Cartesian3.dot(o,e))*Cartesian3.magnitude(o);return defined$1(i)?(i.x=l,i.y=c,i.z=h,i):new three.Vector3(l,c,h)}static toCartesian(e,t,i){return Cartesian3.fromRadians(e.x,e.y,e.z,t,i)}static clone(e,t){if(defined$1(e))return defined$1(t)?(t.x=e.x,t.y=e.y,t.z=e.z,t):new three.Vector3(e.x,e.y,e.z)}static equals(e,t){return e===t||defined$1(e)&&defined$1(t)&&e.x===t.x&&e.y===t.y&&e.z===t.z}static equalsEpsilon(e,t,i){return i=defaultValue(i,0),e===t||defined$1(e)&&defined$1(t)&&CesiumMath.equalsEpsilon(e.x,t.x,i)&&CesiumMath.equalsEpsilon(e.y,t.y,i)&&CesiumMath.equalsEpsilon(e.z,t.z,i)}};let Cartographic=_Cartographic;function setConstants(e){const t=e._uSquared,i=e._ellipsoid.maximumRadius,n=e._ellipsoid.minimumRadius,r=(i-n)/i,s=Math.cos(e._startHeading),a=Math.sin(e._startHeading),o=(1-r)*Math.tan(e._start.y),l=1/Math.sqrt(1+o*o),c=l*o,h=Math.atan2(o,s),u=l*a,d=u*u,p=1-d,m=Math.sqrt(p),f=t/4,g=f*f,_=g*f,A=g*g,v=1+f-3*g/4+5*_/4-175*A/64,y=1-f+15*g/8-35*_/8,x=1-3*f+35*g/4,b=1-5*f,S=v*h-y*Math.sin(2*h)*f/2-x*Math.sin(4*h)*g/16-b*Math.sin(6*h)*_/48-5*Math.sin(8*h)*A/512,C=e._constants;C.a=i,C.b=n,C.f=r,C.cosineHeading=s,C.sineHeading=a,C.tanU=o,C.cosineU=l,C.sineU=c,C.sigma=h,C.sineAlpha=u,C.sineSquaredAlpha=d,C.cosineSquaredAlpha=p,C.cosineAlpha=m,C.u2Over4=f,C.u4Over16=g,C.u6Over64=_,C.u8Over256=A,C.a0=v,C.a1=y,C.a2=x,C.a3=b,C.distanceRatio=S}function computeC(e,t){return e*t*(4+e*(4-3*t))/16}function computeDeltaLambda(e,t,i,n,r,s,a){const o=computeC(e,i);return(1-o)*e*t*(n+o*r*(a+o*s*(2*a*a-1)))}function vincentyInverseFormula(e,t,i,n,r,s,a){const o=(t-i)/t,l=s-n,c=Math.atan((1-o)*Math.tan(r)),h=Math.atan((1-o)*Math.tan(a)),u=Math.cos(c),d=Math.sin(c),p=Math.cos(h),m=Math.sin(h),f=u*p,g=u*m,_=d*m,A=d*p;let v,y,x,b,S,C=l,T=CesiumMath.TWO_PI,E=Math.cos(C),M=Math.sin(C);do{E=Math.cos(C),M=Math.sin(C);const e=g-A*E;let t;x=Math.sqrt(p*p*M*M+e*e),y=_+f*E,v=Math.atan2(x,y),0===x?(t=0,b=1):(t=f*M/x,b=1-t*t),T=C,S=y-2*_/b,isFinite(S)||(S=0),C=l+computeDeltaLambda(o,t,b,v,x,y,S)}while(Math.abs(C-T)>CesiumMath.EPSILON12);const w=b*(t*t-i*i)/(i*i),I=w*(256+w*(w*(74-47*w)-128))/1024,P=S*S,R=i*(1+w*(4096+w*(w*(320-175*w)-768))/16384)*(v-I*x*(S+I*(y*(2*P-1)-I*S*(4*x*x-3)*(4*P-3)/6)/4)),B=Math.atan2(p*M,g-A*E),D=Math.atan2(u*M,g*E-A);e._distance=R,e._startHeading=B,e._endHeading=D,e._uSquared=w}__publicField(Cartographic,"fromRadians",(function(e,t,i,n){return i=defaultValue(i,0),defined$1(n)?(n.x=e,n.y=t,n.z=i,n):new three.Vector3(e,t,i)})),__publicField(Cartographic,"fromDegrees",(function(e,t,i,n){return e=CesiumMath.toRadians(e),t=CesiumMath.toRadians(t),_Cartographic.fromRadians(e,t,i,n)})),__publicField(Cartographic,"ZERO",Object.freeze(new three.Vector3(0,0,0)));const scratchCart1=new three.Vector3,scratchCart2=new three.Vector3;function computeProperties(e,t,i,n){Cartesian3.normalize(n.cartographicToCartesian(t,scratchCart2),scratchCart1),Cartesian3.normalize(n.cartographicToCartesian(i,scratchCart2),scratchCart2),vincentyInverseFormula(e,n.maximumRadius,n.minimumRadius,t.x,t.y,i.x,i.y),e._start=Cartographic.clone(t,e._start),e._end=Cartographic.clone(i,e._end),e._start.z=0,e._end.z=0,setConstants(e)}function EllipsoidGeodesic(e,t,i){const n=defaultValue(i,Ellipsoid.WGS84);this._ellipsoid=n,this._start=new three.Vector3,this._end=new three.Vector3,this._constants={},this._startHeading=void 0,this._endHeading=void 0,this._distance=void 0,this._uSquared=void 0,defined$1(e)&&defined$1(t)&&computeProperties(this,e,t,n)}Object.defineProperties(EllipsoidGeodesic.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},startHeading:{get:function(){return this._startHeading}},endHeading:{get:function(){return this._endHeading}}}),EllipsoidGeodesic.prototype.setEndPoints=function(e,t){computeProperties(this,e,t,this._ellipsoid)},EllipsoidGeodesic.prototype.interpolateUsingFraction=function(e,t){return this.interpolateUsingSurfaceDistance(this._distance*e,t)},EllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance=function(e,t){const i=this._constants,n=i.distanceRatio+e/i.b,r=Math.cos(2*n),s=Math.cos(4*n),a=Math.cos(6*n),o=Math.sin(2*n),l=Math.sin(4*n),c=Math.sin(6*n),h=Math.sin(8*n),u=n*n,d=n*u,p=i.u8Over256,m=i.u2Over4,f=i.u6Over64,g=i.u4Over16;let _=2*d*p*r/3+n*(1-m+7*g/4-15*f/4+579*p/64-(g-15*f/4+187*p/16)*r-(5*f/4-115*p/16)*s-29*p*a/16)+(m/2-g+71*f/32-85*p/16)*o+(5*g/16-5*f/4+383*p/96)*l-u*((f-11*p/2)*o+5*p*l/2)+(29*f/96-29*p/16)*c+539*p*h/1536;const A=Math.asin(Math.sin(_)*i.cosineAlpha),v=Math.atan(i.a/i.b*Math.tan(A));_-=i.sigma;const y=Math.cos(2*i.sigma+_),x=Math.sin(_),b=Math.cos(_),S=i.cosineU*b,C=i.sineU*x,T=Math.atan2(x*i.sineHeading,S-C*i.cosineHeading)-computeDeltaLambda(i.f,i.sineAlpha,i.cosineSquaredAlpha,_,x,b,y);return defined$1(t)?(t.x=this._start.x+T,t.y=v,t.z=0,t):new three.Vector3(this._start.x+T,v,0)};const EasingFunction={LINEAR:e=>e,QUINTIC_IN_OUT:e=>(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2),CUBIC_OUT:e=>--e*e*e+1},scratchStartCart=new three.Vector3;new three.Vector3;const scratchCart=new three.Vector3;new three.Vector3,new three.Frustum;const CameraFlightPath={};function getAltitude(e,t,i){let n,r,s;const a=Math.tan(.5*CesiumMath.toRadians(e.fov));return n=e.near,r=e.near*a,s=e.aspect*r,Math.max(t*n/s,i*n/r)}function adjustAngleForLERP(e,t){return CesiumMath.equalsEpsilon(e,CesiumMath.TWO_PI,CesiumMath.EPSILON11)&&(e=0),t>e+Math.PI?e+=CesiumMath.TWO_PI:t<e-Math.PI&&(e-=CesiumMath.TWO_PI),e}const upScratch$2=new three.Vector3,rightScratch$2=new three.Vector3;function createHeightFunction(e,t,i,n,r,s){let a=r;const o=Math.max(i,n);if(!a)if(s){const i=e.position,n=t,r=e.up,s=e.right,o=e.frustum,l=scratchCart.subVectors(n,i),c=upScratch$2.copy(r).multiplyScalar(r.dot(l)).length(),h=rightScratch$2.copy(s).multiplyScalar(s.dot(l)).length();a=Math.min(.2*getAltitude(o,c,h),1e9)}else{const i=e.position,n=t,r=scratchCart.subVectors(n,i),s=Math.hypot(r.x,r.y);a=.2*s}if(o<a){const e=8,t=1e6,r=-Math.pow((a-i)*t,1/e),s=Math.pow((a-n)*t,1/e);return function(i){const n=i*(s-r)+r;return-Math.pow(n,e)/t+a}}return function(e){return(1-e)*i+e*n}}function createPitchFunction(e,t,i,n){const r=i(.5);if(defined$1(n)&&i(.5)>n){const n=i(0),s=i(1),a=r-n,o=r-s;return function(r){const l=i(r);if(r<.5){const t=(l-n)/a;return(1-t)*e+t*-CesiumMath.PI_OVER_TWO}const c=(l-s)/o;return(1-c)*-CesiumMath.PI_OVER_TWO+c*t}}return function(i){return(1-i)*e+i*t}}function shortestFlight(e,t){const i=e.x-t.x;i<-CesiumMath.PI?e.x+=CesiumMath.TWO_PI:i>CesiumMath.PI&&(t.x+=CesiumMath.TWO_PI)}const scratchStart=new three.Vector3;function createUpdate2D(e,t,i,n,r,s,a,o,l,c){const h=e._ellipsoidCamera,u=scratchStart.copy(h.position),d=adjustAngleForLERP(h.heading,n),p=h.frustum.right-h.frustum.left,m=createHeightFunction(h,i,p,i.z,a);return function(e){const r=e.time/t;h.setView({orientation:{heading:CesiumMath.lerp(d,n,r)}}),Cartesian2.lerp(u,i,r,h.position);const s=m(r),a=h.frustum,o=a.top/a.right,l=(s-(a.right-a.left))/2;a.right+=l,a.left-=l,a.top=a.right*o,a.bottom=-a.top}}function createUpdate3D(e,t,i,n,r,s,a,o,l,c){const h=e._ellipsoidCamera,u=e.mapProjection.ellipsoid,d=scratchStartCart.copy(h.positionCartographic),p=h.pitch,m=adjustAngleForLERP(h.heading,n),f=adjustAngleForLERP(h.roll,s),g=u.cartesianToCartographic(i);d.x=CesiumMath.zeroToTwoPi(d.x),g.x=CesiumMath.zeroToTwoPi(g.x),shortestFlight(d,g);const _=createHeightFunction(h,i,d.z,g.z,a,!0),A=createPitchFunction(p,r,_,c);return function(){const e=d.x,i=g.x,r=d.y,a=g.y;return function(o){const l=o.easingFunction;let c=o.time/t;l&&(c=l(c));const d=Cartesian3.fromRadians(three.MathUtils.lerp(e,i,c),three.MathUtils.lerp(r,a,c),_(c),u);h.setView({destination:d,orientation:{heading:three.MathUtils.lerp(m,n,c),pitch:A(c),roll:three.MathUtils.lerp(f,s,c)}})}}()}function createUpdateCV(e,t,i,n,r,s,a,o,l,c){const h=e._engine,u=h.camera,d=scratchStart.copy(u.position),p=three.MathUtils.degToRad(e.getPitch()),m=adjustAngleForLERP(three.MathUtils.degToRad(e.getHeading()),n),f=createHeightFunction(u,i,d.z,i.z,a,!1),g=createPitchFunction(p,r,f,c);return function(){const r=d.x,s=i.x,a=d.y,o=i.y;return function(i){const l=i.easingFunction;let c=i.time/t;l&&(c=l(c));const u=new three.Vector3(three.MathUtils.lerp(r,s,c),three.MathUtils.lerp(a,o,c),f(c));e.lookAt(h.map.unprojectArrayCoordinate(u.toArray()),{heading:three.MathUtils.radToDeg(three.MathUtils.lerp(m,n,c)),pitch:three.MathUtils.radToDeg(g(c))})}}()}function wrapCallbackColumbus(e){return function(){"function"==typeof e&&e()}}function wrapCallback(e,t){return function(){"function"==typeof t&&t(),e.enableInputs=!0}}function emptyFlight(e,t){return{startObject:{},stopObject:{},duration:0,complete:e,cancel:t}}function Event$1(){}function computeView(e,t,i,n,r){const s=r.elements;return s[0]=n.x,s[1]=i.x,s[2]=-t.x,s[3]=0,s[4]=n.y,s[5]=i.y,s[6]=-t.y,s[7]=0,s[8]=n.z,s[9]=i.z,s[10]=-t.z,s[11]=0,s[12]=-n.dot(e),s[13]=-i.dot(e),s[14]=t.dot(e),s[15]=1,r}function updateViewMatrix(e){computeView(e._position,e._direction,e._up,e._right,e._viewMatrix),e._viewMatrix.multiplyMatrices(e._viewMatrix,e._actualInvTransform),e._invViewMatrix.copy(e._viewMatrix).invert()}CameraFlightPath.createTweenColumbus=function(e,t){let i=(t=t||defaultValue.EMPTY_OBJECT).destination;const n=e.mode;if(n===SceneMode$1.MORPHING)return emptyFlight();const r=t.maximumHeight,s=t.flyOverLongitude,a=t.flyOverLongitudeWeight,o=t.pitchAdjustHeight;let l=t.easingFunction;const c=e._engine.camera;let h=t.duration;h||(h=Math.ceil(Cartesian3.distance(c.position,i)/1e6)+2,h=1e3*Math.min(h,3));const u=defaultValue(t.heading,0),d=defaultValue(t.pitch,0),p=wrapCallbackColumbus(t.complete),m=wrapCallbackColumbus(t.cancel);let f=Cartesian3.equalsEpsilon(i,c.position,CesiumMath.EPSILON10);const g=three.MathUtils.degToRad(e.getHeading()),_=three.MathUtils.degToRad(e.getPitch());if(f=f&&CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(u),CesiumMath.negativePiToPi(g),CesiumMath.EPSILON10)&&CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(d),CesiumMath.negativePiToPi(_),CesiumMath.EPSILON10),f)return emptyFlight(p,m);const A=new Array(4);A[SceneMode$1.SCENE2D]=createUpdate2D,A[SceneMode$1.SCENE3D]=createUpdate3D,A[SceneMode$1.COLUMBUS_VIEW]=createUpdateCV;const v=createUpdateCV(e,h,i,u,d,0,r,s,a,o);if(!defined$1(l)){const e=c.position.z;l=e>(n===i.z)&&e>11500?EasingFunction.CUBIC_OUT:EasingFunction.QUINTIC_IN_OUT}return{duration:h,easingFunction:l,startObject:{time:0},stopObject:{time:h},update:v,complete:p,cancel:m}},CameraFlightPath.createTween=function(e,t){return e.mode===SceneMode$1.SCENE3D?CameraFlightPath.createTween3D(e,t):CameraFlightPath.createTweenColumbus(e,t)},CameraFlightPath.createTween3D=function(e,t){let i=(t=t||defaultValue.EMPTY_OBJECT).destination;const n=e.mode;if(n===SceneMode$1.MORPHING)return emptyFlight();defaultValue(t.convert,!0);const r=e.mapProjection.ellipsoid,s=t.maximumHeight,a=t.flyOverLongitude,o=t.flyOverLongitudeWeight,l=t.pitchAdjustHeight;let c=t.easingFunction;const h=e.camera,u=e._ellipsoidCamera;let d=t.duration;d||(d=Math.ceil(Cartesian3.distance(h.position,i)/1e6)+2,d=1e3*Math.min(d,3));const p=defaultValue(t.heading,0),m=defaultValue(t.pitch,-CesiumMath.PI_OVER_TWO),f=defaultValue(t.roll,0),g=e._controller;g.enableInputs=!1;const _=wrapCallback(g,t.complete),A=wrapCallback(g,t.cancel);u.frustum;let v=n===SceneMode$1.SCENE2D;if(v=v&&Cartesian2.equalsEpsilon(h.position,i,CesiumMath.EPSILON6),v=v||n!==SceneMode$1.SCENE2D&&Cartesian3.equalsEpsilon(i,h.position,CesiumMath.EPSILON10),v=v&&CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(p),CesiumMath.negativePiToPi(u.heading),CesiumMath.EPSILON10)&&CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(m),CesiumMath.negativePiToPi(u.pitch),CesiumMath.EPSILON10)&&CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(f),CesiumMath.negativePiToPi(u.roll),CesiumMath.EPSILON10),v)return emptyFlight(_,A);const y=new Array(4);y[SceneMode$1.SCENE2D]=createUpdate2D,y[SceneMode$1.SCENE3D]=createUpdate3D,y[SceneMode$1.COLUMBUS_VIEW]=createUpdateCV;const x=y[e.mode](e,d,i,p,m,f,s,a,o,l);if(!defined$1(c)){const e=u.positionCartographic.z;c=e>(n===SceneMode$1.SCENE3D?r.cartesianToCartographic(i).z:i.z)&&e>11500?EasingFunction.CUBIC_OUT:EasingFunction.QUINTIC_IN_OUT}return{duration:d,easingFunction:c,startObject:{time:0},stopObject:{time:d},update:x,complete:_,cancel:A}};const scratchCartesian$5=new three.Vector3;function updateMembers(e){let t=e._position;const i=!Cartesian3.equals(t,e.position)||!1;i&&(t=Cartesian3.clone(e.position,e._position));let n=e._direction;const r=!Cartesian3.equals(n,e.direction);r&&(e.direction.normalize(),n=Cartesian3.clone(e.direction,e._direction));let s=e._up;const a=!Cartesian3.equals(s,e.up);a&&(Cartesian3.normalize(e.up,e.up),s=Cartesian3.clone(e.up,e._up));let o=e._right;const l=!Cartesian3.equals(o,e.right);l&&(Cartesian3.normalize(e.right,e.right),o=Cartesian3.clone(e.right,e._right));const c=e._transformChanged;e._transformChanged=!1,c&&(StaticMatrix4.inverseTransformation(e._transform,e._invTransform),StaticMatrix4.clone(e._transform,e._actualTransform),StaticMatrix4.inverseTransformation(e._actualTransform,e._actualInvTransform));const h=e._actualTransform;if((i||c)&&(e._positionWC=StaticMatrix4.multiplyByPoint(h,t,e._positionWC),e._positionCartographic=e._ellipsoid.cartesianToCartographic(e._positionWC,e._positionCartographic)),r||a||l){const t=Cartesian3.dot(n,Cartesian3.cross(s,o,scratchCartesian$5));if(Math.abs(1-t)>.02){const t=1/Cartesian3.magnitudeSquared(s),i=Cartesian3.dot(s,n)*t,r=Cartesian3.multiplyByScalar(n,i,scratchCartesian$5);s=Cartesian3.normalize(Cartesian3.subtract(s,r,e._up),e._up),Cartesian3.clone(s,e.up),o=Cartesian3.cross(n,s,e._right),Cartesian3.clone(o,e.right)}}(r||c)&&(e._directionWC=StaticMatrix4.multiplyByPointAsVector(h,n,e._directionWC),Cartesian3.normalize(e._directionWC,e._directionWC)),(a||c)&&(e._upWC=StaticMatrix4.multiplyByPointAsVector(h,s,e._upWC),Cartesian3.normalize(e._upWC,e._upWC)),(l||c)&&(e._rightWC=StaticMatrix4.multiplyByPointAsVector(h,o,e._rightWC),Cartesian3.normalize(e._rightWC,e._rightWC)),(i||r||a||l||c)&&updateViewMatrix(e)}function getHeading(e,t){let i;return i=CesiumMath.equalsEpsilon(Math.abs(e.z),1,CesiumMath.EPSILON3)?Math.atan2(t.y,t.x)-CesiumMath.PI_OVER_TWO:Math.atan2(e.y,e.x)-CesiumMath.PI_OVER_TWO,CesiumMath.TWO_PI-CesiumMath.zeroToTwoPi(i)}function getPitch(e){return CesiumMath.PI_OVER_TWO-CesiumMath.acosClamped(e.z)}function getRoll(e,t,i){let n=0;return CesiumMath.equalsEpsilon(Math.abs(e.z),1,CesiumMath.EPSILON3)||(n=Math.atan2(-i.z,t.z),n=CesiumMath.zeroToTwoPi(n+CesiumMath.TWO_PI)),n}const scratchHPRMatrix1=new three.Matrix4,scratchHPRMatrix2=new three.Matrix4,setTransformPosition=new three.Vector3,setTransformUp=new three.Vector3,setTransformDirection=new three.Vector3,scratchSetViewCartesian=new three.Vector3,scratchSetViewTransform1=new three.Matrix4,scratchSetViewTransform2=new three.Matrix4,scratchSetViewQuaternion=new three.Quaternion,scratchSetViewMatrix3=new three.Matrix3,scratchSetViewCartographic=new three.Vector3;function setView3D(e,t,i){const n=StaticMatrix4.clone(e.transform,scratchSetViewTransform1),r=Transforms.eastNorthUpToFixedFrame(t,e._ellipsoid,scratchSetViewTransform2);e._setTransform(r),Cartesian3.clone(Cartesian3.ZERO,e.position),i.heading=i.heading-CesiumMath.PI_OVER_TWO;const s=StaticQuaternion.fromHeadingPitchRoll(i,scratchSetViewQuaternion),a=StaticMatrix3.fromQuaternion(s,scratchSetViewMatrix3);StaticMatrix3.getColumn(a,0,e.direction),StaticMatrix3.getColumn(a,2,e.up),Cartesian3.cross(e.direction,e.up,e.right),e._setTransform(n)}function setViewCV(e,t,i,n){const r=StaticMatrix4.clone(e.transform,scratchSetViewTransform1);if(e._setTransform(StaticMatrix4.IDENTITY),!Cartesian3.equals(t,e.positionWC)){if(n){const i=e._projection,n=i.ellipsoid.cartesianToCartographic(t,scratchSetViewCartographic);t=i.project(n,scratchSetViewCartesian)}Cartesian3.clone(t,e.position)}i.heading=i.heading-CesiumMath.PI_OVER_TWO;const s=three.Quaternion.fromHeadingPitchRoll(i,scratchSetViewQuaternion),a=StaticMatrix3.fromQuaternion(s,scratchSetViewMatrix3);StaticMatrix3.getColumn(a,0,e.direction),StaticMatrix3.getColumn(a,2,e.up),Cartesian3.cross(e.direction,e.up,e.right),e._setTransform(r)}function setView2D(e,t,i,n){const r=StaticMatrix4.clone(e.transform,scratchSetViewTransform1);if(e._setTransform(StaticMatrix4.IDENTITY),!Cartesian3.equals(t,e.positionWC)){if(n){const i=e._projection,n=i.ellipsoid.cartesianToCartographic(t,scratchSetViewCartographic);t=i.project(n,scratchSetViewCartesian)}Cartesian2.clone(t,e.position);const i=.5*-t.z,r=-i,s=e.frustum;if(r>i){const e=s.top/s.right;s.right=r,s.left=i,s.top=s.right*e,s.bottom=-s.top}}if(e._scene.mapMode2D===MapMode2D.ROTATE){i.heading=i.heading-CesiumMath.PI_OVER_TWO,i.pitch=-CesiumMath.PI_OVER_TWO,i.roll=0;const t=three.Quaternion.fromHeadingPitchRoll(i,scratchSetViewQuaternion),n=StaticMatrix3.fromQuaternion(t,scratchSetViewMatrix3);StaticMatrix3.getColumn(n,2,e.up),Cartesian3.cross(e.direction,e.up,e.right)}e._setTransform(r)}const scratchLookAtTransform=new three.Matrix4,scratchLookAtMatrix4=new three.Matrix4,scratchLookAtHeadingPitchRangeOffset=new three.Vector3,scratchLookAtHeadingPitchRangeQuaternion1=new three.Quaternion,scratchLookAtHeadingPitchRangeQuaternion2=new three.Quaternion,scratchHeadingPitchRangeMatrix3=new three.Matrix3;function offsetFromHeadingPitchRange(e,t,i){t=CesiumMath.clamp(t,-CesiumMath.PI_OVER_TWO,CesiumMath.PI_OVER_TWO),e=CesiumMath.zeroToTwoPi(e)-CesiumMath.PI_OVER_TWO;const n=StaticQuaternion.fromAxisAngle(Cartesian3.UNIT_Y,-t,scratchLookAtHeadingPitchRangeQuaternion1),r=StaticQuaternion.fromAxisAngle(Cartesian3.UNIT_Z,-e,scratchLookAtHeadingPitchRangeQuaternion2),s=StaticQuaternion.multiply(r,n,r),a=StaticMatrix3.fromQuaternion(s,scratchHeadingPitchRangeMatrix3),o=Cartesian3.clone(Cartesian3.UNIT_X,scratchLookAtHeadingPitchRangeOffset);return StaticMatrix3.multiplyByVector(a,o,o),Cartesian3.negate(o,o),Cartesian3.multiplyByScalar(o,i,o),o}const scratchToHPRDirection=new three.Vector3,scratchToHPRUp=new three.Vector3,scratchToHPRRight=new three.Vector3;function directionUpToHeadingPitchRoll(e,t,i,n){const r=Cartesian3.clone(i.direction,scratchToHPRDirection),s=Cartesian3.clone(i.up,scratchToHPRUp),a=e._ellipsoid,o=Transforms.eastNorthUpToFixedFrame(t,a,scratchHPRMatrix1),l=StaticMatrix4.inverseTransformation(o,scratchHPRMatrix2);StaticMatrix4.multiplyByPointAsVector(l,r,r),StaticMatrix4.multiplyByPointAsVector(l,s,s);const c=Cartesian3.cross(r,s,scratchToHPRRight);return n.heading=getHeading(r,s),n.pitch=getPitch(r),n.roll=getRoll(r,s,c),n}const scratchFlyToDestination=new three.Vector3,newOptions={destination:void 0,heading:void 0,pitch:void 0,roll:void 0,duration:void 0,complete:void 0,cancel:void 0,endTransform:void 0,maximumHeight:void 0,easingFunction:void 0},scratchSetViewOptions={destination:void 0,orientation:{direction:void 0,up:void 0,heading:void 0,pitch:void 0,roll:void 0},convert:void 0,endTransform:void 0},scratchHpr={},moveScratch=new three.Vector3;var pickPerspCenter=new three.Vector3,pickPerspXDir=new three.Vector3,pickPerspYDir=new three.Vector3;function getPickRayPerspective(e,t,i){var n=e._scene.canvas,r=n.clientWidth,s=n.clientHeight,a=Math.tan(.5*three.MathUtils.degToRad(e._camera.fov)),o=e._camera.aspect*a,l=e._camera.near,c=2/r*t.x-1,h=2/s*(s-t.y)-1,u=e.positionWC;Cartesian3.clone(u,i.origin);var d=Cartesian3.multiplyByScalar(e.directionWC,l,pickPerspCenter);Cartesian3.add(u,d,d);var p=Cartesian3.multiplyByScalar(e.rightWC,c*l*o,pickPerspXDir),m=Cartesian3.multiplyByScalar(e.upWC,h*l*a,pickPerspYDir),f=Cartesian3.add(d,p,i.direction);return Cartesian3.add(f,m,f),Cartesian3.subtract(f,u,f),Cartesian3.normalize(f,f),i}function zoom3D$1(e,t){e.move(e.direction,t)}var pickEllipsoid3DRay=new three.Ray;function pickEllipsoid3D(e,t,i,n){i=defaultValue(i,Ellipsoid.WGS84);var r=e.getPickRay(t,pickEllipsoid3DRay),s=IntersectionTests.rayEllipsoid(r,i);if(s){var a=s.start>0?s.start:s.stop;return StaticRay.getPoint(r,a,n)}}var rotateScratchQuaternion=new three.Quaternion,rotateScratchMatrix=new three.Matrix3,lookScratchQuaternion=new three.Quaternion,lookScratchMatrix=new three.Matrix3,rotateVertScratchP=new three.Vector3,rotateVertScratchA=new three.Vector3,rotateVertScratchTan=new three.Vector3,rotateVertScratchNegate=new three.Vector3;function rotateVertical(e,t){var i=e.position;if(defined$1(e.constrainedAxis)&&!Cartesian3.equalsEpsilon(e.position,Cartesian3.ZERO,CesiumMath.EPSILON2)){var n=Cartesian3.normalize(i,rotateVertScratchP),r=Cartesian3.equalsEpsilon(n,e.constrainedAxis,CesiumMath.EPSILON2),s=Cartesian3.equalsEpsilon(n,Cartesian3.negate(e.constrainedAxis,rotateVertScratchNegate),CesiumMath.EPSILON2);if(r||s)(r&&t<0||s&&t>0)&&e.rotate(e.right,t);else{var a=Cartesian3.normalize(e.constrainedAxis,rotateVertScratchA),o=Cartesian3.dot(n,a),l=CesiumMath.acosClamped(o);t>0&&t>l&&(t=l-CesiumMath.EPSILON4),o=Cartesian3.dot(n,Cartesian3.negate(a,rotateVertScratchNegate)),l=CesiumMath.acosClamped(o),t<0&&-t>l&&(t=-l+CesiumMath.EPSILON4);var c=Cartesian3.cross(a,n,rotateVertScratchTan);e.rotate(c,t)}}else e.rotate(e.right,t)}function rotateHorizontal(e,t){defined$1(e.constrainedAxis)?e.rotate(e.constrainedAxis,t):e.rotate(e.up,t)}const _EllipsoidCamera=class{constructor(e){__publicField(this,"_setTransform",(e=>{const t=Cartesian3.clone(this.positionWC,setTransformPosition),i=Cartesian3.clone(this.upWC,setTransformUp),n=Cartesian3.clone(this.directionWC,setTransformDirection);StaticMatrix4.clone(e,this._transform),this._transformChanged=!0,updateMembers(this);const r=this._actualInvTransform;StaticMatrix4.multiplyByPoint(r,t,this.position),StaticMatrix4.multiplyByPointAsVector(r,n,this.direction),StaticMatrix4.multiplyByPointAsVector(r,i,this.up),Cartesian3.cross(this.direction,this.up,this.right),updateMembers(this)})),this._scene=e,this._camera=e.camera,this._ellipsoid=e._ellipsoid,this._transform=new three.Matrix4,this._invTransform=new three.Matrix4,this._actualTransform=new three.Matrix4,this._actualInvTransform=new three.Matrix4,this._transformChanged=!1,this.position=new three.Vector3,this._position=new three.Vector3,this._positionWC=new three.Vector3,this._positionCartographic=new three.Vector3,this._oldPositionWC=void 0,this.positionWCDeltaMagnitude=0,this.positionWCDeltaMagnitudeLastFrame=0,this.timeSinceMoved=0,this._lastMovedTimestamp=0,this.direction=new three.Vector3,this._direction=new three.Vector3,this._directionWC=new three.Vector3,this.up=new three.Vector3,this._up=new three.Vector3,this._upWC=new three.Vector3,this.right=new three.Vector3,this._right=new three.Vector3,this._rightWC=new three.Vector3,this.defaultMoveAmount=1e5,this.defaultLookAmount=Math.PI/60,this.defaultRotateAmount=Math.PI/3600,this.defaultZoomAmount=1e5,this.constrainedAxis=void 0,this.maximumZoomFactor=1.5,this._moveStart=new Event$1,this._moveEnd=new Event$1,this._changed=new Event$1,this._changedPosition=void 0,this._changedDirection=void 0,this._changedFrustum=void 0,this.percentageChanged=.5,this._viewMatrix=new three.Matrix4,this._invViewMatrix=new three.Matrix4,updateViewMatrix(this),this._mode=SceneMode.SCENE3D,this._modeChanged=!0;const t=e.mapProjection;this._projection=t,this._maxCoord=t.project(new three.Vector3(Math.PI,CesiumMath.PI_OVER_TWO,0)),this._max2Dfrustum=void 0,rectangleCameraPosition3D(this,_EllipsoidCamera.DEFAULT_VIEW_RECTANGLE,this.position,!0);let i=Cartesian3.magnitude(this.position);i+=i*_EllipsoidCamera.DEFAULT_VIEW_FACTOR,Cartesian3.normalize(this.position,this.position),Cartesian3.multiplyByScalar(this.position,i,this.position)}canPreloadFlight(){return defined$1(this._currentFlight)}setView(e){e=defaultValue(e,{});let t=defaultValue(e.orientation,defaultValue.EMPTY_OBJECT);const i=this._mode;if(i===SceneMode.MORPHING)return;defined$1(e.endTransform)&&this._setTransform(e.endTransform);let n=defaultValue(e.convert,!0),r=defaultValue(e.destination,Cartesian3.clone(this.positionWC,scratchSetViewCartesian));defined$1(r)&&defined$1(r.west)&&(r=this.getRectangleCameraCoordinates(r,scratchSetViewCartesian),n=!1),defined$1(t.direction)&&(t=directionUpToHeadingPitchRoll(this,r,t,scratchSetViewOptions.orientation)),scratchHpr.heading=defaultValue(t.heading,0),scratchHpr.pitch=defaultValue(t.pitch,-CesiumMath.PI_OVER_TWO),scratchHpr.roll=defaultValue(t.roll,0),i===SceneMode.SCENE3D?setView3D(this,r,scratchHpr):i===SceneMode.SCENE2D?setView2D(this,r,scratchHpr,n):setViewCV(this,r,scratchHpr,n)}lookAt(e,t){if(!defined$1(e))throw new DeveloperError("target is required");if(!defined$1(t))throw new DeveloperError("offset is required");if(this._mode===SceneMode.MORPHING)throw new DeveloperError("lookAt is not supported while morphing.");(t=defaultValue(t,defaultValue.EMPTY_OBJECT)).heading=defaultValue(t.heading,0),t.pitch=defaultValue(t.pitch,-CesiumMath.PI_OVER_TWO),t.range=t.range||.01;const i=StaticMatrix4.clone(this.transform,scratchLookAtTransform);var n=Transforms.eastNorthUpToFixedFrame(e,Ellipsoid.WGS84,scratchLookAtMatrix4);this.lookAtTransform(n,t),this._mode===SceneMode.SCENE3D&&this._setTransform(i)}lookAtTransform(e,t){if(!defined$1(e))throw new DeveloperError("transform is required");if(this._mode===SceneMode.MORPHING)throw new DeveloperError("lookAtTransform is not supported while morphing.");if(this._setTransform(e),!defined$1(t))return;let i;if(i=defined$1(t.heading)?offsetFromHeadingPitchRange(t.heading,t.pitch,t.range):t,this._mode===SceneMode.SCENE2D){Cartesian2.clone(Cartesian2.ZERO,this.position),Cartesian3.negate(i,this.up),this.up.z=0,Cartesian3.magnitudeSquared(this.up)<CesiumMath.EPSILON10&&Cartesian3.clone(Cartesian3.UNIT_Y,this.up),Cartesian3.normalize(this.up,this.up),this._setTransform(StaticMatrix4.IDENTITY),Cartesian3.negate(Cartesian3.UNIT_Z,this.direction),Cartesian3.cross(this.direction,this.up,this.right),Cartesian3.normalize(this.right,this.right);const t=this.frustum,n=t.top/t.right;return t.right=.5*Cartesian3.magnitude(i),t.left=-t.right,t.top=n*t.right,t.bottom=-t.top,void this._setTransform(e)}Cartesian3.clone(i,this.position),Cartesian3.negate(this.position,this.direction),Cartesian3.normalize(this.direction,this.direction),Cartesian3.cross(this.direction,Cartesian3.UNIT_Z,this.right),Cartesian3.magnitudeSquared(this.right)<CesiumMath.EPSILON10&&Cartesian3.clone(Cartesian3.UNIT_X,this.right),Cartesian3.normalize(this.right,this.right),Cartesian3.cross(this.right,this.direction,this.up),Cartesian3.normalize(this.up,this.up)}move(e,t){const i=this.position;Cartesian3.multiplyByScalar(e,t,moveScratch),Cartesian3.add(i,moveScratch,i)}moveForward(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.direction,e)}moveBackward(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.direction,-e)}moveUp(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.up,e)}moveDown(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.up,-e)}moveRight(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.right,e)}moveLeft(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.right,-e)}rotateAroundPoint(e,t,i){const n=new three.Vector3;Cartesian3.subtract(this.position,e,n);const r=defaultValue(i,this.defaultRotateAmount),s=StaticQuaternion.fromAxisAngle(t,-r,rotateScratchQuaternion),a=StaticMatrix3.fromQuaternion(s,rotateScratchMatrix);StaticMatrix3.multiplyByVector(a,n,n),StaticMatrix3.multiplyByVector(a,this.direction,this.direction),StaticMatrix3.multiplyByVector(a,this.up,this.up),StaticMatrix3.multiplyByVector(a,this.right,this.right),Cartesian3.add(n,e,this.position)}zoomIn(e){zoom3D$1(this,e=defaultValue(e,this.defaultZoomAmount))}rotate(e,t){var i=defaultValue(t,this.defaultRotateAmount),n=StaticQuaternion.fromAxisAngle(e,-i,rotateScratchQuaternion),r=StaticMatrix3.fromQuaternion(n,rotateScratchMatrix);StaticMatrix3.multiplyByVector(r,this.position,this.position),StaticMatrix3.multiplyByVector(r,this.direction,this.direction),StaticMatrix3.multiplyByVector(r,this.up,this.up),Cartesian3.cross(this.direction,this.up,this.right),Cartesian3.cross(this.right,this.direction,this.up)}rotateDown(e){rotateVertical(this,e=defaultValue(e,this.defaultRotateAmount))}rotateUp(e){rotateVertical(this,-(e=defaultValue(e,this.defaultRotateAmount)))}rotateRight(e){rotateHorizontal(this,-(e=defaultValue(e,this.defaultRotateAmount)))}rotateLeft(e){rotateHorizontal(this,e=defaultValue(e,this.defaultRotateAmount))}look(e,t){var i=defaultValue(t,this.defaultLookAmount),n=StaticQuaternion.fromAxisAngle(e,-i,lookScratchQuaternion),r=StaticMatrix3.fromQuaternion(n,lookScratchMatrix),s=this.direction,a=this.up,o=this.right;StaticMatrix3.multiplyByVector(r,s,s),StaticMatrix3.multiplyByVector(r,a,a),StaticMatrix3.multiplyByVector(r,o,o)}lookLeft(e){e=defaultValue(e,this.defaultLookAmount),this._mode!==SceneMode.SCENE2D&&this.look(this.up,-e)}lookRight(e){e=defaultValue(e,this.defaultLookAmount),this._mode!==SceneMode.SCENE2D&&this.look(this.up,e)}lookUp(e){e=defaultValue(e,this.defaultLookAmount),this._mode!==SceneMode.SCENE2D&&this.look(this.right,-e)}lookDown(e){e=defaultValue(e,this.defaultLookAmount),this._mode!==SceneMode.SCENE2D&&this.look(this.right,e)}getPickRay(e,t){if(!defined$1(e))throw new DeveloperError("windowPosition is required.");return defined$1(t)||(t=new three.Ray),getPickRayPerspective(this,e,t)}pickEllipsoid(e,t,i){return defined$1(i)||(i=new three.Vector3),i=pickEllipsoid3D(this,e,t=defaultValue(t,Ellipsoid.WGS84),i)}worldToCameraCoordinates(e,t){return defined$1(t)||(t=new three.Vector4(0,0,0,0)),updateMembers(this),StaticMatrix4.multiplyByVector(this._actualInvTransform,e,t)}worldToCameraCoordinatesPoint(e,t){if(!defined$1(e))throw new DeveloperError("cartesian is required.");return defined$1(t)||(t=new three.Vector3),updateMembers(this),StaticMatrix4.multiplyByPoint(this._actualInvTransform,e,t)}cancelFlight(){if(defined$1(this._currentFlight)){const e=this._currentFlight.listener;this._scene._engine.removePrepareRenderListener(e),this._currentFlight=void 0}}completeFlight(){if(defined$1(this._currentFlight)){const e=this._currentFlight.listener;this._scene._engine.removePrepareRenderListener(e);const t={destination:void 0,orientation:{heading:void 0,pitch:void 0,roll:void 0}};t.destination=newOptions.destination,t.orientation.heading=newOptions.heading,t.orientation.pitch=newOptions.pitch,t.orientation.roll=newOptions.roll,this.setView(t),defined$1(this._currentFlight.complete)&&this._currentFlight.complete(),this._currentFlight=void 0}}flyTo(e){let t=(e=defaultValue(e,{})).destination;if(this._mode===SceneMode.MORPHING)return;this.cancelFlight();const i=t instanceof Rectangle;i&&(t=this.getRectangleCameraCoordinates(t,scratchFlyToDestination));let n=defaultValue(e.orientation,defaultValue.EMPTY_OBJECT);if(defined$1(n.direction)&&(n=directionUpToHeadingPitchRoll(this,t,n,scratchSetViewOptions.orientation)),defined$1(e.duration)&&e.duration<=0){const t=scratchSetViewOptions;return t.destination=e.destination,t.orientation.heading=n.heading,t.orientation.pitch=n.pitch,t.orientation.roll=n.roll,t.convert=e.convert,t.endTransform=e.endTransform,this.setView(t),void("function"==typeof e.complete&&e.complete())}const r=this;newOptions.destination=t,newOptions.heading=n.heading,newOptions.pitch=n.pitch,newOptions.roll=n.roll,newOptions.duration=e.duration,newOptions.complete=function(){r._currentFlight=void 0,defined$1(e.complete)&&e.complete()},newOptions.cancel=e.cancel,newOptions.endTransform=e.endTransform,newOptions.convert=!i&&e.convert,newOptions.maximumHeight=e.maximumHeight,newOptions.pitchAdjustHeight=e.pitchAdjustHeight,newOptions.flyOverLongitude=e.flyOverLongitude,newOptions.flyOverLongitudeWeight=e.flyOverLongitudeWeight,newOptions.easingFunction=e.easingFunction;const s=this._scene,a=CameraFlightPath.createTween(s,newOptions);if(0===a.duration)return void("function"==typeof a.complete&&a.complete());const o=s._engine;let l=performance.now();function c(e){const t=performance.now()-l,{duration:i,complete:n,update:r,easingFunction:s}=a;if(t>=i)return r({time:i,easingFunction:s}),o.removePrepareRenderListener(c),void n();r({time:t,easingFunction:s}),o.map.map._syncFromEllipsoidCamera(),o.requestRender()}o.addPrepareRenderListener(c),a.listener=c,this._currentFlight=a}flyHome(e){let t=new three.Vector3,i=this._mode;if(i===SceneMode.MORPHING&&this._scene.completeMorph(),i===SceneMode.SCENE2D)this.flyTo({destination:_EllipsoidCamera.DEFAULT_VIEW_RECTANGLE,duration:e,endTransform:StaticMatrix4.IDENTITY});else if(i===SceneMode.SCENE3D){let t=this.getRectangleCameraCoordinates(_EllipsoidCamera.DEFAULT_VIEW_RECTANGLE),i=Cartesian3.magnitude(t);i+=i*_EllipsoidCamera.DEFAULT_VIEW_FACTOR,Cartesian3.normalize(t,t),Cartesian3.multiplyByScalar(t,i,t),this.flyTo({destination:t,duration:e,endTransform:StaticMatrix4.IDENTITY}),this._scene._engine.requestRender()}else if(i===SceneMode.COLUMBUS_VIEW){let i=this._projection.ellipsoid.maximumRadius,n=new three.Vector3(0,-1,1);n=Cartesian3.multiplyByScalar(Cartesian3.normalize(n,n),5*i,n),this.flyTo({destination:n,duration:e,orientation:{heading:0,pitch:-Math.acos(Cartesian3.normalize(n,t).z),roll:0},endTransform:StaticMatrix4.IDENTITY,convert:!1})}}getRectangleCameraCoordinates(e,t){const i=this._mode;if(defined$1(t)||(t=new three.Vector3),i===SceneMode.SCENE3D)return rectangleCameraPosition3D(this,e,t)}update(){}_adjustOrthographicFrustum(e){}clone(e,t){return defined$1(t)||(t=new _EllipsoidCamera(e._scene)),Cartesian3.clone(e.position,t.position),Cartesian3.clone(e.direction,t.direction),Cartesian3.clone(e.up,t.up),Cartesian3.clone(e.right,t.right),StaticMatrix4.clone(e._transform,t.transform),t._transformChanged=!0,t.frustum=e.frustum.clone(),t}getLocalTransform(){const e=this._ellipsoid,t=StaticMatrix4.clone(this._transform,scratchHPRMatrix1),i=Transforms.eastNorthUpToFixedFrame(this.positionWC,e,scratchHPRMatrix2);this._setTransform(i);const n=new three.Matrix4;return n.set(this.right.x,this.up.x,-this.direction.x,0,this.right.y,this.up.y,-this.direction.y,0,this.right.z,this.up.z,-this.direction.z,0,0,0,0,1),this._setTransform(t),n}get transform(){return this._transform}get inverseTransform(){return updateMembers(this),this._invTransform}get viewMatrix(){return updateMembers(this),this._viewMatrix}get inverseViewMatrix(){return updateMembers(this),this._invViewMatrix}get positionCartographic(){return updateMembers(this),this._positionCartographic}get positionWC(){return updateMembers(this),this._positionWC}get directionWC(){return updateMembers(this),this._directionWC}get upWC(){return updateMembers(this),this._upWC}get rightWC(){return updateMembers(this),this._rightWC}get heading(){const e=this._ellipsoid,t=StaticMatrix4.clone(this._transform,scratchHPRMatrix1),i=Transforms.eastNorthUpToFixedFrame(this.positionWC,e,scratchHPRMatrix2);this._setTransform(i);const n=getHeading(this.direction,this.up);return this._setTransform(t),n}get pitch(){const e=this._ellipsoid,t=StaticMatrix4.clone(this._transform,scratchHPRMatrix1),i=Transforms.eastNorthUpToFixedFrame(this.positionWC,e,scratchHPRMatrix2);this._setTransform(i);const n=getPitch(this.direction);return this._setTransform(t),n}get roll(){const e=this._ellipsoid,t=StaticMatrix4.clone(this._transform,scratchHPRMatrix1),i=Transforms.eastNorthUpToFixedFrame(this.positionWC,e,scratchHPRMatrix2);this._setTransform(i);const n=getRoll(this.direction,this.up,this.right);return this._setTransform(t),n}get moveStart(){return this._moveStart}get moveEnd(){return this._moveEnd}get changed(){return this._changed}};let EllipsoidCamera=_EllipsoidCamera;__publicField(EllipsoidCamera,"DEFAULT_VIEW_RECTANGLE",Rectangle.fromDegrees(73,-5,140,70)),__publicField(EllipsoidCamera,"DEFAULT_VIEW_FACTOR",.5),__publicField(EllipsoidCamera,"DEFAULT_OFFSET",new HeadingPitchRange(0,Math.PI/4,0));const viewRectangle3DCartographic1=new three.Vector3,viewRectangle3DCartographic2=new three.Vector3,viewRectangle3DNorthEast=new three.Vector3,viewRectangle3DSouthWest=new three.Vector3,viewRectangle3DNorthWest=new three.Vector3,viewRectangle3DSouthEast=new three.Vector3,viewRectangle3DNorthCenter=new three.Vector3,viewRectangle3DSouthCenter=new three.Vector3,viewRectangle3DCenter=new three.Vector3,viewRectangle3DEquator=new three.Vector3,defaultRF={direction:new three.Vector3,right:new three.Vector3,up:new three.Vector3};let viewRectangle3DEllipsoidGeodesic;function computeD(e,t,i,n){return Math.abs(Cartesian3.dot(t,i))/n-Cartesian3.dot(e,i)}function rectangleCameraPosition3D(e,t,i,n){const r=e._projection.ellipsoid,s=n?e:defaultRF,a=t.north,o=t.south;let l=t.east;const c=t.west;c>l&&(l+=CesiumMath.TWO_PI);const h=.5*(c+l);let u;if(o<-CesiumMath.PI_OVER_TWO+CesiumMath.RADIANS_PER_DEGREE&&a>CesiumMath.PI_OVER_TWO-CesiumMath.RADIANS_PER_DEGREE)u=0;else{const e=viewRectangle3DCartographic1;e.x=h,e.y=a,e.z=0;const t=viewRectangle3DCartographic2;t.x=h,t.y=o,t.z=0;let i=viewRectangle3DEllipsoidGeodesic;defined$1(i)&&i.ellipsoid===r||(viewRectangle3DEllipsoidGeodesic=i=new EllipsoidGeodesic(void 0,void 0,r)),i.setEndPoints(e,t),u=i.interpolateUsingFraction(.5,viewRectangle3DCartographic1).y}const d=viewRectangle3DCartographic1;d.x=h,d.y=u,d.z=0;const p=r.cartographicToCartesian(d,viewRectangle3DCenter),m=viewRectangle3DCartographic1;m.x=l,m.y=a;const f=r.cartographicToCartesian(m,viewRectangle3DNorthEast);m.x=c;const g=r.cartographicToCartesian(m,viewRectangle3DNorthWest);m.x=h;const _=r.cartographicToCartesian(m,viewRectangle3DNorthCenter);m.y=o;const A=r.cartographicToCartesian(m,viewRectangle3DSouthCenter);m.x=l;const v=r.cartographicToCartesian(m,viewRectangle3DSouthEast);m.x=c;const y=r.cartographicToCartesian(m,viewRectangle3DSouthWest);Cartesian3.subtract(g,p,g),Cartesian3.subtract(v,p,v),Cartesian3.subtract(f,p,f),Cartesian3.subtract(y,p,y),Cartesian3.subtract(_,p,_),Cartesian3.subtract(A,p,A);const x=r.geodeticSurfaceNormal(p,s.direction);Cartesian3.negate(x,x);const b=Cartesian3.cross(x,Cartesian3.UNIT_Z,s.right);Cartesian3.normalize(b,b);const S=Cartesian3.cross(b,x,s.up);let C;const T=Math.tan(.5*three.MathUtils.degToRad(e._camera.fov)),E=e._camera.aspect*T;if(C=Math.max(computeD(x,S,g,T),computeD(x,S,v,T),computeD(x,S,f,T),computeD(x,S,y,T),computeD(x,S,_,T),computeD(x,S,A,T),computeD(x,b,g,E),computeD(x,b,v,E),computeD(x,b,f,E),computeD(x,b,y,E),computeD(x,b,_,E),computeD(x,b,A,E)),o<0&&a>0){const e=viewRectangle3DCartographic1;e.x=c,e.y=0,e.z=0;let t=r.cartographicToCartesian(e,viewRectangle3DEquator);Cartesian3.subtract(t,p,t),C=Math.max(C,computeD(x,S,t,T),computeD(x,b,t,E)),e.x=l,t=r.cartographicToCartesian(e,viewRectangle3DEquator),Cartesian3.subtract(t,p,t),C=Math.max(C,computeD(x,S,t,T),computeD(x,b,t,E))}return Cartesian3.add(p,Cartesian3.multiplyByScalar(x,-C,viewRectangle3DEquator),i)}const _vector3$4=new three.Vector3,_up$3=new three.Vector3(0,0,1);class GradientSkyAtmospherePass extends Pass$1{constructor(){super(),this.uniforms=three.UniformsUtils.clone(SkyAtmosphereGradientShader.uniforms),this.material=new three.ShaderMaterial({defines:{MVT_USE_NORMAL_TEXTURE:!1},uniforms:this.uniforms,vertexShader:CopyShader.vertexShader,fragmentShader:SkyAtmosphereGradientShader.fragmentShader,depthTest:!1,depthWrite:!1,transparent:!0}),this.needsSwap=!0,this.fsQuad=new FullScreenQuad(null),this.needsDepthTexture=!0,this.needsNormalTextureWhenMRT=!0}render(e,t,i){const n=this.sky;if(!n)return;const r=this.rendering,s=r.camera,a=r._engine,o=a.map.isGlobe,l=this.uniforms;l.tDiffuse.value=i.texture,l.tDepth.value=r.main.sceneRendering.depthTexture,l.isGlobe.value=o,l.viewInverseMatrix.value.copy(s.matrixWorld),l.projectionInverseMatrix.value.copy(s.projectionMatrixInverse),l.cameraNear.value=s.near,l.cameraFar.value=s.far,l.color.value.copy(n.color),l.highColor.value.copy(n.highColor),l.cameraPosition.value.copy(s.position);let c=a.map.getViewHeight();c=o?Math.max(c/1e6,2e-4):2e-4,l.viewHeight.value=c,l.resolution=r.uniforms.resolution,l.sunDirection.value.copy(n.localSunDirection);let h=0,u=1;if("earth"===r._engine.map.mapType){let e=r._engine.map._map._ellipsoidCamera;if(!this._sphereCamera){const e=new Ellipsoid(6371e3,6371e3,6371e3);this._sphereCamera=new EllipsoidCamera({_ellipsoid:e,mapProjection:new GeographicProjection(e),camera:s})}const t=this._sphereCamera;t.position.copy(e.position),t.direction.copy(e.direction),t.up.copy(e.up),t.right.copy(e.right),e=t,l.viewInverseMatrix.value.copy(e.getLocalTransform());const i=l.viewInverseMatrix.value.elements;_vector3$4.set(i[8],i[9],i[10]);const n=three.MathUtils.clamp(_vector3$4.dot(_up$3),.1,1),a=1e6*l.viewHeight.value/n,o=three.MathUtils.mapLinear(Math.sqrt(10*l.viewHeight.value),0,1,20,2),c=Math.max(a+100,a*o);h=r.renderState.getDepthByDistance(a),u=r.renderState.getDepthByDistance(c)}l.fogDepthRange.value.set(h,u);const d=e.autoClear,p=e.getRenderTarget();e.autoClear=!1,this.fsQuad.material=this.material,e.setRenderTarget(this.renderToScreen?null:t),e.clear(!0,!1,!1),this.fsQuad.render(e),e.autoClear=d,e.setRenderTarget(p)}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class DefaultSky extends EmptySky{constructor(){super(...arguments),__publicField(this,"isDefaultSky",!0),__publicField(this,"name","DefaultSky"),__publicField(this,"_postPass",null),__publicField(this,"_engine",null),__publicField(this,"_presetWeatherProperties",{clear:{sunLightIntensity:2.5,skyLightIntensity:1.2},partlyCloudy:{sunLightIntensity:2.2,skyLightIntensity:1.2},cloudy:{sunLightIntensity:0,skyLightIntensity:1.5},overcast:{sunLightIntensity:0,skyLightIntensity:1.5},foggy:{sunLightIntensity:0,skyLightIntensity:1.5},rainy:{sunLightIntensity:0,skyLightIntensity:1.5},snowy:{sunLightIntensity:0,skyLightIntensity:1.5},stormy:{sunLightIntensity:0,skyLightIntensity:1.5}})}afterAddToEngine(e){super.afterAddToEngine(e),this._engine=e,this._color=new three.Color(1,1,1,1),this._highColor=new three.Color(.6,.8,1),this.initEnv()}beforeRemoveFromEngine(e){e.rendering.main.postprocessings.remove(this._postPass),super.beforeRemoveFromEngine(e)}initEnv(){const e=this._engine,t=this._postPass=new GradientSkyAtmospherePass;t.renderOrder=50,t.sky=this,e.rendering.main.opaquePostprocessings.add(t)}get highColor(){return this._highColor}set highColor(e){e.isColor&&this._highColor.copy(e)}get color(){return this._color}set color(e){e.isColor&&this._color.copy(e)}get enablePostPass(){return this._postPass.enabled||!1}set enablePostPass(e){this._postPass&&(this._postPass.enabled=e)}dispose(){super.dispose()}}
/*!
  * Proton v1.1.8
  * https://github.com/JackXie60/shader-particle-system
  * Copyright 2022-2025, JackXie60
  * Licensed under the MIT license
  * http://www.opensource.org/licenses/mit-license
  *
  */var f,m,g$2={types:{Boolean:"boolean",STRING:"string",NUMBER:"number",OBJECT:"object"},ensureTypedArg:function(e,t,i){return typeof e===t?e:i},ensureArrayTypedArg:function(e,t,i){if(Array.isArray(e)){for(var n=e.length-1;n>=0;--n)if(typeof e[n]!==t)return i;return e}return this.ensureTypedArg(e,t,i)},ensureInstanceOf:function(e,t,i){return void 0!==e?e:i},ensureArrayInstanceOf:function(e,t,i){if(Array.isArray(e)){for(var n=e.length-1;n>=0;--n)if(void 0!==t&&e[n]instanceof t==0)return i;return e}return this.ensureInstanceOf(e,t,i)},ensureValueOverLifetimeCompliance:function(e,t,i){t=t||3,i=i||3,!1===Array.isArray(e._value)&&(e._value=[e._value]),!1===Array.isArray(e._spread)&&(e._spread=[e._spread]);var n=this.clamp(e._value.length,t,i),r=this.clamp(e._spread.length,t,i),s=Math.max(n,r);e._value.length!==s&&(e._value=this.interpolateArray(e._value,s)),e._spread.length!==s&&(e._spread=this.interpolateArray(e._spread,s))},interpolateArray:function(e,t){for(var i=e.length,n=["function"==typeof e[0].clone?e[0].clone():e[0]],r=(i-1)/(t-1),s=1;s<t-1;++s){var a=s*r,o=Math.floor(a),l=Math.ceil(a),c=a-o;n[s]=this.lerpTypeAgnostic(e[o],e[l],c)}return n.push("function"==typeof e[i-1].clone?e[i-1].clone():e[i-1]),n},clamp:function(e,t,i){return Math.max(t,Math.min(e,i))},zeroToEpsilon:function(e,t){var i=1e-5,n=e;return n=t?Math.random()*i*10:i,e<0&&e>-1e-5&&(n=-n),n},lerpTypeAgnostic:function(e,t,i){var n,r=this.types;return typeof e===r.NUMBER&&typeof t===r.NUMBER?e+(t-e)*i:e instanceof three.Vector2&&t instanceof three.Vector2?((n=e.clone()).x=this.lerp(e.x,t.x,i),n.y=this.lerp(e.y,t.y,i),n):e instanceof three.Vector3&&t instanceof three.Vector3?((n=e.clone()).x=this.lerp(e.x,t.x,i),n.y=this.lerp(e.y,t.y,i),n.z=this.lerp(e.z,t.z,i),n):e instanceof three.Vector4&&t instanceof three.Vector4?((n=e.clone()).x=this.lerp(e.x,t.x,i),n.y=this.lerp(e.y,t.y,i),n.z=this.lerp(e.z,t.z,i),n.w=this.lerp(e.w,t.w,i),n):e instanceof three.Color&&t instanceof three.Color?((n=e.clone()).r=this.lerp(e.r,t.r,i),n.g=this.lerp(e.g,t.g,i),n.b=this.lerp(e.b,t.b,i),n):void console.warn("Invalid argument types, or argument types do not match:",e,t)},lerp:function(e,t,i){return e+(t-e)*i},roundToNearestMultiple:function(e,t){var i;return 0===t||0===(i=Math.abs(e)%t)?e:e<0?-(Math.abs(e)-i):e+t-i},arrayValuesAreEqual:function(e){for(var t=0;t<e.length-1;++t)if(e[t]!==e[t+1])return!1;return!0},randomFloat:function(e,t){return e+t*(Math.random()-.5)},randomVector3:function(e,t,i,n,r){var s=i.x+(Math.random()*n.x-.5*n.x),a=i.y+(Math.random()*n.y-.5*n.y),o=i.z+(Math.random()*n.z-.5*n.z);r&&(s=.5*-r.x+this.roundToNearestMultiple(s,r.x),a=.5*-r.y+this.roundToNearestMultiple(a,r.y),o=.5*-r.z+this.roundToNearestMultiple(o,r.z)),e.typedArray.setVec3Components(t,s,a,o)},randomColor:function(e,t,i,n){var r=i.r+Math.random()*n.x,s=i.g+Math.random()*n.y,a=i.b+Math.random()*n.z;r=this.clamp(r,0,1),s=this.clamp(s,0,1),a=this.clamp(a,0,1),e.typedArray.setVec3Components(t,r,s,a)},randomColorAsHex:(m=new three.Color,function(e,t,i,n){for(var r=i.length,s=[],a=0;a<r;++a){var o=n[a];m.copy(i[a]),m.r+=Math.random()*o.x-.5*o.x,m.g+=Math.random()*o.y-.5*o.y,m.b+=Math.random()*o.z-.5*o.z,m.r=this.clamp(m.r,0,1),m.g=this.clamp(m.g,0,1),m.b=this.clamp(m.b,0,1),s.push(m.getHex())}e.typedArray.setVec4Components(t,s[0],s[1],s[2],s[3])}),randomVector3OnLine:function(e,t,i,n){var r=i.clone();r.lerp(n,Math.random()),e.typedArray.setVec3Components(t,r.x,r.y,r.z)},randomVector3OnSphere:function(e,t,i,n,r,s,a,o){var l=2*Math.random()-1,c=6.2832*Math.random(),h=Math.sqrt(1-l*l),u=this.randomFloat(n,r),d=0,p=0,m=0;a&&(u=Math.round(u/a)*a),d=h*Math.cos(c)*u,p=h*Math.sin(c)*u,m=l*u,d*=s.x,p*=s.y,m*=s.z,d+=i.x,p+=i.y,m+=i.z,e.typedArray.setVec3Components(t,d,p,m)},seededRandom:function(e){var t=1e4*Math.sin(e);return t-(0|t)},randomVector3OnDisc:function(e,t,i,n,r,s,a){var o=6.2832*Math.random(),l=Math.abs(this.randomFloat(n,r)),c=0,h=0,u=0;a&&(l=Math.round(l/a)*a),c=Math.cos(o)*l,h=Math.sin(o)*l,c*=s.x,h*=s.y,c+=i.x,h+=i.y,u+=i.z,e.typedArray.setVec3Components(t,c,h,u)},randomDirectionVector3OnSphere:(f=new three.Vector3,function(e,t,i,n,r,s,a,o){f.copy(s),f.x-=i,f.y-=n,f.z-=r,f.normalize().multiplyScalar(-this.randomFloat(a,o)),e.typedArray.setVec3Components(t,f.x,f.y,f.z)}),randomDirectionVector3OnDisc:(e=new three.Vector3,function(t,i,n,r,s,a,o,l){e.copy(a),e.x-=n,e.y-=r,e.z-=s,e.normalize().multiplyScalar(-this.randomFloat(o,l)),t.typedArray.setVec3Components(i,e.x,e.y,0)}),getPackedRotationAxis:function(){var e=new three.Vector3,t=new three.Vector3,i=new three.Color,n=new three.Vector3(1,1,1);return function(r,s){return e.copy(r).normalize(),t.copy(s).normalize(),e.x+=.5*-s.x+Math.random()*s.x,e.y+=.5*-s.y+Math.random()*s.y,e.z+=.5*-s.z+Math.random()*s.z,e.normalize().add(n).multiplyScalar(.5),i.setRGB(e.x,e.y,e.z),i.getHex()}}()},y={distributions:{BOX:1,SPHERE:2,DISC:3,LINE:4},valueOverLifetimeLength:4},v=function(){function e(e,t,i,n){this.componentSize=i||1,this.size=t||1,this.TypedArrayConstructor=e||Float32Array,this.array=new e(t*this.componentSize),this.indexOffset=n||0}var t=e.prototype;return t.setSize=function(e,t){var i=this.array.length;return t||(e*=this.componentSize),e<i?this.shrink(e):e>i?this.grow(e):void console.info("TypedArray is already of size:",e+".","Will not resize.")},t.shrink=function(e){return this.array=this.array.subarray(0,e),this.size=e,this},t.grow=function(e){var t=new this.TypedArrayConstructor(e);return t.set(this.array),this.array=t,this.size=e,this},t.splice=function(e,t){for(var i=e*this.componentSize,n=t*this.componentSize,r=[],s=this.array.length,a=0;a<s;++a)(a<i||a>n)&&r.push(this.array[a]);return this.setFromArray(0,r),this},t.setFromArray=function(e,t){var i=e+t.length;return i>this.array.length?this.grow(i):i<this.array.length&&this.shrink(i),this.array.set(t,this.indexOffset+e),this},t.setVec2=function(e,t){return this.setVec2Components(e,t.x,t.y)},t.setVec2Components=function(e,t,i){var n=this.array,r=this.indexOffset+e*this.componentSize;return n[r]=t,n[r+1]=i,this},t.setVec3=function(e,t){return this.setVec3Components(e,t.x,t.y,t.z)},t.setVec3Components=function(e,t,i,n){var r=this.array,s=this.indexOffset+e*this.componentSize;return r[s]=t,r[s+1]=i,r[s+2]=n,this},t.setVec4=function(e,t){return this.setVec4Components(e,t.x,t.y,t.z,t.w)},t.setVec4Components=function(e,t,i,n,r){var s=this.array,a=this.indexOffset+e*this.componentSize;return s[a]=t,s[a+1]=i,s[a+2]=n,s[a+3]=r,this},t.setMat3=function(e,t){return this.setFromArray(this.indexOffset+e*this.componentSize,t.elements)},t.setMat4=function(e,t){return this.setFromArray(this.indexOffset+e*this.componentSize,t.elements)},t.setColor=function(e,t){return this.setVec3Components(e,t.r,t.g,t.b)},t.setNumber=function(e,t){return this.array[this.indexOffset+e*this.componentSize]=t,this},t.getValueAtIndex=function(e){return this.array[this.indexOffset+e]},t.getComponentValueAtIndex=function(e){return this.array.subarray(this.indexOffset+e*this.componentSize)},e}(),A$2=function(){function e(t,i,n){var r=e.typeSizeMap;this.type="string"==typeof t&&r.hasOwnProperty(t)?t:"f",this.componentSize=r[this.type],this.arrayType=n||Float32Array,this.typedArray=null,this.bufferAttribute=null,this.dynamicBuffer=!!i,this.updateMin=0,this.updateMax=0}var t=e.prototype;return t.setUpdateRange=function(e,t){this.updateMin=Math.min(e*this.componentSize,this.updateMin*this.componentSize),this.updateMax=Math.max(t*this.componentSize,this.updateMax*this.componentSize)},t.flagUpdate=function(){var e=this.bufferAttribute,t=this.updateMin,i=Math.min(this.updateMax-this.updateMin+this.componentSize,this.typedArray.array.length);void 0!==e.updateRanges?e.updateRanges=[{start:t,count:i}]:(e.updateRange||(e.updateRange={offset:0,count:-1}),e.updateRange.offset=t,e.updateRange.count=i),e.needsUpdate=!0},t.resetUpdateRange=function(){this.updateMin=0,this.updateMax=0},t.resetDynamic=function(){this.bufferAttribute.usage=this.dynamicBuffer?three.DynamicDrawUsage:three.StaticDrawUsage},t.splice=function(e,t){this.typedArray.splice(e,t),this.forceUpdateAll()},t.forceUpdateAll=function(){this.bufferAttribute.array=this.typedArray.array,void 0!==this.bufferAttribute.updateRanges?this.bufferAttribute.updateRanges=[{start:0,count:this.bufferAttribute.array.length}]:(this.bufferAttribute.updateRange||(this.bufferAttribute.updateRange={offset:0,count:-1}),this.bufferAttribute.updateRange.offset=0,this.bufferAttribute.updateRange.count=-1),this.bufferAttribute.usage=three.StaticDrawUsage,this.bufferAttribute.needsUpdate=!0},t._ensureTypedArray=function(e){null!==this.typedArray&&this.typedArray.size===e*this.componentSize||(null!==this.typedArray&&this.typedArray.size!==e?this.typedArray.setSize(e):null===this.typedArray&&(this.typedArray=new v(this.arrayType,e,this.componentSize)))},t._createBufferAttribute=function(e){if(this._ensureTypedArray(e),null!==this.bufferAttribute)return this.bufferAttribute.array=this.typedArray.array,this.bufferAttribute.count=this.bufferAttribute.array.length/this.bufferAttribute.itemSize,void(this.bufferAttribute.needsUpdate=!0);this.bufferAttribute=new three.BufferAttribute(this.typedArray.array,this.componentSize),this.bufferAttribute.usage=this.dynamicBuffer?three.DynamicDrawUsage:three.StaticDrawUsage},t.getLength=function(){return null===this.typedArray?0:this.typedArray.array.length},e}(),e;A$2.typeSizeMap={f:1,v2:2,v3:3,v4:4,c:3,m3:9,m4:16};var _={defines:["#define PACKED_COLOR_SIZE 256.0","#define PACKED_COLOR_DIVISOR 255.0"].join("\n"),uniforms:["uniform float deltaTime;","uniform float runTime;","uniform sampler2D tex;","uniform vec4 textureAnimation;","uniform float scale;","uniform mat3 positionRotationMatrix;","uniform vec3 uniformDirection;"].join("\n"),attributes:["attribute vec4 acceleration;","attribute vec3 velocity;","attribute vec4 rotation;","attribute vec3 rotationCenter;","attribute vec4 params;","attribute vec4 size;","attribute vec4 angle;","attribute vec4 color;","attribute vec4 opacity;"].join("\n"),varyings:["varying vec4 vColor;","#ifdef SHOULD_ROTATE_TEXTURE","    varying float vAngle;","#endif","#ifdef SHOULD_CALCULATE_SPRITE","    varying vec4 vSpriteSheet;","#endif"].join("\n"),branchAvoidanceFunctions:["float when_gt(float x, float y) {","    return max(sign(x - y), 0.0);","}","float when_lt(float x, float y) {","    return min( max(1.0 - sign(x - y), 0.0), 1.0 );","}","float when_eq( float x, float y ) {","    return 1.0 - abs( sign( x - y ) );","}","float when_ge(float x, float y) {","  return 1.0 - when_lt(x, y);","}","float when_le(float x, float y) {","  return 1.0 - when_gt(x, y);","}","float and(float a, float b) {","    return a * b;","}","float or(float a, float b) {","    return min(a + b, 1.0);","}"].join("\n"),unpackColor:["vec3 unpackColor( in float hex ) {","   vec3 c = vec3( 0.0 );","   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float b = mod( hex, PACKED_COLOR_SIZE );","   c.r = r / PACKED_COLOR_DIVISOR;","   c.g = g / PACKED_COLOR_DIVISOR;","   c.b = b / PACKED_COLOR_DIVISOR;","   return c;","}"].join("\n"),unpackRotationAxis:["vec3 unpackRotationAxis( in float hex ) {","   vec3 c = vec3( 0.0 );","   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );","   float b = mod( hex, PACKED_COLOR_SIZE );","   c.r = r / PACKED_COLOR_DIVISOR;","   c.g = g / PACKED_COLOR_DIVISOR;","   c.b = b / PACKED_COLOR_DIVISOR;","   c *= vec3( 2.0 );","   c -= vec3( 1.0 );","   return c;","}"].join("\n"),floatOverLifetime:["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {","    highp float value = 0.0;","    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );","    float fIndex = 0.0;","    float shouldApplyValue = 0.0;","    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );","","    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {","       fIndex = float( i );","       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );","       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );","    }","","    return value;","}"].join("\n"),colorOverLifetime:["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {","    vec3 value = vec3( 0.0 );","    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );","    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );","    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );","    return value;","}"].join("\n"),paramFetchingFunctions:["float getAlive() {","   return params.x;","}","float getAge() {","   return params.y;","}","float getMaxAge() {","   return params.z;","}","float getWiggle() {","   return params.w;","}"].join("\n"),forceFetchingFunctions:["vec4 getPosition( in float age ) {","   return modelViewMatrix * vec4( position, 1.0 );","}","vec3 getVelocity( in float age ) {","   #ifdef HAS_UNIFORM_DIRECTION","   vec3 modifiedVel = velocity;","   float magnitude = length(velocity);","   if (magnitude > 0.0) {","       vec3 normalizedDir = -normalize(positionRotationMatrix[2]);","       modifiedVel = normalizedDir * magnitude;","   }","   return modifiedVel * age;","   #else","   return velocity * age;","   #endif","}","vec3 getAcceleration( in float age ) {","   #ifdef HAS_UNIFORM_DIRECTION","   vec3 baseAccel = acceleration.xyz * age;","   float magnitude = length(baseAccel);","   if (magnitude > 0.0) {","       vec3 normalizedDir = -normalize(positionRotationMatrix[2]);","       return normalizedDir * magnitude;","   }","   return baseAccel;","   #else","   return acceleration.xyz * age;","   #endif","}"].join("\n"),rotationFunctions:["#ifdef SHOULD_ROTATE_PARTICLES","   mat4 getRotationMatrix( in vec3 axis, in float angle) {","       axis = normalize(axis);","       float s = sin(angle);","       float c = cos(angle);","       float oc = 1.0 - c;","","       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,","                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,","                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,","                   0.0,                                0.0,                                0.0,                                1.0);","   }","","   vec3 getRotation( in vec3 pos, in float positionInTime ) {","      if( rotation.y == 0.0 ) {","           return pos;","      }","","      vec3 axis = unpackRotationAxis( rotation.x );","      vec3 center = rotationCenter;","      vec3 translated;","      mat4 rotationMatrix;","      float angle = 0.0;","      angle += when_eq( rotation.z, 0.0 ) * rotation.y;","      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );","      translated = rotationCenter - pos;","      rotationMatrix = getRotationMatrix( axis, angle );","      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );","   }","#endif"].join("\n"),rotateTexture:["    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );","","    #ifdef SHOULD_ROTATE_TEXTURE","       float x = gl_PointCoord.x - 0.5;","       float y = 1.0 - gl_PointCoord.y - 0.5;","       float c = cos( -vAngle );","       float s = sin( -vAngle );","       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );","    #endif","","    #ifdef SHOULD_CALCULATE_SPRITE","        float framesX = vSpriteSheet.x;","        float framesY = vSpriteSheet.y;","        float columnNorm = vSpriteSheet.z;","        float rowNorm = vSpriteSheet.w;","        vUv.x = gl_PointCoord.x * framesX + columnNorm;","        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);","    #endif","","    vec4 rotatedTexture = texture2D( tex, vUv );"].join("\n")},x={vertex:[_.defines,_.uniforms,_.attributes,_.varyings,three.ShaderChunk.common,three.ShaderChunk.logdepthbuf_pars_vertex,three.ShaderChunk.fog_pars_fragment,_.branchAvoidanceFunctions,_.unpackColor,_.unpackRotationAxis,_.floatOverLifetime,_.colorOverLifetime,_.paramFetchingFunctions,_.forceFetchingFunctions,_.rotationFunctions,"void main() {","    highp float age = getAge();","    highp float alive = getAlive();","    highp float maxAge = getMaxAge();","    highp float positionInTime = (age / maxAge);","    highp float isAlive = when_gt( alive, 0.0 );","    #ifdef SHOULD_WIGGLE_PARTICLES","        float wiggleAmount = positionInTime * getWiggle();","        float wiggleSin = isAlive * sin( wiggleAmount );","        float wiggleCos = isAlive * cos( wiggleAmount );","    #endif","    vec3 vel = getVelocity( age );","    vec3 accel = getAcceleration( age );","    vec3 force = vec3( 0.0 );","    vec3 pos = vec3( position );","    pos = positionRotationMatrix * pos;","    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;","    force += vel;","    force *= drag;","    force += accel * age;","    pos += force;","    #ifdef SHOULD_WIGGLE_PARTICLES","        pos.x += wiggleSin;","        pos.y += wiggleCos;","        pos.z += wiggleSin;","    #endif","    #ifdef SHOULD_ROTATE_PARTICLES","        pos = getRotation( pos, positionInTime );","    #endif","    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );","    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;","    #ifdef HAS_PERSPECTIVE","        float perspective = scale / length( mvPosition.xyz );","    #else","        float perspective = 1.0;","    #endif","    float pointSizePerspective = pointSize * perspective;","    #ifdef COLORIZE","       vec3 c = isAlive * getColorOverLifetime(","           positionInTime,","           unpackColor( color.x ),","           unpackColor( color.y ),","           unpackColor( color.z ),","           unpackColor( color.w )","       );","    #else","       vec3 c = vec3(1.0);","    #endif","    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );","    vColor = vec4( c, o );","    #ifdef SHOULD_ROTATE_TEXTURE","        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );","    #endif","    #ifdef SHOULD_CALCULATE_SPRITE","        float framesX = textureAnimation.x;","        float framesY = textureAnimation.y;","        float loopCount = textureAnimation.w;","        float totalFrames = textureAnimation.z;","        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );","        float column = floor(mod( frameNumber, framesX ));","        float row = floor( (frameNumber - column) / framesX );","        float columnNorm = column / framesX;","        float rowNorm = row / framesY;","        vSpriteSheet.x = 1.0 / framesX;","        vSpriteSheet.y = 1.0 / framesY;","        vSpriteSheet.z = columnNorm;","        vSpriteSheet.w = rowNorm;","    #endif","    gl_PointSize = pointSizePerspective;","    gl_Position = projectionMatrix * mvPosition;",three.ShaderChunk.logdepthbuf_vertex,"}"].join("\n"),fragment:[_.uniforms,three.ShaderChunk.common,three.ShaderChunk.fog_pars_fragment,three.ShaderChunk.logdepthbuf_pars_fragment,_.varyings,_.branchAvoidanceFunctions,"void main() {","    vec3 outgoingLight = vColor.xyz;","    ","    #ifdef ALPHATEST","       if ( vColor.w < float(ALPHATEST) ) discard;","    #endif",_.rotateTexture,three.ShaderChunk.logdepthbuf_fragment,"    outgoingLight = vColor.xyz * rotatedTexture.xyz;","    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );",three.ShaderChunk.fog_fragment,"}"].join("\n")},O=function(){function e(e){var t=g$2.types,i=y.valueOverLifetimeLength;for(var n in(e=g$2.ensureTypedArg(e,t.OBJECT,{})).position=g$2.ensureTypedArg(e.position,t.OBJECT,{}),e.velocity=g$2.ensureTypedArg(e.velocity,t.OBJECT,{}),e.acceleration=g$2.ensureTypedArg(e.acceleration,t.OBJECT,{}),e.radius=g$2.ensureTypedArg(e.radius,t.OBJECT,{}),e.drag=g$2.ensureTypedArg(e.drag,t.OBJECT,{}),e.rotation=g$2.ensureTypedArg(e.rotation,t.OBJECT,{}),e.color=g$2.ensureTypedArg(e.color,t.OBJECT,{}),e.opacity=g$2.ensureTypedArg(e.opacity,t.OBJECT,{}),e.size=g$2.ensureTypedArg(e.size,t.OBJECT,{}),e.angle=g$2.ensureTypedArg(e.angle,t.OBJECT,{}),e.wiggle=g$2.ensureTypedArg(e.wiggle,t.OBJECT,{}),e.maxAge=g$2.ensureTypedArg(e.maxAge,t.OBJECT,{}),e.onParticleSpawn&&console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."),this.uuid=three.MathUtils.generateUUID(),this.type=g$2.ensureTypedArg(e.type,t.NUMBER,y.distributions.BOX),this.position={_value:g$2.ensureInstanceOf(e.position.value,three.Vector3,new three.Vector3),_spread:g$2.ensureInstanceOf(e.position.spread,three.Vector3,new three.Vector3),_spreadClamp:g$2.ensureInstanceOf(e.position.spreadClamp,three.Vector3,new three.Vector3),_distribution:g$2.ensureTypedArg(e.position.distribution,t.NUMBER,this.type),_randomise:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1),_radius:g$2.ensureTypedArg(e.position.radius,t.NUMBER,10),_radiusScale:g$2.ensureInstanceOf(e.position.radiusScale,three.Vector3,new three.Vector3(1,1,1)),_distributionClamp:g$2.ensureTypedArg(e.position.distributionClamp,t.NUMBER,0)},this.velocity={_value:g$2.ensureInstanceOf(e.velocity.value,three.Vector3,new three.Vector3),_spread:g$2.ensureInstanceOf(e.velocity.spread,three.Vector3,new three.Vector3),_distribution:g$2.ensureTypedArg(e.velocity.distribution,t.NUMBER,this.type),_randomise:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1)},this.acceleration={_value:g$2.ensureInstanceOf(e.acceleration.value,three.Vector3,new three.Vector3),_spread:g$2.ensureInstanceOf(e.acceleration.spread,three.Vector3,new three.Vector3),_distribution:g$2.ensureTypedArg(e.acceleration.distribution,t.NUMBER,this.type),_randomise:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1)},this.drag={_value:g$2.ensureTypedArg(e.drag.value,t.NUMBER,0),_spread:g$2.ensureTypedArg(e.drag.spread,t.NUMBER,0),_randomise:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1)},this.wiggle={_value:g$2.ensureTypedArg(e.wiggle.value,t.NUMBER,0),_spread:g$2.ensureTypedArg(e.wiggle.spread,t.NUMBER,0)},this.rotation={_axis:g$2.ensureInstanceOf(e.rotation.axis,three.Vector3,new three.Vector3(0,1,0)),_axisSpread:g$2.ensureInstanceOf(e.rotation.axisSpread,three.Vector3,new three.Vector3),_angle:g$2.ensureTypedArg(e.rotation.angle,t.NUMBER,0),_angleSpread:g$2.ensureTypedArg(e.rotation.angleSpread,t.NUMBER,0),_static:g$2.ensureTypedArg(e.rotation.static,t.BOOLEAN,!1),_center:g$2.ensureInstanceOf(e.rotation.center,three.Vector3,this.position._value.clone()),_randomise:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1)},this.maxAge={_value:g$2.ensureTypedArg(e.maxAge.value,t.NUMBER,2),_spread:g$2.ensureTypedArg(e.maxAge.spread,t.NUMBER,0)},this.color={_value:g$2.ensureArrayInstanceOf(e.color.value,three.Color,new three.Color),_spread:g$2.ensureArrayInstanceOf(e.color.spread,three.Vector3,new three.Vector3),_randomise:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1)},this.opacity={_value:g$2.ensureArrayTypedArg(e.opacity.value,t.NUMBER,1),_spread:g$2.ensureArrayTypedArg(e.opacity.spread,t.NUMBER,0),_randomise:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1)},this.size={_value:g$2.ensureArrayTypedArg(e.size.value,t.NUMBER,1),_spread:g$2.ensureArrayTypedArg(e.size.spread,t.NUMBER,0),_randomise:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1)},this.angle={_value:g$2.ensureArrayTypedArg(e.angle.value,t.NUMBER,0),_spread:g$2.ensureArrayTypedArg(e.angle.spread,t.NUMBER,0),_randomise:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1)},this.particleCount=g$2.ensureTypedArg(e.particleCount,t.NUMBER,100),this.duration=g$2.ensureTypedArg(e.duration,t.NUMBER,null),this.isStatic=g$2.ensureTypedArg(e.isStatic,t.BOOLEAN,!1),this.activeMultiplier=g$2.ensureTypedArg(e.activeMultiplier,t.NUMBER,1),this.direction=g$2.ensureTypedArg(e.direction,t.NUMBER,1),this.alive=g$2.ensureTypedArg(e.alive,t.BOOLEAN,!0),this.particlesPerSecond=0,this.activationIndex=0,this.attributeOffset=0,this.attributeEnd=0,this.age=0,this.activeParticleCount=0,this.group=null,this.attributes=null,this.paramsArray=null,this.resetFlags={position:g$2.ensureTypedArg(e.position.randomise,t.BOOLEAN,!1)||g$2.ensureTypedArg(e.radius.randomise,t.BOOLEAN,!1),velocity:g$2.ensureTypedArg(e.velocity.randomise,t.BOOLEAN,!1),acceleration:g$2.ensureTypedArg(e.acceleration.randomise,t.BOOLEAN,!1)||g$2.ensureTypedArg(e.drag.randomise,t.BOOLEAN,!1),rotation:g$2.ensureTypedArg(e.rotation.randomise,t.BOOLEAN,!1),rotationCenter:g$2.ensureTypedArg(e.rotation.randomise,t.BOOLEAN,!1),size:g$2.ensureTypedArg(e.size.randomise,t.BOOLEAN,!1),color:g$2.ensureTypedArg(e.color.randomise,t.BOOLEAN,!1),opacity:g$2.ensureTypedArg(e.opacity.randomise,t.BOOLEAN,!1),angle:g$2.ensureTypedArg(e.angle.randomise,t.BOOLEAN,!1)},this.updateFlags={},this.updateCounts={},this.updateMap={maxAge:"params",position:"position",velocity:"velocity",acceleration:"acceleration",drag:"acceleration",wiggle:"params",rotation:"rotation",size:"size",color:"color",opacity:"opacity",angle:"angle"},this.updateMap)this.updateMap.hasOwnProperty(n)&&(this.updateCounts[this.updateMap[n]]=0,this.updateFlags[this.updateMap[n]]=!1,this._createGetterSetters(this[n],n));this.bufferUpdateRanges={},this.attributeKeys=null,this.attributeCount=0,g$2.ensureValueOverLifetimeCompliance(this.color,i,i),g$2.ensureValueOverLifetimeCompliance(this.opacity,i,i),g$2.ensureValueOverLifetimeCompliance(this.size,i,i),g$2.ensureValueOverLifetimeCompliance(this.angle,i,i)}var t=e.prototype;return t._createGetterSetters=function(e,t){var i=this;Object.keys(e).forEach((function(n){var r=n.replace("_","");Object.defineProperty(e,r,{get:function(){return this[n]},set:function(e){var r=i.updateMap[t],s=this[n],a=y.valueOverLifetimeLength;"_rotationCenter"===n?(i.updateFlags.rotationCenter=!0,this.updateCounts.rotationCenter=0):"_randomise"===n?i.resetFlags[r]=e:(i.updateFlags[r]=!0,i.updateCounts[r]=0),i.group._updateDefines(),this[n]=e,Array.isArray(s)&&g$2.ensureValueOverLifetimeCompliance(i[t],a,a)}})}))},t._setBufferUpdateRanges=function(e){this.attributeKeys=e,this.attributeCount=e.length;for(var t=this.attributeCount-1;t>=0;--t)this.bufferUpdateRanges[e[t]]={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY}},t._calculatePPSValue=function(e){var t=this.particleCount;this.duration?this.particlesPerSecond=t/(e<this.duration?e:this.duration):this.particlesPerSecond=t/e},t._setAttributeOffset=function(e){this.attributeOffset=e,this.activationIndex=e,this.activationEnd=e+this.particleCount},t._assignValue=function(e,t){switch(e){case"position":this._assignPositionValue(t);break;case"velocity":case"acceleration":this._assignForceValue(t,e);break;case"size":case"opacity":this._assignAbsLifetimeValue(t,e);break;case"angle":this._assignAngleValue(t);break;case"params":this._assignParamsValue(t);break;case"rotation":this._assignRotationValue(t);break;case"color":this._assignColorValue(t)}},t._assignPositionValue=function(e){var t=y.distributions,i=this.position,n=this.attributes.position,r=i._value,s=i._spread;switch(i.distribution){case t.BOX:g$2.randomVector3(n,e,r,s,i._spreadClamp);break;case t.SPHERE:g$2.randomVector3OnSphere(n,e,r,i._radius,i._spread.x,i._radiusScale,i._spreadClamp.x,i._distributionClamp||this.particleCount);break;case t.DISC:g$2.randomVector3OnDisc(n,e,r,i._radius,i._spread.x,i._radiusScale,i._spreadClamp.x);break;case t.LINE:g$2.randomVector3OnLine(n,e,r,s)}},t._assignForceValue=function(e,t){var i,n,r,s,a,o=y.distributions,l=this[t],c=l._value,h=l._spread;switch(l._distribution){case o.BOX:g$2.randomVector3(this.attributes[t],e,c,h);break;case o.SPHERE:n=(i=this.attributes.position.typedArray.array)[a=3*e],r=i[a+1],s=i[a+2],g$2.randomDirectionVector3OnSphere(this.attributes[t],e,n,r,s,this.position._value,l._value.x,l._spread.x);break;case o.DISC:n=(i=this.attributes.position.typedArray.array)[a=3*e],r=i[a+1],s=i[a+2],g$2.randomDirectionVector3OnDisc(this.attributes[t],e,n,r,s,this.position._value,l._value.x,l._spread.x);break;case o.LINE:g$2.randomVector3OnLine(this.attributes[t],e,c,h)}if("acceleration"===t){var u=g$2.clamp(g$2.randomFloat(this.drag._value,this.drag._spread),0,1);this.attributes.acceleration.typedArray.array[4*e+3]=u}},t._assignAbsLifetimeValue=function(e,t){var i,n=this.attributes[t].typedArray,r=this[t];g$2.arrayValuesAreEqual(r._value)&&g$2.arrayValuesAreEqual(r._spread)?(i=Math.abs(g$2.randomFloat(r._value[0],r._spread[0])),n.setVec4Components(e,i,i,i,i)):n.setVec4Components(e,Math.abs(g$2.randomFloat(r._value[0],r._spread[0])),Math.abs(g$2.randomFloat(r._value[1],r._spread[1])),Math.abs(g$2.randomFloat(r._value[2],r._spread[2])),Math.abs(g$2.randomFloat(r._value[3],r._spread[3])))},t._assignAngleValue=function(e){var t,i=this.attributes.angle.typedArray,n=this.angle;g$2.arrayValuesAreEqual(n._value)&&g$2.arrayValuesAreEqual(n._spread)?(t=g$2.randomFloat(n._value[0],n._spread[0]),i.setVec4Components(e,t,t,t,t)):i.setVec4Components(e,g$2.randomFloat(n._value[0],n._spread[0]),g$2.randomFloat(n._value[1],n._spread[1]),g$2.randomFloat(n._value[2],n._spread[2]),g$2.randomFloat(n._value[3],n._spread[3]))},t._assignParamsValue=function(e){this.attributes.params.typedArray.setVec4Components(e,this.isStatic?1:0,0,Math.abs(g$2.randomFloat(this.maxAge._value,this.maxAge._spread)),g$2.randomFloat(this.wiggle._value,this.wiggle._spread))},t._assignRotationValue=function(e){this.attributes.rotation.typedArray.setVec3Components(e,g$2.getPackedRotationAxis(this.rotation._axis,this.rotation._axisSpread),g$2.randomFloat(this.rotation._angle,this.rotation._angleSpread),this.rotation._static?0:1),this.attributes.rotationCenter.typedArray.setVec3(e,this.rotation._center)},t._assignColorValue=function(e){g$2.randomColorAsHex(this.attributes.color,e,this.color._value,this.color._spread)},t._resetParticle=function(e){for(var t,i,n=this.resetFlags,r=this.updateFlags,s=this.updateCounts,a=this.attributeKeys,o=this.attributeCount-1;o>=0;--o)i=r[t=a[o]],!0!==n[t]&&!0!==i||(this._assignValue(t,e),this._updateAttributeUpdateRange(t,e),!0===i&&s[t]===this.particleCount?(r[t]=!1,s[t]=0):!0===i&&++s[t])},t._updateAttributeUpdateRange=function(e,t){var i=this.bufferUpdateRanges[e];i.min=Math.min(t,i.min),i.max=Math.max(t,i.max)},t._resetBufferRanges=function(){for(var e,t=this.bufferUpdateRanges,i=this.bufferUpdateKeys,n=this.bufferUpdateCount-1;n>=0;--n)t[e=i[n]].min=Number.POSITIVE_INFINITY,t[e].max=Number.NEGATIVE_INFINITY},t._onRemove=function(){this.particlesPerSecond=0,this.attributeOffset=0,this.activationIndex=0,this.activeParticleCount=0,this.group=null,this.attributes=null,this.paramsArray=null,this.age=0},t._decrementParticleCount=function(){--this.activeParticleCount},t._incrementParticleCount=function(){++this.activeParticleCount},t._checkParticleAges=function(e,t,i,n){for(var r,s,a,o,l=t-1;l>=e;--l)0!==(o=i[r=4*l])&&(a=i[r+1],s=i[r+2],1===this.direction?(a+=n)>=s&&(a=0,o=0,this._decrementParticleCount()):(a-=n)<=0&&(a=s,o=0,this._decrementParticleCount()),i[r]=o,i[r+1]=a,this._updateAttributeUpdateRange("params",l))},t._activateParticles=function(e,t,i,n){for(var r,s,a=this.direction,o=e;o<t;++o)0!==i[r=4*o]&&1!==this.particleCount||(this._incrementParticleCount(),i[r]=1,this._resetParticle(o),s=n*(o-e),i[r+1]=-1===a?i[r+2]-s:s,this._updateAttributeUpdateRange("params",o))},t.update=function(e){if(!this.isStatic){null===this.paramsArray&&(this.paramsArray=this.attributes.params.typedArray.array);var t=this.attributeOffset,i=t+this.particleCount,n=this.paramsArray,r=this.particlesPerSecond*this.activeMultiplier*e,s=this.activationIndex;if(this._resetBufferRanges(),this._checkParticleAges(t,i,n,e),!1!==this.alive){if(null!==this.duration&&this.age>this.duration)return this.alive=!1,void(this.age=0);var a=1===this.particleCount?s:0|s,o=Math.min(a+r,this.activationEnd),l=o-this.activationIndex|0,c=l>0?e/l:0;this._activateParticles(a,o,n,c),this.activationIndex+=r,this.activationIndex>i&&(this.activationIndex=t),this.age+=e}else this.age=0}},t.reset=function(e){if(this.age=0,this.alive=!1,!0===e){for(var t,i=this.attributeOffset,n=i+this.particleCount,r=this.paramsArray,s=this.attributes.params.bufferAttribute,a=n-1;a>=i;--a)r[t=4*a]=0,r[t+1]=0;void 0!==s.updateRanges?s.updateRanges=[{start:0,count:s.array.length}]:(s.updateRange.offset=0,s.updateRange.count=-1),s.needsUpdate=!0}return this},t.enable=function(){return this.alive=!0,this},t.disable=function(){return this.alive=!1,this},t.remove=function(){return null!==this.group?this.group.removeEmitter(this):console.error("Emitter does not belong to a group, cannot remove."),this},e}(),b=function(){function e(e){var t=g$2.types;(e=g$2.ensureTypedArg(e,t.OBJECT,{})).texture=g$2.ensureTypedArg(e.texture,t.OBJECT,{}),this.uuid=three.MathUtils.generateUUID(),this.fixedTimeStep=g$2.ensureTypedArg(e.fixedTimeStep,t.NUMBER,.0167),this.texture=e.texture.value||null,this.textureFrames=e.texture.frames||new three.Vector2(1,1),this.textureFrameCount=g$2.ensureTypedArg(e.texture.frameCount,t.NUMBER,this.textureFrames.x*this.textureFrames.y),this.textureLoop=g$2.ensureTypedArg(e.texture.loop,t.NUMBER,1),this.textureFrames.max(new three.Vector2(1,1)),this.hasPerspective=g$2.ensureTypedArg(e.hasPerspective,t.BOOLEAN,!0),this.colorize=g$2.ensureTypedArg(e.colorize,t.BOOLEAN,!0),this.maxParticleCount=g$2.ensureTypedArg(e.maxParticleCount,t.NUMBER,null),this.blending=g$2.ensureTypedArg(e.blending,t.NUMBER,three.AdditiveBlending),this.transparent=g$2.ensureTypedArg(e.transparent,t.BOOLEAN,!0),this.alphaTest=parseFloat(g$2.ensureTypedArg(e.alphaTest,t.NUMBER,0)),this.depthWrite=g$2.ensureTypedArg(e.depthWrite,t.BOOLEAN,!1),this.depthTest=g$2.ensureTypedArg(e.depthTest,t.BOOLEAN,!0),this.fog=g$2.ensureTypedArg(e.fog,t.BOOLEAN,!0),this.scale=g$2.ensureTypedArg(e.scale,t.NUMBER,300),this.emitters=[],this.emitterIDs=[],this._pool=[],this._poolCreationSettings=null,this._createNewWhenPoolEmpty=0,this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!1,this.particleCount=0,this.uniforms={tex:{type:"t",value:this.texture},textureAnimation:{type:"v4",value:new three.Vector4(this.textureFrames.x,this.textureFrames.y,this.textureFrameCount,Math.max(Math.abs(this.textureLoop),1))},fogColor:{type:"c",value:this.fog?new three.Color:null},fogNear:{type:"f",value:10},fogFar:{type:"f",value:200},fogDensity:{type:"f",value:.5},deltaTime:{type:"f",value:0},runTime:{type:"f",value:0},scale:{type:"f",value:this.scale},positionRotationMatrix:{type:"m3",value:new three.Matrix3}},this.defines={HAS_PERSPECTIVE:this.hasPerspective,COLORIZE:this.colorize,VALUE_OVER_LIFETIME_LENGTH:y.valueOverLifetimeLength,SHOULD_ROTATE_TEXTURE:!1,SHOULD_ROTATE_PARTICLES:!1,SHOULD_WIGGLE_PARTICLES:!1,SHOULD_CALCULATE_SPRITE:this.textureFrames.x>1||this.textureFrames.y>1,HAS_UNIFORM_DIRECTION:!1},this.attributes={position:new A$2("v3",!0),acceleration:new A$2("v4",!0),velocity:new A$2("v3",!0),rotation:new A$2("v4",!0),rotationCenter:new A$2("v3",!0),params:new A$2("v4",!0),size:new A$2("v4",!0),angle:new A$2("v4",!0),color:new A$2("v4",!0),opacity:new A$2("v4",!0)},this.attributeKeys=Object.keys(this.attributes),this.attributeCount=this.attributeKeys.length,this.material=new three.ShaderMaterial({uniforms:this.uniforms,vertexShader:x.vertex,fragmentShader:x.fragment,blending:this.blending,transparent:this.transparent,alphaTest:this.alphaTest,depthWrite:this.depthWrite,depthTest:this.depthTest,defines:this.defines,fog:this.fog}),this.geometry=new three.BufferGeometry,this.mesh=new three.Points(this.geometry,this.material),null===this.maxParticleCount&&console.warn("Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.")}var t=e.prototype;return t._updateDefines=function(){for(var e,t=this.emitters,i=this.defines,n=t.length-1;n>=0;--n)e=t[n],i.SHOULD_CALCULATE_SPRITE||(i.SHOULD_ROTATE_TEXTURE=i.SHOULD_ROTATE_TEXTURE||!!Math.max(Math.max.apply(null,e.angle.value),Math.max.apply(null,e.angle.spread))),i.SHOULD_ROTATE_PARTICLES=i.SHOULD_ROTATE_PARTICLES||!!Math.max(e.rotation.angle,e.rotation.angleSpread),i.SHOULD_WIGGLE_PARTICLES=i.SHOULD_WIGGLE_PARTICLES||!!Math.max(e.wiggle.value,e.wiggle.spread);this.material.needsUpdate=!0},t._applyAttributesToGeometry=function(){var e,t,i=this.attributes,n=this.geometry,r=n.attributes;Object.keys(i).forEach((function(s){e=i[s],(t=r[s])?t.array=e.typedArray.array:n.setAttribute(s,e.bufferAttribute),e.bufferAttribute.needsUpdate=!0})),this.geometry.setDrawRange(0,this.particleCount)},t.addEmitter=function(e){if(e instanceof O!=0)if(this.emitterIDs.indexOf(e.uuid)>-1)console.error("Emitter already exists in this group. Will not add again.");else{if(null===e.group){var t=this.attributes,i=this.particleCount,n=i+e.particleCount;for(var r in this.particleCount=n,null!==this.maxParticleCount&&this.particleCount>this.maxParticleCount&&console.warn("Group: maxParticleCount exceeded. Requesting",this.particleCount,"particles, can support only",this.maxParticleCount),e._calculatePPSValue(e.maxAge._value+e.maxAge._spread),e._setBufferUpdateRanges(this.attributeKeys),e._setAttributeOffset(i),e.group=this,e.attributes=this.attributes,t)t.hasOwnProperty(r)&&t[r]._createBufferAttribute(null!==this.maxParticleCount?this.maxParticleCount:this.particleCount);for(var s=i;s<n;++s)e._assignPositionValue(s),e._assignForceValue(s,"velocity"),e._assignForceValue(s,"acceleration"),e._assignAbsLifetimeValue(s,"opacity"),e._assignAbsLifetimeValue(s,"size"),e._assignAngleValue(s),e._assignRotationValue(s),e._assignParamsValue(s),e._assignColorValue(s);return this._applyAttributesToGeometry(),this.emitters.push(e),this.emitterIDs.push(e.uuid),this._updateDefines(e),this.material.needsUpdate=!0,this.geometry.needsUpdate=!0,this._attributesNeedRefresh=!0,this}console.error("Emitter already belongs to another group. Will not add to requested group.")}else console.error("`emitter` argument must be instance of Emitter. Was provided with:",e)},t.removeEmitter=function(e){var t=this.emitterIDs.indexOf(e.uuid);if(e instanceof O!=0)if(-1!==t){for(var i=e.attributeOffset,n=i+e.particleCount,r=this.attributes.params.typedArray,s=i;s<n;++s)r.array[4*s]=0,r.array[4*s+1]=0;for(var a in this.emitters.splice(t,1),this.emitterIDs.splice(t,1),this.attributes)this.attributes.hasOwnProperty(a)&&this.attributes[a].splice(i,n);this.particleCount-=e.particleCount,e._onRemove(),this._attributesNeedRefresh=!0}else console.error("Emitter does not exist in this group. Will not remove.");else console.error("`emitter` argument must be instance of Emitter. Was provided with:",e)},t.getFromPool=function(){var e=this._pool,t=this._createNewWhenPoolEmpty;if(e.length)return e.pop();if(t){var i=new O(this._poolCreationSettings);return this.addEmitter(i),i}return null},t.releaseIntoPool=function(e){if(e instanceof O!=0)return e.reset(),this._pool.unshift(e),this;console.error("Argument is not instanceof Emitter:",e)},t.getPool=function(){return this._pool},t.addPool=function(e,t,i){var n;this._poolCreationSettings=t,this._createNewWhenPoolEmpty=!!i;for(var r=0;r<e;++r)n=Array.isArray(t)?new O(t[r]):new O(t),this.addEmitter(n),this.releaseIntoPool(n);return this},t._triggerSingleEmitter=function(e){var t=this.getFromPool(),i=this;if(null!==t)return e instanceof three.Vector3&&(t.position.value.copy(e),t.position.value=t.position.value),t.enable(),setTimeout((function(){t.disable(),i.releaseIntoPool(t)}),1e3*Math.max(t.duration,t.maxAge.value+t.maxAge.spread)),this;console.log("Group pool ran out.")},t.triggerPoolEmitter=function(e,t){if("number"==typeof e&&e>1)for(var i=0;i<e;++i)this._triggerSingleEmitter(t);else this._triggerSingleEmitter(t);return this},t._updateUniforms=function(e){this.uniforms.runTime.value+=e,this.uniforms.deltaTime.value=e},t._resetBufferRanges=function(){for(var e=this.attributeKeys,t=this.attributes,i=this.attributeCount-1;i>=0;--i)t[e[i]].resetUpdateRange()},t._updateBuffers=function(e){for(var t,i,n,r=this.attributeKeys,s=this.attributes,a=e.bufferUpdateRanges,o=this.attributeCount-1;o>=0;--o)i=a[t=r[o]],(n=s[t]).setUpdateRange(i.min,i.max),n.flagUpdate()},t.update=function(e){var t,i=this.emitters,n=i.length,r=e||this.fixedTimeStep,s=this.attributeKeys,a=this.attributes;if(this._updateUniforms(r),this._resetBufferRanges(),0!==n||!1!==this._attributesNeedRefresh||!1!==this._attributesNeedDynamicReset){for(var o,l=0;l<n;++l)(o=i[l]).update(r),this._updateBuffers(o);if(!0===this._attributesNeedDynamicReset){for(t=this.attributeCount-1;t>=0;--t)a[s[t]].resetDynamic();this._attributesNeedDynamicReset=!1}if(!0===this._attributesNeedRefresh){for(t=this.attributeCount-1;t>=0;--t)a[s[t]].forceUpdateAll();this._attributesNeedRefresh=!1,this._attributesNeedDynamicReset=!0}}},t.setPositionRotationMatrix=function(e){return e instanceof three.Matrix3?(this.defines.HAS_UNIFORM_DIRECTION||(this.defines.HAS_UNIFORM_DIRECTION=!0,this._needsUpdate=!0),this.uniforms.positionRotationMatrix.value.copy(e)):console.error("positionRotationMatrix must be a Matrix3 instance"),this},t.getPositionRotationMatrix=function(){return this.uniforms.positionRotationMatrix.value},t.getDirectionFromMatrix=function(){var e=this.uniforms.positionRotationMatrix.value;return new three.Vector3(e.elements[6],e.elements[7],e.elements[8])},t.resetPositionRotationMatrix=function(){return this.uniforms.positionRotationMatrix.value.identity(),this},t.dispose=function(){return this.geometry.dispose(),this.material.dispose(),this},e}();const _rotationMatrix$2=new three.Matrix3;class Snow extends three.Object3D{constructor(e,t,i={}){super(),__publicField(this,"update",(e=>{if(e.map.isGlobe){const t=Transforms.eastNorthUpToFixedFrame(e.camera.position);this._system.setPositionRotationMatrix(_rotationMatrix$2.setFromMatrix4(t))}this._system.update(this._clock.getDelta())})),__publicField(this,"createSnow",(()=>(new three.TextureLoader).load(getAssetUrl("assets/textures/sky/others/snow.png")))),__publicField(this,"createEmitter",(()=>{const e=Math.floor(1e4*this._density),t=new three.Vector3(0,0,-10).multiplyScalar(this._density),i=new three.Vector3(0,0,-10).multiplyScalar(this._density);return new O({maxAge:{value:10},position:{value:new three.Vector3(0,100,150),spread:new three.Vector3(1e3,1e3,500)},acceleration:{value:t,spread:new three.Vector3(3,3,0)},velocity:{value:i,spread:new three.Vector3(5,5,0)},size:{value:10},particleCount:e})})),this._renderer=e,this._camera=t,this._density=Math.max(.1,Math.min(5,defaultValue$1(i.density,1))),this._clock=new three.Clock;const n=Math.floor(5e4),r=this._system=new b({texture:{value:this.createSnow()},maxParticleCount:n}),s=this._emitter=this.createEmitter(t,e);r.addEmitter(s),this.add(r.mesh)}get density(){return this._density}set density(e){this._density=Math.max(.1,Math.min(5,e)),this._emitter&&this._system.removeEmitter(this._emitter),this._emitter=this.createEmitter(),this._system.addEmitter(this._emitter)}dispose(){}}const _rotationMatrix$1=new three.Matrix3;class Rain extends three.Object3D{constructor(e,t,i={}){super(),__publicField(this,"update",(e=>{if(e.map.isGlobe){const t=Transforms.eastNorthUpToFixedFrame(e.camera.position);this._system.setPositionRotationMatrix(_rotationMatrix$1.setFromMatrix4(t))}this._system.update(this._clock.getDelta())})),__publicField(this,"createRain",(()=>(new three.TextureLoader).load(getAssetUrl("assets/textures/sky/others/trace_01.png")))),__publicField(this,"createEmitter",(()=>{const e=Math.floor(2e4*this._density),t=new three.Vector3(0,0,-50).multiplyScalar(this._density),i=new three.Vector3(0,10,-50).multiplyScalar(this._density);return new O({maxAge:{value:10},position:{value:new three.Vector3(0,100,250),spread:new three.Vector3(1e3,1e3,500)},acceleration:{value:t,spread:new three.Vector3(3,3,0)},velocity:{value:i,spread:new three.Vector3(3,3,0)},size:{value:60},particleCount:e})})),this._density=Math.max(.1,Math.min(5,defaultValue$1(i.density,1))),this._clock=new three.Clock;const n=Math.floor(1e5),r=this._system=new b({texture:{value:this.createRain()},maxParticleCount:n}),s=this._emitter=this.createEmitter(t,e);r.addEmitter(s),this.add(r.mesh)}get density(){return this._density}set density(e){this._density=Math.max(.1,Math.min(5,e)),this._emitter&&this._system.removeEmitter(this._emitter),this._emitter=this.createEmitter(),this._system.addEmitter(this._emitter)}dispose(){}}const uniforms$u=three.UniformsUtils.clone({map:{value:null},color:{value:new three.Color(1,1,1)},opacity:{value:1},intensity:{value:1},emissiveStrength:{value:4.5},emissiveCoreBoost:{value:1.2},emissiveRimSoftness:{value:.4},emissiveFlicker:{value:1}}),vertexShader$v="\n    #include <common>\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n\n        // 网格中心（包含平移）\n        vec3 center = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n\n        // 从相机到中心的方向，只保留水平分量（Z 轴为垂直方向）\n        vec3 toCamera = cameraPosition - center;\n        toCamera.z = 0.0;\n        float len = length(toCamera);\n        if (len < 1e-5) {\n            toCamera = vec3(0.0, 1.0, 0.0);\n        }\n        else {\n            toCamera /= len;\n        }\n\n        // 构建保持垂直的朝向基（Z 轴朝上）\n        vec3 up = vec3(0.0, 0.0, 1.0);\n        vec3 right = normalize(cross(up, toCamera));\n        vec3 forward = cross(right, up);\n\n        // 解析缩放信息\n        float scaleX = length(modelMatrix[0].xyz);\n        float scaleY = length(modelMatrix[1].xyz);\n        float scaleZ = length(modelMatrix[2].xyz);\n        vec3 scaledPosition = vec3(position.x * scaleX, position.y * scaleY, position.z * scaleZ);\n\n        vec3 worldPosition = center + right * scaledPosition.x + up * scaledPosition.y + forward * scaledPosition.z;\n        gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition, 1.0);\n    }\n",fragmentShader$x="\n    #include <common>\n    uniform sampler2D map;\n    uniform vec3 color;\n    uniform float opacity;\n    uniform float intensity;\n    uniform float emissiveStrength;\n    uniform float emissiveCoreBoost;\n    uniform float emissiveRimSoftness;\n    uniform float emissiveFlicker;\n    varying vec2 vUv;\n\n    void main() {\n        vec4 tex = texture2D(map, vUv);\n        if (tex.a <= 0.01) {\n            discard;\n        }\n        float luminance = dot(tex.rgb, vec3(0.299, 0.587, 0.114));\n        float coreFactor = pow(max(luminance, 1e-3), emissiveCoreBoost);\n        float rimFactor = smoothstep(0.0, emissiveRimSoftness, tex.a);\n        float hdrFactor = emissiveStrength * emissiveFlicker * intensity;\n\n        vec3 finalColor = tex.rgb * color * coreFactor * hdrFactor;\n        float finalAlpha = min(1.0, tex.a * opacity * rimFactor);\n        gl_FragColor = vec4(finalColor, finalAlpha);\n    }\n";class LightningBillboardMaterial extends three.ShaderMaterial{constructor(e={}){super({uniforms:three.UniformsUtils.clone(uniforms$u),vertexShader:vertexShader$v,fragmentShader:fragmentShader$x,transparent:!0,depthWrite:!1,blending:three.AdditiveBlending}),this.setValues(e)}}class Thunderstorm extends three.Object3D{constructor(e,t,i={}){super(),this._clock=new three.Clock,this._renderer=e,this._camera=t,this._options=i,this._lightningInterval=3,this._lastLightningTime=0,this._flashActive=!1,this._flashElapsed=0,this._flashDuration=.45,this._lightningMesh=null,this._lightningFlickerSeed=Math.random()*Math.PI*2,this._intervalRange=i.intervalRange||[1,3],this._durationRange=i.durationRange||[.35,.65],this.sceneSize=i.sceneSize||500,this._scaleRange=i.scaleRange||[30,40],this._distanceRange=i.distanceRange||[.25*this.sceneSize,.55*this.sceneSize],this._lateralRange=i.lateralRange||.2*this.sceneSize,this._emissiveStrength=i.emissiveStrength||1.3,this._emissiveCoreBoost=i.emissiveCoreBoost||1.05,this._emissiveRimSoftness=i.emissiveRimSoftness||.6,this._emissiveFlickerRange=i.emissiveFlickerRange||[.92,1.08],this._createLightningEffect()}_createRainSystem(){const e=Math.floor(1e4*this._density),t=new b({texture:{value:(new three.TextureLoader).load(getAssetUrl("assets/textures/sky/others/trace_01.png"))},maxParticleCount:e}),i=new three.Vector3(0,0,-80).multiplyScalar(this._density),n=new three.Vector3(0,15,-80).multiplyScalar(this._density),r=new O({maxAge:{value:8},position:{value:new three.Vector3(0,100,250),spread:new three.Vector3(1500,1500,800)},acceleration:{value:i,spread:new three.Vector3(5,5,0)},velocity:{value:n,spread:new three.Vector3(5,5,0)},size:{value:80*this._density},particleCount:e});return t.addEmitter(r),t}_createLightningEffect(){const e=(new three.TextureLoader).load(getAssetUrl("assets/textures/weather/thunder.jpg")),t=new three.PlaneGeometry(1,1);this._lightningMaterial=new LightningBillboardMaterial,this._lightningMaterial.uniforms.map.value=e,this._lightningMaterial.uniforms.opacity.value=0,"number"==typeof this._options.intensity&&(this._lightningMaterial.uniforms.intensity.value=this._options.intensity),this._lightningMaterial.uniforms.emissiveStrength.value=this._emissiveStrength,this._lightningMaterial.uniforms.emissiveCoreBoost.value=this._emissiveCoreBoost,this._lightningMaterial.uniforms.emissiveRimSoftness.value=this._emissiveRimSoftness,this._lightningMaterial.uniforms.emissiveFlicker.value=this._emissiveFlickerRange[0],this._lightningContainer=new three.Object3D,this._lightningMesh=new three.Mesh(t,this._lightningMaterial),this._lightningMesh.visible=!1,this._lightningMesh.renderOrder=10;const i=three.MathUtils.randFloat(...this._scaleRange);this._lightningMesh.scale.set(i,i,1),this._lightningContainer.add(this._lightningMesh),this.add(this._lightningContainer)}_generateLightningPosition(e){var t,i;const n=this.sceneSize;if(this._camera){const e=new three.Vector3;this._camera.getWorldDirection(e),e.z=0,e.lengthSq()<1e-4?e.set(0,1,0):e.normalize();const n=new three.Vector3(-e.y,e.x,0);n.lengthSq()<1e-4?n.set(1,0,0):n.normalize();const r=Number.isFinite(null==(t=this._distanceRange)?void 0:t[0])?this._distanceRange[0]:.25*this.sceneSize,s=Number.isFinite(null==(i=this._distanceRange)?void 0:i[1])?this._distanceRange[1]:.55*this.sceneSize,a=Math.max(10,Math.min(r,s)),o=Math.max(a+10,Math.max(r,s)),l=Number.isFinite(this._lateralRange)?this._lateralRange:.2*this.sceneSize,c=three.MathUtils.randFloat(a,o),h=three.MathUtils.randFloatSpread(l),u=three.MathUtils.randFloat(0,15),d=new three.Vector3;return d.addScaledVector(e,c),d.addScaledVector(n,h),d.z=u,d}return new three.Vector3((Math.random()-.5)*n*.3,three.MathUtils.randFloat(.7*n,1.05*n),30)}update(e){const t=this._clock.getDelta();this._updateLightning(t,e)}_updateLightning(e,t){if(this._lastLightningTime+=e,this._lightningMesh)if(!this._flashActive&&this._lastLightningTime>this._lightningInterval&&this._triggerLightning(t),this._flashActive){this._flashElapsed+=e;const t=this._flashElapsed/this._flashDuration;if(t>=1)this._endLightning();else{const e=1-t,i=Math.sin(40*(this._flashElapsed+this._lightningFlickerSeed)),n=.75+.25*i+.1*Math.random(),r=three.MathUtils.clamp(e*n,0,1);this._lightningMaterial.uniforms.opacity.value=r;const s=this._emissiveFlickerRange[0],a=this._emissiveFlickerRange[1],o=three.MathUtils.clamp(s+(a-s)*r+.02*i,s,a);this._lightningMaterial.uniforms.emissiveFlicker.value=o}}else this._lightningMaterial&&(this._lightningMaterial.uniforms.opacity.value=0,this._lightningMaterial.uniforms.emissiveFlicker.value=this._emissiveFlickerRange[0])}_triggerLightning(e){if(!this._lightningMesh)return;this._flashActive=!0,this._flashElapsed=0,this._flashDuration=three.MathUtils.randFloat(...this._durationRange),this._lightningInterval=three.MathUtils.randFloat(...this._intervalRange),this._lightningFlickerSeed=Math.random()*Math.PI*2,this._lightningMesh.visible=!0;const t=three.MathUtils.randFloat(...this._scaleRange);this._lightningMesh.scale.set(t,t,1),this._lightningMesh.position.copy(this._generateLightningPosition(e)),this._lightningMaterial.uniforms.opacity.value=1,this._lightningMaterial.uniforms.emissiveFlicker.value=this._emissiveFlickerRange[1],this._lastLightningTime=0}_endLightning(){this._flashActive=!1,this._lightningMesh&&(this._lightningMesh.visible=!1,this._lightningMaterial.uniforms.opacity.value=0,this._lightningMaterial.uniforms.emissiveFlicker.value=this._emissiveFlickerRange[0])}get density(){return this._density}set density(e){this._density=Math.max(.1,Math.min(5,e))}dispose(){this._lightningContainer&&this._lightningContainer.children.forEach((e=>{e.geometry&&e.geometry.dispose(),e.material&&(e.material.map&&e.material.map.dispose(),e.material.dispose())}))}}class DynamicWeather extends three.Object3D{constructor(e){super(),__publicField(this,"_engine"),__publicField(this,"_sky"),__publicField(this,"_snow"),__publicField(this,"_rain"),__publicField(this,"_weather","partlyCloudy"),__publicField(this,"_currentConverageTextureType",null),__publicField(this,"_tCoverageIntensity",null),__publicField(this,"_skyGroundColorBlue",new three.Color(1657983)),__publicField(this,"_skyGroundColorGray",new three.Color(11184810)),__publicField(this,"_weatherChangedListeners",[]),__publicField(this,"_sunLightScale",1),__publicField(this,"_skyLightScale",1),__publicField(this,"transitionDuration",1e3),__publicField(this,"_transitionStartTime",0),__publicField(this,"_transitionStartState",{}),__publicField(this,"_transitionEndState",{}),__publicField(this,"_inTransition",!1),__publicField(this,"_modifyCount",0),__publicField(this,"beforeRemoveFromEngine",(e=>{this._sky.sunLightIntensity=1,this._sky.skyLightIntensity=.5,this._sky.cloudIntensity=.2,this._sky.mixGrayFactor=0,this._engine.rendering.fog.density=0,this._engine.rendering.composition.coverageIntensity=0,e.removePrepareRenderListener(this.handleBeforeRender)})),__publicField(this,"handleBeforeRender",(e=>{if(this._snow){const e=this._engine.camera.position;this._snow.position.copy(e),this._snow.update(this._engine)}if(this._rain){const e=this._engine.camera.position;this._rain.position.copy(e),this._rain.update(this._engine)}if(this._thunderstorm){const e=this._engine.camera.position;this._thunderstorm.position.copy(e),this._thunderstorm.update(this._engine)}if(this._inTransition){const t=(Date.now()-this._transitionStartTime)/this.transitionDuration;t>1&&(this._inTransition=!1),this._updateWeatherTransitionState(t),e.requestRender()}})),__publicField(this,"_updateWeatherTransitionState",(e=>{e<0&&(e=0),e>1&&(e=1);const t=this._transitionStartState,i=this._transitionEndState;for(const n of Object.keys(t))this._sky[n]=three.MathUtils.lerp(t[n],i[n],e)})),this._sky=e}get weather(){return this._weather}set weather(e){if(!e||e===this._weather)return;const t=this._weather;this._weather=e,this._changeWeather(t,e);for(const i of this._weatherChangedListeners)i(e)}afterAddToEngine(e){this._engine=e,e.addPrepareRenderListener(this.handleBeforeRender),this._changeWeather(this._weather,this._weather)}getCoverageTexture(e){if(null===this._tCoverageIntensity||e!==this._currentConverageTextureType){this._tCoverageIntensity&&this._tCoverageIntensity.dispose();let t="assets/textures/weather/TexturesCom_Snow_Plain_3x3_512_noise.jpg";"rain"===e&&(t="assets/textures/weather/TexturesCom_Ground_MudWet_512_roughness.jpg"),this._tCoverageIntensity=(new three.TextureLoader).load(getAssetUrl(t),(()=>{this._engine.requestRender()}))}return this._tCoverageIntensity}_changeWeather(e,t){const i=this._engine,n=this._sky,r=n.getPresetWeatherProperties(e),s=n.getPresetWeatherProperties(t),a=[],o=[];for(const h of Object.keys(r))r[h]!==s[h]&&(Number.isFinite(r[h])&&Number.isFinite(s[h])?a.push(h):o.push(h));for(const h of Object.keys(s))void 0===r[h]&&o.push(h);let l="snowy"===t,c=["rainy","stormy","thunderstorm"].includes(t);this._transitionStartState={},this._transitionEndState={};for(const h of a)this._transitionStartState[h]=r[h],this._transitionEndState[h]=s[h];if(l){if(!this._snow){const e=this._snow=new Snow(i.renderer,i.camera);this.add(e)}}else this._snow&&(this.remove(this._snow),this._snow.dispose(),this._snow=null);if(c){if("thunderstorm"===t){if(!this._thunderstorm){const e=this._thunderstorm=new Thunderstorm(i.renderer,i.camera);this.add(e)}}else this._thunderstorm&&(this.remove(this._thunderstorm),this._thunderstorm.dispose(),this._thunderstorm=null);if(!this._rain){const e="stormy"===t?{density:4}:{},n=this._rain=new Rain(i.renderer,i.camera,e);this.add(n),this._rain.density="stormy"===t?4:"rainy"===t?1:2}}else this._rain&&(this.remove(this._rain),this._rain.dispose(),this._rain=null),this._thunderstorm&&(this.remove(this._thunderstorm),this._thunderstorm.dispose(),this._thunderstorm=null);if(0!==a.length||0!==o.length){for(const e of o)this._sky[e]=s[e];this.transitionDuration<=0?this._updateWeatherTransitionState(1):(this._transitionStartTime=Date.now(),this._inTransition=!0,i.requestRender())}}addWeatherChangedListener(e){-1===this._weatherChangedListeners.indexOf(e)&&this._weatherChangedListeners.push(e)}removeWeatherChangedListener(e){const t=this._weatherChangedListeners.indexOf(e);-1!==t&&this._weatherChangedListeners.splice(t,1)}get sunLightIntensity(){return this._transitionEndState.sunLightIntensity}set sunLightIntensity(e){this._modifyCount++,this._transitionEndState.sunLightIntensity=e}get cloudIntensity(){return this._transitionEndState.cloudIntensity}set cloudIntensity(e){this._modifyCount++,this._transitionEndState.cloudIntensity=e}get skyLightIntensity(){return this._transitionEndState.skyLightIntensity}set skyLightIntensity(e){this._modifyCount++,this._transitionEndState.skyLightIntensity=e}get groundColor(){return this._sky.groundColor}set groundColor(e){this._sky.groundColor=e}get mixGrayFactor(){return this._transitionEndState.mixGrayFactor}set mixGrayFactor(e){this._modifyCount++,this._transitionEndState.mixGrayFactor=e}get coverageIntensity(){return this._transitionEndState.coverageIntensity}set coverageIntensity(e){this._modifyCount++,this._transitionEndState.coverageIntensity=e}get tCoverageIntensity(){return this._engine.rendering.composition.tCoverageIntensity}set tCoverageIntensity(e){this._engine.rendering.composition.tCoverageIntensity=e}get tRelectionEnhancement(){return this._engine.rendering.ssr.tEnhancement}set tRelectionEnhancement(e){this._engine.rendering.ssr.tEnhancement=e}set fogDensity(e){this._modifyCount++,this._transitionEndState.fogDensity=e}get fogDensity(){return this._transitionEndState.fogDensity}get skyLightScale(){return this._skyLightScale}set skyLightScale(e){this._skyLightScale=e}get sunLightScale(){return this._sunLightScale}set sunLightScale(e){this._sunLightScale=e}}const jitterOffsets=[[0,-.33333333333333337],[-.5,.33333333333333326],[.5,-.7777777777777778],[-.75,-.11111111111111116],[.25,.5555555555555554],[-.25,-.5555555555555556],[.75,.11111111111111116],[-.875,.7777777777777777],[.125,-.9259259259259259],[-.375,-.2592592592592593],[.625,.40740740740740744],[-.625,-.7037037037037037],[.375,-.03703703703703709],[-.125,.6296296296296293],[.875,-.4814814814814815],[-.9375,.18518518518518512]];class SceneRendering{constructor(e){__publicField(this,"_lastTextureRequirementsKey",-1),__publicField(this,"_inited",!1),__publicField(this,"_useFastEmissiveMethod",!0),__publicField(this,"_jitterOffsets",jitterOffsets),__publicField(this,"_jitterIndex",0),this._rendering=e}beginFrame(){if(!this._inited)return this._init(),void(this._inited=!0);this._rendering.main.requirements.isTextureRequirementsChanged()&&this._onTextureRequirementsChanged()}updateRenderTargetSamples(e){}_onTextureRequirementsChanged(){this.dispose(),this._init()}_init(){}render(){}endFrame(){}dispose(){}isInStableRenderState(){return!0}get useFastEmissiveMethod(){return this._useFastEmissiveMethod}set useFastEmissiveMethod(e){this._useFastEmissiveMethod=e}}const PROJECTION_GEO="EPSG:4326",PROJECTION_WEB_MERCATOR="EPSG:3857",PROJECTION_ECEF="EPSG:4978",PROJECTION_BD_MERCATOR="BD:MERCATOR",PROJECTION_UTM="UTM",PROJECTION_EQUAL_EARTH="EPSG:8857",PROJECTION_SCREEN_PIXEL="SCREEN_PIXEL",GEOMETRY_TYPE_POINT=1,GEOMETRY_TYPE_LINE=2,GEOMETRY_TYPE_POLYGON=3,RENDER_STAGE_PREPARE=0,RENDER_STAGE_SCENE=10,RENDER_STAGE_BLOOM=11,RENDER_STAGE_FEATURES=20,RENDER_STAGE_POSTPROCESSING=30;class DirectSceneRendering extends SceneRendering{constructor(){super(...arguments),__publicField(this,"isDirectSceneRendering",!0)}_init(){this._rendering.main,this._onTextureRequirementsChanged(),this._normalMaterial=new three.MeshNormalMaterial}beginFrame(){if(!this._inited)return this._init(),void(this._inited=!0);this._rendering.main.requirements.isTextureRequirementsChanged()&&this._onTextureRequirementsChanged()}_onTextureRequirementsChanged(){const e=this._rendering,t=e.resolution,i=e.pixelRatio,n=e.main.requirements;n.needsEmissiveTexture?(this._emissiveRenderTarget=new three.WebGLRenderTarget(t.x*i,t.y*i),this._emissiveRenderTarget.name="EmissiveRenderTarget"):this._disposeEmissiveRenderTarget(),n.needsNormalTexture?(this._normalRenderTarget=new three.WebGLRenderTarget(t.x*i,t.y*i),this._normalRenderTarget.name="NormalRenderTarget"):this._disposeNormalRenderTarget()}render(e){const t=this._rendering,i=t.renderState,n=t.stats,r=t.main,s=t.renderer,a=t._renderer.xr.isPresenting?t.xr.camera:t.camera,o=t.scene,l=t.resolution;t.pixelRatio;const c=r.requirements;if(!i.viewChanged&&c.enableRenderingJitter){let[e,t]=this._jitterOffsets[void 0!==this._debugEngineJitterIndex?this._debugEngineJitterIndex:this._jitterIndex];a.setViewOffset(l.x,l.y,e/2,t/2,l.x,l.y),this._jitterIndex=(this._jitterIndex+1)%this._jitterOffsets.length}if(s.extraProgramCacheKey=c.currentShaderKey,this.renderTarget){if(!this._sceneRenderTarget||c.isRenderTargetTypeChanged()){this._sceneRenderTarget&&(this._sceneRenderTarget.dispose(),this._sceneRenderTarget=null);const e=t.resolution,i=t.pixelRatio,n=this._tDepth=new three.DepthTexture;n.generateMipmaps=!1,this._sceneRenderTarget=new three.WebGLRenderTarget(e.x*i,e.y*i,{type:c.getRenderTargetType()}),this._sceneRenderTarget.name="SceneRenderTarget",c.enableStencilBuffer&&(n.format=three.DepthStencilFormat,n.type=three.UnsignedInt248Type,this._sceneRenderTarget.stencilBuffer=!0),this._sceneRenderTarget.depthTexture=n,this._sceneRenderTarget.samples=t.features.antialias.samples}s.setRenderTarget(this._sceneRenderTarget)}else s.getRenderTarget()&&s.getRenderTarget().isXRRenderTarget||s.setRenderTarget(null),this._sceneRenderTarget&&(this._sceneRenderTarget.dispose(),this._sceneRenderTarget=null);n.beginTimeStatsItem("renderScene"),s.render(o,a),n.endTimeStatsItem("renderScene"),this.renderTarget?(this._fsQuad||(this._fsQuad=new FullScreenQuad(new three.ShaderMaterial({name:"DirectSceneRenderingCopy",vertexShader:CopyShader.vertexShader,fragmentShader:CopyShader.fragmentShader,blending:three.NoBlending,depthTest:!1,uniforms:{tDiffuse:{value:this._sceneRenderTarget.texture},opacity:{value:1}}}))),this._fsQuad.material.uniforms.tDiffuse.value=this._sceneRenderTarget.texture,s.setRenderTarget(this.renderTarget),this._fsQuad.render(s)):this._fsQuad&&(this._fsQuad.dispose(),this._fsQuad=null),t.opaquePostprocessings.hide();for(const h of e)h.onAfterColorPass&&h.onAfterColorPass(t.engine);if(c.needsEmissiveTexture){i.stage=RENDER_STAGE_BLOOM,s.extraProgramCacheKey=c.currentShaderKey+",emissive";const e=new Set,t=new Set;let r=null;o.traverseVisible((i=>{if(r=i.material,r){if(this._useFastEmissiveMethod&&!this._isEmissiveMaterial(r))return i.visible=!1,void e.add(i);r.defines||(r.defines={}),r.defines.MVT_MODE_EMISSIVE=!0,t.add(i)}})),this._useFastEmissiveMethod?this._emissiveRenderTarget.depthTexture=this._sceneRenderTarget.depthTexture:this._emissiveRenderTarget.depthTexture&&(this._emissiveRenderTarget.depthTexture=null),n.beginTimeStatsItem("renderEmissiveTexture"),s.setRenderTarget(this._emissiveRenderTarget);const l=s.autoClear;this._useFastEmissiveMethod&&(s.autoClear=!1,s.clear(!0,!1,!0));const h=o.background;o.background=null;const u=s.shadowMap.enabled;s.shadowMap.enabled=!1,s.render(o,a),o.background=h,s.autoClear=l,s.shadowMap.enabled=u,n.endTimeStatsItem("renderEmissiveTexture");for(const i of t)i.material.defines.MVT_MODE_EMISSIVE=!1;if(this._useFastEmissiveMethod)for(const i of e)i.visible=!0;s.extraProgramCacheKey="",s.setRenderTarget(this.renderTarget)}if(c.needsNormalTexture){s.extraProgramCacheKey=c.currentShaderKey+",normal",s.setRenderTarget(this._normalRenderTarget);const e=s.autoClear;s.autoClear=!1,s.clear();const t=o.background;o.background=null;const i=s.shadowMap.enabled;s.shadowMap.enabled=!1;const n=o.overrideMaterial;o.overrideMaterial=this._normalMaterial,s.render(o,a),s.autoClear=e,s.shadowMap.enabled=i,o.overrideMaterial=n,o.background=t,s.extraProgramCacheKey="",s.setRenderTarget(this.renderTarget)}for(const h of e)h.onAfterMainPass&&h.onAfterMainPass(t.engine);a.setViewOffset(l.x,l.y,0,0,l.x,l.y)}updateRenderTargetSamples(e){const t=this._sceneRenderTarget;t&&(t.samples=e)}_isBlackColor(e){return 0===e.r&&0===e.g&&0===e.b}_isEmissiveMaterial(e){return!e.disableEmissive&&(!(!e.isShaderMaterial&&!e.isRawShaderMaterial)||(e.isMeshBasicMaterial?e.emissive&&!this._isBlackColor(e.emissive):e.isMeshStandardMaterial||e.isMeshPhongMaterial||e.isMeshLambertMaterial||e.isMeshToonMaterial?e.emissive&&!this._isBlackColor(e.emissive)||!!e.emissiveMap:void 0))}_disposeEmissiveRenderTarget(){this._emissiveRenderTarget&&(this._sceneRenderTarget&&this._emissiveRenderTarget.depthTexture===this._sceneRenderTarget.depthTexture&&(this._emissiveRenderTarget.depthTexture=null),this._emissiveRenderTarget.dispose(),this._emissiveRenderTarget=null)}_disposeNormalRenderTarget(){this._normalRenderTarget&&(this._normalRenderTarget.dispose(),this._normalRenderTarget=null)}dispose(){const e=this._rendering.stats;e.removeTimeStatsItem("renderScene"),e.removeTimeStatsItem("renderEmissiveTexture"),this._disposeEmissiveRenderTarget(),this._disposeNormalRenderTarget(),this._fsQuad&&(this._fsQuad.dispose(),this._fsQuad=null)}setSize(e,t){const i=this._rendering;i.resolution;const n=i.pixelRatio;this._emissiveRenderTarget&&this._emissiveRenderTarget.setSize(e*n,t*n),this._normalRenderTarget&&this._normalRenderTarget.setSize(e*n,t*n),this._sceneRenderTarget&&this._sceneRenderTarget.setSize(e*n,t*n)}get emissiveTexture(){return this._emissiveRenderTarget&&this._emissiveRenderTarget.texture}get normalTexture(){return this._normalRenderTarget&&this._normalRenderTarget.texture}get depthTexture(){return this._sceneRenderTarget&&this._sceneRenderTarget.depthTexture}get diffuseTexture(){return this._sceneRenderTarget&&this._sceneRenderTarget.texture}}class MRTSceneRendering extends SceneRendering{constructor(){super(...arguments),__publicField(this,"isMRTSceneRendering",!0)}_init(){const e=this._rendering,t=e.resolution,i=e.main.requirements;let n=1,r={},s="";i.needsEmissiveTexture&&(r.emissive=n,s+=`#define MVT_MRT_OUT_EMISSIVE ${n}\n`,n++),(i.needsNormalTextureWhenMRT||i.needsNormalTexture)&&(r.normal=n,s+=`#define MVT_MRT_OUT_NORMAL ${n}\n`,n++),i.needsMetallicRoughTexture&&(r.metallicRough=n,s+=`#define MVT_MRT_OUT_METALLICROUGH ${n}\n`,n++),this._textureChannelNameMap=r,s+="#include <mvt_mrt_output_pars_fragment>\n",this._fragBeforeMainStart=s,this._fragBeforeMainEnd="#include <mvt_mrt_output_fragment>\n";const a=this._mainMrt=new three.WebGLRenderTarget(t.x*e.pixelRatio,t.y*e.pixelRatio,n,{samples:e.features.antialias.samples}),o=this._tDepth=new three.DepthTexture;o.generateMipmaps=!1,i.enableStencilBuffer&&(o.format=three.DepthStencilFormat,o.type=three.UnsignedInt248Type,a.stencilBuffer=!0),a.depthTexture=o,a.depthBuffer=!0;for(let l=0,c=a.texture.length;l<c;l++)a.texture[l].minFilter=three.NearestFilter,a.texture[l].magFilter=three.NearestFilter,a.texture[l].format=three.RGBAFormat;a.texture.isTexture=!0,this._fsQuad||(this._fsQuad=new FullScreenQuad(new three.ShaderMaterial({name:CopyShader.name,vertexShader:CopyShader.vertexShader,fragmentShader:CopyShader.fragmentShader,uniforms:{tDiffuse:{value:a.texture[0]},opacity:{value:1}}})))}render(){const e=this._rendering,t=e.stats,i=e.renderer,n=e.main.requirements;i.extraProgramCacheKey="mrt-"+n.currentTextureRequirementsKey+n.currentShaderKey,i.setRenderTarget(this._mainMrt),t.beginTimeStatsItem("renderMRTScene"),i.render(e.scene,e.camera),t.endTimeStatsItem("renderMRTScene"),i.extraProgramCacheKey="",i.setRenderTarget(this.renderTarget),this._fsQuad.render(i)}updateRenderTargetSamples(e){this._mainMrt.samples=e}modifyFragmentShader(e){return addExtraCodeToShader(e,this._fragBeforeMainStart,null,this._fragBeforeMainEnd)}dispose(){this._rendering.stats.removeTimeStatsItem("renderMRTScene"),this._tDepth&&(this._tDepth.dispose(),this._tDepth=null),this._mainMrt&&(this._mainMrt.dispose(),this._mainMrt=null),this._fsQuad&&(this._fsQuad.dispose(),this._fsQuad=null)}setSize(e,t){const i=this._rendering,n=this._mainMrt;n&&n.setSize(e*i.pixelRatio,t*i.pixelRatio)}get emissiveTexture(){return this._mainMrt&&this._mainMrt.texture[this._textureChannelNameMap.emissive]}get normalTexture(){return this._mainMrt&&this._mainMrt.texture[this._textureChannelNameMap.normal]}get metallicRoughTexture(){return this._mainMrt&&this._mainMrt.texture[this._textureChannelNameMap.metallicRough]}get depthTexture(){return this._tDepth}get diffuseTexture(){return this._mainMrt&&this._mainMrt.texture[0]}get highPDepthTexture(){return this._mainMrt&&this._mainMrt.texture[this._textureChannelNameMap.depth]}}class RenderingRequirements{constructor(e){__publicField(this,"needsEmissiveTexture",!1),__publicField(this,"needsNormalTexture",!1),__publicField(this,"needsNormalTextureWhenMRT",!1),__publicField(this,"needsDepthTexture",!1),__publicField(this,"needsMetallicRoughTexture",!1),__publicField(this,"enableStencilBuffer",!1),__publicField(this,"enableRenderingJitter",!1),__publicField(this,"needsFloatRenderTarget",!1),__publicField(this,"_lastNeedsFloatRenderTarget",null),__publicField(this,"_lastTextureRequirementsKey",-1),__publicField(this,"_currentTextureRequirementsKey",-1),__publicField(this,"featuresShaderKey",""),this._rendering=e,this._renderingMain=e.main}beginFrame(){this._resetTextureRequirements(),this._updateRequirements(),this._currentTextureRequirementsKey=this._updateTextureRequirementsKey()}_updateRequirements(){const e=this._renderingMain,t=e.features,i=e.postprocessings;this._rendering.useHighPrecisionBuffer&&(this.needsFloatRenderTarget=!0),t.updateReqirements(this),i.updateReqirements(this)}_resetTextureRequirements(){this.needsEmissiveTexture=!1,this.needsNormalTexture=!1,this.needsNormalTextureWhenMRT=!1,this.needsDepthTexture=!1,this.needsMetallicRoughTexture=!1,this.enableStencilBuffer=!0,this.enableRenderingJitter=!1,this.needsFloatRenderTarget=!1}_updateTextureRequirementsKey(){let e=0;return this.needsEmissiveTexture&&(e|=1),this.needsNormalTexture&&(e|=2),this.needsDepthTexture&&(e|=4),this.needsMetallicRoughTexture&&(e|=8),this.enableStencilBuffer&&(e|=16),e}isTextureRequirementsChanged(){return this._lastTextureRequirementsKey!==this._currentTextureRequirementsKey}isRenderTargetTypeChanged(){return this._lastNeedsFloatRenderTarget!==this.needsFloatRenderTarget}getRenderTargetType(){return this.needsFloatRenderTarget?three.HalfFloatType:three.UnsignedByteType}endFrame(){this._lastTextureRequirementsKey=this._currentTextureRequirementsKey,this._lastNeedsFloatRenderTarget=this.needsFloatRenderTarget}get currentTextureRequirementsKey(){return this._currentTextureRequirementsKey}get currentShaderKey(){return this.featuresShaderKey}}class ShaderPass extends Pass$1{constructor(e,t="tDiffuse"){super(),this.textureID=t,this.uniforms=null,this.material=null,e instanceof three.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=three.UniformsUtils.clone(e.uniforms),this.material=new three.ShaderMaterial({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this._fsQuad=new FullScreenQuad(this.material)}render(e,t,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this._fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this._fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this._fsQuad.render(e))}dispose(){this.material.dispose(),this._fsQuad.dispose()}}const OutputShader={name:"OutputShader",uniforms:{tDiffuse:{value:null},toneMappingExposure:{value:1}},vertexShader:"\n\t\tprecision highp float;\n\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\t#include <tonemapping_pars_fragment>\n\t\t#include <colorspace_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\n\t\t\t// tone mapping\n\n\t\t\t#ifdef LINEAR_TONE_MAPPING\n\n\t\t\t\tgl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( REINHARD_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( CINEON_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( ACES_FILMIC_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( AGX_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( NEUTRAL_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( CUSTOM_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );\n\n\t\t\t#endif\n\n\t\t\t// color space\n\n\t\t\t#ifdef SRGB_TRANSFER\n\n\t\t\t\tgl_FragColor = sRGBTransferOETF( gl_FragColor );\n\n\t\t\t#endif\n\n\t\t}"};class OutputPass extends Pass$1{constructor(){super(),this.uniforms=three.UniformsUtils.clone(OutputShader.uniforms),this.material=new three.RawShaderMaterial({name:OutputShader.name,uniforms:this.uniforms,vertexShader:OutputShader.vertexShader,fragmentShader:OutputShader.fragmentShader}),this._fsQuad=new FullScreenQuad(this.material),this._outputColorSpace=null,this._toneMapping=null}render(e,t,i){this.uniforms.tDiffuse.value=i.texture,this.uniforms.toneMappingExposure.value=e.toneMappingExposure,this._outputColorSpace===e.outputColorSpace&&this._toneMapping===e.toneMapping||(this._outputColorSpace=e.outputColorSpace,this._toneMapping=e.toneMapping,this.material.defines={},three.ColorManagement.getTransfer(this._outputColorSpace)===three.SRGBTransfer&&(this.material.defines.SRGB_TRANSFER=""),this._toneMapping===three.LinearToneMapping?this.material.defines.LINEAR_TONE_MAPPING="":this._toneMapping===three.ReinhardToneMapping?this.material.defines.REINHARD_TONE_MAPPING="":this._toneMapping===three.CineonToneMapping?this.material.defines.CINEON_TONE_MAPPING="":this._toneMapping===three.ACESFilmicToneMapping?this.material.defines.ACES_FILMIC_TONE_MAPPING="":this._toneMapping===three.AgXToneMapping?this.material.defines.AGX_TONE_MAPPING="":this._toneMapping===three.NeutralToneMapping?this.material.defines.NEUTRAL_TONE_MAPPING="":this._toneMapping===three.CustomToneMapping&&(this.material.defines.CUSTOM_TONE_MAPPING=""),this.material.needsUpdate=!0),!0===this.renderToScreen?(e.setRenderTarget(null),this._fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this._fsQuad.render(e))}dispose(){this.material.dispose(),this._fsQuad.dispose()}}class UIPass extends Pass$1{constructor(e){super(),this.name="UIPass",this.needsSwap=!1,this.rendering=e,this.camera=e.camera,this._outputColorSpace=null,this._toneMapping=null,this._uiScene=null,this.material=new three.ShaderMaterial(CopyShader),this.material.name="UIPassCopyShader",this.fsQuad=new FullScreenQuad(this.material)}render(e,t,i){const n=this._uiScene=this.rendering.uiScene;n.visible=!0,e.setRenderTarget(i),this._outputColorSpace===e.outputColorSpace&&this._toneMapping===e.toneMapping||(this._outputColorSpace=e.outputColorSpace,this._toneMapping=e.toneMapping,n.traverse((e=>{const t=e.material;t&&(three.ColorManagement.getTransfer(this._outputColorSpace)===three.SRGBTransfer&&(t.uniforms.srgbTransformer={value:!0}),this._toneMapping===three.LinearToneMapping?t.uniforms.isLinearToneMapping={value:!0}:this._toneMapping===three.ReinhardToneMapping?t.uniforms.isReinhardToneMapping={value:!0}:this._toneMapping===three.CineonToneMapping?t.uniforms.isCineonToneMapping={value:!0}:this._toneMapping===three.ACESFilmicToneMapping&&(t.uniforms.isACESFilmicToneMapping={value:!0}))}))),e.autoClear=!1,e.render(n,this.camera),e.autoClear=!0,!0===this.renderToScreen&&(e.setRenderTarget(null),this.material.uniforms.tDiffuse.value=i.texture,this.fsQuad.render(e)),n.visible=!1}dispose(){this.material.dispose(),this.material=null,this.fsQuad.dispose(),this.fsQuad=null}}
/**
   * postprocessing v6.37.8 build Fri Sep 12 2025
   * https://github.com/pmndrs/postprocessing
   * Copyright 2015-2025 Raoul van Rüschen
   * @license Zlib
   */var fullscreenGeometry=(()=>{const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]),i=new three.BufferGeometry;return i.setAttribute("position",new three.BufferAttribute(e,3)),i.setAttribute("uv",new three.BufferAttribute(t,2)),i})(),Pass=class e{static get fullscreenGeometry(){return fullscreenGeometry}constructor(e="Pass",t=new three.Scene,i=new three.Camera){this.name=e,this.renderer=null,this.scene=t,this.camera=i,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(e){if(this.rtt===e){const t=this.fullscreenMaterial;null!==t&&(t.needsUpdate=!0),this.rtt=!e}}set mainScene(e){}set mainCamera(e){}setRenderer(e){this.renderer=e}isEnabled(){return this.enabled}setEnabled(e){this.enabled=e}get fullscreenMaterial(){return null!==this.screen?this.screen.material:null}set fullscreenMaterial(t){let i=this.screen;null!==i?i.material=t:(i=new three.Mesh(e.fullscreenGeometry,t),i.frustumCulled=!1,null===this.scene&&(this.scene=new three.Scene),this.scene.add(i),this.screen=i)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(e){this.fullscreenMaterial=e}getDepthTexture(){return null}setDepthTexture(e,t=three.BasicDepthPacking){}render(e,t,i,n,r){throw new Error("Render method not implemented!")}setSize(e,t){}initialize(e,t,i){}dispose(){for(const t of Object.keys(this)){const i=this[t];(i instanceof three.WebGLRenderTarget||i instanceof three.Material||i instanceof three.Texture||i instanceof e)&&this[t].dispose()}null!==this.fullscreenMaterial&&this.fullscreenMaterial.dispose()}},EffectAttribute={NONE:0,DEPTH:1,CONVOLUTION:2},EffectShaderSection={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},EffectShaderData=class{constructor(){this.shaderParts=new Map([[EffectShaderSection.FRAGMENT_HEAD,null],[EffectShaderSection.FRAGMENT_MAIN_UV,null],[EffectShaderSection.FRAGMENT_MAIN_IMAGE,null],[EffectShaderSection.VERTEX_HEAD,null],[EffectShaderSection.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=EffectAttribute.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=three.LinearSRGBColorSpace}},BlendFunction={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},effect_default="#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}",effect_default2="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",EffectMaterial=class extends three.ShaderMaterial{constructor(e,t,i,n,r=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:three.REVISION.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new three.Uniform(null),depthBuffer:new three.Uniform(null),resolution:new three.Uniform(new three.Vector2),texelSize:new three.Uniform(new three.Vector2),cameraNear:new three.Uniform(.3),cameraFar:new three.Uniform(1e3),aspect:new three.Uniform(1),time:new three.Uniform(0)},blending:three.NoBlending,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:r}),e&&this.setShaderParts(e),t&&this.setDefines(t),i&&this.setUniforms(i),this.copyCameraSettings(n)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=three.BasicDepthPacking){this.depthBuffer=e,this.depthPacking=t}setShaderData(e){this.setShaderParts(e.shaderParts),this.setDefines(e.defines),this.setUniforms(e.uniforms),this.setExtensions(e.extensions)}setShaderParts(e){return this.fragmentShader=effect_default.replace(EffectShaderSection.FRAGMENT_HEAD,e.get(EffectShaderSection.FRAGMENT_HEAD)||"").replace(EffectShaderSection.FRAGMENT_MAIN_UV,e.get(EffectShaderSection.FRAGMENT_MAIN_UV)||"").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE,e.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=effect_default2.replace(EffectShaderSection.VERTEX_HEAD,e.get(EffectShaderSection.VERTEX_HEAD)||"").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT,e.get(EffectShaderSection.VERTEX_MAIN_SUPPORT)||""),this.needsUpdate=!0,this}setDefines(e){for(const t of e.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(e){for(const t of e.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(e){this.extensions={};for(const t of e)this.extensions[t]=!0;return this}get encodeOutput(){return void 0!==this.defines.ENCODE_OUTPUT}set encodeOutput(e){this.encodeOutput!==e&&(e?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(e){return this.encodeOutput}setOutputEncodingEnabled(e){this.encodeOutput=e}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}setDeltaTime(e){this.uniforms.time.value+=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof three.PerspectiveCamera?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(e,t){const i=this.uniforms;i.resolution.value.set(e,t),i.texelSize.value.set(1/e,1/t),i.aspect.value=e/t}static get Section(){return EffectShaderSection}};function prefixSubstrings(e,t,i){for(const n of t){const t="$1"+e+n.charAt(0).toUpperCase()+n.slice(1),r=new RegExp("([^\\.])(\\b"+n+"\\b)","g");for(const e of i.entries())null!==e[1]&&i.set(e[0],e[1].replace(r,t))}}function integrateEffect(e,t,i){let n=t.getFragmentShader(),r=t.getVertexShader();const s=void 0!==n&&/mainImage/.test(n),a=void 0!==n&&/mainUv/.test(n);if(i.attributes|=t.getAttributes(),void 0===n)throw new Error(`Missing fragment shader (${t.name})`);if(a&&0!==(i.attributes&EffectAttribute.CONVOLUTION))throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);if(!s&&!a)throw new Error(`Could not find mainImage or mainUv function (${t.name})`);{const o=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,l=i.shaderParts;let c=l.get(EffectShaderSection.FRAGMENT_HEAD)||"",h=l.get(EffectShaderSection.FRAGMENT_MAIN_UV)||"",u=l.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE)||"",d=l.get(EffectShaderSection.VERTEX_HEAD)||"",p=l.get(EffectShaderSection.VERTEX_MAIN_SUPPORT)||"";const m=new Set,f=new Set;if(a&&(h+=`\t${e}MainUv(UV);\n`,i.uvTransformation=!0),null!==r&&/mainSupport/.test(r)){const t=/mainSupport *\([\w\s]*?uv\s*?\)/.test(r);p+=`\t${e}MainSupport(`,p+=t?"vUv);\n":");\n";for(const e of r.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const t of e[1].split(/\s*,\s*/))i.varyings.add(t),m.add(t),f.add(t);for(const e of r.matchAll(o))f.add(e[1])}for(const e of n.matchAll(o))f.add(e[1]);for(const e of t.defines.keys())f.add(e.replace(/\([\w\s,]*\)/g,""));for(const e of t.uniforms.keys())f.add(e);f.delete("while"),f.delete("for"),f.delete("if"),t.uniforms.forEach(((t,n)=>i.uniforms.set(e+n.charAt(0).toUpperCase()+n.slice(1),t))),t.defines.forEach(((t,n)=>i.defines.set(e+n.charAt(0).toUpperCase()+n.slice(1),t)));const g=new Map([["fragment",n],["vertex",r]]);prefixSubstrings(e,f,i.defines),prefixSubstrings(e,f,g),n=g.get("fragment"),r=g.get("vertex");const _=t.blendMode;if(i.blendModes.set(_.blendFunction,_),s){null!==t.inputColorSpace&&t.inputColorSpace!==i.colorSpace&&(u+=t.inputColorSpace===three.SRGBColorSpace?"color0 = sRGBTransferOETF(color0);\n\t":"color0 = sRGBToLinear(color0);\n\t"),t.outputColorSpace!==three.NoColorSpace?i.colorSpace=t.outputColorSpace:null!==t.inputColorSpace&&(i.colorSpace=t.inputColorSpace);const r=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;u+=`${e}MainImage(color0, UV, `,0!==(i.attributes&EffectAttribute.DEPTH)&&r.test(n)&&(u+="depth, ",i.readDepth=!0),u+="color1);\n\t";const s=e+"BlendOpacity";i.uniforms.set(s,_.opacity),u+=`color0 = blend${_.blendFunction}(color0, color1, ${s});\n\n\t`,c+=`uniform float ${s};\n\n`}if(c+=n+"\n",null!==r&&(d+=r+"\n"),l.set(EffectShaderSection.FRAGMENT_HEAD,c),l.set(EffectShaderSection.FRAGMENT_MAIN_UV,h),l.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE,u),l.set(EffectShaderSection.VERTEX_HEAD,d),l.set(EffectShaderSection.VERTEX_MAIN_SUPPORT,p),null!==t.extensions)for(const e of t.extensions)i.extensions.add(e)}}Number(three.REVISION.replace(/\D+/g,""));var EffectPass=class extends Pass{constructor(e,...t){super("EffectPass"),this.fullscreenMaterial=new EffectMaterial(null,null,null,e),this.listener=e=>this.handleEvent(e),this.effects=[],this.setEffects(t),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(e){for(const t of this.effects)t.mainScene=e}set mainCamera(e){this.fullscreenMaterial.copyCameraSettings(e);for(const t of this.effects)t.mainCamera=e}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(e){this.fullscreenMaterial.encodeOutput=e}get dithering(){return this.fullscreenMaterial.dithering}set dithering(e){const t=this.fullscreenMaterial;t.dithering=e,t.needsUpdate=!0}setEffects(e){for(const t of this.effects)t.removeEventListener("change",this.listener);this.effects=e.sort(((e,t)=>t.attributes-e.attributes));for(const t of this.effects)t.addEventListener("change",this.listener)}updateMaterial(){const e=new EffectShaderData;let t=0;for(const a of this.effects)if(a.blendMode.blendFunction===BlendFunction.DST)e.attributes|=a.getAttributes()&EffectAttribute.DEPTH;else{if(0!==(e.attributes&a.getAttributes()&EffectAttribute.CONVOLUTION))throw new Error(`Convolution effects cannot be merged (${a.name})`);integrateEffect("e"+t++,a,e)}let i=e.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD),n=e.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE),r=e.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);const s=/\bblend\b/g;for(const a of e.blendModes.values())i+=a.getShaderCode().replace(s,`blend${a.blendFunction}`)+"\n";0!==(e.attributes&EffectAttribute.DEPTH)?(e.readDepth&&(n="float depth = readDepth(UV);\n\n\t"+n),this.needsDepthTexture=null===this.getDepthTexture()):this.needsDepthTexture=!1,e.colorSpace===three.SRGBColorSpace&&(n+="color0 = sRGBToLinear(color0);\n\t"),e.uvTransformation?(r="vec2 transformedUv = vUv;\n"+r,e.defines.set("UV","transformedUv")):e.defines.set("UV","vUv"),e.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD,i),e.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE,n),e.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV,r);for(const[a,o]of e.shaderParts)null!==o&&e.shaderParts.set(a,o.trim().replace(/^#/,"\n#"));this.skipRendering=0===t,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(e)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(e,t=three.BasicDepthPacking){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t;for(const i of this.effects)i.setDepthTexture(e,t)}render(e,t,i,n,r){for(const s of this.effects)s.update(e,t,n);if(!this.skipRendering||this.renderToScreen){const r=this.fullscreenMaterial;r.inputBuffer=t.texture,r.time+=n*this.timeScale,e.setRenderTarget(this.renderToScreen?null:i),e.render(this.scene,this.camera)}}setSize(e,t){this.fullscreenMaterial.setSize(e,t);for(const i of this.effects)i.setSize(e,t)}initialize(e,t,i){this.renderer=e;for(const n of this.effects)n.initialize(e,t,i);this.updateMaterial(),void 0!==i&&i!==three.UnsignedByteType&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const e of this.effects)e.removeEventListener("change",this.listener),e.dispose()}handleEvent(e){if("change"===e.type)this.recompile()}};BlendFunction.NORMAL;const _vector2$1=new three.Vector2;class Postprocessings{constructor(e){__publicField(this,"_postprocessings",[]),__publicField(this,"_validCount",0),__publicField(this,"_composer",null),__publicField(this,"_outputPass",null),__publicField(this,"_samples",0),this._rendering=e}setSize(e,t){this._composer&&this._composer.setSize(e,t);const i=this._rendering.engine.renderer.getDrawingBufferSize(_vector2$1);for(const n of this._postprocessings)n.setSize&&(n instanceof EffectPass?n.setSize(i.width,i.height):n.setSize(e,t))}beginFrame(){if(this._outputPass||(this._outputPass=new OutputPass,this._outputPass.renderOrder=200,this.add(this._outputPass)),!this._uiPass){const e=this._uiPass=new UIPass(this._rendering);e.material.transparent=!0,e.renderOrder=3e3,this.add(e)}const e=this._rendering.uiScene.children.length>0;this._uiPass.enabled=e,this._updatePostprocessings()}_updatePostprocessings(){let e=0;for(let t=0,i=this._postprocessings.length;t<i;t++){this._postprocessings[t].enabled&&e++}this._validCount=e}add(e){const t=this._rendering,i=t.engine;if(-1===this._postprocessings.indexOf(e)){if(e.rendering=this._rendering,e instanceof EffectPass){const n=i.renderer.getDrawingBufferSize(_vector2$1),r=i.renderer.getContext().getContextAttributes().alpha,s=t.useHighPrecisionBuffer?three.HalfFloatType:void 0;e.setRenderer(i.renderer),e.setSize(n.width,n.height),e.initialize(i.renderer,r,s)}this._postprocessings.push(e)}this._postprocessings.sort(((e,t)=>(e.renderOrder||0)-(t.renderOrder||0)))}remove(e){const t=this._postprocessings.indexOf(e);-1!==t&&this._postprocessings.splice(t,1)}render(){if(this._validCount<=0)return;const e=this._rendering,t=e.sharedFullScreenRenderTargets,i=e.stats;i.beginTimeStatsItem("postprocessingRender");let n=e.renderer.getRenderTarget(),r=t.getAvailableRenderTarget();const s=e.renderState.deltaTime/1e3;let a=this._validCount-1,o=0;for(let l=0,c=this._postprocessings.length;l<c;l++){const t=this._postprocessings[l];if(t.enabled){if(t.renderToScreen=a===o,t instanceof EffectPass?t.render(e.renderer,n,r,s):t.render(e.renderer,r,n,s),t.needsSwap&&a!==o){let e=n;n=r,r=e}o++}}t.releaseRenderTarget(n),i.endTimeStatsItem("postprocessingRender")}isInStableRenderState(){for(const e of this._postprocessings)if(e.enabled&&!1===e.isStable)return!1;return!0}updateReqirements(e){for(const t of this._postprocessings)t.enabled&&(t.needsEmissiveTexture&&(e.needsEmissiveTexture=!0),t.needsNormalTexture&&(e.needsNormalTexture=!0),t.needsNormalTextureWhenMRT&&(e.needsNormalTextureWhenMRT=!0),t.needsDepthTexture&&(e.needsDepthTexture=!0),t.needsMetallicRoughTexture&&(e.needsMetallicRoughTexture=!0),t.enableStencilBuffer&&(e.enableStencilBuffer=!0),t.enableRenderingJitter&&(e.enableRenderingJitter=!0))}endFrame(){}dispose(){this._postprocessingRenderTarget1&&(this._postprocessingRenderTarget1.dispose(),this._postprocessingRenderTarget1=null)}get renderTarget1(){return this._postprocessingRenderTarget1}get validCount(){return this._validCount}get postprocessings(){return this._postprocessings}}class OpaqueCopyPass extends Pass$1{constructor(e,t){super(),this.enabled=!0,this.needsSwap=!0,this._camera=new three.OrthographicCamera(-1,1,1,-1,0,1),this._scene=new three.Scene,this._material=new three.ShaderMaterial({uniforms:{tDepth:{value:null},tDiffuse:{value:null}},vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);\n                }\n            ",fragmentShader:"\n                varying vec2 vUv;\n                uniform sampler2D tDiffuse;\n                uniform sampler2D tDepth;\n\n                void main() {\n                    vec4 diffuse = texture2D(tDiffuse, vUv);\n                    float depth = texture2D(tDepth, vUv).r;\n                    gl_FragColor = diffuse;\n                    gl_FragDepth = depth;\n                }\n            "}),this._quad=new FullScreenQuad(this._material),this.material=this._material,this.needsDepthTexture=!0,this.outputTarget=this._createRenderTarget(e,t)}_createRenderTarget(e,t){const i=new three.DepthTexture(e,t,three.FloatType);i.format=three.DepthStencilFormat,i.type=three.UnsignedInt248Type;return new three.WebGLRenderTarget(e,t,{minFilter:three.LinearFilter,magFilter:three.LinearFilter,depthTexture:i,depthBuffer:!0,stencilBuffer:!1})}render(e,t,i){this.enabled&&(this._material.uniforms.tDiffuse.value=i.texture,this._material.uniforms.tDepth.value=i.depthTexture,e.setRenderTarget(t),e.clear(),this._quad.render(e),e.setRenderTarget(this.outputTarget),e.clear(),this._quad.render(e))}get texture(){return this.outputTarget.texture}get depthTexture(){return this.outputTarget.depthTexture}setSize(e,t){this.outputTarget.setSize(e,t),this.outputTarget.depthTexture.image.width=e,this.outputTarget.depthTexture.image.height=t}}const vertexShader$u="#define GLSLIFY 1\n// 为了做水体垂直深度，要求法线normal必须是世界空间的(如一个Plane平面z在球上展示, 将其矩阵转换到球坐标系下, 还需另外做法线计算, 将其从(0, 0, 1)转换到fixed system)\n// 大部分水体数据都没有法线，所以这里默认平面就用0,0,1保证大部分情况正确，球上计算ecefMatrix\nuniform mat4 textureMatrix;\nuniform float time;\nuniform float size;\nuniform float uOffsetScale;\n\n#ifdef IS_GLOBE\nattribute mat4 ecefMatrix;\nvarying mat4 vEcefMatrix;\n#endif\n\nvarying vec2 vUv;\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\nvarying vec4 vClipSpace;\nvarying vec3 vWorldNormal;\n\n#include <common>\n#include <normal_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n    #ifdef IS_GLOBE\n    vEcefMatrix = ecefMatrix;\n        vec3 zNormal = normalize(vec3(ecefMatrix[0][2], ecefMatrix[1][2], ecefMatrix[2][2]));\n    #else\n        vec3 zNormal = vec3(0.0, 0.0, 1.0);\n    #endif\n\n    vUv = uv;\n    mirrorCoord = modelMatrix * vec4(position, 1.0);\n    worldPosition = mirrorCoord.xyzw;\n    mirrorCoord = textureMatrix * mirrorCoord;\n    // 水体扰动\n    float offset = cos(0.5 * (vUv.x * size) + 0.5 * (vUv.y * size)) * sin(time);\n    offset += sin(0.8 * (vUv.x * size) + 0.8 * (vUv.y * size)) * cos(1.5 * time);\n    worldPosition.xyz += zNormal * offset * uOffsetScale;\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vWorldNormal = zNormal;\n\n    vClipSpace = gl_Position;\n\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <normal_vertex>\n    #include <logdepthbuf_vertex>\n    #include <shadowmap_vertex>\n}",fragmentShader$w="// http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nuniform sampler2D tFoamNoise;\nuniform float uDepthSoftness;\nuniform vec3 uWaterShallowColor;\nuniform vec3 uWaterDeepColor;\nuniform float uFoamSpeed;\nuniform float uFoamScale;\nuniform float uFoamSoftness;\nuniform mat4 projectionInverseMatrix;\nuniform mat4 viewInverseMatrix;\nuniform float uCrestFoam;\nuniform vec3 uCrestFoamColor;\nuniform float uFoamDepthSoftness;\nuniform float uSpecularStrength;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\n// uniform sampler2D mirrorSampler;\nuniform bool autoScale;\nuniform float alpha;\nuniform float time;\nuniform float size;\nuniform float distortionScale;\nuniform sampler2D normalMap;\nuniform sampler2D waterBedMap;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform vec3 eye;\nuniform vec3 waterColor;\nuniform vec3 finalColor;\nuniform sampler2D tDepth;\nuniform sampler2D tScreen;\nuniform float uCameraNear;\nuniform float uCameraFar;\nvarying vec4 vClipSpace;\nvarying vec3 vWorldNormal;\n#ifdef USE_ENVMAP\n    uniform sampler2D envMap;\n#else\n    uniform vec3 reflectionColor;\n#endif\nuniform mat3 mvt_normalMatrix;\n\nvarying vec2 vUv;\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\nuniform float uUvScale;\n\nvec4 getNoise(vec2 uv) {\n    vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);\n    vec2 uv1 = uv / 107.0 - vec2(time / -19.0, time / 31.0);\n    vec2 uv2 = uv / vec2(907.0, 803.0) + vec2(time / 101.0, time / 97.0);\n    vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);\n    vec4 noise = texture2D(normalMap, uv0) +\n        texture2D(normalMap, uv1) +\n        texture2D(normalMap, uv2) +\n        texture2D(normalMap, uv3);\n    return noise * 0.5 - 1.0;\n}\n\nvoid sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor) {\n    vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));\n    float direction = max(0.0, dot(eyeDirection, reflection));\n    specularColor += pow(direction, shiny) * sunColor * spec;\n    diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;\n}\n\n#define ENVMAP_TYPE_CUBE_UV\n\n#include <common>\n#include <packing>\n\n#include <bsdfs>\n#include <logdepthbuf_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\n#include <cube_uv_reflection_fragment>\n\n#define MVT_FRAG_REFLECTION_FACTOR\n#define MVT_FRAG_NORMAL\n\n/* texture tiling */\n#define HASHSCALE1 443.8975\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(hash12(ip),hash12(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(hash12(ip+vec2(0.0,1.0)),hash12(ip+vec2(1.0,1.0)),u.x),u.y);\n\t//return res*res;\n    return res;\n}\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx+19.19);\n\treturn fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nstruct InterpNodes2 {\n    vec2 seeds;\n    vec2 weights;\n};\nInterpNodes2 GetNoiseInterpNodes(float smoothNoise) {\n    vec2 globalPhases = vec2(smoothNoise * 0.5) + vec2(0.5, 0.0);\n    vec2 phases = fract(globalPhases);\n    vec2 seeds = floor(globalPhases) * 2.0 + vec2(0.0, 1.0);\n    vec2 weights = min(phases, vec2(1.0) - phases) * 2.0;\n    return InterpNodes2(seeds, weights);\n}\n\nvec4 PreserveVariance(vec4 linearColor, vec4 meanColor, float moment2) {\n    return (linearColor - meanColor) / sqrt(moment2) + meanColor;\n}\n\nvec4 GetTextureSample(sampler2D tex, vec2 uvIn, float seed) {\n    vec3 hash = hash31(seed);\n    float ang = hash.x * 2.0 * PI;\n    mat2 rotation = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    \n    vec2 uv = rotation * uvIn + hash.yz;\n    return texture2D(tex, uv);\n}\n\nconst float layersCount = 5.0;\nvec4 texture2D_NoTiling(sampler2D tex, vec2 uv) {\n    InterpNodes2 interpNodes = GetNoiseInterpNodes(noise(uv) * layersCount);\n    \n    vec4 col;\n    \n    float moment2 = 0.0;\n    for(int i = 0; i < 2; i++) {\n        float weight = interpNodes.weights[i];\n        moment2 += weight * weight;\n        col += GetTextureSample(tex, uv, interpNodes.seeds[i]) * weight;\n    }\n    col = PreserveVariance(col, texture2D(tex, vec2(0.5), 10000.0), moment2);\n    return col;\n}\n\nfloat step_distance(float value) {\n    float n = 100.;\n    if (value > 1000.) {\n        n = 1000.;\n    }\n    if (value > 10000.) {\n        n = 10000.;\n    }\n    if (value > 100000.) {\n        n = 100000.;\n    }\n    return value - value / n;\n}\n\nfloat toLinearDepth (float zDepth) {\n    float near = uCameraNear;\n    float far = uCameraFar;\n    return (2.0 * near * far / (far + near - (2.0 * zDepth - 1.0) * (far - near)));\n}\n\nvec2 clipSpaceToTexCoords(vec4 clipSpace) {\n    vec2 ndc = (clipSpace.xy/clipSpace.w);\n    vec2 textCoords = ndc/2.0+0.50;\n    return textCoords;\n}\n\nfloat linearize_depth(in float depth, in float cameraNear, in float cameraFar){\n    float a = cameraFar / (cameraFar - cameraNear);\n    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n    return a + b / depth;\n}\n\nfloat reconstruct_depth(sampler2D tDepth, const in vec2 uv, in float cameraNear, in float cameraFar){\n    float depth = texture2D(tDepth, uv).x;\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat reconstruct_depth2(float depth, in float cameraNear, in float cameraFar){\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat getDepthFromTexture(sampler2D tDepth, vec2 uv) {\n    #if defined( USE_LOGDEPTHBUF )\n        return linearize_depth(reconstruct_depth(tDepth, uv, uCameraNear, uCameraFar), uCameraNear, uCameraFar);\n    #else\n        return texture2D(tDepth, uv).x;\n    #endif\n}\n\nvec3 mvtGetViewPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);\n\n    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];\n    // clipSpacePosition *= clipW;\n    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;\n    \n    viewSpacePosition /= viewSpacePosition.w;\n    return viewSpacePosition.xyz;\n\n}\n\nvec3 mvtGetWorldPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix, mat4 viewInverseMatrix) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);\n\n    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;\n    vec4 worldSpacePosition = viewInverseMatrix * viewSpacePosition;\n\n    return worldSpacePosition.xyz / worldSpacePosition.w;\n}\n\nfloat getDepth(float depth) {\n    #if defined( USE_LOGDEPTHBUF )\n        return linearize_depth(reconstruct_depth2(depth, uCameraNear, uCameraFar), uCameraNear, uCameraFar);\n    #else\n        return depth;\n    #endif \n}\n\nfloat calculateWaterDepthDiff (vec2 texCoords, float fragDepth) {\n    float depth = getDepthFromTexture(tDepth, texCoords);\n    float depth2 = getDepth(fragDepth);\n\n    return abs(depth2 - depth);\n}\n\nfloat calculateWaterDepth (vec2 texCoords, float fragDepth) {\n    float depth = getDepthFromTexture(tDepth, texCoords);\n    vec3 worldPosition1 = mvtGetWorldPositionByDepth(depth, texCoords, projectionInverseMatrix, viewInverseMatrix);\n    float floorDistance = toLinearDepth (depth);\n    depth = getDepth(fragDepth);\n    vec3 worldPosition2 = mvtGetWorldPositionByDepth(depth, texCoords, projectionInverseMatrix, viewInverseMatrix);\n    return dot((worldPosition2 - worldPosition1), vWorldNormal);\n}\n\nvec2 refract_uv(vec2 uv, float strength, vec3 normal){\n\tfloat strength1 = strength;\n\tuv += strength1 * length(normal) - strength1 * 1.2;\n\treturn uv;\n}\n\nfloat h12(vec2 p)\n{\n    return fract(sin(dot(p, vec2(32.52554, 45.5634))) * 12432.2355);\n}\n\nfloat n12(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f * (3.0 - 2.0 * f);\n    return mix(\n        mix(h12(i + vec2(0.0, 0.0)), h12(i + vec2(1.0, 0.0)), f.x),\n        mix(h12(i + vec2(0.0, 1.0)), h12(i + vec2(1.0, 1.0)), f.x),\n        f.y\n    );\n}\n\nfloat caustics(vec2 p, float t)\n{\n    vec3 k = vec3(p, t);\n    float l;\n    mat3 m = mat3(-2, -1, 2,\n                   3, -2, 1,\n                   1,  2, 2);\n    float n = n12(p);\n    k = k * m * 0.5;\n    l = length(0.5 - fract(k + n));\n    k = k * m * 0.4;\n    l = min(l, length(0.5 - fract(k + n)));\n    k = k * m * 0.3;\n    l = min(l, length(0.5 - fract(k + n)));\n    return pow(l, 7.0) * 25.0;\n}\n\nvec2 hashVec2(vec2 p) {\n    float x = fract(sin(dot(p ,vec2(127.1, 311.7))) * 43758.5453);\n    float y = fract(sin(dot(p ,vec2(269.5, 183.3))) * 43758.5453);\n    return vec2(x, y);\n}\n\nvec2 alignUv(vec2 uv) {\n    vec2 texelSize = resolution * pixelRatio;\n    return vec2((floor(uv * texelSize) + 0.5) / (texelSize));\n}\n\nvoid main() {\n\n    float fragDepth = log2(vFragDepth) * logDepthBufFC * 0.5;\n    // 生成扰动法线\n    vec3 N = normalize(vWorldNormal); // 法线方向\n    vec3 T = normalize(cross(vec3(0.0, 1.0, 0.0), N)); // 切线方向（避免退化）\n    if (length(T) < 1e-3) {\n        T = normalize(cross(vec3(1.0, 0.0, 0.0), N));\n    }\n    vec3 B = cross(N, T); // 副法线\n\n    vec2 uvValue = vUv * uUvScale;\n    vec4 noise = getNoise(uvValue);\n    float cameraDistance = length(cameraPosition.xyz - worldPosition.xyz);\n    float logDistance = log2(cameraDistance) * logDepthBufFC * 0.5;\n    vec3 surfaceNormal = normalize(noise.xyz * vec3(2.0, 2.0, 1.0));\n\n    vec3 originNormal = surfaceNormal;\n    surfaceNormal = normalize(\n        surfaceNormal.x * T +\n        surfaceNormal.y * B +\n        surfaceNormal.z * N\n    );\n\n    // 相机方向与扰动方向\n    vec3 worldToEye = cameraPosition - worldPosition.xyz;\n    vec3 eyeDirection = normalize(worldToEye);\n    float dist = length(worldToEye);\n\n    // 水体颜色透明度设置\n    float foamAlpha = 0.5;\n    float shallowAlpha = 0.3;\n    float deepAlpha = 0.99;\n\n    // 获取裁剪空间的真实贴图坐标\n    vec2 realCoords = clipSpaceToTexCoords(vClipSpace);\n\n    realCoords = alignUv(realCoords);\n    vec2 originRealCoords = realCoords;\n\n    // 原始水深（岸边效果用）\n    float waterDepthOrigin = calculateWaterDepth(realCoords, fragDepth);\n    float depthFade = smoothstep(0.0, 2.0, waterDepthOrigin);\n    // 根据距离进行扰动衰减\n    vec2 distortion = originNormal.xy * (0.001 + min(0.005, 1.0 / cameraDistance)) * distortionScale * depthFade;\n    realCoords += distortion;\n\n    // 计算扰动后的深度贴图值\n    float disturbedDepth = texture2D(tDepth, realCoords).x;\n    // 折射优化\n    // https://catlikecoding.com/unity/tutorials/flow/looking-through-water/\n    // // 判断当前片元是否仍然处于水下（避免扰动水上图像）\n    // bool isStillUnderwater = disturbedDepth > fragDepth + 1e-4;\n\n    // 折射颜色采样逻辑\n    vec4 screenTex;\n    realCoords = originRealCoords + distortion * smoothstep(0.0, 0.1, disturbedDepth - fragDepth) * 0.5;\n    realCoords = alignUv(realCoords);\n    screenTex = texture2D(tScreen, realCoords);\n\n    // 当前水深估计\n    float depth = texture2D(tDepth, realCoords).x;\n    float waterDepth = calculateWaterDepth(realCoords, fragDepth);\n\n    // 波峰泡沫判断（z 趋近 1 表示竖直）\n    float crestFoam = smoothstep(uCrestFoam, 1.0, originNormal.z);\n\n    // 获取泡沫噪声图\n    vec4 foamNoise = texture2D(tFoamNoise, vUv * uFoamScale + uFoamSpeed * time);\n\n    // 计算泡沫边缘程度\n    float foamFactor = abs(foamNoise.r - clamp(waterDepth / uFoamSoftness, 0.0, 1.0));\n    float foamEdge = smoothstep(0.0, 0.3, foamFactor);\n    foamEdge = pow(foamEdge, 2.0);\n\n    // 岸边扰动随机偏移\n    float offset = (hash12(uvValue) - 0.5) * 0.2;\n    float shallowMin = 0.1 + offset;\n    float shallowMax = 0.3 + offset;\n    float shallowFade = smoothstep(shallowMin, shallowMax, waterDepthOrigin);\n    // float shallowFade = smoothstep(shallowMin, shallowMax, waterDepth);\n\n    // 泡沫视距衰减（超过 3000m 消除）\n    // float foamDistanceFade = clamp(1.0 - cameraDistance / 3000.0, 0.0, 1.0);\n    // 视距渐隐，使用 smoothstep 替代 clamp，平滑过渡\n    float foamDepthFade = smoothstep(uFoamDepthSoftness, 0.0, waterDepth);\n    float foamDistanceFade = smoothstep(1000.0, 500.0, cameraDistance); // 3000m 以上完全消失，2000m 以下完全出现\n    float foamAmount = foamEdge * foamDepthFade * shallowFade * foamDistanceFade;\n\n    // 远距离颜色衰减\n    float depthDistanceFade = clamp((1000.0 - cameraDistance) / 1000.0, 0.0, 1.0);\n\n    // 计算颜色渐变和透明度渐变（近岸更浅、更透明）\n    vec3 baseColor = mix(uWaterShallowColor, uWaterDeepColor, clamp(waterDepth / uDepthSoftness, 0.0, 1.0));\n    vec3 shallowDeepColorFaded = mix(uWaterDeepColor, baseColor, depthDistanceFade);\n    float baseAlpha = mix(shallowAlpha, deepAlpha, clamp(waterDepth / uDepthSoftness, 0.0, 1.0));\n    float shallowDeepAlphaFaded = mix(deepAlpha, baseAlpha, depthDistanceFade);\n    vec4 shallowDeepLerp = vec4(shallowDeepColorFaded, shallowDeepAlphaFaded);\n    vec4 foamLerp = shallowDeepLerp;\n\n    // 浪尖区域混入蓝色（波峰增强）\n    foamLerp.rgb = mix(uCrestFoamColor, foamLerp.rgb, crestFoam);\n    vec4 waterColorFoam = foamLerp;\n    vec4 waterColor = waterColorFoam;\n\n    // Beer-Lambert 法则做水下衰减\n    vec3 beersCoeff = vec3(0.15, 0.35, 0.85);\n    float depthDiff = calculateWaterDepthDiff(realCoords, fragDepth);\n    vec3 attenuation = exp(-beersCoeff * depthDiff);\n    waterColor *= vec4(attenuation, 1.0);\n\n    // 岸边褪色权重\n    float maxShoreFadeDepth = 3.0;\n    float shoreFade = clamp(waterDepth / maxShoreFadeDepth, 0.0, 1.0);\n\n    // 水下焦散效果\n    float causticsValue = caustics(uvValue / 10.0, time * .2);\n    float causticsLevel = max(0.0, smoothstep(uDepthSoftness, 0.0, abs(waterDepth)));\n    causticsLevel = pow(causticsLevel, 0.3);\n    causticsValue *= causticsLevel;\n    causticsValue = clamp(causticsValue, 0.0, 1.0) * 0.10;\n    waterColor.rgb += vec3(causticsValue);\n\n    // 光照部分计算\n    waterColorFoam = waterColor;\n    vec3 diffuseLight = vec3(waterColorFoam.rgb);\n    vec3 specularLight = vec3(0.0);\n    vec3 reflectDir = reflect(-worldToEye, normalize((vec4(vNormal, 1.0) * viewMatrix).xyz));\n    sunLight(surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);\n    specularLight *= smoothstep(0.0, 0.1, dot(surfaceNormal, sunDirection)) * uSpecularStrength;\n\n    #ifdef USE_ENVMAP\n        vec3 reflectionSample = textureCubeUV(envMap, reflectDir, 0.0).xyz;\n    #else\n        vec3 reflectionSample = reflectionColor;\n    #endif\n\n    // 菲涅尔反射\n    float theta = max(dot(eyeDirection, surfaceNormal), 0.0);\n    float rf0 = 0.02;\n    float t = clamp(1.0 - cameraDistance / 1000.0, 0.0, 1.0);\n    t = smoothstep(0.0, 1.0, pow(t, 1.3));\n    float exponent = mix(5.0, 50.0, t);\n    float reflectance = rf0 + (1.0 - rf0) * pow((1.0 - theta), 5.0);\n\n    float facing = max(0.0, dot(surfaceNormal, eyeDirection));\n    float scatterFactor = mix(0.3, 1.0, pow(facing, 0.6));\n    vec3 scatter = scatterFactor * waterColorFoam.xyz;\n\n    vec2 uv = mirrorCoord.xy / mirrorCoord.w * 0.01;\n    if(autoScale) {\n        float scat = step_distance(cameraPosition.z) * 0.01;\n        uv /= scat;\n    }\n    uv = uv * size + distortion;\n\n    float r = pow(specularLight.r, 2.0);\n    vec3 albedo = (sunColor * diffuseLight * 0.3 + scatter) + (reflectionSample * 0.9 + reflectionSample * specularLight) * r * max(0.5, reflectance);\n    vec3 outgoingLight = albedo;\n\n    // 最终水体颜色输出，包含高光、反射、散射\n    vec4 composedWaterColor = vec4(outgoingLight, 1.0);\n\n    // 远距离自动强制不透明，避免抖动（渐变替代突变）\n    float distFade = smoothstep(300.0, 2000.0, cameraDistance);\n    // 融合进最终 shoreFade\n    shoreFade = mix(shoreFade, 1.0, distFade);\n\n    // 混合背景场景颜色（screenTex）与水体颜色，岸边透明度控制\n    composedWaterColor = mix(screenTex, composedWaterColor, waterColorFoam.a * shoreFade);\n\n    // 混合泡沫颜色，增强岸边白沫效果\n    composedWaterColor = mix(composedWaterColor, vec4(1.0, 1.0, 1.0, shoreFade), foamAmount);\n\n    composedWaterColor.rgb = clamp(composedWaterColor.rgb, 0.0, 100.0);\n    gl_FragColor = vec4(composedWaterColor.rgb, 1.0);\n\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    #include <logdepthbuf_fragment>\n}\n";function colorToArr4(e){let t=convertSRGBColor(e).toArray(),i=void 0===t[3]?1:t[3];return[t[0],t[1],t[2],i]}function colorToRgbaArr(e){let t=convertSRGBColor(e).toArray(),i=void 0===t[3]?1:t[3];return[255*t[0],255*t[1],255*t[2],i]}function normalizeColor(e){const t=colorToArr4(e);return new three.Color(t[0],t[1],t[2])}function convertSRGBColor(e){if(!e)return new three.Color(1,1,1);if(e.isColor)return e;if("string"==typeof e){const t=/^#([0-9A-Fa-f]{8})/,i=e.match(t);if(i){const e=i[1],t=`#${e.slice(0,6)}`,n=parseInt(e.slice(6,8),16)/255,r=new three.Color(t);return new three.Vector4(r.r,r.g,r.b,n)}const n=/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/,r=e.match(n);if(r){const e=parseInt(r[1],10),t=parseInt(r[2],10),i=parseInt(r[3],10),n=parseFloat(r[4]),s=`rgb(${e}, ${t}, ${i})`,a=new three.Color(s);return new three.Vector4(a.r,a.g,a.b,n)}const s=/hsla\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d.]+)\s*\)/,a=e.match(s);if(a){const e=parseInt(a[1],10)/360,t=parseInt(a[2],10)/100,i=parseInt(a[3],10)/100,n=parseFloat(a[4]),r=(new three.Color).setHSL(e,t,i);return new three.Vector4(r.r,r.g,r.b,n)}}return new three.Color(e)}function rgb565torgb(e){const t=e>>11,i=e>>5&63,n=31&e;return[Math.round(t/31*255),Math.round(i/63*255),Math.round(n/31*255)]}const colorUtils=Object.freeze(Object.defineProperty({__proto__:null,colorToArr4:colorToArr4,colorToRgbaArr:colorToRgbaArr,normalizeColor:normalizeColor,convertSRGBColor:convertSRGBColor,rgb565torgb:rgb565torgb},Symbol.toStringTag,{value:"Module"})),emissiveUniforms={mvt_emissive:{value:null},mvt_emissiveIntensity:{value:1}},selectiveUniforms={selectedObjectColor:{value:[1,1,0,.5]},selectedObjectIndex:{value:-1},selectedObjectColorMode:{value:0}},keepSizeUniforms={keepSize:{value:!1},zoomUnits:{value:1}},defineMaterialNormalProperties=(e,t=[])=>{for(let i of t)Object.defineProperty(e,i,{get:function(){return this.uniforms[i].value},set:function(e){this.uniforms[i].value=e}})},defineMaterialColorProperties=(e,t=[])=>{for(let i of t)Object.defineProperty(e,i,{get:function(){return this.uniforms[i].value},set:function(e){this.uniforms[i].value=normalizeColor(e)}})},defineMaterialAliasProperties=(e,t=[])=>{for(let[i,n,r]of t)Object.defineProperty(e,i,{get:function(){return this.uniforms[n].value},set:function(e){this.uniforms[n].value=r?r(e):e}})},defineMaterialBoolDefineProperties=(e,t=[])=>{for(let[i,n]of t)Object.defineProperty(e,i,{get:function(){return!!this.defines[n]},set:function(e){this[i]!==e&&(e?this.defines[n]=!0:delete this.defines[n],this.needsUpdate=!0)}})},defineMaterialSelectiveProperties=e=>{Object.defineProperties(e,{selectedObjectColor:{get:function(){return this.uniforms.selectedObjectColor.value},set:function(e){this.uniforms.selectedObjectColor.value=e}},selectedObjectColorMode:{get:function(){return this.uniforms.selectedObjectColorMode.value},set:function(e){this.uniforms.selectedObjectColorMode.value=e}},selectedObjectIndex:{get:function(){return this.uniforms.selectedObjectIndex.value},set:function(e){this.uniforms.selectedObjectIndex.value=e}},selective:{get:function(){return!!this.defines.MVT_ENABLE_SELECTIVE},set:function(e){this.selective!==e&&(e?this.defines.MVT_ENABLE_SELECTIVE=!0:delete this.defines.MVT_ENABLE_SELECTIVE,this.needsUpdate=!0)}}})},defineMaterialKeepSizeProperties=e=>{Object.defineProperties(e,{keepSize:{get:function(){return this.uniforms.keepSize.value},set:function(e){this.uniforms.keepSize.value=e}},zoomUnits:{get:function(){return this.uniforms.zoomUnits.value},set:function(e){this.uniforms.zoomUnits.value=e}},zoomUnitsUniform:{get:function(){return this.uniforms.zoomUnits},set:function(e){this.uniforms.zoomUnits=e}}})},defineMaterialEmissiveProperties=e=>{Object.defineProperties(e,{emissiveEnabled:{get:function(){return this.defines.MVT_EMISSIVE_UNIFORM||!1},set:function(e){e?this.defines.MVT_EMISSIVE_UNIFORM=!0:delete this.defines.MVT_EMISSIVE_UNIFORM}},emissive:{get:function(){return this.uniforms.mvt_emissive.value},set:function(e){e?this.defines.MVT_EMISSIVE_COLOR=!0:delete this.defines.MVT_EMISSIVE_COLOR,this.uniforms.mvt_emissive.value=e}},emissiveIntensity:{get:function(){return this.uniforms.mvt_emissiveIntensity.value},set:function(e){this.uniforms.mvt_emissiveIntensity.value=e}}})},generateCubeUVSize=e=>{const t=e&&e.source&&e.source.data&&e.source.data.height||null;if(null===t)return null;const i=Math.log2(t)-2,n=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,i),112)),texelHeight:n,maxMip:i}};class CommonShaderMaterial extends three.ShaderMaterial{constructor(e){super(),__publicField(this,"isCommonShaderMaterial",!0),__publicField(this,"setCommonUniforms",(e=>{for(const t of Object.keys(e))this.uniforms[t]=e[t]})),this.setValues(e)}}const textureLoader$b=new three.TextureLoader,foamTexture=textureLoader$b.load(getAssetUrl("assets/textures/water/foam_noise.webp"));foamTexture.wrapS=foamTexture.wrapT=three.RepeatWrapping;let normalMaps={},waterBedMaps={};const uniforms$t=three.UniformsUtils.merge([three.UniformsLib.fog,three.UniformsLib.lights,{envMap:{value:null},tDepth:{value:null},tScreen:{value:null},uCameraNear:{value:0},uOffsetScale:{value:1},uDepthSoftness:{value:5},uFoamDepthSoftness:{value:1},uFoamSoftness:{value:3},uFoamScale:{value:100},uFoamSpeed:{value:.05},uCrestFoam:{value:.7},uSpecularStrength:{value:1.5},uCrestFoamColor:{value:new three.Color(.3,.3,.6)},viewInverseMatrix:{value:new three.Matrix4},tFoamNoise:{value:foamTexture},uCameraFar:{value:0},uWaterShallowColor:{value:new three.Color(1/255,23/255,60/255)},uWaterDeepColor:{value:new three.Color(1/255,46/255,120/255)},projectionInverseMatrix:{value:new three.Matrix4},alpha:{value:1},time:{value:0},autoScale:{value:!1},size:{value:1},distortionScale:{value:5},sunColor:{value:new three.Color(16777215)},sunDirection:{value:new three.Vector3(.70707,.70707,0)},eye:{value:new three.Vector3},waterColor:{value:new three.Color(7695)},reflectionColor:{value:new three.Color(7695)},finalColor:{value:new three.Color(12573183)},normalMap:{value:null},waterBedMap:{value:null},mvt_normalMatrix:{value:new three.Matrix3},isEmissive:{value:!1},uUvScale:{value:1e3}}]),_WaterMaterial=class extends CommonShaderMaterial{constructor(e={}){super(),__publicField(this,"_timeScaleFactor",.001),__publicField(this,"_style",""),__publicField(this,"_useEnvMap",!0),__publicField(this,"_waterColor",[1/255,46/255,120/255]),__publicField(this,"_foamSpeed",.05),__publicField(this,"_offsetScale",1),__publicField(this,"_depthSoftness",5),__publicField(this,"_foamDepthSoftness",1),__publicField(this,"_foamSoftness",3),__publicField(this,"_foamScale",100),__publicField(this,"_crestFoam",.7),__publicField(this,"_crestFoamColor",[.3,.3,.6]),__publicField(this,"_specularStrength",1.5),__publicField(this,"_uvScale",1e3),this.type="WaterMaterial",this.vertexShader=vertexShader$u,this.fragmentShader=fragmentShader$w,this.isWaterMaterial=!0,this.lights=!0,this.transparent=!0,this.fog=!1,this.style="lake",Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$t)),this.waterColor=defaultValue$1(e.waterColor,this._waterColor),this.foamSpeed=defaultValue$1(e.foamSpeed,this._foamSpeed),this.offsetScale=defaultValue$1(e.offsetScale,this._offsetScale),this.depthSoftness=defaultValue$1(e.depthSoftness,this._depthSoftness),this.foamDepthSoftness=defaultValue$1(e.foamDepthSoftness,this._foamDepthSoftness),this.foamSoftness=defaultValue$1(e.foamSoftness,this._foamSoftness),this.foamScale=defaultValue$1(e.foamScale,this._foamScale),this.crestFoam=defaultValue$1(e.crestFoam,this._crestFoam),this.crestFoamColor=defaultValue$1(e.crestFoamColor,this._crestFoamColor),this.specularStrength=defaultValue$1(e.specularStrength,this._specularStrength),this.uvScale=defaultValue$1(e.uvScale,this._uvScale),this.defines={CUBEUV_TEXEL_WIDTH:.0003255208333333333,CUBEUV_TEXEL_HEIGHT:.000244140625,CUBEUV_MAX_MIP:"10.0"},defineMaterialNormalProperties(this,["sunColor","reflectionColor","finalColor","autoScale","size","alpha","distortionScale","isEmissive"]),Object.defineProperties(this,{waterBedMap:{get:function(){return this.uniforms.waterBedMap.value},set:function(e){e.wrapS=e.wrapT=three.RepeatWrapping,this.uniforms.waterBedMap.value&&this.uniforms.waterBedMap.value.dispose(),this.uniforms.waterBedMap.value=e,this.needsUpdate=!0}},normalMap:{get:function(){return this.uniforms.normalMap.value},set:function(e){e.wrapS=e.wrapT=three.RepeatWrapping,this.uniforms.normalMap.value&&this.uniforms.normalMap.value.dispose(),this.uniforms.normalMap.value=e,this.needsUpdate=!0}}}),this.setValues(e),_WaterMaterial.instances.add(this)}onBeforeSceneRender(e,t,i,n){this.uniforms.eye.value.copy(i.position);const r=e.rendering.opaquePostprocessings;if(this.uniforms.tScreen.value=r.texture,this.uniforms.tDepth.value=r.depthTexture,this.uniforms.uCameraNear.value=i.near,this.uniforms.uCameraFar.value=i.far,this.uniforms.time.value=e.rendering.uniforms.elapsedTime.value*this._timeScaleFactor,this.uniforms.projectionInverseMatrix.value.copy(i.projectionMatrixInverse),this.uniforms.viewInverseMatrix.value.copy(i.matrixWorld),this.uniforms.envMap.value!==t.environment){this.uniforms.envMap.value=t.environment;const e=generateCubeUVSize(t.environment);e&&(this.defines.CUBEUV_TEXEL_WIDTH=e.texelWidth,this.defines.CUBEUV_TEXEL_HEIGHT=e.texelHeight,this.defines.CUBEUV_MAX_MIP=e.maxMip+".0"),t.environment&&this._useEnvMap?this.defines.USE_ENVMAP=!0:delete this.defines.USE_ENVMAP}this.uniforms.mvt_normalMatrix.value.getNormalMatrix(i.matrixWorld),this.setCommonUniforms(e.rendering.uniforms);const s=e.rendering.sky;s&&this.uniforms.sunDirection.value.copy(s.sunDirection)}get useEnvMap(){return this._useEnvMap}set useEnvMap(e){this._useEnvMap=e}get timeScaleFactor(){return this._timeScaleFactor}set timeScaleFactor(e){this._timeScaleFactor=e}get waterColor(){return this._waterColor}set waterColor(e){this._waterColor=e,this.uniforms.uWaterDeepColor.value=new three.Color(e[0],e[1],e[2]),this.uniforms.uWaterShallowColor.value=new three.Color(e[0]/2,e[1]/2,e[2]/2)}get foamSpeed(){return this._foamSpeed}set foamSpeed(e){this._foamSpeed=e,this.uniforms.uFoamSpeed.value=e}get offsetScale(){return this._offsetScale}set offsetScale(e){this._offsetScale=e,this.uniforms.uOffsetScale.value=e}get depthSoftness(){return this._depthSoftness}set depthSoftness(e){this._depthSoftness=e,this.uniforms.uDepthSoftness.value=e}get foamDepthSoftness(){return this._foamDepthSoftness}set foamDepthSoftness(e){this._foamDepthSoftness=e,this.uniforms.uFoamDepthSoftness.value=e}get foamSoftness(){return this._foamSoftness}set foamSoftness(e){this._foamSoftness=e,this.uniforms.uFoamSoftness.value=e}get foamScale(){return this._foamScale}set foamScale(e){this._foamScale=e,this.uniforms.uFoamScale.value=e}get crestFoam(){return this._crestFoam}set crestFoam(e){this._crestFoam=e,this.uniforms.uCrestFoam.value=e}get crestFoamColor(){return this._crestFoamColor}set crestFoamColor(e){this._crestFoamColor=e,this.uniforms.uCrestFoamColor.value=new three.Color(e[0],e[1],e[2])}get specularStrength(){return this._specularStrength}set specularStrength(e){this._specularStrength=e,this.uniforms.uSpecularStrength.value=e}get style(){return this._style}set style(e){e!==this._style&&(normalMaps[e]&&waterBedMaps[e]?(this.normalMap=normalMaps[e],this._style=e):"river"!==e&&"lake"!==e&&"ocean"!==e||(textureLoader$b.load(getAssetUrl(`assets/textures/water/${e}_normal.webp`),(t=>{this.normalMap=t,normalMaps[e]=t})),this._style=e))}get uvScale(){return this._uvScale}set uvScale(e){this._uvScale=e,this.uniforms.uUvScale.value=e}dispose(){_WaterMaterial.instances.delete(this);let e=["envMap","normalMap","waterBedMap"];for(let t=0;t<e.length;t++){const i=e[t];this.uniforms[i]&&this.uniforms[i].value&&this.uniforms[i].value.dispose()}normalMaps={},waterBedMaps={},super.dispose()}static hasActiveInstances(){return _WaterMaterial.instances.size>0}static getActiveInstances(){return new Set(_WaterMaterial.instances)}};let WaterMaterial=_WaterMaterial;__publicField(WaterMaterial,"instances",new Set);class OpaquePostprocessings extends Postprocessings{constructor(e){super(e),__publicField(this,"_enableOpaqueCopy",!1),__publicField(this,"_handleMeshBeforeRender",((e,t,i)=>{if(this._rendering.renderState.stage!==RENDER_STAGE_SCENE)return;if(this._validCount<=0)return;const n=this._rendering.sharedFullScreenRenderTargets;let r=e.getRenderTarget();const s=r;this._updateMultisampleRenderTarget(e,r);let a=n.getAvailableRenderTarget();const o=a;let l=null;const c=this._postprocessings;let h=this._validCount-1,u=0;for(let d=0,p=c.length;d<p;d++){const t=c[d];if(t.enabled){if(t.render(e,a,r),h!==u&&t.needsSwap)if(r===s)r=a,a=n.getAvailableRenderTarget(),l=a;else{let e=r;r=a,a=e}u++}}this._mesh.material.uniforms.tDiffuse.value=a.texture,n.releaseRenderTarget(o),l&&n.releaseRenderTarget(l),e.setRenderTarget(s)})),this._postprocessings=[],this._testRenderTarget=new three.WebGLRenderTarget(1,1,{}),this._testScene=new three.Mesh(new three.BoxGeometry(1,1,1),new three.MeshBasicMaterial({})),this._testScene.frustumCulled=!1,this._opaqueCopyPass=new OpaqueCopyPass,this.add(this._opaqueCopyPass)}beginFrame(){const e=WaterMaterial.hasActiveInstances();if(this._opaqueCopyPass.enabled=this._enableOpaqueCopy||e,this._updatePostprocessings(),this._rendering,this._validCount>0){if(!this._mesh){const e=this._geometry=new three.BufferGeometry;e.setAttribute("position",new three.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),e.setAttribute("uv",new three.Float32BufferAttribute([0,2,0,0,2,0],2));const t=this._material=new three.ShaderMaterial({depthTest:!1,name:"OpaquePostprocessingsCopy",uniforms:{tDiffuse:{value:null}},vertexShader:"\n                        varying vec2 vUv;\n                        void main() {\n                            vUv = uv;\n                            gl_Position = vec4(position, 1.0);\n                        }\n                    ",fragmentShader:"\n                        uniform sampler2D tDiffuse;\n                        varying vec2 vUv;\n\n                        void main() {\n                            vec4 color = texture2D(tDiffuse, vUv);\n                            gl_FragColor = color;\n                            // gl_FragColor = vec4(1.0, .0, .0, 1.0);\n                        }\n                    "}),i=this._mesh=new three.Mesh(e,t);i.isFSQuad=!0,i.frustumCulled=!1,i.renderOrder=1e9,i.onBeforeRender=this._handleMeshBeforeRender,this._rendering.add(i)}this._mesh.visible=!0}else this._mesh&&(this._mesh.visible=!1)}add(e){super.add(e);const t=e.material;t.defines?t.defines.USE_OPAQUE_POST_STAGE=!0:t.defines={USE_OPAQUE_POST_STAGE:!0},t.needsUpdate=!0}_useMultisampledRTT(e,t){const i=e.properties,n=e.extensions,r=e.capabilities.isWebGL2,s=i.get(t);return r&&t.samples>0&&!0===n.has("WEBGL_multisampled_render_to_texture")&&!1!==s.__useRenderToTexture}_updateMultisampleRenderTarget(e,t){if(e.capabilities.isWebGL2&&t.samples>0&&!1===this._useMultisampledRTT(e,t)){const i=e.getContext(),n=e.state,r=e.properties,s=t.isWebGLMultipleRenderTargets?t.texture:[t.texture],a=t.width,o=t.height;let l=i.COLOR_BUFFER_BIT;const c=[],h=t.stencilBuffer?i.DEPTH_STENCIL_ATTACHMENT:i.DEPTH_ATTACHMENT,u=r.get(t),d=!0===t.isWebGLMultipleRenderTargets;if(d)for(let e=0;e<s.length;e++)n.bindFramebuffer(i.FRAMEBUFFER,u.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0+e,i.RENDERBUFFER,null),n.bindFramebuffer(i.FRAMEBUFFER,u.__webglFramebuffer),i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0+e,i.TEXTURE_2D,null,0);n.bindFramebuffer(i.READ_FRAMEBUFFER,u.__webglMultisampledFramebuffer),n.bindFramebuffer(i.DRAW_FRAMEBUFFER,u.__webglFramebuffer);for(let e=0;e<s.length;e++){c.push(i.COLOR_ATTACHMENT0+e),t.depthBuffer&&c.push(h);const n=void 0!==u.__ignoreDepthValues&&u.__ignoreDepthValues;if(!1===n&&t.depthBuffer&&(l|=i.DEPTH_BUFFER_BIT),d&&i.framebufferRenderbuffer(i.READ_FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.RENDERBUFFER,u.__webglColorRenderbuffer[e]),!0===n&&(i.invalidateFramebuffer(i.READ_FRAMEBUFFER,[h]),i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER,[h])),d){const t=r.get(s[e]).__webglTexture;i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,t,0)}i.blitFramebuffer(0,0,a,o,0,0,a,o,l,i.NEAREST)}if(n.bindFramebuffer(i.READ_FRAMEBUFFER,null),n.bindFramebuffer(i.DRAW_FRAMEBUFFER,null),d)for(let e=0;e<s.length;e++){n.bindFramebuffer(i.FRAMEBUFFER,u.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0+e,i.RENDERBUFFER,u.__webglColorRenderbuffer[e]);const t=r.get(s[e]).__webglTexture;n.bindFramebuffer(i.FRAMEBUFFER,u.__webglFramebuffer),i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0+e,i.TEXTURE_2D,t,0)}n.bindFramebuffer(i.DRAW_FRAMEBUFFER,u.__webglMultisampledFramebuffer)}}_updatePostprocessings(){let e=0;for(let t=0,i=this._postprocessings.length;t<i;t++){this._postprocessings[t].enabled&&e++}this._validCount=e}render(){}endFrame(){}setSize(e,t){for(let i=0;i<this.postprocessings.length;i++){this.postprocessings[i].setSize(e*window.devicePixelRatio,t*window.devicePixelRatio)}}show(){this._mesh&&(this._mesh.visible=!0)}hide(){this._mesh&&(this._mesh.visible=!1)}isInStableRenderState(){return!0}get enableOpaqueCopy(){return this._enableOpaqueCopy}set enableOpaqueCopy(e){this._enableOpaqueCopy!==e&&(this._enableOpaqueCopy=e)}get texture(){return this._opaqueCopyPass.texture}get depthTexture(){return this._opaqueCopyPass.depthTexture}dispose(){this._renderTarget&&(this._renderTarget.dispose(),this._renderTarget=null),this._mesh&&(this._rendering.remove(this._mesh),this._mesh.geometry.dispose(),this._mesh.material.dispose(),this._mesh=null)}}const LuminosityHighPassShader={name:"LuminosityHighPassShader",uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new three.Color(0)},defaultOpacity:{value:0}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tfloat v = luminance( texel.xyz );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"};class UnrealBloomPass extends Pass$1{constructor(e,t=1,i,n){super(),this.strength=t,this.radius=i,this.threshold=n,this.resolution=void 0!==e?new three.Vector2(e.x,e.y):new three.Vector2(256,256),this.clearColor=new three.Color(0,0,0),this.needsSwap=!1,this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let r=Math.round(this.resolution.x/2),s=Math.round(this.resolution.y/2);this.renderTargetBright=new three.WebGLRenderTarget(r,s,{type:three.HalfFloatType}),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let l=0;l<this.nMips;l++){const e=new three.WebGLRenderTarget(r,s,{type:three.HalfFloatType});e.texture.name="UnrealBloomPass.h"+l,e.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(e);const t=new three.WebGLRenderTarget(r,s,{type:three.HalfFloatType});t.texture.name="UnrealBloomPass.v"+l,t.texture.generateMipmaps=!1,this.renderTargetsVertical.push(t),r=Math.round(r/2),s=Math.round(s/2)}const a=LuminosityHighPassShader;this.highPassUniforms=three.UniformsUtils.clone(a.uniforms),this.highPassUniforms.luminosityThreshold.value=n,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new three.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader}),this.separableBlurMaterials=[];const o=[3,5,7,9,11];r=Math.round(this.resolution.x/2),s=Math.round(this.resolution.y/2);for(let l=0;l<this.nMips;l++)this.separableBlurMaterials.push(this._getSeparableBlurMaterial(o[l])),this.separableBlurMaterials[l].uniforms.invSize.value=new three.Vector2(1/r,1/s),r=Math.round(r/2),s=Math.round(s/2);this.compositeMaterial=this._getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=t,this.compositeMaterial.uniforms.bloomRadius.value=.1;this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new three.Vector3(1,1,1),new three.Vector3(1,1,1),new three.Vector3(1,1,1),new three.Vector3(1,1,1),new three.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,this.copyUniforms=three.UniformsUtils.clone(CopyShader.uniforms),this.blendMaterial=new three.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:CopyShader.vertexShader,fragmentShader:CopyShader.fragmentShader,blending:three.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this._oldClearColor=new three.Color,this._oldClearAlpha=1,this._basic=new three.MeshBasicMaterial,this._fsQuad=new FullScreenQuad(null)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose();for(let e=0;e<this.separableBlurMaterials.length;e++)this.separableBlurMaterials[e].dispose();this.compositeMaterial.dispose(),this.blendMaterial.dispose(),this._basic.dispose(),this._fsQuad.dispose()}setSize(e,t){let i=Math.round(e/2),n=Math.round(t/2);this.renderTargetBright.setSize(i,n);for(let r=0;r<this.nMips;r++)this.renderTargetsHorizontal[r].setSize(i,n),this.renderTargetsVertical[r].setSize(i,n),this.separableBlurMaterials[r].uniforms.invSize.value=new three.Vector2(1/i,1/n),i=Math.round(i/2),n=Math.round(n/2)}render(e,t,i,n,r){e.getClearColor(this._oldClearColor),this._oldClearAlpha=e.getClearAlpha();const s=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),r&&e.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this._fsQuad.material=this._basic,this._basic.map=i.texture,e.setRenderTarget(null),e.clear(),this._fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=i.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this._fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this._fsQuad.render(e);let a=this.renderTargetBright;for(let o=0;o<this.nMips;o++)this._fsQuad.material=this.separableBlurMaterials[o],this.separableBlurMaterials[o].uniforms.colorTexture.value=a.texture,this.separableBlurMaterials[o].uniforms.direction.value=UnrealBloomPass.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[o]),e.clear(),this._fsQuad.render(e),this.separableBlurMaterials[o].uniforms.colorTexture.value=this.renderTargetsHorizontal[o].texture,this.separableBlurMaterials[o].uniforms.direction.value=UnrealBloomPass.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[o]),e.clear(),this._fsQuad.render(e),a=this.renderTargetsVertical[o];this._fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this._fsQuad.render(e),this._fsQuad.material=this.blendMaterial,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,r&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this._fsQuad.render(e)):(e.setRenderTarget(i),this._fsQuad.render(e)),e.setClearColor(this._oldClearColor,this._oldClearAlpha),e.autoClear=s}_getSeparableBlurMaterial(e){const t=[];for(let i=0;i<e;i++)t.push(.39894*Math.exp(-.5*i*i/(e*e))/e);return new three.ShaderMaterial({defines:{KERNEL_RADIUS:e},uniforms:{colorTexture:{value:null},invSize:{value:new three.Vector2(.5,.5)},direction:{value:new three.Vector2(.5,.5)},gaussianCoefficients:{value:t}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"})}_getCompositeMaterial(e){return new three.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"})}}UnrealBloomPass.BlurDirectionX=new three.Vector2(1,0),UnrealBloomPass.BlurDirectionY=new three.Vector2(0,1);class Feature{constructor(e,t={}){__publicField(this,"_enabled",!1),__publicField(this,"name",""),__publicField(this,"needsShaderKey",!1),this._options=t,this._enabled=!!t.enabled,this._rendering=e}beginFrame(){}render(){}endFrame(){}getCurrentShaderKey(){return""}get enabled(){return this._enabled}set enabled(e){this._enabled=!!e}}class FeatureBloom extends Feature{constructor(){super(...arguments),__publicField(this,"name","bloom"),__publicField(this,"_lastEnabled",!1),__publicField(this,"_strength",.1),__publicField(this,"_threshold",1),__publicField(this,"_radius",0),__publicField(this,"needsFloatRenderTarget",!0)}beginFrame(){this._lastEnabled===this.enabled?this.enabled:this.enabled?this._init():this.dispose()}_init(){const e=this._rendering,t=e.resolution,i=e.main,n=e.pixelRatio;this._bloomRenderTarget=new three.WebGLRenderTarget(t.x*n,t.y*n,{type:three.HalfFloatType}),this._bloomRenderTarget.name="bloomRenderTarget";const r=new three.Vector2;r.set(t.x*n,t.y*n);const s=this._bloomRenderPass=new UnrealBloomPass(r,this._strength,this._radius,this._threshold);s.renderOrder=70,i.postprocessings.add(s),i.useMRT}afterRender(){if(this.enabled){const e=this._rendering;e.main,e.stats}}getCurrentUsedTextures(){if(this.enabled)return[this._bloomRenderTarget.texture]}endFrame(){this._lastEnabled=this.enabled}dispose(){if(this._rendering.stats,this._bloomRenderPass){this._rendering.main.postprocessings.remove(this._bloomRenderPass),this._bloomRenderPass.dispose(),this._bloomRenderPass=null}}get strength(){return this._strength}set strength(e){this._strength=e,this._bloomRenderPass&&(this._bloomRenderPass.strength=e)}get radius(){return this._radius}set radius(e){this._radius=e,this._bloomRenderPass&&(this._bloomRenderPass.radius=e)}get threshold(){return this._threshold}set threshold(e){this._threshold=e,this._bloomRenderPass&&(this._bloomRenderPass.threshold=e)}}const fragmentShader$v="\nstruct TextureInfo {\n    vec2 offset;\n    vec2 scale;\n};\nuniform sampler2D maps[MVT_TEXTURE_COUNT];\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\nuniform TextureInfo textureInfos[MVT_TEXTURE_COUNT];\n\nvoid addTextureColor(sampler2D map, TextureInfo textureInfo) {\n    vec2 transformedUv = (vUv - textureInfo.offset) * textureInfo.scale;\n    if (transformedUv.x >= 0.0 && transformedUv.x <= 1.0 && transformedUv.y >= 0.0 && transformedUv.y <= 1.0) {\n        // gl_FragColor += texture2D(map, transformedUv);\n        vec4 sampleColor = texture2D(map, transformedUv);\n        gl_FragColor.rgb = mix(sampleColor.rgb, gl_FragColor.rgb, 1.0 - sampleColor.a);\n        gl_FragColor.a += sampleColor.a;\n        // gl_FragColor = sampleColor + gl_FragColor;\n    }\n}\nvoid main() {\n\n    gl_FragColor = texture2D(tDiffuse, vUv);\n    // gl_FragColor = vec4(0.5, 0, 0, 0.5);\n    #if MVT_TEXTURE_COUNT > 0\n        addTextureColor(maps[0], textureInfos[0]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 1\n        addTextureColor(maps[1], textureInfos[1]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 2\n        addTextureColor(maps[2], textureInfos[2]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 3\n        addTextureColor(maps[3], textureInfos[3]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 4\n        addTextureColor(maps[4], textureInfos[4]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 5\n        addTextureColor(maps[5], textureInfos[5]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 6\n        addTextureColor(maps[6], textureInfos[6]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 7\n        addTextureColor(maps[7], textureInfos[7]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 8\n        addTextureColor(maps[8], textureInfos[8]);\n    #endif\n}\n";class AddTexturePass extends Pass$1{constructor(){super();const e=CopyShader;this.uniforms={tDiffuse:{value:null},textureInfos:{value:null},maps:{value:null}},this._lastTextureCount=1,this.material=new three.ShaderMaterial({defines:{MVT_TEXTURE_COUNT:1},uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:fragmentShader$v,depthTest:!1,depthWrite:!1}),this.needsSwap=!0,this.fsQuad=new FullScreenQuad(null)}render(e,t,i){const n=e.autoClear;e.autoClear=!1,this.fsQuad.material=this.material,this.material.uniforms.tDiffuse.value=i.texture,e.setRenderTarget(this.renderToScreen?null:t),e.clear(),this.fsQuad.render(e),e.autoClear=n}updateTextures(e,t){e.length===t.length?(this.uniforms.maps.value=e,this.uniforms.textureInfos.value=t,this._lastTextureCount!==t.length&&(this.material.defines.MVT_TEXTURE_COUNT=t.length,this.material.needsUpdate=!0,this._lastTextureCount=t.length)):console.warn("textures and infos length must be equal")}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class FeatureStats extends Feature{constructor(){super(...arguments),__publicField(this,"name","stats"),__publicField(this,"_lastEnabled",!1),__publicField(this,"_canvasWidth",600),__publicField(this,"_canvasHeight",320),__publicField(this,"_canvasPadding",10),__publicField(this,"_lastUpdateTime",0)}beginFrame(){this._lastEnabled===this.enabled?this.enabled&&this._updateTexture():this.enabled?this._init():this.dispose()}_init(){const e=this._rendering,t=e.pixelRatio,i=this._canvas=document.createElement("canvas");this._context=i.getContext("2d"),i.width=this._canvasWidth*t,i.height=this._canvasHeight*t,this._texture=new three.CanvasTexture(i),this._texture.generateMipmaps=!1;const n=this._renderPass=new AddTexturePass;n.renderOrder=10100,n.material.uniforms.textureInfos.value=[{offset:[.2,.2],scale:[2.5,2.5]}],n.material.uniforms.maps.value=[this._texture],e.main.postprocessings.add(this._renderPass)}_updateTexture(){const e=this._rendering,t=e.renderState;if(t.time-this._lastUpdateTime<100)return;this._lastUpdateTime=t.time;const i=e.renderer,n=e.stats,r=this._context,s=e.pixelRatio;n.beginTimeStatsItem("updateStatsTexture"),r.save(),r.scale(s,s),r.clearRect(0,0,this._canvasWidth,this._canvasHeight),r.fillStyle="rgba(0, 0, 0, .6)",r.fillRect(0,0,this._canvasWidth,this._canvasHeight),r.font="14px sans-serif",r.textAlign="right",r.fillStyle="rgb(220,220,220)";const a=n.getSortedTimeStatsItems(),o=Math.min(a.length,10);let l=this._canvasPadding+100,c=this._canvasPadding+20;r.fillText("average",l+150,c),r.fillText("lastValue",l+230,c),r.fillText("count",l+310,c),r.fillText("total",l+450,c),r.strokeStyle="rgb(130,130,130)";for(let f=0;f<o;f++){l=this._canvasPadding+100,c=this._canvasPadding+50+20*f;const e=a[f];r.fillText(e.name,l+50,c),r.fillText(e.average.toFixed(2),l+150,c),r.fillText(e.lastValue.toFixed(2),l+230,c),r.fillText(e.count.toFixed(0),l+310,c),r.fillText(e.total.toFixed(2),l+450,c),c+=5,r.beginPath(),r.moveTo(this._canvasPadding,c),r.lineTo(this._canvasWidth-this._canvasPadding,c),r.stroke()}const h=i.info;r.font="13px sans-serif",r.textAlign="left",l=this._canvasPadding,c=270,r.fillText("frame: "+h.render.frame,l,c),l+=160,r.fillText("calls: "+h.render.calls,l,c),l+=160,r.fillText("triangles: "+h.render.triangles,l,c),l+=160,r.fillText("points: "+h.render.points,l,c),l=this._canvasPadding,c+=20,r.fillText("lines: "+h.render.lines,l,c),l+=160,r.fillText("geometries: "+h.memory.geometries,l,c),l+=160,r.fillText("textures: "+h.memory.textures,l,c),l+=160,r.fillText("programs: "+h.programs.length,l,c),l=this._canvasPadding,c+=20,r.fillText("postprocessing: "+e.main.postprocessings.validCount,l,c);const u=e.main.features.features;let d="";for(const f of u)f.enabled&&(d+=f.name+" ");l+=160,r.fillText("features: "+d,l,c),l+=160,r.fillText("tasks: "+e.taskScheduler.taskCount,l,c),r.restore(),n.endTimeStatsItem("updateStatsTexture"),this._texture.needsUpdate=!0;const p=e.resolution,m=this._renderPass;m.material.uniforms.textureInfos.value[0].offset=[.5-this._canvasWidth/2/p.x,.5-this._canvasHeight/2/p.y],m.material.uniforms.textureInfos.value[0].scale=[1/(this._canvasWidth/p.x),1/(this._canvasHeight/p.y)]}afterRender(){}endFrame(){this._lastEnabled=this.enabled}dispose(){const e=this._rendering;e.stats.removeTimeStatsItem("updateStatsTexture"),e.main.postprocessings.remove(this._renderPass),this._renderPass&&this._renderPass.dispose(),this._texture&&this._texture.dispose()}}const _baseReprojectionMaterial=new three.ShaderMaterial({uniforms:{numFrames:{value:0},tLastFrame:{value:null},height:{value:1},width:{value:1},tDiffuse:{value:null},opacity:{value:1}},transparent:!0,blending:three.AdditiveBlending,depthTest:!1,depthWrite:!1,vertexShader:"\n    varying vec2 Uv;\n\n    void main() {\n        Uv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }",fragmentShader:"\n    // uniform float opacity;\n    uniform float numFrames;\n    uniform float height;\n    uniform float width;\n    uniform sampler2D tDiffuse;\n    // uniform sampler2D tMotion;\n    uniform sampler2D tLastFrame;\n    varying vec2 Uv;\n\n    void main() {\n        vec4 texel = texture2D(tDiffuse, Uv);\n        // vec4 pixelMovement = texture2D(tMotion, Uv);\n        // vec2 oldPixelUv = Uv - ((pixelMovement.xy * 2.0) - 1.0);\n        vec4 oldTexel = texture2D(tLastFrame, Uv);\n\n        // Use simple neighbor clamping\n        vec4 maxNeighbor = vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 minNeighbor = vec4(1.0);\n        vec4 average = vec4(0.0);\n\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                vec2 neighborUv = Uv + vec2(float(x) / width, float(y) / height);\n                vec4 neighborTexel = texture2D(tDiffuse, neighborUv);\n\n                maxNeighbor = max(maxNeighbor, neighborTexel);\n                minNeighbor = min(minNeighbor, neighborTexel);\n                average += neighborTexel / 9.0;\n            }\n        }\n\n\n        oldTexel = clamp(oldTexel, minNeighbor, maxNeighbor);\n\n        // UE Method to get rid of flickering. Weight frame mixing amount\n        // based on local contrast.\n        float contrast = distance(average, texel);\n        // # fix float type color range\n        contrast = clamp(contrast, 0.0, 0.1);\n        float weight = 0.1 * contrast;\n        vec4 compositeColor = mix(oldTexel, texel, weight);\n\n        gl_FragColor = compositeColor;\n    }"});class TAAPass extends Pass$1{constructor(){super(),__publicField(this,"enableRenderingJitter",!0),__publicField(this,"getCurrentUsedTextures",(()=>{const e=[];return this._scratchBuffer&&e.push(this._scratchBuffer.texture),this._oldFrameTarget&&e.push(this._oldFrameTarget.texture),e}));const e=CopyShader;this._oldClearColor=new three.Color,this.uniforms={tDiffuse:{value:null},opacity:{value:1}},this._reprojectionMaterial=_baseReprojectionMaterial.clone(),this.material=new three.ShaderMaterial({uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,depthTest:!1,depthWrite:!1}),this.needsSwap=!0,this.fsQuad=new FullScreenQuad(null),this._isFirstFrame=!0}render(e,t,i){const n=this.rendering.resolution,r=this.rendering.pixelRatio,s=this.rendering.renderState,a=e.autoClear;e.autoClear=!1;let o=null;this._oldFrameTarget||(this._oldFrameTarget=new three.WebGLRenderTarget(n.x*r,n.y*r,{})),s.viewChanged||this._isFirstFrame||this._debugEngineForceRender?(o=this.material.uniforms,o.tDiffuse.value=i.texture,o.opacity.value=1,this.fsQuad.material=this.material,e.setRenderTarget(this._oldFrameTarget),e.clear(),this.fsQuad.render(e)):(this._scratchBuffer||(this._scratchBuffer=new three.WebGLRenderTarget(n.x*r,n.y*r,{})),o=this._reprojectionMaterial.uniforms,o.tLastFrame.value=this._oldFrameTarget.texture,o.height.value=i.height,o.width.value=i.width,o.tDiffuse.value=i.texture,this.fsQuad.material=this._reprojectionMaterial,e.setRenderTarget(this._scratchBuffer),e.clear(),this.fsQuad.render(e),o=this.material.uniforms,o.tDiffuse.value=this._scratchBuffer.texture,o.opacity.value=1,this.fsQuad.material=this.material,e.setRenderTarget(this._oldFrameTarget),e.clear(),this.fsQuad.render(e),s.viewStableFrameCount<32&&this.rendering.requestRender()),o=this.material.uniforms,o.tDiffuse.value=s.viewChanged?i.texture:this._oldFrameTarget.texture,o.opacity.value=1,this.fsQuad.material=this.material,e.setRenderTarget(this.renderToScreen?null:t),e.clear(),this.fsQuad.render(e),e.autoClear=a,this._isFirstFrame=!1}dispose(){this._reprojectionMaterial.dispose(),this.material.dispose(),this.fsQuad.dispose(),this._scratchBuffer&&this._scratchBuffer.dispose(),this._oldFrameTarget&&this._oldFrameTarget.dispose()}}const FXAAShader={name:"FXAAShader",uniforms:{tDiffuse:{value:null},resolution:{value:new three.Vector2(1/1024,1/512)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 resolution;\n\t\tvarying vec2 vUv;\n\n\t\t#define EDGE_STEP_COUNT 6\n\t\t#define EDGE_GUESS 8.0\n\t\t#define EDGE_STEPS 1.0, 1.5, 2.0, 2.0, 2.0, 4.0\n\t\tconst float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );\n\n\t\tfloat _ContrastThreshold = 0.0312;\n\t\tfloat _RelativeThreshold = 0.063;\n\t\tfloat _SubpixelBlending = 1.0;\n\n\t\tvec4 Sample( sampler2D  tex2D, vec2 uv ) {\n\n\t\t\treturn texture( tex2D, uv );\n\n\t\t}\n\n\t\tfloat SampleLuminance( sampler2D tex2D, vec2 uv ) {\n\n\t\t\treturn dot( Sample( tex2D, uv ).rgb, vec3( 0.3, 0.59, 0.11 ) );\n\n\t\t}\n\n\t\tfloat SampleLuminance( sampler2D tex2D, vec2 texSize, vec2 uv, float uOffset, float vOffset ) {\n\n\t\t\tuv += texSize * vec2(uOffset, vOffset);\n\t\t\treturn SampleLuminance(tex2D, uv);\n\n\t\t}\n\n\t\tstruct LuminanceData {\n\n\t\t\tfloat m, n, e, s, w;\n\t\t\tfloat ne, nw, se, sw;\n\t\t\tfloat highest, lowest, contrast;\n\n\t\t};\n\n\t\tLuminanceData SampleLuminanceNeighborhood( sampler2D tex2D, vec2 texSize, vec2 uv ) {\n\n\t\t\tLuminanceData l;\n\t\t\tl.m = SampleLuminance( tex2D, uv );\n\t\t\tl.n = SampleLuminance( tex2D, texSize, uv,  0.0,  1.0 );\n\t\t\tl.e = SampleLuminance( tex2D, texSize, uv,  1.0,  0.0 );\n\t\t\tl.s = SampleLuminance( tex2D, texSize, uv,  0.0, -1.0 );\n\t\t\tl.w = SampleLuminance( tex2D, texSize, uv, -1.0,  0.0 );\n\n\t\t\tl.ne = SampleLuminance( tex2D, texSize, uv,  1.0,  1.0 );\n\t\t\tl.nw = SampleLuminance( tex2D, texSize, uv, -1.0,  1.0 );\n\t\t\tl.se = SampleLuminance( tex2D, texSize, uv,  1.0, -1.0 );\n\t\t\tl.sw = SampleLuminance( tex2D, texSize, uv, -1.0, -1.0 );\n\n\t\t\tl.highest = max( max( max( max( l.n, l.e ), l.s ), l.w ), l.m );\n\t\t\tl.lowest = min( min( min( min( l.n, l.e ), l.s ), l.w ), l.m );\n\t\t\tl.contrast = l.highest - l.lowest;\n\t\t\treturn l;\n\n\t\t}\n\n\t\tbool ShouldSkipPixel( LuminanceData l ) {\n\n\t\t\tfloat threshold = max( _ContrastThreshold, _RelativeThreshold * l.highest );\n\t\t\treturn l.contrast < threshold;\n\n\t\t}\n\n\t\tfloat DeterminePixelBlendFactor( LuminanceData l ) {\n\n\t\t\tfloat f = 2.0 * ( l.n + l.e + l.s + l.w );\n\t\t\tf += l.ne + l.nw + l.se + l.sw;\n\t\t\tf *= 1.0 / 12.0;\n\t\t\tf = abs( f - l.m );\n\t\t\tf = clamp( f / l.contrast, 0.0, 1.0 );\n\n\t\t\tfloat blendFactor = smoothstep( 0.0, 1.0, f );\n\t\t\treturn blendFactor * blendFactor * _SubpixelBlending;\n\n\t\t}\n\n\t\tstruct EdgeData {\n\n\t\t\tbool isHorizontal;\n\t\t\tfloat pixelStep;\n\t\t\tfloat oppositeLuminance, gradient;\n\n\t\t};\n\n\t\tEdgeData DetermineEdge( vec2 texSize, LuminanceData l ) {\n\n\t\t\tEdgeData e;\n\t\t\tfloat horizontal =\n\t\t\t\tabs( l.n + l.s - 2.0 * l.m ) * 2.0 +\n\t\t\t\tabs( l.ne + l.se - 2.0 * l.e ) +\n\t\t\t\tabs( l.nw + l.sw - 2.0 * l.w );\n\t\t\tfloat vertical =\n\t\t\t\tabs( l.e + l.w - 2.0 * l.m ) * 2.0 +\n\t\t\t\tabs( l.ne + l.nw - 2.0 * l.n ) +\n\t\t\t\tabs( l.se + l.sw - 2.0 * l.s );\n\t\t\te.isHorizontal = horizontal >= vertical;\n\n\t\t\tfloat pLuminance = e.isHorizontal ? l.n : l.e;\n\t\t\tfloat nLuminance = e.isHorizontal ? l.s : l.w;\n\t\t\tfloat pGradient = abs( pLuminance - l.m );\n\t\t\tfloat nGradient = abs( nLuminance - l.m );\n\n\t\t\te.pixelStep = e.isHorizontal ? texSize.y : texSize.x;\n\n\t\t\tif (pGradient < nGradient) {\n\n\t\t\t\te.pixelStep = -e.pixelStep;\n\t\t\t\te.oppositeLuminance = nLuminance;\n\t\t\t\te.gradient = nGradient;\n\n\t\t\t} else {\n\n\t\t\t\te.oppositeLuminance = pLuminance;\n\t\t\t\te.gradient = pGradient;\n\n\t\t\t}\n\n\t\t\treturn e;\n\n\t\t}\n\n\t\tfloat DetermineEdgeBlendFactor( sampler2D  tex2D, vec2 texSize, LuminanceData l, EdgeData e, vec2 uv ) {\n\n\t\t\tvec2 uvEdge = uv;\n\t\t\tvec2 edgeStep;\n\t\t\tif (e.isHorizontal) {\n\n\t\t\t\tuvEdge.y += e.pixelStep * 0.5;\n\t\t\t\tedgeStep = vec2( texSize.x, 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\tuvEdge.x += e.pixelStep * 0.5;\n\t\t\t\tedgeStep = vec2( 0.0, texSize.y );\n\n\t\t\t}\n\n\t\t\tfloat edgeLuminance = ( l.m + e.oppositeLuminance ) * 0.5;\n\t\t\tfloat gradientThreshold = e.gradient * 0.25;\n\n\t\t\tvec2 puv = uvEdge + edgeStep * edgeSteps[0];\n\t\t\tfloat pLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\n\t\t\tbool pAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\n\n\t\t\tfor ( int i = 1; i < EDGE_STEP_COUNT && !pAtEnd; i++ ) {\n\n\t\t\t\tpuv += edgeStep * edgeSteps[i];\n\t\t\t\tpLuminanceDelta = SampleLuminance( tex2D, puv ) - edgeLuminance;\n\t\t\t\tpAtEnd = abs( pLuminanceDelta ) >= gradientThreshold;\n\n\t\t\t}\n\n\t\t\tif ( !pAtEnd ) {\n\n\t\t\t\tpuv += edgeStep * EDGE_GUESS;\n\n\t\t\t}\n\n\t\t\tvec2 nuv = uvEdge - edgeStep * edgeSteps[0];\n\t\t\tfloat nLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\n\t\t\tbool nAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\n\n\t\t\tfor ( int i = 1; i < EDGE_STEP_COUNT && !nAtEnd; i++ ) {\n\n\t\t\t\tnuv -= edgeStep * edgeSteps[i];\n\t\t\t\tnLuminanceDelta = SampleLuminance( tex2D, nuv ) - edgeLuminance;\n\t\t\t\tnAtEnd = abs( nLuminanceDelta ) >= gradientThreshold;\n\n\t\t\t}\n\n\t\t\tif ( !nAtEnd ) {\n\n\t\t\t\tnuv -= edgeStep * EDGE_GUESS;\n\n\t\t\t}\n\n\t\t\tfloat pDistance, nDistance;\n\t\t\tif ( e.isHorizontal ) {\n\n\t\t\t\tpDistance = puv.x - uv.x;\n\t\t\t\tnDistance = uv.x - nuv.x;\n\n\t\t\t} else {\n\n\t\t\t\tpDistance = puv.y - uv.y;\n\t\t\t\tnDistance = uv.y - nuv.y;\n\n\t\t\t}\n\n\t\t\tfloat shortestDistance;\n\t\t\tbool deltaSign;\n\t\t\tif ( pDistance <= nDistance ) {\n\n\t\t\t\tshortestDistance = pDistance;\n\t\t\t\tdeltaSign = pLuminanceDelta >= 0.0;\n\n\t\t\t} else {\n\n\t\t\t\tshortestDistance = nDistance;\n\t\t\t\tdeltaSign = nLuminanceDelta >= 0.0;\n\n\t\t\t}\n\n\t\t\tif ( deltaSign == ( l.m - edgeLuminance >= 0.0 ) ) {\n\n\t\t\t\treturn 0.0;\n\n\t\t\t}\n\n\t\t\treturn 0.5 - shortestDistance / ( pDistance + nDistance );\n\n\t\t}\n\n\t\tvec4 ApplyFXAA( sampler2D  tex2D, vec2 texSize, vec2 uv ) {\n\n\t\t\tLuminanceData luminance = SampleLuminanceNeighborhood( tex2D, texSize, uv );\n\t\t\tif ( ShouldSkipPixel( luminance ) ) {\n\n\t\t\t\treturn Sample( tex2D, uv );\n\n\t\t\t}\n\n\t\t\tfloat pixelBlend = DeterminePixelBlendFactor( luminance );\n\t\t\tEdgeData edge = DetermineEdge( texSize, luminance );\n\t\t\tfloat edgeBlend = DetermineEdgeBlendFactor( tex2D, texSize, luminance, edge, uv );\n\t\t\tfloat finalBlend = max( pixelBlend, edgeBlend );\n\n\t\t\tif (edge.isHorizontal) {\n\n\t\t\t\tuv.y += edge.pixelStep * finalBlend;\n\n\t\t\t} else {\n\n\t\t\t\tuv.x += edge.pixelStep * finalBlend;\n\n\t\t\t}\n\n\t\t\treturn Sample( tex2D, uv );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = ApplyFXAA( tDiffuse, resolution.xy, vUv );\n\n\t\t}"},SMAAEdgesShader={name:"SMAAEdgesShader",defines:{SMAA_THRESHOLD:"0.1"},uniforms:{tDiffuse:{value:null},resolution:{value:new three.Vector2(1/1024,1/512)}},vertexShader:"\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvoid SMAAEdgeDetectionVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAAEdgeDetectionVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n\t\t\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\n\t\t\t// Calculate color deltas:\n\t\t\tvec4 delta;\n\t\t\tvec3 C = texture2D( colorTex, texcoord ).rgb;\n\n\t\t\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n\t\t\tvec3 t = abs( C - Cleft );\n\t\t\tdelta.x = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n\t\t\tt = abs( C - Ctop );\n\t\t\tdelta.y = max( max( t.r, t.g ), t.b );\n\n\t\t\t// We do the usual threshold:\n\t\t\tvec2 edges = step( threshold, delta.xy );\n\n\t\t\t// Then discard if there is no edge:\n\t\t\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n\t\t\t\tdiscard;\n\n\t\t\t// Calculate right and bottom deltas:\n\t\t\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n\t\t\tt = abs( C - Cright );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n\t\t\tt = abs( C - Cbottom );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the maximum delta in the direct neighborhood:\n\t\t\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n\t\t\t// Calculate left-left and top-top deltas:\n\t\t\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n\t\t\tt = abs( C - Cleftleft );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n\t\t\tt = abs( C - Ctoptop );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the final maximum delta:\n\t\t\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n\t\t\t// Local contrast adaptation in action:\n\t\t\tedges.xy *= step( 0.5 * maxDelta, delta.xy );\n\n\t\t\treturn vec4( edges, 0.0, 0.0 );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n\n\t\t}"},SMAAWeightsShader={name:"SMAAWeightsShader",defines:{SMAA_MAX_SEARCH_STEPS:"8",SMAA_AREATEX_MAX_DISTANCE:"16",SMAA_AREATEX_PIXEL_SIZE:"( 1.0 / vec2( 160.0, 560.0 ) )",SMAA_AREATEX_SUBTEX_SIZE:"( 1.0 / 7.0 )"},uniforms:{tDiffuse:{value:null},tArea:{value:null},tSearch:{value:null},resolution:{value:new three.Vector2(1/1024,1/512)}},vertexShader:"\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\t\tvarying vec2 vPixcoord;\n\n\t\tvoid SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n\t\t\tvPixcoord = texcoord / resolution;\n\n\t\t\t// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components\n\n\t\t\t// And these for the searches, they indicate the ends of the loops:\n\t\t\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAABlendingWeightCalculationVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\t#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tArea;\n\t\tuniform sampler2D tSearch;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[3];\n\t\tvarying vec2 vPixcoord;\n\n\t\t#if __VERSION__ == 100\n\t\tvec2 round( vec2 x ) {\n\t\t\treturn sign( x ) * floor( abs( x ) + 0.5 );\n\t\t}\n\t\t#endif\n\n\t\tfloat SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n\t\t\t// Not required if searchTex accesses are set to point:\n\t\t\t// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n\t\t\t// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n\t\t\t//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n\t\t\te.r = bias + e.r * scale;\n\t\t\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n\t\t}\n\n\t\tfloat SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\t/**\n\t\t\t\t* @PSEUDO_GATHER4\n\t\t\t\t* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n\t\t\t\t* sample between edge, thus fetching four edges in a row.\n\t\t\t\t* Sampling with different offsets in each direction allows to disambiguate\n\t\t\t\t* which edges are active from the four fetched ones.\n\t\t\t\t*/\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\t// We correct the previous (-0.25, -0.125) offset we applied:\n\t\t\ttexcoord.x += 0.25 * resolution.x;\n\n\t\t\t// The searches are bias by 1, so adjust the coords accordingly:\n\t\t\ttexcoord.x += resolution.x;\n\n\t\t\t// Disambiguate the length added by the last step:\n\t\t\ttexcoord.x += 2.0 * resolution.x; // Undo last step\n\t\t\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.x -= 0.25 * resolution.x;\n\t\t\ttexcoord.x -= resolution.x;\n\t\t\ttexcoord.x -= 2.0 * resolution.x;\n\t\t\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tfloat SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tvec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n\t\t\t// Rounding prevents precision errors of bilinear filtering:\n\t\t\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\n\t\t\t// We do a scale and bias for mapping to texel space:\n\t\t\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\n\t\t\t// Move to proper place, according to the subpixel offset:\n\t\t\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n\t\t\treturn texture2D( areaTex, texcoord, 0.0 ).rg;\n\t\t}\n\n\t\tvec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n\t\t\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tvec2 e = texture2D( edgesTex, texcoord ).rg;\n\n\t\t\tif ( e.g > 0.0 ) { // Edge at north\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the left:\n\t\t\t\tvec2 coords;\n\t\t\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n\t\t\t\tcoords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n\t\t\t\td.x = coords.x;\n\n\t\t\t\t// Now fetch the left crossing edges, two at a time using bilinear\n\t\t\t\t// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n\t\t\t\t// discern what value each edge has:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\n\t\t\t\t// Find the distance to the right:\n\t\t\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n\t\t\t\td.y = coords.x;\n\n\t\t\t\t// We want the distances to be in pixel units (doing this here allow to\n\t\t\t\t// better interleave arithmetic and memory accesses):\n\t\t\t\td = d / resolution.x - pixcoord.x;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the right crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\n\t\t\t\t// Ok, we know how this pattern looks like, now it is time for getting\n\t\t\t\t// the actual area:\n\t\t\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n\t\t\t}\n\n\t\t\tif ( e.r > 0.0 ) { // Edge at west\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the top:\n\t\t\t\tvec2 coords;\n\n\t\t\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n\t\t\t\tcoords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;\n\t\t\t\td.x = coords.y;\n\n\t\t\t\t// Fetch the top crossing edges:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\n\t\t\t\t// Find the distance to the bottom:\n\t\t\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n\t\t\t\td.y = coords.y;\n\n\t\t\t\t// We want the distances to be in pixel units:\n\t\t\t\td = d / resolution.y - pixcoord.y;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the bottom crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\n\t\t\t\t// Get the area for this direction:\n\t\t\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\t\t\t}\n\n\t\t\treturn weights;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n\n\t\t}"},SMAABlendShader={name:"SMAABlendShader",uniforms:{tDiffuse:{value:null},tColor:{value:null},resolution:{value:new three.Vector2(1/1024,1/512)}},vertexShader:"\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvoid SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAANeighborhoodBlendingVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tColor;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n\t\t\t// Fetch the blending weights for current pixel:\n\t\t\tvec4 a;\n\t\t\ta.xz = texture2D( blendTex, texcoord ).xz;\n\t\t\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n\t\t\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\n\t\t\t// Is there any blending weight with a value greater than 0.0?\n\t\t\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n\t\t\t\treturn texture2D( colorTex, texcoord, 0.0 );\n\t\t\t} else {\n\t\t\t\t// Up to 4 lines can be crossing a pixel (one through each edge). We\n\t\t\t\t// favor blending by choosing the line with the maximum weight for each\n\t\t\t\t// direction:\n\t\t\t\tvec2 offset;\n\t\t\t\toffset.x = a.a > a.b ? a.a : -a.b; // left vs. right\n\t\t\t\toffset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs\n\n\t\t\t\t// Then we go in the direction that has the maximum weight:\n\t\t\t\tif ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical\n\t\t\t\t\toffset.y = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\toffset.x = 0.0;\n\t\t\t\t}\n\n\t\t\t\t// Fetch the opposite color and lerp by hand:\n\t\t\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\ttexcoord += sign( offset ) * resolution;\n\t\t\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\n\t\t\t\t// WebGL port note: Added gamma correction\n\t\t\t\tC.xyz = pow(C.xyz, vec3(2.2));\n\t\t\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));\n\t\t\t\tvec4 mixed = mix(C, Cop, s);\n\t\t\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\n\n\t\t\t\treturn mixed;\n\t\t\t}\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n\n\t\t}"};class SMAAPass extends Pass$1{constructor(){super(),this._edgesRT=new three.WebGLRenderTarget(1,1,{depthBuffer:!1,type:three.HalfFloatType}),this._edgesRT.texture.name="SMAAPass.edges",this._weightsRT=new three.WebGLRenderTarget(1,1,{depthBuffer:!1,type:three.HalfFloatType}),this._weightsRT.texture.name="SMAAPass.weights";const e=this,t=new Image;t.src=this._getAreaTexture(),t.onload=function(){e._areaTexture.needsUpdate=!0},this._areaTexture=new three.Texture,this._areaTexture.name="SMAAPass.area",this._areaTexture.image=t,this._areaTexture.minFilter=three.LinearFilter,this._areaTexture.generateMipmaps=!1,this._areaTexture.flipY=!1;const i=new Image;i.src=this._getSearchTexture(),i.onload=function(){e._searchTexture.needsUpdate=!0},this._searchTexture=new three.Texture,this._searchTexture.name="SMAAPass.search",this._searchTexture.image=i,this._searchTexture.magFilter=three.NearestFilter,this._searchTexture.minFilter=three.NearestFilter,this._searchTexture.generateMipmaps=!1,this._searchTexture.flipY=!1,this._uniformsEdges=three.UniformsUtils.clone(SMAAEdgesShader.uniforms),this._materialEdges=new three.ShaderMaterial({defines:Object.assign({},SMAAEdgesShader.defines),uniforms:this._uniformsEdges,vertexShader:SMAAEdgesShader.vertexShader,fragmentShader:SMAAEdgesShader.fragmentShader}),this._uniformsWeights=three.UniformsUtils.clone(SMAAWeightsShader.uniforms),this._uniformsWeights.tDiffuse.value=this._edgesRT.texture,this._uniformsWeights.tArea.value=this._areaTexture,this._uniformsWeights.tSearch.value=this._searchTexture,this._materialWeights=new three.ShaderMaterial({defines:Object.assign({},SMAAWeightsShader.defines),uniforms:this._uniformsWeights,vertexShader:SMAAWeightsShader.vertexShader,fragmentShader:SMAAWeightsShader.fragmentShader}),this._uniformsBlend=three.UniformsUtils.clone(SMAABlendShader.uniforms),this._uniformsBlend.tDiffuse.value=this._weightsRT.texture,this._materialBlend=new three.ShaderMaterial({uniforms:this._uniformsBlend,vertexShader:SMAABlendShader.vertexShader,fragmentShader:SMAABlendShader.fragmentShader}),this._fsQuad=new FullScreenQuad(null)}render(e,t,i){this._uniformsEdges.tDiffuse.value=i.texture,this._fsQuad.material=this._materialEdges,e.setRenderTarget(this._edgesRT),this.clear&&e.clear(),this._fsQuad.render(e),this._fsQuad.material=this._materialWeights,e.setRenderTarget(this._weightsRT),this.clear&&e.clear(),this._fsQuad.render(e),this._uniformsBlend.tColor.value=i.texture,this._fsQuad.material=this._materialBlend,this.renderToScreen?(e.setRenderTarget(null),this._fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(),this._fsQuad.render(e))}setSize(e,t){this._edgesRT.setSize(e,t),this._weightsRT.setSize(e,t),this._materialEdges.uniforms.resolution.value.set(1/e,1/t),this._materialWeights.uniforms.resolution.value.set(1/e,1/t),this._materialBlend.uniforms.resolution.value.set(1/e,1/t)}dispose(){this._edgesRT.dispose(),this._weightsRT.dispose(),this._areaTexture.dispose(),this._searchTexture.dispose(),this._materialEdges.dispose(),this._materialWeights.dispose(),this._materialBlend.dispose(),this._fsQuad.dispose()}_getAreaTexture(){return"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII="}_getSearchTexture(){return"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII="}}class FeatureAntialias extends Feature{constructor(e,t){super(e,t),__publicField(this,"name","AA"),__publicField(this,"_method","msaa"),__publicField(this,"_lastMethod","msaa"),__publicField(this,"_lastEnabled",!1),__publicField(this,"_lastUseMRT",!1),__publicField(this,"_samples",0),this.enabled=t.enabled,this._method=t.method}beginFrame(){this._lastEnabled===this.enabled?this.enabled&&this._lastMethod!==this._method&&(this._disableOldMethod(),this._enableNewMethod()):this.enabled?this._enableNewMethod():this._disableOldMethod()}_disableOldMethod(){const e=this._lastMethod,t=this._rendering;"msaa"===e?(t.updateContextParameters({antialias:!1}),t.main.sceneRendering.updateRenderTargetSamples(0),this._samples=0):"fxaa"===e?(this._fxaaPass&&t.main.postprocessings.remove(this._fxaaPass),this._fxaaPass=null):"taa"===e?(this._taaPass&&t.main.postprocessings.remove(this._taaPass),this._taaPass=null):"smaa"===e&&(this._smaaPass&&t.main.postprocessings.remove(this._smaaPass),this._smaaPass=null)}_enableNewMethod(){const e=this._method,t=this._rendering;if("msaa"===e)t.updateContextParameters({antialias:!0}),t.main.sceneRendering.updateRenderTargetSamples(4),this._samples=4;else if("fxaa"===e){const e=this._fxaaPass=new ShaderPass(FXAAShader),i=t.resolution,n=t.pixelRatio;e.uniforms.resolution.value.set(1/i.x/n,1/i.y/n),e.renderOrder=80,t.main.postprocessings.add(e)}else if("taa"===e){const e=this._taaPass=new TAAPass;e.rendering=t,e.renderOrder=80,t.main.postprocessings.add(e)}else if("smaa"===e){const e=t.resolution,i=t.pixelRatio,n=this._smaaPass=new SMAAPass(e.x*i,e.y*i);n.renderOrder=80,t.main.postprocessings.add(n)}else console.warn("Unknown antialias method:",e)}afterRender(){}endFrame(){this._lastEnabled=this.enabled,this._lastMethod=this._method}dispose(){this.enabled&&"msaa"!==this._method&&this._disableOldMethod()}get method(){return this._method}set method(e){this._method=e}get samples(){return this._samples}}class FeatureBufferView extends Feature{constructor(e,t={}){super(e,t),__publicField(this,"name","bufferView"),__publicField(this,"_lastEnabled",!1),__publicField(this,"_offset",0),__publicField(this,"_currentFrameTextures",[]),this._offset=t.offset||0}beginFrame(){this._lastEnabled===this.enabled||(this.enabled?this._init():this.dispose())}_init(){const e=this._rendering,t=this._renderPass=new AddTexturePass;t.renderOrder=10900,t.material.uniforms.textureInfos.value=[{offset:[.2,.2],scale:[2.5,2.5]}],t.material.uniforms.maps.value=[],e.main.postprocessings.add(this._renderPass)}afterRender(){if(!this.enabled)return;const e=[],t=this._rendering,i=t.main.sceneRendering;i.diffuseTexture&&e.push(i.diffuseTexture),i.emissiveTexture&&e.push(i.emissiveTexture),i.normalTexture&&e.push(i.normalTexture),i.depthTexture&&e.push(i.depthTexture),i.metallicRoughTexture&&e.push(i.metallicRoughTexture);const n=t.main.features.features||[];for(let l=0;l<n.length;l++){const t=n[l];if(t.enabled&&t.getCurrentUsedTextures){const i=t.getCurrentUsedTextures();i&&e.push(...i)}}const r=t.main.opaquePostprocessings.postprocessings||[];for(let l=0;l<r.length;l++){const t=r[l];if(t.getCurrentUsedTextures){const i=t.getCurrentUsedTextures();i&&e.push(...i)}}const s=t.main.postprocessings.postprocessings||[];for(let l=0;l<s.length;l++){const t=s[l];if(t.getCurrentUsedTextures){const i=t.getCurrentUsedTextures();i&&e.push(...i)}}this._currentFrameTextures.length>0&&e.push(...this._currentFrameTextures);const a=[],o=e.slice(this._offset,this._offset+4);if(0!==o.length){for(let e=0;e<o.length;e++)a.push({offset:[.25*e,.25*Math.floor(e/4)],scale:[4,4]});this._renderPass.updateTextures(o,a)}}endFrame(){this._lastEnabled=this.enabled,this._currentFrameTextures.length=0}addCurrentFrameTexture(e){this.enabled&&this._currentFrameTextures.push(e)}dispose(){this._rendering.main.postprocessings.remove(this._renderPass),this._renderPass&&this._renderPass.dispose()}get offset(){return this._offset}set offset(e){this._offset=e}}class SimplexNoise{constructor(e=Math){this.grad3=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],this.grad4=[[0,1,1,1],[0,1,1,-1],[0,1,-1,1],[0,1,-1,-1],[0,-1,1,1],[0,-1,1,-1],[0,-1,-1,1],[0,-1,-1,-1],[1,0,1,1],[1,0,1,-1],[1,0,-1,1],[1,0,-1,-1],[-1,0,1,1],[-1,0,1,-1],[-1,0,-1,1],[-1,0,-1,-1],[1,1,0,1],[1,1,0,-1],[1,-1,0,1],[1,-1,0,-1],[-1,1,0,1],[-1,1,0,-1],[-1,-1,0,1],[-1,-1,0,-1],[1,1,1,0],[1,1,-1,0],[1,-1,1,0],[1,-1,-1,0],[-1,1,1,0],[-1,1,-1,0],[-1,-1,1,0],[-1,-1,-1,0]],this.p=[];for(let t=0;t<256;t++)this.p[t]=Math.floor(256*e.random());this.perm=[];for(let t=0;t<512;t++)this.perm[t]=this.p[255&t];this.simplex=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]}noise(e,t){let i,n,r;const s=(e+t)*(.5*(Math.sqrt(3)-1)),a=Math.floor(e+s),o=Math.floor(t+s),l=(3-Math.sqrt(3))/6,c=(a+o)*l,h=e-(a-c),u=t-(o-c);let d,p;h>u?(d=1,p=0):(d=0,p=1);const m=h-d+l,f=u-p+l,g=h-1+2*l,_=u-1+2*l,A=255&a,v=255&o,y=this.perm[A+this.perm[v]]%12,x=this.perm[A+d+this.perm[v+p]]%12,b=this.perm[A+1+this.perm[v+1]]%12;let S=.5-h*h-u*u;S<0?i=0:(S*=S,i=S*S*this._dot(this.grad3[y],h,u));let C=.5-m*m-f*f;C<0?n=0:(C*=C,n=C*C*this._dot(this.grad3[x],m,f));let T=.5-g*g-_*_;return T<0?r=0:(T*=T,r=T*T*this._dot(this.grad3[b],g,_)),70*(i+n+r)}noise3d(e,t,i){let n,r,s,a;const o=(e+t+i)*(1/3),l=Math.floor(e+o),c=Math.floor(t+o),h=Math.floor(i+o),u=1/6,d=(l+c+h)*u,p=e-(l-d),m=t-(c-d),f=i-(h-d);let g,_,A,v,y,x;p>=m?m>=f?(g=1,_=0,A=0,v=1,y=1,x=0):p>=f?(g=1,_=0,A=0,v=1,y=0,x=1):(g=0,_=0,A=1,v=1,y=0,x=1):m<f?(g=0,_=0,A=1,v=0,y=1,x=1):p<f?(g=0,_=1,A=0,v=0,y=1,x=1):(g=0,_=1,A=0,v=1,y=1,x=0);const b=p-g+u,S=m-_+u,C=f-A+u,T=p-v+2*u,E=m-y+2*u,M=f-x+2*u,w=p-1+.5,I=m-1+.5,P=f-1+.5,R=255&l,B=255&c,D=255&h,F=this.perm[R+this.perm[B+this.perm[D]]]%12,O=this.perm[R+g+this.perm[B+_+this.perm[D+A]]]%12,L=this.perm[R+v+this.perm[B+y+this.perm[D+x]]]%12,N=this.perm[R+1+this.perm[B+1+this.perm[D+1]]]%12;let V=.6-p*p-m*m-f*f;V<0?n=0:(V*=V,n=V*V*this._dot3(this.grad3[F],p,m,f));let U=.6-b*b-S*S-C*C;U<0?r=0:(U*=U,r=U*U*this._dot3(this.grad3[O],b,S,C));let k=.6-T*T-E*E-M*M;k<0?s=0:(k*=k,s=k*k*this._dot3(this.grad3[L],T,E,M));let G=.6-w*w-I*I-P*P;return G<0?a=0:(G*=G,a=G*G*this._dot3(this.grad3[N],w,I,P)),32*(n+r+s+a)}noise4d(e,t,i,n){const r=this.grad4,s=this.simplex,a=this.perm,o=(Math.sqrt(5)-1)/4,l=(5-Math.sqrt(5))/20;let c,h,u,d,p;const m=(e+t+i+n)*o,f=Math.floor(e+m),g=Math.floor(t+m),_=Math.floor(i+m),A=Math.floor(n+m),v=(f+g+_+A)*l,y=e-(f-v),x=t-(g-v),b=i-(_-v),S=n-(A-v),C=(y>x?32:0)+(y>b?16:0)+(x>b?8:0)+(y>S?4:0)+(x>S?2:0)+(b>S?1:0),T=s[C][0]>=3?1:0,E=s[C][1]>=3?1:0,M=s[C][2]>=3?1:0,w=s[C][3]>=3?1:0,I=s[C][0]>=2?1:0,P=s[C][1]>=2?1:0,R=s[C][2]>=2?1:0,B=s[C][3]>=2?1:0,D=s[C][0]>=1?1:0,F=s[C][1]>=1?1:0,O=s[C][2]>=1?1:0,L=s[C][3]>=1?1:0,N=y-T+l,V=x-E+l,U=b-M+l,k=S-w+l,G=y-I+2*l,z=x-P+2*l,j=b-R+2*l,Q=S-B+2*l,H=y-D+3*l,$=x-F+3*l,W=b-O+3*l,q=S-L+3*l,Y=y-1+4*l,X=x-1+4*l,Z=b-1+4*l,K=S-1+4*l,J=255&f,ee=255&g,te=255&_,ie=255&A,ne=a[J+a[ee+a[te+a[ie]]]]%32,re=a[J+T+a[ee+E+a[te+M+a[ie+w]]]]%32,se=a[J+I+a[ee+P+a[te+R+a[ie+B]]]]%32,ae=a[J+D+a[ee+F+a[te+O+a[ie+L]]]]%32,oe=a[J+1+a[ee+1+a[te+1+a[ie+1]]]]%32;let le=.6-y*y-x*x-b*b-S*S;le<0?c=0:(le*=le,c=le*le*this._dot4(r[ne],y,x,b,S));let ce=.6-N*N-V*V-U*U-k*k;ce<0?h=0:(ce*=ce,h=ce*ce*this._dot4(r[re],N,V,U,k));let he=.6-G*G-z*z-j*j-Q*Q;he<0?u=0:(he*=he,u=he*he*this._dot4(r[se],G,z,j,Q));let ue=.6-H*H-$*$-W*W-q*q;ue<0?d=0:(ue*=ue,d=ue*ue*this._dot4(r[ae],H,$,W,q));let de=.6-Y*Y-X*X-Z*Z-K*K;return de<0?p=0:(de*=de,p=de*de*this._dot4(r[oe],Y,X,Z,K)),27*(c+h+u+d+p)}_dot(e,t,i){return e[0]*t+e[1]*i}_dot3(e,t,i,n){return e[0]*t+e[1]*i+e[2]*n}_dot4(e,t,i,n,r){return e[0]*t+e[1]*i+e[2]*n+e[3]*r}}new three.Vector2,new three.Matrix4,new three.Matrix4;const SSAOBlurShader={name:"SSAOBlurShader",uniforms:{tDiffuse:{value:null},resolution:{value:new three.Vector2}},vertexShader:"varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"uniform sampler2D tDiffuse;\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 texelSize = ( 1.0 / resolution );\n\t\t\tfloat result = 0.0;\n\n\t\t\tfor ( int i = - 2; i <= 2; i ++ ) {\n\n\t\t\t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n\t\t\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n\t\t\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n\t\t}"},SSAOShader={defines:{PERSPECTIVE_CAMERA:1,KERNEL_SIZE:32},uniforms:{tDiffuse:{value:null},tNormal:{value:null},tDepth:{value:null},tNoise:{value:null},kernel:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new three.Vector2},cameraProjectionMatrix:{value:new three.Matrix4},cameraInverseProjectionMatrix:{value:new three.Matrix4},kernelRadius:{value:.1},minDistance:{value:1e-4},maxDistance:{value:1e3},intensity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\n\t\tuniform vec3 kernel[ KERNEL_SIZE ];\n\n\t\tuniform vec2 resolution;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float kernelRadius;\n\t\tuniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\tuniform float maxDistance; // avoid the influence of fragments which are too far away\n        uniform float intensity;\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n        float linearize_depth(in float depth){\n            float a = cameraFar / (cameraFar - cameraNear);\n            float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n            return a + b / depth;\n        }\n\n        float reconstruct_depth(const in vec2 uv){\n            float depth = texture2D(tDepth, uv).x;\n            return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n        }\n\n        float getDepth(vec2 uv) {\n            #if defined( USE_LOGDEPTHBUF )\n                return linearize_depth(reconstruct_depth(uv));\n            #else\n                return texture2D(tDepth, uv).x;\n            #endif\n        }\n\t\t// float getDepth( const in vec2 screenPosition ) {\n\n\t\t// \treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t// }\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\t// float fragCoordZ = texture2D( tDepth, screenPosition ).x;\n                float fragCoordZ = getDepth(screenPosition);\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec2 screenPosition ) {\n\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n\t\t}\n\n\t\tvoid main() {\n\n            vec3 sampleNormal = texture2D( tNormal, vUv ).xyz;\n            if (length(sampleNormal) < 0.5) {\n                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n                return;\n            }\n            vec3 viewNormal = unpackRGBToNormal(sampleNormal);\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n            // float depth = texture2D( tDepth, vUv ).x;\n            // float logDepthBufFC = 2.0 / ( log( cameraFar + 1.0 ) / log(2.0) );\n            // float viewZ = -1.0 * (exp2(depth / (logDepthBufFC * 0.5)) - 1.0);\n\n\t\t\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n\n\t\t\tvec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n\t\t\tvec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );\n\n\t\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n\t\t\tvec3 bitangent = cross( viewNormal, tangent );\n\t\t\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n\t\t float occlusion = 0.0;\n\n\t\t for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n\t\t\t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n\t\t\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n\t\t\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\n                // project point and calculate NDC\n\t\t\t\tsamplePointNDC /= samplePointNDC.w;\n\n\t\t\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n\t\t\t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n\t\t\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\n\n                // realDepth = getDepth(samplePointUv);\n                // // realDepth = reconstruct_depth(samplePointUv);\n                // sampleDepth = viewZToPerspectiveDepth(samplePoint.z, cameraNear, cameraFar);\n\n                // sampleDepth = log2(sampleDepth + 1.0) / log2(cameraFar + 1.0);\n                // compute linear depth of the sample view Z value\n\t\t\t\tfloat delta = sampleDepth - realDepth;\n\n\t\t\t\tif ( delta > minDistance && delta < maxDistance ) {\n                // if ( delta > 0.00001 && delta < 0.0001) {\n                    // if fragment is before sample point, increase occlusion\n\n                    // occlusion += 1.0;\n\t\t\t\t\tocclusion += 1.0 * length(sampleVector) * intensity;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n\t\t\tgl_FragColor = vec4( vec3((1.0 - occlusion) ), 1.0 );\n\n\t\t}"};class SSAOPass extends Pass$1{constructor(e,t){super(),this.width=void 0!==e?e:512,this.height=void 0!==t?t:512,this.clear=!0,this.kernelRadius=.5,this.kernelSize=32,this.kernel=[],this.noiseTexture=null,this.intensity=1,this.minDistance=1e-5,this.maxDistance=1e-4,this.generateSampleKernel(),this.generateRandomKernelRotations(),this.ssaoMaterial=new three.ShaderMaterial({defines:Object.assign({},SSAOShader.defines),uniforms:three.UniformsUtils.clone(SSAOShader.uniforms),vertexShader:SSAOShader.vertexShader,fragmentShader:SSAOShader.fragmentShader,blending:three.NoBlending}),this.ssaoMaterial.uniforms.tNoise.value=this.noiseTexture,this.ssaoMaterial.uniforms.kernel.value=this.kernel,this.blurMaterial=new three.ShaderMaterial({defines:Object.assign({},SSAOBlurShader.defines),uniforms:three.UniformsUtils.clone(SSAOBlurShader.uniforms),vertexShader:SSAOBlurShader.vertexShader,fragmentShader:SSAOBlurShader.fragmentShader}),this.copyMaterial=new three.ShaderMaterial({uniforms:three.UniformsUtils.clone(CopyShader.uniforms),vertexShader:CopyShader.vertexShader,fragmentShader:CopyShader.fragmentShader,transparent:!0,depthTest:!1,depthWrite:!1,blendSrc:three.DstColorFactor,blendDst:three.ZeroFactor,blendEquation:three.AddEquation,blendSrcAlpha:three.DstAlphaFactor,blendDstAlpha:three.ZeroFactor,blendEquationAlpha:three.AddEquation}),this.fsQuad=new FullScreenQuad(null),this.originalClearColor=new three.Color,this.needsNormalTexture=!0,this.needsDepthTexture=!0}dispose(){this.ssaoRenderTarget.dispose(),this.blurRenderTarget.dispose(),this.normalMaterial.dispose(),this.blurMaterial.dispose(),this.copyMaterial.dispose(),this.depthRenderMaterial.dispose(),this.fsQuad.dispose()}render(e,t,i){this.ssaoRenderTarget||(this.ssaoRenderTarget=new three.WebGLRenderTarget(i.width,i.height,{})),this.blurRenderTarget||(this.blurRenderTarget=new three.WebGLRenderTarget(i.width,i.height,{}));const n=this.rendering,r=n.main.sceneRendering.normalTexture,s=n.main.sceneRendering.depthTexture;this.ssaoMaterial.uniforms.tDiffuse.value=i.texture,this.ssaoMaterial.uniforms.tNormal.value=r,this.ssaoMaterial.uniforms.tDepth.value=s,this.ssaoMaterial.uniforms.cameraNear.value=n.camera.near,this.ssaoMaterial.uniforms.cameraFar.value=n.camera.far,this.ssaoMaterial.uniforms.resolution.value.set(i.width,i.height),this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(n.camera.projectionMatrix),this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(n.camera.projectionMatrixInverse),this.ssaoMaterial.uniforms.kernelRadius.value=this.kernelRadius,this.ssaoMaterial.uniforms.minDistance.value=this.minDistance,this.ssaoMaterial.uniforms.maxDistance.value=this.maxDistance,this.ssaoMaterial.uniforms.intensity.value=this.intensity,this.renderPass(e,this.ssaoMaterial,this.ssaoRenderTarget),this.blurMaterial.uniforms.resolution.value.set(i.width,i.height),this.blurMaterial.uniforms.tDiffuse.value=this.ssaoRenderTarget.texture,this.renderPass(e,this.blurMaterial,this.blurRenderTarget),this.copyMaterial.uniforms.tDiffuse.value=i.texture,this.copyMaterial.blending=three.NoBlending,this.renderPass(e,this.copyMaterial,this.renderToScreen?null:t),this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget.texture,this.copyMaterial.blending=three.CustomBlending,this.renderPass(e,this.copyMaterial,this.renderToScreen?null:t)}renderPass(e,t,i,n,r){e.getClearColor(this.originalClearColor);const s=e.getClearAlpha(),a=e.autoClear;e.setRenderTarget(i),e.autoClear=!1,null!=n&&(e.setClearColor(n),e.setClearAlpha(r||0),e.clear()),this.fsQuad.material=t,this.fsQuad.render(e),e.autoClear=a,e.setClearColor(this.originalClearColor),e.setClearAlpha(s)}setSize(e,t){this.width=e,this.height=t,this.ssaoRenderTarget.setSize(e,t),this.blurRenderTarget.setSize(e,t)}generateSampleKernel(){const e=this.kernelSize,t=this.kernel;for(let i=0;i<e;i++){const n=new three.Vector3;n.x=2*Math.random()-1,n.y=2*Math.random()-1,n.z=Math.random(),n.normalize();let r=i/e;r=three.MathUtils.lerp(.1,1,r*r),n.multiplyScalar(r),t.push(n)}}generateRandomKernelRotations(){const e=new SimplexNoise,t=new Float32Array(16);for(let i=0;i<16;i++){const n=2*Math.random()-1,r=2*Math.random()-1,s=0;t[i]=e.noise3d(n,r,s)}this.noiseTexture=new three.DataTexture(t,4,4,three.RedFormat,three.FloatType),this.noiseTexture.wrapS=three.RepeatWrapping,this.noiseTexture.wrapT=three.RepeatWrapping,this.noiseTexture.needsUpdate=!0}}class FeatureAo extends Feature{constructor(e,t){super(e,t),__publicField(this,"name","AO"),__publicField(this,"_method","ssao"),__publicField(this,"_ssaoKernelRadius",.5),__publicField(this,"_ssaoMinDistance",1e-5),__publicField(this,"_ssaoMaxDistance",1e-4),__publicField(this,"_ssaoIntensity",1),__publicField(this,"_lastMethod","ssao"),__publicField(this,"_lastEnabled",!1),this.enabled=t.enabled,this._method=t.method}beginFrame(){this._lastEnabled===this.enabled?this.enabled&&this._lastMethod!==this._method&&(this._disableOldMethod(),this._enableNewMethod()):this.enabled?this._enableNewMethod():this._disableOldMethod()}_disableOldMethod(){const e=this._lastMethod,t=this._rendering;"ssao"===e&&(this._ssaoPass&&t.main.postprocessings.remove(this._ssaoPass),this._ssaoPass=null)}_enableNewMethod(){const e=this._method,t=this._rendering;if("ssao"===e){const e=this._ssaoPass=new SSAOPass;e.kernelRadius=this._ssaoKernelRadius,e.minDistance=this._ssaoMinDistance,e.maxDistance=this._ssaoMaxDistance,e.intensity=this._ssaoIntensity,e.renderOrder=900,e.rendering=t,t.main.postprocessings.add(e)}}afterRender(){}endFrame(){this._lastEnabled=this.enabled,this._lastMethod=this._method}dispose(){this.enabled&&this._disableOldMethod()}get method(){return this._method}set method(e){this._method=e}get ssaoKernelRadius(){return this._ssaoKernelRadius}set ssaoKernelRadius(e){this._ssaoKernelRadius=e,this._ssaoPass&&(this._ssaoPass.kernelRadius=e)}get ssaoMinDistance(){return this._ssaoMinDistance}set ssaoMinDistance(e){this._ssaoMinDistance=e,this._ssaoPass&&(this._ssaoPass.minDistance=e)}get ssaoMaxDistance(){return this._ssaoMaxDistance}set ssaoMaxDistance(e){this._ssaoMaxDistance=e,this._ssaoPass&&(this._ssaoPass.maxDistance=e)}get ssaoIntensity(){return this._ssaoIntensity}set ssaoIntensity(e){this._ssaoIntensity=e,this._ssaoPass&&(this._ssaoPass.intensity=e)}}const vertex_shader="#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}",fragment_shader='precision highp sampler2D;\n#define GLSLIFY 1\nvarying vec2 vUv;\nuniform sampler2D tDepth;\nuniform sampler2D tNormal;\nuniform sampler2D tMetalness;\nuniform sampler2D tDiffuse;\n\n#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)\nuniform sampler2D tEnhancement;\nuniform vec2 tEnhancementScale;\nuniform mat4 mvt_viewInverseMatrix;\nuniform mat3 mvt_normalInverseMatrix;\n#endif\n\nuniform float cameraRange;\nuniform vec2 resolution;\nuniform float opacity;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float maxDistance;\nuniform float thickness;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float threshold; // 控制反射最低阈值，低于此致的不计算，可提高性能\n\n#include <packing>\nfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n    //x0: point, x1: linePointA, x2: linePointB\n    //https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n    return length(cross(x0 - x1, x0 - x2)) / length(x2 - x1);\n}\nfloat pointPlaneDistance(vec3 point, vec3 planePoint, vec3 planeNormal) {\n    // https://mathworld.wolfram.com/Point-PlaneDistance.html\n    //// https://en.wikipedia.org/wiki/Plane_(geometry)\n    //// http://paulbourke.net/geometry/pointlineplane/\n    float a = planeNormal.x, b = planeNormal.y, c = planeNormal.z;\n    float x0 = point.x, y0 = point.y, z0 = point.z;\n    float x = planePoint.x, y = planePoint.y, z = planePoint.z;\n    float d = -(a * x + b * y + c * z);\n    float distance = (a * x0 + b * y0 + c * z0 + d) / sqrt(a * a + b * b + c * c);\n    return distance;\n}\n// https://stackoverflow.com/questions/40373184/world-space-position-from-logarithmic-depth-buffer\nfloat linearize_depth(in float depth) {\n    float a = cameraFar / (cameraFar - cameraNear);\n    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n    return a + b / depth;\n}\n\nfloat reconstruct_depth(const in vec2 uv) {\n    float depth = texture2D(tDepth, uv).x;\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat get_logarithmic_depth(const in vec2 uv) {\n    float depth = texture2D(tDepth, uv).x;\n    float logDepthBufFC = 2.0 / ( log( cameraFar + 1.0 ) / log(2.0) );\n    float invViewZ = exp2(depth / (logDepthBufFC * 0.5)) - 1.0;\n    return viewZToPerspectiveDepth(-invViewZ, cameraNear, cameraFar);\n}\nfloat getDepth(const in vec2 uv) {\n    #if defined( USE_LOGDEPTHBUF )\n    // return linearize_depth(reconstruct_depth(uv)); //exp2(logDepth * 2.0 / logDepthBufFC) - 1.0;\n    return get_logarithmic_depth(uv);\n    #else\n    return texture2D(tDepth, uv).x;\n    #endif\n\n}\nfloat getViewZ(const in float depth) {\n    #ifdef PERSPECTIVE_CAMERA\n    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    #else\n    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n    #endif\n}\nvec3 getViewPosition(const in vec2 uv, const in float depth/*clip space*/, const in float clipW) {\n    vec4 clipPosition = vec4((vec3(uv, depth) - 0.5) * 2.0, 1.0);//ndc\n    clipPosition *= clipW; //clip\n    return (cameraInverseProjectionMatrix * clipPosition).xyz;//view\n}\n#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)\nvec3 getWorldPositionFromDepth(float depth) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraInverseProjectionMatrix * clipSpacePosition;\n    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;\n    return worldSpacePosition.xyz / worldSpacePosition.w;\n}\n#endif\nvec3 getViewNormal(const in vec2 uv) {\n    return unpackRGBToNormal(texture2D(tNormal, uv).xyz);\n}\nvec2 viewPositionToXY(vec3 viewPosition) {\n    vec2 xy;\n    vec4 clip = cameraProjectionMatrix * vec4(viewPosition, 1);\n    xy = clip.xy;//clip\n    float clipW = clip.w;\n    xy /= clipW;//NDC\n    xy = (xy + 1.) / 2.;//uv\n    xy *= resolution;//screen\n    return xy;\n}\nvoid main() {\n\n    gl_FragColor = texture2D(tDiffuse, vUv);\n   \n    vec3 sampleNormal = texture2D(tNormal, vUv).xyz;\n    if (length(sampleNormal) < 0.9) {\n        return;\n    }\n\n    vec3 viewNormal = unpackRGBToNormal(sampleNormal);\n    float depth = getDepth(vUv);\n    #ifdef SELECTIVE\n    // 完全没反射的表面直接剔除\n    float intensity = texture2D(tMetalness, vUv).x;\n\n    #if defined(MVT_SSR_USE_ENHANCEMENT_MAP)\n        float dirAlpha = dot(viewNormal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));\n        if (dirAlpha > 0.5) {\n            vec3 worldSpacePosition = getWorldPositionFromDepth(depth);\n            vec2 enhancementUv = vec2(mod(worldSpacePosition.x, tEnhancementScale.x) / tEnhancementScale.x, \n                    mod(worldSpacePosition.y, tEnhancementScale.y) / tEnhancementScale.y);\n            float enhancement = texture2D(tEnhancement, enhancementUv).x;\n            intensity += (1.0 - enhancement);\n        }\n        // gl_FragColor = vec4(enhancement, 0.0, 0.0, 1.0);\n        // return;\n    #endif\n\n         \n    if(intensity < threshold)\n        return;\n    intensity -= threshold;\n    intensity *= 1.0 / (1.0 - threshold);\n    #endif\n\n    \n    float viewZ = getViewZ(depth);\n    // z值已经超过相机远端距离\n    if(-viewZ >= cameraFar)\n        return;\n\n    float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n    // 相机视图下的当前片元坐标\n    vec3 viewPosition = getViewPosition(vUv, depth, clipW);\n\n    // 起点的屏幕坐标\n    vec2 d0 = gl_FragCoord.xy;\n    vec2 d1;\n\n    #ifdef PERSPECTIVE_CAMERA\n    // 入射光方向，相机在原点，方向即为坐标的单位向量\n    vec3 viewIncidentDir = normalize(viewPosition);\n    // 反射光方向\n    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);\n    #else\n    vec3 viewIncidentDir = vec3(0, 0, -1);\n    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);\n    #endif\n\n    // 反射光线最长距离由输入的最大反射距离和入射角决定\n    float maxReflectRayLen = maxDistance / dot(-viewIncidentDir, viewNormal);\n    // dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n    // if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\n    // maxDistance/maxReflectRayLen=cos(theta)\n    // maxDistance/maxReflectRayLen==dot(a,b)\n    // maxReflectRayLen==maxDistance/dot(a,b)\n\n    // 反射最远距离下的坐标点\n    vec3 d1viewPosition = viewPosition + viewReflectDir * maxReflectRayLen;\n    #ifdef PERSPECTIVE_CAMERA\n    if(d1viewPosition.z > -cameraNear) {\n            //https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\n        // 应该是处理反射点溢出相机视野外的情况\n        float t = (-cameraNear - viewPosition.z) / viewReflectDir.z;\n        d1viewPosition = viewPosition + viewReflectDir * t;\n    }\n    #endif\n    // 反射最远点在屏幕上的位置\n    d1 = viewPositionToXY(d1viewPosition);\n\n    // 屏幕像素距离\n    float totalLen = length(d1 - d0);\n    float xLen = d1.x - d0.x;\n    float yLen = d1.y - d0.y;\n    // 最大步数取xy方向较大的一个方向，每次步进一个像素\n    float totalStep = max(abs(xLen), abs(yLen));\n    // x方向每次步进的大小\n    float xSpan = xLen / totalStep;\n    // y方向每次步进的大小\n    float ySpan = yLen / totalStep;\n    // 步进次数最大是屏幕对角线距离（应该是横向或者纵向的最大值），实际次数要远小于这个\n    for(float i = 0.; i < float(MAX_STEP); i += 4.0) {\n        if(i >= totalStep)\n            break;\n        // march到的当前屏幕像素\n        vec2 xy = vec2(d0.x + i * xSpan, d0.y + i * ySpan);\n        // 跑到屏幕外march失败\n        if(xy.x < 0. || xy.x > resolution.x || xy.y < 0. || xy.y > resolution.y)\n            break;\n        // 当前百分比\n        float s = length(xy - d0) / totalLen;\n        // 当前uv\n        vec2 uv = xy / resolution;\n        // 计算当前点的各项参数，和一开始一样\n        float d = getDepth(uv);\n        float vZ = getViewZ(d);\n        // gl_FragColor = vec4(-vZ / 1000., 0.0, 0.0, 1.0);\n        // return;\n        if(-vZ >= cameraFar)\n            continue;\n        float cW = cameraProjectionMatrix[2][3] * vZ + cameraProjectionMatrix[3][3];\n        // 得到当前点的viewposition\n        vec3 vP = getViewPosition(uv, d, cW);\n\n        // 得到当前反射线的z\n        #ifdef PERSPECTIVE_CAMERA\n            // https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\n        float recipVPZ = 1. / viewPosition.z;\n        float viewReflectRayZ = 1. / (recipVPZ + s * (1. / d1viewPosition.z - recipVPZ));\n        #else\n        float viewReflectRayZ = viewPosition.z + s * (d1viewPosition.z - viewPosition.z);\n        #endif\n\n        // if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.\n        // https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164\n        // 反射线的z小于当前点的z,否则就是被遮挡住了\n        if(viewReflectRayZ <= vZ) {\n\n            bool hit;\n            #ifdef INFINITE_THICK\n            hit = true;\n            #else\n            // 点到射线的距离\n            float away = pointToLineDistance(vP, viewPosition, d1viewPosition);\n\n            // minThickness没看懂，和横向邻接点的viewx差值，大约代表了此处一个像素和实际距离的比例，乘3.0？\n            float minThickness;\n            vec2 xyNeighbor = xy;\n            xyNeighbor.x += 1.;\n            vec2 uvNeighbor = xyNeighbor / resolution;\n            vec3 vPNeighbor = getViewPosition(uvNeighbor, d, cW);\n            minThickness = vPNeighbor.x - vP.x;\n            minThickness *= 3.;\n            float tk = max(minThickness, thickness);\n            // 当距离小于阈值时才算是真正相交\n            hit = away <= tk;\n            #endif\n\n            if(hit) {\n                vec3 vN = getViewNormal(uv);\n                // 相交到物体的反面了，march无效\n                if(dot(viewReflectDir, vN) >= 0.)\n                    continue;\n                float distance = pointPlaneDistance(vP, viewPosition, viewNormal);\n                // march距离超过最大\n                if(distance > maxDistance)\n                    break;\n                float op = opacity;\n                // 随着距离减弱反射，防止反射突然消失\n                #ifdef DISTANCE_ATTENUATION\n                float ratio = 1. - (distance / maxDistance);\n                float attenuation = ratio * ratio;\n                op = opacity * attenuation;\n                #endif\n                // 菲涅尔反射定律，与视野角度偏离越大，颜色权重越大\n                #ifdef FRESNEL\n                float fresnelCoe = (dot(viewIncidentDir, viewReflectDir) + 1.) / 2.;\n                op *= fresnelCoe;\n                #endif\n                // 读取反射颜色赋给当前片元\n                gl_FragColor = texture2D(tDiffuse, vUv);\n                vec4 reflectColor = texture2D(tDiffuse, uv);\n                reflectColor.a = op;\n                #ifdef SELECTIVE\n                reflectColor.a *= intensity;\n                #endif\n                gl_FragColor.rgb = mix(gl_FragColor.rgb, reflectColor.rgb, reflectColor.a);\n                // gl_FragColor = vec4(1.0, 0, 0, 1.0);\n                return;\n                \n                // break;\n            }\n        }\n    }\n    // gl_FragColor = texture2D(tDiffuse, vUv);\n}',uniforms$s={tDiffuse:{value:null},tNormal:{value:null},tMetalness:{value:null},tEnhancement:{value:null},tEnhancementScale:{value:new three.Vector2(20,20)},tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new three.Vector2},cameraProjectionMatrix:{value:new three.Matrix4},cameraInverseProjectionMatrix:{value:new three.Matrix4},mvt_viewInverseMatrix:{value:new three.Matrix4},mvt_normalInverseMatrix:{value:new three.Matrix3},opacity:{value:.5},maxDistance:{value:180},cameraRange:{value:0},thickness:{value:.018},logDepthBufFC:{value:1},threshold:{value:.6}};class SsrMaterial extends three.ShaderMaterial{constructor(e){super(),this.vertexShader=vertex_shader,this.fragmentShader=fragment_shader,this.uniforms=three.UniformsUtils.clone(uniforms$s),this.defines={MAX_STEP:0,PERSPECTIVE_CAMERA:!0,DISTANCE_ATTENUATION:!0,FRESNEL:!0,INFINITE_THICK:!1,SELECTIVE:!1},defineMaterialNormalProperties(this,["tDiffuse","tNormal","tDepth","tMetalness","cameraNear","cameraFar","threshold","thickness","opacity","tEnhancementScale"]),defineMaterialBoolDefineProperties(this,[]),Object.defineProperties(this,{tEnhancement:{get:function(){return this.uniforms.tEnhancement.value},set:function(e){e?(this.uniforms.tEnhancement.value=e,this.defines.MVT_SSR_USE_ENHANCEMENT_MAP=!0):(this.uniforms.tEnhancement.value=null,delete this.defines.MVT_SSR_USE_ENHANCEMENT_MAP)}}}),this.setValues(e)}dispose(){let e=["tEnhancement","tDiffuse","tNormal","tDepth","tMetalness"];for(let t=0;t<e.length;t++){const i=e[t];this.uniforms[i]&&this.uniforms[i].value&&this.uniforms[i].value.dispose()}super.dispose()}}class SSRPass extends Pass$1{constructor(){super();const e=this.material=new SsrMaterial;e.defines.DISTANCE_ATTENUATION=!0,e.defines.SELECTIVE=!0,this.fsQuad=new FullScreenQuad(null),this.needsSwap=!0,this.needsMetallicRoughTexture=!0,this.needsNormalTexture=!0,this.needsDepthTexture=!0}render(e,t,i){const n=this.rendering,r=n.main.sceneRendering,s=n.camera,a=this.material;a.uniforms.tDiffuse.value=i.texture,a.uniforms.tDepth.value=r.depthTexture,a.uniforms.tNormal.value=r.normalTexture,a.uniforms.tMetalness.value=r.metallicRoughTexture;const o=new three.Vector2(i.width,i.height);a.uniforms.resolution.value=o,a.defines.MAX_STEP=Math.min(512,Math.sqrt(o.x*o.x+o.y*o.y)),a.uniforms.cameraProjectionMatrix.value.copy(s.projectionMatrix),a.uniforms.cameraInverseProjectionMatrix.value.copy(s.projectionMatrixInverse),a.uniforms.mvt_viewInverseMatrix.value.copy(s.matrixWorld),a.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(s.matrixWorldInverse),a.uniforms.cameraNear.value=s.near,a.uniforms.cameraFar.value=s.far,this.fsQuad.material=a,e.setRenderTarget(this.renderToScreen?null:t),e.clear(),this.fsQuad.render(e)}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class FeatureReflection extends Feature{constructor(e,t){super(e,t),__publicField(this,"name","reflection"),__publicField(this,"_method","ssr"),__publicField(this,"_lastMethod","ssr"),__publicField(this,"_lastEnabled",!1),this.enabled=t.enabled,this._method=t.method}beginFrame(){this._lastEnabled===this.enabled?this.enabled&&this._lastMethod!==this._method&&(this._disableOldMethod(),this._enableNewMethod()):this.enabled?this._enableNewMethod():this._disableOldMethod()}_disableOldMethod(){const e=this._lastMethod,t=this._rendering;"ssr"===e&&(this._ssrPass&&t.main.postprocessings.remove(this._ssrPass),this._ssrPass=null)}_enableNewMethod(){const e=this._method,t=this._rendering;if("ssr"===e){const e=this._ssrPass=new SSRPass;e.renderOrder=800,e.rendering=t,t.main.postprocessings.add(e)}}afterRender(){}endFrame(){this._lastEnabled=this.enabled,this._lastMethod=this._method}dispose(){this.enabled&&this._disableOldMethod()}get method(){return this._method}set method(e){this._method=e}}const _cameraToLightMatrix$1=new three.Matrix4,_center$2=new three.Vector3,_bbox$1=new three.Box3,_lightOrientationMatrix$1=new three.Matrix4,_lightOrientationMatrixInverse$1=new three.Matrix4,_up$2=new three.Vector3(0,1,0);class ShadowFrustum{constructor(){__publicField(this,"maxFar",500),__publicField(this,"lightMargin",100),this.vertices={near:[new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3],far:[new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3]}}updateFromCameraProjectionMatrix(e){const t=e.projectionMatrixInverse;this.vertices.near[0].set(1,1,-1),this.vertices.near[1].set(1,-1,-1),this.vertices.near[2].set(-1,-1,-1),this.vertices.near[3].set(-1,1,-1),this.vertices.near.forEach((function(e){e.applyMatrix4(t)})),this.vertices.far[0].set(1,1,1),this.vertices.far[1].set(1,-1,1),this.vertices.far[2].set(-1,-1,1),this.vertices.far[3].set(-1,1,1);let i=this.maxFar;this.vertices.far.forEach((e=>{e.applyMatrix4(t);const n=Math.abs(e.z);e.multiplyScalar(Math.min(i/n,1))}))}updateShadowBounds(e,t){const i=e.shadow.camera,n=this.vertices.near,r=this.vertices.far,s=r[0];let a;a=s.distanceTo(r[2])>s.distanceTo(n[2])?r[2]:n[2];let o=s.distanceTo(a);o+=this.lightMargin,i.left=-o/2,i.right=o/2,i.top=o/2,i.bottom=-o/2,i.updateProjectionMatrix()}updateLightPosition(e,t,i,n=1024){_lightOrientationMatrix$1.lookAt(new three.Vector3,t,_up$2),_lightOrientationMatrixInverse$1.copy(_lightOrientationMatrix$1).invert();const r=e.shadow.camera,s=(r.right-r.left)/n,a=(r.top-r.bottom)/n;_cameraToLightMatrix$1.multiplyMatrices(_lightOrientationMatrixInverse$1,i.matrixWorld);for(let h=0;h<4;h++)this.vertices.near[h].copy(this.vertices.near[h]).applyMatrix4(_cameraToLightMatrix$1),this.vertices.far[h].copy(this.vertices.far[h]).applyMatrix4(_cameraToLightMatrix$1);const o=this.vertices.near,l=this.vertices.far;_bbox$1.makeEmpty();for(let h=0;h<4;h++)_bbox$1.expandByPoint(o[h]),_bbox$1.expandByPoint(l[h]);r.near=.1;const c=_bbox$1.max.z-_bbox$1.min.z;r.far=c+this.lightMargin,r.far<=r.near&&(r.far=r.near+Math.max(1,c+1)),_bbox$1.getCenter(_center$2),_center$2.z=_bbox$1.max.z+this.lightMargin,_center$2.x=Math.floor(_center$2.x/s)*s,_center$2.y=Math.floor(_center$2.y/a)*a,_center$2.applyMatrix4(_lightOrientationMatrix$1),e.position.copy(_center$2),e.target.position.copy(_center$2),e.target.position.x+=t.x,e.target.position.y+=t.y,e.target.position.z+=t.z}}class DefaultShadow{constructor(e,t){__publicField(this,"_maxDistance",500),this._shadowFeature=e,this._rendering=t,this._shadowFrustum=new ShadowFrustum}update(e,t){const i=this._rendering._engine,n=this._shadowFeature.shadowMapSize;e.shadow.mapSize.x!==n&&(e.shadow.map&&(e.shadow.map.dispose(),e.shadow.map=null),e.shadow.mapSize.set(n,n),e.shadow.needsUpdate=!0);const r=i.camera;this._shadowFrustum.maxFar=this._shadowFeature.maxDistance||this._maxDistance,this._shadowFrustum.updateFromCameraProjectionMatrix(r),this._shadowFrustum.updateShadowBounds(e,r),this._shadowFrustum.updateLightPosition(e,new three.Vector3(-t.x,-t.y,-t.z),r,n),e.updateMatrix(),e.updateMatrixWorld(),e.target.updateMatrix(),e.target.updateMatrixWorld(),e.shadow.camera.updateProjectionMatrix(),e.shadow.bias=-.001,this._currenLight=e}getCurrentUsedTextures(){if(this._currenLight)return[this._currenLight.shadow.map.texture]}showCurrentShadowCamera(){const e=this._rendering;this._currentViewCamera?this._currentViewCamera.copy(this._currenLight.shadow.camera):this._currentViewCamera=this._currenLight.shadow.camera,this._currenLight.updateWorldMatrix(!0,!1),this._currentViewCamera.applyMatrix4(this._currenLight.matrixWorld),this._shadowCameraHelper||(this._shadowCameraHelper=new three.CameraHelper(this._currentViewCamera),e.add(this._shadowCameraHelper))}hideCurrentShadowCamera(){const e=this._rendering;this._shadowCameraHelper&&(e.remove(this._shadowCameraHelper),this._shadowCameraHelper.dispose(),this._shadowCameraHelper=null)}dispose(){}}const CSMShader={lights_fragment_begin:"\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometryClearcoatNormal = clearcoatNormal;\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\t// Iridescence F0 approximation\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n \tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\n  \t\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n\t\tvec2 cascade;\n\t\tfloat cascadeCenter;\n\t\tfloat closestEdge;\n\t\tfloat margin;\n\t\tfloat csmx;\n\t\tfloat csmy;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\t\t\t// NOTE: Depth gets larger away from the camera.\n\t\t\t\t// cascade.x is closer, cascade.y is further\n\t\t\t\tcascade = CSM_cascades[ i ];\n\t\t\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n\t\t\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n\t\t\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\n\t\t\t\tcsmx = cascade.x - margin / 2.0;\n\t\t\t\tcsmy = cascade.y + margin / 2.0;\n\t\t\t\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n\t\t\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\n\t\t\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\n\n\t\t\t\t\tvec3 prevColor = directLight.color;\n\t\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n\t\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n\t\t\t\t\tReflectedLight prevLight = reflectedLight;\n\t\t\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n\t\t\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\n\n\t\t\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n\t\t\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#elif defined (USE_SHADOWMAP)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )\n\t\t// note: no loop here - all CSM lights are in fact one light only\n\t\tgetDirectionalLightInfo( directionalLights[0], directLight );\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t#endif\n\n\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\n\t\t// compute the lights not casting shadows (if any)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#if defined( USE_LIGHT_PROBES )\n\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n\t#endif\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",lights_pars_begin:"\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n\t"+three.ShaderChunk.lights_pars_begin},inverseProjectionMatrix=new three.Matrix4;class CSMFrustum{constructor(e){e=e||{},this.zNear=!0===e.webGL?-1:0,this.vertices={near:[new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3],far:[new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3]},void 0!==e.projectionMatrix&&this.setFromProjectionMatrix(e.projectionMatrix,e.maxFar||1e4)}setFromProjectionMatrix(e,t){const i=this.zNear,n=0===e.elements[11];return inverseProjectionMatrix.copy(e).invert(),this.vertices.near[0].set(1,1,i),this.vertices.near[1].set(1,-1,i),this.vertices.near[2].set(-1,-1,i),this.vertices.near[3].set(-1,1,i),this.vertices.near.forEach((function(e){e.applyMatrix4(inverseProjectionMatrix)})),this.vertices.far[0].set(1,1,1),this.vertices.far[1].set(1,-1,1),this.vertices.far[2].set(-1,-1,1),this.vertices.far[3].set(-1,1,1),this.vertices.far.forEach((function(e){e.applyMatrix4(inverseProjectionMatrix);const i=Math.abs(e.z);n?e.z*=Math.min(t/i,1):e.multiplyScalar(Math.min(t/i,1))})),this.vertices}split(e,t){for(;e.length>t.length;)t.push(new CSMFrustum);t.length=e.length;for(let i=0;i<e.length;i++){const n=t[i];if(0===i)for(let e=0;e<4;e++)n.vertices.near[e].copy(this.vertices.near[e]);else for(let t=0;t<4;t++)n.vertices.near[t].lerpVectors(this.vertices.near[t],this.vertices.far[t],e[i-1]);if(i===e.length-1)for(let e=0;e<4;e++)n.vertices.far[e].copy(this.vertices.far[e]);else for(let t=0;t<4;t++)n.vertices.far[t].lerpVectors(this.vertices.near[t],this.vertices.far[t],e[i])}}toSpace(e,t){for(let i=0;i<4;i++)t.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(e),t.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(e)}}class CSMHelper extends three.Group{constructor(e){super(),this.csm=e,this.displayFrustum=!0,this.displayPlanes=!0,this.displayShadowBounds=!0;const t=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),n=new three.BufferGeometry;n.setIndex(new three.BufferAttribute(t,1)),n.setAttribute("position",new three.BufferAttribute(i,3,!1));const r=new three.LineSegments(n,new three.LineBasicMaterial);this.add(r),this.frustumLines=r,this.cascadeLines=[],this.cascadePlanes=[],this.shadowLines=[]}updateVisibility(){const e=this.displayFrustum,t=this.displayPlanes,i=this.displayShadowBounds,n=this.frustumLines,r=this.cascadeLines,s=this.cascadePlanes,a=this.shadowLines;for(let o=0,l=r.length;o<l;o++){const n=r[o],l=s[o],c=a[o];n.visible=e,l.visible=e&&t,c.visible=i}n.visible=e}update(){const e=this.csm,t=e.camera,i=e.cascades,n=e.mainFrustum,r=e.frustums,s=e.lights,a=this.frustumLines.geometry.getAttribute("position"),o=this.cascadeLines,l=this.cascadePlanes,c=this.shadowLines;if(null===t)return;for(this.position.copy(t.position),this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.updateMatrixWorld(!0);o.length>i;)this.remove(o.pop()),this.remove(l.pop()),this.remove(c.pop());for(;o.length<i;){const e=new three.Box3Helper(new three.Box3,16777215),t=new three.MeshBasicMaterial({transparent:!0,opacity:.1,depthWrite:!1,side:three.DoubleSide}),i=new three.Mesh(new three.PlaneGeometry,t),n=new three.Group,r=new three.Box3Helper(new three.Box3,16776960);n.add(r),this.add(e),this.add(i),this.add(n),o.push(e),l.push(i),c.push(n)}for(let d=0;d<i;d++){const e=r[d],t=s[d].shadow.camera,i=e.vertices.far,n=o[d],a=l[d],h=c[d],u=h.children[0];n.box.min.copy(i[2]),n.box.max.copy(i[0]),n.box.max.z+=1e-4,a.position.addVectors(i[0],i[2]),a.position.multiplyScalar(.5),a.scale.subVectors(i[0],i[2]),a.scale.z=1e-4,this.remove(h),h.position.copy(t.position),h.quaternion.copy(t.quaternion),h.scale.copy(t.scale),h.updateMatrixWorld(!0),this.attach(h),u.box.min.set(t.bottom,t.left,-t.far),u.box.max.set(t.top,t.right,-t.near)}const h=n.vertices.near,u=n.vertices.far;a.setXYZ(0,u[0].x,u[0].y,u[0].z),a.setXYZ(1,u[3].x,u[3].y,u[3].z),a.setXYZ(2,u[2].x,u[2].y,u[2].z),a.setXYZ(3,u[1].x,u[1].y,u[1].z),a.setXYZ(4,h[0].x,h[0].y,h[0].z),a.setXYZ(5,h[3].x,h[3].y,h[3].z),a.setXYZ(6,h[2].x,h[2].y,h[2].z),a.setXYZ(7,h[1].x,h[1].y,h[1].z),a.needsUpdate=!0}dispose(){const e=this.frustumLines,t=this.cascadeLines,i=this.cascadePlanes,n=this.shadowLines;e.geometry.dispose(),e.material.dispose();const r=this.csm.cascades;for(let s=0;s<r;s++){const e=t[s],r=i[s],a=n[s].children[0];e.dispose(),r.geometry.dispose(),r.material.dispose(),a.dispose()}}}const _cameraToLightMatrix=new three.Matrix4,_lightSpaceFrustum=new CSMFrustum,_center$1=new three.Vector3,_bbox=new three.Box3,_uniformArray=[],_logArray=[],_lightOrientationMatrix=new three.Matrix4,_lightOrientationMatrixInverse=new three.Matrix4,_up$1=new three.Vector3(0,0,1);function uniformSplit(e,t,i,n){for(let r=1;r<e;r++)n.push((t+(i-t)*r/e)/i);n.push(1)}function logarithmicSplit(e,t,i,n){for(let r=1;r<e;r++)n.push(t*(i/t)**(r/e)/i);n.push(1)}function practicalSplit(e,t,i,n,r){_uniformArray.length=0,_logArray.length=0,logarithmicSplit(e,t,i,_logArray),uniformSplit(e,t,i,_uniformArray);for(let s=1;s<e;s++)r.push(three.MathUtils.lerp(_uniformArray[s-1],_logArray[s-1],n));r.push(1)}const _presetShadowBias=[-5e-4,-8e-4,-.0015,-.004];class CSMShadow{constructor(e,t){__publicField(this,"_lights",null),__publicField(this,"_light",null),__publicField(this,"_parent",null),__publicField(this,"_cascades",4),__publicField(this,"_maxFar",1e3),__publicField(this,"_shadowMapSize",1024),__publicField(this,"_lightNear",1),__publicField(this,"_lightFar",1e3),__publicField(this,"_lightMargin",100),__publicField(this,"_shadowBias",-5e-4),__publicField(this,"_mainFrustum",null),__publicField(this,"_frustums",[]),__publicField(this,"_breaks",[]),__publicField(this,"_helper",null),__publicField(this,"_fade",!0),this._shadowFeature=e,this._rendering=t,this._engine=t._engine,this._uniforms={CSM_cascades:{value:[]},cameraNear:{value:1},shadowFar:{value:1e3}}}init(){this._old_lights_fragment_begin=three.ShaderChunk.lights_fragment_begin,this._old_lights_pars_begin=three.ShaderChunk.lights_pars_begin,three.ShaderChunk.lights_fragment_begin=CSMShader.lights_fragment_begin,three.ShaderChunk.lights_pars_begin=CSMShader.lights_pars_begin}update(e,t,i){this._rendering._engine,this._light&&this._light!==e&&this._destroyLight(),this._light||(this._createLight(e,i),this._light=e);const n=new three.Vector3(-t.x,-t.y,-t.z);this.updateFrame(e,n)}updateFrame(e,t){const i=this._engine.camera,n=this._frustums;_lightOrientationMatrix.lookAt(new three.Vector3,t,_up$1),_lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert();for(let r=0;r<n.length;r++){const s=this._lights[r];s.color.copy(e.color),s.intensity=e.intensity;const a=s.shadow.camera,o=(a.right-a.left)/this._shadowMapSize,l=(a.top-a.bottom)/this._shadowMapSize;_cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse,i.matrixWorld),n[r].toSpace(_cameraToLightMatrix,_lightSpaceFrustum);const c=_lightSpaceFrustum.vertices.near,h=_lightSpaceFrustum.vertices.far;_bbox.makeEmpty();for(let e=0;e<4;e++)_bbox.expandByPoint(c[e]),_bbox.expandByPoint(h[e]);_bbox.getCenter(_center$1),_center$1.z=_bbox.max.z+this._lightMargin,_center$1.x=Math.floor(_center$1.x/o)*o,_center$1.y=Math.floor(_center$1.y/l)*l,_center$1.applyMatrix4(_lightOrientationMatrix),s.position.copy(_center$1),s.target.position.copy(_center$1),s.target.position.x+=t.x,s.target.position.y+=t.y,s.target.position.z+=t.z}}_createLight(e,t){this._parent=t,this._lights=[],this._light=e,this._mainLightCastShadow=e.castShadow,e.castShadow=!1,e.visible=!1;for(let i=0;i<this._cascades;i++){const n=new three.DirectionalLight(e.color,e.intensity);n.castShadow=!0,n.shadow.mapSize.width=this._shadowMapSize,n.shadow.mapSize.height=this._shadowMapSize,n.shadow.camera.near=this._lightNear,n.shadow.camera.far=this._lightFar,n.shadow.bias=this._shadowBias,n.shadow.bias=_presetShadowBias[i],n.shadow.normalBias=1e-4,t.add(n),t.add(n.target),this._lights.push(n)}this._mainFrustum=new CSMFrustum,this._frustums=[],this.updateFrustums()}getBreaks(){const e=this._rendering._engine.camera,t=Math.min(e.far,this._maxFar);this._breaks.length=0,practicalSplit(this._cascades,e.near,t,.5,this._breaks),this._breaks=[.05,.2,.45,1],this.getExtendedBreaks(this._uniforms.CSM_cascades.value)}initCascades(){const e=this._rendering._engine.camera;this._mainFrustum.setFromProjectionMatrix(e.projectionMatrix,this._maxFar),this._mainFrustum.split(this._breaks,this._frustums)}updateShadowBounds(){const e=this._frustums;for(let t=0;t<e.length;t++){const i=this._lights[t].shadow.camera,n=e[t],r=n.vertices.near,s=n.vertices.far,a=s[0];let o;o=a.distanceTo(s[2])>a.distanceTo(r[2])?s[2]:r[2];let l=a.distanceTo(o);const c=this._engine.camera,h=Math.max(c.far,this._maxFar),u=n.vertices.far[0].z/(h-c.near);l+=2*(.25*Math.pow(u,2)*(h-c.near)),i.left=-l/2,i.right=l/2,i.top=l/2,i.bottom=-l/2,i.updateProjectionMatrix()}}updateUniforms(){const e=this._engine.camera,t=Math.min(e.far,this._maxFar),i=this._uniforms;i.cameraNear.value=e.near,i.shadowFar.value=t}getExtendedBreaks(e){for(;e.length<this._breaks.length;)e.push(new three.Vector2);e.length=this._breaks.length;for(let t=0;t<this._cascades;t++){const i=this._breaks[t],n=this._breaks[t-1]||0;e[t].x=n,e[t].y=i}}updateFrustums(){this.getBreaks(),this.initCascades(),this.updateShadowBounds(),this.updateUniforms()}updateCSMShadow(e,t){e.defines||(e.defines={}),this._fade&&(e.defines.CSM_FADE=""),e.defines.USE_CSM=1,e.defines.CSM_CASCADES=this._cascades,t.uniforms.CSM_cascades=this._uniforms.CSM_cascades,t.uniforms.cameraNear=this._uniforms.cameraNear,t.uniforms.shadowFar=this._uniforms.shadowFar}_destroyLight(){const e=this._light;e.castShadow=this._mainLightCastShadow,e.visible=!0,this._light=null;for(const t of this._lights)this._parent.remove(t),this._parent.remove(t.target)}dispose(){three.ShaderChunk.lights_fragment_begin=this._old_lights_fragment_begin,three.ShaderChunk.lights_pars_begin=this._old_lights_pars_begin,this._destroyLight()}getCurrentUsedTextures(){const e=[];for(const t of this._lights)e.push(t.shadow.map.texture);return e}get shadowBias(){return this._shadowBias}set shadowBias(e){this._shadowBias=e;for(const t of this._lights)t.shadow.bias=e}get showHelper(){return!!this._helper}set showHelper(e){e?(this._helper||(this._helper=new CSMHelper(this._lights)),this._parent.add(this._helper)):(this._parent.remove(this._helper),this._helper=null)}}class FeatureShadow extends Feature{constructor(e,t){super(e,t),__publicField(this,"name","shadow"),__publicField(this,"_method","default"),__publicField(this,"_lastMethod","default"),__publicField(this,"_lastEnabled",!1),__publicField(this,"_shadowMapSize",2048),__publicField(this,"_maxDistance",0),__publicField(this,"needsShaderKey",!0),__publicField(this,"updateShadow",((e,t,i)=>{"default"===this._method?this._defaultShadow.update(e,t):"csm"===this._method&&this._csmShadow.update(e,t,i)})),__publicField(this,"getCurrentUsedTextures",(()=>{if(this.enabled)return"csm"===this._method?this._csmShadow.getCurrentUsedTextures():"default"===this._method?this._defaultShadow.getCurrentUsedTextures():void 0})),__publicField(this,"updateCSMShadow",((e,t)=>{"csm"===this._method&&this._csmShadow.updateCSMShadow(e,t)})),this.enabled=t.enabled,this._method=t.method,t.shadowMapSize&&(this._shadowMapSize=t.shadowMapSize)}beginFrame(){this._lastEnabled===this.enabled?this.enabled&&this._lastMethod!==this._method&&(this._disableOldMethod(),this._enableNewMethod()):this.enabled?this._enableNewMethod():this._disableOldMethod()}_enableNewMethod(){const e=this._method,t=this._rendering;t.renderer.shadowMap.enabled=!0,"default"===e?(this._defaultShadow=new DefaultShadow(this,t),this._currentShaderKey="1"):"csm"===e&&(this._csmShadow=new CSMShadow(this,t),this._csmShadow.init(),this._currentShaderKey="2"),this._lastMethod=e}_disableOldMethod(){const e=this._lastMethod;this._rendering.renderer.shadowMap.enabled=!1,"default"===e?(this._defaultShadow.dispose(),this._defaultShadow=null):"csm"===e&&(this._csmShadow.dispose(),this._csmShadow=null),this._currentShaderKey="0"}getCurrentShaderKey(){return this._currentShaderKey}endFrame(){this._lastEnabled=this.enabled,this._lastMethod=this._method}get method(){return this._method}set method(e){this._method=e}set shadowMapSize(e){this._shadowMapSize=e}get shadowMapSize(){return this._shadowMapSize}set maxDistance(e){this._maxDistance=e}get maxDistance(){return this._maxDistance}}const fragmentShader$u="\n#include <packing>\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\nvoid main() {\n\n    gl_FragColor = packDepthToRGBA(texture2D(tDiffuse, vUv).r);\n}\n",unpackDownscale=255/256,unpackFactors=new three.Vector4(unpackDownscale/16777216,unpackDownscale/65536,unpackDownscale/256,unpackDownscale),_tempVector4$4=new three.Vector4;class FeatureDepthPicking extends Feature{constructor(){super(...arguments),__publicField(this,"name","depthPicking"),__publicField(this,"_lastEnabled",!1),__publicField(this,"needsDepthTexture",!0)}beginFrame(){this._lastEnabled===this.enabled||(this.enabled?this._init():this.dispose())}_init(){const e=this._rendering,t=e.resolution,i=e.pixelRatio;this._depthColorRenderTarget=new three.WebGLRenderTarget(t.x*i,t.y*i,{depthBuffer:!1}),this._fsQuad=new FullScreenQuad(new three.ShaderMaterial({name:CopyShader.name,vertexShader:CopyShader.vertexShader,fragmentShader:fragmentShader$u,uniforms:{tDiffuse:{value:null},opacity:{value:1}}}))}_unpackRGBAToDepth(e){_tempVector4$4.set(e[0]/255,e[1]/255,e[2]/255,e[3]/255);return _tempVector4$4.dot(unpackFactors)}async pickDepth(e,t){const i=this._rendering,n=i.renderer,r=i.pixelRatio,s=new Uint8Array(4);n.readRenderTargetPixels(this._depthColorRenderTarget,e*r,t*r,1,1,s);let a=this._unpackRGBAToDepth(s);if(a>.99||a<1e-6)return null;const o=i.camera,l=o.far,c=o.near,h=2/(Math.log(l+1)/Math.log(2));let u=Math.pow(2,a/(.5*h))-1;return u=-u,a=(c+u)*l/((l-c)*u),a}afterRender(){if(!this.enabled)return;const e=this._rendering,t=e.main.sceneRendering;if(!t.depthTexture)return;this._fsQuad.material.uniforms.tDiffuse.value=t.depthTexture;const i=e.renderer,n=i.autoClear;i.autoClear=!1,i.setRenderTarget(this._depthColorRenderTarget),i.clear(),this._fsQuad.render(i),i.autoClear=n}endFrame(){this._lastEnabled=this.enabled}dispose(){this._fsQuad.material.dispose(),this._fsQuad.dispose(),this._depthColorRenderTarget.dispose(),this._depthColorRenderTarget=null,this._fsQuad=null}get viewTextures(){return this._depthColorRenderTarget?[this._depthColorRenderTarget.texture]:null}}const fragmentShader$t="\n\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\nuniform float saturation;\nuniform float brightness;\nuniform float contrast;\n\nvoid main() {\n    vec4 outColor = texture2D(tDiffuse, vUv);\n    vec3 grayscale = vec3(dot(outColor.xyz,  vec3(0.2126, 0.7152, 0.0722)));\n    outColor.xyz = mix(grayscale, outColor.xyz, 1.0 + saturation);\n\n    outColor.xyz = 0.5 + (1.0 + contrast) * (outColor.xyz - 0.5);\n    outColor.xyz = outColor.xyz + brightness;\n    gl_FragColor = outColor;\n}\n";class ColorAdjustmentPass extends Pass$1{constructor(){super();const e=CopyShader;this.uniforms={tDiffuse:{value:null},saturation:{value:1},brightness:{value:0},contrast:{value:1}},this.material=new three.ShaderMaterial({uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:fragmentShader$t,depthTest:!1,depthWrite:!1}),this.needsSwap=!0,this.fsQuad=new FullScreenQuad(null)}render(e,t,i){const n=e.autoClear;e.autoClear=!1,this.fsQuad.material=this.material,this.material.uniforms.tDiffuse.value=i.texture,e.setRenderTarget(this.renderToScreen?null:t),e.clear(),this.fsQuad.render(e),e.autoClear=n}dispose(){this.material.dispose(),this.fsQuad.dispose()}get saturation(){return this.uniforms.saturation.value}set saturation(e){this.uniforms.saturation.value=e}get brightness(){return this.uniforms.brightness.value}set brightness(e){this.uniforms.brightness.value=e}get contrast(){return this.uniforms.contrast.value}set contrast(e){this.uniforms.contrast.value=e}}class FeatureColorAdjustment extends Feature{constructor(e,t){super(e,t),__publicField(this,"name","ColorAdjustment"),__publicField(this,"_saturation",0),__publicField(this,"_brightness",0),__publicField(this,"_contrast",0),this.enabled=t.enabled,void 0!==t.saturation&&(this._saturation=t.saturation),void 0!==t.brightness&&(this._brightness=t.brightness),void 0!==t.contrast&&(this._contrast=t.contrast)}beginFrame(){if(this.enabled&&!this._renderPass){const e=this._renderPass=new ColorAdjustmentPass;e.saturation=this._saturation,e.brightness=this._brightness,e.contrast=this._contrast,this._rendering.main.postprocessings.add(this._renderPass)}else!this.enabled&&this._renderPass&&(this._rendering.main.postprocessings.remove(this._renderPass),this._renderPass.dispose(),this._renderPass=null)}afterRender(){}endFrame(){}dispose(){this._renderPass&&(this._rendering.main.postprocessings.remove(this._renderPass),this._renderPass.dispose(),this._renderPass=null)}get saturation(){return this._saturation}set saturation(e){this._saturation=e,this._renderPass&&(this._renderPass.saturation=e)}get brightness(){return this._brightness}set brightness(e){this._brightness=e,this._renderPass&&(this._renderPass.brightness=e)}get contrast(){return this._contrast}set contrast(e){this._contrast=e,this._renderPass&&(this._renderPass.contrast=e)}}const fragmentShader$s="\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nuniform sampler2D tVideo;\nuniform mat4 projectionInverseMatrix;\nuniform mat4 viewInverseMatrix;\nuniform mat4 videoProjectionMatrix;\nuniform mat4 videoViewMatrix;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float opacity;\n\nuniform float k1, k2, k3;\nuniform float p1, p2;\n\nvarying vec2 vUv;\n\n#include <packing>\n#include <mvt_depth_packing>\n\nbool visible(vec4 result) {\n    result.x /= result.w;\n    result.y /= result.w;\n    result.z /= result.w;\n\n    return result.x >= -1.0 && result.x <= 1.0 &&\n           result.y >= -1.0 && result.y <= 1.0 &&\n           result.z >= -1.0 && result.z <= 1.0;\n}\n\n// 畸变校正函数\nvec2 undistort(vec2 uv) {\n    // 将纹理坐标转换到[-1, 1]范围\n    vec2 uvNorm = uv * 2.0 - 1.0;\n\n    float r2 = uvNorm.x * uvNorm.x + uvNorm.y * uvNorm.y;\n    float radialDistortion = 1.0 + k1 * r2 + k2 * r2 * r2 + k3 * r2 * r2 * r2;\n    float tangentialDistortionX = 2.0 * p1 * uvNorm.x * uvNorm.y + p2 * (r2 + 2.0 * uvNorm.x * uvNorm.x);\n    float tangentialDistortionY = p1 * (r2 + 2.0 * uvNorm.y * uvNorm.y) + 2.0 * p2 * uvNorm.x * uvNorm.y;\n\n    uvNorm.x = uvNorm.x * radialDistortion + tangentialDistortionX;\n    uvNorm.y = uvNorm.y * radialDistortion + tangentialDistortionY;\n\n    // 将纹理坐标转换回[0, 1]范围\n    return (uvNorm + 1.0) / 2.0;\n}\n\nvoid main() {\n    vec4 diffuseColor = texture2D(tDiffuse, vUv);\n    vec4 outputColor = diffuseColor;\n\n    // 计算当前片元的世界坐标\n    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);\n    vec3 worldPosition = mvtGetWorldPositionByDepth(depth, vUv, projectionInverseMatrix, viewInverseMatrix);\n\n    vec4 videoPos= videoProjectionMatrix * videoViewMatrix * vec4(worldPosition, 1.0);\n\n    // 在视野内的片元才进行融合\n    if (visible(videoPos) && depth <= 0.999999) {\n        vec4 gytyPosition = videoProjectionMatrix * videoViewMatrix * vec4(worldPosition.xyz, 1.0);\n        gytyPosition= gytyPosition / gytyPosition.w;\n        float s = (gytyPosition.s + 1.0) / 2.0;\n        float t = (gytyPosition.t + 1.0) / 2.0;\n        vec2 uv_depth = vec2(s, t);\n\n        // 对纹理坐标进行畸变校正\n        uv_depth = undistort(uv_depth);\n        if (uv_depth.x >= 0.0 && uv_depth.x <= 1.0 && uv_depth.y >= 0.0 && uv_depth.y <= 1.0) {\n            vec4 videoColor = texture2D(tVideo, uv_depth);\n            outputColor = mix(diffuseColor, videoColor, opacity);\n        }\n    }\n\n    gl_FragColor = outputColor;\n}\n";class CameraFusionPass extends Pass$1{constructor(e,t){super(),this.name="CameraFusionPass",this.needsSwap=!0,this._camera=t;const i=CopyShader;this.uniforms=three.UniformsUtils.merge([three.UniformsUtils.clone(i.uniforms),{tDepth:{value:null},tVideo:{value:e},projectionInverseMatrix:{value:new three.Matrix4},viewInverseMatrix:{value:new three.Matrix4},videoProjectionMatrix:{value:new three.Matrix4},videoViewMatrix:{value:new three.Matrix4},cameraNear:{value:null},cameraFar:{value:null},cameraPosition:{value:new three.Vector3},opacity:{value:.5},k1:{value:0},k2:{value:0},k3:{value:0},p1:{value:0},p2:{value:0}}]),this.material=new three.ShaderMaterial({name:"VideoFusionMaterial",uniforms:this.uniforms,vertexShader:i.vertexShader,fragmentShader:fragmentShader$s}),this.fsQuad=new FullScreenQuad(this.material)}render(e,t,i){const n=this.rendering.camera,r=this._camera,s=this.uniforms;s.tDiffuse.value=i.texture,s.tDepth.value=this.rendering.main.sceneRendering.depthTexture,s.projectionInverseMatrix.value.copy(n.projectionMatrixInverse),s.viewInverseMatrix.value.copy(n.matrixWorld),s.cameraNear.value=n.near,s.cameraFar.value=n.far,r&&(s.videoProjectionMatrix.value.copy(r.projectionMatrix),s.videoViewMatrix.value.copy(r.matrixWorldInverse)),!0===this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),e.clear(),this.fsQuad.render(e))}dispose(){this.material.dispose(),this.fsQuad.dispose()}set camera(e){this._camera=e}get camera(){return this._camera}set texture(e){this.uniforms.tVideo.value=e}get texture(){return this.uniforms.tVideo.value}set opacity(e){this.uniforms.opacity.value=e}get opacity(){return this.uniforms.opacity.value}}class FeatureCameraFusion extends Feature{constructor(){super(...arguments),__publicField(this,"name","CameraFusion"),__publicField(this,"_lastEnabled",!1),__publicField(this,"_camera",null),__publicField(this,"_texture",null),__publicField(this,"_opacity",.5)}beginFrame(){this._lastEnabled===this.enabled||(this.enabled?this._init():this.dispose())}_init(){const e=this._rendering,t=this._renderPass=new CameraFusionPass(this._texture,this._camera);t.opacity=this._opacity,t.renderOrder=600,e.main.postprocessings.add(this._renderPass)}afterRender(){}endFrame(){this._lastEnabled=this.enabled}dispose(){this._rendering.main.postprocessings.remove(this._renderPass),this._renderPass&&(this._renderPass.dispose(),this._renderPass=null)}set camera(e){e!==this._camera&&(this._camera&&this._rendering._engine.remove(this._camera),this._rendering._engine.add(e),this._renderPass&&(this._renderPass.camera=e),this._camera=e)}get camera(){return this._camera}set texture(e){this._texture=e,this._renderPass&&(this._renderPass.texture=e)}get texture(){return this._texture}set opacity(e){this._opacity=e,this._renderPass&&(this._renderPass.opacity=e)}get opacity(){return this._opacity}}class FeatureHDR extends Feature{constructor(){super(...arguments),__publicField(this,"name","HDR"),__publicField(this,"_bufferType",three.UnsignedByteType),__publicField(this,"_exposure",1),__publicField(this,"_lastEnabled",!1),__publicField(this,"needsFloatRenderTarget",!0)}beginFrame(){this._lastEnabled,this._enabled}endFrame(){this._lastEnabled=this.enabled}set enabled(e){this._enabled=!!e}get enabled(){return this._enabled}set exposure(e){this._exposure=e}get exposure(){return this._exposure}}class Features{constructor(e,t){__publicField(this,"_features",[]),this._rendering=e,this._bloom=new FeatureBloom(this._rendering,t.bloom),this._features.push(this._bloom),this._antialias=new FeatureAntialias(this._rendering,t.antialias),this._features.push(this._antialias),this._ao=new FeatureAo(this._rendering,t.ao),this._features.push(this._ao),this._reflection=new FeatureReflection(this._rendering,t.reflection),this._features.push(this._reflection),this._bufferView=new FeatureBufferView(this._rendering,t.bufferView),this._features.push(this._bufferView),this._stats=new FeatureStats(this._rendering,t.stats),this._features.push(this._stats),this._shadow=new FeatureShadow(this._rendering,t.shadow),this._features.push(this._shadow),this._depthPicking=new FeatureDepthPicking(this._rendering,t.depthPicking),this._features.push(this._depthPicking),this._colorAdjustment=new FeatureColorAdjustment(this._rendering,t.colorAdjustment),this._features.push(this._colorAdjustment),this._cameraFusion=new FeatureCameraFusion(this._rendering),this._features.push(this._cameraFusion),this._hdr=new FeatureHDR(this._rendering,t.hdr),this._features.push(this._hdr)}beginFrame(){for(const e of this._features)e.beginFrame()}afterRender(){for(const e of this._features)e.afterRender&&e.afterRender()}endFrame(){for(const e of this._features)e.endFrame()}updateReqirements(e){const t=[];for(const i of this._features)i.enabled&&(i.needsEmissiveTexture&&(e.needsEmissiveTexture=!0),i.needsNormalTexture&&(e.needsNormalTexture=!0),i.needsDepthTexture&&(e.needsDepthTexture=!0),i.needsMetallicRoughTexture&&(e.needsMetallicRoughTexture=!0),i.needsFloatRenderTarget&&(e.needsFloatRenderTarget=!0),i.needsShaderKey&&t.push(i.getCurrentShaderKey()));e.featuresShaderKey=t.join("")}isInStableRenderState(){return!0}get ao(){return this._ao}get bloom(){return this._bloom}get stats(){return this._stats}get bufferView(){return this._bufferView}get antialias(){return this._antialias}get reflection(){return this._reflection}get features(){return this._features}get shadow(){return this._shadow}get depthPicking(){return this._depthPicking}get colorAdjustment(){return this._colorAdjustment}get cameraFusion(){return this._cameraFusion}get hdr(){return this._hdr}}class SharedFullScreenRenderTargets{constructor(e){__publicField(this,"_renderTargets",[]),__publicField(this,"_locks",[]),__publicField(this,"_maxRenderTargets",10),this._rendering=e}beginFrame(){this._resetLocks(),this._rendering.main.requirements.isRenderTargetTypeChanged()&&this._disposeRenderTargets()}_disposeRenderTargets(){const e=this._renderTargets;for(let t=0;t<this._maxRenderTargets;t++)e[t]&&(e[t].dispose(),e[t]=null)}_resetLocks(){const e=this._locks;for(let t=0;t<this._maxRenderTargets;t++)e[t]=!1}getAvailableRenderTarget(){const e=this._renderTargets,t=this._locks,i=this._rendering,n=i.resolution,r=i.pixelRatio,s=i.main.requirements.getRenderTargetType();for(let a=0;a<this._maxRenderTargets;a++)if(e[a]||(e[a]=new three.WebGLRenderTarget(n.x*r,n.y*r,{type:s,depthBuffer:!1,magFilter:three.NearestFilter,minFilter:three.NearestFilter,resolveDepthBuffer:!1,resolveStencilBuffer:!1}),e[a].name=`SharedFullScreenRenderTarget_${a}`),!t[a])return t[a]=!0,e[a];throw new Error("No available render target")}releaseRenderTarget(e){const t=this._renderTargets,i=this._locks;for(let n=0;n<this._maxRenderTargets;n++)if(t[n]===e)return void(i[n]=!1);console.warn("Invalid render target to release")}releaseRenderTargetByIndex(e){const t=this._locks;e<0||e>=this._maxRenderTargets?console.warn("Invalid render target to release"):t[e]=!1}lockRenderTarget(e){const t=this._renderTargets,i=this._locks;for(let n=0;n<this._maxRenderTargets;n++)if(t[n]===e)return void(i[n]=!0);console.warn("Invalid render target to lock")}setSize(e,t){const i=this._renderTargets,n=this._rendering.pixelRatio;for(let r=0;r<this._maxRenderTargets;r++)i[r]&&i[r].setSize(e*n,t*n)}endFrame(){}}class RenderingMainNew{constructor(e,t){__publicField(this,"_rendering"),__publicField(this,"_requirements"),__publicField(this,"_useMRT",!1),__publicField(this,"_lastUseMRT",null),__publicField(this,"_sceneRendering"),__publicField(this,"_features"),__publicField(this,"_postprocessings"),__publicField(this,"_opaquePostprocessings"),e._main=this,this._rendering=e,this._requirements=new RenderingRequirements(e),this._features=new Features(e,t.features),this._postprocessings=new Postprocessings(e),this._opaquePostprocessings=new OpaquePostprocessings(e),this._sharedFullScreenRenderTargets=new SharedFullScreenRenderTargets(e),e.postprocessings=this._postprocessings,e.opaquePostprocessings=this._opaquePostprocessings,e.sharedFullScreenRenderTargets=this._sharedFullScreenRenderTargets,e.features=this._features}beginFrame(){const e=this._rendering;if(e.isUseMRTChanged||!this._sceneRendering){let t=!0;this._sceneRendering&&(t=this._sceneRendering.useFastEmissiveMethod,this._sceneRendering.dispose()),e.useMRT?this._sceneRendering=new MRTSceneRendering(this._rendering):this._sceneRendering=new DirectSceneRendering(this._rendering),this._sceneRendering.useFastEmissiveMethod=t}this._features.beginFrame(),this._requirements.beginFrame(),this._sharedFullScreenRenderTargets.beginFrame(),this._sceneRendering.beginFrame(),this._opaquePostprocessings.beginFrame(),this._postprocessings.beginFrame()}render(e){const t=this._rendering.renderState,i=this._sceneRendering,n=this._features,r=this._postprocessings,s=this._opaquePostprocessings,a=this._sharedFullScreenRenderTargets;let o=null;(this._rendering.useMRT||r.validCount>0||s.validCount>0)&&(o=a.getAvailableRenderTarget()),i.renderTarget=o,t.stage=RENDER_STAGE_SCENE,s.show(),i.render(e),s.hide(),t.stage=RENDER_STAGE_FEATURES,n.afterRender(),(this._rendering.useMRT||r.validCount>0)&&(t.stage=RENDER_STAGE_POSTPROCESSING,r.render())}isInStableRenderState(){return this._sceneRendering.isInStableRenderState()&&this._features.isInStableRenderState()&&this._postprocessings.isInStableRenderState()&&this._opaquePostprocessings.isInStableRenderState()}endFrame(){this._requirements.endFrame(),this._features.endFrame(),this._sceneRendering.endFrame(),this._opaquePostprocessings.endFrame(),this._postprocessings.endFrame(),this._sharedFullScreenRenderTargets.endFrame()}setSize(e,t){this._rendering,this._sceneRendering&&this._sceneRendering.setSize(e,t),this._sharedFullScreenRenderTargets&&this._sharedFullScreenRenderTargets.setSize(e,t),this._opaquePostprocessings&&this._opaquePostprocessings.setSize(e,t),this._postprocessings&&this._postprocessings.setSize(e,t)}get sceneRendering(){return this._sceneRendering}get useFastEmissiveMethod(){return this._sceneRendering.useFastEmissiveMethod}set useFastEmissiveMethod(e){this._sceneRendering.useFastEmissiveMethod=e}get antialias(){return!0}get rendering(){return this._rendering}get requirements(){return this._requirements}get features(){return this._features}get postprocessings(){return this._postprocessings}get opaquePostprocessings(){return this._opaquePostprocessings}}const defaultGeoBoundingBox=new three.Box3(new three.Vector3(-180,-90,-100),new three.Vector3(180,90,100));defaultGeoBoundingBox.isDefault=!0,Object.freeze(defaultGeoBoundingBox),Object.freeze(defaultGeoBoundingBox.min),Object.freeze(defaultGeoBoundingBox.max);const _tempVector3In=new three.Vector3,_tempVector3Out=new three.Vector3,projectBoundingBoxMethods={MIN_MAX:1,FOUR_CORNERS:2,FOUR_CORNERS_WITH_EQUATOR:3};class Projection{constructor(){__publicField(this,"isProjection",!0),__publicField(this,"isGeo",!1),__publicField(this,"isAxisAligned",!1),__publicField(this,"projectBoundingBoxMethod",projectBoundingBoxMethods.MIN_MAX)}projectCoordinate(e,t){throw new Error("projectCoordinate() must be implemented in derived classes")}unprojectCoordinate(e,t){throw new Error("unprojectCoordinate() must be implemented in derived classes")}geoBoxToProjectedBox(e,t,i=!0){if(t||(t=new three.Box3),this.projectBoundingBoxMethod===projectBoundingBoxMethods.MIN_MAX)this.projectCoordinate(e.min,t.min,i),this.projectCoordinate(e.max,t.max,i);else if(this.projectBoundingBoxMethod===projectBoundingBoxMethods.FOUR_CORNERS||this.projectBoundingBoxMethod===projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR){let{x:n,y:r,z:s}=e.min,{x:a,y:o,z:l}=e.max;_tempVector3In.set(n,r,s),this.projectCoordinate(_tempVector3In,_tempVector3Out,i),t.expandByPoint(_tempVector3Out),_tempVector3In.set(a,o,l),this.projectCoordinate(_tempVector3In,_tempVector3Out,i),t.expandByPoint(_tempVector3Out),_tempVector3In.set(n,o,0),this.projectCoordinate(_tempVector3In,_tempVector3Out,i),t.expandByPoint(_tempVector3Out),_tempVector3In.set(a,r,0),this.projectCoordinate(_tempVector3In,_tempVector3Out,i),t.expandByPoint(_tempVector3Out),this.projectBoundingBoxMethod===projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR&&r<0&&o>0&&(_tempVector3In.set(n,0,0),this.projectCoordinate(_tempVector3In,_tempVector3Out,i),t.expandByPoint(_tempVector3Out),_tempVector3In.set(a,0,0),this.projectCoordinate(_tempVector3In,_tempVector3Out,i),t.expandByPoint(_tempVector3Out))}return t}getGeodeticSurfaceNormal(e,t){return t||(t=new three.Vector3),t.set(0,0,1),t}getProjectedSurfaceNormal(e,t){return t||(t=new three.Vector3),t.set(0,0,1),t}projectedBoxToGeoBox(e,t,i=!0){return t||(t=new three.Box3),this.unprojectCoordinate(e.min,t.min,i),this.unprojectCoordinate(e.max,t.max,i),t}equals(e){return!!e&&this.name===e.name}localFrameToFixedFrame(e,t){return t||(t=new three.Matrix4),t.identity(),t.setPosition(e),t}get geoBoundingBox(){return this._geoBoundingBox||defaultGeoBoundingBox}get projectedBoundingBox(){if(!this._projectedBoundingBox){const e=this.geoBoundingBox;this._projectedBoundingBox=this.geoBoxToProjectedBox(e,null,!1)}return this._projectedBoundingBox}}const extendUnprojectCoordinate=(e,t,i,n,r=!1)=>{if(Math.abs(e)<n)return t;const s=e>0?1:-1;if(r)return s*i;return s*(i*(1+(Math.abs(e)-n)/n))},extendProjectCoordinate=(e,t,i,n,r=!1)=>{if(Math.abs(e)<i)return t;const s=e>0?1:-1;if(r)return s*n;return s*(n*(1+(Math.abs(e)-i)/i))},D2R=Math.PI/180,A$1=6378137,MAXEXTENT=20037508,R2D=180/Math.PI,MAXLON=85.0511287798;function toMercator(e,t=null,i=!1){var n=Math.abs(e[0])<=180?e[0]:e[0]-360*sign$1(e[0]);const r=t||[0,0];return r[0]=A$1*n*D2R,r[1]=A$1*Math.log(Math.tan(.25*Math.PI+.5*e[1]*D2R)),i?(r[0]=extendProjectCoordinate(e[0],r[0],180,MAXEXTENT),r[1]=extendProjectCoordinate(e[1],r[1],MAXLON,MAXEXTENT)):(r[0]>MAXEXTENT&&(r[0]=MAXEXTENT),r[0]<-MAXEXTENT&&(r[0]=-MAXEXTENT),r[1]>MAXEXTENT&&(r[1]=MAXEXTENT),r[1]<-MAXEXTENT&&(r[1]=-MAXEXTENT)),r}function toWgs84(e,t,i=!1){const n=t||[0,0];return n[0]=e[0]*R2D/A$1,n[1]=(.5*Math.PI-2*Math.atan(Math.exp(-e[1]/A$1)))*R2D,i&&(n[0]=extendUnprojectCoordinate(e[0],n[0],180,MAXEXTENT),n[1]=extendUnprojectCoordinate(e[1],n[1],MAXLON,MAXEXTENT)),n}function sign$1(e){return e<0?-1:e>0?1:0}const _tempCoordinate=[0,0],_inputArray$1=[0,0];class WebMercatorProjection extends Projection{constructor(){super(...arguments),__publicField(this,"name",PROJECTION_WEB_MERCATOR),__publicField(this,"isAxisAligned",!0)}projectCoordinate(e,t,i=!1){_inputArray$1[0]=e.x,_inputArray$1[1]=e.y,i||(_inputArray$1[0]<-180&&(_inputArray$1[0]=-180),_inputArray$1[0]>180&&(_inputArray$1[0]=180),_inputArray$1[1]<-85.0511287798&&(_inputArray$1[1]=-85.0511287798),_inputArray$1[1]>85.0511287798&&(_inputArray$1[1]=85.0511287798));const n=toMercator(_inputArray$1,_tempCoordinate,i);return t||(t=new three.Vector3),t.x=n[0],t.y=n[1],t.z=e.z,t}unprojectCoordinate(e,t,i=!1){const n=toWgs84([e.x,e.y],_tempCoordinate,i);return t||(t=new three.Vector3),t.x=n[0],t.y=n[1],t.z=e.z,t}}class Cartesian4{static clone(e,t){return t||(t=new three.Vector4),t.copy(e),t}static fromElements(e,t,i,n,r){return r||(r=new three.Vector4),r.set(e,t,i,n),r}static lerp(e,t,i,n){return n||(n=new three.Vector4),n.lerpVectors(e,t,i),n}static equals(e,t){return e.equals(t)}static normalize(e,t){return e===t?(e.normalize(),e):(t.copy(e),t.normalize(),t)}static add(e,t,i){return i||(i=new three.Vector4),i.addVectors(e,t)}static multiplyByScalar(e,t,i){return i||(i=new three.Vector4),i.copy(e).multiplyScalar(t),i}static subtract(e,t,i){return i||(i=new three.Vector4),i.subVectors(e,t),i}static distance(e,t){return e.distanceTo(t)}}__publicField(Cartesian4,"ZERO",new three.Vector4(0,0,0,0)),__publicField(Cartesian4,"UNIT_W",Object.freeze(new three.Vector4(0,0,0,1)));const scratchNormal$1=new three.Vector3,scratchCartesian$4=new three.Vector3,scratchInverseTranspose=new three.Matrix4,scratchPlaneCartesian4=new three.Vector4(0,0,0,0),scratchTransformNormal=new three.Vector3;class StaticPlane{static fromPointNormal(e,t,i){return i||(i=new three.Plane),i.setFromNormalAndCoplanarPoint(t,e),i}static fromCartesian4(e,t){const i=Cartesian3.fromCartesian4(e,scratchNormal$1),n=e.w;if(!CesiumMath.equalsEpsilon(Cartesian3.magnitude(i),1,CesiumMath.EPSILON6))throw new Error("normal must be normalized.");return defined$1(t)?(Cartesian3.clone(i,t.normal),t.constant=n,t):new StaticPlane(i,n)}static getPointDistance(e,t){return Cartesian3.dot(e.normal,t)+e.constant}static projectPointOntoPlane(e,t,i){defined$1(i)||(i=new three.Vector3);const n=StaticPlane.getPointDistance(e,t),r=Cartesian3.multiplyByScalar(e.normal,n,scratchCartesian$4);return Cartesian3.subtract(t,r,i)}static transform(e,t,i){const n=e.normal,r=e.constant,s=three.Matrix4.inverseTranspose(t,scratchInverseTranspose);let a=Cartesian4.fromElements(n.x,n.y,n.z,r,scratchPlaneCartesian4);a=three.Matrix4.multiplyByVector(s,a,a);const o=Cartesian3.fromCartesian4(a,scratchTransformNormal);return a=Cartesian4.divideByScalar(a,Cartesian3.magnitude(o),a),three.Plane.fromCartesian4(a,i)}static clone(e,t){return defined$1(t)?(Cartesian3.clone(e.normal,t.normal),t.constant=e.constant,t):new StaticPlane(e.normal,e.constant)}static equals(e,t){return e.constant===t.constant&&Cartesian3.equals(e.normal,t.normal)}}three.Plane.ORIGIN_XY_PLANE=Object.freeze(new StaticPlane(Cartesian3.UNIT_Z,0)),three.Plane.ORIGIN_YZ_PLANE=Object.freeze(new StaticPlane(Cartesian3.UNIT_X,0)),three.Plane.ORIGIN_ZX_PLANE=Object.freeze(new StaticPlane(Cartesian3.UNIT_Y,0));const scratchCart4=new three.Vector4(0,0,0,0),scratchProjectPointOntoPlaneRay$1=new three.Ray,scratchProjectPointOntoPlaneCartesian3$1=new three.Vector3;class EllipsoidTangentPlane{constructor(e,t){if(!defined$1(e=(t=defaultValue(t,Ellipsoid.WGS84)).scaleToGeodeticSurface(e)))throw new DeveloperError("origin must not be at the center of the ellipsoid.");const i=Transforms.eastNorthUpToFixedFrame(e,t);this._ellipsoid=t,this._origin=e,this._xAxis=Cartesian3.fromCartesian4(StaticMatrix4.getColumn(i,0,scratchCart4)),this._yAxis=Cartesian3.fromCartesian4(StaticMatrix4.getColumn(i,1,scratchCart4));const n=Cartesian3.fromCartesian4(StaticMatrix4.getColumn(i,2,scratchCart4));this._plane=StaticPlane.fromPointNormal(e,n)}static fromPoints(e,t){let i=e[0].x,n=e[0].y,r=e[0].z,s=e[0].x,a=e[0].y,o=e[0].z;for(let d=0;d<e.length;d++){const t=e[d],l=t.x,c=t.y,h=t.z;i=Math.min(l,i),s=Math.max(l,s),n=Math.min(c,n),a=Math.max(c,a),r=Math.min(h,r),o=Math.max(h,o)}const l=new three.Vector3(i,n,r),c=new three.Vector3(s,a,o),h=new three.Box3(l,c);let u=new three.Vector3;return u=h.getCenter(u),new EllipsoidTangentPlane(u,t)}projectPointToNearestOnPlane(e,t){defined$1(t)||(t=new Cartesian2);const i=scratchProjectPointOntoPlaneRay$1;i.origin=e,Cartesian3.clone(this._plane.normal,i.direction);let n=IntersectionTests.rayPlane(i,this._plane,scratchProjectPointOntoPlaneCartesian3$1);if(defined$1(n)||(Cartesian3.negate(i.direction,i.direction),n=IntersectionTests.rayPlane(i,this._plane,scratchProjectPointOntoPlaneCartesian3$1)),defined$1(n)){const e=Cartesian3.subtract(n,this._origin,n),i=Cartesian3.dot(this._xAxis,e),r=Cartesian3.dot(this._yAxis,e);return defined$1(t)?(t.x=i,t.y=r,t):new three.Vector2(i,r)}}projectPointsOntoPlane(e,t){defined$1(t)||(t=[]);let i=0;const n=e.length;for(let r=0;r<n;r++){const n=this.projectPointOntoPlane(e[r],t[i]);n&&(t[i]=n,i++)}return t.length=i,t}projectPointOntoPlane(e,t){const i=scratchProjectPointOntoPlaneRay$1;i.origin=e,Cartesian3.normalize(e,i.direction);let n=IntersectionTests.rayPlane(i,this._plane,scratchProjectPointOntoPlaneCartesian3$1);if(defined$1(n)||(Cartesian3.negate(i.direction,i.direction),n=IntersectionTests.rayPlane(i,this._plane,scratchProjectPointOntoPlaneCartesian3$1)),defined$1(n)){const e=Cartesian3.subtract(n,this._origin,n),i=Cartesian3.dot(this._xAxis,e),r=Cartesian3.dot(this._yAxis,e);return defined$1(t)?(t.x=i,t.y=r,t):new three.Vector2(i,r)}}get ellipsoid(){return this._ellipsoid}get origin(){return this._origin}get plane(){return this._plane}get xAxis(){return this._xAxis}get yAxis(){return this._yAxis}get zAxis(){return this._plane.normal}}const Intersect={OUTSIDE:-1,INTERSECTING:0,INSIDE:1},Intersect$1=Object.freeze(Intersect);class OrientedBoundingBox{constructor(e,t){this.isOrientedBoundingBox=!0,this.center=Cartesian3.clone(defaultValue(e,Cartesian3.ZERO),new three.Vector3),this.halfAxes=StaticMatrix3.clone(defaultValue(t,StaticMatrix3.ZERO))}intersectPlane(e){return OrientedBoundingBox.intersectPlane(this,e)}distanceSquaredTo(e){return OrientedBoundingBox.distanceSquaredTo(this,e)}computeCorners(e){return OrientedBoundingBox.computeCorners(this,e)}getCenter(e){return defined$1(e)?(e.copy(this.center),e):this.center.clone()}intersectsObb(e){const t=this.center,i=e.center,n=this.halfAxes,r=e.halfAxes,s=(new three.Vector3).subVectors(i,t),a=new three.Vector3(n.elements[0],n.elements[1],n.elements[2]),o=new three.Vector3(n.elements[3],n.elements[4],n.elements[5]),l=new three.Vector3(n.elements[6],n.elements[7],n.elements[8]),c=new three.Vector3(r.elements[0],r.elements[1],r.elements[2]),h=new three.Vector3(r.elements[3],r.elements[4],r.elements[5]),u=new three.Vector3(r.elements[6],r.elements[7],r.elements[8]),d=a.length(),p=o.length(),m=l.length();a.normalize(),o.normalize(),l.normalize();const f=c.length(),g=h.length(),_=u.length();let A,v,y;return c.normalize(),h.normalize(),u.normalize(),A=d,v=f*Math.abs(a.dot(c))+g*Math.abs(a.dot(h))+_*Math.abs(a.dot(u)),y=Math.abs(s.dot(a)),!(y>A+v)&&(A=p,v=f*Math.abs(o.dot(c))+g*Math.abs(o.dot(h))+_*Math.abs(o.dot(u)),y=Math.abs(s.dot(o)),!(y>A+v)&&(A=m,v=f*Math.abs(l.dot(c))+g*Math.abs(l.dot(h))+_*Math.abs(l.dot(u)),y=Math.abs(s.dot(l)),!(y>A+v)&&(A=d*Math.abs(c.dot(a))+p*Math.abs(c.dot(o))+m*Math.abs(c.dot(l)),v=f,y=Math.abs(s.dot(c)),!(y>A+v)&&(A=d*Math.abs(h.dot(a))+p*Math.abs(h.dot(o))+m*Math.abs(h.dot(l)),v=g,y=Math.abs(s.dot(h)),!(y>A+v)&&(A=d*Math.abs(u.dot(a))+p*Math.abs(u.dot(o))+m*Math.abs(u.dot(l)),v=_,y=Math.abs(s.dot(u)),!(y>A+v))))))}}const scratchOffset$1=new three.Vector3,scratchScale$1=new three.Vector3;function fromPlaneExtents(e,t,i,n,r,s,a,o,l,c,h){if(!(defined$1(r)&&defined$1(s)&&defined$1(a)&&defined$1(o)&&defined$1(l)&&defined$1(c)))throw new DeveloperError("all extents (minimum/maximum X/Y/Z) are required.");defined$1(h)||(h=new OrientedBoundingBox);const u=h.halfAxes;StaticMatrix3.setColumn(u,0,t,u),StaticMatrix3.setColumn(u,1,i,u),StaticMatrix3.setColumn(u,2,n,u);let d=scratchOffset$1;d.x=(r+s)/2,d.y=(a+o)/2,d.z=(l+c)/2;const p=scratchScale$1;p.x=(s-r)/2,p.y=(o-a)/2,p.z=(c-l)/2;const m=h.center;return d=StaticMatrix3.multiplyByVector(u,d,d),Cartesian3.add(e,d,m),StaticMatrix3.multiplyByScale(u,p,u),h}const scratchRectangleCenterCartographic=new three.Vector3,scratchRectangleCenter=new three.Vector3,scratchPerimeterCartographicNC=new three.Vector3,scratchPerimeterCartographicNW=new three.Vector3,scratchPerimeterCartographicCW=new three.Vector3,scratchPerimeterCartographicSW=new three.Vector3,scratchPerimeterCartographicSC=new three.Vector3,scratchPerimeterCartesianNC=new three.Vector3,scratchPerimeterCartesianNW=new three.Vector3,scratchPerimeterCartesianCW=new three.Vector3,scratchPerimeterCartesianSW=new three.Vector3,scratchPerimeterCartesianSC=new three.Vector3,scratchPerimeterProjectedNC=new three.Vector2,scratchPerimeterProjectedNW=new three.Vector2,scratchPerimeterProjectedCW=new three.Vector2,scratchPerimeterProjectedSW=new three.Vector2,scratchPerimeterProjectedSC=new three.Vector2,scratchPlaneOrigin=new three.Vector3,scratchPlaneNormal=new three.Vector3,scratchPlaneXAxis=new three.Vector3,scratchHorizonCartesian=new three.Vector3,scratchHorizonProjected=new three.Vector2,scratchMaxY=new three.Vector3,scratchMinY=new three.Vector3,scratchZ=new three.Vector3,scratchPlane$1=new three.Plane(new three.Vector3(1,0,0),0);OrientedBoundingBox.fromRectangle=function(e,t,i,n,r){if(!defined$1(e))throw new DeveloperError("rectangle is required");if(e.width<0||e.width>CesiumMath.TWO_PI)throw new DeveloperError("Rectangle width must be between 0 and 2 * pi");if(e.height<0||e.height>CesiumMath.PI)throw new DeveloperError("Rectangle height must be between 0 and pi");if(defined$1(n)&&!CesiumMath.equalsEpsilon(n.radii.x,n.radii.y,CesiumMath.EPSILON15))throw new DeveloperError("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");let s,a,o,l,c,h,u;if(t=defaultValue(t,0),i=defaultValue(i,0),n=defaultValue(n,Ellipsoid.WGS84),e.width<=CesiumMath.PI){const d=Rectangle.center(e,scratchRectangleCenterCartographic),p=n.cartographicToCartesian(d,scratchRectangleCenter),m=new EllipsoidTangentPlane(p,n);u=m.plane;const f=d.x,g=e.south<0&&e.north>0?0:d.y,_=Cartographic.fromRadians(f,e.north,i,scratchPerimeterCartographicNC),A=Cartographic.fromRadians(e.west,e.north,i,scratchPerimeterCartographicNW),v=Cartographic.fromRadians(e.west,g,i,scratchPerimeterCartographicCW),y=Cartographic.fromRadians(e.west,e.south,i,scratchPerimeterCartographicSW),x=Cartographic.fromRadians(f,e.south,i,scratchPerimeterCartographicSC),b=n.cartographicToCartesian(_,scratchPerimeterCartesianNC);let S=n.cartographicToCartesian(A,scratchPerimeterCartesianNW);const C=n.cartographicToCartesian(v,scratchPerimeterCartesianCW);let T=n.cartographicToCartesian(y,scratchPerimeterCartesianSW);const E=n.cartographicToCartesian(x,scratchPerimeterCartesianSC),M=m.projectPointToNearestOnPlane(b,scratchPerimeterProjectedNC),w=m.projectPointToNearestOnPlane(S,scratchPerimeterProjectedNW),I=m.projectPointToNearestOnPlane(C,scratchPerimeterProjectedCW),P=m.projectPointToNearestOnPlane(T,scratchPerimeterProjectedSW),R=m.projectPointToNearestOnPlane(E,scratchPerimeterProjectedSC);return s=Math.min(w.x,I.x,P.x),a=-s,l=Math.max(w.y,M.y),o=Math.min(P.y,R.y),A.z=y.z=t,S=n.cartographicToCartesian(A,scratchPerimeterCartesianNW),T=n.cartographicToCartesian(y,scratchPerimeterCartesianSW),c=Math.min(StaticPlane.getPointDistance(u,S),StaticPlane.getPointDistance(u,T)),h=i,fromPlaneExtents(m.origin,m.xAxis,m.yAxis,m.zAxis,s,a,o,l,c,h,r)}const d=e.south>0,p=e.north<0,m=d?e.south:p?e.north:0,f=Rectangle.center(e,scratchRectangleCenterCartographic).x,g=Cartesian3.fromRadians(f,m,i,n,scratchPlaneOrigin);g.z=0;const _=Math.abs(g.x)<CesiumMath.EPSILON10&&Math.abs(g.y)<CesiumMath.EPSILON10?Cartesian3.UNIT_X:Cartesian3.normalize(g,scratchPlaneNormal),A=Cartesian3.UNIT_Z,v=Cartesian3.cross(_,A,scratchPlaneXAxis);u=StaticPlane.fromPointNormal(g,_,scratchPlane$1);const y=Cartesian3.fromRadians(f+CesiumMath.PI_OVER_TWO,m,i,n,scratchHorizonCartesian);a=Cartesian3.dot(StaticPlane.projectPointOntoPlane(u,y,scratchHorizonProjected),v),s=-a,l=Cartesian3.fromRadians(0,e.north,p?t:i,n,scratchMaxY).z,o=Cartesian3.fromRadians(0,e.south,d?t:i,n,scratchMinY).z;const x=Cartesian3.fromRadians(e.east,m,i,n,scratchZ);return c=StaticPlane.getPointDistance(u,x),h=0,fromPlaneExtents(g,v,A,_,s,a,o,l,c,h,r)};const scratchCartesianU=new three.Vector3,scratchCartesianV=new three.Vector3,scratchCartesianW=new three.Vector3,scratchValidAxis2=new three.Vector3,scratchValidAxis3=new three.Vector3,scratchPPrime=new three.Vector3;OrientedBoundingBox.distanceSquaredTo=function(e,t){if(!defined$1(e))throw new DeveloperError("box is required.");if(!defined$1(t))throw new DeveloperError("cartesian is required.");const i=Cartesian3.subtract(t,e.center,scratchOffset$1),n=e.halfAxes;let r=StaticMatrix3.getColumn(n,0,scratchCartesianU),s=StaticMatrix3.getColumn(n,1,scratchCartesianV),a=StaticMatrix3.getColumn(n,2,scratchCartesianW);const o=Cartesian3.magnitude(r),l=Cartesian3.magnitude(s),c=Cartesian3.magnitude(a);let h=!0,u=!0,d=!0;o>0?Cartesian3.divideByScalar(r,o,r):h=!1,l>0?Cartesian3.divideByScalar(s,l,s):u=!1,c>0?Cartesian3.divideByScalar(a,c,a):d=!1;const p=!h+!u+!d;let m,f,g;if(1===p){let e=r;m=s,f=a,u?d||(e=a,f=r):(e=s,m=r),g=Cartesian3.cross(m,f,scratchValidAxis3),e===r?r=g:e===s?s=g:e===a&&(a=g)}else if(2===p){m=r,u?m=s:d&&(m=a);let e=Cartesian3.UNIT_Y;Cartesian3.equalsEpsilon(e,m,CesiumMath.EPSILON3)&&(e=Cartesian3.UNIT_X),f=Cartesian3.cross(m,e,scratchValidAxis2),Cartesian3.normalize(f,f),g=Cartesian3.cross(m,f,scratchValidAxis3),Cartesian3.normalize(g,g),m===r?(s=f,a=g):m===s?(a=f,r=g):m===a&&(r=f,s=g)}else 3===p&&(r=Cartesian3.UNIT_X,s=Cartesian3.UNIT_Y,a=Cartesian3.UNIT_Z);const _=scratchPPrime;_.x=Cartesian3.dot(i,r),_.y=Cartesian3.dot(i,s),_.z=Cartesian3.dot(i,a);let A,v=0;return _.x<-o?(A=_.x+o,v+=A*A):_.x>o&&(A=_.x-o,v+=A*A),_.y<-l?(A=_.y+l,v+=A*A):_.y>l&&(A=_.y-l,v+=A*A),_.z<-c?(A=_.z+c,v+=A*A):_.z>c&&(A=_.z-c,v+=A*A),v},OrientedBoundingBox.intersectPlane=function(e,t){if(!defined$1(e))throw new DeveloperError("box is required.");if(!defined$1(t))throw new DeveloperError("plane is required.");const i=e.center,n=t.normal,r=e.halfAxes,s=n.x,a=n.y,o=n.z,l=r.elements,c=Math.abs(s*l[StaticMatrix3.COLUMN0ROW0]+a*l[StaticMatrix3.COLUMN0ROW1]+o*l[StaticMatrix3.COLUMN0ROW2])+Math.abs(s*l[StaticMatrix3.COLUMN1ROW0]+a*l[StaticMatrix3.COLUMN1ROW1]+o*l[StaticMatrix3.COLUMN1ROW2])+Math.abs(s*l[StaticMatrix3.COLUMN2ROW0]+a*l[StaticMatrix3.COLUMN2ROW1]+o*l[StaticMatrix3.COLUMN2ROW2]),h=Cartesian3.dot(n.clone(),i)+t.constant;return h<=-c?Intersect$1.OUTSIDE:h>=c?Intersect$1.INSIDE:Intersect$1.INTERSECTING};const scratchXAxis=new three.Vector3,scratchYAxis=new three.Vector3,scratchZAxis=new three.Vector3;OrientedBoundingBox.computeCorners=function(e,t){defined$1(t)||(t=[new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3]);const i=e.center,n=e.halfAxes,r=StaticMatrix3.getColumn(n,0,scratchXAxis),s=StaticMatrix3.getColumn(n,1,scratchYAxis),a=StaticMatrix3.getColumn(n,2,scratchZAxis);return Cartesian3.clone(i,t[0]),Cartesian3.subtract(t[0],r,t[0]),Cartesian3.subtract(t[0],s,t[0]),Cartesian3.subtract(t[0],a,t[0]),Cartesian3.clone(i,t[1]),Cartesian3.subtract(t[1],r,t[1]),Cartesian3.subtract(t[1],s,t[1]),Cartesian3.add(t[1],a,t[1]),Cartesian3.clone(i,t[2]),Cartesian3.subtract(t[2],r,t[2]),Cartesian3.add(t[2],s,t[2]),Cartesian3.subtract(t[2],a,t[2]),Cartesian3.clone(i,t[3]),Cartesian3.subtract(t[3],r,t[3]),Cartesian3.add(t[3],s,t[3]),Cartesian3.add(t[3],a,t[3]),Cartesian3.clone(i,t[4]),Cartesian3.add(t[4],r,t[4]),Cartesian3.subtract(t[4],s,t[4]),Cartesian3.subtract(t[4],a,t[4]),Cartesian3.clone(i,t[5]),Cartesian3.add(t[5],r,t[5]),Cartesian3.subtract(t[5],s,t[5]),Cartesian3.add(t[5],a,t[5]),Cartesian3.clone(i,t[6]),Cartesian3.add(t[6],r,t[6]),Cartesian3.add(t[6],s,t[6]),Cartesian3.subtract(t[6],a,t[6]),Cartesian3.clone(i,t[7]),Cartesian3.add(t[7],r,t[7]),Cartesian3.add(t[7],s,t[7]),Cartesian3.add(t[7],a,t[7]),t},OrientedBoundingBox.fromGeoBoundingBox=function(e,t){if(!defined$1(e))throw new DeveloperError("geoBoundingBox is required.");const i=e.min,n=e.max,r=Rectangle.fromBox(e,null,!0);return OrientedBoundingBox.fromRectangle(r,i.z,n.z,null,t)};class ECEFProjection extends Projection{constructor(){super(...arguments),__publicField(this,"name",PROJECTION_ECEF)}projectCoordinate(e,t){return Ellipsoid.WGS84.cartographicDegreeToCartesian(e,t)}unprojectCoordinate(e,t){return Ellipsoid.WGS84.cartesianToCartographicDegree(e,t)}getGeodeticSurfaceNormal(e,t){t||(t=new three.Vector3);return Ellipsoid.WGS84.geodeticSurfaceNormalCartographic(e,t)}getProjectedSurfaceNormal(e,t){t||(t=new three.Vector3);return Ellipsoid.WGS84.geodeticSurfaceNormal(e,t)}geoBoxToProjectedBox(e,t){return t||(t=new OrientedBoundingBox),t=OrientedBoundingBox.fromGeoBoundingBox(e,t)}getLODSacleOfGeoBoundingBox(e){if(e.min.y>85||e.max.y<-85)return 0;const t=(e.min.y+e.max.y)/2;return Math.cos(three.MathUtils.degToRad(t))}localFrameToFixedFrame(e,t){return t||(t=new three.Matrix4),Transforms.eastNorthUpToFixedFrame(e,null,t),t}}function MercatorProjection(){}function extend$2(e,t){for(let i in t)e[i]=t[i]}function Point(e,t){this.lng=e,this.lat=t}function Pixel(e,t){this.x=e,this.y=t}extend$2(Point.prototype,{equals:function(e){return this.lat===e.lat&&this.lng===e.lng},clone:function(){return new Point(this.lat,this.lng)},getLngSpan:function(e){let t=this.lng,i=Math.abs(e-t);return i>180&&(i=360-i),i},sub:function(e){return new Point(this.lat-e.lat,this.lng-e.lng)},toString:function(){return"Point"}}),extend$2(MercatorProjection,{EARTHRADIUS:6370996.81,MCBAND:[12890594.86,8362377.87,5591021,3481989.83,1678043.12,0],LLBAND:[75,60,45,30,15,0],MC2LL:[[1.410526172116255e-8,898305509648872e-20,-1.9939833816331,200.9824383106796,-187.2403703815547,91.6087516669843,-23.38765649603339,2.57121317296198,-.03801003308653,17337981.2],[-7.435856389565537e-9,8983055097726239e-21,-.78625201886289,96.32687599759846,-1.85204757529826,-59.36935905485877,47.40033549296737,-16.50741931063887,2.28786674699375,10260144.86],[-3.030883460898826e-8,898305509983578e-20,.30071316287616,59.74293618442277,7.357984074871,-25.38371002664745,13.45380521110908,-3.29883767235584,.32710905363475,6856817.37],[-1.981981304930552e-8,8983055099779535e-21,.03278182852591,40.31678527705744,.65659298677277,-4.44255534477492,.85341911805263,.12923347998204,-.04625736007561,4482777.06],[3.09191371068437e-9,8983055096812155e-21,6995724062e-14,23.10934304144901,-.00023663490511,-.6321817810242,-.00663494467273,.03430082397953,-.00466043876332,2555164.4],[2.890871144776878e-9,8983055095805407e-21,-3.068298e-8,7.47137025468032,-353937994e-14,-.02145144861037,-1234426596e-14,.00010322952773,-323890364e-14,826088.5]],LL2MC:[[-.0015702102444,111320.7020616939,0x60e374c3105a3,-0x24bb4115e2e164,0x5cc55543bb0ae8,-0x7ce070193f3784,0x5e7ca61ddf8150,-0x261a578d8b24d0,0x665d60f3742ca,82.5],[.0008277824516172526,111320.7020463578,647795574.6671607,-4082003173.641316,10774905663.51142,-15171875531.51559,12053065338.62167,-5124939663.577472,913311935.9512032,67.5],[.00337398766765,111320.7020202162,4481351.045890365,-23393751.19931662,79682215.47186455,-115964993.2797253,97236711.15602145,-43661946.33752821,8477230.501135234,52.5],[.00220636496208,111320.7020209128,51751.86112841131,3796837.749470245,992013.7397791013,-1221952.21711287,1340652.697009075,-620943.6990984312,144416.9293806241,37.5],[-.0003441963504368392,111320.7020576856,278.2353980772752,2485758.690035394,6070.750963243378,54821.18345352118,9540.606633304236,-2710.55326746645,1405.483844121726,22.5],[-.0003218135878613132,111320.7020701615,.00369383431289,823725.6402795718,.46104986909093,2351.343141331292,1.58060784298199,8.77738589078284,.37238884252424,7.45]],getDistanceByMC:function(e,t){if(!e||!t)return 0;let i,n,r,s;return(e=this.convertMC2LL(e))?(i=this.toRadians(e.lng),n=this.toRadians(e.lat),(t=this.convertMC2LL(t))?(r=this.toRadians(t.lng),s=this.toRadians(t.lat),this.getDistance(i,r,n,s)):0):0},getDistanceByLL:function(e,t){if(!e||!t)return 0;let i,n,r,s;return e.lng=this.getLoop(e.lng,-180,180),e.lat=this.getRange(e.lat,-74,74),t.lng=this.getLoop(t.lng,-180,180),t.lat=this.getRange(t.lat,-74,74),i=this.toRadians(e.lng),r=this.toRadians(e.lat),n=this.toRadians(t.lng),s=this.toRadians(t.lat),this.getDistance(i,n,r,s)},convertMC2LL:function(e){if(null==e)return new Point(0,0);if(e.lng<180&&e.lng>-180&&e.lat<90&&e.lat>-90)return e;let t,i;t=new Point(Math.abs(e.lng),Math.abs(e.lat));for(let r=0;r<this.MCBAND.length;r++)if(t.lat>=this.MCBAND[r]){i=this.MC2LL[r];break}let n=this.convertor(e,i);return e=new Point(n.lng.toFixed(6),n.lat.toFixed(6))},convertLL2MC:function(e){if(null==e)return new Point(0,0);if(e.lng>180||e.lng<-180||e.lat>90||e.lat<-90)return e;let t,i;e.lng=this.getLoop(e.lng,-180,180),e.lat=this.getRange(e.lat,-74,74),t=new Point(e.lng,e.lat);for(var n=0;n<this.LLBAND.length;n++)if(t.lat>=this.LLBAND[n]){i=this.LL2MC[n];break}if(!i)for(n=0;n<this.LLBAND.length;n++)if(t.lat<=-this.LLBAND[n]){i=this.LL2MC[n];break}let r=this.convertor(e,i);return e=new Point(Number(r.lng),Number(r.lat))},convertor:function(e,t){if(!e||!t)return;let i=t[0]+t[1]*Math.abs(e.lng),n=Math.abs(e.lat)/t[9],r=t[2]+t[3]*n+t[4]*n*n+t[5]*n*n*n+t[6]*n*n*n*n+t[7]*n*n*n*n*n+t[8]*n*n*n*n*n*n;return i*=e.lng<0?-1:1,r*=e.lat<0?-1:1,new Point(i,r)},getDistance:function(e,t,i,n){return this.EARTHRADIUS*Math.acos(Math.sin(i)*Math.sin(n)+Math.cos(i)*Math.cos(n)*Math.cos(t-e))},toRadians:function(e){return Math.PI*e/180},toDegrees:function(e){return 180*e/Math.PI},getRange:function(e,t,i){return null!=t&&(e=Math.max(e,t)),null!=i&&(e=Math.min(e,i)),e},getLoop:function(e,t,i){for(;e>i;)e-=i-t;for(;e<t;)e+=i-t;return e}}),extend$2(MercatorProjection.prototype,{lngLatToMercator:function(e){return MercatorProjection.convertLL2MC(e)},lngLatToPoint:function(e){let t=MercatorProjection.convertLL2MC(e);return new Pixel(t.lng,t.lat)},mercatorToLngLat:function(e){return MercatorProjection.convertMC2LL(e)},pointToLngLat:function(e){let t=new Point(e.x,e.y);return MercatorProjection.convertMC2LL(t)},pointToPixel:function(e,t,i,n,r){if(!e)return;e=this.lngLatToMercator(e,r);let s=this.getZoomUnits(t);return new Pixel(Math.round((e.lng-i.lng)/s+n.width/2),Math.round((i.lat-e.lat)/s+n.height/2))},pixelToPoint:function(e,t,i,n,r){if(!e)return;let s=this.getZoomUnits(t),a=new Point(i.lng+s*(e.x-n.width/2),i.lat-s*(e.y-n.height/2));return this.mercatorToLngLat(a,r)},getZoomUnits:function(e){return Math.pow(2,18-e)}});const MAX_X=20037726.36,MAX_Y=12474104.17,MAX_LAT=74,MIN_LAT=-MAX_LAT,_tempInput$1=new three.Vector3;class BaiduMercatorProjection extends Projection{constructor(){super(...arguments),__publicField(this,"name",PROJECTION_BD_MERCATOR),__publicField(this,"isAxisAligned",!0),__publicField(this,"unprojectCoordinate",((e,t,i)=>{t||(t=new three.Vector3),_tempInput$1.copy(e),e.x<-MAX_X&&(_tempInput$1.x=-MAX_X),e.x>MAX_X&&(_tempInput$1.x=MAX_X),e.y<-MAX_Y&&(_tempInput$1.y=-MAX_Y),e.y>MAX_Y&&(_tempInput$1.y=MAX_Y);const n=MercatorProjection.convertMC2LL({lng:_tempInput$1.x,lat:_tempInput$1.y});return t.set(Number(n.lng),Number(n.lat),_tempInput$1.z),i&&(t.x=extendUnprojectCoordinate(e.x,t.x,180,MAX_X),t.y=extendUnprojectCoordinate(e.y,t.y,MAX_LAT,MAX_Y)),t}))}projectCoordinate(e,t,i=!1){t||(t=new three.Vector3),_tempInput$1.copy(e),e.x<-180&&(_tempInput$1.x=-180),e.x>180&&(_tempInput$1.x=180),e.y<MIN_LAT&&(_tempInput$1.y=MIN_LAT),e.y>MAX_LAT&&(_tempInput$1.y=MAX_LAT);const n=MercatorProjection.convertLL2MC({lng:_tempInput$1.x,lat:_tempInput$1.y});return t.set(Number(n.lng),Number(n.lat),_tempInput$1.z),i&&(t.x=extendProjectCoordinate(e.x,t.x,180,MAX_X),t.y=extendProjectCoordinate(e.y,t.y,MAX_LAT,MAX_Y)),t}}const scaleFactor=6378137*Math.PI/180;class GeoProjection extends Projection{constructor(){super(...arguments),__publicField(this,"name",PROJECTION_GEO),__publicField(this,"isGeo",!0),__publicField(this,"isAxisAligned",!0)}projectCoordinate(e,t){return t||(t=new three.Vector3),t.x=e.x*scaleFactor,t.y=e.y*scaleFactor,t.z=e.z,t}unprojectCoordinate(e,t){return t||(t=new three.Vector3),t.x=e.x/scaleFactor,t.y=e.y/scaleFactor,t.z=e.z,t}}class ScreenPixelProjection extends Projection{constructor(){super(...arguments),__publicField(this,"name",PROJECTION_SCREEN_PIXEL),__publicField(this,"isAxisAligned",!0)}projectCoordinate(e,t){return t||(t=new three.Vector3),t.x=e.x,t.y=-e.y,t.z=e.z,t}unprojectCoordinate(e,t){return t||(t=new three.Vector3),t.x=e.x,t.y=-e.y,t.z=e.z,t}}var proj4Src={exports:{}};!function(e,t){e.exports=function(){function e(e){e("EPSG:4326","+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"),e("EPSG:4269","+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"),e("EPSG:3857","+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");for(var t=1;t<=60;++t)e("EPSG:"+(32600+t),"+proj=utm +zone="+t+" +datum=WGS84 +units=m"),e("EPSG:"+(32700+t),"+proj=utm +zone="+t+" +south +datum=WGS84 +units=m");e.WGS84=e["EPSG:4326"],e["EPSG:3785"]=e["EPSG:3857"],e.GOOGLE=e["EPSG:3857"],e["EPSG:900913"]=e["EPSG:3857"],e["EPSG:102113"]=e["EPSG:3857"]}var t=1,i=2,n=3,r=4,s=5,a=6378137,o=6356752.314,l=.0066943799901413165,c=484813681109536e-20,h=Math.PI/2,u=.16666666666666666,d=.04722222222222222,p=.022156084656084655,m=1e-10,f=.017453292519943295,g=57.29577951308232,_=Math.PI/4,A=2*Math.PI,v=3.14159265359,y={greenwich:0,lisbon:-9.131906111111,paris:2.337229166667,bogota:-74.080916666667,madrid:-3.687938888889,rome:12.452333333333,bern:7.439583333333,jakarta:106.807719444444,ferro:-17.666666666667,brussels:4.367975,stockholm:18.058277777778,athens:23.7163375,oslo:10.722916666667},x={mm:{to_meter:.001},cm:{to_meter:.01},ft:{to_meter:.3048},"us-ft":{to_meter:1200/3937},fath:{to_meter:1.8288},kmi:{to_meter:1852},"us-ch":{to_meter:20.1168402336805},"us-mi":{to_meter:1609.34721869444},km:{to_meter:1e3},"ind-ft":{to_meter:.30479841},"ind-yd":{to_meter:.91439523},mi:{to_meter:1609.344},yd:{to_meter:.9144},ch:{to_meter:20.1168},link:{to_meter:.201168},dm:{to_meter:.1},in:{to_meter:.0254},"ind-ch":{to_meter:20.11669506},"us-in":{to_meter:.025400050800101},"us-yd":{to_meter:.914401828803658}},b=/[\s_\-\/\(\)]/g;function S(e,t){if(e[t])return e[t];for(var i,n=Object.keys(e),r=t.toLowerCase().replace(b,""),s=-1;++s<n.length;)if((i=n[s]).toLowerCase().replace(b,"")===r)return e[i]}function C(e){var t,i,n,r={},s=e.split("+").map((function(e){return e.trim()})).filter((function(e){return e})).reduce((function(e,t){var i=t.split("=");return i.push(!0),e[i[0].toLowerCase()]=i[1],e}),{}),a={proj:"projName",datum:"datumCode",rf:function(e){r.rf=parseFloat(e)},lat_0:function(e){r.lat0=e*f},lat_1:function(e){r.lat1=e*f},lat_2:function(e){r.lat2=e*f},lat_ts:function(e){r.lat_ts=e*f},lon_0:function(e){r.long0=e*f},lon_1:function(e){r.long1=e*f},lon_2:function(e){r.long2=e*f},alpha:function(e){r.alpha=parseFloat(e)*f},gamma:function(e){r.rectified_grid_angle=parseFloat(e)*f},lonc:function(e){r.longc=e*f},x_0:function(e){r.x0=parseFloat(e)},y_0:function(e){r.y0=parseFloat(e)},k_0:function(e){r.k0=parseFloat(e)},k:function(e){r.k0=parseFloat(e)},a:function(e){r.a=parseFloat(e)},b:function(e){r.b=parseFloat(e)},r:function(e){r.a=r.b=parseFloat(e)},r_a:function(){r.R_A=!0},zone:function(e){r.zone=parseInt(e,10)},south:function(){r.utmSouth=!0},towgs84:function(e){r.datum_params=e.split(",").map((function(e){return parseFloat(e)}))},to_meter:function(e){r.to_meter=parseFloat(e)},units:function(e){r.units=e;var t=S(x,e);t&&(r.to_meter=t.to_meter)},from_greenwich:function(e){r.from_greenwich=e*f},pm:function(e){var t=S(y,e);r.from_greenwich=(t||parseFloat(e))*f},nadgrids:function(e){"@null"===e?r.datumCode="none":r.nadgrids=e},axis:function(e){var t="ewnsud";3===e.length&&-1!==t.indexOf(e.substr(0,1))&&-1!==t.indexOf(e.substr(1,1))&&-1!==t.indexOf(e.substr(2,1))&&(r.axis=e)},approx:function(){r.approx=!0}};for(t in s)i=s[t],t in a?"function"==typeof(n=a[t])?n(i):r[n]=i:r[t]=i;return"string"==typeof r.datumCode&&"WGS84"!==r.datumCode&&(r.datumCode=r.datumCode.toLowerCase()),r}class T{static getId(e){const t=e.find((e=>Array.isArray(e)&&"ID"===e[0]));return t&&t.length>=3?{authority:t[1],code:parseInt(t[2],10)}:null}static convertUnit(e,t="unit"){if(!e||e.length<3)return{type:t,name:"unknown",conversion_factor:null};const i=e[1],n=parseFloat(e[2])||null,r=e.find((e=>Array.isArray(e)&&"ID"===e[0]));return{type:t,name:i,conversion_factor:n,id:r?{authority:r[1],code:parseInt(r[2],10)}:null}}static convertAxis(e){var t;const i=e[1]||"Unknown";let n;const r=i.match(/^\((.)\)$/);if(r){const e=r[1].toUpperCase();if("E"===e)n="east";else if("N"===e)n="north";else{if("U"!==e)throw new Error(`Unknown axis abbreviation: ${e}`);n="up"}}else n=(null==(t=e[2])?void 0:t.toLowerCase())||"unknown";const s=e.find((e=>Array.isArray(e)&&"ORDER"===e[0])),a=s?parseInt(s[1],10):null,o=e.find((e=>Array.isArray(e)&&("LENGTHUNIT"===e[0]||"ANGLEUNIT"===e[0]||"SCALEUNIT"===e[0])));return{name:i,direction:n,unit:this.convertUnit(o),order:a}}static extractAxes(e){return e.filter((e=>Array.isArray(e)&&"AXIS"===e[0])).map((e=>this.convertAxis(e))).sort(((e,t)=>(e.order||0)-(t.order||0)))}static convert(e,t={}){switch(e[0]){case"PROJCRS":t.type="ProjectedCRS",t.name=e[1],t.base_crs=e.find((e=>Array.isArray(e)&&"BASEGEOGCRS"===e[0]))?this.convert(e.find((e=>Array.isArray(e)&&"BASEGEOGCRS"===e[0]))):null,t.conversion=e.find((e=>Array.isArray(e)&&"CONVERSION"===e[0]))?this.convert(e.find((e=>Array.isArray(e)&&"CONVERSION"===e[0]))):null;const i=e.find((e=>Array.isArray(e)&&"CS"===e[0]));i&&(t.coordinate_system={type:i[1],axis:this.extractAxes(e)});const n=e.find((e=>Array.isArray(e)&&"LENGTHUNIT"===e[0]));if(n){const e=this.convertUnit(n);t.coordinate_system.unit=e}t.id=this.getId(e);break;case"BASEGEOGCRS":case"GEOGCRS":t.type="GeographicCRS",t.name=e[1];const r=e.find((e=>Array.isArray(e)&&("DATUM"===e[0]||"ENSEMBLE"===e[0])));if(r){const i=this.convert(r);"ENSEMBLE"===r[0]?t.datum_ensemble=i:t.datum=i;const n=e.find((e=>Array.isArray(e)&&"PRIMEM"===e[0]));n&&"Greenwich"!==n[1]&&(i.prime_meridian={name:n[1],longitude:parseFloat(n[2])})}t.coordinate_system={type:"ellipsoidal",axis:this.extractAxes(e)},t.id=this.getId(e);break;case"DATUM":t.type="GeodeticReferenceFrame",t.name=e[1],t.ellipsoid=e.find((e=>Array.isArray(e)&&"ELLIPSOID"===e[0]))?this.convert(e.find((e=>Array.isArray(e)&&"ELLIPSOID"===e[0]))):null;break;case"ENSEMBLE":t.type="DatumEnsemble",t.name=e[1],t.members=e.filter((e=>Array.isArray(e)&&"MEMBER"===e[0])).map((e=>({type:"DatumEnsembleMember",name:e[1],id:this.getId(e)})));const s=e.find((e=>Array.isArray(e)&&"ENSEMBLEACCURACY"===e[0]));s&&(t.accuracy=parseFloat(s[1]));const a=e.find((e=>Array.isArray(e)&&"ELLIPSOID"===e[0]));a&&(t.ellipsoid=this.convert(a)),t.id=this.getId(e);break;case"ELLIPSOID":t.type="Ellipsoid",t.name=e[1],t.semi_major_axis=parseFloat(e[2]),t.inverse_flattening=parseFloat(e[3]),e.find((e=>Array.isArray(e)&&"LENGTHUNIT"===e[0]))&&this.convert(e.find((e=>Array.isArray(e)&&"LENGTHUNIT"===e[0])),t);break;case"CONVERSION":t.type="Conversion",t.name=e[1],t.method=e.find((e=>Array.isArray(e)&&"METHOD"===e[0]))?this.convert(e.find((e=>Array.isArray(e)&&"METHOD"===e[0]))):null,t.parameters=e.filter((e=>Array.isArray(e)&&"PARAMETER"===e[0])).map((e=>this.convert(e)));break;case"METHOD":t.type="Method",t.name=e[1],t.id=this.getId(e);break;case"PARAMETER":t.type="Parameter",t.name=e[1],t.value=parseFloat(e[2]),t.unit=this.convertUnit(e.find((e=>Array.isArray(e)&&("LENGTHUNIT"===e[0]||"ANGLEUNIT"===e[0]||"SCALEUNIT"===e[0])))),t.id=this.getId(e);break;case"BOUNDCRS":t.type="BoundCRS";const o=e.find((e=>Array.isArray(e)&&"SOURCECRS"===e[0]));if(o){const e=o.find((e=>Array.isArray(e)));t.source_crs=e?this.convert(e):null}const l=e.find((e=>Array.isArray(e)&&"TARGETCRS"===e[0]));if(l){const e=l.find((e=>Array.isArray(e)));t.target_crs=e?this.convert(e):null}const c=e.find((e=>Array.isArray(e)&&"ABRIDGEDTRANSFORMATION"===e[0]));t.transformation=c?this.convert(c):null;break;case"ABRIDGEDTRANSFORMATION":if(t.type="Transformation",t.name=e[1],t.method=e.find((e=>Array.isArray(e)&&"METHOD"===e[0]))?this.convert(e.find((e=>Array.isArray(e)&&"METHOD"===e[0]))):null,t.parameters=e.filter((e=>Array.isArray(e)&&("PARAMETER"===e[0]||"PARAMETERFILE"===e[0]))).map((e=>"PARAMETER"===e[0]?this.convert(e):"PARAMETERFILE"===e[0]?{name:e[1],value:e[2],id:{authority:"EPSG",code:8656}}:void 0)),7===t.parameters.length){const e=t.parameters[6];"Scale difference"===e.name&&(e.value=Math.round(1e12*(e.value-1))/1e6)}t.id=this.getId(e);break;case"AXIS":t.coordinate_system||(t.coordinate_system={type:"unspecified",axis:[]}),t.coordinate_system.axis.push(this.convertAxis(e));break;case"LENGTHUNIT":const h=this.convertUnit(e,"LinearUnit");t.coordinate_system&&t.coordinate_system.axis&&t.coordinate_system.axis.forEach((e=>{e.unit||(e.unit=h)})),h.conversion_factor&&1!==h.conversion_factor&&t.semi_major_axis&&(t.semi_major_axis={value:t.semi_major_axis,unit:h});break;default:t.keyword=e[0]}return t}}class E extends T{static convert(e,t={}){var i;return super.convert(e,t),"Cartesian"===(null==(i=t.coordinate_system)?void 0:i.subtype)&&delete t.coordinate_system,t.usage&&delete t.usage,t}}class M extends T{static convert(e,t={}){var i,n,r;super.convert(e,t);const s=e.find((e=>Array.isArray(e)&&"CS"===e[0]));s&&(t.coordinate_system={subtype:s[1],axis:this.extractAxes(e)});const a=e.find((e=>Array.isArray(e)&&"USAGE"===e[0]));return a&&(t.usage={scope:null==(i=a.find((e=>Array.isArray(e)&&"SCOPE"===e[0])))?void 0:i[1],area:null==(n=a.find((e=>Array.isArray(e)&&"AREA"===e[0])))?void 0:n[1],bbox:null==(r=a.find((e=>Array.isArray(e)&&"BBOX"===e[0])))?void 0:r.slice(1)}),t}}function w(e){return e.find((e=>Array.isArray(e)&&"USAGE"===e[0]))?"2019":(e.find((e=>Array.isArray(e)&&"CS"===e[0]))||"BOUNDCRS"===e[0]||"PROJCRS"===e[0]||e[0],"2015")}function I(e){return("2019"===w(e)?M:E).convert(e)}function P(e){const t=e.toUpperCase();return t.includes("PROJCRS")||t.includes("GEOGCRS")||t.includes("BOUNDCRS")||t.includes("VERTCRS")||t.includes("LENGTHUNIT")||t.includes("ANGLEUNIT")||t.includes("SCALEUNIT")?"WKT2":(t.includes("PROJCS")||t.includes("GEOGCS")||t.includes("LOCAL_CS")||t.includes("VERT_CS")||t.includes("UNIT"),"WKT1")}var R=1,B=2,D=3,F=4,O=5,L=-1,N=/\s/,V=/[A-Za-z]/,U=/[A-Za-z84_]/,k=/[,\]]/,G=/[\d\.E\-\+]/;function z(e){if("string"!=typeof e)throw new Error("not a string");this.text=e.trim(),this.level=0,this.place=0,this.root=null,this.stack=[],this.currentObject=null,this.state=R}function j(e){return new z(e).output()}function Q(e,t,i){Array.isArray(t)&&(i.unshift(t),t=null);var n=t?{}:e,r=i.reduce((function(e,t){return H(t,e),e}),n);t&&(e[t]=r)}function H(e,t){if(Array.isArray(e)){var i=e.shift();if("PARAMETER"===i&&(i=e.shift()),1===e.length)return Array.isArray(e[0])?(t[i]={},void H(e[0],t[i])):void(t[i]=e[0]);if(e.length)if("TOWGS84"!==i){if("AXIS"===i)return i in t||(t[i]=[]),void t[i].push(e);var n;switch(Array.isArray(i)||(t[i]={}),i){case"UNIT":case"PRIMEM":case"VERT_DATUM":return t[i]={name:e[0].toLowerCase(),convert:e[1]},void(3===e.length&&H(e[2],t[i]));case"SPHEROID":case"ELLIPSOID":return t[i]={name:e[0],a:e[1],rf:e[2]},void(4===e.length&&H(e[3],t[i]));case"EDATUM":case"ENGINEERINGDATUM":case"LOCAL_DATUM":case"DATUM":case"VERT_CS":case"VERTCRS":case"VERTICALCRS":return e[0]=["name",e[0]],void Q(t,i,e);case"COMPD_CS":case"COMPOUNDCRS":case"FITTED_CS":case"PROJECTEDCRS":case"PROJCRS":case"GEOGCS":case"GEOCCS":case"PROJCS":case"LOCAL_CS":case"GEODCRS":case"GEODETICCRS":case"GEODETICDATUM":case"ENGCRS":case"ENGINEERINGCRS":return e[0]=["name",e[0]],Q(t,i,e),void(t[i].type=i);default:for(n=-1;++n<e.length;)if(!Array.isArray(e[n]))return H(e,t[i]);return Q(t,i,e)}}else t[i]=e;else t[i]=!0}else t[e]=!0}z.prototype.readCharicter=function(){var e=this.text[this.place++];if(this.state!==F)for(;N.test(e);){if(this.place>=this.text.length)return;e=this.text[this.place++]}switch(this.state){case R:return this.neutral(e);case B:return this.keyword(e);case F:return this.quoted(e);case O:return this.afterquote(e);case D:return this.number(e);case L:return}},z.prototype.afterquote=function(e){if('"'===e)return this.word+='"',void(this.state=F);if(k.test(e))return this.word=this.word.trim(),void this.afterItem(e);throw new Error("havn't handled \""+e+'" in afterquote yet, index '+this.place)},z.prototype.afterItem=function(e){return","===e?(null!==this.word&&this.currentObject.push(this.word),this.word=null,void(this.state=R)):"]"===e?(this.level--,null!==this.word&&(this.currentObject.push(this.word),this.word=null),this.state=R,this.currentObject=this.stack.pop(),void(this.currentObject||(this.state=L))):void 0},z.prototype.number=function(e){if(!G.test(e)){if(k.test(e))return this.word=parseFloat(this.word),void this.afterItem(e);throw new Error("havn't handled \""+e+'" in number yet, index '+this.place)}this.word+=e},z.prototype.quoted=function(e){'"'!==e?this.word+=e:this.state=O},z.prototype.keyword=function(e){if(U.test(e))this.word+=e;else{if("["===e){var t=[];return t.push(this.word),this.level++,null===this.root?this.root=t:this.currentObject.push(t),this.stack.push(this.currentObject),this.currentObject=t,void(this.state=R)}if(!k.test(e))throw new Error("havn't handled \""+e+'" in keyword yet, index '+this.place);this.afterItem(e)}},z.prototype.neutral=function(e){if(V.test(e))return this.word=e,void(this.state=B);if('"'===e)return this.word="",void(this.state=F);if(G.test(e))return this.word=e,void(this.state=D);if(!k.test(e))throw new Error("havn't handled \""+e+'" in neutral yet, index '+this.place);this.afterItem(e)},z.prototype.output=function(){for(;this.place<this.text.length;)this.readCharicter();if(this.state===L)return this.root;throw new Error('unable to parse string "'+this.text+'". State is '+this.state)};var $=.017453292519943295;function W(e){return e*$}function q(e){const t=(e.projName||"").toLowerCase().replace(/_/g," ");e.long0||!e.longc||"albers conic equal area"!==t&&"lambert azimuthal equal area"!==t||(e.long0=e.longc),e.lat_ts||!e.lat1||"stereographic south pole"!==t&&"polar stereographic (variant b)"!==t?e.lat_ts||!e.lat0||"polar stereographic"!==t&&"polar stereographic (variant a)"!==t||(e.lat_ts=e.lat0,e.lat0=W(e.lat0>0?90:-90),delete e.lat1):(e.lat0=W(e.lat1>0?90:-90),e.lat_ts=e.lat1,delete e.lat1)}function Y(e){let t={units:null,to_meter:void 0};return"string"==typeof e?(t.units=e.toLowerCase(),"metre"===t.units&&(t.units="meter"),"meter"===t.units&&(t.to_meter=1)):(null==e?void 0:e.name)&&(t.units=e.name.toLowerCase(),"metre"===t.units&&(t.units="meter"),t.to_meter=e.conversion_factor),t}function X(e){return"object"==typeof e?e.value*e.unit.conversion_factor:e}function Z(e,t){e.ellipsoid.radius?(t.a=e.ellipsoid.radius,t.rf=0):(t.a=X(e.ellipsoid.semi_major_axis),void 0!==e.ellipsoid.inverse_flattening?t.rf=e.ellipsoid.inverse_flattening:void 0!==e.ellipsoid.semi_major_axis&&void 0!==e.ellipsoid.semi_minor_axis&&(t.rf=t.a/(t.a-X(e.ellipsoid.semi_minor_axis))))}function K(e,t={}){var i;return e&&"object"==typeof e?"BoundCRS"===e.type?(K(e.source_crs,t),e.transformation&&("NTv2"===(null==(i=e.transformation.method)?void 0:i.name)?t.nadgrids=e.transformation.parameters[0].value:t.datum_params=e.transformation.parameters.map((e=>e.value))),t):(Object.keys(e).forEach((i=>{var n,r,s;const a=e[i];if(null!==a)switch(i){case"name":if(t.srsCode)break;t.name=a,t.srsCode=a;break;case"type":"GeographicCRS"===a?t.projName="longlat":"ProjectedCRS"===a&&(t.projName=null==(r=null==(n=e.conversion)?void 0:n.method)?void 0:r.name);break;case"datum":case"datum_ensemble":a.ellipsoid&&(t.ellps=a.ellipsoid.name,Z(a,t)),a.prime_meridian&&(t.from_greenwich=a.prime_meridian.longitude*Math.PI/180);break;case"ellipsoid":t.ellps=a.name,Z(a,t);break;case"prime_meridian":t.long0=(a.longitude||0)*Math.PI/180;break;case"coordinate_system":if(a.axis)if(t.axis=a.axis.map((e=>{const t=e.direction;if("east"===t)return"e";if("north"===t)return"n";if("west"===t)return"w";if("south"===t)return"s";throw new Error(`Unknown axis direction: ${t}`)})).join("")+"u",a.unit){const{units:e,to_meter:i}=Y(a.unit);t.units=e,t.to_meter=i}else if(null==(s=a.axis[0])?void 0:s.unit){const{units:e,to_meter:i}=Y(a.axis[0].unit);t.units=e,t.to_meter=i}break;case"id":a.authority&&a.code&&(t.title=a.authority+":"+a.code);break;case"conversion":a.method&&a.method.name&&(t.projName=a.method.name),a.parameters&&a.parameters.forEach((e=>{const i=e.name.toLowerCase().replace(/\s+/g,"_"),n=e.value;e.unit&&e.unit.conversion_factor?t[i]=n*e.unit.conversion_factor:"degree"===e.unit?t[i]=n*Math.PI/180:t[i]=n}));break;case"unit":a.name&&(t.units=a.name.toLowerCase(),"metre"===t.units&&(t.units="meter")),a.conversion_factor&&(t.to_meter=a.conversion_factor);break;case"base_crs":K(a,t),t.datumCode=a.id?a.id.authority+"_"+a.id.code:a.name}})),void 0!==t.latitude_of_false_origin&&(t.lat0=t.latitude_of_false_origin),void 0!==t.longitude_of_false_origin&&(t.long0=t.longitude_of_false_origin),void 0!==t.latitude_of_standard_parallel&&(t.lat0=t.latitude_of_standard_parallel,t.lat1=t.latitude_of_standard_parallel),void 0!==t.latitude_of_1st_standard_parallel&&(t.lat1=t.latitude_of_1st_standard_parallel),void 0!==t.latitude_of_2nd_standard_parallel&&(t.lat2=t.latitude_of_2nd_standard_parallel),void 0!==t.latitude_of_projection_centre&&(t.lat0=t.latitude_of_projection_centre),void 0!==t.longitude_of_projection_centre&&(t.longc=t.longitude_of_projection_centre),void 0!==t.easting_at_false_origin&&(t.x0=t.easting_at_false_origin),void 0!==t.northing_at_false_origin&&(t.y0=t.northing_at_false_origin),void 0!==t.latitude_of_natural_origin&&(t.lat0=t.latitude_of_natural_origin),void 0!==t.longitude_of_natural_origin&&(t.long0=t.longitude_of_natural_origin),void 0!==t.longitude_of_origin&&(t.long0=t.longitude_of_origin),void 0!==t.false_easting&&(t.x0=t.false_easting),t.easting_at_projection_centre&&(t.x0=t.easting_at_projection_centre),void 0!==t.false_northing&&(t.y0=t.false_northing),t.northing_at_projection_centre&&(t.y0=t.northing_at_projection_centre),void 0!==t.standard_parallel_1&&(t.lat1=t.standard_parallel_1),void 0!==t.standard_parallel_2&&(t.lat2=t.standard_parallel_2),void 0!==t.scale_factor_at_natural_origin&&(t.k0=t.scale_factor_at_natural_origin),void 0!==t.scale_factor_at_projection_centre&&(t.k0=t.scale_factor_at_projection_centre),void 0!==t.scale_factor_on_pseudo_standard_parallel&&(t.k0=t.scale_factor_on_pseudo_standard_parallel),void 0!==t.azimuth&&(t.alpha=t.azimuth),void 0!==t.azimuth_at_projection_centre&&(t.alpha=t.azimuth_at_projection_centre),t.angle_from_rectified_to_skew_grid&&(t.rectified_grid_angle=t.angle_from_rectified_to_skew_grid),q(t),t):e}var J=["PROJECTEDCRS","PROJCRS","GEOGCS","GEOCCS","PROJCS","LOCAL_CS","GEODCRS","GEODETICCRS","GEODETICDATUM","ENGCRS","ENGINEERINGCRS"];function ee(e,t){var i=t[0],n=t[1];!(i in e)&&n in e&&(e[i]=e[n],3===t.length&&(e[i]=t[2](e[i])))}function te(e){for(var t=Object.keys(e),i=0,n=t.length;i<n;++i){var r=t[i];-1!==J.indexOf(r)&&ie(e[r]),"object"==typeof e[r]&&te(e[r])}}function ie(e){if(e.AUTHORITY){var t=Object.keys(e.AUTHORITY)[0];t&&t in e.AUTHORITY&&(e.title=t+":"+e.AUTHORITY[t])}if("GEOGCS"===e.type?e.projName="longlat":"LOCAL_CS"===e.type?(e.projName="identity",e.local=!0):"object"==typeof e.PROJECTION?e.projName=Object.keys(e.PROJECTION)[0]:e.projName=e.PROJECTION,e.AXIS){for(var i="",n=0,r=e.AXIS.length;n<r;++n){var s=[e.AXIS[n][0].toLowerCase(),e.AXIS[n][1].toLowerCase()];-1!==s[0].indexOf("north")||("y"===s[0]||"lat"===s[0])&&"north"===s[1]?i+="n":-1!==s[0].indexOf("south")||("y"===s[0]||"lat"===s[0])&&"south"===s[1]?i+="s":-1!==s[0].indexOf("east")||("x"===s[0]||"lon"===s[0])&&"east"===s[1]?i+="e":-1===s[0].indexOf("west")&&("x"!==s[0]&&"lon"!==s[0]||"west"!==s[1])||(i+="w")}2===i.length&&(i+="u"),3===i.length&&(e.axis=i)}e.UNIT&&(e.units=e.UNIT.name.toLowerCase(),"metre"===e.units&&(e.units="meter"),e.UNIT.convert&&("GEOGCS"===e.type?e.DATUM&&e.DATUM.SPHEROID&&(e.to_meter=e.UNIT.convert*e.DATUM.SPHEROID.a):e.to_meter=e.UNIT.convert));var a=e.GEOGCS;function o(t){return t*(e.to_meter||1)}"GEOGCS"===e.type&&(a=e),a&&(a.DATUM?e.datumCode=a.DATUM.name.toLowerCase():e.datumCode=a.name.toLowerCase(),"d_"===e.datumCode.slice(0,2)&&(e.datumCode=e.datumCode.slice(2)),"new_zealand_1949"===e.datumCode&&(e.datumCode="nzgd49"),"wgs_1984"!==e.datumCode&&"world_geodetic_system_1984"!==e.datumCode||("Mercator_Auxiliary_Sphere"===e.PROJECTION&&(e.sphere=!0),e.datumCode="wgs84"),"belge_1972"===e.datumCode&&(e.datumCode="rnb72"),a.DATUM&&a.DATUM.SPHEROID&&(e.ellps=a.DATUM.SPHEROID.name.replace("_19","").replace(/[Cc]larke\_18/,"clrk"),"international"===e.ellps.toLowerCase().slice(0,13)&&(e.ellps="intl"),e.a=a.DATUM.SPHEROID.a,e.rf=parseFloat(a.DATUM.SPHEROID.rf,10)),a.DATUM&&a.DATUM.TOWGS84&&(e.datum_params=a.DATUM.TOWGS84),~e.datumCode.indexOf("osgb_1936")&&(e.datumCode="osgb36"),~e.datumCode.indexOf("osni_1952")&&(e.datumCode="osni52"),(~e.datumCode.indexOf("tm65")||~e.datumCode.indexOf("geodetic_datum_of_1965"))&&(e.datumCode="ire65"),"ch1903+"===e.datumCode&&(e.datumCode="ch1903"),~e.datumCode.indexOf("israel")&&(e.datumCode="isr93")),e.b&&!isFinite(e.b)&&(e.b=e.a),e.rectified_grid_angle&&(e.rectified_grid_angle=W(e.rectified_grid_angle)),[["standard_parallel_1","Standard_Parallel_1"],["standard_parallel_1","Latitude of 1st standard parallel"],["standard_parallel_2","Standard_Parallel_2"],["standard_parallel_2","Latitude of 2nd standard parallel"],["false_easting","False_Easting"],["false_easting","False easting"],["false-easting","Easting at false origin"],["false_northing","False_Northing"],["false_northing","False northing"],["false_northing","Northing at false origin"],["central_meridian","Central_Meridian"],["central_meridian","Longitude of natural origin"],["central_meridian","Longitude of false origin"],["latitude_of_origin","Latitude_Of_Origin"],["latitude_of_origin","Central_Parallel"],["latitude_of_origin","Latitude of natural origin"],["latitude_of_origin","Latitude of false origin"],["scale_factor","Scale_Factor"],["k0","scale_factor"],["latitude_of_center","Latitude_Of_Center"],["latitude_of_center","Latitude_of_center"],["lat0","latitude_of_center",W],["longitude_of_center","Longitude_Of_Center"],["longitude_of_center","Longitude_of_center"],["longc","longitude_of_center",W],["x0","false_easting",o],["y0","false_northing",o],["long0","central_meridian",W],["lat0","latitude_of_origin",W],["lat0","standard_parallel_1",W],["lat1","standard_parallel_1",W],["lat2","standard_parallel_2",W],["azimuth","Azimuth"],["alpha","azimuth",W],["srsCode","name"]].forEach((function(t){return ee(e,t)})),q(e)}function ne(e){if("object"==typeof e)return K(e);const t=P(e);var i=j(e);if("WKT2"===t)return K(I(i));var n=i[0],r={};return H(i,r),te(r),r[n]}function re(e){var t=this;if(2===arguments.length){var i=arguments[1];"string"==typeof i?"+"===i.charAt(0)?re[e]=C(arguments[1]):re[e]=ne(arguments[1]):re[e]=i}else if(1===arguments.length){if(Array.isArray(e))return e.map((function(e){Array.isArray(e)?re.apply(t,e):re(e)}));if("string"==typeof e){if(e in re)return re[e]}else"EPSG"in e?re["EPSG:"+e.EPSG]=e:"ESRI"in e?re["ESRI:"+e.ESRI]=e:"IAU2000"in e?re["IAU2000:"+e.IAU2000]=e:console.log(e);return}}function se(e){return"string"==typeof e}function ae(e){return e in re}function oe(e){return 0!==e.indexOf("+")&&-1!==e.indexOf("[")||"object"==typeof e&&!("srsCode"in e)}e(re);var le=["3857","900913","3785","102113"];function ce(e){var t=S(e,"authority");if(t){var i=S(t,"epsg");return i&&le.indexOf(i)>-1}}function he(e){var t=S(e,"extension");if(t)return S(t,"proj4")}function ue(e){return"+"===e[0]}function de(e){if(!se(e))return e.projName?e:ne(e);if(ae(e))return re[e];if(oe(e)){var t=ne(e);if(ce(t))return re["EPSG:3857"];var i=he(t);return i?C(i):t}return ue(e)?C(e):void 0}function pe(e,t){var i,n;if(e=e||{},!t)return e;for(n in t)void 0!==(i=t[n])&&(e[n]=i);return e}function me(e,t,i){var n=e*t;return i/Math.sqrt(1-n*n)}function fe(e){return e<0?-1:1}function ge(e){return Math.abs(e)<=v?e:e-fe(e)*A}function _e(e,t,i){var n=e*i,r=.5*e;return n=Math.pow((1-n)/(1+n),r),Math.tan(.5*(h-t))/n}function Ae(e,t){for(var i,n,r=.5*e,s=h-2*Math.atan(t),a=0;a<=15;a++)if(i=e*Math.sin(s),s+=n=h-2*Math.atan(t*Math.pow((1-i)/(1+i),r))-s,Math.abs(n)<=1e-10)return s;return-9999}function ve(){var e=this.b/this.a;this.es=1-e*e,"x0"in this||(this.x0=0),"y0"in this||(this.y0=0),this.e=Math.sqrt(this.es),this.lat_ts?this.sphere?this.k0=Math.cos(this.lat_ts):this.k0=me(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)):this.k0||(this.k?this.k0=this.k:this.k0=1)}function ye(e){var t,i,n=e.x,r=e.y;if(r*g>90&&r*g<-90&&n*g>180&&n*g<-180)return null;if(Math.abs(Math.abs(r)-h)<=m)return null;if(this.sphere)t=this.x0+this.a*this.k0*ge(n-this.long0),i=this.y0+this.a*this.k0*Math.log(Math.tan(_+.5*r));else{var s=Math.sin(r),a=_e(this.e,r,s);t=this.x0+this.a*this.k0*ge(n-this.long0),i=this.y0-this.a*this.k0*Math.log(a)}return e.x=t,e.y=i,e}function xe(e){var t,i,n=e.x-this.x0,r=e.y-this.y0;if(this.sphere)i=h-2*Math.atan(Math.exp(-r/(this.a*this.k0)));else{var s=Math.exp(-r/(this.a*this.k0));if(-9999===(i=Ae(this.e,s)))return null}return t=ge(this.long0+n/(this.a*this.k0)),e.x=t,e.y=i,e}function be(){}function Se(e){return e}var Ce=[{init:ve,forward:ye,inverse:xe,names:["Mercator","Popular Visualisation Pseudo Mercator","Mercator_1SP","Mercator_Auxiliary_Sphere","Mercator_Variant_A","merc"]},{init:be,forward:Se,inverse:Se,names:["longlat","identity"]}],Te={},Ee=[];function Me(e,t){var i=Ee.length;return e.names?(Ee[i]=e,e.names.forEach((function(e){Te[e.toLowerCase()]=i})),this):(console.log(t),!0)}function we(e){return e.replace(/[-\(\)\s]+/g," ").trim().replace(/ /g,"_")}function Ie(e){if(!e)return!1;var t=e.toLowerCase();return void 0!==Te[t]&&Ee[Te[t]]||(t=we(t))in Te&&Ee[Te[t]]?Ee[Te[t]]:void 0}function Pe(){Ce.forEach(Me)}var Re={start:Pe,add:Me,get:Ie},Be={MERIT:{a:6378137,rf:298.257,ellipseName:"MERIT 1983"},SGS85:{a:6378136,rf:298.257,ellipseName:"Soviet Geodetic System 85"},GRS80:{a:6378137,rf:298.257222101,ellipseName:"GRS 1980(IUGG, 1980)"},IAU76:{a:6378140,rf:298.257,ellipseName:"IAU 1976"},airy:{a:6377563.396,b:6356256.91,ellipseName:"Airy 1830"},APL4:{a:6378137,rf:298.25,ellipseName:"Appl. Physics. 1965"},NWL9D:{a:6378145,rf:298.25,ellipseName:"Naval Weapons Lab., 1965"},mod_airy:{a:6377340.189,b:6356034.446,ellipseName:"Modified Airy"},andrae:{a:6377104.43,rf:300,ellipseName:"Andrae 1876 (Den., Iclnd.)"},aust_SA:{a:6378160,rf:298.25,ellipseName:"Australian Natl & S. Amer. 1969"},GRS67:{a:6378160,rf:298.247167427,ellipseName:"GRS 67(IUGG 1967)"},bessel:{a:6377397.155,rf:299.1528128,ellipseName:"Bessel 1841"},bess_nam:{a:6377483.865,rf:299.1528128,ellipseName:"Bessel 1841 (Namibia)"},clrk66:{a:6378206.4,b:6356583.8,ellipseName:"Clarke 1866"},clrk80:{a:6378249.145,rf:293.4663,ellipseName:"Clarke 1880 mod."},clrk80ign:{a:6378249.2,b:6356515,rf:293.4660213,ellipseName:"Clarke 1880 (IGN)"},clrk58:{a:6378293.645208759,rf:294.2606763692654,ellipseName:"Clarke 1858"},CPM:{a:6375738.7,rf:334.29,ellipseName:"Comm. des Poids et Mesures 1799"},delmbr:{a:6376428,rf:311.5,ellipseName:"Delambre 1810 (Belgium)"},engelis:{a:6378136.05,rf:298.2566,ellipseName:"Engelis 1985"},evrst30:{a:6377276.345,rf:300.8017,ellipseName:"Everest 1830"},evrst48:{a:6377304.063,rf:300.8017,ellipseName:"Everest 1948"},evrst56:{a:6377301.243,rf:300.8017,ellipseName:"Everest 1956"},evrst69:{a:6377295.664,rf:300.8017,ellipseName:"Everest 1969"},evrstSS:{a:6377298.556,rf:300.8017,ellipseName:"Everest (Sabah & Sarawak)"},fschr60:{a:6378166,rf:298.3,ellipseName:"Fischer (Mercury Datum) 1960"},fschr60m:{a:6378155,rf:298.3,ellipseName:"Fischer 1960"},fschr68:{a:6378150,rf:298.3,ellipseName:"Fischer 1968"},helmert:{a:6378200,rf:298.3,ellipseName:"Helmert 1906"},hough:{a:6378270,rf:297,ellipseName:"Hough"},intl:{a:6378388,rf:297,ellipseName:"International 1909 (Hayford)"},kaula:{a:6378163,rf:298.24,ellipseName:"Kaula 1961"},lerch:{a:6378139,rf:298.257,ellipseName:"Lerch 1979"},mprts:{a:6397300,rf:191,ellipseName:"Maupertius 1738"},new_intl:{a:6378157.5,b:6356772.2,ellipseName:"New International 1967"},plessis:{a:6376523,rf:6355863,ellipseName:"Plessis 1817 (France)"},krass:{a:6378245,rf:298.3,ellipseName:"Krassovsky, 1942"},SEasia:{a:6378155,b:6356773.3205,ellipseName:"Southeast Asia"},walbeck:{a:6376896,b:6355834.8467,ellipseName:"Walbeck"},WGS60:{a:6378165,rf:298.3,ellipseName:"WGS 60"},WGS66:{a:6378145,rf:298.25,ellipseName:"WGS 66"},WGS7:{a:6378135,rf:298.26,ellipseName:"WGS 72"},WGS84:{a:6378137,rf:298.257223563,ellipseName:"WGS 84"},sphere:{a:6370997,b:6370997,ellipseName:"Normal Sphere (r=6370997)"}};const De=Be.WGS84;function Fe(e,t,i,n){var r=e*e,s=t*t,a=(r-s)/r,o=0;return n?(r=(e*=1-a*(u+a*(d+a*p)))*e,a=0):o=Math.sqrt(a),{es:a,e:o,ep2:(r-s)/s}}function Oe(e,t,i,n,r){if(!e){var s=S(Be,n);s||(s=De),e=s.a,t=s.b,i=s.rf}return i&&!t&&(t=(1-1/i)*e),(0===i||Math.abs(e-t)<m)&&(r=!0,t=e),{a:e,b:t,rf:i,sphere:r}}var Le={wgs84:{towgs84:"0,0,0",ellipse:"WGS84",datumName:"WGS84"},ch1903:{towgs84:"674.374,15.056,405.346",ellipse:"bessel",datumName:"swiss"},ggrs87:{towgs84:"-199.87,74.79,246.62",ellipse:"GRS80",datumName:"Greek_Geodetic_Reference_System_1987"},nad83:{towgs84:"0,0,0",ellipse:"GRS80",datumName:"North_American_Datum_1983"},nad27:{nadgrids:"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",ellipse:"clrk66",datumName:"North_American_Datum_1927"},potsdam:{towgs84:"598.1,73.7,418.2,0.202,0.045,-2.455,6.7",ellipse:"bessel",datumName:"Potsdam Rauenberg 1950 DHDN"},carthage:{towgs84:"-263.0,6.0,431.0",ellipse:"clark80",datumName:"Carthage 1934 Tunisia"},hermannskogel:{towgs84:"577.326,90.129,463.919,5.137,1.474,5.297,2.4232",ellipse:"bessel",datumName:"Hermannskogel"},mgi:{towgs84:"577.326,90.129,463.919,5.137,1.474,5.297,2.4232",ellipse:"bessel",datumName:"Militar-Geographische Institut"},osni52:{towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"airy",datumName:"Irish National"},ire65:{towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"mod_airy",datumName:"Ireland 1965"},rassadiran:{towgs84:"-133.63,-157.5,-158.62",ellipse:"intl",datumName:"Rassadiran"},nzgd49:{towgs84:"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",ellipse:"intl",datumName:"New Zealand Geodetic Datum 1949"},osgb36:{towgs84:"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",ellipse:"airy",datumName:"Ordnance Survey of Great Britain 1936"},s_jtsk:{towgs84:"589,76,480",ellipse:"bessel",datumName:"S-JTSK (Ferro)"},beduaram:{towgs84:"-106,-87,188",ellipse:"clrk80",datumName:"Beduaram"},gunung_segara:{towgs84:"-403,684,41",ellipse:"bessel",datumName:"Gunung Segara Jakarta"},rnb72:{towgs84:"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",ellipse:"intl",datumName:"Reseau National Belge 1972"},EPSG_5451:{towgs84:"6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649"},IGNF_LURESG:{towgs84:"-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43"},EPSG_4614:{towgs84:"-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065"},EPSG_4615:{towgs84:"-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748"},ESRI_37241:{towgs84:"-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031"},ESRI_37249:{towgs84:"-440.296,58.548,296.265,1.128,10.202,4.559,-0.438"},ESRI_37245:{towgs84:"-511.151,-181.269,139.609,1.05,2.703,1.798,3.071"},EPSG_4178:{towgs84:"24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01"},EPSG_4622:{towgs84:"-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984"},EPSG_4625:{towgs84:"126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227"},EPSG_5252:{towgs84:"0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439"},EPSG_4314:{towgs84:"597.1,71.4,412.1,0.894,0.068,-1.563,7.58"},EPSG_4282:{towgs84:"-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166"},EPSG_4231:{towgs84:"-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218"},EPSG_4274:{towgs84:"-230.994,102.591,25.199,0.633,-0.239,0.9,1.95"},EPSG_4134:{towgs84:"-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006"},EPSG_4254:{towgs84:"18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013"},EPSG_4159:{towgs84:"-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175"},EPSG_4687:{towgs84:"0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093"},EPSG_4227:{towgs84:"-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225"},EPSG_4746:{towgs84:"599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46"},EPSG_4745:{towgs84:"612.4,77,440.2,-0.054,0.057,-2.797,2.55"},EPSG_6311:{towgs84:"8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926"},EPSG_4289:{towgs84:"565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244"},EPSG_4230:{towgs84:"-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4"},EPSG_4154:{towgs84:"-123.02,-158.95,-168.47"},EPSG_4156:{towgs84:"570.8,85.7,462.8,4.998,1.587,5.261,3.56"},EPSG_4299:{towgs84:"482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"},EPSG_4179:{towgs84:"33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84"},EPSG_4313:{towgs84:"-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747"},EPSG_4194:{towgs84:"163.511,127.533,-159.789"},EPSG_4195:{towgs84:"105,326,-102.5"},EPSG_4196:{towgs84:"-45,417,-3.5"},EPSG_4611:{towgs84:"-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246"},EPSG_4633:{towgs84:"137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824"},EPSG_4641:{towgs84:"-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993"},EPSG_4643:{towgs84:"-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002"},EPSG_4300:{towgs84:"482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"},EPSG_4188:{towgs84:"482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"},EPSG_4660:{towgs84:"982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805"},EPSG_4662:{towgs84:"97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259"},EPSG_3906:{towgs84:"577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664"},EPSG_4307:{towgs84:"-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547"},EPSG_6892:{towgs84:"-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686"},EPSG_4690:{towgs84:"221.597,152.441,176.523,2.403,1.3893,0.884,11.4648"},EPSG_4691:{towgs84:"218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817"},EPSG_4629:{towgs84:"72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653"},EPSG_4630:{towgs84:"165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111"},EPSG_4692:{towgs84:"217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093"},EPSG_9333:{towgs84:"0,0,0,-8.393,0.749,-10.276,0"},EPSG_9059:{towgs84:"0,0,0"},EPSG_4312:{towgs84:"601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887"},EPSG_4123:{towgs84:"-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496"},EPSG_4309:{towgs84:"-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365"},ESRI_104106:{towgs84:"-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058"},EPSG_4281:{towgs84:"-219.247,-73.802,269.529"},EPSG_4322:{towgs84:"0,0,4.5"},EPSG_4324:{towgs84:"0,0,1.9"},EPSG_4284:{towgs84:"43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549"},EPSG_4277:{towgs84:"446.448,-125.157,542.06,0.15,0.247,0.842,-20.489"},EPSG_4207:{towgs84:"-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46"},EPSG_4688:{towgs84:"347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647"},EPSG_4689:{towgs84:"410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218"},EPSG_4720:{towgs84:"0,0,4.5"},EPSG_4273:{towgs84:"278.3,93,474.5,7.889,0.05,-6.61,6.21"},EPSG_4240:{towgs84:"204.64,834.74,293.8"},EPSG_4817:{towgs84:"278.3,93,474.5,7.889,0.05,-6.61,6.21"},ESRI_104131:{towgs84:"426.62,142.62,460.09,4.98,4.49,-12.42,-17.1"},EPSG_4265:{towgs84:"-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68"},EPSG_4263:{towgs84:"-111.92,-87.85,114.5,1.875,0.202,0.219,0.032"},EPSG_4298:{towgs84:"-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536"},EPSG_4270:{towgs84:"-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424"},EPSG_4229:{towgs84:"-121.8,98.1,-10.7"},EPSG_4220:{towgs84:"-55.5,-348,-229.2"},EPSG_4214:{towgs84:"12.646,-155.176,-80.863"},EPSG_4232:{towgs84:"-345,3,223"},EPSG_4238:{towgs84:"-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037"},EPSG_4168:{towgs84:"-170,33,326"},EPSG_4131:{towgs84:"199,931,318.9"},EPSG_4152:{towgs84:"-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"},EPSG_5228:{towgs84:"572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378"},EPSG_8351:{towgs84:"485.021,169.465,483.839,7.786342,4.397554,4.102655,0"},EPSG_4683:{towgs84:"-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06"},EPSG_4133:{towgs84:"0,0,0"},EPSG_7373:{towgs84:"0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693"},EPSG_9075:{towgs84:"-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"},EPSG_9072:{towgs84:"-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"},EPSG_9294:{towgs84:"1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388"},EPSG_4212:{towgs84:"-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492"},EPSG_4191:{towgs84:"-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703"},EPSG_4237:{towgs84:"52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191"},EPSG_4740:{towgs84:"-1.08,-0.27,-0.9"},EPSG_4124:{towgs84:"419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496"},EPSG_5681:{towgs84:"584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922"},EPSG_4141:{towgs84:"23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262"},EPSG_4204:{towgs84:"-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194"},EPSG_4319:{towgs84:"226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798"},EPSG_4200:{towgs84:"24.82,-131.21,-82.66"},EPSG_4130:{towgs84:"0,0,0"},EPSG_4127:{towgs84:"-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359"},EPSG_4149:{towgs84:"674.374,15.056,405.346"},EPSG_4617:{towgs84:"-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0"},EPSG_4663:{towgs84:"-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485"},EPSG_4664:{towgs84:"-211.939,137.626,58.3,-0.089,0.251,0.079,0.384"},EPSG_4665:{towgs84:"-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048"},EPSG_4666:{towgs84:"631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"},EPSG_4756:{towgs84:"-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188"},EPSG_4723:{towgs84:"-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925"},EPSG_4726:{towgs84:"8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081"},EPSG_4267:{towgs84:"-8.0,160.0,176.0"},EPSG_5365:{towgs84:"-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693"},EPSG_4218:{towgs84:"304.5,306.5,-318.1"},EPSG_4242:{towgs84:"-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95"},EPSG_4216:{towgs84:"-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289"},ESRI_104105:{towgs84:"631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"},ESRI_104129:{towgs84:"0,0,0"},EPSG_4673:{towgs84:"174.05,-25.49,112.57"},EPSG_4202:{towgs84:"-124,-60,154"},EPSG_4203:{towgs84:"-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191"},EPSG_3819:{towgs84:"595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408"},EPSG_8694:{towgs84:"-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169"},EPSG_4145:{towgs84:"275.57,676.78,229.6"},EPSG_4283:{towgs84:"61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994"},EPSG_4317:{towgs84:"2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266"},EPSG_4272:{towgs84:"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993"},EPSG_4248:{towgs84:"-307.7,265.3,-363.5"},EPSG_5561:{towgs84:"24,-121,-76"},EPSG_5233:{towgs84:"-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338"},ESRI_104130:{towgs84:"-86,-98,-119"},ESRI_104102:{towgs84:"682,-203,480"},ESRI_37207:{towgs84:"7,-10,-26"},EPSG_4675:{towgs84:"59.935,118.4,-10.871"},ESRI_104109:{towgs84:"-89.121,-348.182,260.871"},ESRI_104112:{towgs84:"-185.583,-230.096,281.361"},ESRI_104113:{towgs84:"25.1,-275.6,222.6"},IGNF_WGS72G:{towgs84:"0,12,6"},IGNF_NTFG:{towgs84:"-168,-60,320"},IGNF_EFATE57G:{towgs84:"-127,-769,472"},IGNF_PGP50G:{towgs84:"324.8,153.6,172.1"},IGNF_REUN47G:{towgs84:"94,-948,-1262"},IGNF_CSG67G:{towgs84:"-186,230,110"},IGNF_GUAD48G:{towgs84:"-467,-16,-300"},IGNF_TAHI51G:{towgs84:"162,117,154"},IGNF_TAHAAG:{towgs84:"65,342,77"},IGNF_NUKU72G:{towgs84:"84,274,65"},IGNF_PETRELS72G:{towgs84:"365,194,166"},IGNF_WALL78G:{towgs84:"253,-133,-127"},IGNF_MAYO50G:{towgs84:"-382,-59,-262"},IGNF_TANNAG:{towgs84:"-139,-967,436"},IGNF_IGN72G:{towgs84:"-13,-348,292"},IGNF_ATIGG:{towgs84:"1118,23,66"},IGNF_FANGA84G:{towgs84:"150.57,158.33,118.32"},IGNF_RUSAT84G:{towgs84:"202.13,174.6,-15.74"},IGNF_KAUE70G:{towgs84:"126.74,300.1,-75.49"},IGNF_MOP90G:{towgs84:"-10.8,-1.8,12.77"},IGNF_MHPF67G:{towgs84:"338.08,212.58,-296.17"},IGNF_TAHI79G:{towgs84:"160.61,116.05,153.69"},IGNF_ANAA92G:{towgs84:"1.5,3.84,4.81"},IGNF_MARQUI72G:{towgs84:"330.91,-13.92,58.56"},IGNF_APAT86G:{towgs84:"143.6,197.82,74.05"},IGNF_TUBU69G:{towgs84:"237.17,171.61,-77.84"},IGNF_STPM50G:{towgs84:"11.363,424.148,373.13"},EPSG_4150:{towgs84:"674.374,15.056,405.346"},EPSG_4754:{towgs84:"-208.4058,-109.8777,-2.5764"},ESRI_104101:{towgs84:"374,150,588"},EPSG_4693:{towgs84:"0,-0.15,0.68"},EPSG_6207:{towgs84:"293.17,726.18,245.36"},EPSG_4153:{towgs84:"-133.63,-157.5,-158.62"},EPSG_4132:{towgs84:"-241.54,-163.64,396.06"},EPSG_4221:{towgs84:"-154.5,150.7,100.4"},EPSG_4266:{towgs84:"-80.7,-132.5,41.1"},EPSG_4193:{towgs84:"-70.9,-151.8,-41.4"},EPSG_5340:{towgs84:"-0.41,0.46,-0.35"},EPSG_4246:{towgs84:"-294.7,-200.1,525.5"},EPSG_4318:{towgs84:"-3.2,-5.7,2.8"},EPSG_4121:{towgs84:"-199.87,74.79,246.62"},EPSG_4223:{towgs84:"-260.1,5.5,432.2"},EPSG_4158:{towgs84:"-0.465,372.095,171.736"},EPSG_4285:{towgs84:"-128.16,-282.42,21.93"},EPSG_4613:{towgs84:"-404.78,685.68,45.47"},EPSG_4607:{towgs84:"195.671,332.517,274.607"},EPSG_4475:{towgs84:"-381.788,-57.501,-256.673"},EPSG_4208:{towgs84:"-157.84,308.54,-146.6"},EPSG_4743:{towgs84:"70.995,-335.916,262.898"},EPSG_4710:{towgs84:"-323.65,551.39,-491.22"},EPSG_7881:{towgs84:"-0.077,0.079,0.086"},EPSG_4682:{towgs84:"283.729,735.942,261.143"},EPSG_4739:{towgs84:"-156,-271,-189"},EPSG_4679:{towgs84:"-80.01,253.26,291.19"},EPSG_4750:{towgs84:"-56.263,16.136,-22.856"},EPSG_4644:{towgs84:"-10.18,-350.43,291.37"},EPSG_4695:{towgs84:"-103.746,-9.614,-255.95"},EPSG_4292:{towgs84:"-355,21,72"},EPSG_4302:{towgs84:"-61.702,284.488,472.052"},EPSG_4143:{towgs84:"-124.76,53,466.79"},EPSG_4606:{towgs84:"-153,153,307"},EPSG_4699:{towgs84:"-770.1,158.4,-498.2"},EPSG_4247:{towgs84:"-273.5,110.6,-357.9"},EPSG_4160:{towgs84:"8.88,184.86,106.69"},EPSG_4161:{towgs84:"-233.43,6.65,173.64"},EPSG_9251:{towgs84:"-9.5,122.9,138.2"},EPSG_9253:{towgs84:"-78.1,101.6,133.3"},EPSG_4297:{towgs84:"-198.383,-240.517,-107.909"},EPSG_4269:{towgs84:"0,0,0"},EPSG_4301:{towgs84:"-147,506,687"},EPSG_4618:{towgs84:"-59,-11,-52"},EPSG_4612:{towgs84:"0,0,0"},EPSG_4678:{towgs84:"44.585,-131.212,-39.544"},EPSG_4250:{towgs84:"-130,29,364"},EPSG_4144:{towgs84:"214,804,268"},EPSG_4147:{towgs84:"-17.51,-108.32,-62.39"},EPSG_4259:{towgs84:"-254.1,-5.36,-100.29"},EPSG_4164:{towgs84:"-76,-138,67"},EPSG_4211:{towgs84:"-378.873,676.002,-46.255"},EPSG_4182:{towgs84:"-422.651,-172.995,84.02"},EPSG_4224:{towgs84:"-143.87,243.37,-33.52"},EPSG_4225:{towgs84:"-205.57,168.77,-4.12"},EPSG_5527:{towgs84:"-67.35,3.88,-38.22"},EPSG_4752:{towgs84:"98,390,-22"},EPSG_4310:{towgs84:"-30,190,89"},EPSG_9248:{towgs84:"-192.26,65.72,132.08"},EPSG_4680:{towgs84:"124.5,-63.5,-281"},EPSG_4701:{towgs84:"-79.9,-158,-168.9"},EPSG_4706:{towgs84:"-146.21,112.63,4.05"},EPSG_4805:{towgs84:"682,-203,480"},EPSG_4201:{towgs84:"-165,-11,206"},EPSG_4210:{towgs84:"-157,-2,-299"},EPSG_4183:{towgs84:"-104,167,-38"},EPSG_4139:{towgs84:"11,72,-101"},EPSG_4668:{towgs84:"-86,-98,-119"},EPSG_4717:{towgs84:"-2,151,181"},EPSG_4732:{towgs84:"102,52,-38"},EPSG_4280:{towgs84:"-377,681,-50"},EPSG_4209:{towgs84:"-138,-105,-289"},EPSG_4261:{towgs84:"31,146,47"},EPSG_4658:{towgs84:"-73,46,-86"},EPSG_4721:{towgs84:"265.025,384.929,-194.046"},EPSG_4222:{towgs84:"-136,-108,-292"},EPSG_4601:{towgs84:"-255,-15,71"},EPSG_4602:{towgs84:"725,685,536"},EPSG_4603:{towgs84:"72,213.7,93"},EPSG_4605:{towgs84:"9,183,236"},EPSG_4621:{towgs84:"137,248,-430"},EPSG_4657:{towgs84:"-28,199,5"},EPSG_4316:{towgs84:"103.25,-100.4,-307.19"},EPSG_4642:{towgs84:"-13,-348,292"},EPSG_4698:{towgs84:"145,-187,103"},EPSG_4192:{towgs84:"-206.1,-174.7,-87.7"},EPSG_4311:{towgs84:"-265,120,-358"},EPSG_4135:{towgs84:"58,-283,-182"},ESRI_104138:{towgs84:"198,-226,-347"},EPSG_4245:{towgs84:"-11,851,5"},EPSG_4142:{towgs84:"-125,53,467"},EPSG_4213:{towgs84:"-106,-87,188"},EPSG_4253:{towgs84:"-133,-77,-51"},EPSG_4129:{towgs84:"-132,-110,-335"},EPSG_4713:{towgs84:"-77,-128,142"},EPSG_4239:{towgs84:"217,823,299"},EPSG_4146:{towgs84:"295,736,257"},EPSG_4155:{towgs84:"-83,37,124"},EPSG_4165:{towgs84:"-173,253,27"},EPSG_4672:{towgs84:"175,-38,113"},EPSG_4236:{towgs84:"-637,-549,-203"},EPSG_4251:{towgs84:"-90,40,88"},EPSG_4271:{towgs84:"-2,374,172"},EPSG_4175:{towgs84:"-88,4,101"},EPSG_4716:{towgs84:"298,-304,-375"},EPSG_4315:{towgs84:"-23,259,-9"},EPSG_4744:{towgs84:"-242.2,-144.9,370.3"},EPSG_4244:{towgs84:"-97,787,86"},EPSG_4293:{towgs84:"616,97,-251"},EPSG_4714:{towgs84:"-127,-769,472"},EPSG_4736:{towgs84:"260,12,-147"},EPSG_6883:{towgs84:"-235,-110,393"},EPSG_6894:{towgs84:"-63,176,185"},EPSG_4205:{towgs84:"-43,-163,45"},EPSG_4256:{towgs84:"41,-220,-134"},EPSG_4262:{towgs84:"639,405,60"},EPSG_4604:{towgs84:"174,359,365"},EPSG_4169:{towgs84:"-115,118,426"},EPSG_4620:{towgs84:"-106,-129,165"},EPSG_4184:{towgs84:"-203,141,53"},EPSG_4616:{towgs84:"-289,-124,60"},EPSG_9403:{towgs84:"-307,-92,127"},EPSG_4684:{towgs84:"-133,-321,50"},EPSG_4708:{towgs84:"-491,-22,435"},EPSG_4707:{towgs84:"114,-116,-333"},EPSG_4709:{towgs84:"145,75,-272"},EPSG_4712:{towgs84:"-205,107,53"},EPSG_4711:{towgs84:"124,-234,-25"},EPSG_4718:{towgs84:"230,-199,-752"},EPSG_4719:{towgs84:"211,147,111"},EPSG_4724:{towgs84:"208,-435,-229"},EPSG_4725:{towgs84:"189,-79,-202"},EPSG_4735:{towgs84:"647,1777,-1124"},EPSG_4722:{towgs84:"-794,119,-298"},EPSG_4728:{towgs84:"-307,-92,127"},EPSG_4734:{towgs84:"-632,438,-609"},EPSG_4727:{towgs84:"912,-58,1227"},EPSG_4729:{towgs84:"185,165,42"},EPSG_4730:{towgs84:"170,42,84"},EPSG_4733:{towgs84:"276,-57,149"},ESRI_37218:{towgs84:"230,-199,-752"},ESRI_37240:{towgs84:"-7,215,225"},ESRI_37221:{towgs84:"252,-209,-751"},ESRI_4305:{towgs84:"-123,-206,219"},ESRI_104139:{towgs84:"-73,-247,227"},EPSG_4748:{towgs84:"51,391,-36"},EPSG_4219:{towgs84:"-384,664,-48"},EPSG_4255:{towgs84:"-333,-222,114"},EPSG_4257:{towgs84:"-587.8,519.75,145.76"},EPSG_4646:{towgs84:"-963,510,-359"},EPSG_6881:{towgs84:"-24,-203,268"},EPSG_6882:{towgs84:"-183,-15,273"},EPSG_4715:{towgs84:"-104,-129,239"},IGNF_RGF93GDD:{towgs84:"0,0,0"},IGNF_RGM04GDD:{towgs84:"0,0,0"},IGNF_RGSPM06GDD:{towgs84:"0,0,0"},IGNF_RGTAAF07GDD:{towgs84:"0,0,0"},IGNF_RGFG95GDD:{towgs84:"0,0,0"},IGNF_RGNCG:{towgs84:"0,0,0"},IGNF_RGPFGDD:{towgs84:"0,0,0"},IGNF_ETRS89G:{towgs84:"0,0,0"},IGNF_RGR92GDD:{towgs84:"0,0,0"},EPSG_4173:{towgs84:"0,0,0"},EPSG_4180:{towgs84:"0,0,0"},EPSG_4619:{towgs84:"0,0,0"},EPSG_4667:{towgs84:"0,0,0"},EPSG_4075:{towgs84:"0,0,0"},EPSG_6706:{towgs84:"0,0,0"},EPSG_7798:{towgs84:"0,0,0"},EPSG_4661:{towgs84:"0,0,0"},EPSG_4669:{towgs84:"0,0,0"},EPSG_8685:{towgs84:"0,0,0"},EPSG_4151:{towgs84:"0,0,0"},EPSG_9702:{towgs84:"0,0,0"},EPSG_4758:{towgs84:"0,0,0"},EPSG_4761:{towgs84:"0,0,0"},EPSG_4765:{towgs84:"0,0,0"},EPSG_8997:{towgs84:"0,0,0"},EPSG_4023:{towgs84:"0,0,0"},EPSG_4670:{towgs84:"0,0,0"},EPSG_4694:{towgs84:"0,0,0"},EPSG_4148:{towgs84:"0,0,0"},EPSG_4163:{towgs84:"0,0,0"},EPSG_4167:{towgs84:"0,0,0"},EPSG_4189:{towgs84:"0,0,0"},EPSG_4190:{towgs84:"0,0,0"},EPSG_4176:{towgs84:"0,0,0"},EPSG_4659:{towgs84:"0,0,0"},EPSG_3824:{towgs84:"0,0,0"},EPSG_3889:{towgs84:"0,0,0"},EPSG_4046:{towgs84:"0,0,0"},EPSG_4081:{towgs84:"0,0,0"},EPSG_4558:{towgs84:"0,0,0"},EPSG_4483:{towgs84:"0,0,0"},EPSG_5013:{towgs84:"0,0,0"},EPSG_5264:{towgs84:"0,0,0"},EPSG_5324:{towgs84:"0,0,0"},EPSG_5354:{towgs84:"0,0,0"},EPSG_5371:{towgs84:"0,0,0"},EPSG_5373:{towgs84:"0,0,0"},EPSG_5381:{towgs84:"0,0,0"},EPSG_5393:{towgs84:"0,0,0"},EPSG_5489:{towgs84:"0,0,0"},EPSG_5593:{towgs84:"0,0,0"},EPSG_6135:{towgs84:"0,0,0"},EPSG_6365:{towgs84:"0,0,0"},EPSG_5246:{towgs84:"0,0,0"},EPSG_7886:{towgs84:"0,0,0"},EPSG_8431:{towgs84:"0,0,0"},EPSG_8427:{towgs84:"0,0,0"},EPSG_8699:{towgs84:"0,0,0"},EPSG_8818:{towgs84:"0,0,0"},EPSG_4757:{towgs84:"0,0,0"},EPSG_9140:{towgs84:"0,0,0"},EPSG_8086:{towgs84:"0,0,0"},EPSG_4686:{towgs84:"0,0,0"},EPSG_4737:{towgs84:"0,0,0"},EPSG_4702:{towgs84:"0,0,0"},EPSG_4747:{towgs84:"0,0,0"},EPSG_4749:{towgs84:"0,0,0"},EPSG_4674:{towgs84:"0,0,0"},EPSG_4755:{towgs84:"0,0,0"},EPSG_4759:{towgs84:"0,0,0"},EPSG_4762:{towgs84:"0,0,0"},EPSG_4763:{towgs84:"0,0,0"},EPSG_4764:{towgs84:"0,0,0"},EPSG_4166:{towgs84:"0,0,0"},EPSG_4170:{towgs84:"0,0,0"},EPSG_5546:{towgs84:"0,0,0"},EPSG_7844:{towgs84:"0,0,0"},EPSG_4818:{towgs84:"589,76,480"}};for(var Ne in Le){var Ve=Le[Ne];Ve.datumName&&(Le[Ve.datumName]=Ve)}function Ue(e,a,o,l,h,u,d){var p={};return p.datum_type=void 0===e||"none"===e?s:r,a&&(p.datum_params=a.map(parseFloat),0===p.datum_params[0]&&0===p.datum_params[1]&&0===p.datum_params[2]||(p.datum_type=t),p.datum_params.length>3&&(0===p.datum_params[3]&&0===p.datum_params[4]&&0===p.datum_params[5]&&0===p.datum_params[6]||(p.datum_type=i,p.datum_params[3]*=c,p.datum_params[4]*=c,p.datum_params[5]*=c,p.datum_params[6]=p.datum_params[6]/1e6+1))),d&&(p.datum_type=n,p.grids=d),p.a=o,p.b=l,p.es=h,p.ep2=u,p}var ke={};function Ge(e,t,i){return t instanceof ArrayBuffer?ze(e,t,i):{ready:je(e,t)}}function ze(e,t,i){var n=!0;void 0!==i&&!1===i.includeErrorFields&&(n=!1);var r=new DataView(t),s=qe(r),a=Ye(r,s),o={header:a,subgrids:Ze(r,a,s,n)};return ke[e]=o,o}async function je(e,t){for(var i=[],n=await t.getImageCount(),r=n-1;r>=0;r--){var s=await t.getImage(r),a=await s.readRasters(),o=[s.getWidth(),s.getHeight()],l=s.getBoundingBox().map($e),c=[s.fileDirectory.ModelPixelScale[0],s.fileDirectory.ModelPixelScale[1]].map($e),h=l[0]+(o[0]-1)*c[0],u=l[3]-(o[1]-1)*c[1],d=a[0],p=a[1],m=[];for(let e=o[1]-1;e>=0;e--)for(let t=o[0]-1;t>=0;t--){var f=e*o[0]+t;m.push([-We(p[f]),We(d[f])])}i.push({del:c,lim:o,ll:[-h,u],cvs:m})}var g={header:{nSubgrids:n},subgrids:i};return ke[e]=g,g}function Qe(e){return void 0===e?null:e.split(",").map(He)}function He(e){if(0===e.length)return null;var t="@"===e[0];return t&&(e=e.slice(1)),"null"===e?{name:"null",mandatory:!t,grid:null,isNull:!0}:{name:e,mandatory:!t,grid:ke[e]||null,isNull:!1}}function $e(e){return e*Math.PI/180}function We(e){return e/3600*Math.PI/180}function qe(e){var t=e.getInt32(8,!1);return 11!==t&&(11!==(t=e.getInt32(8,!0))&&console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"),!0)}function Ye(e,t){return{nFields:e.getInt32(8,t),nSubgridFields:e.getInt32(24,t),nSubgrids:e.getInt32(40,t),shiftType:Xe(e,56,64).trim(),fromSemiMajorAxis:e.getFloat64(120,t),fromSemiMinorAxis:e.getFloat64(136,t),toSemiMajorAxis:e.getFloat64(152,t),toSemiMinorAxis:e.getFloat64(168,t)}}function Xe(e,t,i){return String.fromCharCode.apply(null,new Uint8Array(e.buffer.slice(t,i)))}function Ze(e,t,i,n){for(var r=176,s=[],a=0;a<t.nSubgrids;a++){var o=Je(e,r,i),l=et(e,r,o,i,n),c=Math.round(1+(o.upperLongitude-o.lowerLongitude)/o.longitudeInterval),h=Math.round(1+(o.upperLatitude-o.lowerLatitude)/o.latitudeInterval);s.push({ll:[We(o.lowerLongitude),We(o.lowerLatitude)],del:[We(o.longitudeInterval),We(o.latitudeInterval)],lim:[c,h],count:o.gridNodeCount,cvs:Ke(l)});var u=16;!1===n&&(u=8),r+=176+o.gridNodeCount*u}return s}function Ke(e){return e.map((function(e){return[We(e.longitudeShift),We(e.latitudeShift)]}))}function Je(e,t,i){return{name:Xe(e,t+8,t+16).trim(),parent:Xe(e,t+24,t+24+8).trim(),lowerLatitude:e.getFloat64(t+72,i),upperLatitude:e.getFloat64(t+88,i),lowerLongitude:e.getFloat64(t+104,i),upperLongitude:e.getFloat64(t+120,i),latitudeInterval:e.getFloat64(t+136,i),longitudeInterval:e.getFloat64(t+152,i),gridNodeCount:e.getInt32(t+168,i)}}function et(e,t,i,n,r){var s=t+176,a=16;!1===r&&(a=8);for(var o=[],l=0;l<i.gridNodeCount;l++){var c={latitudeShift:e.getFloat32(s+l*a,n),longitudeShift:e.getFloat32(s+l*a+4,n)};!1!==r&&(c.latitudeAccuracy=e.getFloat32(s+l*a+8,n),c.longitudeAccuracy=e.getFloat32(s+l*a+12,n)),o.push(c)}return o}function tt(e,t){if(!(this instanceof tt))return new tt(e);t=t||function(e){if(e)throw e};var i=de(e);if("object"==typeof i){var n=tt.projections.get(i.projName);if(n){if(i.datumCode&&"none"!==i.datumCode){var r=S(Le,i.datumCode);r&&(i.datum_params=i.datum_params||(r.towgs84?r.towgs84.split(","):null),i.ellps=r.ellipse,i.datumName=r.datumName?r.datumName:i.datumCode)}i.k0=i.k0||1,i.axis=i.axis||"enu",i.ellps=i.ellps||"wgs84",i.lat1=i.lat1||i.lat0;var s=Oe(i.a,i.b,i.rf,i.ellps,i.sphere),a=Fe(s.a,s.b,s.rf,i.R_A),o=Qe(i.nadgrids),l=i.datum||Ue(i.datumCode,i.datum_params,s.a,s.b,a.es,a.ep2,o);pe(this,i),pe(this,n),this.a=s.a,this.b=s.b,this.rf=s.rf,this.sphere=s.sphere,this.es=a.es,this.e=a.e,this.ep2=a.ep2,this.datum=l,this.init(),t(null,this)}else t("Could not get projection name from: "+e)}else t("Could not parse to valid json: "+e)}function it(e,n){return e.datum_type===n.datum_type&&!(e.a!==n.a||Math.abs(e.es-n.es)>5e-11)&&(e.datum_type===t?e.datum_params[0]===n.datum_params[0]&&e.datum_params[1]===n.datum_params[1]&&e.datum_params[2]===n.datum_params[2]:e.datum_type!==i||e.datum_params[0]===n.datum_params[0]&&e.datum_params[1]===n.datum_params[1]&&e.datum_params[2]===n.datum_params[2]&&e.datum_params[3]===n.datum_params[3]&&e.datum_params[4]===n.datum_params[4]&&e.datum_params[5]===n.datum_params[5]&&e.datum_params[6]===n.datum_params[6])}function nt(e,t,i){var n,r,s,a,o=e.x,l=e.y,c=e.z?e.z:0;if(l<-h&&l>-1.001*h)l=-h;else if(l>h&&l<1.001*h)l=h;else{if(l<-h)return{x:-1/0,y:-1/0,z:e.z};if(l>h)return{x:1/0,y:1/0,z:e.z}}return o>Math.PI&&(o-=2*Math.PI),r=Math.sin(l),a=Math.cos(l),s=r*r,{x:((n=i/Math.sqrt(1-t*s))+c)*a*Math.cos(o),y:(n+c)*a*Math.sin(o),z:(n*(1-t)+c)*r}}function rt(e,t,i,n){var r,s,a,o,l,c,h,u,d,p,m,f,g,_,A,v=1e-12,y=v*v,x=30,b=e.x,S=e.y,C=e.z?e.z:0;if(r=Math.sqrt(b*b+S*S),s=Math.sqrt(b*b+S*S+C*C),r/i<v){if(_=0,s/i<v)return A=-n,{x:e.x,y:e.y,z:e.z}}else _=Math.atan2(S,b);a=C/s,u=(o=r/s)*(1-t)*(l=1/Math.sqrt(1-t*(2-t)*o*o)),d=a*l,g=0;do{g++,c=t*(h=i/Math.sqrt(1-t*d*d))/(h+(A=r*u+C*d-h*(1-t*d*d))),f=(m=a*(l=1/Math.sqrt(1-c*(2-c)*o*o)))*u-(p=o*(1-c)*l)*d,u=p,d=m}while(f*f>y&&g<x);return{x:_,y:Math.atan(m/Math.abs(p)),z:A}}function st(e,n,r){if(n===t)return{x:e.x+r[0],y:e.y+r[1],z:e.z+r[2]};if(n===i){var s=r[0],a=r[1],o=r[2],l=r[3],c=r[4],h=r[5],u=r[6];return{x:u*(e.x-h*e.y+c*e.z)+s,y:u*(h*e.x+e.y-l*e.z)+a,z:u*(-c*e.x+l*e.y+e.z)+o}}}function at(e,n,r){if(n===t)return{x:e.x-r[0],y:e.y-r[1],z:e.z-r[2]};if(n===i){var s=r[0],a=r[1],o=r[2],l=r[3],c=r[4],h=r[5],u=r[6],d=(e.x-s)/u,p=(e.y-a)/u,m=(e.z-o)/u;return{x:d+h*p-c*m,y:-h*d+p+l*m,z:c*d-l*p+m}}}function ot(e){return e===t||e===i}function lt(e,t,i){if(it(e,t))return i;if(e.datum_type===s||t.datum_type===s)return i;var r=e.a,c=e.es;if(e.datum_type===n){if(0!==ct(e,!1,i))return;r=a,c=l}var h=t.a,u=t.b,d=t.es;return t.datum_type===n&&(h=a,u=o,d=l),c!==d||r!==h||ot(e.datum_type)||ot(t.datum_type)?(i=nt(i,c,r),ot(e.datum_type)&&(i=st(i,e.datum_type,e.datum_params)),ot(t.datum_type)&&(i=at(i,t.datum_type,t.datum_params)),i=rt(i,d,h,u),t.datum_type!==n||0===ct(t,!0,i)?i:void 0):i}function ct(e,t,i){if(null===e.grids||0===e.grids.length)return console.log("Grid shift grids not found"),-1;var n={x:-i.x,y:i.y},r={x:Number.NaN,y:Number.NaN},s=[];e:for(var a=0;a<e.grids.length;a++){var o=e.grids[a];if(s.push(o.name),o.isNull){r=n;break}if(null!==o.grid)for(var l=o.grid.subgrids,c=0,h=l.length;c<h;c++){var u=l[c],d=(Math.abs(u.del[1])+Math.abs(u.del[0]))/1e4,p=u.ll[0]-d,m=u.ll[1]-d,f=u.ll[0]+(u.lim[0]-1)*u.del[0]+d,_=u.ll[1]+(u.lim[1]-1)*u.del[1]+d;if(!(m>n.y||p>n.x||_<n.y||f<n.x||(r=ht(n,t,u),isNaN(r.x))))break e}else if(o.mandatory)return console.log("Unable to find mandatory grid '"+o.name+"'"),-1}return isNaN(r.x)?(console.log("Failed to find a grid shift table for location '"+-n.x*g+" "+n.y*g+" tried: '"+s+"'"),-1):(i.x=-r.x,i.y=r.y,0)}function ht(e,t,i){var n={x:Number.NaN,y:Number.NaN};if(isNaN(e.x))return n;var r={x:e.x,y:e.y};r.x-=i.ll[0],r.y-=i.ll[1],r.x=ge(r.x-Math.PI)+Math.PI;var s=ut(r,i);if(t){if(isNaN(s.x))return n;s.x=r.x-s.x,s.y=r.y-s.y;var a,o,l=9,c=1e-12;do{if(o=ut(s,i),isNaN(o.x)){console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");break}a={x:r.x-(o.x+s.x),y:r.y-(o.y+s.y)},s.x+=a.x,s.y+=a.y}while(l--&&Math.abs(a.x)>c&&Math.abs(a.y)>c);if(l<0)return console.log("Inverse grid shift iterator failed to converge."),n;n.x=ge(s.x+i.ll[0]),n.y=s.y+i.ll[1]}else isNaN(s.x)||(n.x=e.x+s.x,n.y=e.y+s.y);return n}function ut(e,t){var i,n={x:e.x/t.del[0],y:e.y/t.del[1]},r={x:Math.floor(n.x),y:Math.floor(n.y)},s={x:n.x-1*r.x,y:n.y-1*r.y},a={x:Number.NaN,y:Number.NaN};if(r.x<0||r.x>=t.lim[0])return a;if(r.y<0||r.y>=t.lim[1])return a;i=r.y*t.lim[0]+r.x;var o={x:t.cvs[i][0],y:t.cvs[i][1]};i++;var l={x:t.cvs[i][0],y:t.cvs[i][1]};i+=t.lim[0];var c={x:t.cvs[i][0],y:t.cvs[i][1]};i--;var h={x:t.cvs[i][0],y:t.cvs[i][1]},u=s.x*s.y,d=s.x*(1-s.y),p=(1-s.x)*(1-s.y),m=(1-s.x)*s.y;return a.x=p*o.x+d*l.x+m*h.x+u*c.x,a.y=p*o.y+d*l.y+m*h.y+u*c.y,a}function dt(e,t,i){var n,r,s,a=i.x,o=i.y,l=i.z||0,c={};for(s=0;s<3;s++)if(!t||2!==s||void 0!==i.z)switch(0===s?(n=a,r=-1!=="ew".indexOf(e.axis[s])?"x":"y"):1===s?(n=o,r=-1!=="ns".indexOf(e.axis[s])?"y":"x"):(n=l,r="z"),e.axis[s]){case"e":case"n":c[r]=n;break;case"w":case"s":c[r]=-n;break;case"u":void 0!==i[r]&&(c.z=n);break;case"d":void 0!==i[r]&&(c.z=-n);break;default:return null}return c}function pt(e){var t={x:e[0],y:e[1]};return e.length>2&&(t.z=e[2]),e.length>3&&(t.m=e[3]),t}function mt(e){ft(e.x),ft(e.y)}function ft(e){if("function"==typeof Number.isFinite){if(Number.isFinite(e))return;throw new TypeError("coordinates must be finite numbers")}if("number"!=typeof e||e!=e||!isFinite(e))throw new TypeError("coordinates must be finite numbers")}function gt(e,r){return(e.datum.datum_type===t||e.datum.datum_type===i||e.datum.datum_type===n)&&"WGS84"!==r.datumCode||(r.datum.datum_type===t||r.datum.datum_type===i||r.datum.datum_type===n)&&"WGS84"!==e.datumCode}function _t(e,t,i,n){var r,s=void 0!==(i=Array.isArray(i)?pt(i):{x:i.x,y:i.y,z:i.z,m:i.m}).z;if(mt(i),e.datum&&t.datum&&gt(e,t)&&(i=_t(e,r=new tt("WGS84"),i,n),e=r),n&&"enu"!==e.axis&&(i=dt(e,!1,i)),"longlat"===e.projName)i={x:i.x*f,y:i.y*f,z:i.z||0};else if(e.to_meter&&(i={x:i.x*e.to_meter,y:i.y*e.to_meter,z:i.z||0}),!(i=e.inverse(i)))return;if(e.from_greenwich&&(i.x+=e.from_greenwich),i=lt(e.datum,t.datum,i))return t.from_greenwich&&(i={x:i.x-t.from_greenwich,y:i.y,z:i.z||0}),"longlat"===t.projName?i={x:i.x*g,y:i.y*g,z:i.z||0}:(i=t.forward(i),t.to_meter&&(i={x:i.x/t.to_meter,y:i.y/t.to_meter,z:i.z||0})),n&&"enu"!==t.axis?dt(t,!0,i):(i&&!s&&delete i.z,i)}tt.projections=Re,tt.projections.start();var At=tt("WGS84");function vt(e,t,i,n){var r,s,a;return Array.isArray(i)?(r=_t(e,t,i,n)||{x:NaN,y:NaN},i.length>2?void 0!==e.name&&"geocent"===e.name||void 0!==t.name&&"geocent"===t.name?"number"==typeof r.z?[r.x,r.y,r.z].concat(i.slice(3)):[r.x,r.y,i[2]].concat(i.slice(3)):[r.x,r.y].concat(i.slice(2)):[r.x,r.y]):(s=_t(e,t,i,n),2===(a=Object.keys(i)).length||a.forEach((function(n){if(void 0!==e.name&&"geocent"===e.name||void 0!==t.name&&"geocent"===t.name){if("x"===n||"y"===n||"z"===n)return}else if("x"===n||"y"===n)return;s[n]=i[n]})),s)}function yt(e){return e instanceof tt?e:e.oProj?e.oProj:tt(e)}function xt(e,t,i){e=yt(e);var n,r=!1;return void 0===t?(t=e,e=At,r=!0):(void 0!==t.x||Array.isArray(t))&&(i=t,t=e,e=At,r=!0),t=yt(t),i?vt(e,t,i):(n={forward:function(i,n){return vt(e,t,i,n)},inverse:function(i,n){return vt(t,e,i,n)}},r&&(n.oProj=t),n)}var bt=6,St="AJSAJS",Ct="AFAFAF",Tt=65,Et=73,Mt=79,wt=86,It=90,Pt={forward:Rt,inverse:Bt,toPoint:Dt};function Rt(e,t){return t=t||5,Ut(Lt({lat:e[1],lon:e[0]}),t)}function Bt(e){var t=Nt(jt(e.toUpperCase()));return t.lat&&t.lon?[t.lon,t.lat,t.lon,t.lat]:[t.left,t.bottom,t.right,t.top]}function Dt(e){var t=Nt(jt(e.toUpperCase()));return t.lat&&t.lon?[t.lon,t.lat]:[(t.left+t.right)/2,(t.top+t.bottom)/2]}function Ft(e){return e*(Math.PI/180)}function Ot(e){return e/Math.PI*180}function Lt(e){var t,i,n,r,s,a,o,l=e.lat,c=e.lon,h=6378137,u=.00669438,d=.9996,p=Ft(l),m=Ft(c);o=Math.floor((c+180)/6)+1,180===c&&(o=60),l>=56&&l<64&&c>=3&&c<12&&(o=32),l>=72&&l<84&&(c>=0&&c<9?o=31:c>=9&&c<21?o=33:c>=21&&c<33?o=35:c>=33&&c<42&&(o=37)),a=Ft(6*(o-1)-180+3),t=u/(1-u),i=h/Math.sqrt(1-u*Math.sin(p)*Math.sin(p)),n=Math.tan(p)*Math.tan(p),r=t*Math.cos(p)*Math.cos(p);var f=d*i*((s=Math.cos(p)*(m-a))+(1-n+r)*s*s*s/6+(5-18*n+n*n+72*r-58*t)*s*s*s*s*s/120)+5e5,g=d*(h*((1-u/4-3*u*u/64-5*u*u*u/256)*p-(3*u/8+3*u*u/32+45*u*u*u/1024)*Math.sin(2*p)+(15*u*u/256+45*u*u*u/1024)*Math.sin(4*p)-35*u*u*u/3072*Math.sin(6*p))+i*Math.tan(p)*(s*s/2+(5-n+9*r+4*r*r)*s*s*s*s/24+(61-58*n+n*n+600*r-330*t)*s*s*s*s*s*s/720));return l<0&&(g+=1e7),{northing:Math.round(g),easting:Math.round(f),zoneNumber:o,zoneLetter:Vt(l)}}function Nt(e){var t=e.northing,i=e.easting,n=e.zoneLetter,r=e.zoneNumber;if(r<0||r>60)return null;var s,a,o,l,c,h,u,d,p,m=.9996,f=6378137,g=.00669438,_=(1-Math.sqrt(1-g))/(1+Math.sqrt(1-g)),A=i-5e5,v=t;n<"N"&&(v-=1e7),u=6*(r-1)-180+3,s=g/(1-g),p=(d=v/m/(f*(1-g/4-3*g*g/64-5*g*g*g/256)))+(3*_/2-27*_*_*_/32)*Math.sin(2*d)+(21*_*_/16-55*_*_*_*_/32)*Math.sin(4*d)+151*_*_*_/96*Math.sin(6*d),a=f/Math.sqrt(1-g*Math.sin(p)*Math.sin(p)),o=Math.tan(p)*Math.tan(p),l=s*Math.cos(p)*Math.cos(p),c=f*(1-g)/Math.pow(1-g*Math.sin(p)*Math.sin(p),1.5),h=A/(a*m);var y=p-a*Math.tan(p)/c*(h*h/2-(5+3*o+10*l-4*l*l-9*s)*h*h*h*h/24+(61+90*o+298*l+45*o*o-252*s-3*l*l)*h*h*h*h*h*h/720);y=Ot(y);var x,b=(h-(1+2*o+l)*h*h*h/6+(5-2*l+28*o-3*l*l+8*s+24*o*o)*h*h*h*h*h/120)/Math.cos(p);if(b=u+Ot(b),e.accuracy){var S=Nt({northing:e.northing+e.accuracy,easting:e.easting+e.accuracy,zoneLetter:e.zoneLetter,zoneNumber:e.zoneNumber});x={top:S.lat,right:S.lon,bottom:y,left:b}}else x={lat:y,lon:b};return x}function Vt(e){var t="Z";return 84>=e&&e>=72?t="X":72>e&&e>=64?t="W":64>e&&e>=56?t="V":56>e&&e>=48?t="U":48>e&&e>=40?t="T":40>e&&e>=32?t="S":32>e&&e>=24?t="R":24>e&&e>=16?t="Q":16>e&&e>=8?t="P":8>e&&e>=0?t="N":0>e&&e>=-8?t="M":-8>e&&e>=-16?t="L":-16>e&&e>=-24?t="K":-24>e&&e>=-32?t="J":-32>e&&e>=-40?t="H":-40>e&&e>=-48?t="G":-48>e&&e>=-56?t="F":-56>e&&e>=-64?t="E":-64>e&&e>=-72?t="D":-72>e&&e>=-80&&(t="C"),t}function Ut(e,t){var i="00000"+e.easting,n="00000"+e.northing;return e.zoneNumber+e.zoneLetter+kt(e.easting,e.northing,e.zoneNumber)+i.substr(i.length-5,t)+n.substr(n.length-5,t)}function kt(e,t,i){var n=Gt(i);return zt(Math.floor(e/1e5),Math.floor(t/1e5)%20,n)}function Gt(e){var t=e%bt;return 0===t&&(t=bt),t}function zt(e,t,i){var n=i-1,r=St.charCodeAt(n),s=Ct.charCodeAt(n),a=r+e-1,o=s+t,l=!1;return a>It&&(a=a-It+Tt-1,l=!0),(a===Et||r<Et&&a>Et||(a>Et||r<Et)&&l)&&a++,(a===Mt||r<Mt&&a>Mt||(a>Mt||r<Mt)&&l)&&++a===Et&&a++,a>It&&(a=a-It+Tt-1),o>wt?(o=o-wt+Tt-1,l=!0):l=!1,(o===Et||s<Et&&o>Et||(o>Et||s<Et)&&l)&&o++,(o===Mt||s<Mt&&o>Mt||(o>Mt||s<Mt)&&l)&&++o===Et&&o++,o>wt&&(o=o-wt+Tt-1),String.fromCharCode(a)+String.fromCharCode(o)}function jt(e){if(e&&0===e.length)throw"MGRSPoint coverting from nothing";for(var t,i=e.length,n=null,r="",s=0;!/[A-Z]/.test(t=e.charAt(s));){if(s>=2)throw"MGRSPoint bad conversion from: "+e;r+=t,s++}var a=parseInt(r,10);if(0===s||s+3>i)throw"MGRSPoint bad conversion from: "+e;var o=e.charAt(s++);if(o<="A"||"B"===o||"Y"===o||o>="Z"||"I"===o||"O"===o)throw"MGRSPoint zone letter "+o+" not handled: "+e;n=e.substring(s,s+=2);for(var l=Gt(a),c=Qt(n.charAt(0),l),h=Ht(n.charAt(1),l);h<$t(o);)h+=2e6;var u=i-s;if(u%2!=0)throw"MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters"+e;var d,p,m,f=u/2,g=0,_=0;return f>0&&(d=1e5/Math.pow(10,f),p=e.substring(s,s+f),g=parseFloat(p)*d,m=e.substring(s+f),_=parseFloat(m)*d),{easting:g+c,northing:_+h,zoneLetter:o,zoneNumber:a,accuracy:d}}function Qt(e,t){for(var i=St.charCodeAt(t-1),n=1e5,r=!1;i!==e.charCodeAt(0);){if(++i===Et&&i++,i===Mt&&i++,i>It){if(r)throw"Bad character: "+e;i=Tt,r=!0}n+=1e5}return n}function Ht(e,t){if(e>"V")throw"MGRSPoint given invalid Northing "+e;for(var i=Ct.charCodeAt(t-1),n=0,r=!1;i!==e.charCodeAt(0);){if(++i===Et&&i++,i===Mt&&i++,i>wt){if(r)throw"Bad character: "+e;i=Tt,r=!0}n+=1e5}return n}function $t(e){var t;switch(e){case"C":t=11e5;break;case"D":t=2e6;break;case"E":t=28e5;break;case"F":t=37e5;break;case"G":t=46e5;break;case"H":t=55e5;break;case"J":t=64e5;break;case"K":t=73e5;break;case"L":t=82e5;break;case"M":t=91e5;break;case"N":t=0;break;case"P":t=8e5;break;case"Q":t=17e5;break;case"R":t=26e5;break;case"S":t=35e5;break;case"T":t=44e5;break;case"U":t=53e5;break;case"V":t=62e5;break;case"W":t=7e6;break;case"X":t=79e5;break;default:t=-1}if(t>=0)return t;throw"Invalid zone letter: "+e}function Wt(e,t,i){if(!(this instanceof Wt))return new Wt(e,t,i);if(Array.isArray(e))this.x=e[0],this.y=e[1],this.z=e[2]||0;else if("object"==typeof e)this.x=e.x,this.y=e.y,this.z=e.z||0;else if("string"==typeof e&&void 0===t){var n=e.split(",");this.x=parseFloat(n[0],10),this.y=parseFloat(n[1],10),this.z=parseFloat(n[2],10)||0}else this.x=e,this.y=t,this.z=i||0;console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")}Wt.fromMGRS=function(e){return new Wt(Dt(e))},Wt.prototype.toMGRS=function(e){return Rt([this.x,this.y],e)};var qt=1,Yt=.25,Xt=.046875,Zt=.01953125,Kt=.01068115234375,Jt=.75,ei=.46875,ti=.013020833333333334,ii=.007120768229166667,ni=.3645833333333333,ri=.005696614583333333,si=.3076171875;function ai(e){var t=[];t[0]=qt-e*(Yt+e*(Xt+e*(Zt+e*Kt))),t[1]=e*(Jt-e*(Xt+e*(Zt+e*Kt)));var i=e*e;return t[2]=i*(ei-e*(ti+e*ii)),i*=e,t[3]=i*(ni-e*ri),t[4]=i*e*si,t}function oi(e,t,i,n){return i*=t,t*=t,n[0]*e-i*(n[1]+t*(n[2]+t*(n[3]+t*n[4])))}var li=20;function ci(e,t,i){for(var n=1/(1-t),r=e,s=li;s;--s){var a=Math.sin(r),o=1-t*a*a;if(r-=o=(oi(r,a,Math.cos(r),i)-e)*(o*Math.sqrt(o))*n,Math.abs(o)<m)return r}return r}function hi(){this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.es&&(this.en=ai(this.es),this.ml0=oi(this.lat0,Math.sin(this.lat0),Math.cos(this.lat0),this.en))}function ui(e){var t,i,n,r=e.x,s=e.y,a=ge(r-this.long0),o=Math.sin(s),l=Math.cos(s);if(this.es){var c=l*a,h=Math.pow(c,2),u=this.ep2*Math.pow(l,2),d=Math.pow(u,2),p=Math.abs(l)>m?Math.tan(s):0,f=Math.pow(p,2),g=Math.pow(f,2);t=1-this.es*Math.pow(o,2),c/=Math.sqrt(t);var _=oi(s,o,l,this.en);i=this.a*(this.k0*c*(1+h/6*(1-f+u+h/20*(5-18*f+g+14*u-58*f*u+h/42*(61+179*g-g*f-479*f)))))+this.x0,n=this.a*(this.k0*(_-this.ml0+o*a*c/2*(1+h/12*(5-f+9*u+4*d+h/30*(61+g-58*f+270*u-330*f*u+h/56*(1385+543*g-g*f-3111*f))))))+this.y0}else{var A=l*Math.sin(a);if(Math.abs(Math.abs(A)-1)<m)return 93;if(i=.5*this.a*this.k0*Math.log((1+A)/(1-A))+this.x0,n=l*Math.cos(a)/Math.sqrt(1-Math.pow(A,2)),(A=Math.abs(n))>=1){if(A-1>m)return 93;n=0}else n=Math.acos(n);s<0&&(n=-n),n=this.a*this.k0*(n-this.lat0)+this.y0}return e.x=i,e.y=n,e}function di(e){var t,i,n,r,s=(e.x-this.x0)*(1/this.a),a=(e.y-this.y0)*(1/this.a);if(this.es)if(i=ci(t=this.ml0+a/this.k0,this.es,this.en),Math.abs(i)<h){var o=Math.sin(i),l=Math.cos(i),c=Math.abs(l)>m?Math.tan(i):0,u=this.ep2*Math.pow(l,2),d=Math.pow(u,2),p=Math.pow(c,2),f=Math.pow(p,2);t=1-this.es*Math.pow(o,2);var g=s*Math.sqrt(t)/this.k0,_=Math.pow(g,2);n=i-(t*=c)*_/(1-this.es)*.5*(1-_/12*(5+3*p-9*u*p+u-4*d-_/30*(61+90*p-252*u*p+45*f+46*u-_/56*(1385+3633*p+4095*f+1574*f*p)))),r=ge(this.long0+g*(1-_/6*(1+2*p+u-_/20*(5+28*p+24*f+8*u*p+6*u-_/42*(61+662*p+1320*f+720*f*p))))/l)}else n=h*fe(a),r=0;else{var A=Math.exp(s/this.k0),v=.5*(A-1/A),y=this.lat0+a/this.k0,x=Math.cos(y);t=Math.sqrt((1-Math.pow(x,2))/(1+Math.pow(v,2))),n=Math.asin(t),a<0&&(n=-n),r=0===v&&0===x?0:ge(Math.atan2(v,x)+this.long0)}return e.x=r,e.y=n,e}var pi={init:hi,forward:ui,inverse:di,names:["Fast_Transverse_Mercator","Fast Transverse Mercator"]};function mi(e){var t=Math.exp(e);return t=(t-1/t)/2}function fi(e,t){e=Math.abs(e),t=Math.abs(t);var i=Math.max(e,t),n=Math.min(e,t)/(i||1);return i*Math.sqrt(1+Math.pow(n,2))}function gi(e){var t=1+e,i=t-1;return 0===i?e:e*Math.log(t)/i}function _i(e){var t=Math.abs(e);return t=gi(t*(1+t/(fi(1,t)+1))),e<0?-t:t}function Ai(e,t){for(var i,n=2*Math.cos(2*t),r=e.length-1,s=e[r],a=0;--r>=0;)i=n*s-a+e[r],a=s,s=i;return t+i*Math.sin(2*t)}function vi(e,t){for(var i,n=2*Math.cos(t),r=e.length-1,s=e[r],a=0;--r>=0;)i=n*s-a+e[r],a=s,s=i;return Math.sin(t)*i}function yi(e){var t=Math.exp(e);return t=(t+1/t)/2}function xi(e,t,i){for(var n,r,s=Math.sin(t),a=Math.cos(t),o=mi(i),l=yi(i),c=2*a*l,h=-2*s*o,u=e.length-1,d=e[u],p=0,m=0,f=0;--u>=0;)n=m,r=p,d=c*(m=d)-n-h*(p=f)+e[u],f=h*m-r+c*p;return[(c=s*l)*d-(h=a*o)*f,c*f+h*d]}function bi(){if(!this.approx&&(isNaN(this.es)||this.es<=0))throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');this.approx&&(pi.init.apply(this),this.forward=pi.forward,this.inverse=pi.inverse),this.x0=void 0!==this.x0?this.x0:0,this.y0=void 0!==this.y0?this.y0:0,this.long0=void 0!==this.long0?this.long0:0,this.lat0=void 0!==this.lat0?this.lat0:0,this.cgb=[],this.cbg=[],this.utg=[],this.gtu=[];var e=this.es/(1+Math.sqrt(1-this.es)),t=e/(2-e),i=t;this.cgb[0]=t*(2+t*(-2/3+t*(t*(116/45+t*(26/45+t*(-2854/675)))-2))),this.cbg[0]=t*(t*(2/3+t*(4/3+t*(-82/45+t*(32/45+t*(4642/4725)))))-2),i*=t,this.cgb[1]=i*(7/3+t*(t*(-227/45+t*(2704/315+t*(2323/945)))-1.6)),this.cbg[1]=i*(5/3+t*(-16/15+t*(-13/9+t*(904/315+t*(-1522/945))))),i*=t,this.cgb[2]=i*(56/15+t*(-136/35+t*(-1262/105+t*(73814/2835)))),this.cbg[2]=i*(-26/15+t*(34/21+t*(1.6+t*(-12686/2835)))),i*=t,this.cgb[3]=i*(4279/630+t*(-332/35+t*(-399572/14175))),this.cbg[3]=i*(1237/630+t*(t*(-24832/14175)-2.4)),i*=t,this.cgb[4]=i*(4174/315+t*(-144838/6237)),this.cbg[4]=i*(-734/315+t*(109598/31185)),i*=t,this.cgb[5]=i*(601676/22275),this.cbg[5]=i*(444337/155925),i=Math.pow(t,2),this.Qn=this.k0/(1+t)*(1+i*(1/4+i*(1/64+i/256))),this.utg[0]=t*(t*(2/3+t*(-37/96+t*(1/360+t*(81/512+t*(-96199/604800)))))-.5),this.gtu[0]=t*(.5+t*(-2/3+t*(5/16+t*(41/180+t*(-127/288+t*(7891/37800)))))),this.utg[1]=i*(-1/48+t*(-1/15+t*(437/1440+t*(-46/105+t*(1118711/3870720))))),this.gtu[1]=i*(13/48+t*(t*(557/1440+t*(281/630+t*(-1983433/1935360)))-.6)),i*=t,this.utg[2]=i*(-17/480+t*(37/840+t*(209/4480+t*(-5569/90720)))),this.gtu[2]=i*(61/240+t*(-103/140+t*(15061/26880+t*(167603/181440)))),i*=t,this.utg[3]=i*(-4397/161280+t*(11/504+t*(830251/7257600))),this.gtu[3]=i*(49561/161280+t*(-179/168+t*(6601661/7257600))),i*=t,this.utg[4]=i*(-4583/161280+t*(108847/3991680)),this.gtu[4]=i*(34729/80640+t*(-3418889/1995840)),i*=t,this.utg[5]=i*(-20648693/638668800),this.gtu[5]=.6650675310896665*i;var n=Ai(this.cbg,this.lat0);this.Zb=-this.Qn*(n+vi(this.gtu,2*n))}function Si(e){var t=ge(e.x-this.long0),i=e.y;i=Ai(this.cbg,i);var n=Math.sin(i),r=Math.cos(i),s=Math.sin(t),a=Math.cos(t);i=Math.atan2(n,a*r),t=Math.atan2(s*r,fi(n,r*a)),t=_i(Math.tan(t));var o,l,c=xi(this.gtu,2*i,2*t);return i+=c[0],t+=c[1],Math.abs(t)<=2.623395162778?(o=this.a*(this.Qn*t)+this.x0,l=this.a*(this.Qn*i+this.Zb)+this.y0):(o=1/0,l=1/0),e.x=o,e.y=l,e}function Ci(e){var t,i,n=(e.x-this.x0)*(1/this.a),r=(e.y-this.y0)*(1/this.a);if(r=(r-this.Zb)/this.Qn,n/=this.Qn,Math.abs(n)<=2.623395162778){var s=xi(this.utg,2*r,2*n);r+=s[0],n+=s[1],n=Math.atan(mi(n));var a=Math.sin(r),o=Math.cos(r),l=Math.sin(n),c=Math.cos(n);r=Math.atan2(a*c,fi(l,c*o)),t=ge((n=Math.atan2(l,c*o))+this.long0),i=Ai(this.cgb,r)}else t=1/0,i=1/0;return e.x=t,e.y=i,e}var Ti={init:bi,forward:Si,inverse:Ci,names:["Extended_Transverse_Mercator","Extended Transverse Mercator","etmerc","Transverse_Mercator","Transverse Mercator","Gauss Kruger","Gauss_Kruger","tmerc"]};function Ei(e,t){if(void 0===e){if((e=Math.floor(30*(ge(t)+Math.PI)/Math.PI)+1)<0)return 0;if(e>60)return 60}return e}function Mi(){var e=Ei(this.zone,this.long0);if(void 0===e)throw new Error("unknown utm zone");this.lat0=0,this.long0=(6*Math.abs(e)-183)*f,this.x0=5e5,this.y0=this.utmSouth?1e7:0,this.k0=.9996,Ti.init.apply(this),this.forward=Ti.forward,this.inverse=Ti.inverse}var wi={init:Mi,names:["Universal Transverse Mercator System","utm"],dependsOn:"etmerc"};function Ii(e,t){return Math.pow((1-e)/(1+e),t)}var Pi=20;function Ri(){var e=Math.sin(this.lat0),t=Math.cos(this.lat0);t*=t,this.rc=Math.sqrt(1-this.es)/(1-this.es*e*e),this.C=Math.sqrt(1+this.es*t*t/(1-this.es)),this.phic0=Math.asin(e/this.C),this.ratexp=.5*this.C*this.e,this.K=Math.tan(.5*this.phic0+_)/(Math.pow(Math.tan(.5*this.lat0+_),this.C)*Ii(this.e*e,this.ratexp))}function Bi(e){var t=e.x,i=e.y;return e.y=2*Math.atan(this.K*Math.pow(Math.tan(.5*i+_),this.C)*Ii(this.e*Math.sin(i),this.ratexp))-h,e.x=this.C*t,e}function Di(e){for(var t=1e-14,i=e.x/this.C,n=e.y,r=Math.pow(Math.tan(.5*n+_)/this.K,1/this.C),s=Pi;s>0&&(n=2*Math.atan(r*Ii(this.e*Math.sin(e.y),-.5*this.e))-h,!(Math.abs(n-e.y)<t));--s)e.y=n;return s?(e.x=i,e.y=n,e):null}var Fi={init:Ri,forward:Bi,inverse:Di};function Oi(){Fi.init.apply(this),this.rc&&(this.sinc0=Math.sin(this.phic0),this.cosc0=Math.cos(this.phic0),this.R2=2*this.rc,this.title||(this.title="Oblique Stereographic Alternative"))}function Li(e){var t,i,n,r;return e.x=ge(e.x-this.long0),Fi.forward.apply(this,[e]),t=Math.sin(e.y),i=Math.cos(e.y),n=Math.cos(e.x),r=this.k0*this.R2/(1+this.sinc0*t+this.cosc0*i*n),e.x=r*i*Math.sin(e.x),e.y=r*(this.cosc0*t-this.sinc0*i*n),e.x=this.a*e.x+this.x0,e.y=this.a*e.y+this.y0,e}function Ni(e){var t,i,n,r,s;if(e.x=(e.x-this.x0)/this.a,e.y=(e.y-this.y0)/this.a,e.x/=this.k0,e.y/=this.k0,s=fi(e.x,e.y)){var a=2*Math.atan2(s,this.R2);t=Math.sin(a),i=Math.cos(a),r=Math.asin(i*this.sinc0+e.y*t*this.cosc0/s),n=Math.atan2(e.x*t,s*this.cosc0*i-e.y*this.sinc0*t)}else r=this.phic0,n=0;return e.x=n,e.y=r,Fi.inverse.apply(this,[e]),e.x=ge(e.x+this.long0),e}var Vi={init:Oi,forward:Li,inverse:Ni,names:["Stereographic_North_Pole","Oblique_Stereographic","sterea","Oblique Stereographic Alternative","Double_Stereographic"]};function Ui(e,t,i){return t*=i,Math.tan(.5*(h+e))*Math.pow((1-t)/(1+t),.5*i)}function ki(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.coslat0=Math.cos(this.lat0),this.sinlat0=Math.sin(this.lat0),this.sphere?1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=m&&(this.k0=.5*(1+fe(this.lat0)*Math.sin(this.lat_ts))):(Math.abs(this.coslat0)<=m&&(this.lat0>0?this.con=1:this.con=-1),this.cons=Math.sqrt(Math.pow(1+this.e,1+this.e)*Math.pow(1-this.e,1-this.e)),1===this.k0&&!isNaN(this.lat_ts)&&Math.abs(this.coslat0)<=m&&Math.abs(Math.cos(this.lat_ts))>m&&(this.k0=.5*this.cons*me(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts))/_e(this.e,this.con*this.lat_ts,this.con*Math.sin(this.lat_ts))),this.ms1=me(this.e,this.sinlat0,this.coslat0),this.X0=2*Math.atan(this.ssfn_(this.lat0,this.sinlat0,this.e))-h,this.cosX0=Math.cos(this.X0),this.sinX0=Math.sin(this.X0))}function Gi(e){var t,i,n,r,s,a,o=e.x,l=e.y,c=Math.sin(l),u=Math.cos(l),d=ge(o-this.long0);return Math.abs(Math.abs(o-this.long0)-Math.PI)<=m&&Math.abs(l+this.lat0)<=m?(e.x=NaN,e.y=NaN,e):this.sphere?(t=2*this.k0/(1+this.sinlat0*c+this.coslat0*u*Math.cos(d)),e.x=this.a*t*u*Math.sin(d)+this.x0,e.y=this.a*t*(this.coslat0*c-this.sinlat0*u*Math.cos(d))+this.y0,e):(i=2*Math.atan(this.ssfn_(l,c,this.e))-h,r=Math.cos(i),n=Math.sin(i),Math.abs(this.coslat0)<=m?(s=_e(this.e,l*this.con,this.con*c),a=2*this.a*this.k0*s/this.cons,e.x=this.x0+a*Math.sin(o-this.long0),e.y=this.y0-this.con*a*Math.cos(o-this.long0),e):(Math.abs(this.sinlat0)<m?(t=2*this.a*this.k0/(1+r*Math.cos(d)),e.y=t*n):(t=2*this.a*this.k0*this.ms1/(this.cosX0*(1+this.sinX0*n+this.cosX0*r*Math.cos(d))),e.y=t*(this.cosX0*n-this.sinX0*r*Math.cos(d))+this.y0),e.x=t*r*Math.sin(d)+this.x0,e))}function zi(e){var t,i,n,r,s;e.x-=this.x0,e.y-=this.y0;var a=Math.sqrt(e.x*e.x+e.y*e.y);if(this.sphere){var o=2*Math.atan(a/(2*this.a*this.k0));return t=this.long0,i=this.lat0,a<=m?(e.x=t,e.y=i,e):(i=Math.asin(Math.cos(o)*this.sinlat0+e.y*Math.sin(o)*this.coslat0/a),t=Math.abs(this.coslat0)<m?this.lat0>0?ge(this.long0+Math.atan2(e.x,-1*e.y)):ge(this.long0+Math.atan2(e.x,e.y)):ge(this.long0+Math.atan2(e.x*Math.sin(o),a*this.coslat0*Math.cos(o)-e.y*this.sinlat0*Math.sin(o))),e.x=t,e.y=i,e)}if(Math.abs(this.coslat0)<=m){if(a<=m)return i=this.lat0,t=this.long0,e.x=t,e.y=i,e;e.x*=this.con,e.y*=this.con,n=a*this.cons/(2*this.a*this.k0),i=this.con*Ae(this.e,n),t=this.con*ge(this.con*this.long0+Math.atan2(e.x,-1*e.y))}else r=2*Math.atan(a*this.cosX0/(2*this.a*this.k0*this.ms1)),t=this.long0,a<=m?s=this.X0:(s=Math.asin(Math.cos(r)*this.sinX0+e.y*Math.sin(r)*this.cosX0/a),t=ge(this.long0+Math.atan2(e.x*Math.sin(r),a*this.cosX0*Math.cos(r)-e.y*this.sinX0*Math.sin(r)))),i=-1*Ae(this.e,Math.tan(.5*(h+s)));return e.x=t,e.y=i,e}var ji={init:ki,forward:Gi,inverse:zi,names:["stere","Stereographic_South_Pole","Polar_Stereographic_variant_A","Polar_Stereographic_variant_B","Polar_Stereographic"],ssfn_:Ui};function Qi(){var e=this.lat0;this.lambda0=this.long0;var t=Math.sin(e),i=this.a,n=1/this.rf,r=2*n-Math.pow(n,2),s=this.e=Math.sqrt(r);this.R=this.k0*i*Math.sqrt(1-r)/(1-r*Math.pow(t,2)),this.alpha=Math.sqrt(1+r/(1-r)*Math.pow(Math.cos(e),4)),this.b0=Math.asin(t/this.alpha);var a=Math.log(Math.tan(Math.PI/4+this.b0/2)),o=Math.log(Math.tan(Math.PI/4+e/2)),l=Math.log((1+s*t)/(1-s*t));this.K=a-this.alpha*o+this.alpha*s/2*l}function Hi(e){var t=Math.log(Math.tan(Math.PI/4-e.y/2)),i=this.e/2*Math.log((1+this.e*Math.sin(e.y))/(1-this.e*Math.sin(e.y))),n=-this.alpha*(t+i)+this.K,r=2*(Math.atan(Math.exp(n))-Math.PI/4),s=this.alpha*(e.x-this.lambda0),a=Math.atan(Math.sin(s)/(Math.sin(this.b0)*Math.tan(r)+Math.cos(this.b0)*Math.cos(s))),o=Math.asin(Math.cos(this.b0)*Math.sin(r)-Math.sin(this.b0)*Math.cos(r)*Math.cos(s));return e.y=this.R/2*Math.log((1+Math.sin(o))/(1-Math.sin(o)))+this.y0,e.x=this.R*a+this.x0,e}function $i(e){for(var t=e.x-this.x0,i=e.y-this.y0,n=t/this.R,r=2*(Math.atan(Math.exp(i/this.R))-Math.PI/4),s=Math.asin(Math.cos(this.b0)*Math.sin(r)+Math.sin(this.b0)*Math.cos(r)*Math.cos(n)),a=Math.atan(Math.sin(n)/(Math.cos(this.b0)*Math.cos(n)-Math.sin(this.b0)*Math.tan(r))),o=this.lambda0+a/this.alpha,l=0,c=s,h=-1e3,u=0;Math.abs(c-h)>1e-7;){if(++u>20)return;l=1/this.alpha*(Math.log(Math.tan(Math.PI/4+s/2))-this.K)+this.e*Math.log(Math.tan(Math.PI/4+Math.asin(this.e*Math.sin(c))/2)),h=c,c=2*Math.atan(Math.exp(l))-Math.PI/2}return e.x=o,e.y=c,e}var Wi={init:Qi,forward:Hi,inverse:$i,names:["somerc"]},qi=1e-7;function Yi(e){var t=["Hotine_Oblique_Mercator","Hotine_Oblique_Mercator_variant_A","Hotine_Oblique_Mercator_Azimuth_Natural_Origin"],i="object"==typeof e.projName?Object.keys(e.projName)[0]:e.projName;return"no_uoff"in e||"no_off"in e||-1!==t.indexOf(i)||-1!==t.indexOf(we(i))}function Xi(){var e,t,i,n,r,s,a,o,l,c,u,d=0,p=0,f=0,g=0,v=0,y=0,x=0;this.no_off=Yi(this),this.no_rot="no_rot"in this;var b=!1;"alpha"in this&&(b=!0);var S=!1;if("rectified_grid_angle"in this&&(S=!0),b&&(x=this.alpha),S&&(d=this.rectified_grid_angle),b||S)p=this.longc;else if(f=this.long1,v=this.lat1,g=this.long2,y=this.lat2,Math.abs(v-y)<=qi||(e=Math.abs(v))<=qi||Math.abs(e-h)<=qi||Math.abs(Math.abs(this.lat0)-h)<=qi||Math.abs(Math.abs(y)-h)<=qi)throw new Error;var C=1-this.es;t=Math.sqrt(C),Math.abs(this.lat0)>m?(o=Math.sin(this.lat0),i=Math.cos(this.lat0),e=1-this.es*o*o,this.B=i*i,this.B=Math.sqrt(1+this.es*this.B*this.B/C),this.A=this.B*this.k0*t/e,(r=(n=this.B*t/(i*Math.sqrt(e)))*n-1)<=0?r=0:(r=Math.sqrt(r),this.lat0<0&&(r=-r)),this.E=r+=n,this.E*=Math.pow(_e(this.e,this.lat0,o),this.B)):(this.B=1/t,this.A=this.k0,this.E=n=r=1),b||S?(b?(u=Math.asin(Math.sin(x)/n),S||(d=x)):(u=d,x=Math.asin(n*Math.sin(u))),this.lam0=p-Math.asin(.5*(r-1/r)*Math.tan(u))/this.B):(s=Math.pow(_e(this.e,v,Math.sin(v)),this.B),a=Math.pow(_e(this.e,y,Math.sin(y)),this.B),r=this.E/s,l=(a-s)/(a+s),c=((c=this.E*this.E)-a*s)/(c+a*s),(e=f-g)<-Math.pi?g-=A:e>Math.pi&&(g+=A),this.lam0=ge(.5*(f+g)-Math.atan(c*Math.tan(.5*this.B*(f-g))/l)/this.B),u=Math.atan(2*Math.sin(this.B*ge(f-this.lam0))/(r-1/r)),d=x=Math.asin(n*Math.sin(u))),this.singam=Math.sin(u),this.cosgam=Math.cos(u),this.sinrot=Math.sin(d),this.cosrot=Math.cos(d),this.rB=1/this.B,this.ArB=this.A*this.rB,this.BrA=1/this.ArB,this.no_off?this.u_0=0:(this.u_0=Math.abs(this.ArB*Math.atan(Math.sqrt(n*n-1)/Math.cos(x))),this.lat0<0&&(this.u_0=-this.u_0)),r=.5*u,this.v_pole_n=this.ArB*Math.log(Math.tan(_-r)),this.v_pole_s=this.ArB*Math.log(Math.tan(_+r))}function Zi(e){var t,i,n,r,s,a,o,l,c={};if(e.x=e.x-this.lam0,Math.abs(Math.abs(e.y)-h)>m){if(t=.5*((s=this.E/Math.pow(_e(this.e,e.y,Math.sin(e.y)),this.B))-(a=1/s)),i=.5*(s+a),r=Math.sin(this.B*e.x),n=(t*this.singam-r*this.cosgam)/i,Math.abs(Math.abs(n)-1)<m)throw new Error;l=.5*this.ArB*Math.log((1-n)/(1+n)),a=Math.cos(this.B*e.x),o=Math.abs(a)<qi?this.A*e.x:this.ArB*Math.atan2(t*this.cosgam+r*this.singam,a)}else l=e.y>0?this.v_pole_n:this.v_pole_s,o=this.ArB*e.y;return this.no_rot?(c.x=o,c.y=l):(o-=this.u_0,c.x=l*this.cosrot+o*this.sinrot,c.y=o*this.cosrot-l*this.sinrot),c.x=this.a*c.x+this.x0,c.y=this.a*c.y+this.y0,c}function Ki(e){var t,i,n,r,s,a,o,l={};if(e.x=(e.x-this.x0)*(1/this.a),e.y=(e.y-this.y0)*(1/this.a),this.no_rot?(i=e.y,t=e.x):(i=e.x*this.cosrot-e.y*this.sinrot,t=e.y*this.cosrot+e.x*this.sinrot+this.u_0),r=.5*((n=Math.exp(-this.BrA*i))-1/n),s=.5*(n+1/n),o=((a=Math.sin(this.BrA*t))*this.cosgam+r*this.singam)/s,Math.abs(Math.abs(o)-1)<m)l.x=0,l.y=o<0?-h:h;else{if(l.y=this.E/Math.sqrt((1+o)/(1-o)),l.y=Ae(this.e,Math.pow(l.y,1/this.B)),l.y===1/0)throw new Error;l.x=-this.rB*Math.atan2(r*this.cosgam-a*this.singam,Math.cos(this.BrA*t))}return l.x+=this.lam0,l}var Ji={init:Xi,forward:Zi,inverse:Ki,names:["Hotine_Oblique_Mercator","Hotine Oblique Mercator","Hotine_Oblique_Mercator_variant_A","Hotine_Oblique_Mercator_Variant_B","Hotine_Oblique_Mercator_Azimuth_Natural_Origin","Hotine_Oblique_Mercator_Two_Point_Natural_Origin","Hotine_Oblique_Mercator_Azimuth_Center","Oblique_Mercator","omerc"]};function en(){if(this.lat2||(this.lat2=this.lat1),this.k0||(this.k0=1),this.x0=this.x0||0,this.y0=this.y0||0,!(Math.abs(this.lat1+this.lat2)<m)){var e=this.b/this.a;this.e=Math.sqrt(1-e*e);var t=Math.sin(this.lat1),i=Math.cos(this.lat1),n=me(this.e,t,i),r=_e(this.e,this.lat1,t),s=Math.sin(this.lat2),a=Math.cos(this.lat2),o=me(this.e,s,a),l=_e(this.e,this.lat2,s),c=Math.abs(Math.abs(this.lat0)-h)<m?0:_e(this.e,this.lat0,Math.sin(this.lat0));Math.abs(this.lat1-this.lat2)>m?this.ns=Math.log(n/o)/Math.log(r/l):this.ns=t,isNaN(this.ns)&&(this.ns=t),this.f0=n/(this.ns*Math.pow(r,this.ns)),this.rh=this.a*this.f0*Math.pow(c,this.ns),this.title||(this.title="Lambert Conformal Conic")}}function tn(e){var t=e.x,i=e.y;Math.abs(2*Math.abs(i)-Math.PI)<=m&&(i=fe(i)*(h-2*m));var n,r,s=Math.abs(Math.abs(i)-h);if(s>m)n=_e(this.e,i,Math.sin(i)),r=this.a*this.f0*Math.pow(n,this.ns);else{if((s=i*this.ns)<=0)return null;r=0}var a=this.ns*ge(t-this.long0);return e.x=this.k0*(r*Math.sin(a))+this.x0,e.y=this.k0*(this.rh-r*Math.cos(a))+this.y0,e}function nn(e){var t,i,n,r,s,a=(e.x-this.x0)/this.k0,o=this.rh-(e.y-this.y0)/this.k0;this.ns>0?(t=Math.sqrt(a*a+o*o),i=1):(t=-Math.sqrt(a*a+o*o),i=-1);var l=0;if(0!==t&&(l=Math.atan2(i*a,i*o)),0!==t||this.ns>0){if(i=1/this.ns,n=Math.pow(t/(this.a*this.f0),i),-9999===(r=Ae(this.e,n)))return null}else r=-h;return s=ge(l/this.ns+this.long0),e.x=s,e.y=r,e}var rn={init:en,forward:tn,inverse:nn,names:["Lambert Tangential Conformal Conic Projection","Lambert_Conformal_Conic","Lambert_Conformal_Conic_1SP","Lambert_Conformal_Conic_2SP","lcc","Lambert Conic Conformal (1SP)","Lambert Conic Conformal (2SP)"]};function sn(){this.a=6377397.155,this.es=.006674372230614,this.e=Math.sqrt(this.es),this.lat0||(this.lat0=.863937979737193),this.long0||(this.long0=.4334234309119251),this.k0||(this.k0=.9999),this.s45=.785398163397448,this.s90=2*this.s45,this.fi0=this.lat0,this.e2=this.es,this.e=Math.sqrt(this.e2),this.alfa=Math.sqrt(1+this.e2*Math.pow(Math.cos(this.fi0),4)/(1-this.e2)),this.uq=1.04216856380474,this.u0=Math.asin(Math.sin(this.fi0)/this.alfa),this.g=Math.pow((1+this.e*Math.sin(this.fi0))/(1-this.e*Math.sin(this.fi0)),this.alfa*this.e/2),this.k=Math.tan(this.u0/2+this.s45)/Math.pow(Math.tan(this.fi0/2+this.s45),this.alfa)*this.g,this.k1=this.k0,this.n0=this.a*Math.sqrt(1-this.e2)/(1-this.e2*Math.pow(Math.sin(this.fi0),2)),this.s0=1.37008346281555,this.n=Math.sin(this.s0),this.ro0=this.k1*this.n0/Math.tan(this.s0),this.ad=this.s90-this.uq}function an(e){var t,i,n,r,s,a,o,l=e.x,c=e.y,h=ge(l-this.long0);return t=Math.pow((1+this.e*Math.sin(c))/(1-this.e*Math.sin(c)),this.alfa*this.e/2),i=2*(Math.atan(this.k*Math.pow(Math.tan(c/2+this.s45),this.alfa)/t)-this.s45),n=-h*this.alfa,r=Math.asin(Math.cos(this.ad)*Math.sin(i)+Math.sin(this.ad)*Math.cos(i)*Math.cos(n)),s=Math.asin(Math.cos(i)*Math.sin(n)/Math.cos(r)),a=this.n*s,o=this.ro0*Math.pow(Math.tan(this.s0/2+this.s45),this.n)/Math.pow(Math.tan(r/2+this.s45),this.n),e.y=o*Math.cos(a)/1,e.x=o*Math.sin(a)/1,this.czech||(e.y*=-1,e.x*=-1),e}function on(e){var t,i,n,r,s,a,o,l=e.x;e.x=e.y,e.y=l,this.czech||(e.y*=-1,e.x*=-1),s=Math.sqrt(e.x*e.x+e.y*e.y),r=Math.atan2(e.y,e.x)/Math.sin(this.s0),n=2*(Math.atan(Math.pow(this.ro0/s,1/this.n)*Math.tan(this.s0/2+this.s45))-this.s45),t=Math.asin(Math.cos(this.ad)*Math.sin(n)-Math.sin(this.ad)*Math.cos(n)*Math.cos(r)),i=Math.asin(Math.cos(n)*Math.sin(r)/Math.cos(t)),e.x=this.long0-i/this.alfa,a=t,o=0;var c=0;do{e.y=2*(Math.atan(Math.pow(this.k,-1/this.alfa)*Math.pow(Math.tan(t/2+this.s45),1/this.alfa)*Math.pow((1+this.e*Math.sin(a))/(1-this.e*Math.sin(a)),this.e/2))-this.s45),Math.abs(a-e.y)<1e-10&&(o=1),a=e.y,c+=1}while(0===o&&c<15);return c>=15?null:e}var ln={init:sn,forward:an,inverse:on,names:["Krovak","krovak"]};function cn(e,t,i,n,r){return e*r-t*Math.sin(2*r)+i*Math.sin(4*r)-n*Math.sin(6*r)}function hn(e){return 1-.25*e*(1+e/16*(3+1.25*e))}function un(e){return.375*e*(1+.25*e*(1+.46875*e))}function dn(e){return.05859375*e*e*(1+.75*e)}function pn(e){return e*e*e*(35/3072)}function mn(e,t,i){var n=t*i;return e/Math.sqrt(1-n*n)}function fn(e){return Math.abs(e)<h?e:e-fe(e)*Math.PI}function gn(e,t,i,n,r){var s,a;s=e/t;for(var o=0;o<15;o++)if(s+=a=(e-(t*s-i*Math.sin(2*s)+n*Math.sin(4*s)-r*Math.sin(6*s)))/(t-2*i*Math.cos(2*s)+4*n*Math.cos(4*s)-6*r*Math.cos(6*s)),Math.abs(a)<=1e-10)return s;return NaN}function _n(){this.sphere||(this.e0=hn(this.es),this.e1=un(this.es),this.e2=dn(this.es),this.e3=pn(this.es),this.ml0=this.a*cn(this.e0,this.e1,this.e2,this.e3,this.lat0))}function An(e){var t,i,n=e.x,r=e.y;if(n=ge(n-this.long0),this.sphere)t=this.a*Math.asin(Math.cos(r)*Math.sin(n)),i=this.a*(Math.atan2(Math.tan(r),Math.cos(n))-this.lat0);else{var s=Math.sin(r),a=Math.cos(r),o=mn(this.a,this.e,s),l=Math.tan(r)*Math.tan(r),c=n*Math.cos(r),h=c*c,u=this.es*a*a/(1-this.es);t=o*c*(1-h*l*(1/6-(8-l+8*u)*h/120)),i=this.a*cn(this.e0,this.e1,this.e2,this.e3,r)-this.ml0+o*s/a*h*(.5+(5-l+6*u)*h/24)}return e.x=t+this.x0,e.y=i+this.y0,e}function vn(e){e.x-=this.x0,e.y-=this.y0;var t,i,n=e.x/this.a,r=e.y/this.a;if(this.sphere){var s=r+this.lat0;t=Math.asin(Math.sin(s)*Math.cos(n)),i=Math.atan2(Math.tan(n),Math.cos(s))}else{var a=gn(this.ml0/this.a+r,this.e0,this.e1,this.e2,this.e3);if(Math.abs(Math.abs(a)-h)<=m)return e.x=this.long0,e.y=h,r<0&&(e.y*=-1),e;var o=mn(this.a,this.e,Math.sin(a)),l=o*o*o/this.a/this.a*(1-this.es),c=Math.pow(Math.tan(a),2),u=n*this.a/o,d=u*u;t=a-o*Math.tan(a)/l*u*u*(.5-(1+3*c)*u*u/24),i=u*(1-d*(c/3+(1+3*c)*c*d/15))/Math.cos(a)}return e.x=ge(i+this.long0),e.y=fn(t),e}var yn={init:_n,forward:An,inverse:vn,names:["Cassini","Cassini_Soldner","cass"]};function xn(e,t){var i;return e>1e-7?(1-e*e)*(t/(1-(i=e*t)*i)-.5/e*Math.log((1-i)/(1+i))):2*t}function bn(){var e,t=Math.abs(this.lat0);if(Math.abs(t-h)<m?this.mode=this.lat0<0?this.S_POLE:this.N_POLE:Math.abs(t)<m?this.mode=this.EQUIT:this.mode=this.OBLIQ,this.es>0)switch(this.qp=xn(this.e,1),this.mmf=.5/(1-this.es),this.apa=Rn(this.es),this.mode){case this.N_POLE:case this.S_POLE:this.dd=1;break;case this.EQUIT:this.rq=Math.sqrt(.5*this.qp),this.dd=1/this.rq,this.xmf=1,this.ymf=.5*this.qp;break;case this.OBLIQ:this.rq=Math.sqrt(.5*this.qp),e=Math.sin(this.lat0),this.sinb1=xn(this.e,e)/this.qp,this.cosb1=Math.sqrt(1-this.sinb1*this.sinb1),this.dd=Math.cos(this.lat0)/(Math.sqrt(1-this.es*e*e)*this.rq*this.cosb1),this.ymf=(this.xmf=this.rq)/this.dd,this.xmf*=this.dd}else this.mode===this.OBLIQ&&(this.sinph0=Math.sin(this.lat0),this.cosph0=Math.cos(this.lat0))}function Sn(e){var t,i,n,r,s,a,o,l,c,u,d=e.x,p=e.y;if(d=ge(d-this.long0),this.sphere){if(s=Math.sin(p),u=Math.cos(p),n=Math.cos(d),this.mode===this.OBLIQ||this.mode===this.EQUIT){if((i=this.mode===this.EQUIT?1+u*n:1+this.sinph0*s+this.cosph0*u*n)<=m)return null;t=(i=Math.sqrt(2/i))*u*Math.sin(d),i*=this.mode===this.EQUIT?s:this.cosph0*s-this.sinph0*u*n}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(n=-n),Math.abs(p+this.lat0)<m)return null;i=_-.5*p,t=(i=2*(this.mode===this.S_POLE?Math.cos(i):Math.sin(i)))*Math.sin(d),i*=n}}else{switch(o=0,l=0,c=0,n=Math.cos(d),r=Math.sin(d),s=Math.sin(p),a=xn(this.e,s),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(o=a/this.qp,l=Math.sqrt(1-o*o)),this.mode){case this.OBLIQ:c=1+this.sinb1*o+this.cosb1*l*n;break;case this.EQUIT:c=1+l*n;break;case this.N_POLE:c=h+p,a=this.qp-a;break;case this.S_POLE:c=p-h,a=this.qp+a}if(Math.abs(c)<m)return null;switch(this.mode){case this.OBLIQ:case this.EQUIT:c=Math.sqrt(2/c),i=this.mode===this.OBLIQ?this.ymf*c*(this.cosb1*o-this.sinb1*l*n):(c=Math.sqrt(2/(1+l*n)))*o*this.ymf,t=this.xmf*c*l*r;break;case this.N_POLE:case this.S_POLE:a>=0?(t=(c=Math.sqrt(a))*r,i=n*(this.mode===this.S_POLE?c:-c)):t=i=0}}return e.x=this.a*t+this.x0,e.y=this.a*i+this.y0,e}function Cn(e){e.x-=this.x0,e.y-=this.y0;var t,i,n,r,s,a,o,l=e.x/this.a,c=e.y/this.a;if(this.sphere){var u,d=0,p=0;if((i=.5*(u=Math.sqrt(l*l+c*c)))>1)return null;switch(i=2*Math.asin(i),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(p=Math.sin(i),d=Math.cos(i)),this.mode){case this.EQUIT:i=Math.abs(u)<=m?0:Math.asin(c*p/u),l*=p,c=d*u;break;case this.OBLIQ:i=Math.abs(u)<=m?this.lat0:Math.asin(d*this.sinph0+c*p*this.cosph0/u),l*=p*this.cosph0,c=(d-Math.sin(i)*this.sinph0)*u;break;case this.N_POLE:c=-c,i=h-i;break;case this.S_POLE:i-=h}t=0!==c||this.mode!==this.EQUIT&&this.mode!==this.OBLIQ?Math.atan2(l,c):0}else{if(o=0,this.mode===this.OBLIQ||this.mode===this.EQUIT){if(l/=this.dd,c*=this.dd,(a=Math.sqrt(l*l+c*c))<m)return e.x=this.long0,e.y=this.lat0,e;r=2*Math.asin(.5*a/this.rq),n=Math.cos(r),l*=r=Math.sin(r),this.mode===this.OBLIQ?(o=n*this.sinb1+c*r*this.cosb1/a,s=this.qp*o,c=a*this.cosb1*n-c*this.sinb1*r):(o=c*r/a,s=this.qp*o,c=a*n)}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(c=-c),!(s=l*l+c*c))return e.x=this.long0,e.y=this.lat0,e;o=1-s/this.qp,this.mode===this.S_POLE&&(o=-o)}t=Math.atan2(l,c),i=Bn(Math.asin(o),this.apa)}return e.x=ge(this.long0+t),e.y=i,e}var Tn=.3333333333333333,En=.17222222222222222,Mn=.10257936507936508,wn=.06388888888888888,In=.0664021164021164,Pn=.016415012942191543;function Rn(e){var t,i=[];return i[0]=e*Tn,t=e*e,i[0]+=t*En,i[1]=t*wn,t*=e,i[0]+=t*Mn,i[1]+=t*In,i[2]=t*Pn,i}function Bn(e,t){var i=e+e;return e+t[0]*Math.sin(i)+t[1]*Math.sin(i+i)+t[2]*Math.sin(i+i+i)}var Dn={init:bn,forward:Sn,inverse:Cn,names:["Lambert Azimuthal Equal Area","Lambert_Azimuthal_Equal_Area","laea"],S_POLE:1,N_POLE:2,EQUIT:3,OBLIQ:4};function Fn(e){return Math.abs(e)>1&&(e=e>1?1:-1),Math.asin(e)}function On(){Math.abs(this.lat1+this.lat2)<m||(this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e3=Math.sqrt(this.es),this.sin_po=Math.sin(this.lat1),this.cos_po=Math.cos(this.lat1),this.t1=this.sin_po,this.con=this.sin_po,this.ms1=me(this.e3,this.sin_po,this.cos_po),this.qs1=xn(this.e3,this.sin_po),this.sin_po=Math.sin(this.lat2),this.cos_po=Math.cos(this.lat2),this.t2=this.sin_po,this.ms2=me(this.e3,this.sin_po,this.cos_po),this.qs2=xn(this.e3,this.sin_po),this.sin_po=Math.sin(this.lat0),this.cos_po=Math.cos(this.lat0),this.t3=this.sin_po,this.qs0=xn(this.e3,this.sin_po),Math.abs(this.lat1-this.lat2)>m?this.ns0=(this.ms1*this.ms1-this.ms2*this.ms2)/(this.qs2-this.qs1):this.ns0=this.con,this.c=this.ms1*this.ms1+this.ns0*this.qs1,this.rh=this.a*Math.sqrt(this.c-this.ns0*this.qs0)/this.ns0)}function Ln(e){var t=e.x,i=e.y;this.sin_phi=Math.sin(i),this.cos_phi=Math.cos(i);var n=xn(this.e3,this.sin_phi),r=this.a*Math.sqrt(this.c-this.ns0*n)/this.ns0,s=this.ns0*ge(t-this.long0),a=r*Math.sin(s)+this.x0,o=this.rh-r*Math.cos(s)+this.y0;return e.x=a,e.y=o,e}function Nn(e){var t,i,n,r,s,a;return e.x-=this.x0,e.y=this.rh-e.y+this.y0,this.ns0>=0?(t=Math.sqrt(e.x*e.x+e.y*e.y),n=1):(t=-Math.sqrt(e.x*e.x+e.y*e.y),n=-1),r=0,0!==t&&(r=Math.atan2(n*e.x,n*e.y)),n=t*this.ns0/this.a,this.sphere?a=Math.asin((this.c-n*n)/(2*this.ns0)):(i=(this.c-n*n)/this.ns0,a=this.phi1z(this.e3,i)),s=ge(r/this.ns0+this.long0),e.x=s,e.y=a,e}function Vn(e,t){var i,n,r,s,a=Fn(.5*t);if(e<m)return a;for(var o=e*e,l=1;l<=25;l++)if(a+=s=.5*(r=1-(n=e*(i=Math.sin(a)))*n)*r/Math.cos(a)*(t/(1-o)-i/r+.5/e*Math.log((1-n)/(1+n))),Math.abs(s)<=1e-7)return a;return null}var Un={init:On,forward:Ln,inverse:Nn,names:["Albers_Conic_Equal_Area","Albers_Equal_Area","Albers","aea"],phi1z:Vn};function kn(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0),this.infinity_dist=1e3*this.a,this.rc=1}function Gn(e){var t,i,n,r,s,a,o,l,c=e.x,h=e.y;return n=ge(c-this.long0),t=Math.sin(h),i=Math.cos(h),r=Math.cos(n),s=1,(a=this.sin_p14*t+this.cos_p14*i*r)>0||Math.abs(a)<=m?(o=this.x0+this.a*s*i*Math.sin(n)/a,l=this.y0+this.a*s*(this.cos_p14*t-this.sin_p14*i*r)/a):(o=this.x0+this.infinity_dist*i*Math.sin(n),l=this.y0+this.infinity_dist*(this.cos_p14*t-this.sin_p14*i*r)),e.x=o,e.y=l,e}function zn(e){var t,i,n,r,s,a;return e.x=(e.x-this.x0)/this.a,e.y=(e.y-this.y0)/this.a,e.x/=this.k0,e.y/=this.k0,(t=Math.sqrt(e.x*e.x+e.y*e.y))?(r=Math.atan2(t,this.rc),i=Math.sin(r),a=Fn((n=Math.cos(r))*this.sin_p14+e.y*i*this.cos_p14/t),s=Math.atan2(e.x*i,t*this.cos_p14*n-e.y*this.sin_p14*i),s=ge(this.long0+s)):(a=this.phic0,s=0),e.x=s,e.y=a,e}var jn={init:kn,forward:Gn,inverse:zn,names:["gnom"]};function Qn(e,t){var i=1-(1-e*e)/(2*e)*Math.log((1-e)/(1+e));if(Math.abs(Math.abs(t)-i)<1e-6)return t<0?-1*h:h;for(var n,r,s,a,o=Math.asin(.5*t),l=0;l<30;l++)if(r=Math.sin(o),s=Math.cos(o),a=e*r,o+=n=Math.pow(1-a*a,2)/(2*s)*(t/(1-e*e)-r/(1-a*a)+.5/e*Math.log((1-a)/(1+a))),Math.abs(n)<=1e-10)return o;return NaN}function Hn(){this.sphere||(this.k0=me(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)))}function $n(e){var t,i,n=e.x,r=e.y,s=ge(n-this.long0);if(this.sphere)t=this.x0+this.a*s*Math.cos(this.lat_ts),i=this.y0+this.a*Math.sin(r)/Math.cos(this.lat_ts);else{var a=xn(this.e,Math.sin(r));t=this.x0+this.a*this.k0*s,i=this.y0+this.a*a*.5/this.k0}return e.x=t,e.y=i,e}function Wn(e){var t,i;return e.x-=this.x0,e.y-=this.y0,this.sphere?(t=ge(this.long0+e.x/this.a/Math.cos(this.lat_ts)),i=Math.asin(e.y/this.a*Math.cos(this.lat_ts))):(i=Qn(this.e,2*e.y*this.k0/this.a),t=ge(this.long0+e.x/(this.a*this.k0))),e.x=t,e.y=i,e}var qn={init:Hn,forward:$n,inverse:Wn,names:["cea"]};function Yn(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.lat_ts=this.lat_ts||0,this.title=this.title||"Equidistant Cylindrical (Plate Carre)",this.rc=Math.cos(this.lat_ts)}function Xn(e){var t=e.x,i=e.y,n=ge(t-this.long0),r=fn(i-this.lat0);return e.x=this.x0+this.a*n*this.rc,e.y=this.y0+this.a*r,e}function Zn(e){var t=e.x,i=e.y;return e.x=ge(this.long0+(t-this.x0)/(this.a*this.rc)),e.y=fn(this.lat0+(i-this.y0)/this.a),e}var Kn={init:Yn,forward:Xn,inverse:Zn,names:["Equirectangular","Equidistant_Cylindrical","Equidistant_Cylindrical_Spherical","eqc"]},Jn=20;function er(){this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=hn(this.es),this.e1=un(this.es),this.e2=dn(this.es),this.e3=pn(this.es),this.ml0=this.a*cn(this.e0,this.e1,this.e2,this.e3,this.lat0)}function tr(e){var t,i,n,r=e.x,s=e.y,a=ge(r-this.long0);if(n=a*Math.sin(s),this.sphere)Math.abs(s)<=m?(t=this.a*a,i=-1*this.a*this.lat0):(t=this.a*Math.sin(n)/Math.tan(s),i=this.a*(fn(s-this.lat0)+(1-Math.cos(n))/Math.tan(s)));else if(Math.abs(s)<=m)t=this.a*a,i=-1*this.ml0;else{var o=mn(this.a,this.e,Math.sin(s))/Math.tan(s);t=o*Math.sin(n),i=this.a*cn(this.e0,this.e1,this.e2,this.e3,s)-this.ml0+o*(1-Math.cos(n))}return e.x=t+this.x0,e.y=i+this.y0,e}function ir(e){var t,i,n,r,s,a,o,l,c;if(n=e.x-this.x0,r=e.y-this.y0,this.sphere)if(Math.abs(r+this.a*this.lat0)<=m)t=ge(n/this.a+this.long0),i=0;else{var h;for(a=this.lat0+r/this.a,o=n*n/this.a/this.a+a*a,l=a,s=Jn;s;--s)if(l+=c=-1*(a*(l*(h=Math.tan(l))+1)-l-.5*(l*l+o)*h)/((l-a)/h-1),Math.abs(c)<=m){i=l;break}t=ge(this.long0+Math.asin(n*Math.tan(l)/this.a)/Math.sin(i))}else if(Math.abs(r+this.ml0)<=m)i=0,t=ge(this.long0+n/this.a);else{var u,d,p,f,g;for(a=(this.ml0+r)/this.a,o=n*n/this.a/this.a+a*a,l=a,s=Jn;s;--s)if(g=this.e*Math.sin(l),u=Math.sqrt(1-g*g)*Math.tan(l),d=this.a*cn(this.e0,this.e1,this.e2,this.e3,l),p=this.e0-2*this.e1*Math.cos(2*l)+4*this.e2*Math.cos(4*l)-6*this.e3*Math.cos(6*l),l-=c=(a*(u*(f=d/this.a)+1)-f-.5*u*(f*f+o))/(this.es*Math.sin(2*l)*(f*f+o-2*a*f)/(4*u)+(a-f)*(u*p-2/Math.sin(2*l))-p),Math.abs(c)<=m){i=l;break}u=Math.sqrt(1-this.es*Math.pow(Math.sin(i),2))*Math.tan(i),t=ge(this.long0+Math.asin(n*u/this.a)/Math.sin(i))}return e.x=t,e.y=i,e}var nr={init:er,forward:tr,inverse:ir,names:["Polyconic","American_Polyconic","poly"]};function rr(){this.A=[],this.A[1]=.6399175073,this.A[2]=-.1358797613,this.A[3]=.063294409,this.A[4]=-.02526853,this.A[5]=.0117879,this.A[6]=-.0055161,this.A[7]=.0026906,this.A[8]=-.001333,this.A[9]=67e-5,this.A[10]=-34e-5,this.B_re=[],this.B_im=[],this.B_re[1]=.7557853228,this.B_im[1]=0,this.B_re[2]=.249204646,this.B_im[2]=.003371507,this.B_re[3]=-.001541739,this.B_im[3]=.04105856,this.B_re[4]=-.10162907,this.B_im[4]=.01727609,this.B_re[5]=-.26623489,this.B_im[5]=-.36249218,this.B_re[6]=-.6870983,this.B_im[6]=-1.1651967,this.C_re=[],this.C_im=[],this.C_re[1]=1.3231270439,this.C_im[1]=0,this.C_re[2]=-.577245789,this.C_im[2]=-.007809598,this.C_re[3]=.508307513,this.C_im[3]=-.112208952,this.C_re[4]=-.15094762,this.C_im[4]=.18200602,this.C_re[5]=1.01418179,this.C_im[5]=1.64497696,this.C_re[6]=1.9660549,this.C_im[6]=2.5127645,this.D=[],this.D[1]=1.5627014243,this.D[2]=.5185406398,this.D[3]=-.03333098,this.D[4]=-.1052906,this.D[5]=-.0368594,this.D[6]=.007317,this.D[7]=.0122,this.D[8]=.00394,this.D[9]=-.0013}function sr(e){var t,i=e.x,n=e.y-this.lat0,r=i-this.long0,s=n/c*1e-5,a=r,o=1,l=0;for(t=1;t<=10;t++)o*=s,l+=this.A[t]*o;var h,u=l,d=a,p=1,m=0,f=0,g=0;for(t=1;t<=6;t++)h=m*u+p*d,p=p*u-m*d,m=h,f=f+this.B_re[t]*p-this.B_im[t]*m,g=g+this.B_im[t]*p+this.B_re[t]*m;return e.x=g*this.a+this.x0,e.y=f*this.a+this.y0,e}function ar(e){var t,i,n=e.x,r=e.y,s=n-this.x0,a=(r-this.y0)/this.a,o=s/this.a,l=1,h=0,u=0,d=0;for(t=1;t<=6;t++)i=h*a+l*o,l=l*a-h*o,h=i,u=u+this.C_re[t]*l-this.C_im[t]*h,d=d+this.C_im[t]*l+this.C_re[t]*h;for(var p=0;p<this.iterations;p++){var m,f=u,g=d,_=a,A=o;for(t=2;t<=6;t++)m=g*u+f*d,f=f*u-g*d,g=m,_+=(t-1)*(this.B_re[t]*f-this.B_im[t]*g),A+=(t-1)*(this.B_im[t]*f+this.B_re[t]*g);f=1,g=0;var v=this.B_re[1],y=this.B_im[1];for(t=2;t<=6;t++)m=g*u+f*d,f=f*u-g*d,g=m,v+=t*(this.B_re[t]*f-this.B_im[t]*g),y+=t*(this.B_im[t]*f+this.B_re[t]*g);var x=v*v+y*y;u=(_*v+A*y)/x,d=(A*v-_*y)/x}var b=u,S=d,C=1,T=0;for(t=1;t<=9;t++)C*=b,T+=this.D[t]*C;var E=this.lat0+T*c*1e5,M=this.long0+S;return e.x=M,e.y=E,e}var or={init:rr,forward:sr,inverse:ar,names:["New_Zealand_Map_Grid","nzmg"]};function lr(){}function cr(e){var t=e.x,i=e.y,n=ge(t-this.long0),r=this.x0+this.a*n,s=this.y0+this.a*Math.log(Math.tan(Math.PI/4+i/2.5))*1.25;return e.x=r,e.y=s,e}function hr(e){e.x-=this.x0,e.y-=this.y0;var t=ge(this.long0+e.x/this.a),i=2.5*(Math.atan(Math.exp(.8*e.y/this.a))-Math.PI/4);return e.x=t,e.y=i,e}var ur={init:lr,forward:cr,inverse:hr,names:["Miller_Cylindrical","mill"]},dr=20;function pr(){this.sphere?(this.n=1,this.m=0,this.es=0,this.C_y=Math.sqrt((this.m+1)/this.n),this.C_x=this.C_y/(this.m+1)):this.en=ai(this.es)}function mr(e){var t,i,n=e.x,r=e.y;if(n=ge(n-this.long0),this.sphere){if(this.m)for(var s=this.n*Math.sin(r),a=dr;a;--a){var o=(this.m*r+Math.sin(r)-s)/(this.m+Math.cos(r));if(r-=o,Math.abs(o)<m)break}else r=1!==this.n?Math.asin(this.n*Math.sin(r)):r;t=this.a*this.C_x*n*(this.m+Math.cos(r)),i=this.a*this.C_y*r}else{var l=Math.sin(r),c=Math.cos(r);i=this.a*oi(r,l,c,this.en),t=this.a*n*c/Math.sqrt(1-this.es*l*l)}return e.x=t,e.y=i,e}function fr(e){var t,i,n;return e.x-=this.x0,i=e.x/this.a,e.y-=this.y0,t=e.y/this.a,this.sphere?(t/=this.C_y,i/=this.C_x*(this.m+Math.cos(t)),this.m?t=Fn((this.m*t+Math.sin(t))/this.n):1!==this.n&&(t=Fn(Math.sin(t)/this.n)),i=ge(i+this.long0),t=fn(t)):(t=ci(e.y/this.a,this.es,this.en),(n=Math.abs(t))<h?(n=Math.sin(t),i=ge(this.long0+e.x*Math.sqrt(1-this.es*n*n)/(this.a*Math.cos(t)))):n-m<h&&(i=this.long0)),e.x=i,e.y=t,e}var gr={init:pr,forward:mr,inverse:fr,names:["Sinusoidal","sinu"]};function _r(){}function Ar(e){for(var t=e.x,i=e.y,n=ge(t-this.long0),r=i,s=Math.PI*Math.sin(i);;){var a=-(r+Math.sin(r)-s)/(1+Math.cos(r));if(r+=a,Math.abs(a)<m)break}r/=2,Math.PI/2-Math.abs(i)<m&&(n=0);var o=.900316316158*this.a*n*Math.cos(r)+this.x0,l=1.4142135623731*this.a*Math.sin(r)+this.y0;return e.x=o,e.y=l,e}function vr(e){var t,i;e.x-=this.x0,e.y-=this.y0,i=e.y/(1.4142135623731*this.a),Math.abs(i)>.999999999999&&(i=.999999999999),t=Math.asin(i);var n=ge(this.long0+e.x/(.900316316158*this.a*Math.cos(t)));n<-Math.PI&&(n=-Math.PI),n>Math.PI&&(n=Math.PI),i=(2*t+Math.sin(2*t))/Math.PI,Math.abs(i)>1&&(i=1);var r=Math.asin(i);return e.x=n,e.y=r,e}var yr={init:_r,forward:Ar,inverse:vr,names:["Mollweide","moll"]};function xr(){Math.abs(this.lat1+this.lat2)<m||(this.lat2=this.lat2||this.lat1,this.temp=this.b/this.a,this.es=1-Math.pow(this.temp,2),this.e=Math.sqrt(this.es),this.e0=hn(this.es),this.e1=un(this.es),this.e2=dn(this.es),this.e3=pn(this.es),this.sinphi=Math.sin(this.lat1),this.cosphi=Math.cos(this.lat1),this.ms1=me(this.e,this.sinphi,this.cosphi),this.ml1=cn(this.e0,this.e1,this.e2,this.e3,this.lat1),Math.abs(this.lat1-this.lat2)<m?this.ns=this.sinphi:(this.sinphi=Math.sin(this.lat2),this.cosphi=Math.cos(this.lat2),this.ms2=me(this.e,this.sinphi,this.cosphi),this.ml2=cn(this.e0,this.e1,this.e2,this.e3,this.lat2),this.ns=(this.ms1-this.ms2)/(this.ml2-this.ml1)),this.g=this.ml1+this.ms1/this.ns,this.ml0=cn(this.e0,this.e1,this.e2,this.e3,this.lat0),this.rh=this.a*(this.g-this.ml0))}function br(e){var t,i=e.x,n=e.y;if(this.sphere)t=this.a*(this.g-n);else{var r=cn(this.e0,this.e1,this.e2,this.e3,n);t=this.a*(this.g-r)}var s=this.ns*ge(i-this.long0),a=this.x0+t*Math.sin(s),o=this.y0+this.rh-t*Math.cos(s);return e.x=a,e.y=o,e}function Sr(e){var t,i,n,r;e.x-=this.x0,e.y=this.rh-e.y+this.y0,this.ns>=0?(i=Math.sqrt(e.x*e.x+e.y*e.y),t=1):(i=-Math.sqrt(e.x*e.x+e.y*e.y),t=-1);var s=0;return 0!==i&&(s=Math.atan2(t*e.x,t*e.y)),this.sphere?(r=ge(this.long0+s/this.ns),n=fn(this.g-i/this.a),e.x=r,e.y=n,e):(n=gn(this.g-i/this.a,this.e0,this.e1,this.e2,this.e3),r=ge(this.long0+s/this.ns),e.x=r,e.y=n,e)}var Cr={init:xr,forward:br,inverse:Sr,names:["Equidistant_Conic","eqdc"]};function Tr(){this.R=this.a}function Er(e){var t,i,n=e.x,r=e.y,s=ge(n-this.long0);Math.abs(r)<=m&&(t=this.x0+this.R*s,i=this.y0);var a=Fn(2*Math.abs(r/Math.PI));(Math.abs(s)<=m||Math.abs(Math.abs(r)-h)<=m)&&(t=this.x0,i=r>=0?this.y0+Math.PI*this.R*Math.tan(.5*a):this.y0+Math.PI*this.R*-Math.tan(.5*a));var o=.5*Math.abs(Math.PI/s-s/Math.PI),l=o*o,c=Math.sin(a),u=Math.cos(a),d=u/(c+u-1),p=d*d,f=d*(2/c-1),g=f*f,_=Math.PI*this.R*(o*(d-g)+Math.sqrt(l*(d-g)*(d-g)-(g+l)*(p-g)))/(g+l);s<0&&(_=-_),t=this.x0+_;var A=l+d;return _=Math.PI*this.R*(f*A-o*Math.sqrt((g+l)*(l+1)-A*A))/(g+l),i=r>=0?this.y0+_:this.y0-_,e.x=t,e.y=i,e}function Mr(e){var t,i,n,r,s,a,o,l,c,h,u,d;return e.x-=this.x0,e.y-=this.y0,u=Math.PI*this.R,s=(n=e.x/u)*n+(r=e.y/u)*r,u=3*(r*r/(l=-2*(a=-Math.abs(r)*(1+s))+1+2*r*r+s*s)+(2*(o=a-2*r*r+n*n)*o*o/l/l/l-9*a*o/l/l)/27)/(c=(a-o*o/3/l)/l)/(h=2*Math.sqrt(-c/3)),Math.abs(u)>1&&(u=u>=0?1:-1),d=Math.acos(u)/3,i=e.y>=0?(-h*Math.cos(d+Math.PI/3)-o/3/l)*Math.PI:-(-h*Math.cos(d+Math.PI/3)-o/3/l)*Math.PI,t=Math.abs(n)<m?this.long0:ge(this.long0+Math.PI*(s-1+Math.sqrt(1+2*(n*n-r*r)+s*s))/2/n),e.x=t,e.y=i,e}var wr,Ir={init:Tr,forward:Er,inverse:Mr,names:["Van_der_Grinten_I","VanDerGrinten","Van_der_Grinten","vandg"]},Pr={exports:{}};function Rr(){return wr||(wr=1,e=Pr,t=function(t){e.exports?e.exports=t:window.geodesic=t},(r={}).Constants={},r.Math={},r.Accumulator={},(i=r.Constants).WGS84={a:6378137,f:1/298.257223563},i.version={major:2,minor:1,patch:1},i.version_string="2.1.1",(n=r.Math).digits=53,n.epsilon=Math.pow(.5,n.digits-1),n.degree=Math.PI/180,n.sq=function(e){return e*e},n.hypot=function(e,t){return Math.sqrt(e*e+t*t)},n.cbrt=Math.cbrt||function(e){var t=Math.pow(Math.abs(e),1/3);return e>0?t:e<0?-t:e},n.log1p=Math.log1p||function(e){var t=1+e,i=t-1;return 0===i?e:e*Math.log(t)/i},n.atanh=Math.atanh||function(e){var t=Math.abs(e);return t=n.log1p(2*t/(1-t))/2,e>0?t:e<0?-t:e},n.copysign=function(e,t){return Math.abs(e)*(t<0||0===t&&1/t<0?-1:1)},n.sum=function(e,t){var i=e+t,n=i-t,r=i-n;return n-=e,{s:i,t:i?0-(n+(r-=t)):i}},n.polyval=function(e,t,i,n){for(var r=e<0?0:t[i++];--e>=0;)r=r*n+t[i++];return r},n.AngRound=function(e){var t=1/16,i=Math.abs(e);return i=i<t?t-(t-i):i,n.copysign(i,e)},n.remainder=function(e,t){return(e%=t)<-t/2?e+t:e<t/2?e:e-t},n.AngNormalize=function(e){var t=n.remainder(e,360);return 180===Math.abs(t)?n.copysign(180,e):t},n.LatFix=function(e){return Math.abs(e)>90?NaN:e},n.AngDiff=function(e,t){var i,r,s=n.sum(n.remainder(-e,360),n.remainder(t,360));return i=(s=n.sum(n.remainder(s.s,360),s.t)).s,r=s.t,0!==i&&180!==Math.abs(i)||(i=n.copysign(i,0===r?t-e:-r)),{d:i,e:r}},n.sincosd=function(e){var t,i,r,s,a,o,l;switch(t=e%360,i=(t-=90*(r=Math.round(t/90)))*this.degree,s=Math.sin(i),a=Math.cos(i),45===Math.abs(t)?(a=Math.sqrt(.5),s=n.copysign(a,i)):30===Math.abs(t)&&(a=Math.sqrt(.75),s=n.copysign(.5,i)),3&r){case 0:o=s,l=a;break;case 1:o=a,l=-s;break;case 2:o=-s,l=-a;break;default:o=-a,l=s}return l+=0,0===o&&(o=n.copysign(o,e)),{s:o,c:l}},n.sincosde=function(e,t){var i,r,s,a,o,l,c;switch(i=e%360,s=Math.round(i/90),r=(i=n.AngRound(i-90*s+t))*this.degree,a=Math.sin(r),o=Math.cos(r),45===Math.abs(i)?(o=Math.sqrt(.5),a=n.copysign(o,r)):30===Math.abs(i)&&(o=Math.sqrt(.75),a=n.copysign(.5,r)),3&s){case 0:l=a,c=o;break;case 1:l=o,c=-a;break;case 2:l=-a,c=-o;break;default:l=-o,c=a}return c+=0,0===l&&(l=n.copysign(l,e+t)),{s:l,c:c}},n.atan2d=function(e,t){var i,r=0;switch(Math.abs(e)>Math.abs(t)&&([e,t]=[t,e],r=2),n.copysign(1,t)<0&&(t=-t,++r),i=Math.atan2(e,t)/this.degree,r){case 1:i=n.copysign(180,e)-i;break;case 2:i=90-i;break;case 3:i=-90+i}return i},function(e,t){e.Accumulator=function(e){this.Set(e)},e.Accumulator.prototype.Set=function(t){t||(t=0),t.constructor===e.Accumulator?(this._s=t._s,this._t=t._t):(this._s=t,this._t=0)},e.Accumulator.prototype.Add=function(e){var i=t.sum(e,this._t),n=t.sum(i.s,this._s);i=i.t,this._s=n.s,this._t=n.t,0===this._s?this._s=i:this._t+=i},e.Accumulator.prototype.Sum=function(t){var i;return t?((i=new e.Accumulator(this)).Add(t),i._s):this._s},e.Accumulator.prototype.Negate=function(){this._s*=-1,this._t*=-1},e.Accumulator.prototype.Remainder=function(e){this._s=t.remainder(this._s,e),this.Add(0)}}(r.Accumulator,r.Math),r.Geodesic={},r.GeodesicLine={},r.PolygonArea={},function(e,t,i,n,r){var s,a,o,l,c,h,u,d,p,m,f,g=6,_=g,A=g,v=g,y=v,x=20,b=x+n.digits+10,S=n.epsilon,C=200*S,T=Math.sqrt(S),E=S,M=1e3*T,w=0,I=31,P=32640;e.tiny_=Math.sqrt(Number.MIN_VALUE/Number.EPSILON),e.nC1_=g,e.nC1p_=g,e.nC2_=g,e.nC3_=g,e.nC4_=g,s=e.nC3_*(e.nC3_-1)/2,a=e.nC4_*(e.nC4_+1)/2,e.CAP_C1=1,e.CAP_C1p=2,e.CAP_C2=4,e.CAP_C3=8,e.CAP_C4=16,e.NONE=0,e.ARC=64,e.LATITUDE=128|w,e.LONGITUDE=256|e.CAP_C3,e.AZIMUTH=512|w,e.DISTANCE=1024|e.CAP_C1,e.STANDARD=e.LATITUDE|e.LONGITUDE|e.AZIMUTH|e.DISTANCE,e.DISTANCE_IN=2048|e.CAP_C1|e.CAP_C1p,e.REDUCEDLENGTH=4096|e.CAP_C1|e.CAP_C2,e.GEODESICSCALE=8192|e.CAP_C1|e.CAP_C2,e.AREA=16384|e.CAP_C4,e.ALL=P|I,e.LONG_UNROLL=32768,e.OUT_MASK=P|e.LONG_UNROLL,e.SinCosSeries=function(e,t,i,n){var r=n.length,s=r-(e?1:0),a=2*(i-t)*(i+t),o=1&s?n[--r]:0,l=0;for(s=Math.floor(s/2);s--;)o=a*(l=a*o-l+n[--r])-o+n[--r];return e?2*t*i*o:i*(o-l)},o=function(e,t){var i,r,s,a,o,l,c,h,u,d,p,m,f=n.sq(e),g=n.sq(t),_=(f+g-1)/6;return 0===g&&_<=0?i=0:(l=_,(o=(r=f*g/4)*(r+2*(a=_*(s=n.sq(_)))))>=0?(c=r+a,c+=c<0?-Math.sqrt(o):Math.sqrt(o),l+=(h=n.cbrt(c))+(0!==h?s/h:0)):(u=Math.atan2(Math.sqrt(-o),-(r+a)),l+=2*_*Math.cos(u/3)),d=Math.sqrt(n.sq(l)+g),m=((p=l<0?g/(d-l):l+d)-g)/(2*d),i=p/(Math.sqrt(p+n.sq(m))+m)),i},l=[1,4,64,0,256],e.A1m1f=function(e){var t=Math.floor(_/2);return(n.polyval(t,l,0,n.sq(e))/l[t+1]+e)/(1-e)},c=[-1,6,-16,32,-9,64,-128,2048,9,-16,768,3,-5,512,-7,1280,-7,2048],e.C1f=function(t,i){var r,s,a=n.sq(t),o=t,l=0;for(r=1;r<=e.nC1_;++r)s=Math.floor((e.nC1_-r)/2),i[r]=o*n.polyval(s,c,l,a)/c[l+s+1],l+=s+2,o*=t},h=[205,-432,768,1536,4005,-4736,3840,12288,-225,116,384,-7173,2695,7680,3467,7680,38081,61440],e.C1pf=function(t,i){var r,s,a=n.sq(t),o=t,l=0;for(r=1;r<=e.nC1p_;++r)s=Math.floor((e.nC1p_-r)/2),i[r]=o*n.polyval(s,h,l,a)/h[l+s+1],l+=s+2,o*=t},u=[-11,-28,-192,0,256],e.A2m1f=function(e){var t=Math.floor(A/2);return(n.polyval(t,u,0,n.sq(e))/u[t+1]-e)/(1+e)},d=[1,2,16,32,35,64,384,2048,15,80,768,7,35,512,63,1280,77,2048],e.C2f=function(t,i){var r,s,a=n.sq(t),o=t,l=0;for(r=1;r<=e.nC2_;++r)s=Math.floor((e.nC2_-r)/2),i[r]=o*n.polyval(s,d,l,a)/d[l+s+1],l+=s+2,o*=t},e.Geodesic=function(e,t){if(this.a=e,this.f=t,this._f1=1-this.f,this._e2=this.f*(2-this.f),this._ep2=this._e2/n.sq(this._f1),this._n=this.f/(2-this.f),this._b=this.a*this._f1,this._c2=(n.sq(this.a)+n.sq(this._b)*(0===this._e2?1:(this._e2>0?n.atanh(Math.sqrt(this._e2)):Math.atan(Math.sqrt(-this._e2)))/Math.sqrt(Math.abs(this._e2))))/2,this._etol2=.1*T/Math.sqrt(Math.max(.001,Math.abs(this.f))*Math.min(1,1-this.f/2)/2),!(isFinite(this.a)&&this.a>0))throw new Error("Equatorial radius is not positive");if(!(isFinite(this._b)&&this._b>0))throw new Error("Polar semi-axis is not positive");this._A3x=new Array(y),this._C3x=new Array(s),this._C4x=new Array(a),this.A3coeff(),this.C3coeff(),this.C4coeff()},p=[-3,128,-2,-3,64,-1,-3,-1,16,3,-1,-2,8,1,-1,2,1,1],e.Geodesic.prototype.A3coeff=function(){var e,t,i=0,r=0;for(e=v-1;e>=0;--e)t=Math.min(v-e-1,e),this._A3x[r++]=n.polyval(t,p,i,this._n)/p[i+t+1],i+=t+2},m=[3,128,2,5,128,-1,3,3,64,-1,0,1,8,-1,1,4,5,256,1,3,128,-3,-2,3,64,1,-3,2,32,7,512,-10,9,384,5,-9,5,192,7,512,-14,7,512,21,2560],e.Geodesic.prototype.C3coeff=function(){var t,i,r,s=0,a=0;for(t=1;t<e.nC3_;++t)for(i=e.nC3_-1;i>=t;--i)r=Math.min(e.nC3_-i-1,i),this._C3x[a++]=n.polyval(r,m,s,this._n)/m[s+r+1],s+=r+2},f=[97,15015,1088,156,45045,-224,-4784,1573,45045,-10656,14144,-4576,-858,45045,64,624,-4576,6864,-3003,15015,100,208,572,3432,-12012,30030,45045,1,9009,-2944,468,135135,5792,1040,-1287,135135,5952,-11648,9152,-2574,135135,-64,-624,4576,-6864,3003,135135,8,10725,1856,-936,225225,-8448,4992,-1144,225225,-1440,4160,-4576,1716,225225,-136,63063,1024,-208,105105,3584,-3328,1144,315315,-128,135135,-2560,832,405405,128,99099],e.Geodesic.prototype.C4coeff=function(){var t,i,r,s=0,a=0;for(t=0;t<e.nC4_;++t)for(i=e.nC4_-1;i>=t;--i)r=e.nC4_-i-1,this._C4x[a++]=n.polyval(r,f,s,this._n)/f[s+r+1],s+=r+2},e.Geodesic.prototype.A3f=function(e){return n.polyval(y-1,this._A3x,0,e)},e.Geodesic.prototype.C3f=function(t,i){var r,s,a=1,o=0;for(r=1;r<e.nC3_;++r)s=e.nC3_-r-1,a*=t,i[r]=a*n.polyval(s,this._C3x,o,t),o+=s+1},e.Geodesic.prototype.C4f=function(t,i){var r,s,a=1,o=0;for(r=0;r<e.nC4_;++r)s=e.nC4_-r-1,i[r]=a*n.polyval(s,this._C4x,o,t),o+=s+1,a*=t},e.Geodesic.prototype.Lengths=function(t,i,n,r,s,a,o,l,c,h,u,d,p){var m,f,g,_,A={},v=0,y=0,x=0,b=0;if((u&=e.OUT_MASK)&(e.DISTANCE|e.REDUCEDLENGTH|e.GEODESICSCALE)&&(x=e.A1m1f(t),e.C1f(t,d),u&(e.REDUCEDLENGTH|e.GEODESICSCALE)&&(b=e.A2m1f(t),e.C2f(t,p),v=x-b,b=1+b),x=1+x),u&e.DISTANCE)m=e.SinCosSeries(!0,a,o,d)-e.SinCosSeries(!0,n,r,d),A.s12b=x*(i+m),u&(e.REDUCEDLENGTH|e.GEODESICSCALE)&&(y=v*i+(x*m-b*(e.SinCosSeries(!0,a,o,p)-e.SinCosSeries(!0,n,r,p))));else if(u&(e.REDUCEDLENGTH|e.GEODESICSCALE)){for(f=1;f<=e.nC2_;++f)p[f]=x*d[f]-b*p[f];y=v*i+(e.SinCosSeries(!0,a,o,p)-e.SinCosSeries(!0,n,r,p))}return u&e.REDUCEDLENGTH&&(A.m0=v,A.m12b=l*(r*a)-s*(n*o)-r*o*y),u&e.GEODESICSCALE&&(g=r*o+n*a,_=this._ep2*(c-h)*(c+h)/(s+l),A.M12=g+(_*a-o*y)*n/s,A.M21=g-(_*n-r*y)*a/l),A},e.Geodesic.prototype.InverseStart=function(t,i,r,s,a,l,c,h,u,d,p){var m,f,g,_,A,v,y,x,b,S,T,E,w,I,P,R,B,D,F,O,L={},N=s*i-a*t,V=a*i+s*t;return L.sig12=-1,m=s*i,m+=a*t,(f=V>=0&&N<.5&&a*c<.5)?(_=n.sq(t+s),_/=_+n.sq(i+a),L.dnm=Math.sqrt(1+this._ep2*_),g=c/(this._f1*L.dnm),A=Math.sin(g),v=Math.cos(g)):(A=h,v=u),L.salp1=a*A,L.calp1=v>=0?N+a*t*n.sq(A)/(1+v):m-a*t*n.sq(A)/(1-v),x=n.hypot(L.salp1,L.calp1),b=t*s+i*a*v,f&&x<this._etol2?(L.salp2=i*A,L.calp2=N-i*s*(v>=0?n.sq(A)/(1+v):1-v),y=n.hypot(L.salp2,L.calp2),L.salp2/=y,L.calp2/=y,L.sig12=Math.atan2(x,b)):Math.abs(this._n)>.1||b>=0||x>=6*Math.abs(this._n)*Math.PI*n.sq(i)||(O=Math.atan2(-h,-u),this.f>=0?(I=(w=n.sq(t)*this._ep2)/(2*(1+Math.sqrt(1+w))+w),S=O/(E=this.f*i*this.A3f(I)*Math.PI),T=m/(E*i)):(P=a*i-s*t,R=Math.atan2(m,P),T=c/(E=((S=(B=this.Lengths(this._n,Math.PI+R,t,-i,r,s,a,l,i,a,e.REDUCEDLENGTH,d,p)).m12b/(i*a*B.m0*Math.PI)-1)<-.01?m/S:-this.f*n.sq(i)*Math.PI)/i)),T>-C&&S>-1-M?this.f>=0?(L.salp1=Math.min(1,-S),L.calp1=-Math.sqrt(1-n.sq(L.salp1))):(L.calp1=Math.max(S>-C?0:-1,S),L.salp1=Math.sqrt(1-n.sq(L.calp1))):(D=o(S,T),F=E*(this.f>=0?-S*D/(1+D):-T*(1+D)/D),A=Math.sin(F),v=-Math.cos(F),L.salp1=a*A,L.calp1=m-a*t*n.sq(A)/(1-v))),L.salp1<=0?(L.salp1=1,L.calp1=0):(y=n.hypot(L.salp1,L.calp1),L.salp1/=y,L.calp1/=y),L},e.Geodesic.prototype.Lambda12=function(t,i,r,s,a,o,l,c,h,u,d,p,m,f){var g,_,A,v,y,x,b,S,C,T,E,M,w,I={};return 0===t&&0===c&&(c=-e.tiny_),_=l*i,A=n.hypot(c,l*t),I.ssig1=t,v=_*t,I.csig1=y=c*i,g=n.hypot(I.ssig1,I.csig1),I.ssig1/=g,I.csig1/=g,I.salp2=a!==i?_/a:l,I.calp2=a!==i||Math.abs(s)!==-t?Math.sqrt(n.sq(c*i)+(i<-t?(a-i)*(i+a):(t-s)*(t+s)))/a:Math.abs(c),I.ssig2=s,x=_*s,I.csig2=b=I.calp2*a,g=n.hypot(I.ssig2,I.csig2),I.ssig2/=g,I.csig2/=g,I.sig12=Math.atan2(Math.max(0,I.csig1*I.ssig2-I.ssig1*I.csig2),I.csig1*I.csig2+I.ssig1*I.ssig2),S=Math.max(0,y*x-v*b),C=y*b+v*x,E=Math.atan2(S*u-C*h,C*u+S*h),M=n.sq(A)*this._ep2,I.eps=M/(2*(1+Math.sqrt(1+M))+M),this.C3f(I.eps,f),T=e.SinCosSeries(!0,I.ssig2,I.csig2,f)-e.SinCosSeries(!0,I.ssig1,I.csig1,f),I.domg12=-this.f*this.A3f(I.eps)*_*(I.sig12+T),I.lam12=E+I.domg12,d&&(0===I.calp2?I.dlam12=-2*this._f1*r/t:(w=this.Lengths(I.eps,I.sig12,I.ssig1,I.csig1,r,I.ssig2,I.csig2,o,i,a,e.REDUCEDLENGTH,p,m),I.dlam12=w.m12b,I.dlam12*=this._f1/(I.calp2*a))),I},e.Geodesic.prototype.Inverse=function(t,i,r,s,a){var o,l;return a||(a=e.STANDARD),a===e.LONG_UNROLL&&(a|=e.STANDARD),a&=e.OUT_MASK,l=(o=this.InverseInt(t,i,r,s,a)).vals,a&e.AZIMUTH&&(l.azi1=n.atan2d(o.salp1,o.calp1),l.azi2=n.atan2d(o.salp2,o.calp2)),l},e.Geodesic.prototype.InverseInt=function(t,i,r,s,a){var o,l,c,h,u,d,p,m,f,g,_,A,v,y,C,T,M,w,I,P,R,B,D,F,O,L,N,V,U,k,G,z,j,Q,H,$,W,q,Y,X,Z,K,J,ee,te,ie,ne,re,se,ae,oe,le,ce,he,ue,de,pe,me,fe,ge,_e,Ae,ve,ye,xe,be={};if(be.lat1=t=n.LatFix(t),be.lat2=r=n.LatFix(r),t=n.AngRound(t),r=n.AngRound(r),l=(o=n.AngDiff(i,s)).e,o=o.d,a&e.LONG_UNROLL?(be.lon1=i,be.lon2=i+o+l):(be.lon1=n.AngNormalize(i),be.lon2=n.AngNormalize(s)),l*=c=n.copysign(1,o),C=(o*=c)*n.degree,T=(h=n.sincosde(o,l)).s,M=h.c,l=180-o-l,(u=Math.abs(t)<Math.abs(r)||isNaN(r)?-1:1)<0&&(c*=-1,[r,t]=[t,r]),t*=d=n.copysign(1,-t),r*=d,h=n.sincosd(t),p=this._f1*h.s,m=h.c,p/=h=n.hypot(p,m),m/=h,m=Math.max(e.tiny_,m),h=n.sincosd(r),f=this._f1*h.s,g=h.c,f/=h=n.hypot(f,g),g/=h,g=Math.max(e.tiny_,g),m<-p?g===m&&(f=n.copysign(p,f)):Math.abs(f)===-p&&(g=m),v=Math.sqrt(1+this._ep2*n.sq(p)),y=Math.sqrt(1+this._ep2*n.sq(f)),D=new Array(e.nC1_+1),F=new Array(e.nC2_+1),O=new Array(e.nC3_),(L=-90===t||0===T)&&(P=T,B=0,V=p,U=(I=M)*m,k=f,G=(R=1)*g,w=Math.atan2(Math.max(0,U*k-V*G),U*G+V*k),_=(N=this.Lengths(this._n,w,V,U,v,k,G,y,m,g,a|e.DISTANCE|e.REDUCEDLENGTH,D,F)).s12b,A=N.m12b,a&e.GEODESICSCALE&&(be.M12=N.M12,be.M21=N.M21),w<1||A>=0?((w<3*e.tiny_||w<S&&(_<0||A<0))&&(w=A=_=0),A*=this._b,_*=this._b,be.a12=w/n.degree):L=!1),pe=2,!L&&0===p&&(this.f<=0||l>=180*this.f))I=R=0,P=B=1,_=this.a*C,w=j=C/this._f1,A=this._b*Math.sin(w),a&e.GEODESICSCALE&&(be.M12=be.M21=Math.cos(w)),be.a12=o/this._f1;else if(!L)if(w=(N=this.InverseStart(p,m,v,f,g,y,C,T,M,D,F)).sig12,P=N.salp1,I=N.calp1,w>=0)B=N.salp2,R=N.calp2,Q=N.dnm,_=w*this._b*Q,A=n.sq(Q)*this._b*Math.sin(w/Q),a&e.GEODESICSCALE&&(be.M12=be.M21=Math.cos(w/Q)),be.a12=w/n.degree,j=C/(this._f1*Q);else{for(H=0,$=e.tiny_,W=1,q=e.tiny_,Y=-1,X=!1,Z=!1;K=(N=this.Lambda12(p,m,v,f,g,y,P,I,T,M,H<x,D,F,O)).lam12,B=N.salp2,R=N.calp2,w=N.sig12,V=N.ssig1,U=N.csig1,k=N.ssig2,G=N.csig2,z=N.eps,fe=N.domg12,J=N.dlam12,!Z&&Math.abs(K)>=(X?8:1)*S&&H!=b;++H)K>0&&(H<x||I/P>Y/q)?(q=P,Y=I):K<0&&(H<x||I/P<W/$)&&($=P,W=I),H<x&&J>0&&(ee=-K/J,Math.abs(ee)<Math.PI&&(te=Math.sin(ee),(ne=P*(ie=Math.cos(ee))+I*te)>0))?(I=I*ie-P*te,P=ne,P/=h=n.hypot(P,I),I/=h,X=Math.abs(K)<=16*S):(P=($+q)/2,I=(W+Y)/2,P/=h=n.hypot(P,I),I/=h,X=!1,Z=Math.abs($-P)+(W-I)<E||Math.abs(P-q)+(I-Y)<E);re=a|(a&(e.REDUCEDLENGTH|e.GEODESICSCALE)?e.DISTANCE:e.NONE),_=(N=this.Lengths(z,w,V,U,v,k,G,y,m,g,re,D,F)).s12b,A=N.m12b,a&e.GEODESICSCALE&&(be.M12=N.M12,be.M21=N.M21),A*=this._b,_*=this._b,be.a12=w/n.degree,a&e.AREA&&(ye=Math.sin(fe),pe=T*(xe=Math.cos(fe))-M*ye,me=M*xe+T*ye)}return a&e.DISTANCE&&(be.s12=0+_),a&e.REDUCEDLENGTH&&(be.m12=0+A),a&e.AREA&&(se=P*m,0!==(ae=n.hypot(I,P*p))&&0!==se?(V=p,U=I*m,k=f,G=R*g,z=(le=n.sq(ae)*this._ep2)/(2*(1+Math.sqrt(1+le))+le),ce=n.sq(this.a)*ae*se*this._e2,V/=h=n.hypot(V,U),U/=h,k/=h=n.hypot(k,G),G/=h,he=new Array(e.nC4_),this.C4f(z,he),ue=e.SinCosSeries(!1,V,U,he),de=e.SinCosSeries(!1,k,G,he),be.S12=ce*(de-ue)):be.S12=0,L||2!=pe||(pe=Math.sin(j),me=Math.cos(j)),!L&&me>-.7071&&f-p<1.75?(fe=1+me,ge=1+m,_e=1+g,oe=2*Math.atan2(pe*(p*_e+f*ge),fe*(p*f+ge*_e))):(ve=R*I+B*P,0===(Ae=B*I-R*P)&&ve<0&&(Ae=e.tiny_*I,ve=-1),oe=Math.atan2(Ae,ve)),be.S12+=this._c2*oe,be.S12*=u*c*d,be.S12+=0),u<0&&([B,P]=[P,B],[R,I]=[I,R],a&e.GEODESICSCALE&&([be.M21,be.M12]=[be.M12,be.M21])),{vals:be,salp1:P*=u*c,calp1:I*=u*d,salp2:B*=u*c,calp2:R*=u*d}},e.Geodesic.prototype.GenDirect=function(i,n,r,s,a,o){return o?o===e.LONG_UNROLL&&(o|=e.STANDARD):o=e.STANDARD,s||(o|=e.DISTANCE_IN),new t.GeodesicLine(this,i,n,r,o).GenPosition(s,a,o)},e.Geodesic.prototype.Direct=function(e,t,i,n,r){return this.GenDirect(e,t,i,!1,n,r)},e.Geodesic.prototype.ArcDirect=function(e,t,i,n,r){return this.GenDirect(e,t,i,!0,n,r)},e.Geodesic.prototype.Line=function(e,i,n,r){return new t.GeodesicLine(this,e,i,n,r)},e.Geodesic.prototype.DirectLine=function(e,t,i,n,r){return this.GenDirectLine(e,t,i,!1,n,r)},e.Geodesic.prototype.ArcDirectLine=function(e,t,i,n,r){return this.GenDirectLine(e,t,i,!0,n,r)},e.Geodesic.prototype.GenDirectLine=function(i,n,r,s,a,o){var l;return o||(o=e.STANDARD|e.DISTANCE_IN),s||(o|=e.DISTANCE_IN),(l=new t.GeodesicLine(this,i,n,r,o)).GenSetDistance(s,a),l},e.Geodesic.prototype.InverseLine=function(i,r,s,a,o){var l,c,h;return o||(o=e.STANDARD|e.DISTANCE_IN),l=this.InverseInt(i,r,s,a,e.ARC),h=n.atan2d(l.salp1,l.calp1),o&e.OUT_MASK&e.DISTANCE_IN&&(o|=e.DISTANCE),(c=new t.GeodesicLine(this,i,r,h,o,l.salp1,l.calp1)).SetArc(l.vals.a12),c},e.Geodesic.prototype.Polygon=function(e){return new i.PolygonArea(this,e)},e.WGS84=new e.Geodesic(r.WGS84.a,r.WGS84.f)}(r.Geodesic,r.GeodesicLine,r.PolygonArea,r.Math,r.Constants),function(e,t,i){t.GeodesicLine=function(t,n,r,s,a,o,l){var c,h,u,d,p,m;a||(a=e.STANDARD|e.DISTANCE_IN),this.a=t.a,this.f=t.f,this._b=t._b,this._c2=t._c2,this._f1=t._f1,this.caps=a|e.LATITUDE|e.AZIMUTH|e.LONG_UNROLL,this.lat1=i.LatFix(n),this.lon1=r,void 0===o||void 0===l?(this.azi1=i.AngNormalize(s),c=i.sincosd(i.AngRound(this.azi1)),this.salp1=c.s,this.calp1=c.c):(this.azi1=s,this.salp1=o,this.calp1=l),c=i.sincosd(i.AngRound(this.lat1)),u=this._f1*c.s,h=c.c,u/=c=i.hypot(u,h),h/=c,h=Math.max(e.tiny_,h),this._dn1=Math.sqrt(1+t._ep2*i.sq(u)),this._salp0=this.salp1*h,this._calp0=i.hypot(this.calp1,this.salp1*u),this._ssig1=u,this._somg1=this._salp0*u,this._csig1=this._comg1=0!==u||0!==this.calp1?h*this.calp1:1,c=i.hypot(this._ssig1,this._csig1),this._ssig1/=c,this._csig1/=c,this._k2=i.sq(this._calp0)*t._ep2,d=this._k2/(2*(1+Math.sqrt(1+this._k2))+this._k2),this.caps&e.CAP_C1&&(this._A1m1=e.A1m1f(d),this._C1a=new Array(e.nC1_+1),e.C1f(d,this._C1a),this._B11=e.SinCosSeries(!0,this._ssig1,this._csig1,this._C1a),p=Math.sin(this._B11),m=Math.cos(this._B11),this._stau1=this._ssig1*m+this._csig1*p,this._ctau1=this._csig1*m-this._ssig1*p),this.caps&e.CAP_C1p&&(this._C1pa=new Array(e.nC1p_+1),e.C1pf(d,this._C1pa)),this.caps&e.CAP_C2&&(this._A2m1=e.A2m1f(d),this._C2a=new Array(e.nC2_+1),e.C2f(d,this._C2a),this._B21=e.SinCosSeries(!0,this._ssig1,this._csig1,this._C2a)),this.caps&e.CAP_C3&&(this._C3a=new Array(e.nC3_),t.C3f(d,this._C3a),this._A3c=-this.f*this._salp0*t.A3f(d),this._B31=e.SinCosSeries(!0,this._ssig1,this._csig1,this._C3a)),this.caps&e.CAP_C4&&(this._C4a=new Array(e.nC4_),t.C4f(d,this._C4a),this._A4=i.sq(this.a)*this._calp0*this._salp0*t._e2,this._B41=e.SinCosSeries(!1,this._ssig1,this._csig1,this._C4a)),this.a13=this.s13=NaN},t.GeodesicLine.prototype.GenPosition=function(t,n,r){var s,a,o,l,c,h,u,d,p,m,f,g,_,A,v,y,x,b,S,C,T,E,M,w,I,P,R={};return r?r===e.LONG_UNROLL&&(r|=e.STANDARD):r=e.STANDARD,r&=this.caps&e.OUT_MASK,R.lat1=this.lat1,R.azi1=this.azi1,R.lon1=r&e.LONG_UNROLL?this.lon1:i.AngNormalize(this.lon1),t?R.a12=n:R.s12=n,t||this.caps&e.DISTANCE_IN&e.OUT_MASK?(l=0,c=0,t?(s=n*i.degree,a=(M=i.sincosd(n)).s,o=M.c):(d=n/(this._b*(1+this._A1m1)),p=Math.sin(d),m=Math.cos(d),s=d-((l=-e.SinCosSeries(!0,this._stau1*m+this._ctau1*p,this._ctau1*m-this._stau1*p,this._C1pa))-this._B11),a=Math.sin(s),o=Math.cos(s),Math.abs(this.f)>.01&&(h=this._ssig1*o+this._csig1*a,u=this._csig1*o-this._ssig1*a,l=e.SinCosSeries(!0,h,u,this._C1a),s-=((1+this._A1m1)*(s+(l-this._B11))-n/this._b)/Math.sqrt(1+this._k2*i.sq(h)),a=Math.sin(s),o=Math.cos(s))),h=this._ssig1*o+this._csig1*a,u=this._csig1*o-this._ssig1*a,S=Math.sqrt(1+this._k2*i.sq(h)),r&(e.DISTANCE|e.REDUCEDLENGTH|e.GEODESICSCALE)&&((t||Math.abs(this.f)>.01)&&(l=e.SinCosSeries(!0,h,u,this._C1a)),c=(1+this._A1m1)*(l-this._B11)),_=this._calp0*h,0===(A=i.hypot(this._salp0,this._calp0*u))&&(A=u=e.tiny_),x=this._salp0,b=this._calp0*u,t&&r&e.DISTANCE&&(R.s12=this._b*((1+this._A1m1)*s+c)),r&e.LONGITUDE&&(v=this._salp0*h,y=u,g=i.copysign(1,this._salp0),f=((r&e.LONG_UNROLL?g*(s-(Math.atan2(h,u)-Math.atan2(this._ssig1,this._csig1))+(Math.atan2(g*v,y)-Math.atan2(g*this._somg1,this._comg1))):Math.atan2(v*this._comg1-y*this._somg1,y*this._comg1+v*this._somg1))+this._A3c*(s+(e.SinCosSeries(!0,h,u,this._C3a)-this._B31)))/i.degree,R.lon2=r&e.LONG_UNROLL?this.lon1+f:i.AngNormalize(i.AngNormalize(this.lon1)+i.AngNormalize(f))),r&e.LATITUDE&&(R.lat2=i.atan2d(_,this._f1*A)),r&e.AZIMUTH&&(R.azi2=i.atan2d(x,b)),r&(e.REDUCEDLENGTH|e.GEODESICSCALE)&&(C=e.SinCosSeries(!0,h,u,this._C2a),T=(1+this._A2m1)*(C-this._B21),E=(this._A1m1-this._A2m1)*s+(c-T),r&e.REDUCEDLENGTH&&(R.m12=this._b*(S*(this._csig1*h)-this._dn1*(this._ssig1*u)-this._csig1*u*E)),r&e.GEODESICSCALE&&(M=this._k2*(h-this._ssig1)*(h+this._ssig1)/(this._dn1+S),R.M12=o+(M*h-u*E)*this._ssig1/this._dn1,R.M21=o-(M*this._ssig1-this._csig1*E)*h/S)),r&e.AREA&&(w=e.SinCosSeries(!1,h,u,this._C4a),0===this._calp0||0===this._salp0?(I=x*this.calp1-b*this.salp1,P=b*this.calp1+x*this.salp1):(I=this._calp0*this._salp0*(o<=0?this._csig1*(1-o)+a*this._ssig1:a*(this._csig1*a/(1+o)+this._ssig1)),P=i.sq(this._salp0)+i.sq(this._calp0)*this._csig1*u),R.S12=this._c2*Math.atan2(I,P)+this._A4*(w-this._B41)),t||(R.a12=s/i.degree),R):(R.a12=NaN,R)},t.GeodesicLine.prototype.Position=function(e,t){return this.GenPosition(!1,e,t)},t.GeodesicLine.prototype.ArcPosition=function(e,t){return this.GenPosition(!0,e,t)},t.GeodesicLine.prototype.GenSetDistance=function(e,t){e?this.SetArc(t):this.SetDistance(t)},t.GeodesicLine.prototype.SetDistance=function(t){var i;this.s13=t,i=this.GenPosition(!1,this.s13,e.ARC),this.a13=0+i.a12},t.GeodesicLine.prototype.SetArc=function(t){var i;this.a13=t,i=this.GenPosition(!0,this.a13,e.DISTANCE),this.s13=0+i.s12}}(r.Geodesic,r.GeodesicLine,r.Math),function(e,t,i,n){var r,s,a,o;r=function(e,t){var n=i.AngDiff(e,t).d;return e=i.AngNormalize(e),t=i.AngNormalize(t),n>0&&(e<0&&t>=0||e>0&&0===t)?1:n<0&&e>=0&&t<0?-1:0},s=function(e,t){return(0<=(t%=720)&&t<360||t<-360?0:1)-(0<=(e%=720)&&e<360||e<-360?0:1)},a=function(e,t,i,n,r){return e.Remainder(t),1&i&&e.Add((e.Sum()<0?1:-1)*t/2),n||e.Negate(),r?e.Sum()>t/2?e.Add(-t):e.Sum()<=-t/2&&e.Add(+t):e.Sum()>=t?e.Add(-t):e.Sum()<0&&e.Add(+t),0+e.Sum()},o=function(e,t,n,r,s){return e=i.remainder(e,t),1&n&&(e+=(e<0?1:-1)*t/2),r||(e*=-1),s?e>t/2?e-=t:e<=-t/2&&(e+=t):e>=t?e-=t:e<0&&(e+=t),0+e},e.PolygonArea=function(e,i){this._geod=e,this.a=this._geod.a,this.f=this._geod.f,this._area0=4*Math.PI*e._c2,this.polyline=i||!1,this._mask=t.LATITUDE|t.LONGITUDE|t.DISTANCE|(this.polyline?t.NONE:t.AREA|t.LONG_UNROLL),this.polyline||(this._areasum=new n.Accumulator(0)),this._perimetersum=new n.Accumulator(0),this.Clear()},e.PolygonArea.prototype.Clear=function(){this.num=0,this._crossings=0,this.polyline||this._areasum.Set(0),this._perimetersum.Set(0),this._lat0=this._lon0=this.lat=this.lon=NaN},e.PolygonArea.prototype.AddPoint=function(e,t){var i;0===this.num?(this._lat0=this.lat=e,this._lon0=this.lon=t):(i=this._geod.Inverse(this.lat,this.lon,e,t,this._mask),this._perimetersum.Add(i.s12),this.polyline||(this._areasum.Add(i.S12),this._crossings+=r(this.lon,t)),this.lat=e,this.lon=t),++this.num},e.PolygonArea.prototype.AddEdge=function(e,t){var i;this.num&&(i=this._geod.Direct(this.lat,this.lon,e,t,this._mask),this._perimetersum.Add(t),this.polyline||(this._areasum.Add(i.S12),this._crossings+=s(this.lon,i.lon2)),this.lat=i.lat2,this.lon=i.lon2),++this.num},e.PolygonArea.prototype.Compute=function(e,t){var i,s,o={number:this.num};return this.num<2?(o.perimeter=0,this.polyline||(o.area=0),o):this.polyline?(o.perimeter=this._perimetersum.Sum(),o):(i=this._geod.Inverse(this.lat,this.lon,this._lat0,this._lon0,this._mask),o.perimeter=this._perimetersum.Sum(i.s12),(s=new n.Accumulator(this._areasum)).Add(i.S12),o.area=a(s,this._area0,this._crossings+r(this.lon,this._lon0),e,t),o)},e.PolygonArea.prototype.TestPoint=function(e,t,i,n){var s,a,l,c,h={number:this.num+1};if(0===this.num)return h.perimeter=0,this.polyline||(h.area=0),h;for(h.perimeter=this._perimetersum.Sum(),a=this.polyline?0:this._areasum.Sum(),l=this._crossings,c=0;c<(this.polyline?1:2);++c)s=this._geod.Inverse(0===c?this.lat:e,0===c?this.lon:t,0!==c?this._lat0:e,0!==c?this._lon0:t,this._mask),h.perimeter+=s.s12,this.polyline||(a+=s.S12,l+=r(0===c?this.lon:t,0!==c?this._lon0:t));return this.polyline||(h.area=o(a,this._area0,l,i,n)),h},e.PolygonArea.prototype.TestEdge=function(e,t,i,n){var a,l,c,h={number:this.num?this.num+1:0};return 0===this.num||(h.perimeter=this._perimetersum.Sum()+t,this.polyline||(l=this._areasum.Sum(),c=this._crossings,l+=(a=this._geod.Direct(this.lat,this.lon,e,t,this._mask)).S12,c+=s(this.lon,a.lon2),c+=r(a.lon2,this._lon0),a=this._geod.Inverse(a.lat2,a.lon2,this._lat0,this._lon0,this._mask),h.perimeter+=a.s12,l+=a.S12,h.area=o(l,this._area0,c,i,n))),h}}(r.PolygonArea,r.Geodesic,r.Math,r.Accumulator),t(r)),Pr.exports;var e,t,i,n,r}var Br=Rr();function Dr(){this.sin_p12=Math.sin(this.lat0),this.cos_p12=Math.cos(this.lat0),this.g=new Br.Geodesic.Geodesic(this.a,this.es/(1+Math.sqrt(1-this.es)))}function Fr(e){var t,i,n,r,s,a,o,l,c,u,d,p,g,_,A,v=e.x,y=e.y,x=Math.sin(e.y),b=Math.cos(e.y),S=ge(v-this.long0);return this.sphere?Math.abs(this.sin_p12-1)<=m?(e.x=this.x0+this.a*(h-y)*Math.sin(S),e.y=this.y0-this.a*(h-y)*Math.cos(S),e):Math.abs(this.sin_p12+1)<=m?(e.x=this.x0+this.a*(h+y)*Math.sin(S),e.y=this.y0+this.a*(h+y)*Math.cos(S),e):(c=this.sin_p12*x+this.cos_p12*b*Math.cos(S),l=(o=Math.acos(c))?o/Math.sin(o):1,e.x=this.x0+this.a*l*b*Math.sin(S),e.y=this.y0+this.a*l*(this.cos_p12*x-this.sin_p12*b*Math.cos(S)),e):(t=hn(this.es),i=un(this.es),n=dn(this.es),r=pn(this.es),Math.abs(this.sin_p12-1)<=m?(s=this.a*cn(t,i,n,r,h),a=this.a*cn(t,i,n,r,y),e.x=this.x0+(s-a)*Math.sin(S),e.y=this.y0-(s-a)*Math.cos(S),e):Math.abs(this.sin_p12+1)<=m?(s=this.a*cn(t,i,n,r,h),a=this.a*cn(t,i,n,r,y),e.x=this.x0+(s+a)*Math.sin(S),e.y=this.y0+(s+a)*Math.cos(S),e):Math.abs(v)<m&&Math.abs(y-this.lat0)<m?(e.x=e.y=0,e):(u=this.lat0/f,d=this.long0/f,p=y/f,g=v/f,A=(_=this.g.Inverse(u,d,p,g,this.g.AZIMUTH)).azi1*f,e.x=_.s12*Math.sin(A),e.y=_.s12*Math.cos(A),e))}function Or(e){var t,i,n,r,s,a,o,l,c,u,d,p,g,_,A,v,y;if(e.x-=this.x0,e.y-=this.y0,this.sphere){if((t=Math.sqrt(e.x*e.x+e.y*e.y))>2*h*this.a)return;return i=t/this.a,n=Math.sin(i),r=Math.cos(i),s=this.long0,Math.abs(t)<=m?a=this.lat0:(a=Fn(r*this.sin_p12+e.y*n*this.cos_p12/t),o=Math.abs(this.lat0)-h,s=Math.abs(o)<=m?this.lat0>=0?ge(this.long0+Math.atan2(e.x,-e.y)):ge(this.long0-Math.atan2(-e.x,e.y)):ge(this.long0+Math.atan2(e.x*n,t*this.cos_p12*r-e.y*this.sin_p12*n))),e.x=s,e.y=a,e}return l=hn(this.es),c=un(this.es),u=dn(this.es),d=pn(this.es),Math.abs(this.sin_p12-1)<=m?(a=gn(((p=this.a*cn(l,c,u,d,h))-(t=Math.sqrt(e.x*e.x+e.y*e.y)))/this.a,l,c,u,d),s=ge(this.long0+Math.atan2(e.x,-1*e.y)),e.x=s,e.y=a,e):Math.abs(this.sin_p12+1)<=m?(p=this.a*cn(l,c,u,d,h),a=gn(((t=Math.sqrt(e.x*e.x+e.y*e.y))-p)/this.a,l,c,u,d),s=ge(this.long0+Math.atan2(e.x,e.y)),e.x=s,e.y=a,e):(g=this.lat0/f,_=this.long0/f,A=Math.atan2(e.x,e.y)/f,v=Math.sqrt(e.x*e.x+e.y*e.y),y=this.g.Direct(g,_,A,v,this.g.STANDARD),e.x=y.lon2*f,e.y=y.lat2*f,e)}var Lr={init:Dr,forward:Fr,inverse:Or,names:["Azimuthal_Equidistant","aeqd"]};function Nr(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0)}function Vr(e){var t,i,n,r,s,a,o,l,c=e.x,h=e.y;return n=ge(c-this.long0),t=Math.sin(h),i=Math.cos(h),r=Math.cos(n),s=1,((a=this.sin_p14*t+this.cos_p14*i*r)>0||Math.abs(a)<=m)&&(o=this.a*s*i*Math.sin(n),l=this.y0+this.a*s*(this.cos_p14*t-this.sin_p14*i*r)),e.x=o,e.y=l,e}function Ur(e){var t,i,n,r,s,a,o;return e.x-=this.x0,e.y-=this.y0,i=Fn((t=Math.sqrt(e.x*e.x+e.y*e.y))/this.a),n=Math.sin(i),r=Math.cos(i),a=this.long0,Math.abs(t)<=m?(o=this.lat0,e.x=a,e.y=o,e):(o=Fn(r*this.sin_p14+e.y*n*this.cos_p14/t),s=Math.abs(this.lat0)-h,Math.abs(s)<=m?(a=this.lat0>=0?ge(this.long0+Math.atan2(e.x,-e.y)):ge(this.long0-Math.atan2(-e.x,e.y)),e.x=a,e.y=o,e):(a=ge(this.long0+Math.atan2(e.x*n,t*this.cos_p14*r-e.y*this.sin_p14*n)),e.x=a,e.y=o,e))}var kr={init:Nr,forward:Vr,inverse:Ur,names:["ortho"]},Gr={FRONT:1,RIGHT:2,BACK:3,LEFT:4,TOP:5,BOTTOM:6},zr={AREA_0:1,AREA_1:2,AREA_2:3,AREA_3:4};function jr(){this.x0=this.x0||0,this.y0=this.y0||0,this.lat0=this.lat0||0,this.long0=this.long0||0,this.lat_ts=this.lat_ts||0,this.title=this.title||"Quadrilateralized Spherical Cube",this.lat0>=h-_/2?this.face=Gr.TOP:this.lat0<=-(h-_/2)?this.face=Gr.BOTTOM:Math.abs(this.long0)<=_?this.face=Gr.FRONT:Math.abs(this.long0)<=h+_?this.face=this.long0>0?Gr.RIGHT:Gr.LEFT:this.face=Gr.BACK,0!==this.es&&(this.one_minus_f=1-(this.a-this.b)/this.a,this.one_minus_f_squared=this.one_minus_f*this.one_minus_f)}function Qr(e){var t,i,n,r,s,a,o={x:0,y:0},l={value:0};if(e.x-=this.long0,t=0!==this.es?Math.atan(this.one_minus_f_squared*Math.tan(e.y)):e.y,i=e.x,this.face===Gr.TOP)r=h-t,i>=_&&i<=h+_?(l.value=zr.AREA_0,n=i-h):i>h+_||i<=-(h+_)?(l.value=zr.AREA_1,n=i>0?i-v:i+v):i>-(h+_)&&i<=-_?(l.value=zr.AREA_2,n=i+h):(l.value=zr.AREA_3,n=i);else if(this.face===Gr.BOTTOM)r=h+t,i>=_&&i<=h+_?(l.value=zr.AREA_0,n=-i+h):i<_&&i>=-_?(l.value=zr.AREA_1,n=-i):i<-_&&i>=-(h+_)?(l.value=zr.AREA_2,n=-i-h):(l.value=zr.AREA_3,n=i>0?-i+v:-i-v);else{var c,u,d,p,m,f;this.face===Gr.RIGHT?i=Wr(i,+h):this.face===Gr.BACK?i=Wr(i,3.14159265359):this.face===Gr.LEFT&&(i=Wr(i,-h)),p=Math.sin(t),m=Math.cos(t),f=Math.sin(i),c=m*Math.cos(i),u=m*f,d=p,this.face===Gr.FRONT?n=$r(r=Math.acos(c),d,u,l):this.face===Gr.RIGHT?n=$r(r=Math.acos(u),d,-c,l):this.face===Gr.BACK?n=$r(r=Math.acos(-c),d,-u,l):this.face===Gr.LEFT?n=$r(r=Math.acos(-u),d,c,l):(r=n=0,l.value=zr.AREA_0)}return a=Math.atan(12/v*(n+Math.acos(Math.sin(n)*Math.cos(_))-h)),s=Math.sqrt((1-Math.cos(r))/(Math.cos(a)*Math.cos(a))/(1-Math.cos(Math.atan(1/Math.cos(n))))),l.value===zr.AREA_1?a+=h:l.value===zr.AREA_2?a+=v:l.value===zr.AREA_3&&(a+=1.5*v),o.x=s*Math.cos(a),o.y=s*Math.sin(a),o.x=o.x*this.a+this.x0,o.y=o.y*this.a+this.y0,e.x=o.x,e.y=o.y,e}function Hr(e){var t,i,n,r,s,a,o,l,c,u,d,p,m={lam:0,phi:0},f={value:0};if(e.x=(e.x-this.x0)/this.a,e.y=(e.y-this.y0)/this.a,i=Math.atan(Math.sqrt(e.x*e.x+e.y*e.y)),t=Math.atan2(e.y,e.x),e.x>=0&&e.x>=Math.abs(e.y)?f.value=zr.AREA_0:e.y>=0&&e.y>=Math.abs(e.x)?(f.value=zr.AREA_1,t-=h):e.x<0&&-e.x>=Math.abs(e.y)?(f.value=zr.AREA_2,t=t<0?t+v:t-v):(f.value=zr.AREA_3,t+=h),c=v/12*Math.tan(t),s=Math.sin(c)/(Math.cos(c)-1/Math.sqrt(2)),a=Math.atan(s),(o=1-(n=Math.cos(t))*n*(r=Math.tan(i))*r*(1-Math.cos(Math.atan(1/Math.cos(a)))))<-1?o=-1:o>1&&(o=1),this.face===Gr.TOP)l=Math.acos(o),m.phi=h-l,f.value===zr.AREA_0?m.lam=a+h:f.value===zr.AREA_1?m.lam=a<0?a+v:a-v:f.value===zr.AREA_2?m.lam=a-h:m.lam=a;else if(this.face===Gr.BOTTOM)l=Math.acos(o),m.phi=l-h,f.value===zr.AREA_0?m.lam=-a+h:f.value===zr.AREA_1?m.lam=-a:f.value===zr.AREA_2?m.lam=-a-h:m.lam=a<0?-a-v:-a+v;else{var g,_,A;c=(g=o)*g,_=(c+=(A=c>=1?0:Math.sqrt(1-c)*Math.sin(a))*A)>=1?0:Math.sqrt(1-c),f.value===zr.AREA_1?(c=_,_=-A,A=c):f.value===zr.AREA_2?(_=-_,A=-A):f.value===zr.AREA_3&&(c=_,_=A,A=-c),this.face===Gr.RIGHT?(c=g,g=-_,_=c):this.face===Gr.BACK?(g=-g,_=-_):this.face===Gr.LEFT&&(c=g,g=_,_=-c),m.phi=Math.acos(-A)-h,m.lam=Math.atan2(_,g),this.face===Gr.RIGHT?m.lam=Wr(m.lam,-h):this.face===Gr.BACK?m.lam=Wr(m.lam,-3.14159265359):this.face===Gr.LEFT&&(m.lam=Wr(m.lam,+h))}return 0!==this.es&&(u=m.phi<0?1:0,d=Math.tan(m.phi),p=this.b/Math.sqrt(d*d+this.one_minus_f_squared),m.phi=Math.atan(Math.sqrt(this.a*this.a-p*p)/(this.one_minus_f*p)),u&&(m.phi=-m.phi)),m.lam+=this.long0,e.x=m.lam,e.y=m.phi,e}function $r(e,t,i,n){var r;return e<m?(n.value=zr.AREA_0,r=0):(r=Math.atan2(t,i),Math.abs(r)<=_?n.value=zr.AREA_0:r>_&&r<=h+_?(n.value=zr.AREA_1,r-=h):r>h+_||r<=-(h+_)?(n.value=zr.AREA_2,r=r>=0?r-v:r+v):(n.value=zr.AREA_3,r+=h)),r}function Wr(e,t){var i=e+t;return i<-3.14159265359?i+=A:i>3.14159265359&&(i-=A),i}var qr={init:jr,forward:Qr,inverse:Hr,names:["Quadrilateralized Spherical Cube","Quadrilateralized_Spherical_Cube","qsc"]},Yr=[[1,22199e-21,-715515e-10,31103e-10],[.9986,-482243e-9,-24897e-9,-13309e-10],[.9954,-83103e-8,-448605e-10,-9.86701e-7],[.99,-.00135364,-59661e-9,36777e-10],[.9822,-.00167442,-449547e-11,-572411e-11],[.973,-.00214868,-903571e-10,1.8736e-8],[.96,-.00305085,-900761e-10,164917e-11],[.9427,-.00382792,-653386e-10,-26154e-10],[.9216,-.00467746,-10457e-8,481243e-11],[.8962,-.00536223,-323831e-10,-543432e-11],[.8679,-.00609363,-113898e-9,332484e-11],[.835,-.00698325,-640253e-10,9.34959e-7],[.7986,-.00755338,-500009e-10,9.35324e-7],[.7597,-.00798324,-35971e-9,-227626e-11],[.7186,-.00851367,-701149e-10,-86303e-10],[.6732,-.00986209,-199569e-9,191974e-10],[.6213,-.010418,883923e-10,624051e-11],[.5722,-.00906601,182e-6,624051e-11],[.5322,-.00677797,275608e-9,624051e-11]],Xr=[[-520417e-23,.0124,121431e-23,-845284e-16],[.062,.0124,-1.26793e-9,4.22642e-10],[.124,.0124,5.07171e-9,-1.60604e-9],[.186,.0123999,-1.90189e-8,6.00152e-9],[.248,.0124002,7.10039e-8,-2.24e-8],[.31,.0123992,-2.64997e-7,8.35986e-8],[.372,.0124029,9.88983e-7,-3.11994e-7],[.434,.0123893,-369093e-11,-4.35621e-7],[.4958,.0123198,-102252e-10,-3.45523e-7],[.5571,.0121916,-154081e-10,-5.82288e-7],[.6176,.0119938,-241424e-10,-5.25327e-7],[.6769,.011713,-320223e-10,-5.16405e-7],[.7346,.0113541,-397684e-10,-6.09052e-7],[.7903,.0109107,-489042e-10,-104739e-11],[.8435,.0103431,-64615e-9,-1.40374e-9],[.8936,.00969686,-64636e-9,-8547e-9],[.9394,.00840947,-192841e-9,-42106e-10],[.9761,.00616527,-256e-6,-42106e-10],[1,.00328947,-319159e-9,-42106e-10]],Zr=.8487,Kr=1.3523,Jr=g/5,es=1/Jr,ts=18,is=function(e,t){return e[0]+t*(e[1]+t*(e[2]+t*e[3]))},ns=function(e,t){return e[1]+t*(2*e[2]+3*t*e[3])};function rs(e,t,i,n){for(var r=t;n;--n){var s=e(r);if(r-=s,Math.abs(s)<i)break}return r}function ss(){this.x0=this.x0||0,this.y0=this.y0||0,this.long0=this.long0||0,this.es=0,this.title=this.title||"Robinson"}function as(e){var t=ge(e.x-this.long0),i=Math.abs(e.y),n=Math.floor(i*Jr);n<0?n=0:n>=ts&&(n=ts-1),i=g*(i-es*n);var r={x:is(Yr[n],i)*t,y:is(Xr[n],i)};return e.y<0&&(r.y=-r.y),r.x=r.x*this.a*Zr+this.x0,r.y=r.y*this.a*Kr+this.y0,r}function os(e){var t={x:(e.x-this.x0)/(this.a*Zr),y:Math.abs(e.y-this.y0)/(this.a*Kr)};if(t.y>=1)t.x/=Yr[ts][0],t.y=e.y<0?-h:h;else{var i=Math.floor(t.y*ts);for(i<0?i=0:i>=ts&&(i=ts-1);;)if(Xr[i][0]>t.y)--i;else{if(!(Xr[i+1][0]<=t.y))break;++i}var n=Xr[i],r=5*(t.y-n[0])/(Xr[i+1][0]-n[0]);r=rs((function(e){return(is(n,e)-t.y)/ns(n,e)}),r,m,100),t.x/=is(Yr[i],r),t.y=(5*i+r)*f,e.y<0&&(t.y=-t.y)}return t.x=ge(t.x+this.long0),t}var ls={init:ss,forward:as,inverse:os,names:["Robinson","robin"]};function cs(){this.name="geocent"}function hs(e){return nt(e,this.es,this.a)}function us(e){return rt(e,this.es,this.a,this.b)}var ds={init:cs,forward:hs,inverse:us,names:["Geocentric","geocentric","geocent","Geocent"]},ps={N_POLE:0,S_POLE:1,EQUIT:2,OBLIQ:3},ms={h:{def:1e5,num:!0},azi:{def:0,num:!0,degrees:!0},tilt:{def:0,num:!0,degrees:!0},long0:{def:0,num:!0},lat0:{def:0,num:!0}};function fs(){if(Object.keys(ms).forEach(function(e){if(void 0===this[e])this[e]=ms[e].def;else{if(ms[e].num&&isNaN(this[e]))throw new Error("Invalid parameter value, must be numeric "+e+" = "+this[e]);ms[e].num&&(this[e]=parseFloat(this[e]))}ms[e].degrees&&(this[e]=this[e]*f)}.bind(this)),Math.abs(Math.abs(this.lat0)-h)<m?this.mode=this.lat0<0?ps.S_POLE:ps.N_POLE:Math.abs(this.lat0)<m?this.mode=ps.EQUIT:(this.mode=ps.OBLIQ,this.sinph0=Math.sin(this.lat0),this.cosph0=Math.cos(this.lat0)),this.pn1=this.h/this.a,this.pn1<=0||this.pn1>1e10)throw new Error("Invalid height");this.p=1+this.pn1,this.rp=1/this.p,this.h1=1/this.pn1,this.pfact=(this.p+1)*this.h1,this.es=0;var e=this.tilt,t=this.azi;this.cg=Math.cos(t),this.sg=Math.sin(t),this.cw=Math.cos(e),this.sw=Math.sin(e)}function gs(e){e.x-=this.long0;var t,i,n,r,s=Math.sin(e.y),a=Math.cos(e.y),o=Math.cos(e.x);switch(this.mode){case ps.OBLIQ:i=this.sinph0*s+this.cosph0*a*o;break;case ps.EQUIT:i=a*o;break;case ps.S_POLE:i=-s;break;case ps.N_POLE:i=s}switch(t=(i=this.pn1/(this.p-i))*a*Math.sin(e.x),this.mode){case ps.OBLIQ:i*=this.cosph0*s-this.sinph0*a*o;break;case ps.EQUIT:i*=s;break;case ps.N_POLE:i*=-a*o;break;case ps.S_POLE:i*=a*o}return r=1/((n=i*this.cg+t*this.sg)*this.sw*this.h1+this.cw),t=(t*this.cg-i*this.sg)*this.cw*r,i=n*r,e.x=t*this.a,e.y=i*this.a,e}function _s(e){e.x/=this.a,e.y/=this.a;var t,i,n,r={x:e.x,y:e.y};n=1/(this.pn1-e.y*this.sw),t=this.pn1*e.x*n,i=this.pn1*e.y*this.cw*n,e.x=t*this.cg+i*this.sg,e.y=i*this.cg-t*this.sg;var s=fi(e.x,e.y);if(Math.abs(s)<m)r.x=0,r.y=e.y;else{var a,o;switch(o=1-s*s*this.pfact,o=(this.p-Math.sqrt(o))/(this.pn1/s+s/this.pn1),a=Math.sqrt(1-o*o),this.mode){case ps.OBLIQ:r.y=Math.asin(a*this.sinph0+e.y*o*this.cosph0/s),e.y=(a-this.sinph0*Math.sin(r.y))*s,e.x*=o*this.cosph0;break;case ps.EQUIT:r.y=Math.asin(e.y*o/s),e.y=a*s,e.x*=o;break;case ps.N_POLE:r.y=Math.asin(a),e.y=-e.y;break;case ps.S_POLE:r.y=-Math.asin(a)}r.x=Math.atan2(e.x,e.y)}return e.x=r.x+this.long0,e.y=r.y,e}var As={init:fs,forward:gs,inverse:_s,names:["Tilted_Perspective","tpers"]};function vs(){if(this.flip_axis="x"===this.sweep?1:0,this.h=Number(this.h),this.radius_g_1=this.h/this.a,this.radius_g_1<=0||this.radius_g_1>1e10)throw new Error;if(this.radius_g=1+this.radius_g_1,this.C=this.radius_g*this.radius_g-1,0!==this.es){var e=1-this.es,t=1/e;this.radius_p=Math.sqrt(e),this.radius_p2=e,this.radius_p_inv2=t,this.shape="ellipse"}else this.radius_p=1,this.radius_p2=1,this.radius_p_inv2=1,this.shape="sphere";this.title||(this.title="Geostationary Satellite View")}function ys(e){var t,i,n,r,s=e.x,a=e.y;if(s-=this.long0,"ellipse"===this.shape){a=Math.atan(this.radius_p2*Math.tan(a));var o=this.radius_p/fi(this.radius_p*Math.cos(a),Math.sin(a));if(i=o*Math.cos(s)*Math.cos(a),n=o*Math.sin(s)*Math.cos(a),r=o*Math.sin(a),(this.radius_g-i)*i-n*n-r*r*this.radius_p_inv2<0)return e.x=Number.NaN,e.y=Number.NaN,e;t=this.radius_g-i,this.flip_axis?(e.x=this.radius_g_1*Math.atan(n/fi(r,t)),e.y=this.radius_g_1*Math.atan(r/t)):(e.x=this.radius_g_1*Math.atan(n/t),e.y=this.radius_g_1*Math.atan(r/fi(n,t)))}else"sphere"===this.shape&&(t=Math.cos(a),i=Math.cos(s)*t,n=Math.sin(s)*t,r=Math.sin(a),t=this.radius_g-i,this.flip_axis?(e.x=this.radius_g_1*Math.atan(n/fi(r,t)),e.y=this.radius_g_1*Math.atan(r/t)):(e.x=this.radius_g_1*Math.atan(n/t),e.y=this.radius_g_1*Math.atan(r/fi(n,t))));return e.x=e.x*this.a,e.y=e.y*this.a,e}function xs(e){var t,i,n,r,s=-1,a=0,o=0;if(e.x=e.x/this.a,e.y=e.y/this.a,"ellipse"===this.shape){this.flip_axis?(o=Math.tan(e.y/this.radius_g_1),a=Math.tan(e.x/this.radius_g_1)*fi(1,o)):(a=Math.tan(e.x/this.radius_g_1),o=Math.tan(e.y/this.radius_g_1)*fi(1,a));var l=o/this.radius_p;if(t=a*a+l*l+s*s,(n=(i=2*this.radius_g*s)*i-4*t*this.C)<0)return e.x=Number.NaN,e.y=Number.NaN,e;r=(-i-Math.sqrt(n))/(2*t),s=this.radius_g+r*s,a*=r,o*=r,e.x=Math.atan2(a,s),e.y=Math.atan(o*Math.cos(e.x)/s),e.y=Math.atan(this.radius_p_inv2*Math.tan(e.y))}else if("sphere"===this.shape){if(this.flip_axis?(o=Math.tan(e.y/this.radius_g_1),a=Math.tan(e.x/this.radius_g_1)*Math.sqrt(1+o*o)):(a=Math.tan(e.x/this.radius_g_1),o=Math.tan(e.y/this.radius_g_1)*Math.sqrt(1+a*a)),t=a*a+o*o+s*s,(n=(i=2*this.radius_g*s)*i-4*t*this.C)<0)return e.x=Number.NaN,e.y=Number.NaN,e;r=(-i-Math.sqrt(n))/(2*t),s=this.radius_g+r*s,a*=r,o*=r,e.x=Math.atan2(a,s),e.y=Math.atan(o*Math.cos(e.x)/s)}return e.x=e.x+this.long0,e}var bs={init:vs,forward:ys,inverse:xs,names:["Geostationary Satellite View","Geostationary_Satellite","geos"]},Ss=1.340264,Cs=-.081106,Ts=893e-6,Es=.003796,Ms=Math.sqrt(3)/2;function ws(){this.es=0,this.long0=void 0!==this.long0?this.long0:0}function Is(e){var t=ge(e.x-this.long0),i=e.y,n=Math.asin(Ms*Math.sin(i)),r=n*n,s=r*r*r;return e.x=t*Math.cos(n)/(Ms*(Ss+3*Cs*r+s*(7*Ts+9*Es*r))),e.y=n*(Ss+Cs*r+s*(Ts+Es*r)),e.x=this.a*e.x+this.x0,e.y=this.a*e.y+this.y0,e}function Ps(e){e.x=(e.x-this.x0)/this.a,e.y=(e.y-this.y0)/this.a;var t,i,n,r,s=1e-9,a=12,o=e.y;for(r=0;r<a&&(o-=n=(o*(Ss+Cs*(t=o*o)+(i=t*t*t)*(Ts+Es*t))-e.y)/(Ss+3*Cs*t+i*(7*Ts+9*Es*t)),!(Math.abs(n)<s));++r);return i=(t=o*o)*t*t,e.x=Ms*e.x*(Ss+3*Cs*t+i*(7*Ts+9*Es*t))/Math.cos(o),e.y=Math.asin(Math.sin(o)/Ms),e.x=ge(e.x+this.long0),e}var Rs={init:ws,forward:Is,inverse:Ps,names:["eqearth","Equal Earth","Equal_Earth"]},Bs=1e-10;function Ds(){var e;if(this.phi1=this.lat1,Math.abs(this.phi1)<Bs)throw new Error;this.es?(this.en=ai(this.es),this.m1=oi(this.phi1,this.am1=Math.sin(this.phi1),e=Math.cos(this.phi1),this.en),this.am1=e/(Math.sqrt(1-this.es*this.am1*this.am1)*this.am1),this.inverse=Os,this.forward=Fs):(Math.abs(this.phi1)+Bs>=h?this.cphi1=0:this.cphi1=1/Math.tan(this.phi1),this.inverse=Ns,this.forward=Ls)}function Fs(e){var t,i,n,r=ge(e.x-(this.long0||0)),s=e.y;return t=this.am1+this.m1-oi(s,i=Math.sin(s),n=Math.cos(s),this.en),i=n*r/(t*Math.sqrt(1-this.es*i*i)),e.x=t*Math.sin(i),e.y=this.am1-t*Math.cos(i),e.x=this.a*e.x+(this.x0||0),e.y=this.a*e.y+(this.y0||0),e}function Os(e){var t,i,n,r;if(e.x=(e.x-(this.x0||0))/this.a,e.y=(e.y-(this.y0||0))/this.a,i=fi(e.x,e.y=this.am1-e.y),r=ci(this.am1+this.m1-i,this.es,this.en),(t=Math.abs(r))<h)t=Math.sin(r),n=i*Math.atan2(e.x,e.y)*Math.sqrt(1-this.es*t*t)/Math.cos(r);else{if(!(Math.abs(t-h)<=Bs))throw new Error;n=0}return e.x=ge(n+(this.long0||0)),e.y=fn(r),e}function Ls(e){var t,i,n=ge(e.x-(this.long0||0)),r=e.y;return i=this.cphi1+this.phi1-r,Math.abs(i)>Bs?(e.x=i*Math.sin(t=n*Math.cos(r)/i),e.y=this.cphi1-i*Math.cos(t)):e.x=e.y=0,e.x=this.a*e.x+(this.x0||0),e.y=this.a*e.y+(this.y0||0),e}function Ns(e){var t,i;e.x=(e.x-(this.x0||0))/this.a,e.y=(e.y-(this.y0||0))/this.a;var n=fi(e.x,e.y=this.cphi1-e.y);if(i=this.cphi1+this.phi1-n,Math.abs(i)>h)throw new Error;return t=Math.abs(Math.abs(i)-h)<=Bs?0:n*Math.atan2(e.x,e.y)/Math.cos(i),e.x=ge(t+(this.long0||0)),e.y=fn(i),e}var Vs={init:Ds,names:["bonne","Bonne (Werner lat_1=90)"]};function Us(e){e.Proj.projections.add(pi),e.Proj.projections.add(Ti),e.Proj.projections.add(wi),e.Proj.projections.add(Vi),e.Proj.projections.add(ji),e.Proj.projections.add(Wi),e.Proj.projections.add(Ji),e.Proj.projections.add(rn),e.Proj.projections.add(ln),e.Proj.projections.add(yn),e.Proj.projections.add(Dn),e.Proj.projections.add(Un),e.Proj.projections.add(jn),e.Proj.projections.add(qn),e.Proj.projections.add(Kn),e.Proj.projections.add(nr),e.Proj.projections.add(or),e.Proj.projections.add(ur),e.Proj.projections.add(gr),e.Proj.projections.add(yr),e.Proj.projections.add(Cr),e.Proj.projections.add(Ir),e.Proj.projections.add(Lr),e.Proj.projections.add(kr),e.Proj.projections.add(qr),e.Proj.projections.add(ls),e.Proj.projections.add(ds),e.Proj.projections.add(As),e.Proj.projections.add(bs),e.Proj.projections.add(Rs),e.Proj.projections.add(Vs)}return xt.defaultDatum="WGS84",xt.Proj=tt,xt.WGS84=new xt.Proj("WGS84"),xt.Point=Wt,xt.toPoint=pt,xt.defs=re,xt.nadgrid=Ge,xt.transform=_t,xt.mgrs=Pt,xt.version="2.17.0",Us(xt),xt}()}(proj4Src);const proj4=proj4Src.exports;let globalId$1=1;const _inputArray=new Array(2);class GenericDefinedProjection extends Projection{constructor(e,t,i){super(),e||(e="custom_"+globalId$1++),this._name=e,this._parameters=t,proj4.defs(this._name)||proj4.defs(this._name,t),i&&i.isBox3&&(this._geoBoundingBox=i)}projectCoordinate(e,t,i){_inputArray[0]=e.x,_inputArray[1]=e.y;const n=this.geoBoundingBox;_inputArray[0]<n.min.x&&(_inputArray[0]=n.min.x),_inputArray[0]>n.max.x&&(_inputArray[0]=n.max.x),_inputArray[1]<n.min.y&&(_inputArray[1]=n.min.y),_inputArray[1]>n.max.y&&(_inputArray[1]=n.max.y);const r=proj4("EPSG:4326",this.name,_inputArray);if(t||(t=new three.Vector3),i){const i=this.projectedBoundingBox;t.x=extendProjectCoordinate(e.x,r[0],n.max.x,i.max.x),t.y=extendProjectCoordinate(e.y,r[1],n.max.y,i.max.y)}else t.x=r[0],t.y=r[1];return t.z=e.z,t}unprojectCoordinate(e,t,i){const n=this.projectedBoundingBox;_inputArray[0]=e.x,_inputArray[1]=e.y,_inputArray[0]<n.min.x&&(_inputArray[0]=n.min.x),_inputArray[0]>n.max.x&&(_inputArray[0]=n.max.x),_inputArray[1]<n.min.y&&(_inputArray[1]=n.min.y),_inputArray[1]>n.max.y&&(_inputArray[1]=n.max.y);const r=proj4(this.name,"EPSG:4326",_inputArray);if(t||(t=new three.Vector3),i){const i=this.geoBoundingBox;t.x=extendUnprojectCoordinate(e.x,r[0],i.max.x,n.max.x),t.y=extendUnprojectCoordinate(e.y,r[1],i.max.y,n.max.y)}else t.x=r[0],t.y=r[1];return t.z=e.z,t}get name(){return this._name}}const _cache={},projectionDefs={"EPSG:5070":{parameters:"+proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs",projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,geoBoundingBox:[[-172.54,23.81,0],[-47.74,86.46,0]]},"EPSG:8857":{parameters:"+proj=eqearth +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs",projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR}};for(let r=1;r<=60;r++){let e=6*(r-1)-180,t=6*r-180;e-=12,t+=12,e<-180&&(e=-180),t>180&&(t=180),projectionDefs[`EPSG:${32600+r}`]={projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,geoBoundingBox:[[e,-80,0],[t,84,0]]},projectionDefs[`EPSG:${32700+r}`]={projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,geoBoundingBox:[[e,-80,0],[t,84,0]]}}for(let r=0;r<11;r++){let e=r+13,t=6*e-3,i=1e6*e+5e5;projectionDefs[`EPSG:${4491+r}`]={parameters:`+proj=tmerc +lat_0=0 +lon_0=${t} +k=1 +x_0=${i} +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,geoBoundingBox:[[t-3,3,0],[t+3,54,0]]},projectionDefs[`EPSG:${4502+r}`]={parameters:`+proj=tmerc +lat_0=0 +lon_0=${t} +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,geoBoundingBox:[[t-3,3,0],[t+3,54,0]]},e=25+2*r,t=3*e,i=1e6*e+5e5,projectionDefs["EPSG:"+(4513+2*r)]={parameters:`+proj=tmerc +lat_0=0 +lon_0=${t} +k=1 +x_0=${i} +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,geoBoundingBox:[[t-1.5,3,0],[t+1.5,54,0]]},projectionDefs["EPSG:"+(4534+2*r)]={parameters:`+proj=tmerc +lat_0=0 +lon_0=${t} +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,geoBoundingBox:[[t-1.5,3,0],[t+1.5,54,0]]},e=25+2*r+1,r<10&&(t=3*e,i=1e6*e+5e5,projectionDefs["EPSG:"+(4513+2*r+1)]={parameters:`+proj=tmerc +lat_0=0 +lon_0=${t} +k=1 +x_0=${i} +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,geoBoundingBox:[[t-1.5,3,0],[t+1.5,54,0]]},projectionDefs["EPSG:"+(4534+2*r+1)]={parameters:`+proj=tmerc +lat_0=0 +lon_0=${t} +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs +type=crs`,projectBoundingBoxMethod:projectBoundingBoxMethods.FOUR_CORNERS_WITH_EQUATOR,geoBoundingBox:[[t-1.5,3,0],[t+1.5,54,0]]})}const normalizeProjectionName=e=>"EPSG:900913"===(e=e.toUpperCase().trim())?PROJECTION_WEB_MERCATOR:"GLOBE"===e||"ECEF"===e?PROJECTION_ECEF:e,getProjection=e=>{if(e=normalizeProjectionName(e),!_cache[e])switch(e){case PROJECTION_WEB_MERCATOR:_cache[e]=new WebMercatorProjection;break;case PROJECTION_ECEF:_cache[e]=new ECEFProjection;break;case PROJECTION_BD_MERCATOR:_cache[e]=new BaiduMercatorProjection;break;case PROJECTION_GEO:_cache[e]=new GeoProjection;break;case PROJECTION_SCREEN_PIXEL:_cache[e]=new ScreenPixelProjection;break;default:let t=null;if(projectionDefs[e]){const i=projectionDefs[e];let n=null;if(i.geoBoundingBox){const e=i.geoBoundingBox;n=new three.Box3(new three.Vector3(e[0][0],e[0][1],e[0][2]||0),new three.Vector3(e[1][0],e[1][1],e[1][2]||0))}t=new GenericDefinedProjection(e,i.parameters,n),i.projectBoundingBoxMethod&&(t.projectBoundingBoxMethod=i.projectBoundingBoxMethod)}if(!t)throw new Error(`Unsupported projection: ${e}`);_cache[e]=t}return _cache[e]},_CoordTransformer=class{static _cacheKey(e,t){return`${e}->${t}`}static _clearPathCache(){_CoordTransformer._pathCache.clear()}static _findTransformPath(e,t,i=new Set){const n=_CoordTransformer._cacheKey(e,t);if(_CoordTransformer._pathCache.has(n))return _CoordTransformer._pathCache.get(n);if(i.has(e))return _CoordTransformer._pathCache.set(n,null),null;if(i.add(e),_CoordTransformer._registeredTransformers[e]&&_CoordTransformer._registeredTransformers[e][t]){const i=[e,t];return _CoordTransformer._pathCache.set(n,i),i}if(_CoordTransformer._registeredTransformers[e])for(const r of Object.keys(_CoordTransformer._registeredTransformers[e])){const s=_CoordTransformer._findTransformPath(r,t,new Set(i));if(s){const t=[e,...s];return _CoordTransformer._pathCache.set(n,t),t}}return _CoordTransformer._pathCache.set(n,null),null}static transform(e,t,i,n){if(e===t)return n.copy(i),n;const r=_CoordTransformer._findTransformPath(e,t);if(!r)return n.copy(i),n;let s=i;for(let a=0;a<r.length-1;a++){const e=r[a],t=r[a+1];s=_CoordTransformer._registeredTransformers[e][t](s,n)}return s}static register(e,t,i){_CoordTransformer._registeredTransformers[e]||(_CoordTransformer._registeredTransformers[e]={}),_CoordTransformer._registeredTransformers[e][t]=i,_CoordTransformer._clearPathCache()}static unregister(e,t){_CoordTransformer._registeredTransformers[e]&&(delete _CoordTransformer._registeredTransformers[e][t],_CoordTransformer._clearPathCache())}static canTransform(e,t){if(e===t)return!1;return null!==_CoordTransformer._findTransformPath(e,t)}static serialize(){const e={};for(const t of Object.keys(_CoordTransformer._registeredTransformers)){e[t]={};for(const i of Object.keys(_CoordTransformer._registeredTransformers[t]))e[t][i]=_CoordTransformer._registeredTransformers[t][i].toString()}return JSON.stringify(e)}static deserialize(json){const result=JSON.parse(json);for(const srcCoord of Object.keys(result))for(const targetCoord of Object.keys(result[srcCoord]))_CoordTransformer.register(srcCoord,targetCoord,eval(result[srcCoord][targetCoord]))}};let CoordTransformer=_CoordTransformer;__publicField(CoordTransformer,"_registeredTransformers",{}),__publicField(CoordTransformer,"_pathCache",new Map);const _inputVector3=new three.Vector3,_outputVector3=new three.Vector3,fixCoordiates=(e,t)=>{if(e)if(0===t)void 0===e[2]&&(e[2]=0);else for(const i of e)fixCoordiates(i,t-1)};function getGeoFeatures(e,t){if(!e)return[];let i=null;return t&&projectGeoJSON(e,t),i=e.features?e.features:Array.isArray(e)?e:[e],i}function projectGeoJSON(e,t){if(e)if("FeatureCollection"===e.type||e.features){const i=e.features;for(const e of i)projectGeoJSON(e,t)}else if(Array.isArray(e)){const i=e;for(const e of i)projectGeoJSON(e,t)}else if("Feature"===e.type||e.geometry){if(!e.geometry)return;if(Array.isArray(e.geometry.coordinates)){if(e.geometry[t.name])return;fixFeature(e);const i=projectArrayCoordinates(e.geometry.coordinates,t);e.geometry[t.name]=i}}}function projectArrayCoordinates(e,t){if(Array.isArray(e[0])){const i=[];for(let n of e)i.push(projectArrayCoordinates(n,t));return i}if("number"==typeof e[0]||"string"==typeof e[0])return _inputVector3.set(e[0],e[1],e[2]||0),t.projectCoordinate(_inputVector3,_outputVector3),[_outputVector3.x,_outputVector3.y,_outputVector3.z]}function unprojectArrayCoordinates(e,t){if(Array.isArray(e[0])){const i=[];for(let n of e)i.push(unprojectArrayCoordinates(n,t));return i}if("number"==typeof e[0]||"string"==typeof e[0])return _inputVector3.set(e[0],e[1],e[2]||0),t.unprojectCoordinate(_inputVector3,_outputVector3),[_outputVector3.x,_outputVector3.y,_outputVector3.z]}function transformArrayCoordinates(e,t,i){if(Array.isArray(e[0])){const n=[];for(let r of e)n.push(transformArrayCoordinates(r,t,i));return n}if("number"==typeof e[0]||"string"==typeof e[0])return _inputVector3.set(e[0],e[1],e[2]||0),CoordTransformer.transform(t,i,_inputVector3,_outputVector3),[_outputVector3.x,_outputVector3.y,_outputVector3.z]}function fixFeature(e){e.type||(e.type="Feature");const t=e.geometry.type,i={Point:0,MultiPoint:1,LineString:1,MultiLineString:2,Polygon:2,MultiPolygon:3};return Object.keys(i).includes(t)&&fixCoordiates(e.geometry.coordinates,i[t]),e}function multiPointToPoints(e,t){if(!e.geometry)return[];if("Point"===e.geometry.type)return[e];if("MultiPoint"===e.geometry.type||"LineString"===e.geometry.type){const i=[],{type:n,geometry:r,...s}=e;for(let a=0;a<e.geometry.coordinates.length;a++){const n=e.geometry.coordinates[a];if(t){const r=e.geometry[t][a];i.push({type:"Feature",geometry:{type:"Point",coordinates:n,[t]:r},...s})}else i.push({type:"Feature",geometry:{type:"Point",coordinates:n},...s})}return i}return[]}function multiLineStringToLineStrings(e,t){if(!e.geometry)return[];if("LineString"===e.geometry.type)return[e];if("MultiLineString"===e.geometry.type||"Polygon"===e.geometry.type){const i=[],{type:n,geometry:r,...s}=e;for(let a=0;a<e.geometry.coordinates.length;a++){const n=e.geometry.coordinates[a];if(t){const r=e.geometry[t][a];i.push({type:"Feature",geometry:{type:"LineString",coordinates:n,[t]:r},...s})}else i.push({type:"Feature",geometry:{type:"LineString",coordinates:n},...s})}return i}return[]}function multiPolygonToPolygons(e,t){if(!e.geometry)return[];if("Polygon"===e.geometry.type)return[e];if("MultiPolygon"===e.geometry.type){const i=[],{type:n,geometry:r,...s}=e;for(let a=0;a<e.geometry.coordinates.length;a++){const n=e.geometry.coordinates[a];if(t){const r=e.geometry[t][a];i.push({type:"Feature",geometry:{type:"Polygon",coordinates:n,[t]:r},...s})}else i.push({type:"Feature",geometry:{type:"Polygon",coordinates:n},...s})}return i}return[]}function convertLineString2Points(e){let t=this.getGeoFeatures(e),i=[];for(let n=0;n<t.length;n++){const e=t[n],r=this.multiLineStringToLineStrings(e);for(let t=0;t<r.length;t++){const e=r[t],n=this.multiPointToPoints(e);i.push(...n)}}return i}function convertPolygon2LineString(e){let t=this.getGeoFeatures(e),i=[];for(let n=0;n<t.length;n++){const e=t[n],r=this.multiPolygonToPolygons(e);for(let t=0;t<r.length;t++){const e=r[t],n=this.multiLineStringToLineStrings(e);i.push(...n)}}return i}function coordEach(e,t,i){if(null===e)return;let n,r,s,a,o,l,c,h,u=0,d=0,p=e.type,m="FeatureCollection"===p,f="Feature"===p,g=m?e.features.length:1;for(let _=0;_<g;_++){c=m?e.features[_].geometry:f?e.geometry:e,h=!!c&&"GeometryCollection"===c.type,o=h?c.geometries.length:1;for(let e=0;e<o;e++){let o=0,p=0;if(a=h?c.geometries[e]:c,null===a)continue;l=a.coordinates;let m=a.type;switch(u=!i||"Polygon"!==m&&"MultiPolygon"!==m?0:1,m){case null:break;case"Point":if(!1===t(l,d,_,o,p))return!1;d++,o++;break;case"LineString":case"MultiPoint":for(n=0;n<l.length;n++){if(!1===t(l[n],d,_,o,p))return!1;d++,"MultiPoint"===m&&o++}"LineString"===m&&o++;break;case"Polygon":case"MultiLineString":for(n=0;n<l.length;n++){for(r=0;r<l[n].length-u;r++){if(!1===t(l[n][r],d,_,o,p))return!1;d++}"MultiLineString"===m&&o++,"Polygon"===m&&p++}"Polygon"===m&&o++;break;case"MultiPolygon":for(n=0;n<l.length;n++){for(p=0,r=0;r<l[n].length;r++){for(s=0;s<l[n][r].length-u;s++){if(!1===t(l[n][r][s],d,_,o,p))return!1;d++}p++}o++}break;case"GeometryCollection":for(n=0;n<a.geometries.length;n++)if(!1===coordEach(a.geometries[n],t,i))return!1;break;default:throw new Error("Unknown Geometry Type")}}}}function geomEach(e,t){let i,n,r,s,a,o,l,c,h,u,d=0,p="FeatureCollection"===e.type,m="Feature"===e.type,f=p?e.features.length:1;for(i=0;i<f;i++){for(o=p?e.features[i].geometry:m?e.geometry:e,c=p?e.features[i].properties:m?e.properties:{},h=p?e.features[i].bbox:m?e.bbox:void 0,u=p?e.features[i].id:m?e.id:void 0,l=!!o&&"GeometryCollection"===o.type,a=l?o.geometries.length:1,r=0;r<a;r++)if(s=l?o.geometries[r]:o,null!==s)switch(s.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":if(!1===t(s,d,c,h,u))return!1;break;case"GeometryCollection":for(n=0;n<s.geometries.length;n++)if(!1===t(s.geometries[n],d,c,h,u))return!1;break;default:throw new Error("Unknown Geometry Type")}else if(!1===t(null,d,c,h,u))return!1;d++}}function featureEach(e,t){if("Feature"===e.type)t(e,0);else if("FeatureCollection"===e.type)for(let i=0;i<e.features.length&&!1!==t(e.features[i],i);i++);}function geomReduce(e,t,i){let n=i;return geomEach(e,(function(e,r,s,a,o){n=0===r&&void 0===i?e:t(n,e,r,s,a,o)})),n}function getbbox(e,t={}){if(null!=e.bbox&&!0!==t.recompute)return e.bbox;const i=[1/0,1/0,-1/0,-1/0];return coordEach(e,(e=>{i[0]>e[0]&&(i[0]=e[0]),i[1]>e[1]&&(i[1]=e[1]),i[2]<e[0]&&(i[2]=e[0]),i[3]<e[1]&&(i[3]=e[1])})),i}function getCoord(e){if(Array.isArray(e))return e;if("Feature"===e.type){if(null!==e.geometry)return e.geometry.coordinates}else if(e.coordinates)return e.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function getGeom(e){return"Feature"===e.type?e.geometry:e}function inBBox(e,t){return t[0]<=e[0]&&t[1]<=e[1]&&t[2]>=e[0]&&t[3]>=e[1]}function pointInPolygon(e,t){let i=0,n=0,r=0,s=0,a=0,o=0,l=0,c=0,h=null,u=null;const d=e[0],p=e[1],m=t.length;for(;i<m;i++){n=0;const m=t[i].length-1,f=t[i];if(h=f[0],h[0]!==f[m][0]&&h[1]!==f[m][1])throw new Error("First and last coordinates in a ring must be the same");for(a=h[0]-d,o=h[1]-p;n<m;n++)if(u=f[n+1],c=u[1]-p,o<0&&c<0||o>0&&c>0)h=u,o=c,a=h[0]-d;else{if(l=u[0]-e[0],c>0&&o<=0){if(s=a*c-l*o,s>0)r+=1;else if(0===s)return 0}else if(o>0&&c<=0){if(s=a*c-l*o,s<0)r+=1;else if(0===s)return 0}else if(0===c&&o<0){if(s=a*c-l*o,0===s)return 0}else if(0===o&&c<0){if(s=a*c-l*o,0===s)return 0}else if(0===o&&0===c){if(l<=0&&a>=0)return 0;if(a<=0&&l>=0)return 0}h=u,o=c,a=l}}return r%2!=0}function booleanPointInPolygon(e,t,i={}){if(!e)throw new Error("point is required");if(!t)throw new Error("polygon is required");const n=getCoord(e),r=getGeom(t),s=r.type,a=t.bbox;let o=r.coordinates;if(a&&!1===inBBox(n,a))return!1;"Polygon"===s&&(o=[o]);let l=!1;for(let c=0;c<o.length;++c){const e=pointInPolygon(n,o[c]);if(0===e)return!i.ignoreBoundary;e&&(l=!0)}return l}function feature(e,t,i={}){const n={type:"Feature"};return(0===i.id||i.id)&&(n.id=i.id),i.bbox&&(n.bbox=i.bbox),n.properties=t||{},n.geometry=e,n}function featureCollection(e,t={}){const i={type:"FeatureCollection"};return t.id&&(i.id=t.id),t.bbox&&(i.bbox=t.bbox),i.features=e,i}function coordToPoint(e,t,i={}){if(!e)throw new Error("coordinates is required");if(!Array.isArray(e))throw new Error("coordinates must be an Array");if(e.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!isNumber(e[0])||!isNumber(e[1]))throw new Error("coordinates must contain numbers");return feature({type:"Point",coordinates:e},t,i)}function coordToLineString(e,t,i={}){if(!e)throw new Error("coordinates is required");if(!Array.isArray(e))throw new Error("coordinates must be an Array");return feature({type:"LineString",coordinates:e},t,i)}function coordToPolygon(e,t,i={}){for(const n of e){if(n.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(n[n.length-1].length!==n[0].length)throw new Error("First and last Position are not equivalent.");for(let e=0;e<n[n.length-1].length;e++)if(n[n.length-1][e]!==n[0][e])throw new Error("First and last Position are not equivalent.")}return feature({type:"Polygon",coordinates:e},t,i)}function computeGeoJSONArea(e){return geomReduce(e,((e,t)=>e+calculateArea(t)),0)}function calculateArea(e){let t,i=0;switch(e.type){case"Polygon":return polygonArea(e.coordinates);case"MultiPolygon":for(t=0;t<e.coordinates.length;t++)i+=polygonArea(e.coordinates[t]);return i;case"Point":case"MultiPoint":case"LineString":case"MultiLineString":return 0}return 0}function polygonArea(e){let t=0;if(e&&e.length>0){t+=Math.abs(ringArea(e[0]));for(let i=1;i<e.length;i++)t-=Math.abs(ringArea(e[i]))}return t}function ringArea(e){let t,i,n,r,s,a,o,l=0;const c=e.length;if(c>2){for(o=0;o<c;o++)o===c-2?(r=c-2,s=c-1,a=0):o===c-1?(r=c-1,s=0,a=1):(r=o,s=o+1,a=o+2),t=e[r],i=e[s],n=e[a],l+=(MercatorProjection.toRadians(n[0])-MercatorProjection.toRadians(t[0]))*Math.sin(MercatorProjection.toRadians(i[1]));l=6371008.8*l*6371008.8/2}return l}function getcenter(e,t={}){const i=getbbox(e);return coordToPoint([(i[0]+i[2])/2,(i[1]+i[3])/2],t.properties,t)}function isLngLatArrValid(e){return e[0]>=-180&&e[0]<=180&&e[1]>=-90&&e[1]<=90}const geojsonUtils=Object.freeze(Object.defineProperty({__proto__:null,getGeoFeatures:getGeoFeatures,projectArrayCoordinates:projectArrayCoordinates,unprojectArrayCoordinates:unprojectArrayCoordinates,transformArrayCoordinates:transformArrayCoordinates,fixFeature:fixFeature,multiPointToPoints:multiPointToPoints,multiLineStringToLineStrings:multiLineStringToLineStrings,multiPolygonToPolygons:multiPolygonToPolygons,convertLineString2Points:convertLineString2Points,convertPolygon2LineString:convertPolygon2LineString,coordEach:coordEach,geomEach:geomEach,featureEach:featureEach,geomReduce:geomReduce,getbbox:getbbox,getCoord:getCoord,getGeom:getGeom,inBBox:inBBox,booleanPointInPolygon:booleanPointInPolygon,feature:feature,featureCollection:featureCollection,coordToPoint:coordToPoint,coordToLineString:coordToLineString,coordToPolygon:coordToPolygon,computeGeoJSONArea:computeGeoJSONArea,getcenter:getcenter,isLngLatArrValid:isLngLatArrValid},Symbol.toStringTag,{value:"Module"})),getCRSName=function(e){return"string"==typeof e?e:"object"==typeof e?e.properties.name:null};class DataItem{constructor(e,t={},i=!1){__publicField(this,"_originalCoordinates"),__publicField(this,"_attributes"),__publicField(this,"_id"),__publicField(this,"_sourceProjectionName"),__publicField(this,"_coordinates"),__publicField(this,"_projectedCoordinates",{}),__publicField(this,"_type"),__publicField(this,"_isMulti",!1),__publicField(this,"_size",1),__publicField(this,"_isValid",!0),e||(console.warn("DataItem: feature is required"),this._isValid=!1);let n=null,r={};if(Array.isArray(e))this._type=GEOMETRY_TYPE_POINT,this._originalCoordinates=e;else if(e.isVector3)this._type=GEOMETRY_TYPE_POINT,this._originalCoordinates=[e.x,e.y,e.z];else if("object"==typeof e){const t=e.geometry;if(t){const e=(t.type||"").toUpperCase();"POINT"===e?this._type=GEOMETRY_TYPE_POINT:"LINESTRING"===e?this._type=GEOMETRY_TYPE_LINE:"POLYGON"===e?this._type=GEOMETRY_TYPE_POLYGON:"MULTIPOINT"===e?(this._type=GEOMETRY_TYPE_POINT,this._isMulti=!0,this._size=t.coordinates.length):"MULTILINESTRING"===e?(this._type=GEOMETRY_TYPE_LINE,this._isMulti=!0,this._size=t.coordinates.length):"MULTIPOLYGON"===e?(this._type=GEOMETRY_TYPE_POLYGON,this._isMulti=!0,this._size=t.coordinates.length):(this._isValid=!1,console.warn("DataItem: geometry is invalid")),this._originalCoordinates=t.coordinates}else console.warn("DataItem: geometry is required"),this._isValid=!1;e.crs&&(n=getCRSName(e.crs)),e.properties&&Object.assign(r,e.properties)}else console.warn("DataItem: feature is invalid");Object.assign(r,t),this._attributes=r,void 0!==r.id&&(this._id=r.id),!n&&r.crs&&(n=getCRSName(r.crs)),this._sourceProjectionName=n,!n||n===PROJECTION_GEO&&!i?this._coordinates=this._originalCoordinates:this._projectedCoordinates[n]=this._originalCoordinates}_getTransformedCoordinates(e,t){if(!this._transformedCoordinates){const i=this.coordinates;e&&t&&CoordTransformer.canTransform(e,t)?this._transformedCoordinates=transformArrayCoordinates(i,e,t):this._transformedCoordinates=i}return this._transformedCoordinates}getProjectedCoordinates(e,t=0,i,n){return this._projectedCoordinates[e.name]||(this._projectedCoordinates[e.name]=projectArrayCoordinates(this._getTransformedCoordinates(i,n),e)),this._isMulti?this._projectedCoordinates[e.name][t]:this._projectedCoordinates[e.name]}toGeoJSON(){let e="Point";return this._type===GEOMETRY_TYPE_LINE?e="LineString":this._type===GEOMETRY_TYPE_POLYGON&&(e="Polygon"),this._isMulti&&(e="Multi"+e),{type:"Feature",geometry:{type:e,coordinates:this.coordinates},properties:this._attributes}}setCoordinates(e,t){this._coordinates=null,this._projectedCoordinates={},this._isMulti&&(this._size=e.length),t?(this._sourceProjectionName=t.name,this._originalCoordinates=e,this._projectedCoordinates[t.name]=e):this._coordinates=e}setAttribute(e,t){this._attributes[e]=t}setAttributes(e){Object.assign(this._attributes,e)}get attributes(){return this._attributes}get id(){return this._id}set id(e){void 0===this._id?this._id=e:console.warn("DataItem: id is already set")}get coordinates(){if(!this._coordinates){const e=getProjection(this._sourceProjectionName);this._coordinates=unprojectArrayCoordinates(this._originalCoordinates,e)}return this._coordinates}get sourceProjectionName(){return this._sourceProjectionName}get type(){return this._type}get isMulti(){return this._isMulti}get size(){return this._size}get isValid(){return this._isValid}}const OPERATION_ADD=1,OPERATION_REMOVE=2,OPERATION_LOAD=4;class DataSource{constructor(e={}){__publicField(this,"_generatedIdIndex",1),__publicField(this,"_objects",[]),__publicField(this,"_data",{}),__publicField(this,"_userData",[]),__publicField(this,"_userDataNeedsUpdate",!1),__publicField(this,"_dataItems",[]),__publicField(this,"_attributeMap",new Map),__publicField(this,"_needsUpdate",!0),__publicField(this,"_idIndexMap",{}),__publicField(this,"_indexIdMap",{}),__publicField(this,"_queuedData",[]),__publicField(this,"_isCurve",!1),__publicField(this,"_filter",null),__publicField(this,"_sourceCoordType"),__publicField(this,"_targetCoordType"),this._options=e,this._sourceCoordType=e.coordType||void 0,this._id=e.id||(new Date).valueOf(),e.attributes&&this.defineAttributes(e.attributes)}async load(e){if(e&&"string"==typeof e){try{const t=await fetch(e),i=await this._convertStreamingDataToObjectData(t);this._queuedData.push({operation:OPERATION_LOAD,data:i}),this.needsUpdate=!0}catch(t){console.error("load data error",t)}return this}console.warn("url is required")}async _convertStreamingDataToObjectData(e){console.error("please implement _convertStreamingDataToObjectData method")}_parseObjectDataToDataItems(e){console.error("please implement _parseObjectDataToDataItems method")}defineAttribute(e,t){return t?this._attributeMap.set(e,t):this._attributeMap.set(e,e),this.needsUpdate=!0,this}setAttribute(e,t){return console.warn("setAttribute is deprecated, please use defineAttribute instead."),this.defineAttribute(e,t)}defineAttributes(e){let t=Object.keys(e);for(let i=0;i<t.length;i++){const n=t[i];this._attributeMap.set(n,e[n])}return this.needsUpdate=!0,this}setAttributes(e){return console.warn("setAttributes is deprecated, please use defineAttributes instead."),this.defineAttributes(e)}undefineAttribute(e){return this._attributeMap.delete(e),this.needsUpdate=!0,this}removeAttribute(e){return console.warn("removeAttribute is deprecated, please use undefineAttribute instead."),this.undefineAttribute(e)}undefineAllAttributes(){return this._attributeMap.clear(),this.needsUpdate=!0,this}removeAttributes(){return console.warn("removeAttributes is deprecated, please use undefineAllAttributes instead."),this.undefineAllAttributes()}add(e){return this._queuedData.push({operation:OPERATION_ADD,data:Array.isArray(e)?e:[e]}),this.needsUpdate=!0,this}remove(e){return this._queuedData.push({operation:OPERATION_REMOVE,data:Array.isArray(e)?e:[e]}),this.needsUpdate=!0,this}setAttributeValue(e,t,i){return this.setAttributeValues(e,{[t]:i})}setAttributeValues(e,t){Array.isArray(e)||(e=[e]);for(let i=0;i<e.length;i++){const n=e[i],r=this._idIndexMap[n];void 0!==r&&this._dataItems[r].setAttributes(t)}return this.needsUpdate=!0,this}setCoordinates(e,t,i){Array.isArray(e)||(e=[e]);for(let n=0;n<e.length;n++){const r=e[n],s=this._idIndexMap[r];void 0!==s&&this._dataItems[s].setCoordinates(t,i)}return this.needsUpdate=!0,this}get(e){let t={};if(this.data.position&&this.data.position.length&&void 0!==e&&!(e>=this.data.position.length)){for(const i in this.data)if(Object.hasOwnProperty.call(this.data,i)){const n=this.data[i];t[i]=n[e]}return t}}getDataItemIndex(e){return this.data.index[e]}getDataItem(e){const t=this.getDataItemIndex(e);if(void 0!==t)return this._dataItems[t]}exportToGeoJSON(){let e=[];for(let t=0;t<this._dataItems.length;t++){const i=this._dataItems[t];e.push(i.toGeoJSON())}return{type:"FeatureCollection",features:e}}_executeAddData(e){for(let t=0;t<e.length;t++){const i=e[t];if(this._filter instanceof Function&&!this._filter(i,t))continue;i.id||(i.id="_gid_"+this._generatedIdIndex++);const n=i.id;if(void 0!==this._idIndexMap[n])continue;const r=this._dataItems.length;this._indexIdMap[r]=n,this._idIndexMap[n]=r,this._dataItems.push(i)}}_executeRemoveData(e){for(let t=0;t<e.length;t++){const i=e[t];let n;if(n=i instanceof DataItem||"[object Object]"===Array.prototype.toString.call(i)?i.id:i,void 0!==n){const e=this._idIndexMap[n];if(void 0===e)return void console.warn("remove fail1",e,n);const t=this._dataItems.length-1;if(e>t)return void console.warn("remove fail2",e,n);if(e<t){const i=this._indexIdMap[t];this._dataItems[e]=this._dataItems[t],this._indexIdMap[e]=i,this._idIndexMap[i]=e}delete this._idIndexMap[n],delete this._indexIdMap[t],this._dataItems.length=this._dataItems.length-1}}}_processData(e){this._templateDataLength=e.index.length;let t=null,i=0;for(let n=0;n<this._dataItems.length;n++)if(t=this._dataItems[n],t.isValid){i=t.isMulti?t.size:1;for(let r=0;r<i;r++){const i=t.getProjectedCoordinates(this.projection,r,this._sourceCoordType,this._targetCoordType);e.position.push(i),e.index.push(n);for(const s of this._attributeMap.keys()){let i;const a=this._attributeMap.get(s);t.attributes&&void 0!==t.attributes[a]&&null!==t.attributes[a]?i=t.attributes[a]:a instanceof Function&&(i=a(t.attributes,t,r,n)),e[s].push(i)}}}}update(){if(this.isDirectBuffer)return void(this.needsUpdate=!1);const e=this._queuedData.length;if(e>0)for(let i=0;i<e;i++){const e=this._queuedData.shift();if(e.operation===OPERATION_LOAD){const t=this._parseObjectDataToDataItems(e.data);this._executeAddData(t)}else e.operation===OPERATION_ADD?this._executeAddData(e.data):e.operation===OPERATION_REMOVE&&this._executeRemoveData(e.data)}let t={position:[],index:[]};for(const i of this._attributeMap.keys())t[i]=[];this._processData(t,[]),this._data=t,this._userDataNeedsUpdate=!0,this.needsUpdate=!1}setData(e){this.clear(),this._queuedData.push({operation:OPERATION_LOAD,data:e}),this.needsUpdate=!0}clear(){this._data={},this._userData=[],this._queuedData=[],this._dataItems=[],this.needsUpdate=!0,this._idIndexMap={},this._indexIdMap={},this.onClear()}setFilter(e){this._filter=e,this.needsUpdate=!0}onClear(){}_formatGeometry(e){return e?Array.isArray(e)?{type:"Point",coordinates:e}:e.isVector3?{type:"Point",coordinates:[e.x,e.y,e.z]}:e:null}dispose(){this.clear()}get dataItems(){return this._dataItems}get size(){return this.needsUpdate&&this.update(),this.data&&this.data.position&&this.data.position.length||0}get data(){return this._data}get userData(){if(!this._userDataNeedsUpdate)return this._userData;if(!this._data||!this._data.position||!this._data.position.length)return[];const e=[];let t=null;for(let i=0,n=this._data.position.length;i<n;i++){const n={position:this._data.position[i],index:this._data.index[i]};for(const e of this._attributeMap.keys())t=this._data[e]&&this._data[e][i],n[e]=t;e.push(n)}return this._userData=e,this._userDataNeedsUpdate=!1,this._userData}get needsUpdate(){return this._needsUpdate}set needsUpdate(e){this._needsUpdate=e}get objects(){return this._objects}set objects(e){this._objects=e}set targetCoordType(e){this._targetCoordType=e,this._sourceCoordType&&this._targetCoordType&&!CoordTransformer.canTransform(this._sourceCoordType,this._targetCoordType)&&console.warn(`DataSource: ${this._sourceCoordType} to ${this._targetCoordType} is not supported`)}get sourceCoordType(){return this._sourceCoordType}get targetCoordType(){return this._targetCoordType}}class ThreeObject extends three.Object3D{constructor(e){super(),__publicField(this,"_enableRtc",!0),__publicField(this,"_cachedRtc",[0,0,0]),__publicField(this,"makeMeshPositionOffset",(e=>{this._cachedRtc=[e[0],e[1],e[2]||0],this.updateTransform()})),__publicField(this,"makeGeometryOffsetPosition",((e,t,i)=>{if(!this._enableRtc)return;const n=e.boundingSphere&&e.boundingSphere.center;if(!n)return this._cachedRtc=[0,0,0],void this.updateTransform();const{x:r,y:s,z:a}=n;e.isCustomInstancedBufferGeometry?this.makePostionArrayOffset(e.attributes.instancedPosition.array,r,s,a,t,i):(this.makePostionArrayOffset(e.attributes.position.array,r,s,a,t,i),e.attributes.position.array.length),e.computeBoundingSphere(),this._cachedRtc=[r,s,a],this.updateTransform()})),__publicField(this,"makePostionArrayOffset",((e,t,i,n,r,s)=>{if(!e||e.length<3)return;const a="number"==typeof s?Math.min(s,e.length):e.length;let o=r||e;for(let l=0;l<a-2;l+=3)e[l]=o[l]-t,e[l+1]=o[l+1]-i,e[l+2]=o[l+2]-n})),__publicField(this,"updateTransform",(()=>{const[e,t,i]=this._cachedRtc;this.position.set(e,t,i),this.updateMatrixWorld(!0)})),Object.defineProperties(this,{enableRtc:{get:function(){return this._enableRtc},set:function(e){this._enableRtc=e}}})}defineGeometryProxyProperties(e=[]){for(let t=0;t<e.length;t++){const i=e[t];Object.defineProperty(this,i,{get:function(){return this.geometry[i]},set:function(e){this.geometry[i]=e}})}}defineGeometryUpdateProxyProperties(e=[]){for(let t=0;t<e.length;t++){const i=e[t];Object.defineProperty(this,i,{get:function(){return this.geometry[i]},set:function(e){this.geometry[i]=e,this.needsUpdate=!0}})}}defineMaterialProxyProperties(e=[]){for(let t=0;t<e.length;t++){const i=e[t];Object.defineProperty(this,i,{get:function(){return this.material[i]},set:function(e){this.material[i]=e}})}}defineMaterialUpdateProxyProperties(e=[]){for(let t=0;t<e.length;t++){const i=e[t];Object.defineProperty(this,i,{get:function(){return this.material[i]},set:function(e){this.material[i]=e,this.material.needsUpdate=!0}})}}defineMaterialColorProxyProperties(e=[]){for(let t=0;t<e.length;t++){const i=e[t];Object.defineProperty(this,i,{get:function(){return this.material[i]},set:function(e){this.material[i]=normalizeColor(e)}})}}raycast(e,t){this.visible&&super.raycast(e,t)}}class GeoObject extends ThreeObject{constructor(){super(...arguments),__publicField(this,"isGeoObject",!0),__publicField(this,"dataAutoUpdate",!0),__publicField(this,"_parameters"),__publicField(this,"_dataSource"),__publicField(this,"_dataSourceUpdated"),__publicField(this,"_needsUpdate"),__publicField(this,"_zooms",[0,100]),__publicField(this,"_zoomVisibleCache"),__publicField(this,"engine"),__publicField(this,"_attributeRenameMap",{}),__publicField(this,"travelFeatureLineCoordinate",((e,t,i)=>{const n=e.geometry;if(!n||!n[t]||!n.type)return;const r=n[t];if("LineString"===n.type)i&&i(r);else if("MultiLineString"===n.type||"Polygon"===n.type)for(let s of r)i&&i(s);else if("MultiPolygon"===n.type)for(let s of r)for(let e of s)i&&i(e)})),__publicField(this,"travelLineCoordinates",((e,t="coordinates",i,n=0)=>{if(Array.isArray(e)&&i)for(let r=0,s=e.length;r<s;r++){const s=e[r],a=n+r,o=s.geometry;if(!o||!o[t]||!o.type)continue;const l=o[t];if("LineString"===o.type)i&&i(l,s,a);else if("MultiLineString"===o.type||"Polygon"===o.type)for(let e of l)i&&i(e,s,a);else if("MultiPolygon"===o.type)for(let e of l)for(let t of e)i&&i(t,s,a)}})),__publicField(this,"travelPolygonCoordinates",((e,t="coordinates",i,n=0)=>{if(Array.isArray(e)&&i)for(let r=0,s=e.length;r<s;r++){const s=e[r],a=n+r,o=s.geometry;if(!o||!o[t]||!o.type)continue;const l=o[t];if("Polygon"===o.type)i&&i(l,s,a);else if("MultiPolygon"===o.type)for(let e of l)i&&i(e,s,a);else if("LineString"===o.type)i&&i([l],s,a);else if("MultiLineString"===o.type)for(let e of l)i&&i([e],s,a)}})),__publicField(this,"travelPointCoordinates",((e,t="coordinates",i,n=0)=>{if(Array.isArray(e)&&i)for(let r=0,s=e.length;r<s;r++){const s=e[r],a=n+r,o=s.geometry;if(!o||!o[t]||!o.type)continue;const l=o[t];"Point"===o.type&&i&&i(l,s,a)}})),__publicField(this,"getPointsBounding",((e,t="coordinates")=>{let i=1/0,n=1/0,r=1/0,s=-1/0,a=-1/0,o=-1/0;return this.travelPointCoordinates(e,t,(e=>{const[t,l,c=0]=e;t<i&&(i=t),t>s&&(s=t),l<n&&(n=l),l>a&&(a=l),c<r&&(r=c),c>o&&(o=c)})),isFinite(i)||(i=0),isFinite(s)||(s=0),isFinite(n)||(n=0),isFinite(a)||(a=0),isFinite(r)||(r=0),isFinite(o)||(o=0),[i,n,r,s,a,o]}))}get parameters(){return this._parameters}set parameters(e){this._parameters?this._parameters={...this._parameters,...e}:this._parameters={...this.getDefaultParams(),...e}}get dataSource(){return 0===Object.keys(this._attributeRenameMap).length?this._dataSource:(this._proxyDataSource&&!this._proxyDataSourceNeedsUpdate||(this._proxyDataSource=this._createProxyDataSource(),this._proxyDataSourceNeedsUpdate=!1),this._proxyDataSource)}set dataSource(e){this.setDataSource(e)}get needsUpdate(){return this._needsUpdate}set needsUpdate(e){this._needsUpdate=e}get zooms(){return this._zooms}set zooms(e){this._zooms=e}get inZoomsRange(){const e=this.engine;return!!e&&(e.map.getZoom()>=this.zooms[0]&&e.map.getZoom()<=this.zooms[1])}_createProxyDataSource(){return new Proxy(this._dataSource,{get:(e,t)=>"data"===t?this._createMappedObjectProxy(e.data):"userData"===t?this._createLazyMappedArrayProxy(e.userData):Reflect.get(e,t)})}_createMappedObjectProxy(e){return new Proxy(e,{get:(e,t)=>e[this._attributeRenameMap[t]||t],set:(e,t,i)=>(e[this._attributeRenameMap[t]||t]=i,console.warn("property of dataSource should not be set by user in Proxy",t),!0)})}_createLazyMappedArrayProxy(e){return new Proxy(e,{get:(e,t)=>{const i=Reflect.get(e,t);return"string"==typeof t&&/^\d+$/.test(t)?this._createMappedObjectProxy(i):i},set:(e,t,i)=>(console.warn("property of dataSource should not be set by user in Proxy",t),Reflect.set(e,t,i))})}addAttributeRename(e,t){this._attributeRenameMap[e]=t,this._proxyDataSourceNeedsUpdate=!0}removeAttributeRename(e){delete this._attributeRenameMap[e],this._proxyDataSourceNeedsUpdate=!0}clearAttributeRename(){this._attributeRenameMap={},this._proxyDataSourceNeedsUpdate=!0}afterAddToEngine(e){this.engine=e,this.initObject();const t=e.map.isGlobe;this.material&&(this.material.isGlobe=t),this.isInstancedMesh&&this.material&&(this.material.defines?this.material.defines.IS_INSTANCE=!0:this.material.defines={IS_INSTANCE:!0})}beforeRemoveFromEngine(e){this.dispose()}initObject(){}getDefaultParams(){return{}}getEntityByIndex(e){const t=this.dataSource;if(!t)return;const i={index:e,value:t.getDataItem(e),itemIndex:t.getDataItemIndex(e),pairs:{}},n=t.data;for(const r of Object.keys(n))i.pairs[r]=n[r][e];return i}setDataSource(e){if(e)e.objects.indexOf(this)>-1||(this._dataSource=e,e.targetCoordType=this.engine.map.coordType,e.projection=this.engine.map.projection,e.objects.push(this),this.needsUpdate=!0,this.engine.requestRender());else if(this._dataSource){const e=this._dataSource.objects.indexOf(this);e>-1&&this._dataSource.objects.splice(e,1),this._dataSource=null,this.needsUpdate=!0,this.engine.requestRender()}}onBeforeScenePrepareRender(e,t,i,n){this.dataSource&&(this.dataSource.needsUpdate&&(this.dataSource.update(),this.needsUpdate=!0),this.dataAutoUpdate&&this.needsUpdate&&this._enableCollision&&(e.rendering.collision.needsUpdate=!0),this.onBeforeScenePrepareRenderHook&&this.onBeforeScenePrepareRenderHook(e,t,i,n),this.visible&&!this.inZoomsRange?(this._zoomVisibleCache=this.visible,this.visible=!1):!this.visible&&this._zoomVisibleCache&&this.inZoomsRange&&(this.visible=this._zoomVisibleCache,this._zoomVisibleCache=void 0))}onBeforeSceneRender(e,t,i,n){this.dataSource&&(this.dataAutoUpdate&&this.needsUpdate&&!this._enableCollision||this.dataAutoUpdate&&this.isGroundPrimitive&&this.isDynamic?this._updateData():this.dataAutoUpdate&&this._collisionUpdated?(this._updateData(),this._collisionUpdated=!1):this.geometry&&this.geometry.needsUpdate&&this.geometry.updateGeometry&&(this.geometry.updateGeometry(),this.afterGeometryUpdate&&this.afterGeometryUpdate()),this.onBeforeSceneRenderHook&&this.onBeforeSceneRenderHook(e,t,i,n))}_updateData(){}collisionTest(e){return{}}onDispose(){}dispose(){if(this.geometry&&this.geometry.dispose(),this.material)if(Array.isArray(this.material))for(let e=0;e<this.material.length;e++){this.material[e].dispose()}else this.material.dispose();this.onDispose()}bindTerrain(e){this._terrain=e}}class GeoMesh extends GeoObject{constructor(){super(...arguments),__publicField(this,"isMesh",!0)}}const _offset$1=new three.Vector3,_box$3=new three.Box3,_boxMorphTargets=new three.Box3,_vector$6=new three.Vector3;class SymbolGeometry extends three.BufferGeometry{constructor(e){super(e),this.parameters=e,this._drawRange=0,this._init=!1}setData(e){if(this._init)return void this.updateData(e);const{positions:t,indices:i,typesAndPIndices:n,uvs:r,whs:s,rotateZs:a,offsets:o,instanceRotationMatrices:l,styles:c,drawRange:h,fadeOpacityAndSince:u,stretch:d}=e;r.length>0&&this.setAttribute("uv",new three.Float32BufferAttribute(r,2)),a.length>0&&this.setAttribute("rotateZ",new three.Float32BufferAttribute(a,1)),o.length>0&&this.setAttribute("offset",new three.Float32BufferAttribute(o,2)),l.length>0&&this.setAttribute("instanceRotationMatrix",new three.Float32BufferAttribute(l,9)),u.length>0&&this.setAttribute("fadeOpacityAndSince",new three.Float32BufferAttribute(u,2)),this.setAttribute("whAndSize",new three.Float32BufferAttribute(s,3)),this.setAttribute("stretch",new three.Float32BufferAttribute(d,4));const p=new three.InterleavedBuffer(c,9);this.setAttribute("fillStyles",new three.InterleavedBufferAttribute(p,4,0)),this.setAttribute("strokeStyles",new three.InterleavedBufferAttribute(p,4,4)),this.setAttribute("strokeWidth",new three.InterleavedBufferAttribute(p,1,8)),this.setAttribute("position",new three.Float32BufferAttribute(t,3));const m=new three.InterleavedBuffer(n,2);this.setAttribute("pIndex",new three.InterleavedBufferAttribute(m,1,1)),this.setAttribute("type",new three.InterleavedBufferAttribute(m,1,0)),this.setIndex(i),this._drawRange=h,this._init=!0}updateData(e){const{positions:t,uvs:i,whs:n,rotateZs:r,offsets:s,instanceRotationMatrices:a,styles:o,typesAndPIndices:l,indices:c,drawRange:h,fadeOpacityAndSince:u,stretch:d}=e,p=h/3,m=this.getAttribute("position");for(let M=0;M<p;M++)m.setXYZ(M,t[3*M],t[3*M+1],t[3*M+2]);m.needsUpdate=!0;const f=this.getAttribute("uv");if(f)for(let M=0;M<p;M++)f.setXY(M,i[2*M],i[2*M+1]);f.needsUpdate=!0;const g=this.getAttribute("rotateZ");if(g)for(let M=0;M<p;M++)g.setX(M,r[M]);g.needsUpdate=!0;const _=this.getAttribute("offset");if(_)for(let M=0;M<p;M++)_.setXYZW(M,s[2*M],s[2*M+1]);_.needsUpdate=!0;const A=this.getAttribute("fadeOpacityAndSince");if(A)for(let M=0;M<p;M++)A.setXY(M,u[2*M],u[2*M+1]);A.needsUpdate=!0;const v=this.getAttribute("instanceRotationMatrix");if(v)for(let M=0;M<p;M++){const e=9*M;v.set([a[e],a[e+1],a[e+2],a[e+3],a[e+4],a[e+5],a[e+6],a[e+7],a[e+8]],e)}v.needsUpdate=!0;const y=this.getAttribute("whAndSize");if(y)for(let M=0;M<p;M++)y.setXYZ(M,n[3*M],n[3*M+1],n[3*M+2]);y.needsUpdate=!0;const x=this.getAttribute("stretch");if(x)for(let M=0;M<p;M++)x.setXYZW(M,d[4*M],d[4*M+1],d[4*M+2],d[4*M+3]);x.needsUpdate=!0;const b=this.getAttribute("fillStyles"),S=this.getAttribute("strokeStyles"),C=this.getAttribute("strokeWidth");if(b&&S)for(let M=0;M<p;M++)b.setXYZW(M,o[9*M],o[9*M+1],o[9*M+2],o[9*M+3]),S.setXYZW(M,o[9*M+4],o[9*M+5],o[9*M+6],o[9*M+7]),C.setX(M,o[9*M+8]);b.needsUpdate=!0,S.needsUpdate=!0,C.needsUpdate=!0;const T=this.getAttribute("type"),E=this.getAttribute("pIndex");if(T&&E)for(let M=0;M<p;M++)T.setX(M,l[2*M]),E.setX(M,l[2*M+1]);T.needsUpdate=!0,E.needsUpdate=!0,this._drawRange=h,this.setIndex(c)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new three.Sphere);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new three.Vector3,1/0);if(e){const i=this.boundingSphere.center,n=e.array.slice(0,this._drawRange);if(_box$3.setFromArray(n),t)for(let e=0,s=t.length;e<s;e++){const i=t[e];_boxMorphTargets.setFromBufferAttribute(i),this.morphTargetsRelative?(_vector$6.addVectors(_box$3.min,_boxMorphTargets.min),_box$3.expandByPoint(_vector$6),_vector$6.addVectors(_box$3.max,_boxMorphTargets.max),_box$3.expandByPoint(_vector$6)):(_box$3.expandByPoint(_boxMorphTargets.min),_box$3.expandByPoint(_boxMorphTargets.max))}_box$3.getCenter(i);let r=0;for(let e=0,t=n.length;e<t;e+=3)_vector$6.fromArray(n,e),r=Math.max(r,i.distanceToSquared(_vector$6));if(t)for(let s=0,a=t.length;s<a;s++){const n=t[s],a=this.morphTargetsRelative;for(let t=0,s=n.count;t<s;t++)_vector$6.fromBufferAttribute(n,t),a&&(_offset$1.fromBufferAttribute(e,t),_vector$6.add(_offset$1)),r=Math.max(r,i.distanceToSquared(_vector$6))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}}const vertexShader$t="#define GLSLIFY 1\n#include <common>\nuniform vec2 pixelOffset;\nuniform vec3 positionOffset;\nuniform bool u_flat;\n\n#ifdef RENDER_IN_POSTPROCESS\n    uniform float cameraFar;\n#endif\n\n#ifdef IS_GLOBE\n    attribute mat3 instanceRotationMatrix;\n#endif\n\nattribute float pIndex;\nattribute vec3 whAndSize;\nattribute vec4 stretch;\n// attribute float size;\nattribute float rotateZ;\nattribute float type;\nattribute vec4 strokeStyles;\nattribute vec4 fillStyles;\nattribute float strokeWidth;\nattribute vec2 offset;\n\nvarying vec2 v_uv;\nvarying float v_type;\nvarying float v_iconOpacity;\nvarying float vScale;\nvarying float opacityRatio;\nvarying vec4 vStretch;\n\nvarying vec4 vStrokeStyles;\nvarying vec4 vFillStyles;\nvarying float vSize;\nvarying float vStrokeWidth;\n\n#ifdef RENDER_IN_POSTPROCESS\n    varying vec2 vClipSpacePosition;\n    varying float vLogDepth;\n#endif\n\nuniform float elapsedTime;\n#ifdef MVT_ENABLE_FADE\n    attribute vec2 fadeOpacityAndSince;\n    uniform float fadeDuration;\n    varying float vFadeOpacity;\n#endif\n\n// 仅仅text有的\n// offset, anchor, strokeStyles\n\nvec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {\n    float x = coord.x;\n    float y = coord.y;\n    if (corner == 1.0) {\n        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    } else if (corner == 2.0) {\n        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else if (corner == 3.0) {\n        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else {\n        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    }\n    return vec3(x, y, coord.z);\n}\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n#include <mvt_animation_pars_vertex>\nvoid main() {\n    v_uv = uv;\n    v_type = type;\n\n    opacityRatio = 1.0;\n    vScale = 1.0;\n    vStretch = stretch;\n\n    #include <mvt_animation_label_vertex>\n\n    vec2 wh = whAndSize.xy;\n    float size = whAndSize.z;\n\n    mat4 currentInstanceMatrix = mat4(1.0);\n    vec3 currentPosition = position;\n    #ifdef IS_GLOBE\n        currentInstanceMatrix = mat4(\n            vec4(instanceRotationMatrix[0], 0.0),\n            vec4(instanceRotationMatrix[1], 0.0),\n            vec4(instanceRotationMatrix[2], 0.0),\n            vec4(position, 1.0)\n        );\n\n        currentPosition = vec3(0.0, 0.0, 0.0);\n    #endif\n\n    #ifdef ENABLE_ANIMATION_JUMP\n        currentPosition.z += jumpHeight;\n    #endif\n\n    vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));\n\n    #ifdef RENDER_IN_POSTPROCESS\n        vec4 clipSpacePosition = projectionMatrix * viewMatrix * worldPosition;\n        vClipSpacePosition.xy = ((clipSpacePosition.xy / clipSpacePosition.w) + 1.0) / 2.0;\n\n        float fcoef = 1.0 / log2(cameraFar + 1.0);\n        float logDepth = log2(max(1e-6, 1.0 + clipSpacePosition.w)) * fcoef;\n        vLogDepth = logDepth;\n    #endif\n\n    if (type == 0.0) {\n        float iconRotateZ = rotateZ;\n        v_iconOpacity = fillStyles.w;\n        // vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n        if (u_flat) {\n            float hw = wh.x * 0.5 * vScale;\n            float hh = wh.y * 0.5 * vScale;\n\n            if (keepSize) {\n                float pixelSize = getPixelSize(worldPosition.xyz);\n                hw *= pixelSize;\n                hh *= pixelSize;\n            }\n\n            #ifdef ENABLE_ANIMATION_ROTATE\n            iconRotateZ += rotation;\n            #endif\n            vec3 current = transformCoord(currentPosition, vec2(hw, hh), pIndex, -iconRotateZ);\n\n            gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);\n        }\n        else {\n            worldPosition.x += positionOffset.x;\n            worldPosition.y += positionOffset.y;\n            worldPosition.z += positionOffset.z;\n            gl_Position = projectionMatrix * viewMatrix * worldPosition;\n            float w = gl_Position.w;\n            gl_Position /= w;\n\n            float hw = wh.x / resolution.x * vScale;\n            float hh = wh.y / resolution.y * vScale;\n\n            float pixelSize = getPixelSize(worldPosition.xyz);\n            float iconOffsetX = offset.x * 2.0 / resolution.x * vScale;\n            float iconOffsetY = offset.y * 2.0 / resolution.y * vScale;\n            if (!keepSize) {\n                hw = hw / pixelSize;\n                hh = hh / pixelSize;\n\n                iconOffsetX /= pixelSize;\n                iconOffsetY /= pixelSize;\n            }\n            gl_Position.x += pixelOffset.x / resolution.x;\n            gl_Position.y += pixelOffset.y / resolution.y;\n\n            if (pIndex == 1.0) {\n                gl_Position.x -= hw;\n                gl_Position.y += hh;\n            } else if (pIndex == 2.0) {\n                gl_Position.x += hw;\n                gl_Position.y += hh;\n            } else if (pIndex == 3.0) {\n                gl_Position.x += hw;\n                gl_Position.y -= hh;\n            } else {\n                gl_Position.x -= hw;\n                gl_Position.y -= hh;\n            }\n\n            gl_Position.x += iconOffsetX;\n            gl_Position.y += iconOffsetY;\n\n            gl_Position *= w;\n        }\n    }\n    else {\n        float textRotateZ = rotateZ;\n\n        // vec4 worldPosition = (modelMatrix * vec4(position, 1.0));\n\n        if (u_flat) {\n            // viewMatrix[0]表示相机的右方向，不管相机如何倾斜tilt，法向量都指向正北方向，正好可以用来计算和文字的夹角\n            mat4 localViewMatrix = viewMatrix * currentInstanceMatrix;\n            vec4 right = localViewMatrix[0];\n            float theta = dot(vec2(sin(textRotateZ), cos(textRotateZ)), vec2(-right.y, right.x));\n            if (theta < 0.0) {\n                textRotateZ += PI;\n            }\n            // TODO 支持offset\n            float hw = wh.x * 0.5 * vScale;\n            float hh = wh.y * 0.5 * vScale;\n\n            float pixelSize = getPixelSize(worldPosition.xyz);\n            float xOffset = offset.x * vScale;\n            float yOffset = offset.y * vScale;\n            if (keepSize) {\n                hw = hw * pixelSize;\n                hh = hh * pixelSize;\n\n                xOffset *= pixelSize;\n                yOffset *= pixelSize;\n            }\n\n            #ifdef ENABLE_ANIMATION_ROTATE\n            textRotateZ += rotation;\n            #endif\n            vec3 transformedPoint =  transformCoord(currentPosition, vec2(xOffset, yOffset), 2.0, -textRotateZ);\n            vec3 current = transformCoord(transformedPoint, vec2(hw, hh), pIndex, -textRotateZ);\n\n            gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);\n\n            // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        }\n        else {\n            // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);\n            worldPosition.x += positionOffset.x;\n            worldPosition.y += positionOffset.y;\n            worldPosition.z += positionOffset.z;\n            vec4 pos = projectionMatrix * viewMatrix * worldPosition;\n            float w = pos.w;\n            vec3 screen = pos.xyz / w;\n\n            float hw = wh.x / resolution.x * vScale;\n            float hh = wh.y / resolution.y * vScale;\n\n            float textOffsetX = offset.x * 2.0 / resolution.x * vScale;\n            float textOffsetY = offset.y * 2.0 / resolution.y * vScale;\n            if (!keepSize) {\n                float pixelSize = getPixelSize(worldPosition.xyz);\n                hw = hw / pixelSize;\n                hh = hh / pixelSize;\n\n                textOffsetX /= pixelSize;\n                textOffsetY /= pixelSize;\n            }\n\n            screen.x += pixelOffset.x / resolution.x;\n            screen.y += pixelOffset.y / resolution.y;\n\n            vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -textRotateZ);\n\n            current = vec3(current.x + textOffsetX, current.y + textOffsetY, current.z);\n\n            gl_Position = vec4(current, 1.0);\n\n            gl_Position *= w;\n\n        }\n\n        vStrokeStyles = strokeStyles;\n        vFillStyles = fillStyles;\n        vSize = size;\n        vStrokeWidth = strokeWidth;\n    }\n\n    #ifdef MVT_ENABLE_FADE\n        float fadeDiff = (elapsedTime - fadeOpacityAndSince.y) / fadeDuration;\n        if (fadeOpacityAndSince.x > 2.0) {\n            fadeDiff = clamp(fadeDiff, 0.0, 1.0);\n            vFadeOpacity = fadeOpacityAndSince.x - fadeDiff - 2.0;\n            // vFadeOpacity = vFadeOpacity * vFadeOpacity;\n        } else {\n            vFadeOpacity = fadeOpacityAndSince.x + fadeDiff;\n            // vFadeOpacity = sqrt(vFadeOpacity);\n        }\n        vFadeOpacity = clamp(vFadeOpacity, 0.0, 1.0);\n    #endif\n\n    #include <logdepthbuf_vertex>\n}",fragmentShader$r="#define GLSLIFY 1\n#ifdef USE_ICON\nuniform sampler2D spriteMap;\nuniform sampler2D map;\n#endif\n\n#ifdef USE_TEXT\nuniform sampler2D textMap;\n#endif\nuniform sampler2D depthTexture;\nuniform float pixelRatio;\nuniform bool useMap;\n\nvarying vec2 v_uv;\nvarying float v_type;\nvarying float v_iconOpacity;\nvarying vec4 vFillStyles;\nvarying vec4 vStrokeStyles;\nvarying float vStrokeWidth;\nvarying float vSize;\nvarying vec4 vStretch;\n\n#ifdef RENDER_IN_POSTPROCESS\n    varying vec2 vClipSpacePosition;\n    varying float vLogDepth;\n#endif\n\n#ifdef MVT_ENABLE_FADE\n    varying float vFadeOpacity;\n#endif\n\n#include <logdepthbuf_pars_fragment>\n#include <tonemapping_pars_fragment>\n#include <output_pars_fragment>\nvoid main() {\n    // #ifdef RENDER_IN_POSTPROCESS\n    //     float depthValue = texture2D(depthTexture, vClipSpacePosition).r;\n    //     float bias = 0.002; // 避免设置一个阈值，精度误差造成文字绘制不稳定\n    //     if (vLogDepth > depthValue + bias) {\n    //         discard;\n    //     }\n    // #endif\n\n    // 三格拉伸, 解决拉伸变形问题\n    vec2 uv = v_uv;\n    if (v_uv.x < vStretch.x + vStretch.w) {\n        uv.x = vStretch.x + (v_uv.x - vStretch.x) * vStretch.z;\n    }\n    else if (v_uv.x > vStretch.y - vStretch.w) {\n        uv.x = vStretch.y - (vStretch.y - v_uv.x) * vStretch.z;\n    }\n    else {\n        float startU = vStretch.x + vStretch.w * vStretch.z;\n        float endU = vStretch.y - vStretch.w * vStretch.z;\n        float uvOffset = endU - startU;\n\n        uv.x = startU + (v_uv.x - (vStretch.x + vStretch.w)) / (vStretch.y - vStretch.x - vStretch.w * 2.0) * uvOffset;\n    }\n    if (v_type == 0.0) {\n        #ifdef USE_ICON\n            if (useMap) {\n                gl_FragColor = texture2D(map, vec2(uv.x, 1.0 - uv.y));\n            }\n            else {\n                gl_FragColor = texture2D(spriteMap, vec2(uv.x, 1.0 - uv.y));\n            }\n\n            gl_FragColor.a *= v_iconOpacity;\n        #endif\n    }\n    else {\n        #ifdef USE_TEXT\n            float fontScale = vSize / 24.0;\n            float gamma = (0.105 / pixelRatio) / fontScale;\n            float buff = (256.0 - 64.0) / 256.0;\n\n            float distance = texture2D(textMap, vec2(v_uv.x, v_uv.y)).r;\n            float alpha = smoothstep(buff - gamma, buff + gamma, distance);\n            vec3 fontColor = vFillStyles.xyz;\n            float fillAlpha = vFillStyles.w;\n\n            if (vStrokeWidth > 0.0) {\n                float inFill = alpha;\n                float outlineBuffer = (6.0 - vStrokeWidth / fontScale) / 8.0;\n                float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n\n                float ratio = smoothstep(0.0, 1.0, inFill);\n                fontColor = mix(vStrokeStyles.xyz, fontColor, ratio);\n                fillAlpha = mix(vStrokeStyles.w, fillAlpha, ratio);\n                alpha = inBorder;\n            }\n\n            gl_FragColor = vec4(fontColor, alpha * fillAlpha);\n        #endif\n\n    }\n\n    #ifdef MVT_ENABLE_FADE\n        gl_FragColor.a *= vFadeOpacity;\n    #endif\n\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n    #include <output_fragment>\n}",commonUniforms={height:{value:0},size:{value:1},size3:{value:[1,1,1]},resolution:{value:[1,1]},zoomUnits:{value:1},color:{value:[1,0,0]},opacity:{value:1}},animationUnifroms={animationRotatePeriod:{value:4e3},animationJumpPeriod:{value:4e3},animationJumpHeight:{value:30},animationPeriodOffset:{value:!1},animationEffect:{value:!0},animationEffectPeriod:{value:4e3},animationPeriod:{value:4e3}},defineCommonProperties=e=>{Object.defineProperties(e,{color:{get:function(){return this.uniforms.color.value},set:function(e){this.uniforms.color.value=normalizeColor(e)}},height:{get:function(){return this.uniforms.height.value},set:function(e){this.uniforms.height.value=e}},size:{get:function(){return this.uniforms.size.value},set:function(e){this.uniforms.size.value=e}},size3:{get:function(){return this.uniforms.size3.value},set:function(e){Array.isArray(e)&&3===e.length&&(this.uniforms.size3.value=e)}},useSize3:{get:function(){return this.defines.USE_SIZE3},set:function(e){e===this.defines.USE_SIZE3&&(this.defines.USE_SIZE3=!!e),this.needsUpdate=!0}},opacity:{get:function(){return this.uniforms.opacity.value},set:function(e){this.uniforms.opacity.value=e}}})},defineAnimationProperties=e=>{Object.defineProperties(e,{animationRotate:{get:function(){return!!this.defines.ENABLE_ANIMATION_ROTATE},set:function(e){e!==this.animationRotate&&(e?this.defines.ENABLE_ANIMATION_ROTATE=!0:delete this.defines.ENABLE_ANIMATION_ROTATE,this.needsUpdate=!0)}},animationRotatePeriod:{get:function(){return this.uniforms.animationRotatePeriod.value},set:function(e){this.uniforms.animationRotatePeriod.value=e}},animationJump:{get:function(){return!!this.defines.ENABLE_ANIMATION_JUMP},set:function(e){e!==this.animationJump&&(e?this.defines.ENABLE_ANIMATION_JUMP=!0:delete this.defines.ENABLE_ANIMATION_JUMP,this.needsUpdate=!0)}},animationJumpPeriod:{get:function(){return this.uniforms.animationJumpPeriod.value},set:function(e){this.uniforms.animationJumpPeriod.value=e}},animationJumpHeight:{get:function(){return this.uniforms.animationJumpHeight.value},set:function(e){this.uniforms.animationJumpHeight.value=e}},animationPeriodOffset:{get:function(){return this.uniforms.animationPeriodOffset.value},set:function(e){this.uniforms.animationPeriodOffset.value=e}},animationEffect:{get:function(){return this.uniforms.animationEffect.value},set:function(e){this.uniforms.animationEffect.value=e}},animationEffectPeriod:{get:function(){return this.uniforms.animationEffectPeriod.value},set:function(e){this.uniforms.animationEffectPeriod.value=e}},animationScale:{get:function(){return!!this.defines.ENABLE_ANIMATION_SCALE},set:function(e){e!==this.animationScale&&(e?this.defines.ENABLE_ANIMATION_SCALE=!0:delete this.defines.ENABLE_ANIMATION_SCALE,this.needsUpdate=!0)}},animationBreath:{get:function(){return!!this.defines.ENABLE_ANIMATION_BREATH},set:function(e){e!==this.animationBreath&&(e?this.defines.ENABLE_ANIMATION_BREATH=!0:delete this.defines.ENABLE_ANIMATION_BREATH,this.needsUpdate=!0)}},animationPeriod:{get:function(){return this.uniforms.animationPeriod.value},set:function(e){this.uniforms.animationPeriod.value=e}}})},uniforms$r=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,commonUniforms,animationUnifroms,{spriteMap:{value:null},textMap:{value:null},map:{value:null},useMap:{value:!1},pixelOffset:{value:[0,0]},positionOffset:{value:[0,0,0]},targetScale:{value:2},minScale:{value:0},maxScale:{value:2},opacityGradient:{value:!1},opacity:{value:1},keepSize:{value:!0},depthTexture:{value:null},u_flat:{value:!1},cameraFar:{value:0},srgbTransformer:{value:!1},fadeDuration:{value:300}}]),textureLoader$a=new three.TextureLoader;class SymbolMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="SymbolMaterial",this.vertexShader=vertexShader$t,this.fragmentShader=fragmentShader$r,this.transparent=!0,this.depthTest=!1,this._mapSrc="",Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$r)),defineCommonProperties(this),defineAnimationProperties(this),defineMaterialKeepSizeProperties(this),defineMaterialAliasProperties(this,[["flat","u_flat"]]),defineMaterialBoolDefineProperties(this,[["isRenderInPostprocess","RENDER_IN_POSTPROCESS"],["isGlobe","IS_GLOBE"],["useText","USE_TEXT"],["useIcon","USE_ICON"],["enableFade","MVT_ENABLE_FADE"]]),defineMaterialNormalProperties(this,["depthTexture","cameraFar","resolution","pixelOffset","positionOffset","opacity","fadeDuration"]),Object.defineProperties(this,{spriteTexture:{get:function(){return this.uniforms.spriteMap.value},set:function(e){this.uniforms.spriteMap.value=e||null}},textTexture:{get:function(){return this.uniforms.textMap.value},set:function(e){this.uniforms.textMap.value=e||null}},mapSrc:{get:function(){return this._mapSrc},set:function(e){if(this.mapSrc!==e){if(this.uniforms.map.value&&this.uniforms.map.value.dispose(),!e)return this.uniforms.map.value=null,void(this.uniforms.useMap.value=!1);textureLoader$a.load(e,(t=>{t.wrapS=t.wrapT=three.ClampToEdgeWrapping,t.colorSpace=three.SRGBColorSpace,this.uniforms.map.value=t,this.uniforms.useMap.value=!0,this._mapSrc=e}))}}}}),this.setValues(e)}dispose(){this.uniforms.spriteMap.value&&this.uniforms.spriteMap.value.dispose(),this.uniforms.textMap.value&&this.uniforms.textMap.value.dispose(),super.dispose()}}const INF=1e20;class TinySDF{constructor({fontSize:e=24,buffer:t=3,radius:i=8,cutoff:n=.25,fontFamily:r="sans-serif",fontWeight:s="normal",fontStyle:a="normal"}={}){this.buffer=t,this.cutoff=n,this.radius=i;const o=this.size=e+4*t,l=this._createCanvas(o),c=this.ctx=l.getContext("2d",{willReadFrequently:!0});c.font=`${a} ${s} ${e}px ${r}`,c.textBaseline="alphabetic",c.textAlign="left",c.fillStyle="black",this.gridOuter=new Float64Array(o*o),this.gridInner=new Float64Array(o*o),this.f=new Float64Array(o),this.z=new Float64Array(o+1),this.v=new Uint16Array(o)}_createCanvas(e){const t=document.createElement("canvas");return t.width=t.height=e,t}draw(e){const{width:t,actualBoundingBoxAscent:i,actualBoundingBoxDescent:n,actualBoundingBoxLeft:r,actualBoundingBoxRight:s}=this.ctx.measureText(e),a=Math.ceil(i),o=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(s-r))),l=Math.min(this.size-this.buffer,a+Math.ceil(n)),c=o+2*this.buffer,h=l+2*this.buffer,u=Math.max(c*h,0),d=new Uint8ClampedArray(u),p={data:d,width:c,height:h,glyphWidth:o,glyphHeight:l,glyphTop:a,glyphLeft:0,glyphAdvance:t};if(0===o||0===l)return p;const{ctx:m,buffer:f,gridInner:g,gridOuter:_}=this;m.clearRect(f,f,o,l),m.fillText(e,f,f+a);const A=m.getImageData(f,f,o,l);_.fill(INF,0,u),g.fill(0,0,u);for(let v=0;v<l;v++)for(let e=0;e<o;e++){const t=A.data[4*(v*o+e)+3]/255;if(0===t)continue;const i=(v+f)*c+e+f;if(1===t)_[i]=0,g[i]=INF;else{const e=.5-t;_[i]=e>0?e*e:0,g[i]=e<0?e*e:0}}edt(_,0,0,c,h,c,this.f,this.v,this.z),edt(g,f,f,o,l,c,this.f,this.v,this.z);for(let v=0;v<u;v++){const e=Math.sqrt(_[v])-Math.sqrt(g[v]);d[v]=Math.round(255-255*(e/this.radius+this.cutoff))}return p}}function edt(e,t,i,n,r,s,a,o,l){for(let c=t;c<t+n;c++)edt1d(e,i*s+c,s,r,a,o,l);for(let c=i;c<i+r;c++)edt1d(e,c*s+t,1,n,a,o,l)}function edt1d(e,t,i,n,r,s,a){s[0]=0,a[0]=-INF,a[1]=INF,r[0]=e[t];for(let o=1,l=0,c=0;o<n;o++){r[o]=e[t+o*i];const n=o*o;do{const e=s[l];c=(r[o]-r[e]+n-e*e)/(o-e)/2}while(c<=a[l]&&--l>-1);l++,s[l]=o,a[l]=c,a[l+1]=INF}for(let o=0,l=0;o<n;o++){for(;a[l+1]<o;)l++;const n=s[l],c=o-n;e[t+o*i]=r[n]+c*c}}const MISSING_CHAR_WIDTH=32,SINGLE_LINE=[];function nextPowOfTwo(e){return Math.pow(2,Math.ceil(Math.log2(e)))}function getDefaultCharacterSet(){const e=[];for(let t=32;t<128;t++)e.push(String.fromCharCode(t));return e}function buildMappingWithContext({characterSet:e,context:t,fontHeight:i,buffer:n,maxCanvasWidth:r,mapping:s={},xOffset:a=0,yOffset:o=0,defaultFontWeight:l,fontFamily:c}){let h=0,u=a,d=0;for(const p of e){const{char:e,fontWeight:a}=p,m=e+defaultValue$1(a,l)+c;if(!s[m]){const a=t.measureText(e),l=Math.ceil(a.width);let c=a.actualBoundingBoxAscent+a.actualBoundingBoxDescent;0===c&&(c=l),c+=n,u+l+2*n>r&&(u=0,h++,d=0),d=Math.max(d,i+2*n),s[m]={x:u+n,y:o+h*d+n,width:l,height:d,layoutWidth:l,layoutHeight:i,textHeight:Math.ceil(Math.max(c,l))},u+=l+2*n}}return{mapping:s,xOffset:u,yOffset:o+h*d,canvasHeight:nextPowOfTwo(o+(h+1)*d)}}function getTextWidth(e,t,i,n){var r;let s=0;for(let a=t;a<i;a++){s+=(null==(r=n[e[a]])?void 0:r.layoutWidth)||0}return s}function breakAll(e,t,i,n,r,s){let a=t,o=0;for(let l=t;l<i;l++){const t=getTextWidth(e,l,l+1,r);o+t>n&&(a<l&&s.push(l),a=l,o=0),o+=t}return o}function breakWord(e,t,i,n,r,s){let a=t,o=t,l=t,c=0;for(let h=t;h<i;h++)if(" "===e[h]?l=h+1:" "!==e[h+1]&&h+1!==i||(l=h+1),l>o){let t=getTextWidth(e,o,l,r);c+t>n&&(a<o&&(s.push(o),a=o,c=0),t>n&&(t=breakAll(e,o,l,n,r,s),a=s[s.length-1])),o=l,c+=t}return c}function autoWrapping(e,t,i,n,r=0,s){void 0===s&&(s=e.length);const a=[];return"break-all"===t?breakAll(e,r,s,i,n,a):breakWord(e,r,s,i,n,a),a}function transformRow(e,t,i,n,r,s,a){let o=0,l=0;for(let c=t;c<i;c++){const t=n[e[c]];t?(l||(l=t.layoutHeight),r[c]=o+t.layoutWidth/2,o+=t.layoutWidth+a):(r[c]=o,o+=MISSING_CHAR_WIDTH)}s[0]=o-a,s[1]=l}function transformParagraph(e,t,i,n,r,s,a=0,o=[0,0]){var l,c;let h;h=Array.isArray(t)?t:Array.from(t);const u=h.length,d=new Array(u),p=new Array(u),m=new Array(u),f=("break-word"===n||"break-all"===n)&&isFinite(r)&&r>0,g=[0,0],_=[0,0],A=[];let v=0,y=0,x=0,b=0,S=1;const[C,T]=o;for(let E=0;E<=u;E++){const t=e[E];if("\\"!==t&&E!==u||(b=E),b>x){const e=f?autoWrapping(h,n,r,s,x,b):SINGLE_LINE;for(let t=0;t<=e.length;t++){const n=0===t?x:e[t-1],r=t<e.length?e[t]:b;transformRow(h,n,r,s,d,_,a+C);for(let e=n;e<r;e++){const t=h[e],i=(null==(l=s[t])?void 0:l.layoutOffsetY)||0,n=(null==(c=s[t])?void 0:c.textHeight)||0;p[e]=y-i,m[e]=_[0],A.push(n),v+=n}y+=_[1]*i+T,g[0]=Math.max(g[0],_[0])}x=b}"\\"===t&&(d[x]=0,p[x]=0,m[x]=0,x++,S++)}return g[1]=Math.max(0,y),{x:d,y:p,rowWidth:m,size:g,rowNum:S,heightSize:v,textHeights:A}}const measureCache={};function wrapText(e,t,i,n){const r=n+","+i+","+t;let s=measureCache[r];if(!s){const i=t.split(" ");if(i.length>1){const t=e.measureText("M").width*n;let r="";const a=[];for(let n=0,s=i.length;n<s;++n){const s=i[n],o=r+(r?" ":"")+s;e.measureText(o).width<=t?r=o:(r&&a.push(r),r=s)}r&&a.push(r);for(let i=0,n=a.length;i<n&&n>1;++i){const r=a[i];if(e.measureText(r).width<.35*t){const t=e.measureText(a[i-1]).width,s=e.measureText(a[i+1]).width,o=i>0?t:1/0,l=i<n-1?s:1/0;a.splice(i,1),n-=1,o<l?(a[i-1]+=" "+r,i-=1):a[i]=r+" "+a[i]}}for(let i=0,n=a.length-1;i<n;++i){const r=a[i],s=a[i+1];if(e.measureText(r)>.7*t&&e.measureText(s)<.6*t){const o=r.split(" "),l=o.pop();e.measureText(l)<.2*t&&(a[i]=o.join(" "),a[i+1]=l+" "+s),n-=1}}s=a.join("\\")}else s=t;measureCache[r]=s}return s}class LRUCache$1{constructor(t){__publicField(this,"triggerRemoveEvent",((t,i)=>{try{this.onRemove(i,t)}catch(e){console.warn("error occurs when disposing tile",e)}})),this.cache={},this.head=this.tail=null,this.length=0,this.max=t.max||1e3,this.maxAge=t.maxAge||0,this.onRemove=t.onRemove||(()=>{})}clear(){for(const e of Object.keys(this.cache)){const t=this.cache[e];this.triggerRemoveEvent(e,t.value)}this.cache={},this.head=this.tail=null,this.length=0}remove(e){if(!this.cache.hasOwnProperty(e))return;const t=this.cache[e];return delete this.cache[e],this._unlink(e,t.prev,t.next),t.value}_unlink(e,t,i){this.length--,0===this.length?this.head=this.tail=null:this.head===e?(this.head=t,this.cache[this.head].next=null):this.tail===e?(this.tail=i,this.cache[this.tail].prev=null):(this.cache[t].next=i,this.cache[i].prev=t)}peek(e){if(!this.cache.hasOwnProperty(e))return;const t=this.cache[e];return this._checkAge(e,t)?t.value:void 0}set(e,t){let i=null;if(this.cache.hasOwnProperty(e)){if(i=this.cache[e],i.value=t,this.maxAge&&(i.modified=Date.now()),e===this.head)return t;this._unlink(e,i.prev,i.next)}else i={value:t,modified:0,next:null,prev:null},this.maxAge&&(i.modified=Date.now()),this.cache[e]=i,this.length===this.max&&this.evict();return this.length++,i.next=null,i.prev=this.head,this.head&&(this.cache[this.head].next=e),this.head=e,this.tail||(this.tail=e),t}_checkAge(e,t){return!(this.maxAge&&Date.now()-t.modified>this.maxAge)||(this.remove(e),this.triggerRemoveEvent(t.value,e),!1)}has(e){return this.cache.hasOwnProperty(e)&&this._checkAge(e,this.cache[e])}get(e){if(!this.cache.hasOwnProperty(e))return;const t=this.cache[e];return this._checkAge(e,t)?(this.head!==e&&(e===this.tail?(this.tail=t.next,this.cache[this.tail].prev=null):this.cache[t.prev].next=t.next,this.cache[t.next].prev=t.prev,this.cache[this.head].next=e,t.prev=this.head,t.next=null,this.head=e),t.value):void 0}evict(){if(!this.tail)return;const e=this.tail,t=this.remove(this.tail);this.triggerRemoveEvent(e,t)}}const INITIAL_CANVAS_WIDTH=512,INITIAL_CANVAS_HEIGHT=512,SDF_SCALE$2=1,fontSettings$2={fontSize:24*SDF_SCALE$2,buffer:3*SDF_SCALE$2,radius:8*SDF_SCALE$2};function getNewChars(e){let t;return t="string"==typeof e?new Set(Array.from(e)):new Set(e),t}function setTextStyle(e,t,i,n){e.font=`${i}px ${t}`,e.fillStyle="#000",e.textAlign="start",e.textBaseline="top"}const lruCacheSize=2e3,localGlyphs=new LRUCache$1({max:lruCacheSize});class FontAtlasManager{constructor(){__publicField(this,"props",{}),__publicField(this,"_entry",{}),__publicField(this,"_textureData",new Uint8Array(INITIAL_CANVAS_WIDTH*INITIAL_CANVAS_HEIGHT)),__publicField(this,"_currentWidth",INITIAL_CANVAS_WIDTH),__publicField(this,"_currentHeight",INITIAL_CANVAS_HEIGHT),__publicField(this,"_xOffset",0),__publicField(this,"_yOffset",0),__publicField(this,"_mapping",{}),__publicField(this,"_canvasHeight",0),__publicField(this,"_atlas"),__publicField(this,"_ctx"),__publicField(this,"_version",0)}get atlas(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}setProps(e={}){Object.assign(this.props,e);const t=getNewChars(this.props.characterSet);this._generateFontAtlas(t);const i=this._createTextureData(t);this._atlas=i}async setPropsAsync(e,t={},i=30){Object.assign(this.props,t);const n=getNewChars(this.props.characterSet),r=Array.from(n);this._prepareFontAtlas();let s=0;const a=r.length;return new Promise((t=>{const n=()=>{const o=Math.min(s+i,a),l=r.slice(s,o);this._generateFontAtlas(l);const c=this._processCharBatch(l);s=c?0:o,s<a?e.addTask((()=>Promise.resolve(n()))):(this._finalizeTextureData(),t())};e.addTask((()=>Promise.resolve(n())))}))}_prepareFontAtlas(){const e=document.createElement("canvas");e.width=this._currentWidth,this._ctx=e.getContext("2d",{willReadFrequently:!0}),setTextStyle(this._ctx,this.props.fontFamily,fontSettings$2.fontSize)}_generateFontAtlas(e){var t;const{fontSize:i,buffer:n,radius:r}=fontSettings$2,{fontFamily:s,sdf:a}=this.props;if(a)for(const o of e){let e,a;"string"==typeof o?(e=this.props.fontWeight,a=o):(e=defaultValue$1(o.fontWeight||(null==(t=o.textStyle)?void 0:t.fontWeight),this.props.fontWeight),a=o.char);const l=a+e+s;if(localGlyphs.get(l))continue;let c=this._entry[s];c||(this._entry[s]={},c=this._entry[s]);let h=c[e];h||(h=new TinySDF({fontSize:i,buffer:n,radius:r,fontFamily:s,fontWeight:`${e}`}),h.ctx.textBaseline="top",this._entry[s][e]=h);const u=h.draw(a);localGlyphs.set(l,u)}}_processCharBatch(e){const{fontWeight:t,fontFamily:i}=this.props,{buffer:n}=fontSettings$2,{mapping:r,canvasHeight:s,xOffset:a,yOffset:o}=buildMappingWithContext({characterSet:e,context:this._ctx,fontHeight:fontSettings$2.fontSize,buffer:n,maxCanvasWidth:this._currentWidth,mapping:this._mapping,xOffset:this._xOffset,yOffset:this._yOffset,defaultFontWeight:t,fontFamily:i});s>this._currentHeight&&(this._currentHeight=s,this._textureData=new Uint8Array(this._currentWidth*this._currentHeight));const l=this._ctx.canvas.width,c=this._textureData;for(const h of e){const e=("string"==typeof h?h:h.char)+("string"==typeof h?t:defaultValue$1(h.fontWeight,t))+i,{data:n,width:s,height:a,glyphTop:o}=localGlyphs.get(e),u=r[e];u.layoutOffsetY=o;const d=Math.floor(u.y*l+u.x);for(let t=0;t<a;t++){const e=d+t*l,i=t*s;for(let t=0;t<s;t++)c[e+t]=n[i+t]}}this._xOffset=a,this._yOffset=o}_finalizeTextureData(){const e=new Uint8Array(this._textureData);this._atlas={textureData:e,xOffset:this._xOffset,yOffset:this._yOffset,mapping:this._mapping,width:this._currentWidth,height:this._currentHeight}}_debugRenderTexture(){let e=document.getElementById("debug-texture-atlas");e||(e=document.createElement("canvas"),e.id="debug-texture-atlas",e.style.position="fixed",e.style.left="20px",e.style.bottom="20px",e.style.zIndex="10000",e.style.imageRendering="pixelated",document.body.appendChild(e));const{textureData:t,width:i,height:n}=this._atlas;let r=4*i,s=4*n;if(r>480||s>480){const e=Math.min(480/r,480/s);r=Math.floor(4*i*e),s=Math.floor(4*n*e)}e.width=r,e.height=s;const a=e.getContext("2d"),o=a.createImageData(r,s);for(let l=0;l<s;l++)for(let e=0;e<r;e++){const a=Math.floor(e/r*i),c=t[Math.floor(l/s*n)*i+a]||0,h=4*(l*r+e);o.data[h]=c,o.data[h+1]=c,o.data[h+2]=c,o.data[h+3]=255}a.putImageData(o,0,0),this._atlas.mapping&&(a.strokeStyle="rgba(255, 0, 0, 0.3)",a.lineWidth=1,Object.values(this._atlas.mapping).forEach((e=>{const t=e.x/i*r,o=e.y/n*s,l=e.width/i*r,c=e.height/n*s;a.strokeRect(t,o,l,c)})))}_createTextureData(e){return this._reset(),this._prepareFontAtlas(),this._processCharBatch(Array.from(e)),this._finalizeTextureData(),this._atlas}_reset(){this._textureData&&this._textureData.fill(0),this._mapping={},this._xOffset=0,this._yOffset=0}}class FadeData{constructor(e={}){__publicField(this,"_fadeDuration",300),__publicField(this,"_idField","id"),__publicField(this,"_lastData",[]),__publicField(this,"_filterData",[]),__publicField(this,"_lastDataMap",{}),__publicField(this,"_fadeSinceField","fadeSince"),__publicField(this,"_fadeOpacityField","fadeOpacity"),__publicField(this,"_stableTime",0),__publicField(this,"_debugTrackLogId",null),this._fadeDuration=defaultValue$1(e.fadeDuration,300)}processId(e){return e}_dataToMap(e){if(!Array.isArray(e))return{};const t={};for(const i of e){const e=this.processId(i[this._idField]);void 0!==e&&(t[e]=i)}return t}isStable(e){return e>=this._stableTime}update(e,t,i=!1){Array.isArray(e)||(console.warn("data should be an array"),e=[]);let n=t;const r=this._dataToMap(e),s=i&&this._dataToMap(this.filterData),a=this._lastDataMap,o=this._lastData,l=this._fadeDuration,c=[];for(const h of e){const e=this.processId(h[this._idField]),i=e&&a[e];if(this._debugTrackLogId,i){const e=i[this._fadeOpacityField]||0,r=i[this._fadeSinceField];if(this._debugTrackLogId,e>2){this._debugTrackLogId;const e=t-r;h[this._fadeOpacityField]=.001,h[this._fadeSinceField]=t-(l-e),c.push(h),n=Math.max(n,t+l)}else this._debugTrackLogId,h[this._fadeOpacityField]=i[this._fadeOpacityField],h[this._fadeSinceField]=i[this._fadeSinceField],c.push(h),n=Math.max(n,r+l)}else this._debugTrackLogId,h[this._fadeSinceField]=t,h[this._fadeOpacityField]=.001,void 0===e&&(h[this._fadeOpacityField]=1),c.push(h),n=Math.max(n,t+l)}for(const h of o){const e=this.processId(h[this._idField]);if(void 0!==e&&(this._debugTrackLogId,(!i||s[e])&&!r[e])){const i=h[this._fadeOpacityField]||0,s=h[this._fadeSinceField],a=t-s;if(i<=1)this._debugTrackLogId,h[this._fadeOpacityField]=3,h[this._fadeSinceField]=a<l?t-(l-a):t,c.push(h),r[e]=h,n=Math.max(n,t+l);else{this._debugTrackLogId;let t=i-a/l-2;t=three.MathUtils.clamp(t,0,1),t>0&&(c.push(h),r[e]=h,n=Math.max(n,s+l))}}}this._stableTime=n,this._lastData=c,this._lastDataMap=r}get filterData(){return this._filterData}set filterData(e){this._filterData=e}get data(){return this._lastData}get fadeDuration(){return this._fadeDuration}set fadeDuration(e){this._fadeDuration=e}}function potpack(e){let t=0,i=0;for(const a of e)t+=a.w*a.h,i=Math.max(i,a.w);e.sort(((e,t)=>t.h-e.h));const n=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(t/.95)),i),h:1/0}];let r=0,s=0;for(const a of e)for(let e=n.length-1;e>=0;e--){const t=n[e];if(!(a.w>t.w||a.h>t.h)){if(a.x=t.x,a.y=t.y,s=Math.max(s,a.y+a.h),r=Math.max(r,a.x+a.w),a.w===t.w&&a.h===t.h){const t=n.pop();e<n.length&&(n[e]=t)}else a.h===t.h?(t.x+=a.w,t.w-=a.w):a.w===t.w?(t.y+=a.h,t.h-=a.h):(n.push({x:t.x+a.w,y:t.y,w:t.w-a.w,h:a.h}),t.y+=a.h,t.h-=a.h);break}}return{w:r,h:s,fill:t/(r*s)||0}}const getFontSize=(e,t,i,n,r,s=1,a=1)=>(e.font=`${a}px Microsoft Yahei`,e.textBaseline="top",e.measureText(i).width+t[1]+t[3]>=n||a*s+1*(s-1)+t[0]+t[2]>=r?a-1:getFontSize(e,t,i,n,r,s,a+1)),createSprite=(e,t,i,n={})=>{let r=!1;const s=potpack(e);let{fillStyle:a,fontSize:o,gap:l,padding:c,dpr:h,drawText:u=!0,textAlign:d}=n;const p=s.w,m=s.h;i.width===p&&i.height===m||(r=!0),i.width=p||1,i.height=m||1,t.save(),d&&(t.textAlign=d);for(let f=0;f<e.length;f++){const i=e[f],n=i.icon,r=i.text;if(t.drawImage(n,i.x+l[0]/2,i.y+l[1]/2,i.width,i.height),defined$2(r)&&u){const e=`${String(r)}`.split("\\");e.forEach(((n,r)=>{"auto"===o&&(o=getFontSize(t,c,n,i.width,i.height,e.length)),t.font=`${o}px Microsoft Yahei`,t.fillStyle=a,t.textBaseline="top",t.fillText(n,i.x+l[0]/2+("center"===d?i.width/2:c[3]),i.y+l[1]/2+c[0]+(Number(o)+1)*r)}))}}return t.restore(),r},url2canvas=(e,t,i)=>{if("object"==typeof e)t(e);else{let n=new Image;n.crossOrigin="anonymous",n.onload=function(){let e=n.width,i=n.height,r=document.createElement("canvas");r.width=e,r.height=i,r.getContext("2d").drawImage(n,0,0,e,i),t&&t(r)},n.onerror=function(){i&&i()},n.src=e}},_tempPosition$1=new three.Vector3,_tempMatrix$2=new three.Matrix4;let curStyleId$2;class TextBoxCalculator{constructor(e,t={}){this.ctx=e,this.engine=t.engine,this.dpr=this.engine.rendering.pixelRatio,this.padding=t.padding||[0,0],this._textPadding=t.textPadding||[0,0],this._textSize=t.textSize||16,this._textWeight=t.textWeight||"normal",this._textStrokeWidth=t.textStrokeWidth||0,this._textFamily=t.textFamily||"sans-serif"}getTextBox(e,t){const i=this.ctx,n=this.dpr;this._textSize;const r=this._textFamily,s=this.padding,a=this._textPadding;e.textSize=defaultValue$1(e.textSize,this._textSize),e.textWeight=defaultValue$1(e.textWeight,this._textWeight),e.textStrokeWidth=defaultValue$1(e.textStrokeWidth,this._textStrokeWidth);const{textSize:o,textWeight:l,textStrokeWidth:c,maxWidth:h}=e;let u=String(e.text||"");const d=this.getStrictStyleId(e);i.save(),i.scale(n,n),i.textBaseline="top";let p=e.textSize;if(d!==curStyleId$2?(this._setCanvasFont(i,o,l,c,r),curStyleId$2=d):i.font=`${e.textSize}px ${r}`,defined$2(h)&&u&&(u=wrapText(i,u,i.font,h)),t){const t=e.rotateZ,n=this._processTextLayout(u,p),r=n.flat();this._calculateTransform(e.position,_tempMatrix$2);const a=_tempMatrix$2.extractRotation(_tempMatrix$2),o=this._applyRotateZ(r,t,a),l=this._calculateWidths(n),c=Math.max(...l)+2*s[0],h=p*l.length+2*s[1];return i.restore(),{width:c,height:h,wrappedText:u,widthList:l,chars:o,rotationMatrix:a}}const m=u.split("\\"),f=m.map((e=>i.measureText(e).width+(e.length-1)*a[0])),g=Math.max(...f)+2*s[0],_=(p+a[1])*m.length+2*s[1];return i.restore(),{width:g,height:_,wrappedText:u,widthList:f}}_setCanvasFont(e,t,i,n,r){e.font=i>=10&&i%10==0?`${i} ${t}px ${r}`:`${t}px ${r}`,n>0&&(e.lineWidth=n)}_processTextLayout(e,t){const i=this.ctx,n=this.padding,r=String(e).split("\\"),s=-(r.length*t)/2;return r.map(((e,r)=>{const a=[];let o=0;for(const n of e){const e=i.measureText(n).width;a.push({char:n,width:e,height:t,offsetX:0,offsetY:-(s+t/2+r*t)}),o+=e}let l=-o/2;for(const t of a)l+=t.width/2,t.offsetX=l,l+=t.width/2,t.width+=2*n[0];return a}))}_applyRotateZ(e,t,i){const n=this.engine.camera.matrixWorld;return this._calculateRotation(n,i,t)<0&&(t+=Math.PI),e.map((({offsetX:e,offsetY:i,...n})=>({...n,offsetX:e*Math.cos(t)-i*Math.sin(t),offsetY:e*Math.sin(t)+i*Math.cos(t)})))}_calculateRotation(e,t,i){const n=(new three.Matrix4).multiplyMatrices(e,t),r=n.elements[0],s=n.elements[1];return Math.sin(i)*-s+Math.cos(i)*r}_calculateWidths(e){return e.map((e=>e.reduce(((e,t)=>e+t.width),0)))}getStrictStyleId(e){const{text:t,textSize:i,textWeight:n,textStrokeWidth:r}=e;return[t,i,n,r].join("_")}_calculateTransform(e,t){return this.engine.map.isGlobe?(t||(t=new three.Matrix4),Transforms.eastNorthUpToFixedFrame(_tempPosition$1.fromArray(e),null,t),t):defaultValue$1.EMPTY_MAT4}}class GeometryBufferBuilder{constructor(e=3e4){this.maxChar=e,this._initBuffers()}_initBuffers(){const e=this.maxChar;this.data={positions:new Float32Array(3*e),typesAndPIndices:new Float32Array(2*e),rotateZs:new Float32Array(e),uvs:new Float32Array(2*e),offsets:new Float32Array(2*e),instanceRotationMatrices:new Float32Array(9*e),whs:new Float32Array(3*e),stretch:new Float32Array(4*e),styles:new Float32Array(9*e),fadeOpacityAndSince:new Float32Array(2*e),indices:[]},this.offsets={positionsOffset:0,typesAndPIndicesOffset:0,rotateZsOffset:0,uvsOffset:0,offsetsOffset:0,instanceRotationMatricesOffset:0,whsOffset:0,stylesOffset:0,fadeOpacityAndSinceOffset:0,stretchOffset:0},this._cachePositions=[]}clear(){Object.keys(this.offsets).forEach((e=>this.offsets[e]=0)),this.data.indices.length=0,this._cachePositions.length=0}packPosition(e,t,i){for(let n=0;n<4;n++){const n=this.offsets.positionsOffset;this.data.positions[n]=e,this.data.positions[n+1]=t,this.data.positions[n+2]=i,this.offsets.positionsOffset+=3,this._cachePositions.push(e,t,i)}}packUV(e){this.data.uvs.set(e,this.offsets.uvsOffset),this.offsets.uvsOffset+=8}packOffset(e,t){for(let i=0;i<4;i++)this.data.offsets[this.offsets.offsetsOffset++]=e,this.data.offsets[this.offsets.offsetsOffset++]=t}packTypeAndPIndex(e){const t=this.offsets.typesAndPIndicesOffset;this.data.typesAndPIndices.set([e,0,e,1,e,2,e,3],t),this.offsets.typesAndPIndicesOffset+=8}packRotateZ(e){for(let t=0;t<4;t++)this.data.rotateZs[this.offsets.rotateZsOffset++]=e}packStyle(e,t,i){for(let n=0;n<4;n++){const n=this.offsets.stylesOffset;this.data.styles.set([e[0],e[1],e[2],e[3],t[0],t[1],t[2],t[3],i],n),this.offsets.stylesOffset+=9}}packWH(e,t,i=0){for(let n=0;n<4;n++)this.data.whs[this.offsets.whsOffset++]=e,this.data.whs[this.offsets.whsOffset++]=t,this.data.whs[this.offsets.whsOffset++]=i}packStretch(e=0,t=0,i=1,n=0){for(let r=0;r<4;r++)this.data.stretch[this.offsets.stretchOffset++]=e,this.data.stretch[this.offsets.stretchOffset++]=t,this.data.stretch[this.offsets.stretchOffset++]=i,this.data.stretch[this.offsets.stretchOffset++]=n}packRotationMatrix(e){const t=e.elements;for(let i=0;i<4;i++)this.data.instanceRotationMatrices.set(t,this.offsets.instanceRotationMatricesOffset),this.offsets.instanceRotationMatricesOffset+=9}packFade(e,t){for(let i=0;i<4;i++)this.data.fadeOpacityAndSince[this.offsets.fadeOpacityAndSinceOffset++]=e,this.data.fadeOpacityAndSince[this.offsets.fadeOpacityAndSinceOffset++]=t}packQuadIndices(e){const t=4*e;this.data.indices.push(t,t+2,t+1,t,t+3,t+2)}get drawRange(){return this.offsets.positionsOffset}}const textAnchors=["left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"],currentInstanceMatrix=new three.Matrix4,tempPosition=new three.Vector3,tempRotationMatrix=new three.Matrix3,TEXT_ALIGN$1={center:0,left:1,right:-1},SDF_SCALE$1=1,fontSettings$1={fontSize:24*SDF_SCALE$1,buffer:3*SDF_SCALE$1,radius:8*SDF_SCALE$1},SymbolType={ICON:"icon",TEXT:"text",ICONTEXT:"icontext"},defaultUv=[0,1,0,0,1,0,1,1],defaultOffset=[0,0],_tempMatrix4$5=new three.Matrix4,_tempVector3$8=new three.Vector3,_tempVector2$4=new three.Vector2,_tempVector4$3=new three.Vector4,_tempOffset$1=new three.Vector2,_tempA$1=new three.Vector3,_morphA$1=new three.Vector3,_xAxis=new three.Vector3,_yAxis=new three.Vector3;class Label extends GeoMesh{constructor(e={}){super(e),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"parameters"),__publicField(this,"spriteTexture"),__publicField(this,"textTexture"),__publicField(this,"_maxChar",3e4),__publicField(this,"_version",0),__publicField(this,"_cacheData",[]),__publicField(this,"oldMapTextureRes",new Map),__publicField(this,"iconUrlHash",new LRUCache$1({max:100,onRemove:(e,t)=>{const i=this.boxHash.get(t),n=this.boxes.indexOf(i);n>=0&&this.boxes.splice(n,1),this.boxHash.delete(t)}})),__publicField(this,"boxHash",new Map),__publicField(this,"gap",[4,4]),__publicField(this,"_labelQuadStarts",[]),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"canvas"),__publicField(this,"ctx"),__publicField(this,"cachedTextData",[]),__publicField(this,"_collisionBoxCache",new LRUCache$1({max:1e3})),__publicField(this,"isRenderInPostprocess",!1),this.parameters=e,this.spriteTexture=e.spriteTexture,this.vertexIcons=e.vertexIcons,this.flat=defaultValue$1(e.flat,!1),this.symbolType=defaultValue$1(e.type,SymbolType.ICON),this._enableFade=defaultValue$1(e.enableFade,!1),this._enableFadeFilter=defaultValue$1(e.enableFadeFilter,!0),this._textSize=defaultValue$1(e.textSize,16),this._textFamily=defaultValue$1(e.textFamily,"sans-serif"),e.textFillStyle?this._textFillStyle=Array.isArray(e.textFillStyle)?e.textFillStyle:colorToRgbaArr(e.textFillStyle):this._textFillStyle=[255,255,255,1],e.textStrokeStyle?this._textStrokeStyle=Array.isArray(e.textStrokeStyle)?e.textStrokeStyle:colorToRgbaArr(e.textStrokeStyle):this._textStrokeStyle=[0,0,0,1],this._textStrokeWidth=defaultValue$1(e.textStrokeWidth,0),this._textAnchor=defaultValue$1(e.textAnchor,"center"),this._textOffset=defaultValue$1(e.textOffset,[0,0]),this._textWeight=defaultValue$1(e.textWeight,"400"),this._rotateZ=defaultValue$1(e.rotateZ,0),this._textPadding=defaultValue$1(e.textPadding,[0,2]),this._padding=defaultValue$1(e.padding,[2,2]),this.textAlign=defaultValue$1(this.parameters.textAlign,"center"),this.isRenderInPostprocess=this.parameters.isRenderInPostprocess||!1,this.symbolType===SymbolType.TEXT?(this._iconWidth=0,this._iconHeight=0):(this._iconWidth=defaultValue$1(this.parameters.iconWidth,40),this._iconHeight=defaultValue$1(this.parameters.iconHeight,40)),this._offset=defaultValue$1(this.parameters.offset,[0,0]),this._fadeData=new FadeData({fadeDuration:this.parameters.fadeDuration}),this._fadeData.processId=e=>e&&e.split("_")[0],this._useIconScale=defaultValue$1(this.parameters.useIconScale,!1);const t=new FontAtlasManager;this.fontAtalasManager=t;const i=this.canvas=document.createElement("canvas");i.width=i.height=1;const n=this.ctx=i.getContext("2d");n.textAlign="start",n.textBaseline="top",this.vertexIcons&&(this.iconCanvas=document.createElement("canvas"),this.iconCanvas.width=this.iconCanvas.height=1,this.iconCtx=this.iconCanvas.getContext("2d"),this.spriteTexture=new three.CanvasTexture(this.iconCanvas),this.spriteTexture.colorSpace=three.SRGBColorSpace),this.defineMaterialProxyProperties(["mapSrc","transparent","depthTest","depthWrite","opacity","flat","keepSize","vertexColors","positionOffset","pixelOffset"]),this.boxes=[]}initObject(){const e=this.symbolType===SymbolType.TEXT||this.symbolType===SymbolType.ICONTEXT,t=this.symbolType===SymbolType.ICON||this.symbolType===SymbolType.ICONTEXT,{fontFamily:i,fillStyle:n,strokeStyle:r,vertexIcons:s,textSize:a,useIconScale:o,...l}=this.parameters;this.geometry=new SymbolGeometry(this.parameters),this.material=new SymbolMaterial({useText:e,useIcon:t,...l});const c=this.engine.map.isGlobe;this.material.isGlobe=c,this.material.enableFade=this._enableFade,this.material.setCommonUniforms(this.engine.rendering.uniforms),this.material.spriteTexture=this.spriteTexture,this.textBoxCalculator=new TextBoxCalculator(this.ctx,{engine:this.engine,defaultFontSize:this._textSize,defaultFontFamily:this._textFamily,defaultTextStrokeWidth:this._textStrokeWidth,padding:this._padding,textPadding:this._textPadding,textSize:this._textSize,textWeight:this._textWeight,textStrokeWidth:this._textStrokeWidth,textFamily:this._textFamily}),this.bufferBuilder=new GeometryBufferBuilder(3e4)}collisionTest(e){const t=e.boundingBox,i=this.symbolType===SymbolType.TEXT&&this.flat;return t&&!i?t:this.computeBoundingBox(e)}computeBoundingBox(e){const t=this.symbolType,i=e.iconSize||[],n=defaultValue$1(i[0],this._iconWidth),r=defaultValue$1(i[1],this._iconHeight),s=e.tolerance||0;if(t===SymbolType.ICON)return{width:n,height:r,tolerance:s};const a=defaultValue$1(e.textAnchor,this._textAnchor),o=a?textAnchors.indexOf(a)+1:0;if(t===SymbolType.TEXT){const t=this.expandTextVariants(e),i=[],n=[];for(let r=0;r<t.length;r++){t[r];const a=this.textBoxCalculator.getTextBox(e,this.flat),{offsetX:l,offsetY:c}=this._getTextOrIconOffset(o,a.width,a.height);n.push({...a,offsetX:l,offsetY:c,textBox:a,tolerance:s}),i.push(a)}return i.length>1?(e.textBox=i,n):(e.textBox=i[0],n[0])}if(t===SymbolType.ICONTEXT){const t=this.expandTextVariants(e),i=[],a=[];for(let e=0;e<t.length;e++){const l=t[e],c=this.textBoxCalculator.getTextBox(l,this.flat);if(0===e){const{offsetX:e,offsetY:t,width:a,height:l}=this._getTextIconOffset(c,o,n,r);i.push({width:a,height:l,offsetX:e,offsetY:t,textBox:c,tolerance:s})}else{const{offsetX:e,offsetY:t}=this._getTextOrIconOffset(o,c.width,c.height);i.push({width:c.width,height:c.height,offsetX:e,offsetY:t,textBox:c,tolerance:s})}a.push(c)}return a.length>1?(e.textBox=a,i):(e.textBox=a[0],i[0])}}_getTextIconOffset(e,t,i,n){const r=this._padding,s=e.width,a=e.height;let o=0,l=0,c=0,h=0;switch(t){case 0:o=Math.max(s,i),l=Math.max(a,n);break;case 1:o=s+i+r[0],l=Math.max(a,i),c=(s+r[0])/2;break;case 2:o=s+i+r[0],l=Math.max(a,i),c=-(s+r[0])/2;break;case 3:o=Math.max(s,i),l=a+n+r[1],h=(a+r[1])/2;break;case 4:o=Math.max(s,i),l=a+n+r[1],h=-(a+r[1])/2;break;case 5:o=s+i+r[0],l=a+n+r[1],c=(s+r[0])/2,h=(a+r[1])/2;break;case 6:o=s+i+r[0],l=a+n+r[1],c=-(s+r[0])/2,h=(a+r[1])/2;break;case 7:o=s+i+r[0],l=a+n+r[1],c=(s+r[0])/2,h=-(a+r[1])/2;break;case 8:o=s+i+r[0],l=a+n+r[1],c=-(s+r[0])/2,h=-(a+r[1])/2}return{width:o,height:l,offsetX:c,offsetY:h}}_getTextOrIconOffset(e,t,i){let n=0,r=0;switch(e){case 0:break;case 1:n=t/2;break;case 2:n=-t/2;break;case 3:r=i/2;break;case 4:r=-i/2;break;case 5:n=t/2,r=i/2;break;case 6:n=-t/2,r=i/2;break;case 7:n=t/2,r=-i/2;break;case 8:n=-t/2,r=-i/2}return{offsetX:n,offsetY:r}}_updateData(){this._version++,this.bufferBuilder.clear(),this._labelQuadStarts.length=0;let e=this.dataSource.userData;this._enableCollision&&this._collisionData&&(e=this._collisionData),this._enableFade&&(this._fadeData.filterData=this.dataSource.userData,this._fadeData.update(e,this.engine.rendering.uniforms.elapsedTime.value,this._enableFadeFilter),e=this._fadeData.data),this.packBuffer(e),this.needsUpdate=!1}packBuffer(e){if(!e)return;const t=this._version,i=this.symbolType,n=this.engine.map.isGlobe;e=e.filter((e=>{if(e.checkVisible&&n){const t=e.position;tempPosition.fromArray(t);return this.engine.map.map.occluder.isPointVisible(tempPosition)}return!0}));let r=0;const s=this.engine.rendering.taskScheduler;i===SymbolType.ICON?this.updateIconHash(e).then((()=>{this._version===t&&s.addTask((()=>new Promise((i=>{this._version===t&&(this.updateIconSprite(),r=this.packIconBuffer(e,r),this._commitBuffer(),i())}))))})):i===SymbolType.TEXT?this.updateTextSprite(e).then((()=>{this._version===t&&s.addTask((()=>new Promise((i=>{this._version===t&&(this.updateTextSpriteTexture(),this.packTextBuffer(e,r),this._commitBuffer(),i())}))))})):i===SymbolType.ICONTEXT&&this.updateTextSprite(e).then((()=>{this._version===t&&this.updateIconHash(e).then((()=>{this._version===t&&s.addTask((()=>new Promise((i=>{this._version===t&&(this.updateTextSpriteTexture(),this.updateIconSprite(),r=this.packIconAndTextBuffer(e,r),this._commitBuffer(),i())}))))}))}))}_commitBuffer(){this.bufferBuilder.data.drawRange=this.bufferBuilder.drawRange,this.geometry.setData(this.bufferBuilder.data),this._enableFade&&(this.material.fadeDuration=this._fadeData.fadeDuration),this.geometry.computeBoundingSphere();const e=this.bufferBuilder.offsets.positionsOffset;this.makeGeometryOffsetPosition(this.geometry,this.bufferBuilder._cachePositions,e),this.engine.requestRender(),this._cacheData.length=0}updateIconDataItem(e,t){const i=this.vertexIcons,n=this.iconCanvas,r=this._textPadding,s=this._useIconScale;if(i){const i=e.position,a=defaultValue$1(e.iconSize,[]),o=defaultValue$1(a[0],this._iconWidth);let l=defaultValue$1(a[1],this._iconHeight);const c=e.offset||defaultOffset,h=e.textDrawOnIcon,u=e.icon,d=e.rotateZ,p=this.boxHash.get(u);if(!p)return t;s&&(l=o*p.h/p.w),this.packPosition(i),this.packRotationMatrix(i),this.packRotateZ(d);const m=p.x/n.width,f=(p.x+p.w)/n.width,g=(p.y+p.h)/n.height,_=p.y/n.height;if(this.packIconUV([m,g,m,_,f,_,f,g]),h){let t;t=e.boundingBox&&e.boundingBox.textBox?e.boundingBox.textBox:e.textBox||this.textBoxCalculator.getTextBox(e,this.flat);const i=Math.ceil(t.width),n=Math.ceil(t.height),s=5,a=i+2*s,c=Math.max(n,l)+2*r[1],h=Math.round(a),u=Math.round(c/2);this.packWH(h,u,0);const d=h/u/(o/l),p=s/a*(f-m);this.packStretch(m,f,d,p)}else this.packWH(o,l,0),this.packStretch(0,0,1,0);this.packOffset(c[0],c[1]),this.packTypeAndPIndex(0),this.packIconStyle(),this.packFade(e),this.bufferBuilder.packQuadIndices(t)}else{const i=e.position,n=e.offset||defaultOffset;let r=e.iconUvs;const s=e.rotateZ,a=e.iconOpacity,o=e.iconSize||[],l=defaultValue$1(o[0],this._iconWidth),c=defaultValue$1(o[1],this._iconHeight);this.packPosition(i),this.packRotationMatrix(i),this.packRotateZ(s),this.packWH(l,c,0),this.packStretch(0,0,1,0),this.packOffset(n[0],n[1]),r||(r=defaultUv),this.packIconUV(r),this.packIconStyle(a),this.packTypeAndPIndex(0),this.packFade(e),this.bufferBuilder.packQuadIndices(t)}return++t}isSplitArray(e,t){if(!Array.isArray(t))return!1;if(["text","textSize","textWeight","textAnchor","textStrokeWidth"].includes(e))return!0;const i=t.every((e=>"number"==typeof e));return(!["textFillStyle","textStrokeStyle","textOffset"].includes(e)||!i)&&t.length>1}expandTextVariants(e){var t;const i=["text","textFillStyle","textStrokeStyle","textStrokeWidth","textOffset","textSize","textWeight","textAnchor","textBox"],n=Array.isArray(e.text)?e.text:null;if(!n)return[e];const r=n.length,s=[];for(let a=0;a<r;a++){const n={...e};for(const r of i){const i=e[r];this.isSplitArray(r,i)&&(n[r]=null!=(t=i[a])?t:i[i.length-1])}s.push(n)}return s}packIconAndTextBuffer(e,t=0){const[i,n]=this.material.resolution||[];if(!(isNaN(i)||i<=0||isNaN(n)||n<=0)){for(let i=0;i<e.length;i++){const n=e[i];this._labelQuadStarts.push(t),t=this.updateIconDataItem(n,t);const r=this.expandTextVariants(n);for(let e=0;e<r.length;e++)t=this.updateTextDataItem(r[e],t)}return t}console.warn("resolution is invalid")}packIconBuffer(e,t=0){const[i,n]=this.material.resolution||[];if(!(isNaN(i)||i<=0||isNaN(n)||n<=0)){for(let i=0;i<e.length;i++)this._labelQuadStarts.push(t),t=this.updateIconDataItem(e[i],t);return t}console.warn("resolution is invalid")}async updateIconHash(e){if(this.vertexIcons){const t=this.getTextureAndHash(e,"icon",0,0,!0);Array.isArray(t)&&await Promise.all(t)}}async updateTextSprite(e){const t=e;let i=new Map,n=!1,r={};this.fontAtalasManager&&this.fontAtalasManager.mapping&&(r=this.fontAtalasManager.mapping);for(let s=0;s<t.length;s++){const e=t[s];let a,o=e.text;a=Array.isArray(o)?o.map((e=>String(e))):[String(o)];const l=a.length,c=defaultValue$1(e.textWeight,this._textWeight),h=defaultValue$1(e.textFamily,this._textFamily);for(let t=0;t<l;t++){const e=a[t];let s=c;Array.isArray(c)&&(s=c[t]);const o=Array.from(e);for(let t=0,a=o.length;t<a;t++){const e=o[t],a=e+s+h;i.set(a,{char:e,fontWeight:s}),r[a]||(n=!0)}}}n&&await this.updateTextTexture(i.values())}getTextureAndHash(e,t,i,n,r){const s=this.iconUrlHash;if(!r&&this.oldMapTextureRes)return this.oldMapTextureRes;const a=e.map((e=>e[t])).filter((e=>{const t=!defined$2(s.get(e));return t&&s.set(e,String(s.length)),t}));if(0===a.length)return this.oldMapTextureRes;return a.map((e=>new Promise((t=>{url2canvas(e,(i=>{s.set(e,i),t(e)}))}))))}updateIconSprite(){if(!this.iconCanvas)return this.oldMapTextureRes;const e=this.iconCtx,t=this.iconUrlHash,i=t.cache;for(let r in i)if(i.hasOwnProperty(r)){const e=i[r].value;if(!defined$2(e)||"string"==typeof e||"number"==typeof e)continue;const t=this.boxes.findIndex((e=>e.key===r));if(t>=0){const[e]=this.boxes.splice(t,1);this.boxes.unshift(e);continue}const n=e.width,s=e.height,a=n+this.gap[0],o=s+this.gap[1];this.boxes.unshift({w:a,h:o,width:n,height:s,key:r,icon:e})}let n=!1;if(this.boxes.forEach((e=>{const t=e.key;this.boxHash.has(t)||(n=!0,this.boxHash.set(e.key,e))})),n){createSprite(this.boxes,e,this.iconCanvas,{gap:this.gap,padding:[2,2],dpr:this.engine.rendering.pixelRatio})&&this.spriteTexture.dispose(),this.spriteTexture.needsUpdate=!0,this.material.spriteTexture=this.spriteTexture,this.material.isIconMap=!0}return this.oldMapTextureRes={texture:this.spriteTexture,iconUrlHash:t},this.oldMapTextureRes}getEntityByIndex(e){const t=this.dataSource;this._enableCollision&&this._collisionData&&(e=this._collisionData[e].index);const i={index:e,value:t.getDataItem(e),itemIndex:t.getDataItemIndex(e),pairs:{}},n=t.data;for(const r of Object.keys(n))i.pairs[r]=n[r][e];return i}async updateTextTexture(e){const t=Array.from(e);this._fontSettings={fontFamily:this._textFamily,fontWeight:"400",characterSet:t,sdf:!0,...fontSettings$1},this.fontAtalasManager.setProps(this._fontSettings)}updateTextSpriteTexture(){const e=this.fontAtalasManager.atlas;if(!e)return;const{textureData:t,width:i,height:n}=e;!this.textTexture||this.textTexture.image.width!==i||this.textTexture.image.height!==n?(this.textTexture&&this.textTexture.dispose(),this.textTexture=new three.DataTexture(t,i,n),this.textTexture.minFilter=this.textTexture.magFilter=three.LinearFilter,this.textTexture.format=three.RedFormat,this.textTexture.needsUpdate=!0,this.material.textTexture=this.textTexture):(this.textTexture.image.data.set(t),this.textTexture.needsUpdate=!0)}packTextBuffer(e,t=0){const[i,n]=this.material.resolution||[];if(!(isNaN(i)||i<=0||isNaN(n)||n<=0)){for(let i=0;i<e.length;i++){this._labelQuadStarts.push(t);const n=this.expandTextVariants(e[i]);for(let e=0;e<n.length;e++)t=this.updateTextDataItem(n[e],t)}return t}console.warn("resolution is invalid")}updateTextDataItem(e,t){const{mapping:i}=this.fontAtalasManager.atlas||{},n=e.position;let r;r=e.boundingBox&&e.boundingBox.textBox?e.boundingBox.textBox:e.textBox||this.textBoxCalculator.getTextBox(e,this.flat);const s=r.wrappedText,a=r.widthList,o=Math.max(...a);e.textSize=defaultValue$1(e.textSize,this._textSize),e.textWeight=defaultValue$1(e.textWeight,this._textWeight),e.textFillStyle?e.textFillStyle=Array.isArray(e.textFillStyle)?e.textFillStyle:colorToRgbaArr(e.textFillStyle):e.textFillStyle=this._textFillStyle,e.textStrokeStyle?e.textStrokeStyle=Array.isArray(e.textStrokeStyle)?e.textStrokeStyle:colorToRgbaArr(e.textStrokeStyle):e.textStrokeStyle=this._textStrokeStyle,e.textStrokeWidth=defaultValue$1(e.textStrokeWidth,this._textStrokeWidth),e.textOffset=defaultValue$1(e.textOffset,this._textOffset),e.textDrawOnIcon=defaultValue$1(e.textDrawOnIcon,!1),e.textFamily=defaultValue$1(e.textFamily,this._textFamily),e.icon=defaultValue$1(e.icon,this.mapSrc),e.iconSize=defaultValue$1(e.iconSize,[this._iconWidth,this._iconHeight]),e.rotateZ=defaultValue$1(e.rotateZ,this._rotateZ);const l=e.textWeight,c=e.textSize,h=e.rotateZ,u=e.textFamily,d=c/this._fontSettings.fontSize,p=transformParagraph(s,Array.from(s).map((e=>e+l+u)),1,"break-word",o*c,i,0,this._textPadding.map((e=>e/d))),m=p.x.length,f=Array.from(s);let g=0;for(let _=0;_<m;_++){const r=f[_];if("\\"===r)continue;const s=i[r+l+u];if(!s)return;this.packPosition(n),this.packTextOffset(e,p,_),this.packTextUV(s),this.packTextWh(e,s),this.packStretch(0,0,1,0),this.packTextStyle(e),this.packTypeAndPIndex(1),this.packRotateZ(h),this.packRotationMatrix(n),this.packFade(e),this.bufferBuilder.packQuadIndices(t+g),g++}return t+=g}packRotateZ(e){e=e||0,this.bufferBuilder.packRotateZ(e)}packRotationMatrix(e){this.engine.map.isGlobe&&(this._calculateTransform(e,currentInstanceMatrix),tempRotationMatrix.setFromMatrix4(currentInstanceMatrix),this.bufferBuilder.packRotationMatrix(tempRotationMatrix))}packPosition(e){this.bufferBuilder.packPosition(e[0],e[1],e[2])}packFade(e){if(this._enableFade){const{fadeOpacity:t,fadeSince:i}=e;this.bufferBuilder.packFade(t,i)}}packOffset(e,t){this.bufferBuilder.packOffset(e,t)}packWH(e,t,i){this.bufferBuilder.packWH(e,t,i)}packStretch(e,t,i,n){this.bufferBuilder.packStretch(e,t,i,n)}packTypeAndPIndex(e){this.bufferBuilder.packTypeAndPIndex(e)}packIconStyle(e=1){this.bufferBuilder.packStyle([1,1,1,e],[0,0,0,0],0)}packIconUV(e){this.bufferBuilder.packUV(e)}packTextStyle(e){var t,i;let{textStrokeStyle:n,textStrokeWidth:r,textFillStyle:s}=e;this.bufferBuilder.packStyle([s[0]/255,s[1]/255,s[2]/255,null!=(t=s[3])?t:1],[n[0]/255,n[1]/255,n[2]/255,null!=(i=n[3])?i:1],r)}packTextWh(e,t){const{textSize:i}=e;let{width:n,height:r}=t;n+=2*this._fontSettings.buffer;const s=i/this._fontSettings.fontSize;this.bufferBuilder.packWH(n*s,r*s,i)}packTextUV(e){const{width:t,height:i}=this.fontAtalasManager.atlas||{};let{x:n,y:r,width:s,height:a}=e;s+=2*this._fontSettings.buffer;const o=n/t,l=r/i,c=o+s/t,h=l+a/i;this.bufferBuilder.packUV([o,h,o,l,c,l,c,h])}packTextOffset(e,t,i){const{x:n,y:r,rowWidth:s,rowNum:a,size:[o,l]}=t,c=this._useIconScale,{textSize:h,textOffset:u,textAnchor:d=this._textAnchor,iconSize:p=[],icon:m}=e,f=defaultValue$1(p[0],this._iconWidth);let g=defaultValue$1(p[1],this._iconHeight);const _=this.boxHash.get(m);c&&_&&(g=f*_.h/_.w);const A=this._padding;let v=-1*o/2+(1-TEXT_ALIGN$1[this.textAlign])*(o-s[i])/2+n[i]+u[0],y=l/a*(a-1)/2-r[i]+u[1],x=0,b=0;const S=defined$2(d)?textAnchors.indexOf(d)+1:0,C=o-s[i];switch(S){case 1:v+=o/2-C/2,x+=f/2+A[0];break;case 2:v-=o/2-C/2,x-=f/2+A[0];break;case 3:y-=l/2,b-=g/2+A[1];break;case 4:y+=l/2,b+=g/2+A[1];break;case 5:v+=o/2,x+=f/2+A[0],y-=l/2,b-=g/2+A[1];break;case 6:v-=o/2,x-=f/2+A[0],y-=l/2,b-=g/2+A[1];break;case 7:v+=o/2,x+=f/2+A[0],y+=o/2,x+=f/2+A[0];break;case 8:v-=o/2,x-=f/2+A[0],y+=o/2,x+=f/2+A[0]}const T=h/this._fontSettings.fontSize,E=e.offset||defaultOffset,M=v*T+x+E[0],w=y*T+b+E[1];this.bufferBuilder.packOffset(M,w)}_calculateTransform(e,t){return this.engine.map.isGlobe?(t||(t=new three.Matrix4),Transforms.eastNorthUpToFixedFrame(tempPosition.fromArray(e),null,t),t):defaultValue$1.EMPTY_MAT4}onBeforeScenePrepareRenderHook(e,t,i){const n=e.rendering.main.sceneRendering.depthTexture;this.material.uniforms.depthTexture.value=n,this.material.uniforms.cameraFar.value=e.rendering.camera.far}onBeforeSceneRender(e,t,i,n){super.onBeforeSceneRender(e,t,i,n),this._enableFade&&!this._fadeData.isStable(n.elapsedTime)&&e.requestRender()}onDispose(){this.spriteTexture&&this.spriteTexture.dispose(),this.textTexture&&this.textTexture.dispose()}getPixelSize(e){const{camera:t,rendering:i}=this.engine;return t.isOrthographicCamera?this.material.uniforms.zoomUnits.value:.2*t.projectionMatrix.elements[5]/i.resolution.y*t.position.distanceTo(e)}_findLabelIndexByQuad(e){if(!this._labelQuadStarts||0===this._labelQuadStarts.length)return e;let t=0,i=this._labelQuadStarts.length-1;for(;t<i;){const n=Math.ceil((t+i)/2);this._labelQuadStarts[n]<=e?t=n:i=n-1}return t}getVertexPosition(e,t){const i=this.geometry,n=i.attributes.position,r=i.morphAttributes.position,s=i.attributes.whAndSize,a=i.attributes.offset,o=i.morphTargetsRelative;t.fromBufferAttribute(n,e),_tempVector2$4.fromBufferAttribute(s,e),_tempOffset$1.fromBufferAttribute(a,e);const l=this.engine.map.isGlobe;if(l){const t=i.attributes.instanceRotationMatrix.array,n=9*e;_xAxis.set(t[n],t[n+1],t[n+2]),_yAxis.set(t[n+3],t[n+4],t[n+5])}const c=e%4;let h=_tempVector2$4.x/2,u=_tempVector2$4.y/2,d=_tempOffset$1.x,p=_tempOffset$1.y;if(this.keepSize){const e=this.position,i=this.getPixelSize(_tempVector3$8.addVectors(e,t));h*=i,u*=i,d*=i,p*=i}1===c?h=-h:2===c||(3===c?u=-u:(u=-u,h=-h));const m=h+d,f=u+p;l?(_tempVector3$8.set(0,0,0),_tempVector3$8.addScaledVector(_xAxis,m),_tempVector3$8.addScaledVector(_yAxis,f),t.add(_tempVector3$8)):(t.x+=m,t.y+=f);const g=this.morphTargetInfluences;if(r&&g){_morphA$1.set(0,0,0);for(let i=0,n=r.length;i<n;i++){const n=g[i],s=r[i];0!==n&&(_tempA$1.fromBufferAttribute(s,e),o?_morphA$1.addScaledVector(_tempA$1,n):_morphA$1.addScaledVector(_tempA$1.sub(t),n))}t.add(_morphA$1)}return t}raycast(e,t){if(!this.visible)return;if(this.flat){null===this.geometry.boundingSphere&&this.geometry.computeBoundingSphere();let i=10*Math.max(this._iconWidth,this._iconHeight);return this.keepSize&&(i*=this.material.uniforms.zoomUnits.value),this.geometry.boundingSphere.radius+=i,three.Mesh.prototype.raycast.call(this,e,t),void(this.geometry.boundingSphere.radius-=i)}const i=this.geometry,n=this.position,r=i.getAttribute("position");if(!r||!r.array||!r.array.length)return;let s=e.camera;s||(s=this.engine.camera);const a=e.mouse;if(!a)return;const o=a.x,l=a.y,c=this.material.uniforms.resolution.value;_tempMatrix4$5.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),_tempMatrix4$5.multiplyMatrices(_tempMatrix4$5,this.matrixWorld);const h=r.array;let u=0,d=0,p=0,m=0,f=0,g=0;const _=this.bufferBuilder.offsets.positionsOffset,A=i.getAttribute("whAndSize"),v=i.getAttribute("offset");let y=0;for(let x=0,b=_-11;x<b;x+=12){_tempVector4$3.set(h[x],h[x+1],h[x+2],1),_tempVector4$3.applyMatrix4(_tempMatrix4$5),_tempVector4$3.divideScalar(_tempVector4$3.w);const e=A.getX(y),i=A.getY(y);let r=2*v.getX(y)/c.x,a=2*v.getY(y)/c.y;if(f=e/c.x,g=i/c.y,!this.keepSize){const e=this.getPixelSize(_tempVector3$8.set(h[x]+n.x,h[x+1]+n.y,h[x+2]+n.z));r/=e,a/=e,f/=e,g/=e}if(_tempVector4$3.x+=r,_tempVector4$3.y+=a,u=_tempVector4$3.x-f,p=_tempVector4$3.x+f,d=_tempVector4$3.y-g,m=_tempVector4$3.y+g,u<=o&&p>=o&&d<=l&&m>=l){_tempVector3$8.set(h[x],h[x+1],h[x+2]),_tempVector3$8.applyMatrix4(this.matrixWorld);const e={instanceId:this._findLabelIndexByQuad(x/12),object:this,distance:_tempVector3$8.distanceTo(s.position),point:_tempVector3$8.clone()};t.push(e)}y+=4}}get enableFade(){return this._enableFade}set enableFade(e){this._enableFade=e,this.material.enableFade=e}}Label.prototype._computeIntersections=three.Mesh.prototype._computeIntersections;class ScreenTextGeometry extends three.BufferGeometry{constructor(e){super(),this.parameters=e||{}}setData(e,t){const i=[],n=[],r=[],s=[],a=[],o=[],l=[],c=[],h=[];let u=0;for(const m of e){const{x:e,y:d,char:p,rotation:f=0,size:g=26,fillColor:_=[1,1,1,1],strokeColor:A=[0,0,0,1],strokeWidth:v=0}=m,y=t[p];if(!y)continue;u++;const x=24,b=(x+2*3)*(g/x)/2,S=[[-b,-b],[b,-b],[-b,b],[b,b]];for(const[t,a]of S)i.push(0,0,0),n.push(e,d),r.push(t,a),s.push(f),o.push(g),l.push(..._),c.push(...A),h.push(v);a.push(y.startU,y.endV,y.endU,y.endV,y.startU,y.startV,y.endU,y.startV)}const d=[],p=u;for(let m=0;m<p;m++){const e=4*m;d.push(e,e+2,e+1),d.push(e+1,e+2,e+3)}this.setAttribute("position",new three.Float32BufferAttribute(new Float32Array(i),3)),this.setAttribute("aScreenPosition",new three.Float32BufferAttribute(new Float32Array(n),2)),this.setAttribute("aOffset",new three.Float32BufferAttribute(new Float32Array(r),2)),this.setAttribute("aRotation",new three.Float32BufferAttribute(new Float32Array(s),1)),this.setAttribute("aAtlasUV",new three.Float32BufferAttribute(new Float32Array(a),2)),this.setAttribute("aSize",new three.Float32BufferAttribute(new Float32Array(o),1)),this.setAttribute("aFillColor",new three.Float32BufferAttribute(new Float32Array(l),4)),this.setAttribute("aStrokeColor",new three.Float32BufferAttribute(new Float32Array(c),4)),this.setAttribute("aStrokeWidth",new three.Float32BufferAttribute(new Float32Array(h),1)),this.setIndex(d)}}const vertexShader$s="#define GLSLIFY 1\n// 屏幕坐标（像素）\nattribute vec2 aScreenPosition;\n// 局部偏移（相对字符中心）\nattribute vec2 aOffset;\n// 旋转角度\nattribute float aRotation;\n// 图集UV\nattribute vec2 aAtlasUV;\n// 字符大小\nattribute float aSize;\n// 样式属性\nattribute vec4 aFillColor;\nattribute vec4 aStrokeColor;\nattribute float aStrokeWidth;\n\nvarying vec2 vUv;\nvarying float vSize;\nvarying vec4 vFillColor;\nvarying vec4 vStrokeColor;\nvarying float vStrokeWidth;\n\nuniform vec2 resolution;\nuniform float pixelRatio;\n\nvoid main() {\n    // 应用旋转到局部偏移\n    float s = sin(aRotation);\n    float c = cos(aRotation);\n    vec2 rotatedOffset = vec2(\n        c * aOffset.x - s * aOffset.y,\n        s * aOffset.x + c * aOffset.y\n    );\n    \n    // 计算最终屏幕坐标\n    vec2 screenPos = aScreenPosition + rotatedOffset;\n    \n    // 屏幕坐标 → NDC坐标\n    vec2 ndc;\n    ndc.x = (screenPos.x / resolution.x) * 2.0 - 1.0;\n    ndc.y = 1.0 - (screenPos.y / resolution.y) * 2.0;\n    \n    // 输出位置（z=0 在最前面）\n    gl_Position = vec4(ndc, 0.0, 1.0);\n    \n    // 传递UV、大小和样式\n    vUv = aAtlasUV;\n    vSize = aSize;\n    vFillColor = aFillColor;\n    vStrokeColor = aStrokeColor;\n    vStrokeWidth = aStrokeWidth;\n}\n\n",fragmentShader$q="#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float vSize;\nvarying vec4 vFillColor;\nvarying vec4 vStrokeColor;\nvarying float vStrokeWidth;\n\nuniform sampler2D textMap;\nuniform float opacity;\nuniform float pixelRatio;\n\n#include <tonemapping_pars_fragment>\n#include <output_pars_fragment>\n\nvoid main() {\n    // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    // 从 SDF 纹理采样\n    float distance = texture2D(textMap, vUv).r;\n    \n    // SDF 渲染参数（与 Symbol 材质相同）\n    float fontScale = vSize / 24.0;\n    float gamma = (0.105 / pixelRatio) / fontScale;\n    float buff = (256.0 - 64.0) / 256.0;\n    \n    // 计算文字的 alpha\n    float alpha = smoothstep(buff - gamma, buff + gamma, distance);\n    \n    // 使用per-instance的填充颜色\n    vec3 fontColor = vFillColor.xyz;\n    float fillAlpha = vFillColor.w;\n    \n    // 如果有描边，混合描边和填充\n    if (vStrokeWidth > 0.0) {\n        float inFill = alpha;\n        float outlineBuffer = (6.0 - vStrokeWidth / fontScale) / 8.0;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        \n        float ratio = smoothstep(0.0, 1.0, inFill);\n        fontColor = mix(vStrokeColor.xyz, fontColor, ratio);\n        fillAlpha = mix(vStrokeColor.w, fillAlpha, ratio);\n        alpha = inBorder;\n    }\n    \n    // 输出最终颜色\n    gl_FragColor = vec4(fontColor, alpha * fillAlpha);\n    \n    // Alpha 测试\n    if (gl_FragColor.a <= 0.01) {\n        discard;\n    }\n    \n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    #include <output_fragment>\n}\n\n";class ScreenTextMaterial extends three.ShaderMaterial{constructor(e={}){super(),this.vertexShader=vertexShader$s,this.fragmentShader=fragmentShader$q,this.name="ScreenTextMaterial";const t=e.color||"#ffffff",i=e.strokeColor||"#000000",n=this._hexToRgba(t),r=this._hexToRgba(i);this.uniforms=three.UniformsUtils.clone({textMap:{value:null},opacity:{value:e.opacity||1},resolution:{value:new three.Vector2(800,600)},pixelRatio:{value:1},fillColor:{value:new three.Vector4(...n)},strokeColor:{value:new three.Vector4(...r)},strokeWidth:{value:e.strokeWidth||0},fontSize:{value:e.fontSize||24}}),this.transparent=!0,this.depthTest=!1,this.depthWrite=!1,this._defineProxyProperties(["opacity","strokeWidth","fontSize"]),this._defineColorProperties(),e&&this.setValues(e)}_hexToRgba(e,t=1){3===(e=e.replace("#","")).length&&(e=e.split("").map((e=>e+e)).join(""));return[parseInt(e.substring(0,2),16)/255,parseInt(e.substring(2,4),16)/255,parseInt(e.substring(4,6),16)/255,t]}_rgbaToHex(e){return"#"+[Math.round(255*e[0]),Math.round(255*e[1]),Math.round(255*e[2])].map((e=>e.toString(16).padStart(2,"0"))).join("")}_defineProxyProperties(e){e.forEach((e=>{Object.defineProperty(this,e,{get:function(){return this.uniforms[e].value},set:function(t){this.uniforms[e].value=t}})}))}_defineColorProperties(){Object.defineProperty(this,"color",{get:function(){const e=[this.uniforms.fillColor.value.x,this.uniforms.fillColor.value.y,this.uniforms.fillColor.value.z,this.uniforms.fillColor.value.w];return this._rgbaToHex(e)},set:function(e){const t=this._hexToRgba(e);this.uniforms.fillColor.value.set(...t)}})}}function clamp(e,t,i){return Math.max(t,Math.min(i,e))}class Vector2{constructor(e=0,t=0){Vector2.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,n=e.elements;return this.x=n[0]*t+n[3]*i+n[6],this.y=n[1]*t+n[4]*i+n[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=clamp(this.x,e.x,t.x),this.y=clamp(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=clamp(this.x,e,t),this.y=clamp(this.y,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(clamp(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(clamp(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),n=Math.sin(t),r=this.x-e.x,s=this.y-e.y;return this.x=r*i-s*n+e.x,this.y=r*n+s*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Quaternion{constructor(e=0,t=0,i=0,n=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=i,this._w=n}static slerpFlat(e,t,i,n,r,s,a){let o=i[n+0],l=i[n+1],c=i[n+2],h=i[n+3];const u=r[s+0],d=r[s+1],p=r[s+2],m=r[s+3];if(0===a)return e[t+0]=o,e[t+1]=l,e[t+2]=c,void(e[t+3]=h);if(1===a)return e[t+0]=u,e[t+1]=d,e[t+2]=p,void(e[t+3]=m);if(h!==m||o!==u||l!==d||c!==p){let e=1-a;const t=o*u+l*d+c*p+h*m,i=t>=0?1:-1,n=1-t*t;if(n>Number.EPSILON){const r=Math.sqrt(n),s=Math.atan2(r,t*i);e=Math.sin(e*s)/r,a=Math.sin(a*s)/r}const r=a*i;if(o=o*e+u*r,l=l*e+d*r,c=c*e+p*r,h=h*e+m*r,e===1-a){const e=1/Math.sqrt(o*o+l*l+c*c+h*h);o*=e,l*=e,c*=e,h*=e}}e[t]=o,e[t+1]=l,e[t+2]=c,e[t+3]=h}static multiplyQuaternionsFlat(e,t,i,n,r,s){const a=i[n],o=i[n+1],l=i[n+2],c=i[n+3],h=r[s],u=r[s+1],d=r[s+2],p=r[s+3];return e[t]=a*p+c*h+o*d-l*u,e[t+1]=o*p+c*u+l*h-a*d,e[t+2]=l*p+c*d+a*u-o*h,e[t+3]=c*p-a*h-o*u-l*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,n){return this._x=e,this._y=t,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const i=e._x,n=e._y,r=e._z,s=e._order,a=Math.cos,o=Math.sin,l=a(i/2),c=a(n/2),h=a(r/2),u=o(i/2),d=o(n/2),p=o(r/2);switch(s){case"XYZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"YXZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"ZXY":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"ZYX":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"YZX":this._x=u*c*h+l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h-u*d*p;break;case"XZY":this._x=u*c*h-l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!0===t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,n=Math.sin(i);return this._x=e.x*n,this._y=e.y*n,this._z=e.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],n=t[4],r=t[8],s=t[1],a=t[5],o=t[9],l=t[2],c=t[6],h=t[10],u=i+a+h;if(u>0){const e=.5/Math.sqrt(u+1);this._w=.25/e,this._x=(c-o)*e,this._y=(r-l)*e,this._z=(s-n)*e}else if(i>a&&i>h){const e=2*Math.sqrt(1+i-a-h);this._w=(c-o)/e,this._x=.25*e,this._y=(n+s)/e,this._z=(r+l)/e}else if(a>h){const e=2*Math.sqrt(1+a-i-h);this._w=(r-l)/e,this._x=(n+s)/e,this._y=.25*e,this._z=(o+c)/e}else{const e=2*Math.sqrt(1+h-i-a);this._w=(s-n)/e,this._x=(r+l)/e,this._y=(o+c)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<1e-8?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(0===i)return this;const n=Math.min(1,t/i);return this.slerp(e,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,n=e._y,r=e._z,s=e._w,a=t._x,o=t._y,l=t._z,c=t._w;return this._x=i*c+s*a+n*l-r*o,this._y=n*c+s*o+r*a-i*l,this._z=r*c+s*l+i*o-n*a,this._w=s*c-i*a-n*o-r*l,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const i=this._x,n=this._y,r=this._z,s=this._w;let a=s*e._w+i*e._x+n*e._y+r*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=s,this._x=i,this._y=n,this._z=r,this;const o=1-a*a;if(o<=Number.EPSILON){const e=1-t;return this._w=e*s+t*this._w,this._x=e*i+t*this._x,this._y=e*n+t*this._y,this._z=e*r+t*this._z,this.normalize(),this}const l=Math.sqrt(o),c=Math.atan2(l,a),h=Math.sin((1-t)*c)/l,u=Math.sin(t*c)/l;return this._w=s*h+this._w*u,this._x=i*h+this._x*u,this._y=n*h+this._y*u,this._z=r*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),i=Math.random(),n=Math.sqrt(1-i),r=Math.sqrt(i);return this.set(n*Math.sin(e),n*Math.cos(e),r*Math.sin(t),r*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(e=0,t=0,i=0){Vector3.prototype.isVector3=!0,this.x=e,this.y=t,this.z=i}set(e,t,i){return void 0===i&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(_quaternion$1.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(_quaternion$1.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,n=this.z,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6]*n,this.y=r[1]*t+r[4]*i+r[7]*n,this.z=r[2]*t+r[5]*i+r[8]*n,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,n=this.z,r=e.elements,s=1/(r[3]*t+r[7]*i+r[11]*n+r[15]);return this.x=(r[0]*t+r[4]*i+r[8]*n+r[12])*s,this.y=(r[1]*t+r[5]*i+r[9]*n+r[13])*s,this.z=(r[2]*t+r[6]*i+r[10]*n+r[14])*s,this}applyQuaternion(e){const t=this.x,i=this.y,n=this.z,r=e.x,s=e.y,a=e.z,o=e.w,l=2*(s*n-a*i),c=2*(a*t-r*n),h=2*(r*i-s*t);return this.x=t+o*l+s*h-a*c,this.y=i+o*c+a*l-r*h,this.z=n+o*h+r*c-s*l,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,n=this.z,r=e.elements;return this.x=r[0]*t+r[4]*i+r[8]*n,this.y=r[1]*t+r[5]*i+r[9]*n,this.z=r[2]*t+r[6]*i+r[10]*n,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=clamp(this.x,e.x,t.x),this.y=clamp(this.y,e.y,t.y),this.z=clamp(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=clamp(this.x,e,t),this.y=clamp(this.y,e,t),this.z=clamp(this.z,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(clamp(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,n=e.y,r=e.z,s=t.x,a=t.y,o=t.z;return this.x=n*o-r*a,this.y=r*s-i*o,this.z=i*a-n*s,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return _vector$5.copy(this).projectOnVector(e),this.sub(_vector$5)}reflect(e){return this.sub(_vector$5.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(clamp(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,n=this.z-e.z;return t*t+i*i+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const n=Math.sin(t)*e;return this.x=n*Math.sin(i),this.y=Math.cos(t)*e,this.z=n*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),n=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=n,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=2*Math.random()-1,i=Math.sqrt(1-t*t);return this.x=i*Math.cos(e),this.y=t,this.z=i*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _vector$5=new Vector3,_quaternion$1=new Quaternion;function isPointEqual(e,t,i=1e-6){return getDistance(e,t)<i}function getDistance(e,t){return Math.sqrt(Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2)+Math.pow((e[2]||0)-(t[2]||0),2))}function intepolateScalar(e,t,i){return e+(t-e)*i}function intepolateArray3(e,t,i){return[e[0]+(t[0]-e[0])*i,e[1]+(t[1]-e[1])*i,e[2]+(t[2]-e[2])*i]}function getDirection(e,t,i){return i||(i=new Vector2),i.fromArray([t[0]-e[0],t[1]-e[1]]),i.normalize(),i}function getDirection3(e,t,i){return i||(i=new Vector3),i.fromArray([t[0]-e[0],t[1]-e[1],t[2]-e[2]]),i.normalize(),i}const arc1Scratch=new Vector3,normalScratch=new Vector3,r1Scratch=new Vector3,mcScratch=new Vector3;function calculateCircleCenter1(e,t,i){arc1Scratch.subVectors(t,e);const n=arc1Scratch.length();arc1Scratch.normalize(),normalScratch.crossVectors(i,arc1Scratch).normalize(),r1Scratch.crossVectors(normalScratch,i).normalize();let r=arc1Scratch.normalize().dot(i);r=Math.asin(r);const s=mcScratch.copy(normalScratch).cross(arc1Scratch).normalize(),a=n/2/Math.cos(r)*Math.sin(r);return e.clone().add(t).multiplyScalar(.5).add(s.multiplyScalar(a))}const dirAScratch=new Vector3,dirBScratch=new Vector3,interPointAScratch=new Vector3,interPointBScratch=new Vector3,lerpPointScratch=new Vector3,offsetScratch=new Vector3;function getRadiusCenter3D(e,t,i){const[n,r,s]=e,[a,o,l]=t,c=dirAScratch.set(r[0]-n[0],r[1]-n[1],r[2]-n[2]).normalize(),h=dirBScratch.set(o[0]-a[0],o[1]-a[1],o[2]-a[2]).normalize(),u=r[0]-n[0],d=r[1]-n[1],p=r[2]-n[2],m=1-s;interPointAScratch.set(n[0]+u*m,n[1]+d*m,n[2]+p*m);const f=o[0]-a[0],g=o[1]-a[1],_=o[2]-a[2];interPointBScratch.set(a[0]+f*l,a[1]+g*l,a[2]+_*l);const A=calculateCircleCenter1(interPointAScratch,interPointBScratch,c),v=interPointAScratch.clone().sub(A).length();lerpPointScratch.lerpVectors(interPointAScratch,interPointBScratch,i/2),offsetScratch.copy(lerpPointScratch).sub(A);const y=offsetScratch.length();offsetScratch.multiplyScalar(v/y),lerpPointScratch.copy(A).add(offsetScratch),offsetScratch.normalize();const x=c.clone().cross(h).normalize().cross(offsetScratch).normalize();return{point:lerpPointScratch.toArray(),direction:x.toArray()}}const removeDuplicatesEpsilon=CesiumMath.EPSILON10;function equalsEpsilon(e,t,i){if(e===t)return!0;if(defined$2(e)&&defined$2(t)&&Array.isArray(e)&&Array.isArray(t)){let n=!0;return e.forEach(((r,s)=>{n=n&&CesiumMath.equalsEpsilon(e[s],t[s],i)})),n}return!1}function arrayRemoveDuplicates(e,t,i){if(!e)return;t=t||!1;const n=defined$2(i),r=e.length;if(r<2)return e;let s,a,o,l=e[0],c=0,h=-1;for(s=1;s<r;++s)a=e[s],equalsEpsilon(l,a,removeDuplicatesEpsilon)?(defined$2(o)||(o=e.slice(0,s),c=s-1,h=0),n&&i.push(s)):(defined$2(o)&&(o.push(a),c=s,n&&(h=i.length)),l=a);return t&&equalsEpsilon(e[0],e[r-1],removeDuplicatesEpsilon)&&(n&&(defined$2(o)?i.splice(h,0,c):i.push(r-1)),defined$2(o)?o.length-=1:o=e.slice(0,-1)),defined$2(o)?o:e}function slerpVectors(e,t,i){const n=three.MathUtils.clamp(e.dot(t),-1,1),r=Math.acos(n)*i,s=t.clone().sub(e.clone().multiplyScalar(n)).normalize();return e.clone().multiplyScalar(Math.cos(r)).add(s.multiplyScalar(Math.sin(r)))}function numberOfPoints$2(e,t,i){let n;return n=e.isVector3?e.distanceTo(t):getDistance(e,t),Math.ceil(n/i)}const subdivideHeightsScratchArray$3=[];function subdivideHeights$3(e,t,i){const n=subdivideHeightsScratchArray$3;n.length=e;let r=0;if(t===i){for(r=0;r<e;r++)n[r]=t;return n}const s=(i-t)/e;for(let a=0;a<e;a++){const e=t+a*s;n[a]=e}return n}const cartoScratch$1=new three.Vector3,cartesianScratch$1=new three.Vector3;function extractHeights$1(e,t){const i=e.length,n=new Array(i);for(let r=0;r<i;r++)cartesianScratch$1.fromArray(e[r]),n[r]=t.cartesianToCartographic(cartesianScratch$1,cartoScratch$1).z;return n}const scaleFirst$3=new three.Vector3,scaleLast$2=new three.Vector3,carto1$3=new three.Vector3,carto2$2=new three.Vector3,cartesian$3=new three.Vector3;new three.Vector3;const ellipsoidGeodesic$3=new EllipsoidGeodesic,scratchP0=new three.Vector3,scratchP1=new three.Vector3,scratchLerpPoint=new three.Vector3;function generateCartesianArcColumbus(e,t,i,n,r,s,a){const o=scratchP0.copy(e),l=scratchP1.copy(t),c=numberOfPoints$2(e,t,i),h=subdivideHeights$3(c,n,r);let u=a;o.z=n,o.toArray(s,u),u+=3;for(let d=1;d<c;d++){scratchLerpPoint.copy(o);const e=scratchLerpPoint.lerp(l,d/c);e.z=h[d],e.toArray(s,u),u+=3}return u}function generateCartesianArc(e,t,i,n,r,s,a,o){const l=n.scaleToGeodeticSurface(e,scaleFirst$3),c=n.scaleToGeodeticSurface(t,scaleLast$2),h=numberOfPoints$2(e,t,i),u=n.cartesianToCartographic(l,carto1$3),d=n.cartesianToCartographic(c,carto2$2),p=subdivideHeights$3(h,r,s);ellipsoidGeodesic$3.setEndPoints(u,d);const m=ellipsoidGeodesic$3.surfaceDistance/h;let f=o;u.z=r;let g=n.cartographicToCartesian(u,cartesian$3);g.toArray(a,f),f+=3;for(let _=1;_<h;_++){const e=ellipsoidGeodesic$3.interpolateUsingSurfaceDistance(_*m,carto2$2);e.z=p[_],g=n.cartographicToCartesian(e,cartesian$3),g.toArray(a,f),f+=3}return f}function CubicBezierP0(e,t){const i=1-e;return i*i*i*t}function CubicBezierP1(e,t){const i=1-e;return 3*i*i*e*t}function CubicBezierP2(e,t){return 3*(1-e)*e*e*t}function CubicBezierP3(e,t){return e*e*e*t}function CubicBezier(e,t,i,n,r){return CubicBezierP0(e,t)+CubicBezierP1(e,i)+CubicBezierP2(e,n)+CubicBezierP3(e,r)}const _start=new three.Vector3,_end=new three.Vector3,_startCarto=new three.Vector3,_endCarto=new three.Vector3,_controlCarto1=new three.Vector3,_controlCarto2=new three.Vector3,_controlCartesian1=new three.Vector3,_controlCartesian2=new three.Vector3,_controlSurfaceNormal1=new three.Vector3,_controlSurfaceNormal2=new three.Vector3,ellipsoidGeodesic$2=new EllipsoidGeodesic,_getQuarter=function(e,t){let i=e[0],n=e[1];return[(3*i+t[0])/4,(3*n+t[1])/4]},_getDistance=function(e,t){let i=e[0],n=e[1],r=t[0],s=t[1];return Math.sqrt(Math.pow(i-r,2)+Math.pow(n-s,2))},_getControlPoint=function(e,t,i=1){return[..._getQuarter(e,t),_getDistance(e,t)/i]};function getECEFControlPoints(e,t,i=2){_start.fromArray(e),_end.fromArray(t),Ellipsoid.WGS84.cartesianToCartographic(_start,_startCarto),Ellipsoid.WGS84.cartesianToCartographic(_end,_endCarto),ellipsoidGeodesic$2.setEndPoints(_startCarto,_endCarto);const n=ellipsoidGeodesic$2.surfaceDistance,r=n/i;ellipsoidGeodesic$2.interpolateUsingSurfaceDistance(n/3,_controlCarto1),Ellipsoid.WGS84.cartographicToCartesian(_controlCarto1,_controlCartesian1),Ellipsoid.WGS84.geodeticSurfaceNormalCartographic(_controlCarto1,_controlSurfaceNormal1),ellipsoidGeodesic$2.interpolateUsingSurfaceDistance(2*n/3,_controlCarto2),Ellipsoid.WGS84.cartographicToCartesian(_controlCarto2,_controlCartesian2),Ellipsoid.WGS84.geodeticSurfaceNormalCartographic(_controlCarto2,_controlSurfaceNormal2);const s=_controlCartesian1.addScaledVector(_controlSurfaceNormal1,r),a=_controlCartesian2.addScaledVector(_controlSurfaceNormal2,r);return[s.toArray(),a.toArray()]}function getPlaneControlPoint(e,t,i){return[_getControlPoint(e,t,i),_getControlPoint(t,e,i)]}function getBezierPoint(e,t,i,n,r){return[CubicBezier(e,t[0],i[0],n[0],r[0]),CubicBezier(e,t[1],i[1],n[1],r[1]),CubicBezier(e,t[2],i[2],n[2],r[2])]}function getCurve(e,t){const{divisions:i=20,heightRatio:n=2,isGlobe:r}=t,[s,a]=[e[0],e[e.length-1]];let o=r?getECEFControlPoints:getPlaneControlPoint;const[l,c]=o(s,a,n),h=[];for(let u=0;u<=i;u++){const e=u/i;h.push(getBezierPoint(e,s,l,c,a))}return h}const scaleFirst$2=new three.Vector3,scaleLast$1=new three.Vector3,carto1$2=new three.Vector3,carto2$1=new three.Vector3,cartesian$2=new three.Vector3,lastPoint$1=new three.Vector3,ellipsoidGeodesic$1=new EllipsoidGeodesic,tempTrans$1=new three.Vector3,scratchPrevPosition=new three.Vector3,scratchPosition$2=new three.Vector3,scratchPosition1=new three.Vector3,scratchPosition2=new three.Vector3,scratchNextPosition=new three.Vector3,scratchDiff=new three.Vector3,p0Scratch$2=new three.Vector3,p1Scratch$4=new three.Vector3,MERCATOR_LENGTH=20037508.3427892;class PolylineGeometry extends three.BufferGeometry{constructor(e){super(),__publicField(this,"isFatLineGeometry",!0),this.parameters=e,this._granularity=e.granularity||.5*CesiumMath.RADIANS_PER_DEGREE,this._needsUpdate=!1,this._needsCounter=!1,this._height=e.height||0,this._isCurve=e.isCurve||!1,this._flags={lastFlip:-1,started:!1,normal:null,totalDistance:0}}setData(e){if(this._needsUpdate=!0,this._isCurve&&e.position.length>0&&Array.isArray(e.position[0])&&Array.isArray(e.position[0][0])&&!Array.isArray(e.position[0][0][0]))for(let t=0;t<e.position.length;t++){const i=e.position[t];e.position[t]=getCurve(i,{isGlobe:this.engine.map.isGlobe})}this.cachedData=e,(this.parameters.dashed||this.parameters.enableAnimation||this.parameters.mapSrc||this.parameters.map)&&(this._needsCounter=!0),this.updateGeometry(),this.needsUpdate=!1}updateGeometryColumbus(e){const t=[],i=[],n=[],r=[],s=[],a=[],o=[],l=[];let c=0;const h=this.parameters.vertexColors;for(let u=0,d=e.position.length;u<d;u++){let d=arrayRemoveDuplicates(e.position[u]);if(d.length<2)continue;const p=e.index[u],m=this.parameters.vertexColors?colorToArr4(e.color[u]):[1,1,1,1];d=d.map((e=>[e[0],e[1],e[2]+this._height||0]));const f=d.map((e=>e[2]+this._height)),g=MERCATOR_LENGTH*(this._granularity/Math.PI),_=this.generateArcColumbus({positions:d,minDistance:g,height:f});this.packAttribute(_,t,r,s,a,l);const A=_.length/3,v=A-1;for(let e=0;e<v;e++)i.push(c,c+2,c+1),i.push(c+1,c+2,c+3),c+=4;o.push(...new Array(2*(2*A-2)).fill(p)),h&&n.push(...new Array(6*(2*A-2)).fill(m).flat())}this.cachedPositions=t,this.cachedPrevs=r,this.cachedNexts=s,this.setAttribute("position",new three.Float32BufferAttribute(t,3)),this.setAttribute("prev",new three.Float32BufferAttribute(r,3)),this.setAttribute("expandAndPrev",new three.Float32BufferAttribute(l,2)),this.setAttribute("next",new three.Float32BufferAttribute(s,3)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(o,1)),this.setAttribute("uv",new three.Float32BufferAttribute(a,2)),h&&this.setAttribute("aColor",new three.Float32BufferAttribute(n,4)),this.setIndex(i)}updateGeometry3D(e){const t=[],i=[],n=[],r=[],s=[],a=[],o=[],l=[],c=this._granularity,h=this.engine.map.map.ellipsoid||Ellipsoid.WGS84,u=CesiumMath.chordLength(c,h.maximumRadius);let d=0;const p=this.parameters.vertexColors;for(let m=0,f=e.position.length;m<f;m++){let c=arrayRemoveDuplicates(e.position[m]);if(c.length<2)continue;const f=e.index[m],g=this.parameters.vertexWidths?e.lineWidth[m]:this.parameters.lineWidth,_=this.parameters.vertexColors?colorToArr4(e.color[m]):[1,1,1,1],A=extractHeights$1(c,h).map((e=>e+this._height)),v=this.generateArc({positions:c,minDistance:u,ellipsoid:h,height:A,width:g}),y=t.length;this.packAttribute(v,t,r,s,a,l);const x=v.length/3-1;for(let e=0;e<x;e++)i.push(d,d+2,d+1),i.push(d+1,d+2,d+3),d+=4;o.push(...new Array((t.length-y)/3).fill(f)),p&&n.push(...new Array(t.length-y).fill(_).flat())}this.cachedPositions=t,this.cachedPrevs=r,this.cachedNexts=s,this.setAttribute("position",new three.Float32BufferAttribute(t,3)),this.setAttribute("prev",new three.Float32BufferAttribute(r,3)),this.setAttribute("next",new three.Float32BufferAttribute(s,3)),this.setAttribute("expandAndPrev",new three.Float32BufferAttribute(l,2)),this.setAttribute("uv",new three.Float32BufferAttribute(a,2)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(o,1)),p&&this.setAttribute("aColor",new three.Float32BufferAttribute(n,4)),this.setIndex(i)}updateGeometry(){const e=this.cachedData;this.engine.map.isGlobe?this.updateGeometry3D(e):this.updateGeometryColumbus(e)}packAttribute(e,t,i,n,r,s){const a=e.length/3,o=new Float32Array(a);for(let c=1;c<a;c++){const t=e.slice(3*c,3*c+3),i=e.slice(3*(c-1),3*(c-1)+3);o[c]=o[c-1]+getDistance(t,i)}const l=o[o.length-1];for(let c=0;c<a;c++){scratchPosition$2.fromArray(e,3*c),0===c?(scratchNextPosition.fromArray(e,3),scratchDiff.subVectors(scratchPosition$2,scratchNextPosition),scratchPrevPosition.addVectors(scratchPosition$2,scratchDiff)):scratchPrevPosition.fromArray(e,3*(c-1)),c===a-1?(scratchPosition1.fromArray(e,3*(a-1)),scratchPosition2.fromArray(e,3*(a-2)),scratchDiff.subVectors(scratchPosition1,scratchPosition2),scratchNextPosition.addVectors(scratchPosition1,scratchDiff)):scratchNextPosition.fromArray(e,3*(c+1));const h=o[c]/l,u=c===a-1?2:4;for(let e=0===c?2:0;e<u;e++){t.push(scratchPosition$2.x,scratchPosition$2.y,scratchPosition$2.z),i.push(scratchPrevPosition.x,scratchPrevPosition.y,scratchPrevPosition.z),n.push(scratchNextPosition.x,scratchNextPosition.y,scratchNextPosition.z);const a=e-2<0?-1:1;s.push(e%2*2-1),s.push(a);const o=e%2;r.push(h,o)}}}generateArcColumbus(e){e||(e={});const t=e.positions,i=t.length;let n=e.minDistance,r=e.height||0;const s=Array.isArray(r);defined$2(n)||(n=MERCATOR_LENGTH*(this._granularity/Math.PI));let a,o=0;for(a=0;a<i-1;a++)o+=numberOfPoints$2(t[a],t[a+1],n);let l=0;const c=new Array(3*(o+1));for(a=0;a<i-1;a++){p0Scratch$2.fromArray(t[a]),p1Scratch$4.fromArray(t[a+1]);const e=s?r[a]:r,i=s?r[a+1]:r;l=generateCartesianArcColumbus(p0Scratch$2,p1Scratch$4,n,e,i,c,l)}return lastPoint$1.set(...t[i-1]),lastPoint$1.z=s?r[i-1]:r,lastPoint$1.toArray(c,l),l+=3,c}generateArc(e){e||(e={});const t=e.positions,i=t.length,n=e.ellipsoid||Ellipsoid.WGS84;let r=e.height||0;const s=Array.isArray(r);if(i<1)return[];if(1===i){tempTrans$1.fromArray(t[0]);const e=n.scaleToGeodeticSurface(tempTrans$1,scaleFirst$2);if(r=s?r[0]:r,0!==r){const t=n.geodeticSurfaceNormal(e,cartesian$2);Cartesian3.multiplyByScalar(t,r,t),Cartesian3.add(e,t,e)}return[e.x,e.y,e.z]}let a=e.minDistance;defined$2(a)||(a=CesiumMath.chordLength(this._granularity,n.maximumRadius));let o,l=0;for(let p=0;p<i-1;p++)l+=numberOfPoints$2(t[p],t[p+1],a);const c=new Array(3*(l+1));let h=0;const u=new three.Vector3;for(o=0;o<i-1;o++){p0Scratch$2.fromArray(t[o]),p1Scratch$4.fromArray(t[o+1]),u.crossVectors(p0Scratch$2,p1Scratch$4).normalize();const e=s?r[o]:r,i=s?r[o+1]:r;h=generateCartesianArc(p0Scratch$2,p1Scratch$4,a,n,e,i,c,h)}lastPoint$1.set(...t[i-1]);const d=n.cartesianToCartographic(lastPoint$1,carto1$2);d.z=s?r[i-1]:r;return n.cartographicToCartesian(d,cartesian$2).toArray(c,h),h+=3,c}generateCartesianArc(e,t,i,n,r,s,a,o,l,c,h,u){const d=n.scaleToGeodeticSurface(e,scaleFirst$2),p=n.scaleToGeodeticSurface(t,scaleLast$1),m=numberOfPoints$2(e,t,i),f=n.cartesianToCartographic(d,carto1$2),g=n.cartesianToCartographic(p,carto2$1),_=subdivideHeights$3(m,r,s);ellipsoidGeodesic$1.setEndPoints(f,g);const A=ellipsoidGeodesic$1.surfaceDistance/m;let v=o;f.z=r;const y=(new three.Vector3).copy(l).negate();let x=n.cartographicToCartesian(f,cartesian$2);x.toArray(a,v),l.toArray(c,v),h.push(u),v+=3,x.toArray(a,v),y.toArray(c,v),h.push(u),v+=3;for(let b=1;b<m;b++){const e=ellipsoidGeodesic$1.interpolateUsingSurfaceDistance(b*A,carto2$1);e.z=_[b],x=n.cartographicToCartesian(e,cartesian$2),x.toArray(a,v),l.toArray(c,v),h.push(u),v+=3,x.toArray(a,v),y.toArray(c,v),h.push(u),v+=3}return v}get needsUpdate(){return this._needsUpdate}set needsUpdate(e){this._needsUpdate=e}}const vertexShader$r="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n#else\n    uniform vec3 color;\n#endif\n\nattribute vec3 prev;\nattribute vec3 next;\nattribute vec2 expandAndPrev;\n\nuniform float elapsedTime;\nuniform bool vertexColors;\nuniform float lineWidth;\nuniform float height;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 viewportTransform;\nuniform mat4 viewportOrthographicTransform;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vZoomUnits;\nvarying vec2 vDir;\n\n#ifdef USE_DASH\nvarying float vPolylineAngle;\n#endif\n\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvec2 project(vec4 coord) {\n    vec2 screen = coord.xy / coord.w;\n    vec2 clip = (screen.xy + 1.0) * 0.5;\n    return clip * resolution;\n}\n\nvec4 unproject(vec2 projected, float z, float w) {\n    vec2 clip = projected / resolution;\n    vec2 screen = clip * 2.0 - 1.0;\n    return vec4(screen * w, z, w);\n}\n\nvec4 eyeToWindowCoordinates(vec4 positionEC) {\n    vec4 q = projectionMatrix * positionEC;\n    q.xyz /= q.w;\n    q.xyz = (viewportTransform * vec4(q.xyz, 1.0)).xyz;\n\n    return q;\n\n}\n\nbool equalsEpsilon(vec3 left, vec3 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\n\nvoid clipLineSegmentToNearPlane(\n    vec3 p0,\n    vec3 p1,\n    out vec4 positionWC,\n    out bool clipped,\n    out bool culledByNearPlane,\n    out vec4 clippedPositionEC)\n{\n    culledByNearPlane = false;\n    clipped = false;\n\n    vec3 p0ToP1 = p1 - p0;\n    float magnitude = length(p0ToP1);\n    vec3 direction = normalize(p0ToP1);\n\n    float endPoint0Distance = cameraNear + p0.z;\n\n    float denominator = -direction.z;\n\n    if (endPoint0Distance > 0.0 && abs(denominator) < 0.0000001)\n    {\n        culledByNearPlane = true;\n    }\n    else if (endPoint0Distance > 0.0)\n    {\n        float t = endPoint0Distance / denominator;\n        if (t < 0.0 || t > magnitude)\n        {\n            culledByNearPlane = true;\n        }\n        else\n        {\n            // Segment crosses the near plane, update p0 to lie exactly on it.\n            p0 = p0 + t * direction;\n            p0.z = min(p0.z, -cameraNear);\n\n            clipped = true;\n        }\n    }\n\n    clippedPositionEC = vec4(p0, 1.0);\n    positionWC = eyeToWindowCoordinates(clippedPositionEC);\n}\n\nconst float piOverFour = 0.7853981633974483;\n\nvoid main() {\n    #include <begin_vertex>\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #else\n        vColor = vec4(color, 1.0);\n    #endif\n\n    vec4 prevEC = modelViewMatrix * vec4(prev, 1.0);\n    vec4 nextEC = modelViewMatrix * vec4(next, 1.0);\n    vec4 positionEC = modelViewMatrix * vec4(transformed, 1.0);\n\n    float direction = expandAndPrev.x;\n    bool usePrevious = expandAndPrev.y < 0.0;\n\n    #ifdef USE_DASH\n        vec4 positionWindow = eyeToWindowCoordinates(positionEC);\n        vec4 previousWindow = eyeToWindowCoordinates(prevEC);\n        vec4 nextWindow = eyeToWindowCoordinates(nextEC);\n\n        vec2 lineDir;\n        if (usePrevious) {\n            lineDir = normalize(positionWindow.xy - previousWindow.xy);\n        }\n        else {\n            lineDir = normalize(nextWindow.xy - positionWindow.xy);\n        }\n        float angle = atan(lineDir.x, lineDir.y) - 1.570796327;\n\n        angle = floor(angle / piOverFour + 0.5) * piOverFour;\n        vPolylineAngle = angle;\n    #endif\n\n    vec4 clippedPrevWC, clippedPrevEC;\n    bool prevSegmentClipped, prevSegmentCulled;\n    clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);\n\n    vec4 clippedNextWC, clippedNextEC;\n    bool nextSegmentClipped, nextSegmentCulled;\n    clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);\n\n    bool segmentClipped, segmentCulled;\n    vec4 clippedPositionWC, clippedPositionEC;\n    clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC);\n    \n    vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);\n    vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);\n\n    // 如果片段被裁剪，不能使用其来计算方向\n    if (prevSegmentCulled)\n    {\n        directionToPrevWC = -directionToNextWC;\n    }\n    else if (nextSegmentCulled)\n    {\n        directionToNextWC = -directionToPrevWC;\n    }\n\n    vec2 thisSegmentForwardWC;\n    vec2 otherSegmentForwardWC;\n    if (usePrevious)\n    {\n        thisSegmentForwardWC = -directionToPrevWC;\n        otherSegmentForwardWC = directionToNextWC;\n    }\n    else\n    {\n        thisSegmentForwardWC = directionToNextWC;\n        otherSegmentForwardWC =  -directionToPrevWC;\n    }\n\n    vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x);\n    vec2 leftWC = thisSegmentLeftWC;\n    float expandWidth = lineWidth * 0.5;\n\n    // 根据夹角偏移顶点\n    if (\n        !equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), 1.0)\n        && !equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), 1.0))\n    {\n\n        vec2 otherSegmentLeftWC = vec2(-otherSegmentForwardWC.y, otherSegmentForwardWC.x);\n        vec2 leftSumWC = thisSegmentLeftWC + otherSegmentLeftWC;\n        float leftSumLength = length(leftSumWC);\n        leftWC = leftSumLength < 0.000001 ? thisSegmentLeftWC : (leftSumWC / leftSumLength);\n\n        vec2 u = -thisSegmentForwardWC;\n        vec2 v = leftWC;\n        float sinAngle = abs(u.x * v.y - u.y * v.x);\n        expandWidth = clamp(expandWidth / sinAngle, 0.0, lineWidth * 2.0);\n    }\n\n    vec2 pos = clippedPositionWC.xy + (leftWC * expandWidth) * direction;\n    vec4 windowCoordinates = vec4(pos, -clippedPositionWC.z, 1.0) * (projectionMatrix * clippedPositionEC).w;\n\n    vec4 finalPosition = viewportOrthographicTransform * windowCoordinates;\n\n    gl_Position = finalPosition;\n\n    #include <beginnormal_vertex>\n    #include <fog_vertex>\n    #include <logdepthbuf_vertex>\n}",fragmentShader$p="#define GLSLIFY 1\n#include <common>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\nuniform float lineWidth;\nuniform float opacity;\nuniform float alphaTest;\nuniform float elapsedTime;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vZoomUnits;\n\n#ifdef USE_DASH\nuniform float pixelRatio;\nvarying float vPolylineAngle;\n\nconst float maskLength = 16.0;\n\nmat2 rotate(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n#endif\n\nvoid main() {\n\n    vec4 c = vColor;\n    // TODO\n    // 支持虚线和贴图\n    #ifdef USE_DASH\n        vec2 pos = rotate(vPolylineAngle) * gl_FragCoord.xy;\n\n        float oddOrEven = fract( pos.x / (20.0 * pixelRatio));\n        if (oddOrEven > 0.5) {\n            discard;\n        }\n    #endif\n    c *= opacity;\n    gl_FragColor = c;\n\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}",uniforms$q=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,emissiveUniforms,{lineWidth:{value:10},color:{value:[0,1,1]},opacity:{value:1},resolution:{value:new three.Vector2(1,1)},dashArray:{value:20},dashOffset:{value:0},dashRatio:{value:.5},alphaTest:{value:0},vertexColors:{value:!1},elapsedTime:{value:0},isEmissive:{value:!1},viewportTransform:{value:new three.Matrix4},viewportOrthographicTransform:{value:new three.Matrix4},cameraNear:{value:0},cameraFar:{value:0}}]);class PolylineMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="PolylineMaterial",this.isPolylineMaterial=!0,this.fog=!0,this.fragmentShader=fragmentShader$p,this.side=three.DoubleSide,this.vertexShader=vertexShader$r,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$q)),defineMaterialNormalProperties(this,["lineWidth","opacity","dashArray","dashOffset","dashRatio","alphaTest","isEmissive","cameraNear","cameraFar"]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["dashed","USE_DASH"]]),defineMaterialEmissiveProperties(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}dispose(){this.uniforms.map&&this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const _inverseMatrix$1=new three.Matrix4,_ray$2=new three.Ray,_sphere$3=new three.Sphere,_viewportTransform$1=new three.Matrix4,_viewportOrthographicTransform=new three.Matrix4;class PolylineInternal extends GeoMesh{constructor(e){super(),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"_resolution",new three.Vector2),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"color"),__publicField(this,"vertexColors"),__publicField(this,"emissive"),__publicField(this,"map"),__publicField(this,"opacity"),__publicField(this,"alphaTest"),__publicField(this,"dashed"),__publicField(this,"dashArray"),__publicField(this,"dashOffset"),__publicField(this,"dashRatio"),__publicField(this,"makeGeometryOffsetPosition",(e=>{if(!this._enableRtc)return;const t=e.boundingSphere&&e.boundingSphere.center;if(!t)return this._cachedRtc=[0,0,0],void this.updateTransform();const{x:i,y:n,z:r}=t,s=e.cachedPositions,a=e.cachedPrevs,o=e.cachedNexts;this.makePostionArrayOffset(e.attributes.position.array,i,n,r,s),this.makePostionArrayOffset(e.attributes.prev.array,i,n,r,a),this.makePostionArrayOffset(e.attributes.next.array,i,n,r,o),this.geometry.computeBoundingSphere(),this._cachedRtc=[i,n,r],this.updateTransform()})),this.parameters=e,this.defineMaterialProxyProperties(["height","transparent","opacity","alphaTest","dashed","dashArray","dashOffset","dashRatio","color","vertexColors","vertexWidths","emissive"])}getDefaultParams(){return{lineWidth:4}}computeViewportOrthographicTransform(e,t,i,n){t=t||0,i=i||1;const r=e.x||0,s=e.y||0,a=r+e.width||0,o=s+e.height|0;let l=1/(a-r),c=1/(o-s),h=1/(i-t);const u=-(a+r)*l,d=-(o+s)*c,p=-(i+t)*h;l*=2,c*=2,h*=-2;const m=n.elements;return m[0]=l,m[1]=0,m[2]=0,m[3]=0,m[4]=0,m[5]=c,m[6]=0,m[7]=0,m[8]=0,m[9]=0,m[10]=h,m[11]=0,m[12]=u,m[13]=d,m[14]=p,m[15]=1,n}computeViewportTransformation(e,t,i,n){const r=e.x||0,s=e.y||0;t=t||0;const a=.5*(e.width||0),o=.5*(e.height||0),l=.5*((i=i||1)-t),c=a,h=o,u=l,d=r+a,p=s+o,m=t+l,f=n.elements;return f[0]=c,f[1]=0,f[2]=0,f[3]=0,f[4]=0,f[5]=h,f[6]=0,f[7]=0,f[8]=0,f[9]=0,f[10]=u,f[11]=0,f[12]=d,f[13]=p,f[14]=m,f[15]=1,n}initObject(){const{lineJoin:e,lineCap:t,isCurve:i,flat:n,keepSize:r,...s}=this.parameters;(this.geometry=new PolylineGeometry(this.parameters)).engine=this.engine;(this.material=new PolylineMaterial(s)).setCommonUniforms(this.engine.rendering.uniforms)}onBeforeScenePrepareRenderHook(){this._cameraNear!==this.engine.camera.near&&(this.material.uniforms.cameraNear.value=this.engine.camera.near,this._cameraNear=this.engine.camera.near),this._cameraFar!==this.engine.camera.far&&(this.material.uniforms.cameraFar.value=this.engine.camera.far,this._cameraFar=this.engine.camera.far);const{x:e,y:t}=this.engine.rendering.uniforms.resolution.value;this._resolution.x===e&&this._resolution.y===t||(this.material.uniforms.viewportTransform.value.copy(this.computeViewportTransformation({width:this.engine.rendering.uniforms.resolution.value.x,height:this.engine.rendering.uniforms.resolution.value.y},0,1,_viewportTransform$1)),this.material.uniforms.viewportOrthographicTransform.value.copy(this.computeViewportOrthographicTransform({width:this.engine.rendering.uniforms.resolution.value.x,height:this.engine.rendering.uniforms.resolution.value.y},0,1,_viewportOrthographicTransform)),this._resolution.set(e,t))}_updateData(){const e=this.dataSource.data;this.geometry.setData(e),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry),this.geometry.computeBoundingBox(),this.needsUpdate=!1}afterGeometryUpdate(){this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry),this.geometry.computeBoundingBox()}get lineWidth(){return this.parameters.lineWidth}set lineWidth(e){this.parameters.lineWidth=e}raycast(e,t){if(!this.visible)return;const i=this.geometry,n=this.matrixWorld,r=e.params.Line.threshold,s=i.drawRange;let a=this.lineWidth/2;if(a*=this.material.uniforms.zoomUnits.value,null===i.boundingSphere&&i.computeBoundingSphere(),_sphere$3.copy(i.boundingSphere),_sphere$3.applyMatrix4(n),_sphere$3.radius+=a,!1===e.ray.intersectsSphere(_sphere$3))return;_inverseMatrix$1.copy(n).invert(),_ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$1);const o=a/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=new three.Vector3,h=new three.Vector3,u=new three.Vector3,d=new three.Vector3;if(i.isBufferGeometry){const n=i.index,r=i.attributes,a=r.position,o=r.objectIndex;if(null!==n){for(let i=Math.max(0,s.start),r=Math.min(n.count,s.start+s.count)-1;i<r;i+=2){const r=n.getX(i),s=n.getX(i+1);c.fromBufferAttribute(a,r),h.fromBufferAttribute(a,s);if(_ray$2.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const p=e.ray.origin.distanceTo(d);if(p<e.near||p>e.far)continue;o.getX(r)===o.getX(s)&&t.push({distance:p,point:u.clone().applyMatrix4(this.matrixWorld),index:o.getX(r),face:null,faceIndex:null,object:this})}}else{for(let i=Math.max(0,s.start),n=Math.min(a.count,s.start+s.count)-1;i<n;i+=2){c.fromBufferAttribute(a,i),h.fromBufferAttribute(a,i+1);if(_ray$2.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const n=e.ray.origin.distanceTo(d);n<e.near||n>e.far||t.push({distance:n,point:u.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}}}e.params.Line.threshold=r}}function computeNormal(e){return new three.Vector2(-e.y,e.x)}function computeMiter(e,t){let i=new three.Vector2;return i.addVectors(e,t),i.normalize(),computeNormal(i)}function vector2RotateTo(e,t){let i=e.x*t.x+e.y*t.y,n=Math.sqrt(e.x*e.x+e.y*e.y),r=Math.sqrt(t.x*t.x+t.y*t.y),s=Math.acos(i/(n*r));return e.x*t.y-t.x*e.y<0&&(s=2*Math.PI-s),s}function rotatePoint(e,t,i){const n=e.clone().sub(t),r=Math.cos(i),s=Math.sin(i),a=n.x*r+n.y*s,o=-n.x*s+n.y*r,l=new three.Vector2(a,o);return l.add(t),l}function isAOConcaveAngle(e,t,i){const n=[i[0]-t[0],i[1]-t[1]],r=[e[0]-t[0],e[1]-t[1]];return(n[0]*r[0]+n[1]*r[1])/Math.sqrt((n[0]*n[0]+n[1]*n[1])*(r[0]*r[0]+r[1]*r[1]))>-.866&&-n[1]*r[0]+n[0]*r[1]<0}class ShadowVolumeLineGeometry extends three.BufferGeometry{constructor(){super(...arguments),__publicField(this,"_volumeSegmentLines",((e,t,i,n,r,s,a,o,l,c,h)=>{let u=0,d=new three.Vector2;const p=[a[0],a[1]];let m=getDirection([s[0],s[1]],p);if(h&&(d=computeNormal(m),this._volumeExtrusions(e,t,n,i,s,d,l)),o){let r=getDirection(p,[o[0],o[1]]),s=new three.Vector2;s.addVectors(m,r),s.normalize();const c=computeMiter(m,r),h=computeNormal(m),d=Math.min(l,l/c.dot(h));this._volumeExtrusions(e,t,n,i,a,c,d),u+=2}else d=computeNormal(m),this._volumeExtrusions(e,t,n,i,a,d,l),u+=2;return u})),__publicField(this,"_volumeExtrusions",((e,t,i,n,r,s,a)=>{i.push(s.x,s.y,0,-s.x,-s.y,0),e.push(r[0]+s.x*a/2,r[1]+s.y*a/2,r[2]),t.push(r[0]-s.x*a/2,r[1]-s.y*a/2,r[2]),n.push(a,a)}))}createVolumeGeometry(e,t){let i=this.parameters.lineWidth*t,n=[];for(let r=0;r<e.length;r++){const{vertices:t}=this.lineToShadowVolumeMesh(e[r],i);n.push([t])}return n}lineToShadowVolumeMesh(e,t){let i=0,n=null,r=null,s=null,a=null;const o=[],l=[],c=[],h=[],u=[],d=[];let p=!0;for(let g=1,_=e.length-1;g<=_;g++){if(n=a||e[g-1],r=e[g],s=e[g+1],s&&isPointEqual(r,s)){a=n;continue}const o=this._volumeSegmentLines(u,d,h,l,c,n,r,s,t,i,p);-1!==o&&(i+=o,a=null),p=!1}const m=this.conversion(u,3),f=this.conversion(d,3);return o.push(...m.concat(f.reverse())),o.push(o[0]),{vertices:o,indices:c,normals:l,widths:h}}conversion(e,t){let i=e.length,n=i%t===0?i/t:Math.floor(i/t+1),r=[];for(let s=0;s<n;s++){let i=e.slice(s*t,s*t+t);r.push(i)}return r}}const scaleFirst$1=new three.Vector3,scaleLast=new three.Vector3,carto1$1=new three.Vector3,carto2=new three.Vector3,carto3=new three.Vector3,cartoNext=new three.Vector3,cartesian$1=new three.Vector3,cartesian2=new three.Vector3,cartesianOffset=new three.Vector3,cartesianPrev=new three.Vector3,cartesianNext=new three.Vector3,lastMiterScratch=new three.Vector3;new three.Vector3;const negativeNormalScratch=new three.Vector3,negativeMiterScratch=new three.Vector3,ellipsoidGeodesic=new EllipsoidGeodesic;function numberOfPoints$1(e,t,i){let n;return n=e.isVector3?e.distanceTo(t):getDistance(e,t),Math.ceil(n/i)}const subdivideHeightsScratchArray$2=[],subdivideHeights$2=(e,t,i)=>{const n=subdivideHeightsScratchArray$2;n.length=e;let r=0;if(t===i){for(r=0;r<e;r++)n[r]=t;return n}const s=(i-t)/e;for(let a=0;a<e;a++){const e=t+a*s;n[a]=e}return n};function direction$1(e,t,i){return i.copy(e).sub(t),i.normalize(),i}function tangentDirection(e,t,i,n){return direction$1(e,t,n),n.cross(i).normalize(),n.cross(i).normalize(),n}const cosine90=0,forwardScratch=new three.Vector3,toPreviousScratch=new three.Vector3,toNextScratch=new three.Vector3;function computeVertexMiterNormal(e,t,i,n,r){const s=tangentDirection(e,t,n,toPreviousScratch),a=tangentDirection(i,t,n,toNextScratch);r.copy(s).add(a).normalize();const o=forwardScratch.copy(n).cross(r),l=a.dot(o)<cosine90;return l&&r.negate(),{miter:r,isFlip:l}}const p0Scratch$1=new three.Vector3,p1Scratch$3=new three.Vector3,p2Scratch$2=new three.Vector3;class FatLineGeometry extends ShadowVolumeLineGeometry{constructor(e){super(),__publicField(this,"isFatLineGeometry",!0),__publicField(this,"_segmentLines",((e,t,i,n,r,s,a,o,l,c,h,u,d,p,m,f,g)=>{let _=0,A=new three.Vector2,v=new three.Vector2,y=new three.Vector2;const x="square"===this.parameters.lineCap,b="round"===this.parameters.lineCap,S="bevel"===this.parameters.lineJoin,C="round"===this.parameters.lineJoin,T=[h[0],h[1]],E=[c[0],c[1]];let M=this.getFlatDirection(E,T),w=0;this._needsCounter&&(w=getDistance(h,c),this._flags.totalDistance+=w),this._flags.normal||(this._flags.normal=new three.Vector2,this._flags.normal=computeNormal(M));let I,P,R,B=-1;if(!this._flags.started)if(this._flags.started=!0,I=this._flags.totalDistance-w,R=this._flags.totalDistance,P=I-w,x){const l=new three.Vector2,u=new three.Vector2;l.addVectors(this._flags.normal,M),u.subVectors(this._flags.normal,M),a.push(u.x,u.y,0,-l.x,-l.y,0),e.push(c[0],c[1],c[2],c[0],c[1],c[2]);const g=[h[0]-c[0],h[1]-c[1],h[2]-c[2]];m.push(c[0]+g[0],c[1]+g[0],c[2]+g[0],c[0]+g[0],c[1]+g[0],c[2]+g[0]),f.push(h[0],h[1],h[2],h[0],h[1],h[2]),t.push(this._flags.totalDistance-w,0,this._flags.totalDistance-w,1),i.push(I,I),n.push(P,R,P,R),s.push(d,B,d,B),r.push(0,0),this.parameters.vertexColors&&o.push(p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3])}else if(b){const u=M.clone();u.negate();const A=new three.Vector2;A.subVectors(this._flags.normal,M),A.normalize();const v=new three.Vector2;v.addVectors(this._flags.normal,M),v.normalize();const y=this._flags.normal.clone(),x=this._flags.normal.clone();x.negate(),a.push(u.x,u.y,0),a.push(A.x,A.y,0),a.push(-v.x,-v.y,0),a.push(y.x,y.y,0),a.push(x.x,x.y,0);const b=[h[0]-c[0],h[1]-c[1],h[2]-c[2]];for(let a=0;a<5;a++)e.push(c[0],c[1],c[2]),m.push(c[0]+b[0],c[1]+b[1],c[2]+b[2]),f.push(h[0],h[1],h[2]),s.push(d,B),t.push(this._flags.totalDistance-w,0),i.push(I),n.push(P,R),r.push(0),this.parameters.vertexColors&&o.push(p[0],p[1],p[2],p[3]);l.push(g+0,g+2,g+1,g+1,g+2,g+3,g+3,g+2,g+4),_+=3,g+=3}else this._extrusions(e,a,t,i,n,r,s,o,c,c,h,this._flags.normal,I,P,R,d,B,!0,p,m,f);if(l.push(...-1===this._flags.lastFlip?[g+0,g+1,g+2]:[g+1,g+0,g+2]),I=this._flags.totalDistance,P=this._flags.totalDistance-w,u){R=I+getDistance(h,u)}else R=I+w;if(u){const x=[u[0],u[1]];v=this.getFlatDirection(T,x),y.addVectors(M,v),y.normalize();const b=computeMiter(M,v),E=computeNormal(M),w=d/b.dot(E);let D=y.dot(this._flags.normal)>0?-1:1,F=S;if(!F&&"miter"===this.parameters.lineJoin){Math.abs(w)>(this.parameters.miterLimit||2*d)&&(F=!0)}if(F){const y=Math.min(2*d,Math.abs(w));a.push(this._flags.normal.x*D,this._flags.normal.y*D,0),a.push(-b.x*D,-b.y*D,0),e.push(h[0],h[1],h[2],h[0],h[1],h[2]),m.push(c[0],c[1],c[2],c[0],c[1],c[2]),f.push(u[0],u[1],u[2],u[0],u[1],u[2]),s.push(d,1,y,1),i.push(I,I),n.push(P,R,P,R),r.push(0,0),l.push(...this._flags.lastFlip===-D?-1===this._flags.lastFlip?[g+2,g+1,g+3]:[g+1,g+2,g+3]:-1===this._flags.lastFlip?[g+0,g+2,g+3]:[g+2,g+0,g+3]),A=computeNormal(v),this._flags.normal.copy(A),a.push(this._flags.normal.x*D,this._flags.normal.y*D,0),e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(u[0],u[1],u[2]),s.push(d,1),i.push(I),n.push(P,R),r.push(0),a.push(-b.x*D,-b.y*D,0),e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(u[0],u[1],u[2]),s.push(y,B),i.push(I),n.push(P,R),r.push(0),a.push(this._flags.normal.x*D,this._flags.normal.y*D,0),e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(u[0],u[1],u[2]),s.push(d,B),i.push(I),n.push(P,R),r.push(0),l.push(...1===D?[g+2,g+3,g+4]:[g+3,g+2,g+4]),this._flipedUV(t,this._flags.totalDistance,D,!0),this.parameters.vertexColors&&o.push(p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3]),_+=5}else if(C){const y=Math.min(2*d,Math.abs(w));a.push(this._flags.normal.x*D,this._flags.normal.y*D,0),e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(u[0],u[1],u[2]),s.push(d,1),i.push(I),n.push(P,R),r.push(0),a.push(b.x*D,b.y*D,0),e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(u[0],u[1],u[2]),s.push(d,1),i.push(I),n.push(P,R),r.push(0),a.push(b.x*D,b.y*D,0),e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(u[0],u[1],u[2]),s.push(d,B),i.push(I),n.push(P,R),r.push(0),a.push(-b.x*D,-b.y*D,0),e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(u[0],u[1],u[2]),s.push(y,1),i.push(I),n.push(P,R),r.push(0),a.push(-b.x*D,-b.y*D,0),e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(u[0],u[1],u[2]),s.push(y,B),i.push(I),n.push(P,R),r.push(0),l.push(...this._flags.lastFlip===-D?-1===this._flags.lastFlip?[g+2,g+1,g+5,g+2,g+5,g+3]:[g+1,g+2,g+5,g+5,g+2,g+3]:-1===this._flags.lastFlip?[g+0,g+2,g+5,g+2,g+3,g+5]:[g+2,g+0,g+5,g+3,g+2,g+5]),A=computeNormal(v),this._flags.normal.copy(A),a.push(this._flags.normal.x*D,this._flags.normal.y*D,0),e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(u[0],u[1],u[2]),s.push(d,B),i.push(I),n.push(P,R),r.push(0),l.push(...-1===D?[g+6,g+4,g+7]:[g+4,g+6,g+7]),this._flipedUV(t,this._flags.totalDistance,D,!1),this.parameters.vertexColors&&o.push(p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3]),_+=6}else this._extrusions(e,a,t,i,n,r,s,o,h,c,u,b,I,P,R,w,1,!1,p,m,f),this._extrusions(e,a,t,i,n,r,s,o,h,c,u,b,I,P,R,w,B,!1,p,m,f),l.push(...-1===this._flags.lastFlip?[g+2,g+1,g+3]:[g+2,g+0,g+3]),D=-1,this._flags.normal.copy(b),_+=4;this._flags.lastFlip=D}else{if(this._flags.normal=computeNormal(M),x){const l=new three.Vector2,u=new three.Vector2;l.addVectors(M,this._flags.normal),u.subVectors(M,this._flags.normal),a.push(l.x,l.y,0,u.x,u.y,0),e.push(h[0],h[1],h[2],h[0],h[1],h[2]),m.push(c[0],c[1],c[2],c[0],c[1],c[2]);const g=[h[0]-c[0],h[1]-c[1],h[2]-c[2]];f.push(h[0]+g[0],h[1]+g[1],h[2]+g[2],h[0]+g[0],h[1]+g[1],h[2]+g[2]),s.push(d,1,d,1),t.push(this._flags.totalDistance,0,this._flags.totalDistance,1),i.push(I,I),n.push(P,R,P,R),r.push(0,0),this.parameters.vertexColors&&o.push(p[0],p[1],p[2],p[3],p[0],p[1],p[2],p[3])}else this._extrusions(e,a,t,i,n,r,s,o,h,c,u,this._flags.normal,I,P,R,d,1,!1,p,m,f);if(l.push(...-1===this._flags.lastFlip?[g+2,g+1,g+3]:[g+2,g+0,g+3]),_+=2,b){const u=new three.Vector2;u.addVectors(M,this._flags.normal),u.normalize();const A=new three.Vector2;A.subVectors(M,this._flags.normal),A.normalize();const v=M.clone();a.push(u.x,u.y,0),a.push(A.x,A.y,0),a.push(v.x,v.y,0);const y=h[0]+(h[0]-c[0]),x=h[1]+(h[1]-c[1]),b=h[2]+(h[2]-c[2]);for(let a=0;a<3;a++)e.push(h[0],h[1],h[2]),m.push(c[0],c[1],c[2]),f.push(y,x,b),s.push(d,1),t.push(this._flags.totalDistance,0),i.push(I),n.push(P,R,P,R),r.push(0),this.parameters.vertexColors&&o.push(p[0],p[1],p[2],p[3]);l.push(g+2,g+3,g+4,g+4,g+3,g+5,g+4,g+5,g+6),_+=3}}return _})),__publicField(this,"_extrusions",((e,t,i,n,r,s,a,o,l,c,h,u,d,p,m,f,g,_,A,v,y)=>{if(t.push(u.x,u.y,0,-u.x,-u.y,0),e.push(l[0],l[1],l[2],l[0],l[1],l[2]),_){const e=[h[0]-l[0],h[1]-l[1],h[2]-l[2]];v.push(c[0]-e[0],c[1]-e[1],c[2]-e[2],c[0]-e[0],c[1]-e[1],c[2]-e[2])}else v.push(c[0],c[1],c[2],c[0],c[1],c[2]);if(h)y.push(h[0],h[1],h[2],h[0],h[1],h[2]);else{const e=[l[0]-c[0],l[1]-c[1],l[2]-c[2]];y.push(l[0]+e[0],l[1]+e[1],l[2]+e[2],l[0]+e[0],l[1]+e[1],l[2]+e[2])}a.push(f,g,f,g),i.push(d,0,d,1),n.push(d,d),r.push(p,m,p,m),s.push(0,0),this.parameters.vertexColors&&o.push(A[0],A[1],A[2],A[3],A[0],A[1],A[2],A[3])})),this.parameters=e,this._granularity=e.granularity||CesiumMath.RADIANS_PER_DEGREE,this._needsUpdate=!1,this._needsCounter=!1,this._height=e.height||0,this._isCurve=e.isCurve||!1,this._flags={lastFlip:-1,started:!1,normal:null,totalDistance:0}}setData(e){if(this._needsUpdate=!0,this._isCurve&&e.position.length>0&&Array.isArray(e.position[0])&&Array.isArray(e.position[0][0])&&!Array.isArray(e.position[0][0][0]))for(let t=0;t<e.position.length;t++){const i=e.position[t];e.position[t]=getCurve(i,{isGlobe:this.engine.map.isGlobe})}this.cachedData=e,(this.parameters.dashed||this.parameters.enableAnimation||this.parameters.mapSrc||this.parameters.map)&&(this._needsCounter=!0),this.updateGeometry(),this._needsUpdate=!1}updateGeometryColumbus(e){const t=[],i=[],n=[],r=[],s=[],a=[],o=[],l=[],c=[],h=[],u=[],d=[],p=[],m=[];let f=0;for(let g=0;g<e.position.length;g++){const _=arrayRemoveDuplicates(e.position[g]),A=e.index[g],v=this.parameters.vertexWidths?e.lineWidth[g]:this.parameters.lineWidth,y=this.parameters.vertexColors?colorToArr4(e.color[g]):[1,1,1,1];this._flags={lastFlip:-1,started:!1,normal:null,totalDistance:0};const x=_.length;let b=t.length/3,S=Math.random();u.push(S,S),n.push(0,0),d.push(A,A);for(let e=1;e<x;e++){const g=_[e-1],C=_[e],T=e<x-1?_[e+1]:null,E=this._segmentLines(t,i,a,o,h,s,c,l,r,g,C,T,v,y,p,m,b);-1!==E&&(b+=E);for(let t=0;t<E;t++)n.push(e/x),this._needsCounter&&this.parameters.enableAnimationChaos&&u.push(S),d.push(A);f=Math.max(this._flags.totalDistance,f)}if(this._needsCounter)for(let e=0;e<h.length;e++)h[e]=f}this.cachedPositions=t,this.cachedPrevs=p,this.cachedNexts=m,this.setAttribute("position",new three.Float32BufferAttribute(t,3)),this.setAttribute("prev",new three.Float32BufferAttribute(p,3)),this.setAttribute("next",new three.Float32BufferAttribute(m,3)),this.setAttribute("uv",new three.Float32BufferAttribute(i,2)),this.setAttribute("normal",new three.Float32BufferAttribute(c,3)),this.setAttribute("expandAndPrev",new three.Float32BufferAttribute(s,2)),this.setAttribute("counter",new three.Float32BufferAttribute(n,1)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(d,1)),this._needsCounter&&(this.setAttribute("lengths",new three.Float32BufferAttribute(a,1)),this.setAttribute("totalLength",new three.Float32BufferAttribute(h,1)),this.setAttribute("prevAndNextLength",new three.Float32BufferAttribute(o,2)),this.setAttribute("randomFactor",new three.Float32BufferAttribute(u,1))),this.parameters.vertexColors&&this.setAttribute("aColor",new three.Float32BufferAttribute(l,4)),this.setIndex(r),this.computeBoundingSphere()}updateGeometry3D(e){const t=[],i=[],n=[],r=[],s=[],a=[],o=[],l=[],c=[],h=[],u=[],d=[],p=this._granularity,m=this.engine.map.map.ellipsoid||Ellipsoid.WGS84,f=CesiumMath.chordLength(p,m.maximumRadius);let g=0;const _=this.parameters.vertexColors;let A,v=0;for(let y=0,x=e.position.length;y<x;y++){const p=[];let A=arrayRemoveDuplicates(e.position[y]);const x=e.index[y],b=this.parameters.vertexWidths?e.lineWidth[y]:this.parameters.lineWidth,S=this.parameters.vertexColors?colorToArr4(e.color[y]):[1,1,1,1],C=extractHeights$1(A,m).map((e=>e+this._height)),{positions:T,normals:E,lengths:M,randoms:w,totalLength:I,prevs:P,nexts:R,expandAndPrevs:B,prevAndNextLengths:D,uvs:F}=this.generateArc({positions:A,indices:n,minDistance:f,ellipsoid:m,height:C,width:b,bevelIndices:p});v=Math.max(v,I);const O=T.length/3;for(let e=0;e<O;e+=4){n.push(g+e,g+e+1,g+e+2),n.push(g+e+2,g+e+1,g+e+3);const t=e+4;p.includes(t)&&(n.push(g+e+2,g+e+3,g+t),e++)}g+=O,t.push(...T),a.push(...E),h.push(...P),c.push(...R),i.push(...F),d.push(...D),u.push(...B),l.push(...new Array(M.length).fill(x)),_&&s.push(...new Array(M.length).fill(S).flat()),this._needsCounter&&(r.push(...M),this.parameters.enableAnimationChaos&&o.push(...w))}this._needsCounter&&(A=new Array(t.length/3).fill(v)),this.cachedPositions=t,this.setAttribute("position",new three.Float32BufferAttribute(t,3)),this.setAttribute("prev",new three.Float32BufferAttribute(h,3)),this.setAttribute("next",new three.Float32BufferAttribute(c,3)),this.setAttribute("expandAndPrev",new three.Float32BufferAttribute(u,2)),this.setAttribute("normal",new three.Float32BufferAttribute(a,3)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(l,1)),this.setAttribute("uv",new three.Float32BufferAttribute(i,2)),this.setAttribute("prevAndNextLength",new three.Float32BufferAttribute(d,2)),_&&this.setAttribute("aColor",new three.Float32BufferAttribute(s,4)),this._needsCounter&&this.setAttribute("totalLength",new three.Float32BufferAttribute(A,1)),this.setIndex(n)}updateGeometry(){const e=this.cachedData;this.engine.map.isGlobe?this.updateGeometry3D(e):this.updateGeometryColumbus(e)}getFlatDirection(e,t){return isPointEqual(e,t)?this._flags.normal?new three.Vector2(this._flags.normal.y,-this._flags.normal.x):new three.Vector2(1,0):getDirection(e,t)}generateArc(e){e||(e={});const t=e.positions,i=e.indices,n=e.bevelIndices||[],r=t.length,s=e.ellipsoid||Ellipsoid.WGS84,a=e.width||1;let o=e.height||0;const l=Array.isArray(o);if(r<1)return[];if(1===r){const e=s.scaleToGeodeticSurface(t[0],scaleFirst$1);if(o=l?o[0]:o,0!==o){const t=s.geodeticSurfaceNormal(e,cartesian$1);Cartesian3.multiplyByScalar(t,o,t),Cartesian3.add(e,t,e)}return[e.x,e.y,e.z]}let c=e.minDistance;defined$2(c)||(c=CesiumMath.chordLength(this._granularity,s.maximumRadius));let h=0;for(let L=0;L<r-1;L++)h+=numberOfPoints$1(t[L],t[L+1],c);const u=2*h+(r-2),d=u,p=2*u,m=3*u,f=new Array(m),g=new Array(m),_=new Array(d),A=new Array(d),v=new Array(m),y=new Array(m),x=new Array(p),b=new Array(p),S=new Array(p),C=new Array(d);let T=0,E=0;const M=new three.Vector3,w=new three.Vector3;let I;const P={lastFlip:!1,curFlip:!1},R={last:0,next:0},B=new three.Vector3,D=new three.Vector3;let F;for(let L=0;L<r-1;L++){if(p0Scratch$1.fromArray(t[L]),p1Scratch$3.fromArray(t[L+1]),M.crossVectors(p0Scratch$1,p1Scratch$3).normalize(),L<r-2){Ellipsoid.WGS84.geodeticSurfaceNormal(p1Scratch$3,B),p2Scratch$2.fromArray(t[L+2]),w.crossVectors(p1Scratch$3,p2Scratch$2).normalize();const{isFlip:e}=computeVertexMiterNormal(p0Scratch$1,p1Scratch$3,p2Scratch$2,B,D);F=D,P.curFlip=!e}else F=M;const e=I||M;R.last=Math.min(2*a,Math.abs(a/e.dot(M))),R.next=Math.min(2*a,Math.abs(a/F.dot(M)));const i=l?o[L]:o,h=l?o[L+1]:o,u=L<r-2,d=this.generateCartesianArc(p0Scratch$1,p1Scratch$3,c,s,i,h,f,v,y,T,M,w,F,e,R,P,g,a,_,x,E,u,n,b,C);T=d.index;E+=d.surfaceDistance,I||(I=lastMiterScratch),F&&I.copy(F),P.lastFlip=P.curFlip}const O=Math.random();A.fill(O);for(let L=0;L<C.length;L++){let e,t,i=L-1;for(;i>=0&&C[i]===C[L];)i--;let n=L+1;for(;n<C.length&&C[n]===C[L];)n++;e=i<0?0:_[i],t=n>=C.length?_[_.length-1]:_[n],S[2*L]=e,S[2*L+1]=t}return{positions:f,normals:g,lengths:_,randoms:A,totalLength:E,prevs:v,nexts:y,expandAndPrevs:x,prevAndNextLengths:S,uvs:b,indices:i}}generateCartesianArc(e,t,i,n,r,s,a,o,l,c,h,u,d,p,m,f,g,_,A,v,y,x,b,S,C){const T=n.scaleToGeodeticSurface(e,scaleFirst$1),E=n.scaleToGeodeticSurface(t,scaleLast),M=numberOfPoints$1(e,t,i),w=n.cartesianToCartographic(T,carto1$1),I=n.cartesianToCartographic(E,carto2),P=subdivideHeights$2(M,r,s),{lastFlip:R,curFlip:B}=f;ellipsoidGeodesic.setEndPoints(w,I);const D=ellipsoidGeodesic.surfaceDistance/M;let F=c;w.z=r,I.z=s;const O=negativeNormalScratch.copy(h).negate(),L=p?negativeMiterScratch.copy(p).negate():void 0,N=m.last,V=m.next;let U=h,k=O,G=_,z=_;R?(k=L,z=N):(U=p||h,G=N);let j,Q=F/3,H=n.cartographicToCartesian(w,cartesian$1);if(H.toArray(a,F),U.toArray(g,F),A[Q]=y,S[2*Q]=y,S[2*Q+1]=0,v[2*Q]=G,v[2*Q+1]=-1,C[Q]=1,F+=3,Q=F/3,H.toArray(a,F),k.toArray(g,F),v[2*Q]=z,v[2*Q+1]=-1,A[Q]=y,S[2*Q]=y,S[2*Q+1]=1,C[Q]=1,F+=3,M>1){const e=ellipsoidGeodesic.interpolateUsingSurfaceDistance(D,cartoNext);e.z=P[1],n.cartographicToCartesian(e,cartesian2)}else n.cartographicToCartesian(I,cartesian2);cartesianOffset.subVectors(cartesian$1,cartesian2),cartesianOffset.add(cartesian$1),cartesianOffset.toArray(o,c),cartesianOffset.toArray(o,c+3),cartesian2.toArray(l,c),cartesian2.toArray(l,c+3);for(let q=1;q<M;q++)j?carto3.copy(cartoNext):ellipsoidGeodesic.interpolateUsingSurfaceDistance(q*D,carto3),M===q+1?j=I:(j=ellipsoidGeodesic.interpolateUsingSurfaceDistance((q+1)*D,cartoNext),j.z=P[q+1]),carto3.z=P[q],cartesianPrev.copy(cartesian$1),H=n.cartographicToCartesian(carto3,cartesian$1),n.cartographicToCartesian(j,cartesianNext),Q=F/3,H.toArray(a,F),h.toArray(g,F),v[2*Q]=_,v[2*Q+1]=1,cartesianPrev.toArray(o,F),cartesianNext.toArray(l,F),A[Q]=y+q*D,S[2*Q]=y+q*D,S[2*Q+1]=0,C[Q]=-1,F+=3,Q=F/3,H.toArray(a,F),O.toArray(g,F),v[2*Q]=_,v[2*Q+1]=1,cartesianPrev.toArray(o,F),cartesianNext.toArray(l,F),A[Q]=y+q*D,S[2*Q]=y+q*D,S[2*Q+1]=1,C[Q]=-1,F+=3,Q=F/3,H.toArray(a,F),h.toArray(g,F),v[2*Q]=_,v[2*Q+1]=-1,cartesianPrev.toArray(o,F),cartesianNext.toArray(l,F),A[Q]=y+q*D,S[2*Q]=y+q*D,S[2*Q+1]=0,C[Q]=1,F+=3,Q=F/3,H.toArray(a,F),O.toArray(g,F),v[2*Q]=_,v[2*Q+1]=-1,cartesianPrev.toArray(o,F),cartesianNext.toArray(l,F),A[Q]=y+q*D,S[2*Q]=y+q*D,S[2*Q+1]=1,C[Q]=1,F+=3;const $=ellipsoidGeodesic.surfaceDistance;n.cartographicToCartesian(I,cartesian2),cartesianOffset.subVectors(cartesian2,cartesian$1),cartesianOffset.add(cartesian2);const W=d?negativeMiterScratch.copy(d).negate():void 0;return U=h,k=O,G=_,z=_,x&&(B?(k=W||h,z=V):(U=d||h,G=V)),Q=F/3,cartesian2.toArray(a,F),U.toArray(g,F),A[Q]=y+$,v[2*Q]=G,v[2*Q+1]=1,S[2*Q]=y+$,S[2*Q+1]=0,cartesian$1.toArray(o,F),cartesianOffset.toArray(l,F),C[Q]=-1,F+=3,Q=F/3,cartesian2.toArray(a,F),k.toArray(g,F),A[Q]=y+$,v[2*Q]=z,v[2*Q+1]=1,cartesian$1.toArray(o,F),cartesianOffset.toArray(l,F),S[2*Q]=y+$,S[2*Q+1]=1,C[Q]=-1,F+=3,x&&(Q=F/3,b.push(Q),cartesian2.toArray(a,F),B?u.toArray(g,F):negativeNormalScratch.copy(u).negate().toArray(g,F),A[Q]=y+$,v[2*Q]=_,v[2*Q+1]=1,S[2*Q]=y+$,S[2*Q+1]=1,C[Q]=-1,cartesian$1.toArray(o,F),cartesianOffset.toArray(l,F),F+=3),{index:F,surfaceDistance:$,lastLength:D}}_flipedUV(e,t,i,n){n?-1===i?e.push(t,1,t,0,t,1,t,0,t,1):e.push(t,0,t,1,t,0,t,1,t,0):-1===i?e.push(t,1,t,1,t,1,t,0,t,0,t,1):e.push(t,0,t,0,t,0,t,1,t,1,t,0)}get needsUpdate(){return this._needsUpdate}set needsUpdate(e){this._needsUpdate=e}get isCurve(){return this._isCurve}set isCurve(e){this._isCurve=e,this.needsUpdate=!0,this.engine.requestRender()}}const vertexShader$q="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n#else\n    uniform vec3 color;\n#endif\n\nattribute float totalLength;\nattribute float lengths;\nattribute float randomFactor;\n\n#ifdef USE_PREV_NEXT\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 viewportTransform;\nuniform float fovX;\nuniform float fovY;\nattribute vec3 prev;\nattribute vec3 next;\nattribute vec2 expandAndPrev;\n#else\nattribute float aWidth;\n#endif\n\n#ifdef MVT_USE_EXTENT_CLIP\nattribute vec2 extentVertex;\nvarying vec2 vExtentVertex;\n#endif\n\nuniform float elapsedTime;\nuniform bool vertexColors;\nuniform bool antialias;\nuniform float antialiasFactor;\nuniform float lineWidth;\nuniform float height;\nuniform float uZoomUnits;\nuniform bool useZoomUnits;\n\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying float vAliasPart;\nvarying float vCounter;\nvarying float vLength;\nvarying float vTotalLength;\nvarying float vZoomUnits;\nvarying float vClippedLength;\n\n#ifdef USE_ANIMATION\nuniform float animationSpeed;\nuniform float animationTailType;\nuniform float animationTailRatio;\nuniform float animationTailLength;\nuniform float animationIdle;\nvarying float vAnimationOpacity;\n#endif\n\n#ifdef MVT_USE_VERTEX_DASHARRAY\nattribute float aDashArray;\nvarying float vDashArray;\n#endif\n\n#ifdef MVT_USE_VERTEX_DASHRATIO\nattribute float aDashRatio;\nvarying float vDashRatio;\nuniform float useLength;\n#endif\n\nattribute vec2 prevAndNextLength;\n\n#ifdef USE_DASH\nvarying vec2 vPrevAndNextLength;\n#endif\n\nfloat branchFreeTernary(bool comparison, float a, float b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\n#if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)\nattribute float layerIndex;\nvarying float vLayerIndex;\n#endif\n\n#ifdef USE_PREV_NEXT\n\nvec4 eyeToWindowCoordinates(vec4 positionEC) {\n    vec4 q = projectionMatrix * positionEC;\n    q.xyz /= q.w;\n    q.xyz = (viewportTransform * vec4(q.xyz, 1.0)).xyz;\n\n    return q;\n}\n\nvoid clipLineSegmentWithLengthToNearPlane(\n    vec3 p0,\n    vec3 p1,\n    float l0,\n    float l1,\n    out vec4 positionWC,\n    out bool clipped,\n    out bool culledByNearPlane,\n    out vec4 clippedPositionEC,\n    out float clippedLength\n)\n{\n    culledByNearPlane = false;\n    clippedLength = l0;\n    clipped = false;\n\n    vec3 p0ToP1 = p1 - p0;\n    float magnitude = length(p0ToP1);\n    vec3 direction = normalize(p0ToP1);\n    float lengthDistance = l1 - l0;\n\n    float endPoint0Distance = cameraNear + p0.z;\n\n    float denominator = -direction.z;\n\n    if (endPoint0Distance > 0.0 && abs(denominator) < 0.0000001)\n    {\n        culledByNearPlane = true;\n    }\n    else if (endPoint0Distance > 0.0)\n    {\n        float t = endPoint0Distance / denominator;\n        if (t < 0.0 || t > magnitude)\n        {\n            culledByNearPlane = true;\n        }\n        else\n        {\n            // Segment crosses the near plane, update p0 to lie exactly on it.\n            p0 = p0 + t * direction;\n            p0.z = min(p0.z, -cameraNear);\n\n            l0 = mix(l0, l1, t / magnitude);\n\n            // clippedLength = l0 + (t / ma)\n\n            clipped = true;\n        }\n    }\n\n    // 视锥体参数\n    float tanHalfFovX = tan(fovX / 2.0 * 1.5);\n    float tanHalfFovY = tan(fovY / 2.0 * 1.5);\n\n    vec4 planes[4];\n    planes[0] = vec4( 1,  0,  tanHalfFovX, 0); // Left\n    planes[1] = vec4(-1,  0,  tanHalfFovX, 0); // Right\n    planes[2] = vec4( 0,  1,  tanHalfFovY, 0); // Bottom\n    planes[3] = vec4( 0, -1,  tanHalfFovY, 0); // Top\n\n    vec3 p0Clone = p0;\n    float lengthClone = l0;\n    float mint = 10.0;\n    for (int i = 0; i < 2; i++) {\n        vec4 plane = planes[i];\n        float d0 = dot(vec4(p0, 1.0), plane);\n        float d1 = dot(vec4(p1, 1.0), plane);\n\n        if (d0 > 0.0 && d1 > 0.0) {\n            // 线段完全在该裁剪平面外，剔除\n            culledByNearPlane = true;\n        }\n        else if (d0 > 0.0) {\n            // p0 在外，p1 在内，计算交点\n            mint = min(mint, d0 / (d0 - d1));\n            p0Clone = mix(p0, p1, mint);\n            lengthClone = mix(l0, l1, mint);\n            // clippedLength = l0 - (mint / lengthDistance);\n            clipped = true;\n        }\n    }\n\n    p0 = p0Clone;\n    l0 = lengthClone;\n    mint = 10.0;\n    for (int i = 2; i < 4; i++) {\n        vec4 plane = planes[i];\n        float d0 = dot(vec4(p0, 1.0), plane);\n        float d1 = dot(vec4(p1, 1.0), plane);\n\n        if (d0 > 0.0 && d1 > 0.0) {\n            // 线段完全在该裁剪平面外，剔除\n            culledByNearPlane = true;\n        }\n        else if (d0 > 0.0) {\n            // p0 在外，p1 在内，计算交点\n            mint = min(mint, d0 / (d0 - d1));\n            p0Clone = mix(p0, p1, mint);\n            lengthClone = mix(l0, l1, mint);\n            // clippedLength = l0 + (mint * lengthDistance);\n            // clippedLength = l0 - (mint / lengthDistance);\n            clipped = true;\n        }\n    }\n\n    p0 = p0Clone;\n    clippedLength = lengthClone;\n\n    clippedPositionEC = vec4(p0, 1.0);\n    positionWC = eyeToWindowCoordinates(clippedPositionEC);\n\n}\n\nvoid clipLineSegmentToNearPlane(\n    vec3 p0,\n    vec3 p1,\n    out vec4 positionWC,\n    out bool clipped,\n    out bool culledByNearPlane,\n    out vec4 clippedPositionEC)\n{\n    culledByNearPlane = false;\n    clipped = false;\n\n    vec3 p0ToP1 = p1 - p0;\n    float magnitude = length(p0ToP1);\n    vec3 direction = normalize(p0ToP1);\n\n    float endPoint0Distance = cameraNear + p0.z;\n\n    float denominator = -direction.z;\n\n    if (endPoint0Distance > 0.0 && abs(denominator) < 0.0000001)\n    {\n        culledByNearPlane = true;\n    }\n    else if (endPoint0Distance > 0.0)\n    {\n        float t = endPoint0Distance / denominator;\n        if (t < 0.0 || t > magnitude)\n        {\n            culledByNearPlane = true;\n        }\n        else\n        {\n            // Segment crosses the near plane, update p0 to lie exactly on it.\n            p0 = p0 + t * direction;\n            p0.z = min(p0.z, -cameraNear);\n\n            clipped = true;\n        }\n    }\n\n    // 视锥体参数\n    float tanHalfFovX = tan(fovX / 2.0 * 1.5);\n    float tanHalfFovY = tan(fovY / 2.0 * 1.5);\n\n    vec4 planes[4];\n    planes[0] = vec4( 1,  0,  tanHalfFovX, 0); // Left\n    planes[1] = vec4(-1,  0,  tanHalfFovX, 0); // Right\n    planes[2] = vec4( 0,  1,  tanHalfFovY, 0); // Bottom\n    planes[3] = vec4( 0, -1,  tanHalfFovY, 0); // Top\n\n    vec3 p0Clone = p0;\n    float mint = 10.0;\n    for (int i = 0; i < 2; i++) {\n        vec4 plane = planes[i];\n        float d0 = dot(vec4(p0, 1.0), plane);\n        float d1 = dot(vec4(p1, 1.0), plane);\n\n        if (d0 > 0.0 && d1 > 0.0) {\n            // 线段完全在该裁剪平面外，剔除\n            culledByNearPlane = true;\n        }\n        else if (d0 > 0.0) {\n            // p0 在外，p1 在内，计算交点\n            mint = min(mint, d0 / (d0 - d1));\n            p0Clone = mix(p0, p1, mint);\n            clipped = true;\n        }\n    }\n\n    p0 = p0Clone;\n    mint = 10.0;\n    for (int i = 2; i < 4; i++) {\n        vec4 plane = planes[i];\n        float d0 = dot(vec4(p0, 1.0), plane);\n        float d1 = dot(vec4(p1, 1.0), plane);\n\n        if (d0 > 0.0 && d1 > 0.0) {\n            // 线段完全在该裁剪平面外，剔除\n            culledByNearPlane = true;\n        }\n        else if (d0 > 0.0) {\n            // p0 在外，p1 在内，计算交点\n            mint = min(mint, d0 / (d0 - d1));\n            p0Clone = mix(p0, p1, mint);\n            clipped = true;\n        }\n    }\n\n    p0 = p0Clone;\n\n    clippedPositionEC = vec4(p0, 1.0);\n    positionWC = eyeToWindowCoordinates(clippedPositionEC);\n\n}\n\n#endif\n\nvoid main() {\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #else\n        vColor = vec4(color, 1.0);\n    #endif\n\n    vUV = uv;\n    // vCounter = counter;\n    // vLength = uv.x;\n    vTotalLength = totalLength;\n\n    #ifdef MVT_USE_EXTENT_CLIP\n    vExtentVertex = extentVertex;\n    #endif\n\n    #include <begin_vertex>\n\n    #ifdef USE_PREV_NEXT\n        float width = expandAndPrev.x;\n        float pixelSize;\n        vec4 worldPosition;\n        if (keepSize) {\n            vec4 prevEC = modelViewMatrix * vec4(prev, 1.0);\n            vec4 nextEC = modelViewMatrix * vec4(next, 1.0);\n            vec4 positionEC = modelViewMatrix * vec4(transformed, 1.0);\n\n            bool usePrevious = expandAndPrev.y > 0.0;\n\n            vec4 clippedPrevWC, clippedPrevEC;\n            bool prevSegmentClipped, prevSegmentCulled;\n            clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);\n\n            vec4 clippedNextWC, clippedNextEC;\n            bool nextSegmentClipped, nextSegmentCulled;\n            clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);\n\n            bool segmentClipped, segmentCulled;\n            vec4 clippedPositionWC, clippedPositionEC;\n            float clippedLength;\n            clipLineSegmentWithLengthToNearPlane(\n                positionEC.xyz,\n                usePrevious ? prevEC.xyz : nextEC.xyz,\n                uv.x,\n                usePrevious ? prevAndNextLength.x : prevAndNextLength.y,\n                clippedPositionWC,\n                segmentClipped,\n                segmentCulled,\n                clippedPositionEC,\n                clippedLength\n            );\n\n            vClippedLength = clippedLength;\n            \n            vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);\n            vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);\n\n            vec4 prevWorld = modelMatrix * vec4(prev, 1.0);\n            vec4 nextWorld = modelMatrix * vec4(next, 1.0);\n            vec2 directionToPrevWC1 = normalize(nextWorld.xy - prevWorld.xy);\n            vec2 directionNormal = vec2(-directionToPrevWC1.y, directionToPrevWC1.x);\n            worldPosition = inverse(viewMatrix) * (clippedPositionEC);\n            pixelSize = getPixelSize(worldPosition.xyz);\n        }\n        else {\n            worldPosition = modelMatrix * vec4(transformed, 1.0);\n            pixelSize = getPixelSize(worldPosition.xyz);\n            vClippedLength = uv.x;\n        }\n    #else \n        vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n        float pixelSize = getPixelSize(worldPosition.xyz);\n        float width = aWidth;\n\n        #ifdef MVT_USE_VERTEX_DASHRATIO\n            vClippedLength = lengths;\n        #else\n            vClippedLength = uv.x;\n        #endif\n    #endif\n\n    // pixelSize不如统一的zoomUnits的效果\n    // vZoomUnits = branchFreeTernary(useZoomUnits, uZoomUnits, pixelSize);\n    vZoomUnits = branchFreeTernary(useZoomUnits, uZoomUnits, zoomUnits);\n\n    vec3 extrude = normal.xyz * width / 2.0;\n    float pixelWidth = width;\n    if (keepSize) {\n        extrude *= pixelSize;\n        pixelWidth *= pixelSize;\n    }\n    if (antialias) {\n        // 抗锯齿虚化宽度的单位一定是像素，线两侧各虚化0.5个像素\n        float aliasFeatureWidth = 0.5 * antialiasFactor * pixelSize;\n        extrude += normal.xyz * aliasFeatureWidth;\n        float halfWidth = pixelWidth / 2.0;\n        vNormal = normalize(normal.xyz);\n        vAliasPart = 1. - (2. * aliasFeatureWidth / (halfWidth + aliasFeatureWidth));\n    }\n    worldPosition.xyz += extrude;\n    // worldPosition.z += height;\n\n    #if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)\n        vLayerIndex = layerIndex;\n    #endif\n    \n    #ifdef USE_ANIMATION\n        float tailLength = animationTailType == 1.0 ? vTotalLength * animationTailRatio : animationTailLength;\n\n        #ifdef ANIMATION_CHAOS\n            float currentTime = elapsedTime + randomFactor * 1000.0 * 3600.;\n        #else\n            float currentTime = elapsedTime;\n        #endif\n        float currentLength = mod(currentTime * animationSpeed, vTotalLength + tailLength + animationIdle * animationSpeed);\n        vAnimationOpacity = (vClippedLength - (currentLength - tailLength)) / tailLength;\n    #endif\n\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n\n    #ifdef MVT_USE_VERTEX_DASHARRAY\n    vDashArray = aDashArray;\n    #endif\n\n    #ifdef MVT_USE_VERTEX_DASHRATIO\n    vDashRatio = aDashRatio;\n    #endif\n\n    #include <beginnormal_vertex>\n    #include <fog_vertex>\n    #include <logdepthbuf_vertex>\n}",fragmentShader$o="#define GLSLIFY 1\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_depth_range_pars_fragment>\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef MVT_USE_EXTENT_CLIP\nvarying vec2 vExtentVertex;\n#endif\n\nuniform sampler2D map;\nuniform bool useMap;\nuniform bool keepSize;\nuniform bool antialias;\nuniform float lineWidth;\nuniform float mapGap;\nuniform float opacity;\nuniform float alphaTest;\nuniform float elapsedTime;\nuniform bool flipUv;\nuniform bool isSingle;\nuniform bool needRound;\nuniform bool useMeterUnits;\n\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec4 vColor;\nvarying float vAliasPart;\nvarying float vCounter;\nvarying float vLength;\nvarying float vTotalLength;\nvarying float vZoomUnits;\n\n#ifdef USE_ANIMATION\nuniform float animationInterval;\nvarying float vAnimationOpacity;\n#endif\n\n#ifdef USE_DASH\n#ifdef MVT_USE_VERTEX_DASHARRAY\nvarying float vDashArray;\n#else\nuniform float dashArray;\n#endif\nuniform float dashOffset;\n#ifdef MVT_USE_VERTEX_DASHRATIO\nvarying float vDashRatio;\n#else\nuniform float dashRatio;\n#endif\nuniform bool keepDashLength;\nvarying float vDashOpacity;\n#endif\n\nvarying float vClippedLength;\n\nvec2 branchFreeTernary(bool comparison, vec2 a, vec2 b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\nvoid main() {\n\n   vec4 c = vColor;\n\n    #ifdef MVT_USE_EXTENT_CLIP\n    if (vExtentVertex.x < 0.0 || vExtentVertex.x > 1.0 || vExtentVertex.y < 0.0 || vExtentVertex.y > 1.0) {\n        discard;\n    }\n    #endif\n \n    if(useMap) {\n        // icon之间的间隔，经验值为间隔50倍宽度，比较稀疏且好看\n        float margin = lineWidth * mapGap;\n        float halfMargin = margin / 2.0;\n        float texWidth = lineWidth;\n        if (keepSize && !useMeterUnits) {\n            margin *= vZoomUnits;\n            texWidth *= vZoomUnits;\n        }\n        if (needRound && vClippedLength > (texWidth + margin)) {\n            discard;\n        }\n        float delta = mod(vClippedLength, texWidth + margin);\n        float uvx;\n        if (isSingle) {\n            uvx = vClippedLength / vTotalLength;\n        }\n        else {\n            uvx = (delta - halfMargin) / texWidth;\n        }\n        if (delta >= halfMargin && delta <= halfMargin + texWidth) {\n            vec2 uv = branchFreeTernary(flipUv, vec2(vUV.y, uvx), vec2(uvx, vUV.y));\n            vec4 texture = texture2D(map, uv);\n            // c = texture.a >= 0.5 ? texture : c;\n            c = texture;\n        }\n    }\n\n    #ifdef USE_ANIMATION\n        float animationAlpha = vAnimationOpacity;\n        if (animationInterval > 0.0) {\n            animationAlpha = mod(vAnimationOpacity, animationInterval);\n        }\n        if (animationAlpha > 1.0 || animationAlpha < 0.0) {\n            discard;\n        }\n        c.a *= animationAlpha;\n    #endif\n\n    #ifdef USE_DASH\n        #ifdef MVT_USE_VERTEX_DASHARRAY\n        float darray = vDashArray;\n        #else\n        float darray = dashArray;\n        #endif\n\n        #ifdef MVT_USE_VERTEX_DASHRATIO\n        float dratio = vDashRatio;\n        #else\n        float dratio = dashRatio;\n        #endif\n        if (keepSize && keepDashLength) {\n            darray *= vZoomUnits;\n        }\n        c.a *= step(mod(vClippedLength + dashOffset, darray), (darray * dratio));\n    #endif\n\n    if (c.a < alphaTest) {\n        discard;\n    }\n\n    // 抗锯齿 make line edge antialias\n    if (antialias) {\n        float blur = 1.0;\n        // blur = 1.0 - smoothstep(vAliasPart, 1.0, length(vNormal));\n        blur = 1.0 - (length(vNormal) - vAliasPart) / (1.0 - vAliasPart);\n        blur = clamp(blur, 0.0, 1.0);\n        c.a *= blur;\n    }\n\n    gl_FragColor = c;\n\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n    #include <mvt_depth_range_fragment>\n}",textureLoader$9=new three.TextureLoader,uniforms$p=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,emissiveUniforms,{antialias:{value:!1},antialiasFactor:{value:1},lineWidth:{value:100},keepSize:{value:!1},map:{value:null},useMap:{value:!1},mapGap:{value:50},color:{value:[0,1,1]},height:{value:0},opacity:{value:1},resolution:{value:new three.Vector2(1,1)},sizeAttenuation:{value:1},dashArray:{value:20},dashOffset:{value:0},dashRatio:{value:.5},alphaTest:{value:0},repeat:{value:new three.Vector2(1,1)},vertexColors:{value:!1},vertexZIndexLegacy:{value:!1},vertexZIndex:{value:!1},elapsedTime:{value:0},enableAnimation:{value:!1},enableAnimationChaos:{value:!1},animationInterval:{value:0},animationSpeed:{value:1},animationTailType:{value:1},animationTailRatio:{value:.2},animationTailLength:{value:100},animationIdle:{value:1e3},isEmissive:{value:!1},keepDashLength:{value:!0},depthRange:{value:new three.Vector2(0,1)},viewportTransform:{value:new three.Matrix4},cameraNear:{value:0},cameraFar:{value:0},fovX:{value:0},fovY:{value:0},uZoomUnits:{value:1},flipUv:{value:!1},useZoomUnits:{value:!1},useLength:{value:!1},isSingle:{value:!1},needRound:{value:!1},useMeterUnits:{value:!1}}]);class FatLineMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="FatLineMaterial",this.isFatLineMaterial=!0,this.fog=!0,this.fragmentShader=fragmentShader$o,this.vertexShader=vertexShader$q,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$p)),defineMaterialNormalProperties(this,["antialias","mapGap","isSingle","flipUv","lineWidth","keepSize","height","opacity","dashArray","dashOffset","dashRatio","alphaTest","animationInterval","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle","isEmissive","keepDashLength","depthRange","antialiasFactor","useLength","needRound","useMeterUnits"]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexZIndexLegacy","MVT_USE_VERTEX_ZINDEX_LEGACY"],["vertexZIndex","MVT_USE_VERTEX_ZINDEX"],["enableAnimation","USE_ANIMATION"],["enableAnimationChaos","ANIMATION_CHAOS"],["dashed","USE_DASH"],["enableDepthRange","MVT_USE_DEPTH_RANGE"],["enableExtentClip","MVT_USE_EXTENT_CLIP"],["vertexDashArray","MVT_USE_VERTEX_DASHARRAY"],["vertexDashRatio","MVT_USE_VERTEX_DASHRATIO"],["enablePrevAndNext","USE_PREV_NEXT"]]),defineMaterialEmissiveProperties(this),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const t=this.mapSrc,i="url_map";if(this.userData[i]===e)return;if(t&&t.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[i];const n=textureLoader$9.load(e);n.wrapS=n.wrapT=three.ClampToEdgeWrapping,this.uniforms.map.value=n,this.userData[i]=e,this.uniforms.useMap.value=!0}},map:{get:function(){return this.uniforms.map.value},set:function(e){const t=this.map;if(!e)return t.dispose(),this.uniforms.map.value=null,void(this.uniforms.useMap.value=!1);this.uniforms.map.value=e,this.uniforms.useMap.value=!0}},zoomUnits:{get:function(){return this.uniforms.uZoomUnits.value},set:function(e){this.uniforms.uZoomUnits.value=e,this.uniforms.useZoomUnits.value=!0}}}),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}new three.Vector3,new three.Vector3;const _inverseMatrix=new three.Matrix4,_ray$1=new three.Ray,_sphere$2=new three.Sphere,_viewportTransform=new three.Matrix4;class FatLineInternal extends GeoMesh{constructor(e){super(),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"_resolution",new three.Vector2),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"lineJoin"),__publicField(this,"lineCap"),__publicField(this,"miterLimit"),__publicField(this,"keepSize"),__publicField(this,"color"),__publicField(this,"vertexColors"),__publicField(this,"mapSrc"),__publicField(this,"opacity"),__publicField(this,"alphaTest"),__publicField(this,"dashed"),__publicField(this,"dashArray"),__publicField(this,"dashOffset"),__publicField(this,"dashRatio"),__publicField(this,"enableAnimation"),__publicField(this,"enableAnimationChaos"),__publicField(this,"animationSpeed"),__publicField(this,"animationTailType"),__publicField(this,"animationTailRatio"),__publicField(this,"animationTailLength"),__publicField(this,"animationIdle"),__publicField(this,"makeGeometryOffsetPosition",(e=>{if(!this._enableRtc)return;const t=e.boundingSphere&&e.boundingSphere.center;if(!t)return this._cachedRtc=[0,0,0],void this.updateTransform();const{x:i,y:n,z:r}=t,s=e.cachedPositions,a=e.cachedPrevs,o=e.cachedNexts;this.makePostionArrayOffset(e.attributes.position.array,i,n,r,s),e.attributes.prev&&this.makePostionArrayOffset(e.attributes.prev.array,i,n,r,a),e.attributes.next&&this.makePostionArrayOffset(e.attributes.next.array,i,n,r,o),this.geometry.computeBoundingSphere(),this._cachedRtc=[i,n,r],this.updateTransform()})),this.parameters=e,this.raycastBuffer=this.parameters.raycastBuffer||0,this.parameters.lineJoin=this.parameters.lineJoin||"bevel",this.defineGeometryProxyProperties(["lineJoin","lineCap","miterLimit","isCurve"]),this.defineMaterialProxyProperties(["antialias","map","mapSrc","mapGap","height","keepSize","transparent","opacity","alphaTest","dashed","dashArray","dashOffset","dashRatio","enableAnimation","enableAnimationChaos","animationInterval","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle","color","vertexColors","vertexWidths","emissive","keepDashLength","needRound","useMeterUnits"])}getDefaultParams(){return{lineWidth:4}}initObject(){const{lineJoin:e,lineCap:t,isCurve:i,flat:n,...r}=this.parameters;(this.geometry=new FatLineGeometry(this.parameters)).engine=this.engine,r.enablePrevAndNext=!0;(this.material=new FatLineMaterial(r)).setCommonUniforms(this.engine.rendering.uniforms)}_updateData(){const e=this.dataSource.data;this.geometry.setData(e),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox(),this.makeGeometryOffsetPosition(this.geometry),this.needsUpdate=!1}afterGeometryUpdate(){this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox()}computeViewportTransformation(e,t,i,n){const r=e.x||0,s=e.y||0;t=t||0;const a=.5*(e.width||0),o=.5*(e.height||0),l=.5*((i=i||1)-t),c=a,h=o,u=l,d=r+a,p=s+o,m=t+l,f=n.elements;return f[0]=c,f[1]=0,f[2]=0,f[3]=0,f[4]=0,f[5]=h,f[6]=0,f[7]=0,f[8]=0,f[9]=0,f[10]=u,f[11]=0,f[12]=d,f[13]=p,f[14]=m,f[15]=1,n}onBeforeScenePrepareRenderHook(){const{x:e,y:t}=this.engine.rendering.uniforms.resolution.value;this._resolution.x===e&&this._resolution.y===t||(this.material.uniforms.viewportTransform.value.copy(this.computeViewportTransformation({width:this.engine.rendering.uniforms.resolution.value.x,height:this.engine.rendering.uniforms.resolution.value.y},0,1,_viewportTransform)),this._resolution.set(e,t)),this.material.uniforms.cameraNear.value=this.engine.camera.near,this.material.uniforms.cameraFar.value=this.engine.camera.far,this.material.uniforms.fovY.value=this.engine.camera.fov/180*Math.PI,this.material.uniforms.fovX.value=this.material.uniforms.fovY.value*this.engine.camera.aspect}get lineWidth(){return this.parameters.lineWidth}set lineWidth(e){this.parameters.lineWidth=e,this.needsUpdate=!0,this.engine.requestRender()}raycast(e,t){if(!this.visible)return;const i=this.geometry,n=this.matrixWorld,r=e.params.Line.threshold,s=i.drawRange;let a=this.lineWidth/2+this.raycastBuffer;if(this.material.keepSize&&(a*=this.material.uniforms.zoomUnits.value),null===i.boundingSphere&&i.computeBoundingSphere(),_sphere$2.copy(i.boundingSphere),_sphere$2.applyMatrix4(n),_sphere$2.radius+=a,!1===e.ray.intersectsSphere(_sphere$2))return;_inverseMatrix.copy(n).invert(),_ray$1.copy(e.ray).applyMatrix4(_inverseMatrix);const o=a/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=new three.Vector3,h=new three.Vector3,u=new three.Vector3,d=new three.Vector3;if(i.isBufferGeometry){const n=i.index,r=i.attributes,a=r.position,o=r.objectIndex;if(null!==n){for(let i=Math.max(0,s.start),r=Math.min(n.count,s.start+s.count)-1;i<r;i+=2){const r=n.getX(i),s=n.getX(i+1);c.fromBufferAttribute(a,r),h.fromBufferAttribute(a,s);if(_ray$1.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const p=e.ray.origin.distanceTo(d);if(p<e.near||p>e.far)continue;const m=o.getX(r);m===o.getX(s)&&t.push({distance:p,point:u.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}else{for(let i=Math.max(0,s.start),n=Math.min(a.count,s.start+s.count)-1;i<n;i+=2){c.fromBufferAttribute(a,i),h.fromBufferAttribute(a,i+1);if(_ray$1.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const n=e.ray.origin.distanceTo(d);n<e.near||n>e.far||t.push({distance:n,point:u.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}}}e.params.Line.threshold=r}}class Polyline extends three.Group{constructor(e={}){super(),__publicField(this,"_object");const t=e.flat;this._object=t?new FatLineInternal(e):new PolylineInternal(e);const i=new Proxy(this,{get:(e,t,i)=>{if(t in e)return Reflect.get(e,t,i);const n=Reflect.get(this._object,t,i);return"function"==typeof n?n.bind(this._object):n},set:(e,t,i,n)=>t in e?Reflect.set(e,t,i,n):Reflect.set(this._object,t,i,n)});return i.add(this._object),i}}class GeoPoints extends GeoObject{constructor(){super(...arguments),__publicField(this,"isPoints",!0),__publicField(this,"isEventEntitySupported",!0)}get size(){return this.material.size}set size(e){this.material.size=e}raycast(e,t){if(!this.visible)return;const i=e.params.Points.threshold;let n=i*this.size;this.material.uniforms.zoomUnits&&(n*=this.material.uniforms.zoomUnits.value),e.params.Points.threshold=n/2,three.Points.prototype.raycast.call(this,e,t),e.params.Points.threshold=i}getEntityByIndex(e){const t=this.dataSource;this._enableCollision&&this._collisionData&&(e=this._collisionData[e].index);const i={value:t.getDataItem(e),itemIndex:t.getDataItemIndex(e),pairs:{}},n=t.data;for(const r of Object.keys(n))i.pairs[r]=n[r][e],i[r]=n[r][e];return i}}class SimplePointGeometry extends three.BufferGeometry{constructor(e){super(e),this.parameters=e}setData(e){const{vertexSizes:t,vertexColors:i}=this.parameters,{aPositions:n,aObjectIndices:r,aMapIndexs:s,aColors:a,aSizes:o}=e;this.setAttribute("position",new three.Float32BufferAttribute(n,3)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(r,1)),this.setAttribute("aMapIndex",new three.Float32BufferAttribute(s,1)),i&&this.setAttribute("aColor",new three.Float32BufferAttribute(a,4)),t&&this.setAttribute("aSize",new three.Float32BufferAttribute(o,1))}}const vertexShader$p="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_SIZE\n    attribute float aSize;\n    varying float vSize;\n#endif\n\n#ifdef MVT_USE_VERTEX_OFFSET\n    attribute vec2 aOffset;\n#else\n    uniform vec2 uOffset;\n#endif\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n    varying vec4 vColor;\n#endif\n\nuniform float size;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n    #include <mvt_selective_vertex>\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n\n    #ifdef MVT_USE_VERTEX_OFFSET\n        vec2 offset = aOffset * 2. * pixelRatio * pixelSize;\n    #else\n        vec2 offset = uOffset * 2. * pixelRatio * pixelSize;\n    #endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    gl_Position.xy = gl_Position.xy - offset;\n\n    #ifdef MVT_USE_VERTEX_SIZE\n        vSize = aSize * pixelRatio;\n        gl_PointSize = vSize;\n    #else\n        gl_PointSize = size * pixelRatio;\n    #endif\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #endif\n\n    #include <logdepthbuf_vertex>\n}",fragmentShader$n="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec3 color;\n#endif\nuniform float uShapeType;\nuniform float opacity;\n\n#ifdef MVT_USE_VERTEX_SIZE\n    varying float vSize;\n#else\n    uniform float size;\n#endif\nuniform bool useMap;\nuniform sampler2D map;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        gl_FragColor = vColor;\n    #else\n        gl_FragColor = vec4(color, 1.0);\n    #endif\n\n    if (uShapeType == 2.) {\n        float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n        #ifdef MVT_USE_VERTEX_SIZE\n            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);\n        #else\n            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);\n        #endif\n        \n        if (alpha <= 0.) {\n            discard;\n        } else {\n            gl_FragColor.a *= alpha;\n        }\n    }\n \n    if (useMap) {\n        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);\n     //    gl_FragColor.a += tColor.a;\n        \n        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);\n        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);\n        // gl_FragColor.a += tColor.a;\n        // gl_FragColor = tColor;\n    }\n\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <mvt_selective_fragment> \n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}",textureLoader$8=new three.TextureLoader,uniforms$o=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,emissiveUniforms,{isEmissive:{value:!1},color:{value:[1,1,0]},size:{value:30},vertexColors:{value:!1},vertexSizes:{value:!1},uShapeType:{value:2},opacity:{value:1},map:{value:null},useMap:{value:!1},uOffset:{value:[0,0]}}]);class SimplePointMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="SimplePointMaterial",this.vertexShader=vertexShader$p,this.fragmentShader=fragmentShader$n,this.isSimplePointMaterial=!0,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$o)),defineMaterialSelectiveProperties(this),defineMaterialNormalProperties(this,["size","uShapeType","opacity","isEmissive"]),defineMaterialAliasProperties(this,[["offset","uOffset"]]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexSizes","MVT_USE_VERTEX_SIZE"]]),defineMaterialEmissiveProperties(this),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const t=this.mapSrc,i="url_map";if(this.userData[i]===e)return;if(t&&t.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[i];const n=textureLoader$8.load(e);n.wrapS=n.wrapT=three.ClampToEdgeWrapping,this.uniforms.map.value=n,this.userData[i]=e,this.uniforms.useMap.value=!0}}}),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class SimplePoint extends GeoPoints{constructor(e){super(e),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"color"),__publicField(this,"vertexColors"),__publicField(this,"size"),__publicField(this,"vertexSizes"),__publicField(this,"opacity"),this.parameters=e,this.defineMaterialProxyProperties(["size","uShapeType","opacity","emissive","vertexColors","vertexSizes","color","mapSrc"]),this.defineMaterialUpdateProxyProperties(["transparent"])}collisionTest(e){return this.parameters.vertexSizes&&e.size?{width:e.size,height:e.size}:{width:this.size,height:this.size}}initObject(){this.geometry=new SimplePointGeometry(this.parameters),this.material=new SimplePointMaterial(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}_updateData(){const e=this.dataSource.data,{vertexSizes:t,vertexColors:i}=this.parameters;let n=[];n=this._enableCollision&&this._collisionData?this._collisionData:this.dataSource.userData;const r=[],s=[],a=[],o=[];for(let l=0;l<n.length;l++){const c=n[l].position,h=n[l].index;if(r.push(...c),s.push(h),i&&e.color){let e=colorToArr4(n[l].color);a.push(e[0],e[1],e[2],e[3])}t&&e.size&&o.push(n[l].size)}this.geometry.setData({aPositions:r,aObjectIndices:s,aColors:a,aSizes:o}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,r),this.needsUpdate=!1}}const _GeoJSONDataSource=class extends DataSource{constructor(e){super(e),this.type="GeoJSONDataSource"}async _convertStreamingDataToObjectData(e){return await e.json()}_parseObjectDataToDataItems(e){let t=null,i=null;Array.isArray(e)?t=e:Array.isArray(e.features)||"FeatureCollection"===e.type?(t=e.features,i=e.properties):"Feature"===e.type&&(t=[e]);const n=[];for(let r=0;r<t.length;r++)n.push(new DataItem(t[r],i));return n}};let GeoJSONDataSource=_GeoJSONDataSource;__publicField(GeoJSONDataSource,"fromGeoJSON",(function(e,t){"string"==typeof e&&console.error("It seems that you are trying to pass a URL to GeoJSONDataSource.fromGeoJSON, please use GeoJSONDataSource.fromURL instead.");let i=new _GeoJSONDataSource(t);return i.setData(e),i})),__publicField(GeoJSONDataSource,"fromURL",(async function(e,t){let i=new _GeoJSONDataSource(t);return await i.load(e),i})),__publicField(GeoJSONDataSource,"fromGeoJSONObject",(function(e,t){return console.warn("GeoJSONDataSource.fromGeoJSONObject is deprecated, please use GeoJSONDataSource.fromGeoJSON instead."),_GeoJSONDataSource.fromGeoJSON(e,t)})),__publicField(GeoJSONDataSource,"fromObject",(function(e,t){return console.warn("GeoJSONDataSource.fromObject is deprecated, please use GeoJSONDataSource.fromGeoJSON instead."),_GeoJSONDataSource.fromGeoJSON(e,t)}));const SDF_FONT_SIZE=24,SDF_BUFFER=3,SDF_RADIUS=8;class ScreenText extends GeoMesh{constructor(e={}){super(),__publicField(this,"engine"),__publicField(this,"parameters"),__publicField(this,"fontAtlasManager"),__publicField(this,"atlasTexture"),this.parameters={fontSize:26,fontFamily:"sans-serif",fontWeight:"400",color:"#ffffff",opacity:1,strokeWidth:0,strokeColor:"#000000",keepUpright:!0,textMaxAngle:45,clippingBuffer:256,debug:!1,...e},this.frustumCulled=!1,this.matrixAutoUpdate=!1,this.renderOrder=999,this.FlipState={unknown:0,flipRequired:1,flipNotRequired:2},this._flipStates=new Map,this._textsAlongLinesData=[],this._tempMatrix4=new three.Matrix4,this._tempVector2=new three.Vector2,this._tempVector4=new three.Vector4,this._tempVector4_2=new three.Vector4,this._measureCanvas=document.createElement("canvas"),this._measureCanvas.width=this._measureCanvas.height=1,this._measureCtx=this._measureCanvas.getContext("2d"),this._emptyFrameCount=0,this._emptyFrameThreshold=3,this._placeTextCache=new Map,this._shapeCache=new LRUCache$1({max:500}),this._debugPolyline=null,this._debugNormalPoints=null,this._debugAnchorPoints=null}initObject(){this.geometry=new ScreenTextGeometry(this.parameters),this.material=new ScreenTextMaterial(this.parameters),this._initFontAtlas(),this._defineProxyProperties(["color","opacity"])}afterAddToEngine(e){super.afterAddToEngine(e),this._updateResolution(),this.parameters.debug&&this._initDebugObjects()}_initDebugObjects(){this.engine&&this.parameters.debug&&(this._debugPolyline=new Polyline({color:"#ff0000",opacity:.6,linewidth:2}),this.engine.add(this._debugPolyline),this._debugNormalPoints=new SimplePoint({color:"#00ff00",size:6}),this.engine.add(this._debugNormalPoints),this._debugAnchorPoints=new SimplePoint({color:"#ff0000",size:12}),this.engine.add(this._debugAnchorPoints))}collisionTest(e){const{text:t,linePoints:i,position:n}=e;if(!t||!i||!n)return null;const r={id:e.id,text:t,line:i,anchor:n,anchorIndex:e.anchorIndex,textFillStyle:e.textFillStyle,textSize:e.textSize,textStrokeStyle:e.textStrokeStyle,textStrokeWidth:e.textStrokeWidth};let s=this._placeTextCache.get(e.id);return s||(s=this._placeTextAlongLine(r,!0),e.id&&this._placeTextCache.set(e.id,s||[])),s&&0!==s.length?{chars:s,isProjected:!0,tolerance:e.tolerance||0,width:100,height:100}:null}_updateResolution(){this.engine&&this.engine.renderer&&this.material&&(this.engine.renderer.getSize(this._tempVector2),this.material.uniforms.resolution.value.set(this._tempVector2.x,this._tempVector2.y),this.material.uniforms.pixelRatio.value=this.engine.renderer.getPixelRatio())}_initFontAtlas(){this.fontAtlasManager=new FontAtlasManager;const e=this.parameters.fontWeight||"400",t=this.parameters.fontFamily||"sans-serif",i={buffer:SDF_BUFFER,radius:SDF_RADIUS,fontSize:SDF_FONT_SIZE};this.fontAtlasManager.setProps({fontFamily:t,fontWeight:e,characterSet:[],sdf:!0,...i}),this.atlasTexture=new three.DataTexture(new Uint8Array(262144),512,512,three.RedFormat),this.atlasTexture.wrapS=this.atlasTexture.wrapT=three.ClampToEdgeWrapping,this.atlasTexture.minFilter=this.atlasTexture.magFilter=three.LinearFilter,this.atlasTexture.generateMipmaps=!1,this.atlasTexture.needsUpdate=!0,this.material.uniforms.textMap.value=this.atlasTexture}_defineProxyProperties(e){e.forEach((e=>{Object.defineProperty(this,e,{get:function(){return this.material?this.material[e]:void 0},set:function(t){this.material&&(this.material[e]=t)}})}))}setTexts(e){if(!this.geometry)return;if(this._updateResolution(),!e||0===e.length)return this._emptyFrameCount++,void(this._emptyFrameCount>=this._emptyFrameThreshold&&(this.geometry.setData([],{}),this._lastCharCount=0));this._emptyFrameCount=0,this._lastCharCount=e.length;const t=new Set;for(const o of e)o.char&&t.add(o.char);t.size>0&&this._updateFontAtlas([...t]);const i={},n=this.fontAtlasManager.mapping,r=this.fontAtlasManager.atlas,s=this.parameters.fontFamily||"sans-serif",a=this.parameters.fontWeight||"400";if(n&&r){const e=r.width,o=r.height;for(const r of t){const t=n[r+a+s];if(t){const n=t.x,s=t.y;let a=t.width;const l=t.height;a+=2*SDF_BUFFER;const c=n/e,h=s/o,u=c+a/e,d=h+l/o;i[r]={startU:c,startV:d,endU:u,endV:h}}}}this.geometry.setData(e,i)}_updateFontAtlas(e){const t=this.parameters.fontWeight||"400",i=this.parameters.fontFamily||"sans-serif",n={buffer:SDF_BUFFER,radius:SDF_RADIUS,fontSize:SDF_FONT_SIZE},r=Array.from(e).map((e=>({char:e,fontWeight:t})));this.fontAtlasManager.setProps({fontFamily:i,fontWeight:t,characterSet:r,sdf:!0,...n});const s=this.fontAtlasManager.atlas;if(s&&s.textureData){const e=this.fontAtlasManager.atlas;!this.atlasTexture||this.atlasTexture.image.width!==e.width||this.atlasTexture.image.height!==e.height?(this.atlasTexture&&this.atlasTexture.dispose(),this.atlasTexture=new three.DataTexture(e.textureData,e.width,e.height,three.RedFormat),this.atlasTexture.wrapS=this.atlasTexture.wrapT=three.ClampToEdgeWrapping,this.atlasTexture.minFilter=this.atlasTexture.magFilter=three.LinearFilter,this.atlasTexture.generateMipmaps=!1,this.atlasTexture.needsUpdate=!0):(this.atlasTexture.image.data.set(e.textureData),this.atlasTexture.needsUpdate=!0),this.material.uniforms.textMap.value=this.atlasTexture}}setTextAlongLine(e,t,i){this.setTextsAlongLines([{text:e,line:t,anchor:i}])}setTextsAlongLines(e){this.engine?this._textsAlongLinesData=e.map(((e,t)=>({...e,id:e.id||`text_${t}_${e.text}`}))):console.error("❌ ScreenText 未添加到引擎，无法计算屏幕坐标")}onBeforeScenePrepareRenderHook(e,t,i){if(this._updateResolution(),this._textsAlongLinesData&&this._textsAlongLinesData.length>0)try{this._updateTextsAlongLines(this._textsAlongLinesData)}catch(n){console.error("沿线文字更新失败:",n)}}_updateTextsAlongLines(e){const t=[];for(let i=0;i<e.length;i++){const n=e[i];let r;r=n.id&&this._placeTextCache.has(n.id)?this._placeTextCache.get(n.id):this._placeTextAlongLine(n,i),r&&r.length>0&&t.push(...r)}this._placeTextCache.clear(),this.setTexts(t)}_placeTextAlongLine(e){const{text:t,line:i,anchor:n,anchorIndex:r,id:s,textFillStyle:a,textSize:o,textStrokeStyle:l,textStrokeWidth:c}=e,h=s||t,u=!this._initializedGroups||!this._initializedGroups.has(h);this._initializedGroups||(this._initializedGroups=new Set);const d=this.engine.camera,p=this.engine.rendering.renderState.viewMatrixWorldInverse;this._tempMatrix4.multiplyMatrices(d.projectionMatrix,p),this.engine.renderer.getSize(this._tempVector2);const m=this._lineToScreenCoords(i,this._tempMatrix4,this._tempVector2);let f;if(void 0!==r&&r>=0){let e=-1;for(let t=0;t<m.length;t++)if(m[t].originalIndex===r){e=t;break}if(-1===e)return[];if(f=m[e],f.originalW<=0)return[];e===m.length-1?f.segment=Math.max(0,m.length-2):f.segment=e}else{if(f=this._worldToScreen(n,this._tempMatrix4,this._tempVector2),this._isPointBehindCamera(n,this._tempMatrix4))return[];f.segment=this._findSegmentForAnchor(f,m)}if(!this._isAnchorVisible(f,this._tempVector2))return[];const g=void 0!==o?o:this.parameters.fontSize,_=this._parseColorToRgba(a,this.parameters.color),A=this._parseColorToRgba(l,this.parameters.strokeColor),v=void 0!==c?c:this.parameters.strokeWidth,y=g+2*v,x=`${t}_${y}_${this.parameters.fontFamily}_${this.parameters.fontWeight}`;let b=this._shapeCache.get(x);if(!b){if(b=this._shapeText(t,y),!b||!b.glyphs||0===b.glyphs.length)return[];this._shapeCache.set(x,b)}let S=!1,C=!1;if(this.parameters.keepUpright&&b.glyphs.length>=2){const e=b.glyphs[0],t=b.glyphs[b.glyphs.length-1],i=(t.x+t.width)/2,n=e.x+e.width/2-i,r=t.x+t.width/2-i,s=this._placeGlyphAlongLine(n,f,m,!1),a=this._placeGlyphAlongLine(r,f,m,!1);if(s&&a){const e=this._tempVector2.x/this._tempVector2.y,t=(a.x-s.x)*e,i=a.y-s.y;let n="horizontal",r=this._requiresOrientationChange(t,i,n);r&&r.useVertical&&(n="vertical",r=this._requiresOrientationChange(t,i,n)),r&&r.needsFlipping?(S=!0,this._flipStates.set(h,this.FlipState.flipRequired)):this._flipStates.set(h,this.FlipState.flipNotRequired),C=Math.abs(i)>Math.abs(t)}}const T=(b.glyphs[b.glyphs.length-1].x+b.glyphs[b.glyphs.length-1].width)/2,E=[];for(let M=0;M<b.glyphs.length;M++){const e=b.glyphs[M],t=e.x+e.width/2-T,i=this._placeGlyphAlongLine(t,f,m,S,C);if(!i)return u&&this._initializedGroups.add(h),[];E.push({x:i.x,y:i.y,char:e.char,rotation:i.angle,size:g,fillColor:_,strokeColor:A,strokeWidth:v})}return u&&this._initializedGroups.add(h),E}_parseColorToRgba(e,t="#ffffff"){if(e||(e=t),Array.isArray(e)){return[e[0]>1?e[0]/255:e[0],e[1]>1?e[1]/255:e[1],e[2]>1?e[2]/255:e[2],e.length>3?e[3]>1?e[3]/255:e[3]:1]}if("string"==typeof e){const t=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(t){return[parseInt(t[1],10)/255,parseInt(t[2],10)/255,parseInt(t[3],10)/255,void 0!==t[4]?parseFloat(t[4]):1]}if(e.startsWith("#")){let t=e.replace("#","");3===t.length&&(t=t.split("").map((e=>e+e)).join(""));return[parseInt(t.substring(0,2),16)/255,parseInt(t.substring(2,4),16)/255,parseInt(t.substring(4,6),16)/255,1]}}return[1,1,1,1]}_shapeText(e,t){const i=this._measureCtx;i.font=`${t}px ${this.parameters.fontFamily||"sans-serif"}`;const n=[];let r=0;for(let s=0;s<e.length;s++){const t=e[s],a=i.measureText(t).width;n.push({char:t,x:r,width:a,advance:a}),r+=a}return{glyphs:n,totalWidth:r}}_distance(e,t){const i=t.x-e.x,n=t.y-e.y;return Math.sqrt(i*i+n*n)}_lineToScreenCoords(e,t,i){const n=[];for(let a=0;a<e.length;a++){const i=e[a];this._tempVector4.set(i[0],i[1],i[2],1),this._tempVector4.applyMatrix4(t),n.push({x:this._tempVector4.x,y:this._tempVector4.y,z:this._tempVector4.z,w:this._tempVector4.w,originalIndex:a})}const r=[];for(let a=0;a<n.length;a++){const e=n[a],t=n[a+1];if(e.w>0&&r.push(e),t&&(e.w>0&&t.w<=0||e.w<=0&&t.w>0)){const i=.001,n=(i-e.w)/(t.w-e.w),s={x:e.x+n*(t.x-e.x),y:e.y+n*(t.y-e.y),z:e.z+n*(t.z-e.z),w:i,isClipped:!0,originalSegment:a,originalIndex:void 0};r.push(s)}}const s=[];for(let a=0;a<r.length;a++){const e=r[a],t=e.x/e.w,n=e.y/e.w,o=e.z/e.w,l=(t+1)/2*i.x,c=(1-n)/2*i.y;s.push({x:l,y:c,z:o,originalW:e.w,isClipped:e.isClipped||!1,originalIndex:e.originalIndex})}return s}_worldToScreen(e,t,i){this._tempVector4_2.set(e[0],e[1],e[2],1),this._tempVector4_2.applyMatrix4(t),this._tempVector4_2.divideScalar(this._tempVector4_2.w);return{x:(this._tempVector4_2.x+1)/2*i.x,y:(1-this._tempVector4_2.y)/2*i.y}}_findSegmentForAnchor(e,t){let i=1/0,n=0;for(let r=0;r<t.length-1;r++){const s=this._pointToSegmentDistance(e,t[r],t[r+1]);s<i&&(i=s,n=r)}return n}_pointToSegmentDistance(e,t,i){const n=e.x,r=e.y,s=t.x,a=t.y,o=i.x-s,l=i.y-a,c=o*o+l*l;if(0===c)return this._distance(e,t);let h=((n-s)*o+(r-a)*l)/c;h=Math.max(0,Math.min(1,h));const u=n-(s+h*o),d=r-(a+h*l);return Math.sqrt(u*u+d*d)}_isAnchorVisible(e,t){const{clippingBuffer:i}=this.parameters,n=i/t.x*2,r=i/t.y*2,s=e.x/t.x*2-1,a=1-e.y/t.y*2;return s>=-1-n&&s<=1+n&&a>=-1-r&&a<=1+r}_isPointBehindCamera(e,t){return this._tempVector4_2.set(e[0],e[1],e[2]||0,1),this._tempVector4_2.applyMatrix4(t),this._tempVector4_2.w<=0}_isInFlipRetainRange(e,t){const i=Math.tan(85*Math.PI/180);return 0===e||Math.abs(t/e)>i}_requiresOrientationChange(e,t,i="horizontal"){return Math.abs(t)>Math.abs(e)?t<0?{needsFlipping:!0,useVertical:!0}:null:e<0?{needsFlipping:!0}:null}_placeGlyphAlongLine(e,t,i,n=!1,r=!1){const s=!this._placeGlyphDebugDone;if(!t||void 0===t.segment)return null;if(!i||i.length<2)return null;if(t.segment>i.length-2)return null;if(Math.abs(e)<1e-6){const e=i[t.segment],s=i[t.segment+1],a=s.x-e.x,o=s.y-e.y,l=Math.atan2(o,a);let c=(n?Math.PI:0)+l;return r&&(c-=Math.PI/2),{x:t.x,y:t.y,z:t.z||0,angle:c,segment:t.segment}}let a=e>0?1:-1,o=0,l=!1;n&&(a*=-1,o=Math.PI);const c=a<0?Math.PI:0,h=i[t.segment],u=i[t.segment+1];if(!h||!u)return null;const d=Math.abs(e);let p=t.segment,m=d,f={x:t.x,y:t.y,z:t.z||0},g=a>0?i[p+1]:i[p],_=this._distance(f,g);_<1e-6&&(a>0?p>=i.length-2||(p++,f=i[p],g=i[p+1],_=this._distance(f,g)):p<=0||(p--,f=i[p+1],g=i[p],_=this._distance(f,g)));let A=null;for(;m>_;){if(m-=_,A&&this.parameters.textMaxAngle<180){const e={x:A.end.x-A.start.x,y:A.end.y-A.start.y,z:(A.end.z||0)-(A.start.z||0)},t={x:g.x-f.x,y:g.y-f.y,z:(g.z||0)-(f.z||0)},i=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z),n=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z);if(i>0&&n>0){const r=(e.x*t.x+e.y*t.y+e.z*t.z)/(i*n),s=this.parameters.textMaxAngle*Math.PI/180;if(r<Math.cos(s))return null}}if(A={start:f,end:g},p+=a,p<0){const e=i[0],t=i[1],n={x:t.x-e.x,y:t.y-e.y,z:(t.z||0)-(e.z||0)},r=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z);if(0===r||!isFinite(m))return null;if(m>r)return null;const s={x:n.x/r,y:n.y/r,z:n.z/r};f={x:e.x-s.x*m,y:e.y-s.y*m,z:(e.z||0)-s.z*m},g=e,_=m,m=0,p=0,l=!0;break}if(p>=i.length-1){const e=i[i.length-2],t=i[i.length-1],n={x:t.x-e.x,y:t.y-e.y,z:(t.z||0)-(e.z||0)},r=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z);if(0===r||!isFinite(m))return null;if(m>r)return null;const s={x:n.x/r,y:n.y/r,z:n.z/r};f=t,g={x:t.x+s.x*m,y:t.y+s.y*m,z:(t.z||0)+s.z*m},_=m,p=i.length-2,l=!0;break}f=a>0?i[p]:i[p+1],g=a>0?i[p+1]:i[p],_=this._distance(f,g)}const v=m/_,y=f,x=g,b=y.x+(x.x-y.x)*v,S=y.y+(x.y-y.y)*v,C=(y.z||0)+((x.z||0)-(y.z||0))*v,T=x.x-y.x,E=x.y-y.y,M=Math.atan2(E,T);let w;return w=l?o+M:o+c+M,r&&(w-=Math.PI/2),s&&(this._placeGlyphDebugDone=!0),{x:b,y:S,z:C,angle:w,segment:p}}_updateData(){if(!this.dataSource||!this.engine)return;let e=this.dataSource.userData;this._enableCollision&&this._collisionData&&(e=this._collisionData);const t=[],i=[],n=[],r=[];for(let s=0;s<e.length;s++){const i=[e[s].position[0],e[s].position[1],e[s].position[2]||0],n=e[s].text,r=e[s].linePoints;if(!n||!r||!Array.isArray(r))continue;const a=e[s].id||`text_${s}_${n}`,o=e[s].anchorIndex;t.push({text:n,line:r,anchor:i,anchorIndex:o,id:a,textFillStyle:e[s].textFillStyle,textSize:e[s].textSize,textStrokeStyle:e[s].textStrokeStyle,textStrokeWidth:e[s].textStrokeWidth})}if(this.parameters.debug&&this.engine.map){const e=this.dataSource.userData;for(let t=0;t<e.length;t++){const s=e[t].linePoints,a=e[t].anchorIndex,o=e[t].id;if(!s||!Array.isArray(s)||s.length<2)continue;const l=s.map((e=>this.engine.map.unprojectArrayCoordinate(e))).filter((e=>e&&e.length>=2));l.length>=2&&i.push({type:"Feature",geometry:{type:"LineString",coordinates:l},properties:{textId:o}}),s.forEach(((e,t)=>{const i=this.engine.map.unprojectArrayCoordinate(e);i&&i.length>=2&&(t===a?r.push({type:"Feature",geometry:{type:"Point",coordinates:i},properties:{textId:o,index:t}}):n.push({type:"Feature",geometry:{type:"Point",coordinates:i},properties:{textId:o,index:t}}))}))}}this.parameters.debug&&this._updateDebugObjects(i,n,r),t.length>0?this.setTextsAlongLines(t):this.setTexts([]),this.needsUpdate=!1}_updateDebugObjects(e,t,i){if(this._debugPolyline&&this._debugNormalPoints&&this._debugAnchorPoints)try{e.length>0?this._debugPolyline.dataSource=GeoJSONDataSource.fromGeoJSON(e):this._debugPolyline.dataSource=GeoJSONDataSource.fromGeoJSON([]),t.length>0?this._debugNormalPoints.dataSource=GeoJSONDataSource.fromGeoJSON(t):this._debugNormalPoints.dataSource=GeoJSONDataSource.fromGeoJSON([]),i.length>0?this._debugAnchorPoints.dataSource=GeoJSONDataSource.fromGeoJSON(i):this._debugAnchorPoints.dataSource=GeoJSONDataSource.fromGeoJSON([])}catch(n){console.error("Failed to update debug objects:",n)}}showAtlasDebug(e={}){const{size:t=300,position:i="top-right",autoUpdate:n=!0}=e;this._debugPanel&&this._debugPanel.remove();const r=document.createElement("div");r.style.position="fixed",r.style.zIndex="10000",r.style.background="rgba(0, 0, 0, 0.8)",r.style.padding="10px",r.style.borderRadius="5px",r.style.boxShadow="0 2px 10px rgba(0,0,0,0.5)",r.style.fontFamily="monospace",r.style.fontSize="12px",r.style.color="#fff";const s={"top-left":{top:"10px",left:"10px"},"top-right":{top:"10px",right:"10px"},"bottom-left":{bottom:"10px",left:"10px"},"bottom-right":{bottom:"10px",right:"10px"}};Object.assign(r.style,s[i]||s["top-right"]);const a=document.createElement("div");a.textContent="ScreenText Atlas Debug",a.style.marginBottom="10px",a.style.fontWeight="bold",a.style.borderBottom="1px solid #666",a.style.paddingBottom="5px",r.appendChild(a);const o=document.createElement("div");o.style.marginBottom="10px",r.appendChild(o);const l=document.createElement("div");l.style.border="1px solid #666",l.style.background="#222",l.style.display="flex",l.style.justifyContent="center",l.style.alignItems="center",l.style.overflow="hidden",r.appendChild(l);const c=document.createElement("canvas");c.style.maxWidth=`${t}px`,c.style.maxHeight=`${t}px`,c.style.imageRendering="pixelated",l.appendChild(c);const h=document.createElement("button");h.textContent="✕",h.style.position="absolute",h.style.top="10px",h.style.right="10px",h.style.background="#ff4444",h.style.border="none",h.style.color="#fff",h.style.width="20px",h.style.height="20px",h.style.borderRadius="3px",h.style.cursor="pointer",h.style.fontSize="14px",h.style.lineHeight="1",h.onclick=()=>this.hideAtlasDebug(),r.appendChild(h),document.body.appendChild(r),this._debugPanel=r;const u=()=>{if(!this.atlasTexture||!this._debugPanel)return;const e=this.fontAtlasManager.atlas;if(!e||!e.textureData)return;const t=this.fontAtlasManager.mapping,i=t?Object.keys(t).length:0,n=e.width,r=e.height,s=this._lastCharCount||0;o.innerHTML=`\n                <div>Atlas Size: ${n} × ${r}</div>\n                <div>Cached Chars: ${i}</div>\n                <div>Rendered Chars: ${s}</div>\n                <div>Type: SDF Texture</div>\n            `,c.width=n,c.height=r;const a=c.getContext("2d"),l=a.createImageData(n,r),h=e.textureData;for(let o=0;o<h.length;o++){const e=h[o],t=4*o;l.data[t]=e,l.data[t+1]=e,l.data[t+2]=e,l.data[t+3]=255}if(a.putImageData(l,0,0),t&&i>0&&i<100){a.strokeStyle="rgba(255, 0, 0, 0.5)",a.lineWidth=1;for(const e of Object.values(t)){const t=e.x,i=e.y,n=e.width+2*SDF_BUFFER,r=e.height;a.strokeRect(t,i,n,r)}}};return u(),n&&(this._debugUpdateInterval=setInterval(u,100)),this}hideAtlasDebug(){return this._debugPanel&&(this._debugPanel.remove(),this._debugPanel=null),this._debugUpdateInterval&&(clearInterval(this._debugUpdateInterval),this._debugUpdateInterval=null),this}getAtlasTexture(){return this.atlasTexture}getFontAtlasManager(){return this.fontAtlasManager}getCharacterSet(){var e;const t=null==(e=this.fontAtlasManager)?void 0:e.mapping;if(!t)return new Set;const i=(this.parameters.fontWeight||"400")+(this.parameters.fontFamily||"sans-serif"),n=new Set;for(const r of Object.keys(t))if(r.endsWith(i)){const e=r.slice(0,-i.length);n.add(e)}return n}dispose(){this.hideAtlasDebug(),this._debugPolyline&&(this.engine&&this.engine.remove(this._debugPolyline),this._debugPolyline.dispose(),this._debugPolyline=null),this._debugNormalPoints&&(this.engine&&this.engine.remove(this._debugNormalPoints),this._debugNormalPoints.dispose(),this._debugNormalPoints=null),this._debugAnchorPoints&&(this.engine&&this.engine.remove(this._debugAnchorPoints),this._debugAnchorPoints.dispose(),this._debugAnchorPoints=null),this._shapeCache&&this._shapeCache.clear(),this._placeTextCache&&this._placeTextCache.clear(),this._flipStates&&this._flipStates.clear(),this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose(),this.atlasTexture&&this.atlasTexture.dispose()}}function bucketSort(e){let t=e.reduce(((e,t)=>{let i=+t.split("-")[0];return Math.max(i,e)}),0);return(e=e.sort(((e,i)=>{const n=e.split("-"),r=i.split("-");let s=n[0],a=n[1],o=n[2],l=r[0],c=r[1],h=r[2];if(s!==t){const e=t-s;a*=Math.pow(2,e),o*=Math.pow(2,e)}if(l!==t){const e=t-l;c*=Math.pow(2,e),h*=Math.pow(2,e)}return a!==c?c-a:h-o}))).reverse(),e}const getUUID=()=>(new Date).getTime()+Math.random().toString(36).slice(2);class RenderingLabel{constructor(e){__publicField(this,"_blocks",{}),__publicField(this,"_collisionLabels",{icon_text:{},text_flat:{},text_fix:{},icon_flat:{},icon_flat_with_depth:{},icon:{}}),__publicField(this,"_removalBuffer",[]),__publicField(this,"_removalBufferSize",6),__publicField(this,"_timers",{}),__publicField(this,"_enabled",!1),__publicField(this,"_spriteTexture",null),this._rendering=e}get enabled(){return this._enabled}set enabled(e){e!==this._enabled&&(this._enabled=e,e?this.init():this.dispose())}set spriteTexture(e){this._spriteTexture||(this._spriteTexture=e)}init(){this.initCollisionLabel(),this.initLabel()}initCollisionLabel(){const e=this._iconDataSource=new DataSource,t=this._icon=this._rendering.add(new Label({type:"icon",vertexIcons:!0,enableFade:!0,isRenderInPostprocess:!0}));e.defineAttributes({id:"id",icon:"icon",iconSize:"iconSize",boundingBox:"boundingBox",offset:"offset",checkVisible:"checkVisible",tolerance:"tolerance"}),t.dataSource=e;const i=this._iconUvDataSource=new DataSource,n=this._iconUv=this._rendering.add(new Label({spriteTexture:this._spriteTexture,transparent:!0,enableFade:!0,isRenderInPostprocess:!0,type:"icon"}));i.defineAttributes({id:"id",iconUvs:"iconUvs",iconSize:"iconSize",iconOpacity:"iconOpacity",boundingBox:"boundingBox",offset:"offset",checkVisible:"checkVisible",tolerance:"tolerance"}),n.dataSource=i;const r=this._iconFlatUvDataSource=new DataSource,s=this._iconFlatUv=this._rendering.add(new Label({spriteTexture:this._spriteTexture,transparent:!0,isRenderInPostprocess:!0,enableFade:!0,flat:!0,type:"icon"}));r.defineAttributes({id:"id",iconUvs:"iconUvs",iconSize:"iconSize",iconOpacity:"iconOpacity",rotateZ:"rotateZ",boundingBox:"boundingBox",checkVisible:"checkVisible",tolerance:"tolerance"}),s.dataSource=r;const a=this._textFlatDataSource=new DataSource,o=this._textFlat=this._rendering.add(new Label({type:"text",isRenderInPostprocess:!0,enableFade:!0,flat:!0}));a.defineAttributes({id:"id",text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textAnchor:"textAnchor",textWeight:"textWeight",rotateZ:"rotateZ",boundingBox:"boundingBox",checkVisible:"checkVisible",tolerance:"tolerance"}),o.dataSource=a;const l=this._textFixedDataSource=new DataSource,c=this._textFixed=this._rendering.add(new Label({type:"text",isRenderInPostprocess:!0,enableFade:!0,flat:!1}));l.defineAttributes({id:"id",text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textWeight:"textWeight",textAnchor:"textAnchor",boundingBox:"boundingBox",offset:"offset",checkVisible:"checkVisible",tolerance:"tolerance"}),c.dataSource=l;const h=this._iconTextDataSource=new DataSource,u=this._iconText=this._rendering.add(new Label({type:"icontext",vertexIcons:!0,enableFade:!0,isRenderInPostprocess:!0}));h.defineAttributes({id:"id",text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textWeight:"textWeight",textAnchor:"textAnchor",textDrawOnIcon:"textDrawOnIcon",icon:"icon",iconSize:"iconSize",direction:"direction",rotateZ:"rotateZ",boundingBox:"boundingBox",offset:"offset",checkVisible:"checkVisible",tolerance:"tolerance"}),u.dataSource=h;const d=this._iconTextUvDataSource=new DataSource,p=this._iconTextUv=this._rendering.add(new Label({type:"icontext",isRenderInPostprocess:!0,spriteTexture:this._spriteTexture,enableFade:!0,transparent:!0}));d.defineAttributes({id:"id",type:"type",text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textWeight:"textWeight",textOffset:"textOffset",textAnchor:"textAnchor",textDrawOnIcon:"textDrawOnIcon",rotateZ:"rotateZ",iconUvs:"iconUvs",iconSize:"iconSize",iconOpacity:"iconOpacity",boundingBox:"boundingBox",offset:"offset",checkVisible:"checkVisible",tolerance:"tolerance"}),p.dataSource=d;const m=this._roadLabelDataSource=new DataSource,f=this._roadLabel=this._rendering.add(new ScreenText({fontSize:16,color:"#000000",strokeWidth:2,strokeColor:"#ffffff",keepUpright:!0,textMaxAngle:45,debug:!1}));m.defineAttributes({text:"text",linePoints:"linePoints",anchorIndex:"anchorIndex",id:"id",rank:"rank",bucket:"bucket",distance:"distance",tolerance:"tolerance",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth"}),f.dataSource=m,this._rendering.collision.setGroupOption("poi",{enabledBucketCache:!0,requireClip:!1,bucketSort:bucketSort}),this._rendering.collision.add(t,{margin:[2,2]},"poi"),this._rendering.collision.add(n,{margin:[2,2]},"poi"),this._rendering.collision.add(s,{margin:[2,2]},"poi"),this._rendering.collision.add(o,{margin:[2,2]},"poi"),this._rendering.collision.add(c,{margin:[2,2]},"poi"),this._rendering.collision.add(u,{margin:[2,2]},"poi"),this._rendering.collision.add(p,{margin:[2,2]},"poi"),this._rendering.collision.add(f,{margin:[2,2]},"poi")}initLabel(){const e=this._labelIconDataSource=new DataSource,t=this._labelIcon=this._rendering.add(new Label({type:"icon",vertexIcons:!0,isRenderInPostprocess:!0}));e.defineAttributes({id:"id",icon:"icon",iconSize:"iconSize",offset:"offset"}),t.dataSource=e;const i=this._labelIconFlatDataSource=new DataSource,n=this._labelIconFlat=this._rendering.add(new Label({vertexIcons:!0,transparent:!0,isRenderInPostprocess:!0,flat:!0,type:"icon"}));i.defineAttributes({id:"id",icon:"icon",iconSize:"iconSize",offset:"offset",iconUvs:"iconUvs",iconOpacity:"iconOpacity",rotateZ:"rotateZ"}),n.dataSource=i;const r=this._labelIconFlatDepthDataSource=new DataSource,s=this._labelIconFlatDepth=this._rendering.add(new Label({vertexIcons:!0,transparent:!0,depthTest:!0,keepSize:!1,flat:!0,type:"icon"}));r.defineAttributes({id:"id",icon:"icon",iconSize:"iconSize",offset:"offset",iconUvs:"iconUvs",iconOpacity:"iconOpacity",rotateZ:"rotateZ"}),s.dataSource=r;const a=this._labelTextFlatDataSource=new DataSource,o=this._labelTextFlat=this._rendering.add(new Label({type:"text",isRenderInPostprocess:!0,flat:!0}));a.defineAttributes({text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textAnchor:"textAnchor",rotateZ:"rotateZ"}),o.dataSource=a;const l=this._labelTextFixedDataSource=new DataSource,c=this._labelTextFixed=this._rendering.add(new Label({type:"text",isRenderInPostprocess:!0,flat:!1}));l.defineAttributes({text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textAnchor:"textAnchor",offset:"offset"}),c.dataSource=l;const h=this._labelIconTextDataSource=new DataSource,u=this._labelIconText=this._rendering.add(new Label({type:"icontext",vertexIcons:!0,isRenderInPostprocess:!0}));h.defineAttributes({text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textAnchor:"textAnchor",textDrawOnIcon:"textDrawOnIcon",icon:"icon",iconSize:"iconSize",direction:"direction",rotateZ:"rotateZ",offset:"offset"}),u.dataSource=h}getLabelType(e){let t=e.type;if(t)return t;const i=e.flat;let n=!1,r=!1;if(e.text&&(n=!0),e.mapSrc){const{width:t,height:i}=e;e.icon=e.mapSrc,e.iconSize=[t||40,i||40],r=!0}return n&&r?t="icon_text":n?t=i?"text_flat":"text_fix":r&&(t=i?"icon_flat":"icon"),t}processLabel(e){return e.type=this.getLabelType(e),e}_getCollisionLabel(e){let t=e.type||this.getLabelType(e),i=e.group||"default";e.attributes&&e.attributes.group&&(i=e.attributes.group);const n=this._collisionLabels[t];if(n[i])return n[i];let r;const s=new DataSource;return"icon_text"===t?(r=this._rendering.add(new Label({type:"icontext",vertexIcons:!0,isRenderInPostprocess:!0})),s.defineAttributes({text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textWeight:"textWeight",textAnchor:"textAnchor",textDrawOnIcon:"textDrawOnIcon",icon:"icon",iconSize:"iconSize",direction:"direction",rotateZ:"rotateZ",offset:"offset",tolerance:"tolerance",isCustom:"isCustom"})):"icon"===t?(r=this._rendering.add(new Label({type:"icon",vertexIcons:!0,isRenderInPostprocess:!0})),s.defineAttributes({id:"id",icon:"icon",iconSize:"iconSize",offset:"offset",tolerance:"tolerance",isCustom:"isCustom"})):"icon_flat"===t?(r=this._rendering.add(new Label({vertexIcons:!0,transparent:!0,isRenderInPostprocess:!0,flat:!0,type:"icon"})),s.defineAttributes({id:"id",icon:"icon",iconSize:"iconSize",offset:"offset",iconUvs:"iconUvs",iconOpacity:"iconOpacity",rotateZ:"rotateZ",tolerance:"tolerance",isCustom:"isCustom"})):"text_flat"===t?(r=this._rendering.add(new Label({type:"text",isRenderInPostprocess:!0,flat:!0})),s.defineAttributes({text:"text",textSize:"textSize",textWeight:"textWeight",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textAnchor:"textAnchor",rotateZ:"rotateZ",tolerance:"tolerance",isCustom:"isCustom"})):"text_fix"===t&&(r=this._rendering.add(new Label({type:"text",isRenderInPostprocess:!0,flat:!1})),s.defineAttributes({text:"text",textSize:"textSize",textWeight:"textWeight",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textAnchor:"textAnchor",offset:"offset",tolerance:"tolerance",isCustom:"isCustom"})),r.dataSource=s,n[i]=r,this._rendering.collision.add(r,{margin:[0,0]},i),r}addCollisionLabel(e){const t=e.type,i=!!t;i||this.processLabel(e);const n=this.computeBoundingBox(e);e.boundingBox=n;let r=e;if(!(e instanceof DataItem)&&"[object Object]"===Array.prototype.toString.call(e)){const{position:t,forceProjected:n,...s}=e;s.isCustom=!i,r=new DataItem(t,s,n)}if("icon_text"===t)this._iconTextDataSource.add(r);else if("icon_text_uv"===t)this._iconTextUvDataSource.add(r);else if("icon"===t)this._iconDataSource.add(r);else if("icon_uv"===t)this._iconUvDataSource.add(r);else if("icon_flat_uv"===t)this._iconFlatUvDataSource.add(r);else if("text_flat"===t||"labelp"===t)this._textFlatDataSource.add(r);else if("text_fix"===t)this._textFixedDataSource.add(r);else{const t=this._getCollisionLabel(e),i=e.type;let n=e.group||"default";e.attributes&&e.attributes.group&&(n=e.attributes.group),this._clearLabelFromRemovalBuffer(i,n),t.dataSource.add(r)}return r}addNormalLabel(e){let t=e;if(!(e instanceof DataItem)&&"[object Object]"===Array.prototype.toString.call(e)){const{position:i,forceProjected:n,...r}=e;t=new DataItem(i,r,n)}return"icon"===e.type?this._labelIconDataSource.add(t):"icon_flat"===e.type?this._labelIconFlatDataSource.add(t):"icon_flat_with_depth"===e.type?this._labelIconFlatDepthDataSource.add(t):"text_flat"===e.type?this._labelTextFlatDataSource.add(t):"text_fix"===e.type?this._labelTextFixedDataSource.add(t):"icon_text"===e.type&&this._labelIconTextDataSource.add(t),t}addLabel(e){this.enabled||(this.enabled=!0);if(!e.position)return void console.warn("need position");let t;return e.collision?t=this.addCollisionLabel(e):(this.processLabel(e),t=this.addNormalLabel(e)),t}addLabels(e,t){this.enabled||(this.enabled=!0);const i=this._rendering.taskScheduler.addTask(this._createLabelTask(e));return t=t||getUUID(),this._blocks[t]=i,i.promise}_createLabelTask(e){return()=>new Promise(((t,i)=>{try{const i=[];for(const t of e){const e=defaultValue$1(t.collision,!0);if(t.collision=e,e){const e=this.addCollisionLabel(t);i.push(e)}else{const e=this.addNormalLabel(t);i.push(e)}}this._rendering.requestRender(),t(i)}catch(n){i(n)}}))}computeBoundingBox(e){let t;return this.enabled||(this.enabled=!0),"icon_text"===e.type?t=this._iconText.computeBoundingBox(e):"icon_text_uv"===e.type?t=this._iconTextUv.computeBoundingBox(e):"icon"===e.type?t=this._icon.computeBoundingBox(e):"icon_uv"===e.type?t=this._iconUv.computeBoundingBox(e):"icon_flat_uv"===e.type?t=this._iconFlatUv.computeBoundingBox(e):"text_flat"===e.type||"labelp"===e.type?t=this._textFlat.computeBoundingBox(e):"text_fix"===e.type&&(t=this._textFixed.computeBoundingBox(e)),t}_checkRemoveCollisionLabel(e,t){if(1===e.dataSource.userData.length){const i=t.type||this.getLabelType(t);let n=t.group||"default";t.attributes&&t.attributes.group&&(n=t.attributes.group);const r=`${i}-${n}`;this._removalBuffer.find((e=>e.key===r))||this._removalBuffer.push({collisionLabel:e,key:r}),this._removalBuffer.length>=this._removalBufferSize&&this._flushPartialRemovalBuffer()}}_flushPartialRemovalBuffer(){const e=Math.floor(this._removalBuffer.length/2),t=this._removalBuffer.splice(0,e);for(const i of t){const{collisionLabel:e,key:t}=i;if(!e||!e.dataSource)continue;const[n,r]=t.split("-");this._rendering.remove(e),this._rendering.collision.remove(e,r),this._collisionLabels[n]&&delete this._collisionLabels[n][r]}}_clearLabelFromRemovalBuffer(e,t){const i=`${e}-${t}`,n=this._removalBuffer.findIndex((e=>e.key===i));-1!==n&&this._removalBuffer.splice(n,1)}removeCollisionLabel(e){if(e.isCustom||e.attributes&&e.attributes.isCustom){const t=this._getCollisionLabel(e);return t.dataSource.remove(e),void this._checkRemoveCollisionLabel(t,e,t.dataSource)}"icon_text"===e.type?this._iconTextDataSource.remove(e):"icon_text_uv"===e.type?this._iconTextUvDataSource.remove(e):"icon"===e.type?this._iconDataSource.remove(e):"icon_uv"===e.type?this._iconUvDataSource.remove(e):"icon_flat_uv"===e.type?this._iconFlatUvDataSource.remove(e):"text_flat"===e.type||"labelp"===e.type?this._textFlatDataSource.remove(e):"text_fix"===e.type&&this._textFixedDataSource.remove(e)}removeNormalLabel(e){const t=e.attributes;let i=e.type;t&&t.type&&(i=t.type),"icon"===i?this._labelIconDataSource.remove(e):"icon_flat"===i?this._labelIconFlatDataSource.remove(e):"icon_flat_with_depth"===i?this._labelIconFlatDepthDataSource.remove(e):"text_flat"===i?this._labelTextFlatDataSource.remove(e):"text_fix"===i?this._labelTextFixedDataSource.remove(e):"icon_text"===i&&this._labelIconTextDataSource.remove(e)}removeLabel(e){let t=e.collision;t||(t=e.attributes&&e.attributes.collision),t?this.removeCollisionLabel(e):this.removeNormalLabel(e)}removeLabels(e,t){const i=this._blocks[t];if(i&&!i.isStart())return i.cancel(),void delete this._blocks[t];for(const n of e){const e=defaultValue$1(n.collision,!0);n.collision=e,this.removeLabel(n)}this._rendering.requestRender()}addRoadLabels(e,t){this.enabled||(this.enabled=!0);for(const i of e){const{position:e,...t}=i,n=new DataItem(e,t);this._roadLabelDataSource.add(n)}}removeRoadLabels(e){for(const t of e){const e=t.id,i=this._roadLabelDataSource.userData;for(let t=i.length-1;t>=0;t--)if(i[t].id===e){this._roadLabelDataSource.remove(i[t]);break}}}dispose(){this._rendering.collision.remove(this._fixText,"poi"),this._rendering.collision.remove(this._labelText,"poi"),this._rendering.collision.remove(this._flatText,"poi"),this._rendering.remove(this._fixText),this._rendering.remove(this._flatText),this._rendering.remove(this._labelText),this._roadLabel&&(this._rendering.collision.remove(this._roadLabel,"poi"),this._rendering.remove(this._roadLabel))}}function quickselect(e,t,i,n,r){quickselectStep(e,t,i||0,n||e.length-1,r||defaultCompare)}function quickselectStep(e,t,i,n,r){for(;n>i;){if(n-i>600){var s=n-i+1,a=t-i+1,o=Math.log(s),l=.5*Math.exp(2*o/3),c=.5*Math.sqrt(o*l*(s-l)/s)*(a-s/2<0?-1:1);quickselectStep(e,t,Math.max(i,Math.floor(t-a*l/s+c)),Math.min(n,Math.floor(t+(s-a)*l/s+c)),r)}var h=e[t],u=i,d=n;for(swap$3(e,i,t),r(e[n],h)>0&&swap$3(e,i,n);u<d;){for(swap$3(e,u,d),u++,d--;r(e[u],h)<0;)u++;for(;r(e[d],h)>0;)d--}0===r(e[i],h)?swap$3(e,i,d):swap$3(e,++d,n),d<=t&&(i=d+1),t<=d&&(n=d-1)}}function swap$3(e,t,i){var n=e[t];e[t]=e[i],e[i]=n}function defaultCompare(e,t){return e<t?-1:e>t?1:0}class RBush{constructor(e=9){this._maxEntries=Math.max(4,e),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}all(){return this._all(this.data,[])}search(e){let t=this.data;const i=[];if(!intersects$1(e,t))return i;const n=this.toBBox,r=[];for(;t;){for(let s=0;s<t.children.length;s++){const a=t.children[s],o=t.leaf?n(a):a;intersects$1(e,o)&&(t.leaf?i.push(a):contains(e,o)?this._all(a,i):r.push(a))}t=r.pop()}return i}collides(e){let t=this.data;if(!intersects$1(e,t))return!1;const i=[];for(;t;){for(let n=0;n<t.children.length;n++){const r=t.children[n],s=t.leaf?this.toBBox(r):r;if(intersects$1(e,s)){if(t.leaf||contains(e,s))return!0;i.push(r)}}t=i.pop()}return!1}load(e){if(!e||!e.length)return this;if(e.length<this._minEntries){for(let t=0;t<e.length;t++)this.insert(e[t]);return this}let t=this._build(e.slice(),0,e.length-1,0);if(this.data.children.length)if(this.data.height===t.height)this._splitRoot(this.data,t);else{if(this.data.height<t.height){const e=this.data;this.data=t,t=e}this._insert(t,this.data.height-t.height-1,!0)}else this.data=t;return this}insert(e){return e&&this._insert(e,this.data.height-1),this}clear(){return this.data=createNode([]),this}remove(e,t){if(!e)return this;let i=this.data;const n=this.toBBox(e),r=[],s=[];let a,o,l;for(;i||r.length;){if(i||(i=r.pop(),o=r[r.length-1],a=s.pop(),l=!0),i.leaf){const n=findItem(e,i.children,t);if(-1!==n)return i.children.splice(n,1),r.push(i),this._condense(r),this}l||i.leaf||!contains(i,n)?o?(a++,i=o.children[a],l=!1):i=null:(r.push(i),s.push(a),a=0,o=i,i=i.children[0])}return this}toBBox(e){return e}compareMinX(e,t){return e.minX-t.minX}compareMinY(e,t){return e.minY-t.minY}toJSON(){return this.data}fromJSON(e){return this.data=e,this}_all(e,t){const i=[];for(;e;)e.leaf?t.push(...e.children):i.push(...e.children),e=i.pop();return t}_build(e,t,i,n){const r=i-t+1;let s,a=this._maxEntries;if(r<=a)return s=createNode(e.slice(t,i+1)),calcBBox(s,this.toBBox),s;n||(n=Math.ceil(Math.log(r)/Math.log(a)),a=Math.ceil(r/Math.pow(a,n-1))),s=createNode([]),s.leaf=!1,s.height=n;const o=Math.ceil(r/a),l=o*Math.ceil(Math.sqrt(a));multiSelect(e,t,i,l,this.compareMinX);for(let c=t;c<=i;c+=l){const t=Math.min(c+l-1,i);multiSelect(e,c,t,o,this.compareMinY);for(let i=c;i<=t;i+=o){const r=Math.min(i+o-1,t);s.children.push(this._build(e,i,r,n-1))}}return calcBBox(s,this.toBBox),s}_chooseSubtree(e,t,i,n){for(;n.push(t),!t.leaf&&n.length-1!==i;){let i,n=1/0,r=1/0;for(let s=0;s<t.children.length;s++){const a=t.children[s],o=bboxArea(a),l=enlargedArea(e,a)-o;l<r?(r=l,n=o<n?o:n,i=a):l===r&&o<n&&(n=o,i=a)}t=i||t.children[0]}return t}_insert(e,t,i){const n=i?e:this.toBBox(e),r=[],s=this._chooseSubtree(n,this.data,t,r);for(s.children.push(e),extend$1(s,n);t>=0&&r[t].children.length>this._maxEntries;)this._split(r,t),t--;this._adjustParentBBoxes(n,r,t)}_split(e,t){const i=e[t],n=i.children.length,r=this._minEntries;this._chooseSplitAxis(i,r,n);const s=this._chooseSplitIndex(i,r,n),a=createNode(i.children.splice(s,i.children.length-s));a.height=i.height,a.leaf=i.leaf,calcBBox(i,this.toBBox),calcBBox(a,this.toBBox),t?e[t-1].children.push(a):this._splitRoot(i,a)}_splitRoot(e,t){this.data=createNode([e,t]),this.data.height=e.height+1,this.data.leaf=!1,calcBBox(this.data,this.toBBox)}_chooseSplitIndex(e,t,i){let n,r=1/0,s=1/0;for(let a=t;a<=i-t;a++){const t=distBBox(e,0,a,this.toBBox),o=distBBox(e,a,i,this.toBBox),l=intersectionArea(t,o),c=bboxArea(t)+bboxArea(o);l<r?(r=l,n=a,s=c<s?c:s):l===r&&c<s&&(s=c,n=a)}return n||i-t}_chooseSplitAxis(e,t,i){const n=e.leaf?this.compareMinX:compareNodeMinX,r=e.leaf?this.compareMinY:compareNodeMinY;this._allDistMargin(e,t,i,n)<this._allDistMargin(e,t,i,r)&&e.children.sort(n)}_allDistMargin(e,t,i,n){e.children.sort(n);const r=this.toBBox,s=distBBox(e,0,t,r),a=distBBox(e,i-t,i,r);let o=bboxMargin(s)+bboxMargin(a);for(let l=t;l<i-t;l++){const t=e.children[l];extend$1(s,e.leaf?r(t):t),o+=bboxMargin(s)}for(let l=i-t-1;l>=t;l--){const t=e.children[l];extend$1(a,e.leaf?r(t):t),o+=bboxMargin(a)}return o}_adjustParentBBoxes(e,t,i){for(let n=i;n>=0;n--)extend$1(t[n],e)}_condense(e){for(let t,i=e.length-1;i>=0;i--)0===e[i].children.length?i>0?(t=e[i-1].children,t.splice(t.indexOf(e[i]),1)):this.clear():calcBBox(e[i],this.toBBox)}}function findItem(e,t,i){if(!i)return t.indexOf(e);for(let n=0;n<t.length;n++)if(i(e,t[n]))return n;return-1}function calcBBox(e,t){distBBox(e,0,e.children.length,t,e)}function distBBox(e,t,i,n,r){r||(r=createNode(null)),r.minX=1/0,r.minY=1/0,r.maxX=-1/0,r.maxY=-1/0;for(let s=t;s<i;s++){const t=e.children[s];extend$1(r,e.leaf?n(t):t)}return r}function extend$1(e,t){return e.minX=Math.min(e.minX,t.minX),e.minY=Math.min(e.minY,t.minY),e.maxX=Math.max(e.maxX,t.maxX),e.maxY=Math.max(e.maxY,t.maxY),e}function compareNodeMinX(e,t){return e.minX-t.minX}function compareNodeMinY(e,t){return e.minY-t.minY}function bboxArea(e){return(e.maxX-e.minX)*(e.maxY-e.minY)}function bboxMargin(e){return e.maxX-e.minX+(e.maxY-e.minY)}function enlargedArea(e,t){return(Math.max(t.maxX,e.maxX)-Math.min(t.minX,e.minX))*(Math.max(t.maxY,e.maxY)-Math.min(t.minY,e.minY))}function intersectionArea(e,t){const i=Math.max(e.minX,t.minX),n=Math.max(e.minY,t.minY),r=Math.min(e.maxX,t.maxX),s=Math.min(e.maxY,t.maxY);return Math.max(0,r-i)*Math.max(0,s-n)}function contains(e,t){return e.minX<=t.minX&&e.minY<=t.minY&&t.maxX<=e.maxX&&t.maxY<=e.maxY}function intersects$1(e,t){return t.minX<=e.maxX&&t.minY<=e.maxY&&t.maxX>=e.minX&&t.maxY>=e.minY}function createNode(e){return{children:e,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function multiSelect(e,t,i,n,r){const s=[t,i];for(;s.length;){if((i=s.pop())-(t=s.pop())<=n)continue;const a=t+Math.ceil((i-t)/n/2)*n;quickselect(e,a,t,i,r),s.push(t,a,a,i)}}const _tempMatrix4$4=new three.Matrix4,_tempPosition=new three.Vector3,_tempOffset=new three.Vector4,_tempCharPosition=new three.Vector4,vec4=new three.Vector4,getPixelSize$3=(e,t,i)=>.2*Math.tan(t/2)*e/i*10;class RenderingCollision{constructor(e){__publicField(this,"_groupObjectMap",{}),__publicField(this,"_groupDataMap",{}),__publicField(this,"_groupOptions",{}),__publicField(this,"_objectDataMap",new Map),__publicField(this,"_needsUpdate",!1),__publicField(this,"_restrictCount",1e4),__publicField(this,"_cacheBucketKeys",{}),__publicField(this,"_lastUpdateTime",0),__publicField(this,"_delayUpdateTime",200),__publicField(this,"_delayUpdateTimeHandler",null),__publicField(this,"_margin",[0,0]),__publicField(this,"_maxRenderDepth",1),__publicField(this,"_lastZoom",0),__publicField(this,"_viewMatrixWorld",new three.Matrix4),__publicField(this,"_projectionMatrix",new three.Matrix4),__publicField(this,"_viewChanged",!0),this._rendering=e}add(e,t={},i="_default"){e instanceof GeoObject?e.dataSource?(this._groupObjectMap[i]||(this._groupObjectMap[i]=[],this._groupDataMap[i]=[]),this._groupObjectMap[i].push(e),void 0!==t.margin&&"number"==typeof t.margin&&(t.margin=[t.margin,t.margin]),e._enableCollision=!0,e._collisionOptions=t,e.dataSource.defineAttribute("rank","rank"),e.dataSource.defineAttribute("bucket","bucket"),e.dataSource.defineAttribute("distance","distance")):console.error("Object must have DataSource before it added to Collision!"):console.error("Collison Test only work with GeoObject.")}setGroupOption(e,t){this._groupOptions[e]=t}remove(e,t="_default"){if(!(e instanceof GeoObject))return void console.error("Collison Test only work with GeoObject.");let i=this._groupObjectMap[t].indexOf(e);i>-1?(this._groupObjectMap[t].splice(i,1),delete e._enableCollision,delete e._collisionOptions,delete e._collisionData,delete e._collisionUpdated,e.dataSource.undefineAttribute("rank","rank")):console.error("remove error: cannot find object in this group.")}sortBucket(e){e&&e.length>0&&e.sort(((e,t)=>t.rank-e.rank||t.position[0]-e.position[0]||t.position[1]-e.position[1]))}sortBuckets(e,t){const i=this._groupOptions[t]||{},n=i.bucketSort,r=i.enabledBucketCache;let s=Object.keys(e);if(n&&(s=n(s)),r){this._cacheBucketKeys[t]||(this._cacheBucketKeys[t]=[]);const i=this._cacheBucketKeys[t];if(i&&i.length>0){const t=[],n=[];for(let e=0;e<i.length;e++){const n=i[e];s.includes(n)&&t.push(n)}for(let r=0;r<s.length;r++){const t=s[r];if(!i.includes(t)){const i=e[t][0]||{};n.push({key:t,distance:i.distance||Number.POSITIVE_INFINITY})}}n.sort(((e,t)=>e.distance-t.distance)),s=t.concat(n.map((e=>e.key)))}this._cacheBucketKeys[t]=s}const a=[];for(let o=0;o<s.length;o++){const t=e[s[o]];this.sortBucket(t),a.push(...t)}return this.sortBucket(a),a}sortData(){let e=Object.keys(this._groupObjectMap);for(let t=0;t<e.length;t++){const i=e[t],n=this._groupObjectMap[i];for(let e=0;e<n.length;e++){const t=n[e];t._collisionData=[],t._collisionUpdated=!0;let i=t.dataSource.userData;for(let e=0;e<i.length;e++)i[e]._objects=t.dataSource.objects}let r=[];for(let e=0;e<n.length;e++){const t=n[e];r=r.concat(t.dataSource.userData)}const s={};r.forEach((e=>{const t=e.bucket||"default";s[t]||(s[t]=[]),s[t].push(e)})),this._groupDataMap[i]=this.sortBuckets(s,i)}this._needsUpdate=!1}update(e){if(!Object.keys(this._groupDataMap).length)return;if(this._delayUpdateTimeHandler)return;const t=Date.now(),i=t-this._lastUpdateTime;i<this._delayUpdateTime?this._delayUpdateTimeHandler=setTimeout((()=>{clearTimeout(this._delayUpdateTimeHandler),this._delayUpdateTimeHandler=null,this._rendering.requestRender()}),this._delayUpdateTime-i+1):(this.needsUpdate?(this.sortData(),this._collisionTest()):(this._viewChanged=!e.viewMatrixWorld.equals(this._viewMatrixWorld)||!e.projectionMatrix.equals(this._projectionMatrix),this._viewChanged&&(this._collisionTest(),this._viewMatrixWorld.copy(e.viewMatrixWorld),this._projectionMatrix.copy(e.projectionMatrix))),this._lastUpdateTime=t)}_calculatePixelSize(e,t){const i=this._rendering.renderState.cameraOffset;t.sub(i);const n=e.position.distanceTo(t),r=e.fov*Math.PI/180,s=this._rendering.resolution.y;return getPixelSize$3(n,r,s)}_collisionTest(){var e,t,i;const n=Object.keys(this._groupDataMap),r=this._rendering.camera,s=this._rendering.renderState.viewMatrixWorldInverse,a=this._rendering.resolution?this._rendering.resolution.toArray():[0,0],[o,l]=a;if(isNaN(o)||o<=0||isNaN(l)||l<=0)return console.warn("resolution is invalid"),!1;_tempMatrix4$4.multiplyMatrices(r.projectionMatrix,s);const c=this._rendering.stats,h=this._rendering.renderState.cameraOffset,u=this._objectDataMap;u.clear(),c.beginTimeStatsItem("labelCollision");for(const d of n){const n=this._groupDataMap[d];if(!n)continue;const s=new RBush,a=this._groupOptions[d]||{},c=!defined$2(a.requireClip)||a.requireClip;for(const d of n){const n=d._objects;for(const e of n)u.has(e)||u.set(e,[]);const a=n.find((e=>e._enableCollision));if(!a)continue;const[p,m,f]=this._getScreenPosition(d.position,_tempMatrix4$4,o,l);if(f>this._maxRenderDepth)continue;const g=a.collisionTest(d);if(!g)continue;const _=Array.isArray(g)?g:[g],A=[];for(const t of _){const i=t.tolerance||0,n=(null==(e=a._collisionOptions)?void 0:e.margin)||this.margin;let s=[];if(t.chars)if(t.isProjected)s=this._computeProjectedCharBoundingBoxes(t.chars,n,i,o,l);else{const e=_tempPosition.fromArray(d.position),a=this._calculatePixelSize(r,e);s=this._computeCharBoundingBoxes(t.chars,a,t.rotationMatrix,d.position,r,h,_tempMatrix4$4,n,i,o,l)}else{const e=this._computeObjectBoundingBox(t,p,m,n,i);if(!e)continue;if(c&&(e.maxX<0||e.maxY<0||e.minX>o||e.minY>l))continue;s.push(e)}A.push(...s)}if(!this._insertAndCheckCollision(s,A))continue;for(const e of A)s.insert(e);const v={...d,w:(null==(t=_[0])?void 0:t.width)||0,h:(null==(i=_[0])?void 0:i.height)||0};for(const e of n)u.get(e).push(v)}}this._updateCollisionDataForObjects(u),c.endTimeStatsItem("labelCollision")}_getScreenPosition(e,t,i,n){vec4.set(e[0],e[1],e[2],1),vec4.applyMatrix4(t),vec4.divideScalar(vec4.w);return[(vec4.x+1)/2*i,(1-vec4.y)/2*n,vec4.z]}_computeProjectedCharBoundingBoxes(e,t,i,n,r){const s=[];for(let a=0;a<e.length;a++){const n=e[a],{x:r,y:o,size:l,width:c,height:h,rotation:u}=n;let d=c||l||16,p=h||l||16;if(u&&0!==u){const e=d/2,t=p/2,i=Math.cos(u),n=Math.sin(u),r=[{x:-e,y:-t},{x:e,y:-t},{x:e,y:t},{x:-e,y:t}].map((e=>({x:e.x*i-e.y*n,y:e.x*n+e.y*i}))),s=r.map((e=>e.x)),a=r.map((e=>e.y));d=Math.max(...s)-Math.min(...s),p=Math.max(...a)-Math.min(...a)}const m=t[0]+i,f=t[1]+i;s.push({minX:r-(d+2*Math.max(m,0))/2,minY:o-(p+2*Math.max(f,0))/2,maxX:r+(d+2*Math.max(m,0))/2,maxY:o+(p+2*Math.max(f,0))/2})}return s}_computeCharBoundingBoxes(e,t,i,n,r,s,a,o,l,c,h){const u=[];for(let d=0;d<e.length;d++){const{width:p,height:m,offsetX:f,offsetY:g}=e[d];if(!p||!m)continue;const _=_tempOffset.set(f*t,g*t,0,0).applyMatrix4(i),A=_tempCharPosition.set(n[0]+_.x,n[1]+_.y,n[2]+_.z,1);_tempPosition.copy(A).sub(s).sub(r.position);const v=_tempPosition.applyMatrix4(i).normalize(),y=Math.max(Math.abs(v.z),.1);A.applyMatrix4(a),A.divideScalar(A.w);const x=(A.x+1)/2*c,b=(1-A.y)/2*h,S=Math.hypot(p,m),C=o[0]+l,T=o[1]+l;u.push({minX:x-(S+2*Math.max(C,0))/2,minY:b-(S*y+2*Math.max(T,0))/2,maxX:x+(S+2*Math.max(C,0))/2,maxY:b+(S*y+2*Math.max(T,0))/2})}return u}_computeObjectBoundingBox(e,t,i,n,r){let{width:s,height:a,offsetX:o=0,offsetY:l=0}=e;if(!s||!a)return null;const c=n[0]+r,h=n[1]+r;return s+=2*Math.max(c,0),a+=2*Math.max(h,0),{minX:t-s/2+o,minY:i-a/2+l,maxX:t+s/2+o,maxY:i+a/2+l}}_insertAndCheckCollision(e,t){for(const i of t)if(e.collides(i))return!1;for(const i of t)e.insert(i);return!0}_updateCollisionDataForObjects(e){for(const[t,i]of e.entries())t._collisionData&&t._collisionData.length===i.length||(t._collisionData=i,t._collisionUpdated=!0)}set margin(e){"number"==typeof e?this._margin=[e,e]:e instanceof Array&&(this._margin=e)}get margin(){return this._margin}set maxRenderDepth(e){this._maxRenderDepth=e}set restrictCount(e){this._restrictCount=e}get restrictCount(){return this._restrictCount}get needsUpdate(){return this._needsUpdate}set needsUpdate(e){this._needsUpdate=e}}class RenderingAnimation{constructor(e){__publicField(this,"_rendering",null),__publicField(this,"_mixer",null),__publicField(this,"_customMixers",[]),this._rendering=e}update(e){this._mixer&&this._mixer.update(e.deltaSeconds);for(const t of this._customMixers)t.update(e.deltaSeconds)}addMixer(e){-1===this._customMixers.indexOf(e)&&this._customMixers.push(e)}removeMixer(e){let t=this._customMixers.indexOf(e);-1!==t&&this._customMixers.splice(t,1)}get mixer(){return this._mixer||(this._mixer=new three.AnimationMixer(this._rendering.scene)),this._mixer}}class VRButton{static createButton(e,t={}){const i=document.createElement("button");function n(){i.style.display="",i.style.cursor="auto",i.style.left="calc(50% - 75px)",i.style.width="150px",i.onmouseenter=null,i.onmouseleave=null,i.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return i.id="VRButton",i.style.display="none",r(i),navigator.xr.isSessionSupported("immersive-vr").then((function(r){r?function(){let n=null;async function r(t){t.addEventListener("end",s),await e.xr.setSession(t),i.textContent="EXIT VR",n=t}function s(){n.removeEventListener("end",s),i.textContent="ENTER VR",n=null}i.style.display="",i.style.cursor="pointer",i.style.left="calc(50% - 50px)",i.style.width="100px",i.textContent="ENTER VR";const a={...t,optionalFeatures:["local-floor","bounded-floor","layers",...t.optionalFeatures||[]]};i.onmouseenter=function(){i.style.opacity="1.0"},i.onmouseleave=function(){i.style.opacity="0.5"},i.onclick=function(){null===n?navigator.xr.requestSession("immersive-vr",a).then(r):(n.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",a).then(r).catch((e=>{console.warn(e)})))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",a).then(r).catch((e=>{console.warn(e)}))}():(n(),i.textContent="VR NOT SUPPORTED"),r&&VRButton.xrSessionIsGranted&&i.click()})).catch((function(e){n(),console.warn("Exception when trying to call xr.isSessionSupported",e),i.textContent="VR NOT ALLOWED"})),i;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{VRButton.xrSessionIsGranted=!0}))}}}VRButton.xrSessionIsGranted=!1,VRButton.registerSessionGrantedListener();class RenderingXr{constructor(e){__publicField(this,"onSessionStart",(()=>{})),__publicField(this,"onSessionEnd",(()=>{})),this._rendering=e}init(){const e=this._rendering,t=e._renderer;if(e._useXR){e.useMrt=!1,e.enableAnimationLoop=!0,e.animationLoopFrameTime=16,e.autoOffsetRelativeCenter=!1;const i=e._camera,n=this.camera=i.clone();n.far=2e3,n.name="xrCamera";const r=this.xrCamera=new three.Group;r.name="xrCameraGroup",r.add(n),e._engine.add(r),r.rotation.set(Math.PI/2,0,0),document.body.appendChild(VRButton.createButton(t)),t.setAnimationLoop(e.render),t.xr.enabled=!0,t.xr.addEventListener("sessionstart",this.onSessionStart),t.xr.addEventListener("sessionend",this.onSessionEnd)}}dispose(){const e=this._rendering._renderer;e.xr.removeEventListener("sessionstart",this.onSessionStart),e.xr.removeEventListener("sessionend",this.onSessionEnd)}}class TimeStatsItem{constructor(e){__publicField(this,"_lastValue",0),__publicField(this,"_count",0),__publicField(this,"_total",0),__publicField(this,"_beginTime",0),__publicField(this,"_name"),this._name=e}begin(e){this._beginTime=e}end(e){this._lastValue=e-this._beginTime,this._total=this._total+this._lastValue,this._count++}add(e){this._total+=e,this._lastValue=e,this._count++}get total(){return this._total}get count(){return this._count}get average(){return 0===this._count?0:this._total/this._count}get lastValue(){return this._lastValue}get name(){return this._name}get beginTime(){return this._beginTime}}class Stats{constructor(){__publicField(this,"_timeStatsItem",{})}addTimeStatsItem(e){const t=new TimeStatsItem(e);this._timeStatsItem[e]=t}removeTimeStatsItem(e){delete this._timeStatsItem[e]}beginTimeStatsItem(e,t){this._timeStatsItem[e]||this.addTimeStatsItem(e),null==t&&(t=performance.now()),this._timeStatsItem[e].begin(t)}endTimeStatsItem(e,t){this._timeStatsItem[e]||this.addTimeStatsItem(e),null==t&&(t=performance.now()),this._timeStatsItem[e].end(t)}addTimeStatsItemValue(e,t){this._timeStatsItem[e]||this.addTimeStatsItem(e),this._timeStatsItem[e].add(t)}getSortedTimeStatsItems(){let e=Object.values(this._timeStatsItem);const t=performance.now();return e=e.filter((e=>t-e.beginTime<5e3)),e.sort(((e,t)=>t.average-e.average)),e}printString(){let e="Stas:\n";const t=this.getSortedTimeStatsItems();for(const i of t)e+=`${i.name}:\n${i.average.toFixed(2)}\t ${i.lastValue.toFixed(2)}\t ${i.count}\t ${i.total.toFixed(2)}\n`;return e}}const CHECK_EVENT=1,CHECK_VISIBLE=2,_ascSort=(e,t)=>e.distance-t.distance,_hasEventListener=(e,t)=>{const i=e._listeners;if(void 0===i)return!1;let n=null;for(let r=0,s=t.length;r<s;r++)if(n=i[t[r]],n&&n.length>0)return!0;return!1},_intersectFlagObject=(e,t,i,n,r,s,a,o)=>{let l=!0,c=!0;if(i&CHECK_EVENT&&((a=a||_hasEventListener(e,s))||(c=!1)),!(i&CHECK_VISIBLE)||e.visible){if(n&&!n(e,t,r)&&(c=!1),c&&e.layers.test(t.layers)){!1===e.raycast(t,r)&&(l=!1)}if(!0===l&&!0===o){const o=e.children;for(let e=0,l=o.length;e<l;e++)_intersectFlagObject(o[e],t,i,n,r,s,a,!0)}}};class CustomRaycaster extends three.Raycaster{constructor(){super(),this.mouse=new three.Vector2}intersectFlagObjects(e,t,i,n=!0,r,s=[]){for(let a=0,o=e.length;a<o;a++)_intersectFlagObject(e[a],this,t,r,s,i,!1,n);return s.sort(_ascSort),s}}__publicField(CustomRaycaster,"CHECK_EVENT",CHECK_EVENT),__publicField(CustomRaycaster,"CHECK_VISIBLE",CHECK_VISIBLE);class FlowEvent{constructor(){__publicField(this,"isFlowEvent",!0)}execute(){}}class MultipleToggleEvent extends FlowEvent{constructor(e,t=0){super(),__publicField(this,"_currentIndex",0),__publicField(this,"_callbacks",[]),t>e.length-1&&(t=e.length-1),t<0&&(t=0),this._currentIndex=t,Array.isArray(e)?this._callbacks=e:console.warn("callbacks must be an array")}execute(e){const t=this._callbacks[this._currentIndex];t&&t(e,this._currentIndex),this._currentIndex++,this._currentIndex>this._callbacks.length-1&&(this._currentIndex=0)}}class EventParams{constructor(e,t,i){__publicField(this,"_engine",null),__publicField(this,"_originalEvent",null),__publicField(this,"_isPropagationStopped",!1),__publicField(this,"_entityProxy",null),__publicField(this,"_position"),__publicField(this,"_point"),__publicField(this,"target",null),__publicField(this,"currentTarget",null),__publicField(this,"intersection",null),this._engine=e,this._originalEvent=t,this.pixel=t&&t.pixel,this.event=t&&t.event,this._entityProxy=i}get originalEvent(){return this._originalEvent}stopPropagation(){this._isPropagationStopped=!0}get isPropagationStopped(){return this._isPropagationStopped}get entity(){return this._entityProxy?this._entityProxy.entity:null}get object(){return console.warn("EventParams.object is deprecated, use EventParams.currentTarget instead"),this.currentTarget}get directObject(){return console.warn("EventParams.directObject is deprecated, use EventParams.target instead"),this.target}get position(){if(void 0!==this._position)return this._position;if(this.intersection&&this.intersection.point){const e=this.intersection.point;this._position=[e.x,e.y,e.z]}else this._position=null;return this._position}set position(e){void 0===this._position?null!=e?e.isVector3?this._position=[e.x,e.y,e.z]:this._position=e:this._position=null:console.warn("EventParams.position is readonly after initialized")}get point(){if(void 0!==this._point)return this._point;const e=this.position;return this._point=null===e?null:this._engine.map.unprojectArrayCoordinate(e),this._point}}class EntityProxy{constructor(e,t){__publicField(this,"_hasComputed",!1),this._object=e,this._intersection=t}_computeEntity(){const e=this._object,t=this._intersection;if(e.getEntityByIntersection)return e.getEntityByIntersection(t);let i=-1;if(void 0!==t.instanceId?i=t.instanceId:void 0!==t.face&&null!==t.face?e.getEntityIndexByFace&&(i=e.getEntityIndexByFace(t.faceIndex,t.face.a)):void 0!==t.index&&(i=t.index),i<0)return null;const n=e.getEntityByIndex(i);return n&&n.pairs&&this._addPointProperty(n,e),n}_addPointProperty(e){Object.defineProperty(e.pairs,"point",{get:()=>e.value.coordinates})}get entity(){return this._hasComputed||(this._entity=this._computeEntity(),this._hasComputed=!0),this._entity}get intersection(){return this._intersection}}class EventThrottle{constructor(){this._eventToTriggerMap={},this._isBusy=!1,this._isEmpty=!0}restart(){this._eventToTriggerMap={}}putEvent(e,t){this._eventToTriggerMap[e]||(this._eventToTriggerMap[e]=t,this._isEmpty=!1)}async triggerEvents(t){if(this._isBusy)return;this._isBusy=!0;const i=this._eventToTriggerMap;this._eventToTriggerMap={},this._isEmpty=!0;try{await t(i)}catch(e){console.error("error occurs when triggering event",e)}finally{this._isBusy=!1}}get isEmpty(){return this._isEmpty}get isBusy(){return this._isBusy}}const _EngineEvent=class{constructor(e){__publicField(this,"_mouse",new three.Vector2),__publicField(this,"_mousePosition",new three.Vector2),__publicField(this,"_intersections"),__publicField(this,"_engine",null),__publicField(this,"_currentMouseEnterLeaveObjects"),__publicField(this,"_handleTriggerEvents",(async e=>{await this._triggerEventOfObjects(e)&&this._triggerMouseLeaveEvents(e),this._lastMouseEnterLeaveObjects=this._currentMouseEnterLeaveObjects,this._engine.requestRender()})),__publicField(this,"_triggerEventOfObjects",(async e=>{const t=this._engine,i=Object.keys(e),n=e[i[0]];this._updateMouse(n);const r=this._currentMouseEnterLeaveObjects,s=r&&r.keys();let a=!1;s.forEach((e=>{a=a||_hasEventListener(e,i)})),this._intersections=await t.rendering.picking.pickIntersectionsOfEventObjects(this._mousePosition,i);const o=this._currentMouseEnterLeaveObjects=new Map;if(0===this._intersections.length)return await this._triggerRootObjectEvents(e,null),a;const l=this._intersections[0];let c=l.object;const h=c,u={};let d=null,p=null;for(;c;){let t=!1;p=[];const n=c._listeners;for(const e of i)n&&n[e]&&0!==n[e].length&&p.push(e);const r=n&&Object.keys(n)||[];(r.includes(_EngineEvent.EVENT_NAME_MOUSE_ENTER)||r.includes(_EngineEvent.EVENT_NAME_MOUSE_LEAVE))&&(t=!0),d=c.isEventEntitySupported?new EntityProxy(c,l):null;let s=!1,a=!1,m=null;if(t)if(o.set(c,d),this._lastMouseEnterLeaveObjects.has(c)){const e=this._lastMouseEnterLeaveObjects.get(c);c.isEventEntitySupported&&!this._isSameEntity(d,e)&&(s=!0,a=!0,m=e)}else s=!0;for(const i of p){if(u[i])continue;if(i===_EngineEvent.EVENT_NAME_MOUSE_ENTER&&!s)continue;if(i===_EngineEvent.EVENT_NAME_MOUSE_LEAVE){if(!a)continue;m&&(d=m)}const t=e[i],n=c._listeners[i],r=new EventParams(this._engine,t,d);r.target=h,r.currentTarget=c,r.intersection=l,this._executeCallbacks(n,r),r.isPropagationStopped&&(u[i]=!0)}c=c.parent}return await this._triggerRootObjectEvents(e,l,u),a})),__publicField(this,"_isSameEntity",((e,t)=>{var i,n;const r=null==(i=null==e?void 0:e.entity)?void 0:i.index,s=null==(n=null==t?void 0:t.entity)?void 0:n.index;return void 0!==r&&r===s})),__publicField(this,"_handlePointerDown",(e=>{this._eventThrottle.putEvent(_EngineEvent.EVENT_NAME_POINTER_DOWN,e),this._engine.requestRender()})),__publicField(this,"_handlePointerUp",(e=>{this._eventThrottle.putEvent(_EngineEvent.EVENT_NAME_POINTER_UP,e),this._engine.requestRender()})),__publicField(this,"_handleClick",(e=>{this._eventThrottle.putEvent(_EngineEvent.EVENT_NAME_CLICK,e),this._engine.requestRender()})),__publicField(this,"_handleDblClick",(e=>{this._eventThrottle.putEvent(_EngineEvent.EVENT_NAME_DOUBLE_CLICK,e),this._engine.requestRender()})),__publicField(this,"_handleRightClick",(e=>{this._eventThrottle.putEvent(_EngineEvent.EVENT_NAME_RIGHT_CLICK,e),this._engine.requestRender()})),__publicField(this,"_handleRightDblClick",(e=>{this._eventThrottle.putEvent(_EngineEvent.EVENT_NAME_RIGHT_DOUBLE_CLICK,e),this._engine.requestRender()})),__publicField(this,"_handleMouseMove",(e=>{this._eventThrottle.putEvent(_EngineEvent.EVENT_NAME_MOUSE_MOVE,e),this._eventThrottle.putEvent(_EngineEvent.EVENT_NAME_MOUSE_ENTER,e),this._eventThrottle.putEvent(_EngineEvent.EVENT_NAME_MOUSE_LEAVE,e),this._engine.requestRender()})),__publicField(this,"_updateMouse",(e=>{const t=this._engine,i=t.map.getResolution();let n=e.pixel[0],r=e.pixel[1];const s=t.map.map.control;s&&(n/=s.startScaleX||1,r/=s.startScaleY||1);const a=n/i.x,o=r/i.y;this._mouse.set(2*a-1,1-2*o),this._mousePosition.set(n,r)})),this._engine=e,this._eventThrottle=new EventThrottle,this._isEventHandleBusy=!1,this._currentMouseEnterLeaveObjects=new Map,this._lastMouseEnterLeaveObjects=new Map}beginFrame(){}endFrame(){const e=this._eventThrottle;e.isBusy||e.isEmpty||e.triggerEvents(this._handleTriggerEvents)}_triggerMouseLeaveEvents(e){const t=this._currentMouseEnterLeaveObjects,i=this._lastMouseEnterLeaveObjects;for(const[n,r]of i)if(!t.has(n)){const t=n._listeners;if(!t||!t[_EngineEvent.EVENT_NAME_MOUSE_LEAVE]||0===t[_EngineEvent.EVENT_NAME_MOUSE_LEAVE].length)continue;const i=e[_EngineEvent.EVENT_NAME_MOUSE_MOVE],s=t[_EngineEvent.EVENT_NAME_MOUSE_LEAVE],a=new EventParams(this._engine,i,r);a.target=n,a.currentTarget=n,a.intersection=r&&r.intersection,this._executeCallbacks(s,a)}}async _triggerRootObjectEvents(e,t,i){const n=this._engine.map,r=n._listeners;if(!r||0===Object.keys(r).length)return;const s=Object.keys(e);let a=null;t&&(a=t.point);let o=!0;for(const l of s){if(i&&i[l])continue;const s=r[l];if(!s||0===s.length)continue;if(!a&&o){o=!1;const e=this._engine.rendering.picking;a=await e.pickWorldPosition(this._mousePosition)}const c=e[l],h=new EventParams(this._engine,c,null);h.target=t&&t.object,h.currentTarget=n,h.intersection=t,h.position=a,this._executeCallbacks(s,h)}}_executeCallbacks(e,t){for(const n of e){if(!n)continue;const e=t.event;if(e&&(e.defaultPrevented||e.domEvent&&e.domEvent.defaultPrevented))return;try{n.isFlowEvent?n.execute(t):n(t)}catch(i){console.error("error occurs when triggering callback",i)}}}bind(e,t,i){"string"==typeof e&&(i=t,t=e,e=this._engine.map),console.warn("bind is deprecated, use object.addEventListener instead"),e.addEventListener(t,i)}unbind(e,t,i){"string"==typeof e&&(i=t,t=e,e=this._engine.map),console.warn("unbind is deprecated, use object.removeEventListener instead"),e.removeEventListener(t,i)}markEventProxy(e,t){console.warn("markEventProxy is deprecated, no need to call this method")}createMultipleToggleEvent(e,t=0){return new MultipleToggleEvent(e,t)}dispose(){}};let EngineEvent=_EngineEvent;__publicField(EngineEvent,"EVENT_NAME_CLICK","click"),__publicField(EngineEvent,"EVENT_NAME_DOUBLE_CLICK","dblclick"),__publicField(EngineEvent,"EVENT_NAME_RIGHT_CLICK","rightclick"),__publicField(EngineEvent,"EVENT_NAME_RIGHT_DOUBLE_CLICK","rightdblclick"),__publicField(EngineEvent,"EVENT_NAME_MOUSE_MOVE","mousemove"),__publicField(EngineEvent,"EVENT_NAME_MOUSE_ENTER","mouseenter"),__publicField(EngineEvent,"EVENT_NAME_MOUSE_LEAVE","mouseleave"),__publicField(EngineEvent,"EVENT_NAME_POINTER_DOWN","pointerdown"),__publicField(EngineEvent,"EVENT_NAME_POINTER_UP","pointerup");const _raycaster$6=new CustomRaycaster,_defaultPickEventNames=[EngineEvent.EVENT_NAME_CLICK,EngineEvent.EVENT_NAME_DOUBLE_CLICK,EngineEvent.EVENT_NAME_MOUSE_MOVE,EngineEvent.EVENT_NAME_POINTER_DOWN,EngineEvent.EVENT_NAME_POINTER_UP,EngineEvent.EVENT_NAME_MOUSE_ENTER,EngineEvent.EVENT_NAME_MOUSE_LEAVE],_Picking=class{constructor(e){__publicField(this,"_useDepthPicking",!1),__publicField(this,"_positionCache",{}),__publicField(this,"_seaLevelPositionCache",{}),__publicField(this,"_intersectionCache",{}),__publicField(this,"pixelToNdc",(e=>{const t=this._rendering.resolution;return new three.Vector2(e.x/t.x*2-1,1-e.y/t.y*2)})),__publicField(this,"ndcToPixel",(e=>{const t=this._rendering.resolution;return new three.Vector2((e.x+1)/2*t.x,(1-e.y)/2*t.y)})),this._rendering=e}init(){}dispose(){}beginFrame(){this._positionCache={},this._seaLevelPositionCache={},this._intersectionCache={[_Picking.PICK_INTERSECTION_TYPE_ALL]:{},[_Picking.PICK_INTERSECTION_TYPE_VISIBLE]:{},[_Picking.PICK_INTERSECTION_TYPE_EVENT]:{}},this._rendering.features.depthPicking.enabled=this._useDepthPicking}endFrame(){}async pickWorldPosition(e){let t=await this.pickSceneWorldPosition(e);return t||(t=this.pickSeaLevelWorldPosition(e)),t}async pickWorldPositionFromNdc(e){const t=this.ndcToPixel(e);return await this.pickWorldPosition(t)}async pickSceneWorldPosition(e){const t=`${Math.round(e.x)}_${Math.round(e.y)}`;if(void 0!==this._positionCache[t])return this._positionCache[t];let i=await this._pickSceneWorldPosition(e);return this._positionCache[t]=i,i}async pickSceneWorldPositionFromNdc(e){const t=this.ndcToPixel(e);return await this.pickSceneWorldPosition(t)}async _pickSceneWorldPosition(e){if(this._useDepthPicking){return await this._pickSceneWorldPositionFromDepth(e)}const t=await this.pickIntersectionsOfVisibleObjects(e);let i=null;for(let r=0,s=t.length;r<s;r++)if(!(t[r].object.isPoints||t[r].object.isLine||t[r].object.collisionDisabled||!1===t[r].object.visible)){i=t[r];break}if(null===i||!i.point)return null;let n=new three.Vector3;return n.copy(i.point),n}async _pickSceneWorldPositionFromDepth(e){const t=this._rendering,i=t.features.depthPicking,n=this.pixelToNdc(e),r=await i.pickDepth(e.x,.5*(n.y+1)*t.resolution.y);if(null===r||r>.999999)return null;const s=new three.Vector3(n.x,n.y,2*r-1),a=t.camera;return s.unproject(a),s}pickIntersections(e){return this._pickIntersectionByRayRasting(_Picking.PICK_INTERSECTION_TYPE_ALL,e)}async pickIntersectionsOfVisibleObjects(e){return this._pickIntersectionByRayRasting(_Picking.PICK_INTERSECTION_TYPE_VISIBLE,e,null)}async pickIntersectionsOfEventObjects(e,t=_defaultPickEventNames){return this._pickIntersectionByRayRasting(_Picking.PICK_INTERSECTION_TYPE_EVENT,e,t)}async _pickIntersectionByRayRasting(e,t,i=_defaultPickEventNames){const n=`${Math.round(t.x)}_${Math.round(t.y)}`,r=this._intersectionCache[e];if(void 0!==r[n])return r[n];const s=this._rendering.camera,a=this.pixelToNdc(t);_raycaster$6.setFromCamera(a,s),_raycaster$6.mouse.copy(a);let o=null;if(e===_Picking.PICK_INTERSECTION_TYPE_ALL)o=_raycaster$6.intersectObjects(this._rendering.objectsScene.children,!0);else if(e===_Picking.PICK_INTERSECTION_TYPE_VISIBLE){const e=CustomRaycaster.CHECK_VISIBLE;o=_raycaster$6.intersectFlagObjects(this._rendering.objectsScene.children,e,null,!0)}else if(e===_Picking.PICK_INTERSECTION_TYPE_EVENT){const e=CustomRaycaster.CHECK_EVENT|CustomRaycaster.CHECK_VISIBLE;o=_raycaster$6.intersectFlagObjects(this._rendering.objectsScene.children,e,i,!0)}return r[n]=o,o}pickTerrainWorldPosition(e){const t=this._pickIntersectionsWithCheckCallback(e,((e,t)=>e.isMesh&&e.isTerrainTile));return t.length>0?t[0].point:null}_pickIntersectionsWithCheckCallback(e,t){_raycaster$6.set(e.origin,e.direction);return _raycaster$6.intersectFlagObjects(this._rendering.objectsScene.children,0,null,!0,t)}pickSeaLevelWorldPositionFromNdc(e){const t=this.ndcToPixel(e);return this.pickSeaLevelWorldPosition(t)}pickSeaLevelWorldPosition(e){const t=`${Math.round(e.x)}_${Math.round(e.y)}`;if(void 0!==this._seaLevelPositionCache[t])return this._seaLevelPositionCache[t];let i=this._rendering._engine.map.pickSeaLevelWorldPosition(e);return this._seaLevelPositionCache[t]=i,i}get useDepthPicking(){return this._useDepthPicking}set useDepthPicking(e){this._useDepthPicking=e}};let Picking=_Picking;function matrix4EqualsEpsilon(e,t,i=1e-10){i=defaultValue$1(i,0);const n=e.elements,r=t.elements;return n===r||defined$2(n)&&defined$2(r)&&Math.abs(n[0]-r[0])<=i&&Math.abs(n[1]-r[1])<=i&&Math.abs(n[2]-r[2])<=i&&Math.abs(n[3]-r[3])<=i&&Math.abs(n[4]-r[4])<=i&&Math.abs(n[5]-r[5])<=i&&Math.abs(n[6]-r[6])<=i&&Math.abs(n[7]-r[7])<=i&&Math.abs(n[8]-r[8])<=i&&Math.abs(n[9]-r[9])<=i&&Math.abs(n[10]-r[10])<=i&&Math.abs(n[11]-r[11])<=i&&Math.abs(n[12]-r[12])<=i&&Math.abs(n[13]-r[13])<=i&&Math.abs(n[14]-r[14])<=i&&Math.abs(n[15]-r[15])<=i}__publicField(Picking,"PICK_INTERSECTION_TYPE_ALL",1),__publicField(Picking,"PICK_INTERSECTION_TYPE_VISIBLE",2),__publicField(Picking,"PICK_INTERSECTION_TYPE_EVENT",3);class RenderState{constructor(e){__publicField(this,"_stage",null),__publicField(this,"_time",0),__publicField(this,"_startTime",0),__publicField(this,"_elapsedTime",0),__publicField(this,"_viewChanged",!1),__publicField(this,"_viewMatrixWorld",new three.Matrix4),__publicField(this,"_viewMatrixWorldInverse",new three.Matrix4),__publicField(this,"_projectionMatrix",new three.Matrix4),__publicField(this,"_cameraMatrix",new three.Matrix4),__publicField(this,"_cameraMatrixInverse",new three.Matrix4),__publicField(this,"_cameraOffsetX",0),__publicField(this,"_cameraOffsetY",0),__publicField(this,"_cameraOffset",new three.Vector3),__publicField(this,"_frameCount",0),__publicField(this,"_viewStableFrameCount",0),__publicField(this,"_isRendererRecreated",!1),__publicField(this,"_cameraLocation",new three.Vector3),__publicField(this,"_resolution",new three.Vector2),__publicField(this,"_pixelRatio",1),__publicField(this,"_isResolutionChanged",!1),__publicField(this,"_isPixelRatioChanged",!1),__publicField(this,"_isResolutionOrPixelRatioChanged",!1),__publicField(this,"_inRenderVideoMode",!1),this._rendering=e,this._startTime=(new Date).getTime(),this._time=this._startTime}beginFrame(e,t){this._deltaTime=t-this._time,this._deltaSeconds=this._deltaTime/1e3,this._time=t,this._elapsedTime=t-this._startTime;const i=e.renderer.info.render.frame;i<this._frameCount&&(this._isRendererRecreated=!0),this._frameCount=i;const n=e.camera,r=n.matrixWorld,s=n.projectionMatrix;matrix4EqualsEpsilon(r,this._viewMatrixWorld,1e-8)&&matrix4EqualsEpsilon(s,this._projectionMatrix,1e-8)?(this._viewChanged=!1,this._viewStableFrameCount++):(this._viewChanged=!0,this._viewStableFrameCount=0,e.requestRender()),this._viewMatrixWorld.copy(n.matrixWorld),this._viewMatrixWorldInverse.copy(n.matrixWorldInverse),this._projectionMatrix.copy(n.projectionMatrix);const a=e.resolution;a.x!==this._resolution.x||a.y!==this._resolution.y?(this._isResolutionChanged=!0,this._resolution.set(a.x,a.y)):this._isResolutionChanged=!1;const o=e.pixelRatio;o!==this._pixelRatio?(this._isPixelRatioChanged=!0,this._pixelRatio=o):this._isPixelRatioChanged=!1,this._isResolutionOrPixelRatioChanged=this._isResolutionChanged||this._isPixelRatioChanged,this._inRenderVideoMode=!!e._videoConfig}endFrame(){this._isRendererRecreated=!1}updateCameraOffsetState(e,t,i,n){this._cameraMatrix.copy(e.matrixWorld),this._cameraMatrixInverse.copy(e.matrixWorldInverse),this._cameraOffsetX=t,this._cameraOffsetY=i,this._cameraOffset.set(t,i,n)}getDepthByDistance(e){const t=this._rendering.camera,i=t.far,n=t.near;return t.isPerspectiveCamera?this._rendering.renderer.capabilities.logarithmicDepthBuffer?Math.log(e+1)/Math.log(i+1):i*(e-n)/(e*(i-n)):(i-e)/(i-n)}get time(){return this._time}get viewChanged(){return this._viewChanged}get viewMatrixWorld(){return this._viewMatrixWorld}get viewMatrixWorldInverse(){return this._viewMatrixWorldInverse}get projectionMatrix(){return this._projectionMatrix}get cameraMatrix(){return this._cameraMatrix}get cameraMatrixInverse(){return this._cameraMatrixInverse}get cameraOffsetX(){return this._cameraOffsetX}get cameraOffsetY(){return this._cameraOffsetY}get deltaTime(){return this._deltaTime}get elapsedTime(){return this._elapsedTime}get deltaSeconds(){return this._deltaSeconds}get frameCount(){return this._frameCount}get viewStableFrameCount(){return this._viewStableFrameCount}get cameraOffset(){return this._cameraOffset}get isRendererRecreated(){return this._isRendererRecreated}set stage(e){this._stage=e}get stage(){return this._stage}get isResolutionOrPixelRatioChanged(){return this._isResolutionOrPixelRatioChanged}get isResolutionChanged(){return this._isResolutionChanged}get isPixelRatioChanged(){return this._isPixelRatioChanged}}class MicroTask{constructor(e,t=0){this.taskFunc=e,this.priority=t,this._isCancelled=!1,this._isStart=!1,this._promise=new Promise(((e,t)=>{this._resolve=e,this._reject=t}))}execute(){if(this._isStart=!0,this.isCancelled())console.warn("MicroTask: Task was cancelled");else try{const e=this.taskFunc();Promise.resolve(e).then(this._resolve).catch(this._reject)}catch(e){this._reject(new Error("Task failed:",e))}}cancel(){this._isCancelled=!0}isCancelled(){return this._isCancelled}isStart(){return this._isStart}get promise(){return this._promise}}class RenderingMicroTaskScheduler{constructor(e){__publicField(this,"_frameDurationList",[]),__publicField(this,"_maxTaskCount",1e3),__publicField(this,"_taskQueue",[]),this._rendering=e}beginFrame(){if(this._frameStartTime=performance.now(),this._lastFrameStartTime){const e=this._frameStartTime-this._lastFrameStartTime;this._frameDurationList.push(e),this._frameDurationList.length>5&&this._frameDurationList.shift()}this._lastFrameStartTime=this._frameStartTime}endFrame(){if(this._frameDurationList.length<5)return;const e=performance.now(),t=e-this._frameStartTime,i=this._frameDurationList.reduce(((e,t)=>e+t),0)/this._frameDurationList.length;let n=Math.min(16,i)-t;const r=this._taskQueue;for(;r.length>0;){const{task:t}=this._taskQueue.shift();t.execute();if(performance.now()-e>=n&&r.length<=this._maxTaskCount)break}}executeAllTasks(){for(;this._taskQueue.length>0;){const{task:e}=this._taskQueue.shift();e.execute()}}addTask(e,t=0){const i=new MicroTask(e,t);return this._taskQueue.push({task:i,priority:t}),this._taskQueue.sort(((e,t)=>t.priority-e.priority)),i}get maxTaskCount(){return this._maxTaskCount}set maxTaskCount(e){this._maxTaskCount=e}get taskCount(){return this._taskQueue.length}}const _warnCache={};function warnOnce(e){e in _warnCache||(_warnCache[e]=!0,console.warn(e))}const _errorCache={};function errorOnce(e){e in _errorCache||(_errorCache[e]=!0,console.error(e))}const _tempMatrix4$3=new three.Matrix4,_tempSphere=new three.Sphere,_tempFrustum=new three.Frustum,_opaqueSort=(e,t)=>e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.name!==t.material.name?e.material.name>t.material.name?1:-1:e.material.type!==t.material.type?e.material.type-t.material.type:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id,_transparentSort=(e,t)=>e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id,debugVertexShader="\n    #include <common>\n    #include <logdepthbuf_pars_vertex>\n    void main() {\n        #include <begin_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n    }\n",debugFragmentShader="\n    #include <common>\n    #include <logdepthbuf_pars_fragment>\n    uniform vec3 color;\n    void main() {\n        gl_FragColor = vec4( color, 1.0 );\n        #include <logdepthbuf_fragment>\n    }\n",debugColors=[4886754,5289385,7184241,12888157,14191694,12017001,10189749],DEBUG_MODE_NONE=0,DEBUG_MODE_MESH=1,DEBUG_MODE_MATERIAL=2,DEBUG_MODE_OBJECT=3;let __debugObjectId=1;class EngineRendering{constructor(t,i={}){__publicField(this,"_engine"),__publicField(this,"_outputEncoding"),__publicField(this,"_enableAnimationLoop"),__publicField(this,"_animationLoopFrameTime"),__publicField(this,"_uniforms"),__publicField(this,"_main"),__publicField(this,"_bloom"),__publicField(this,"_ssr"),__publicField(this,"_composition"),__publicField(this,"_label"),__publicField(this,"_renderState"),__publicField(this,"_camera"),__publicField(this,"_canvas"),__publicField(this,"_context"),__publicField(this,"_renderer"),__publicField(this,"_scene"),__publicField(this,"_weather"),__publicField(this,"_rawCamera"),__publicField(this,"_useMRT",!1),__publicField(this,"_isUseMRTChanged",!1),__publicField(this,"_freezeUpdate",!1),__publicField(this,"_isRunning",!1),__publicField(this,"_needsRenderImmediately",!1),__publicField(this,"_needsRenderNext",!1),__publicField(this,"_beforeRenderListeners",[]),__publicField(this,"_prepareRenderListeners",[]),__publicField(this,"_startTime",0),__publicField(this,"_pixelRatio",window.devicePixelRatio),__publicField(this,"_resolution",new three.Vector2),__publicField(this,"_sky",null),__publicField(this,"_debugShaderType",0),__publicField(this,"_beforeScenePrepareRenderObjects",new Set),__publicField(this,"_beforeSceneRenderObjects",new Set),__publicField(this,"_onRenderModeChangedObjects",new Set),__publicField(this,"_onRenderPassChangedObjects",new Set),__publicField(this,"_useClip"),__publicField(this,"_wireframe",!0),__publicField(this,"_debugMaterial",null),__publicField(this,"_debugMode",DEBUG_MODE_NONE),__publicField(this,"_autoOffsetRelativeCenter",!0),__publicField(this,"_clampCameraNearFar",!1),__publicField(this,"_options",{}),__publicField(this,"lastRenderTime",0),__publicField(this,"_lastClockTime",0),__publicField(this,"_contextParameters",{alpha:!0,stencil:!0,antialias:!1,powerPreference:"high-performance",preserveDrawingBuffer:!1,premultipliedAlpha:!1}),__publicField(this,"_needsReCreateRenderer",!1),__publicField(this,"_frameDuration",100),__publicField(this,"_useHighPrecisionBuffer",!0),__publicField(this,"handleShaderBeforeResolve",((e,t,i)=>{if(this._useMRT){const e=this._renderer.getRenderTarget();e&&e.isWebGLMultipleRenderTargets&&(t=this.convertMrtSupportedFragment(t))}else t=this.convertNMrtSupportedFragment(t,i.shaderID);return"basic"===i.shaderID&&(t="#define BASIC\nuniform vec3 emissive;\n"+t),{vertexShader:e=addClipableToVertexShader(e),fragmentShader:t=addClipableToFragmentShader(t)}})),__publicField(this,"handleShaderBeforeCompile",((e,t,i)=>{if(e=addEditableToVertexShader(e),this._useMRT){const n=this._renderer.getRenderTarget();if(n&&n.isWebGLMultipleRenderTargets){i.isRawShaderMaterial&&i.glslVersion!==three.GLSL3&&(e=["#version 300 es","precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+e,t=["#version 300 es","#define varying in","layout(location = 0) out highp vec4 pc_fragColor;","#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+t)}}return{vertexShader:e,fragmentShader:t}})),__publicField(this,"handleMaterialBeforeCompile",((e,t)=>{e.handleMaterialBeforeCompile&&e.handleMaterialBeforeCompile(this._engine,this),this.shadow.enabled&&"csm"===this.shadow.method&&this.shadow.updateCSMShadow(e,t)})),__publicField(this,"convertMrtSupportedFragment",(e=>this._main.sceneRendering.modifyFragmentShader(e))),__publicField(this,"convertNMrtSupportedFragment",((e,t)=>addNMrtSupportFragmentShader(e))),__publicField(this,"_renderVideoFrame",(async()=>{const e=this._videoConfig,t=e.frameCount,i=this._videoFrameIndex;if(i>=t){this.startRenderLoop(),this._renderVideoResolve();const e=this._videoSavedState;return this._resolution.copy(this._engine.map.getResolution()),this._pixelRatio=e.pixelRatio,this.features.antialias.enabled=e.aaEnabled,this.features.antialias.method=e.aaMethod,void(this._videoConfig=null)}const n=this._startTime+i/t*e.duration*1e3;this.renderScene(n);let r=!0;if(this._taskScheduler.taskCount>0&&(this._taskScheduler.executeAllTasks(),r=!1),r){this._scene.traverse((e=>{e.isRenderAsyncObject&&(e.isInStableRenderState()||(r=!1))}))}if(r&&(r=this._main.isInStableRenderState()),r){const n=await new Promise((e=>this._canvas.toBlob(e,"image/png"))),r=`frame_${String(i).padStart(5,"0")}.png`,s=await e.directoryHandle.getFileHandle(r,{create:!0}),a=await s.createWritable();await a.write(n),await a.close(),this._videoFrameIndex++,e.onProgress&&e.onProgress({frameIndex:i,frameCount:t}),requestAnimationFrame(this._renderVideoFrame)}else requestAnimationFrame(this._renderVideoFrame)})),__publicField(this,"render",(()=>{if(!this._isRunning)return;const t=(new Date).valueOf();if(this._engine.clock.tick(t-this._lastClockTime),this._lastClockTime=t,this._beginFrame(),this._useXR||requestAnimationFrame(this.render),(this._needsRenderNext||this._enableAnimationLoop)&&this._animationLoopFrameTime<17&&(this._needsRenderImmediately=!0),!(this._needsRenderImmediately||(this._needsRenderNext||this._enableAnimationLoop)&&t-this.lastRenderTime>=this._animationLoopFrameTime))return void this._endFrame();let i=this._needsRenderImmediately?0:t-this.lastRenderTime-this._animationLoopFrameTime;i>this._animationLoopFrameTime-16&&(i=this._animationLoopFrameTime-16),this.lastRenderTime=t-i,this._needsRenderImmediately=!1,this._needsRenderNext=!1;const n=this._stats;n.beginTimeStatsItem("renderAll");try{this.renderScene(t)}catch(e){console.error("renderScene error",e)}finally{n.endTimeStatsItem("renderAll"),this._endFrame()}})),__publicField(this,"scaleZAtCurrentPosition",(()=>{const e=this._engine.map,t=e.getScaleAt(e.getCenter());this.scene.scale.z=t})),__publicField(this,"showCurrentViewFrustum",(()=>{this._currentViewCamera?this._currentViewCamera.copy(this._camera):this._currentViewCamera=this._camera.clone();const e=this._currentViewCameraHelper=new three.CameraHelper(this._currentViewCamera);e.matrixAutoUpdate=!1,this.add(e)})),__publicField(this,"removeCurrentViewFrustum",(()=>{this._currentViewCameraHelper&&(this.remove(this._currentViewCameraHelper),this._currentViewCameraHelper=null,this._currentViewCamera=null)})),this._engine=t;const n=this._options=this.getInitialConfig(i);Object.assign(this._contextParameters,n.contextParameters),n.preserveDrawingBuffer&&(this._contextParameters.preserveDrawingBuffer=!0);const r=n.features.antialias;this._contextParameters.antialias=r.enabled&&"msaa"===r.method,this._enableAnimationLoop=n.enableAnimationLoop||!1,this._animationLoopFrameTime=n.animationLoopFrameTime||16,this._useMRT=n.useMRT||!1,this._useXR=n.useXR||!1,this._pixelRatio=n.pixelRatio||window.devicePixelRatio,this._resolution.set(i.resolution.x,i.resolution.y),this._uniforms={time:{value:0},elapsedTime:{value:0},pixelRatio:{value:this._pixelRatio},zoomUnits:{value:1},resolution:{value:this._resolution.clone()}},Object.freeze(this._uniforms),this._stats=new Stats(this),this._main=new RenderingMainNew(this,n),this._picking=new Picking(this),this._label=new RenderingLabel(this),this._collision=new RenderingCollision(this),this._animation=new RenderingAnimation(this),this._xr=new RenderingXr(this),this._renderState=new RenderState(this),this._taskScheduler=new RenderingMicroTaskScheduler(this)}getInitialConfig(e){return deepMerge({useMRT:!1,enableAnimationLoop:!1,animationLoopFrameTime:16,useXR:!1,pixelRatio:window.devicePixelRatio,features:{antialias:{enabled:!0,method:"smaa"},bloom:{enabled:!1,strength:.1,threshold:1,radius:0},ao:{enabled:!1,method:"ssao"},reflection:{enabled:!1,method:"ssr"},shadow:{enabled:!1,method:"default"},depthPicking:{enabled:!1},colorAdjustment:{enabled:!1},hdr:{enabled:!1}}},e)}init(){const e=this._resolution;this._options.isOrthographicCamera?this._camera=new three.OrthographicCamera(-e.x/2,e.x/2,e.y/2,-e.y/2,.1,1e6):this._camera=new three.PerspectiveCamera(35,e.x/e.y,1,100),this._camera.matrixAutoUpdate=!1,this._rawCamera=this._camera.clone();const t=this._scene=new three.Scene,i=this.uiScene=new three.Group,n=this.objectsScene=new three.Group,r=this.environmentScene=new three.Group;n.add(i),t.add(n),t.add(r),t.matrixAutoUpdate=!1,this._createRenderer(),this._uniforms.resolution.value[0]=e.x,this._uniforms.resolution.value[1]=e.y,this._picking.init(),this._xr.init();let s=this._options.sky;void 0===s&&(s=new DefaultSky),s&&this.add(s)}_createRenderer(){const e=this._resolution,t=this._engine;let i=!!this._renderer,n=1;i&&(n=this._renderer.envMapIntensity,t.map.releaseCanvas(),this._renderer.forceContextLoss(),this._renderer.dispose());const r=this._canvas=document.createElement("canvas");addClass(r,`${CSS_NAMESPACE}-canvas`),r.style.position="absolute",r.style.top="0",r.style.left="0",r.style.zIndex="2";const s=this._context=r.getContext("webgl2",this._contextParameters),a=this._renderer=new three.WebGLRenderer({canvas:r,context:s,logarithmicDepthBuffer:!0});a.setClearColor(16777215,0),a.setPixelRatio(this._pixelRatio),a.setSize(e.x,e.y),a.setOpaqueSort(_opaqueSort),a.setTransparentSort(_transparentSort),a.info.autoReset=!1,this._renderer.extraProgramCacheKey="0",this._renderer.envMapIntensity=n,a.onShaderBeforeResolve=this.handleShaderBeforeResolve,a.onShaderBeforeCompile=this.handleShaderBeforeCompile,a.onMaterialBeforeCompile=this.handleMaterialBeforeCompile,i&&(t.map._map.canvas=r,t.map.bindCanvas())}addBeforeRenderListener(e){-1===this._beforeRenderListeners.indexOf(e)&&this._beforeRenderListeners.push(e)}removeBeforeRenderListener(e){const t=this._beforeRenderListeners.indexOf(e);t>-1&&this._beforeRenderListeners.splice(t,1)}addPrepareRenderListener(e){-1===this._prepareRenderListeners.indexOf(e)&&this._prepareRenderListeners.push(e)}removePrepareRenderListener(e){const t=this._prepareRenderListeners.indexOf(e);t>-1&&this._prepareRenderListeners.splice(t,1)}add(e){return e.traverse((e=>{e.afterAddToEngine&&!e.__initInEngine&&(e.__initInEngine=!0,e.afterAddToEngine(this._engine)),e instanceof EmptySky?this.sky=e:e instanceof DynamicWeather&&(this.weather=e),this.addBeforePrepareRenderObject(e),this.addBeforeRenderObject(e),this.addOnRenderModeChangeObject(e)})),e.__isEnvironment?this.environmentScene.add(e):e.isRenderInPostprocess?this.uiScene.add(e):this.objectsScene.add(e),e.supportRenderPassCallbacks&&this._onRenderPassChangedObjects.add(e),this._needsRenderImmediately=!0,e.userData.__debugObjectId||(e.userData.__debugObjectId=__debugObjectId++),e}remove(e){e&&(e.traverse((e=>{e.beforeRemoveFromEngine&&(e.__initInEngine=void 0,e.beforeRemoveFromEngine(this._engine)),e instanceof EmptySky?this._sky=null:e instanceof DynamicWeather&&(this._weather=null),this.removeBeforeRenderObject(e),this.removeBeforePrepareRenderObject(e),this.removeOnRenderModeChangeObject(e)})),e.__isEnvironment?this.environmentScene.remove(e):e.isRenderInPostprocess?this.uiScene.remove(e):this.objectsScene.remove(e),e.supportRenderPassCallbacks&&this._onRenderPassChangedObjects.delete(e),this._needsRenderImmediately=!0)}addBeforePrepareRenderObject(e){e.onBeforeScenePrepareRender&&this._beforeScenePrepareRenderObjects.add(e)}removeBeforePrepareRenderObject(e){this._beforeScenePrepareRenderObjects.delete(e)}addBeforeRenderObject(e){e.onBeforeSceneRender&&this._beforeSceneRenderObjects.add(e)}removeBeforeRenderObject(e){this._beforeSceneRenderObjects.delete(e)}addOnRenderModeChangeObject(e){e.onRenderModeChanged&&this._onRenderModeChangedObjects.add(e)}removeOnRenderModeChangeObject(e){e.onRenderModeChanged&&this._onRenderModeChangedObjects.delete(e)}startRenderLoop(){this._isRunning=!0,this._needsRenderImmediately=!0,this._startTime=(new Date).valueOf(),this._lastClockTime=this._startTime,this.render()}stopRenderLoop(){this._isRunning=!1}updateCamera(){this._engine.map.updateCamera()}requestRender(){this._needsRenderImmediately=!0}_copyRawCamera(){this._rawCamera||(this._rawCamera=this._camera.clone()),this._rawCamera.copy(this._camera)}renderScene(e){const t=this._engine,i=t.event,n=this._stats;e||(e=(new Date).valueOf()),this._uniforms.time.value=e,this._uniforms.elapsedTime.value=e-this._startTime,this._uniforms.zoomUnits.value=this._engine.map.getZoomUnits(),this._uniforms.resolution.value.copy(this._resolution),this.camera._isLocked||this.updateCamera(),this._copyRawCamera();const r=this._camera,s=this._scene,a=this._renderer;this.environmentScene.visible=!1;const o=this._renderState;i.beginFrame(),o.beginFrame(this,e),o.isResolutionOrPixelRatioChanged&&this._main.setSize(this._resolution.x,this._resolution.y,this._pixelRatio),this._picking.beginFrame(),this._main.beginFrame(),this._needsReCreateRenderer?(this._needsReCreateRenderer=!1,this._createRenderer()):o.isResolutionOrPixelRatioChanged&&(this._renderer.setSize(this._resolution.x,this._resolution.y),this._renderer.setPixelRatio(this._pixelRatio));o._viewChanged&&r.dispatchEvent({type:"viewchanged"}),n.beginTimeStatsItem("updateAnimation"),this._animation.update(o),n.endTimeStatsItem("updateAnimation");for(let g of this._prepareRenderListeners)g(this._engine,o);this._beforeScenePrepareRenderObjects.forEach((e=>{e.onBeforeScenePrepareRender(t,s,r,o)}));const l=r.position.clone();let c=0,h=0,u=0;const d=1e3,p=Math.floor(l.x/d)*d,m=Math.floor(l.y/d)*d,f=Math.floor(l.z/d)*d;if(c=l.x-p,h=l.y-m,u=l.z-f,this._autoOffsetRelativeCenter){if(a.xr.isPresenting){this._xr.xrCamera.position.set(p+c,m+h,f+u)}r.position.set(c,h,u),r.updateMatrix(),r.updateMatrixWorld(),s.position.set(-p,-m,-f),o.updateCameraOffsetState(r,p,m,f)}else{if(a.xr.isPresenting){this._xr.xrCamera.position.copy(l)}o.updateCameraOffsetState(r,0,0,0)}s.updateMatrix(),s.updateMatrixWorld(),this._clampCameraNearFar&&this._computeCameraNearFar(),a.info.reset(),n.beginTimeStatsItem("updateCollision"),this._collision.update(o),n.endTimeStatsItem("updateCollision"),this._beforeSceneRenderObjects.forEach((e=>{e.onBeforeSceneRender(t,s,r,o)}));for(let g of this._beforeRenderListeners)g(this._engine,o);if(n.beginTimeStatsItem("updateNodeMaterials"),n.endTimeStatsItem("updateNodeMaterials"),n.beginTimeStatsItem("renderMain"),this._main.render(this._onRenderPassChangedObjects),n.endTimeStatsItem("renderMain"),this._autoOffsetRelativeCenter){if(a.xr.isPresenting){this._xr.xrCamera.position.copy(l)}r.position.copy(l),r.updateMatrix(),r.updateMatrixWorld(),s.position.set(0,0,0),s.updateMatrix(),s.updateMatrixWorld()}this._main.endFrame(),this._picking.endFrame(),o.endFrame(this),i.endFrame(),this._useMRTChanged=!1}async renderVideo(t){let i=null;try{i=await window.showDirectoryPicker()}catch(e){return void console.error("请检查当前页面是否为https协议，showDirectoryPicker error:",e)}t.directoryHandle=i,t.outputPath=i.name,this._videoConfig=t,this.stopRenderLoop();const n=t.duration,r=n*t.fps;this._startTime=(new Date).valueOf(),this._videoFrameCount=r,this._videoFrameIndex=0,this._resolution.set(t.width,t.height),this._videoSavedState={pixelRatio:this._pixelRatio,aaEnabled:this.features.antialias.enabled,aaMethod:this.features.antialias.method},this._pixelRatio=t.pixelRatio||1,this._resolution.set(t.width,t.height),this.features.antialias.enabled=!1,this.features.antialias.method="msaa";const s=t.tracker;return s&&s.start({duration:1e3*n,...t.trackerOptions}),this._renderVideoFrame(),new Promise(((e,t)=>{this._renderVideoResolve=e,this._renderVideoReject=t}))}_computeCameraNearFar(){const e=this._camera,t=this._scene;_tempMatrix4$3.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),_tempFrustum.setFromProjectionMatrix(_tempMatrix4$3);const i=new three.Vector2(1/0,0);this._computeObjectNearFar(t,e,_tempFrustum,i,[null,null]),i.x<.1&&(i.x=.1),e.near=i.x,e.far=i.y,e.updateProjectionMatrix()}_computeObjectNearFar(e,t,i,n,r){if(!1===e.visible)return;if(e.layers.test(t.layers)&&(e.isMesh||e.isLine||e.isPoints||e.isSprite)){if(e.isFSQuad)return;if(!e.frustumCulled||i.intersectsObject(e)){const i=e.geometry;if(i.boundingSphere||i.computeBoundingSphere(),!i.boundingSphere)return;if(_tempSphere.copy(i.boundingSphere),_tempSphere.applyMatrix4(e.matrixWorld),_tempSphere.radius>0){const i=_tempSphere.center.distanceTo(t.position),s=i-_tempSphere.radius,a=i+_tempSphere.radius;n.x>s&&(n.x=s,r[0]=e),n.y<a&&(n.y=a,r[1]=e)}}}const s=e.children;if(s)for(let a=0,o=s.length;a<o;a++)this._computeObjectNearFar(s[a],t,i,n,r)}_beginFrame(){this._taskScheduler.beginFrame()}_endFrame(){this._taskScheduler.endFrame()}updateContextParameters(e){const t=this._contextParameters;for(const i of Object.keys(e))t[i]!==e[i]&&(t[i]=e[i],this._needsReCreateRenderer=!0)}dispose(){this.stopRenderLoop(),this._debugMaterial&&this._debugMaterial.dispose();const e=Array.from(this.objectsScene.children),t=Array.from(this.environmentScene.children);for(let n=e.length-1;n>=0;n--){const t=e[n];this.remove(t),t.dispose&&t.dispose()}for(let n=t.length-1;n>=0;n--){const e=t[n];this.remove(e),e.dispose&&e.dispose()}this._picking.dispose(),this._renderer.dispose();let i=this._context.getExtension("WEBGL_lose_context");i&&i.loseContext()}get engine(){return this._engine}get contextParameters(){return this._contextParameters}get sky(){return this._sky}set sky(e){this._sky&&console.warn("you are trying to set sky, but it has already been set.Please use `engine.remove(oldSky)` before setting a new sky."),this._sky=e}get weather(){return this._weather}set weather(e){this._weather&&console.warn("you are trying to set weather, but it has already been set.Please use `engine.remove(oldWeather)` before setting a new weather."),this._weather=e}get debugShaderType(){return this._debugShaderType}set debugShaderType(e){if(this._debugShaderType=e,!this._useMRT)return;e=parseInt(e,10);const t=this._composition;if(e&&0!==e)if(1===e)t.debugTextures=this._main.getTextures();else if(2===e){const e=[];this.objectsScene.traverse((t=>{t.isLight&&t.shadow&&t.shadow.map&&e.push(t.shadow.map.texture)})),t.debugTextures=e}else 3===e?t.debugTextures=this._bloom.getTextures():4===e?t.debugTextures=this._ssr.getTextures():5===e&&this._sky&&this._sky.getTextures&&(t.debugTextures=this._sky.getTextures());else t.debugTextures=null}get isUseMRTChanged(){return this._useMRTChanged}get useMrt(){return this.useMRT}set useMrt(e){this.useMRT=e}get useMRT(){return this._useMRT}set useMRT(e){this._useMRT!==e&&(this._useMRT=e,this._useMRTChanged=!0)}get main(){return this._main}get shadow(){return this._main.features.shadow}get bloom(){return this._main.features.bloom}get ssr(){return warnOnce("deprecated, ssr has been removed"),{}}get composition(){return warnOnce("deprecated, composition has been removed"),{}}get fog(){return warnOnce("deprecated, fog has been removed"),{}}get postprocessing(){return warnOnce("deprecated, postprocessing has been removed"),{}}get label(){return this._label}get colorAdjustment(){return this._main.features.colorAdjustment}get renderState(){return this._renderState}get pick(){return warnOnce("`rendering.pick` is deprecated, use `.picking` instead"),this._picking}get picking(){return this._picking}get stats(){return this._stats}get collision(){return this._collision}get animation(){return this._animation}get xr(){return this._xr}get taskScheduler(){return this._taskScheduler}get enableAnimationLoop(){return this._enableAnimationLoop}set enableAnimationLoop(e){this._enableAnimationLoop=e}get animationLoopFrameTime(){return this._animationLoopFrameTime}set animationLoopFrameTime(e){this._animationLoopFrameTime=e}get resolution(){return this._resolution}set resolution(e){this._resolution=e}get pixelRatio(){return this._pixelRatio}set pixelRatio(e){this._pixelRatio=e}get outputEncoding(){return this._outputEncoding}set outputEncoding(e){this._outputEncoding=e}get canvas(){return this._canvas}get renderer(){return this._renderer}get camera(){return this._camera}get scene(){return this._scene}get uniforms(){return this._uniforms}set wireframe(e){this._wireframe=e,this._debugMaterial&&(this._debugMaterial.wireframe=e)}get wireframe(){return this._wireframe}set debugMode(e){(e=parseInt(e,10))!==this._debugMode&&(this._debugMode=e,e!==DEBUG_MODE_NONE?(this._debugMaterial||(this._debugMaterial=new three.ShaderMaterial({uniforms:{color:{value:new three.Color(35071)}},vertexShader:debugVertexShader,fragmentShader:debugFragmentShader,wireframe:this._wireframe}),this._debugMaterial.onBeforeRender=(e,t,i,n,r,s)=>{let a=0;const o=this._debugMode;if(o===DEBUG_MODE_MESH)a=r.id;else if(o===DEBUG_MODE_MATERIAL)a=r.material.id;else if(o===DEBUG_MODE_OBJECT){let e=r;do{if(e.userData.__debugObjectId){a=e.userData.__debugObjectId;break}}while(e.parent&&(e=e.parent))}let l=null;l=a?debugColors[a%debugColors.length]:13750737,this._debugMaterial.uniforms.color.value.set(l),this._debugMaterial.uniformsNeedUpdate=!0}),this._scene.overrideMaterial=this._debugMaterial):(this._scene.overrideMaterial=null,this._debugMaterial.dispose(),this._debugMaterial=null))}get debugMode(){return this._debugMode}get autoOffsetRelativeCenter(){return this._autoOffsetRelativeCenter}set autoOffsetRelativeCenter(e){this._autoOffsetRelativeCenter=e}get freezeUpdate(){return this._freezeUpdate}set freezeUpdate(e){!!e!==this._freezeUpdate&&(this._freezeUpdate=!!e,e?this.stopRenderLoop():this.startRenderLoop())}get useHighPrecisionBuffer(){return this._useHighPrecisionBuffer}set useHighPrecisionBuffer(e){this._useHighPrecisionBuffer=e}get clampCameraNearFar(){return this._clampCameraNearFar}set clampCameraNearFar(e){this._clampCameraNearFar=e}get hasWater(){return this._waterReference>0}get rawCamera(){return this._rawCamera}}const _raycaster$5=new three.Raycaster,_seaLevelPlane$1=new three.Plane(new three.Vector3(0,0,1),0),_pointIn$1=new three.Vector3,_pointOut$1=new three.Vector3;class BaseMap{constructor(e,t){this._engine=e,this._options=t}init(){}parsePointToArr(e){if(!e)return null;let t=[];if(Array.isArray(e))for(let i of e)t.push(parseFloat(i));else if("string"==typeof e){const i=e.split(",");for(let e=0;e<i.length;e++)t[e]=parseFloat(i[e])}else"object"==typeof e&&e.isVector3&&(t=[e.x,e.y,e.z]);return t}projectArrayCoordinate(e,t){return _pointIn$1.set(e[0],e[1],e[2]||0),this.projection.projectCoordinate(_pointIn$1,_pointOut$1),t||(t=[0,0,0]),t[0]=_pointOut$1.x,t[1]=_pointOut$1.y,t[2]=_pointOut$1.z,t}unprojectArrayCoordinate(e,t){return _pointIn$1.set(e[0],e[1],e[2]||0),this.projection.unprojectCoordinate(_pointIn$1,_pointOut$1),t||(t=[0,0,0]),t[0]=_pointOut$1.x,t[1]=_pointOut$1.y,t[2]=_pointOut$1.z,t}getViewHeight(){return this.camera.position.z}bindCanvas(){console.warn("bindCanvas must be implemented in subclass")}releaseCanvas(){console.warn("releaseCanvas must be implemented in subclass")}pickSeaLevelWorldPosition(e){const t=this._engine.camera,i=this._engine.rendering.picking.pixelToNdc(e);_raycaster$5.setFromCamera(i,t);const n=new three.Vector3;return _raycaster$5.ray.intersectPlane(_seaLevelPlane$1,n),n}dispose(){}}const isSupportPointerEvent=!!window.PointerEvent,isMobile=/ipod|ipad|iphone|android/.test(navigator.userAgent.toLowerCase()),isPointerTouch=e=>e&&"touch"===e.pointerType,isTouchEvent=e=>e.type.includes("touch"),EVENTS=(()=>{let e;return e=isSupportPointerEvent?{DOWN:"pointerdown",MOVE:"pointermove",UP:"pointerup",CANCEL:"pointercancel"}:isMobile?{DOWN:"touchstart",MOVE:"touchmove",UP:"touchend",CANCEL:"touchcancel"}:{DOWN:"mousedown",MOVE:"mousemove",UP:"mouseup",CANCEL:"mousecancel"},e})(),EventAction$1={NONE:0,PAN:1,ROTATE:2,ZOOM:3},_mouse$1=new three.Vector2,_raycaster$4=new three.Raycaster,_mapPlane$2=new three.Plane(new three.Vector3(0,0,1),0);new three.Vector3;const _mapCenter=new three.Vector3,_mapMcCoord0$1=new three.Vector3,_mapMcCoord$1=new three.Vector3,_tempCamera$1=new three.PerspectiveCamera;_tempCamera$1.fov=35,new three.Vector2;class MapControl{constructor(e){__publicField(this,"map"),__publicField(this,"currentAction"),__publicField(this,"startX"),__publicField(this,"startY"),__publicField(this,"startCenterX"),__publicField(this,"startCenterY"),__publicField(this,"startPitch"),__publicField(this,"startHeading"),__publicField(this,"startZoom"),__publicField(this,"startZoomUnits"),__publicField(this,"startAtTop"),__publicField(this,"mapWidth"),__publicField(this,"mapHeight"),__publicField(this,"startCamera",new three.PerspectiveCamera),__publicField(this,"startCenter",new three.Vector3),__publicField(this,"startNdc",new three.Vector2),__publicField(this,"startPoint",new three.Vector3),__publicField(this,"startScaleX",1),__publicField(this,"startScaleY",1),__publicField(this,"startBoundX"),__publicField(this,"startBoundY"),__publicField(this,"_enabled",!1),__publicField(this,"minPitch",0),__publicField(this,"maxPitch",89),__publicField(this,"zoomSpeed",.005),__publicField(this,"headingSpeed",.4),__publicField(this,"pitchSpeed",.3),__publicField(this,"doubleClickTimer",null),__publicField(this,"clickInterval",200),__publicField(this,"init",(()=>{const e=this.map.domContainer;e.addEventListener(EVENTS.DOWN,this.handleMouseDown),e.addEventListener("wheel",this.handleWheel),e.addEventListener("contextmenu",this.handleContextMenu),e.addEventListener(EVENTS.MOVE,this.handleMouseMove)})),__publicField(this,"handleResize",(e=>{const[t,i]=this.map.getContainerSize();this.mapWidth=t,this.mapHeight=i;const n=this.map.domContainer.getBoundingClientRect();this.startBoundX=n.left,this.startBoundY=n.top,this.startScaleX=n.width/t,this.startScaleY=n.height/i})),__publicField(this,"handleMouseMove",(e=>{this.currentAction===EventAction$1.NONE&&this.onEventMouseMove&&this.onEventMouseMove(e)})),__publicField(this,"handleMouseDown",(e=>{let t=this.mapHeight,i=this.mapWidth;const n=this.map.domContainer.getBoundingClientRect();this.startBoundX=n.left,this.startBoundY=n.top,this.startScaleX=n.width/i,this.startScaleY=n.height/t;const r=(e.clientX-this.startBoundX)/this.startScaleX,s=(e.clientY-this.startBoundY)/this.startScaleY;if(0===e.button?(this.startZoomUnits=this.map.getZoomUnitsByZoom(this.map.zoom),this.setPanStartState(r,s),this.currentAction=EventAction$1.PAN):2===e.button?this.currentAction=EventAction$1.ROTATE:this.currentAction=EventAction$1.NONE,this.currentAction===EventAction$1.NONE)return;e&&this.onEventPointerDown&&(this.hasMoved||this.onEventPointerDown(e)),this.startX=r,this.startY=s;const a=this.map;this.startCenterX=a.center[0],this.startCenterY=a.center[1],this.startPitch=a.pitch,this.startHeading=a.heading,this.startZoom=a.zoom,this.startAtTop=s<t/2,document.addEventListener(EVENTS.MOVE,this.handleMouseDragging),document.addEventListener(EVENTS.UP,this.handleMouseUp)})),__publicField(this,"handleMouseDragging",(e=>{if(this.currentAction===EventAction$1.NONE)return;this.hasMoved=!0;const t=this.currentPixelX=(e.clientX-this.startBoundX)/this.startScaleX,i=this.currentPixelY=(e.clientY-this.startBoundY)/this.startScaleY;this.currentAction===EventAction$1.PAN?this.handlePan(t,i):this.currentAction===EventAction$1.ROTATE&&this.handleRotate(t,i)})),__publicField(this,"handleMouseUp",(e=>{this.currentAction=EventAction$1.NONE,document.removeEventListener(EVENTS.MOVE,this.handleMouseDragging),document.removeEventListener(EVENTS.UP,this.handleMouseUp),e&&this.onEventPointerUp&&this.onEventPointerUp(e),e&&this.onEventClick&&(this.hasMoved||this.onEventClick(e)),e&&this.onEventDblClick&&(!this.hasMoved&&this.waitSecondClick?(this.onEventDblClick(e),this.clearDoubleClickTimer()):this.waitSecondClick=!0),clearTimeout(this.doubleClickTimer),this.doubleClickTimer=setTimeout((()=>{this.clearDoubleClickTimer()}),this.clickInterval),this.hasMoved=!1})),__publicField(this,"clearDoubleClickTimer",(()=>{this.doubleClickTimer&&clearTimeout(this.doubleClickTimer),this.waitSecondClick=!1,this.doubleClickTimer=null})),__publicField(this,"handleContextMenu",(e=>{e.preventDefault()})),__publicField(this,"handleWheel",(e=>{e.preventDefault(),e.stopPropagation();const t=(e.clientX-this.startBoundX)/this.startScaleX,i=(e.clientY-this.startBoundY)/this.startScaleY;this.handleZoom({deltaX:e.deltaX,deltaY:e.deltaY,pixelX:t,pixelY:i})})),__publicField(this,"handlePan",((e,t)=>{const i=this.map;this.getNdc(e,t,_mouse$1),this.ndcToPoint(_mouse$1,this.startCamera,_mapMcCoord$1),_mapMcCoord$1.distanceTo(this.startCamera.position)>6e3*i.zoomUnits?this.handleMouseUp():(_mapCenter.subVectors(this.startCenter,_mapMcCoord$1.sub(this.startPoint)),i.center=[_mapCenter.x,_mapCenter.y],i.updateView())})),__publicField(this,"setPanStartState",((e,t)=>{const i=this.map;this.startCamera.copy(i.camera),this.startCamera.updateMatrixWorld(),this.startCenter.set(i.center[0],i.center[1],0),this.getNdc(e,t,this.startNdc),this.ndcToPoint(this.startNdc,i.camera,this.startPoint)})),__publicField(this,"handleRotate",((e,t)=>{const i=this.map;let n=e-this.startX;const r=t-this.startY;this.startAtTop||(n*=-1);let s=this.startHeading+n*this.headingSpeed;s=this.makeHeadingSafe(s),i.heading=s;let a=this.startPitch+r*this.pitchSpeed;a=this.makePitchSafe(a),i.pitch=a,i.updateView()})),__publicField(this,"handleZoom",(e=>{const t=this.map;let i=t.zoom,n=i+e.deltaY*this.zoomSpeed*-1;if(i===n)return;if(n=this.makeZoomSafe(n),n<t.earthViewZoomMax)return this.map.zoom=n,void this.map.updateView();let r=this.mapWidth,s=this.mapHeight;const a=this.map.domContainer.getBoundingClientRect();this.startBoundX=a.left,this.startBoundY=a.top,this.startScaleX=a.width/r,this.startScaleY=a.height/s;let o=t.center,l=t.pitch,c=t.heading;this.getNdc(e.pixelX,e.pixelY,_mouse$1),_mapCenter.set(o[0],o[1],0),this.ndcToPoint(_mouse$1,t.camera,_mapMcCoord0$1),_mapMcCoord0$1.distanceTo(t.camera.position)>6e3*t.zoomUnits||(t.computeMapCameraMatrix(_tempCamera$1,o,n,l,c),this.ndcToPoint(_mouse$1,_tempCamera$1,_mapMcCoord$1),_mapCenter.sub(_mapMcCoord$1.sub(_mapMcCoord0$1)),this.map.center[0]=_mapCenter.x,this.map.center[1]=_mapCenter.y,this.map.zoom=n,this.map.updateView())})),__publicField(this,"makeZoomSafe",(e=>e>this.map.maxZoom?this.map.maxZoom:e<this.map.minZoom?this.map.minZoom:e)),__publicField(this,"makeHeadingSafe",(e=>((e%=360)<0&&(e+=360),e))),__publicField(this,"makePitchSafe",(e=>e<this.minPitch?this.minPitch:e>this.maxPitch?this.maxPitch:e)),__publicField(this,"dispose",(()=>{const e=this.map.domContainer;e.removeEventListener(EVENTS.DOWN,this.handleMouseDown),e.removeEventListener("wheel",this.handleWheel),e.removeEventListener("contextmenu",this.handleContextMenu),document.removeEventListener(EVENTS.MOVE,this.handleMouseDragging),document.removeEventListener(EVENTS.UP,this.handleMouseUp),e.removeEventListener(EVENTS.MOVE,this.handleMouseMove),this.clearDoubleClickTimer()})),this.map=e,this.enabled=!0,this.currentAction=EventAction$1.NONE}set enabled(e){e!==this._enabled&&(e?this.init():this.dispose(),this._enabled=e)}ndcToPoint(e,t,i){_raycaster$4.setFromCamera(e,t),_raycaster$4.ray.intersectPlane(_mapPlane$2,i)}getNdc(e,t,i){i.x=e/this.mapWidth*2-1,i.y=1-t/this.mapHeight*2}}var lib={},sensorPool={},id={};!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var t=1;e.default=function(){return"".concat(t++)}}(id);var sensors={},object={},debounce={};!function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;e.default=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:60,i=null;return function(){for(var n=this,r=arguments.length,s=new Array(r),a=0;a<r;a++)s[a]=arguments[a];clearTimeout(i),i=setTimeout((function(){e.apply(n,s)}),t)}}}(debounce);var constant={};Object.defineProperty(constant,"__esModule",{value:!0}),constant.SizeSensorId=constant.SensorTabIndex=constant.SensorClassName=void 0;var SizeSensorId="size-sensor-id";constant.SizeSensorId=SizeSensorId;var SensorClassName="size-sensor-object";constant.SensorClassName=SensorClassName;var SensorTabIndex="-1";constant.SensorTabIndex=SensorTabIndex,Object.defineProperty(object,"__esModule",{value:!0}),object.createSensor=void 0;var _debounce$1=_interopRequireDefault$2(debounce),_constant$2=constant;function _interopRequireDefault$2(e){return e&&e.__esModule?e:{default:e}}var createSensor$2=function(e,t){var i=void 0,n=[],r=(0,_debounce$1.default)((function(){n.forEach((function(t){t(e)}))})),s=function(){i&&i.parentNode&&(i.contentDocument&&i.contentDocument.defaultView.removeEventListener("resize",r),i.parentNode.removeChild(i),e.removeAttribute(_constant$2.SizeSensorId),i=void 0,n=[],t&&t())};return{element:e,bind:function(t){i||(i=function(){"static"===getComputedStyle(e).position&&(e.style.position="relative");var t=document.createElement("object");return t.onload=function(){t.contentDocument.defaultView.addEventListener("resize",r),r()},t.style.display="block",t.style.position="absolute",t.style.top="0",t.style.left="0",t.style.height="100%",t.style.width="100%",t.style.overflow="hidden",t.style.pointerEvents="none",t.style.zIndex="-1",t.style.opacity="0",t.setAttribute("class",_constant$2.SensorClassName),t.setAttribute("tabindex",_constant$2.SensorTabIndex),t.type="text/html",e.appendChild(t),t.data="about:blank",t}()),-1===n.indexOf(t)&&n.push(t)},destroy:s,unbind:function(e){var t=n.indexOf(e);-1!==t&&n.splice(t,1),0===n.length&&i&&s()}}};object.createSensor=createSensor$2;var resizeObserver={};Object.defineProperty(resizeObserver,"__esModule",{value:!0}),resizeObserver.createSensor=void 0;var _constant$1=constant,_debounce=_interopRequireDefault$1(debounce);function _interopRequireDefault$1(e){return e&&e.__esModule?e:{default:e}}var createSensor$1=function(e,t){var i=void 0,n=[],r=(0,_debounce.default)((function(){n.forEach((function(t){t(e)}))})),s=function(){i.disconnect(),n=[],i=void 0,e.removeAttribute(_constant$1.SizeSensorId),t&&t()};return{element:e,bind:function(t){var s;i||((s=new ResizeObserver(r)).observe(e),r(),i=s),-1===n.indexOf(t)&&n.push(t)},destroy:s,unbind:function(e){var t=n.indexOf(e);-1!==t&&n.splice(t,1),0===n.length&&i&&s()}}};resizeObserver.createSensor=createSensor$1,Object.defineProperty(sensors,"__esModule",{value:!0}),sensors.createSensor=void 0;var _object=object,_resizeObserver=resizeObserver,createSensor="undefined"!=typeof ResizeObserver?_resizeObserver.createSensor:_object.createSensor;sensors.createSensor=createSensor,Object.defineProperty(sensorPool,"__esModule",{value:!0}),sensorPool.removeSensor=sensorPool.getSensor=sensorPool.Sensors=void 0;var _id=_interopRequireDefault(id),_sensors=sensors,_constant=constant;function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}var Sensors={};function clean(e){e&&Sensors[e]&&delete Sensors[e]}sensorPool.Sensors=Sensors;var getSensor=function(e){var t=e.getAttribute(_constant.SizeSensorId);if(t&&Sensors[t])return Sensors[t];var i=(0,_id.default)();e.setAttribute(_constant.SizeSensorId,i);var n=(0,_sensors.createSensor)(e,(function(){return clean(i)}));return Sensors[i]=n,n};sensorPool.getSensor=getSensor;var removeSensor=function(e){var t=e.element.getAttribute(_constant.SizeSensorId);e.destroy(),clean(t)};sensorPool.removeSensor=removeSensor,Object.defineProperty(lib,"__esModule",{value:!0}),lib.ver=clear_1=lib.clear=bind_1=lib.bind=void 0;var _sensorPool=sensorPool,bind=function(e,t){var i=(0,_sensorPool.getSensor)(e);return i.bind(t),function(){i.unbind(t)}},bind_1=lib.bind=bind,clear=function(e){var t=(0,_sensorPool.getSensor)(e);(0,_sensorPool.removeSensor)(t)},clear_1=lib.clear=clear,ver="1.0.2";lib.ver=ver;const _tempQuaternion1=new three.Quaternion,_tempQuaternion2$1=new three.Quaternion,_raycaster$3=new three.Raycaster,_mapPlane$1=new three.Plane(new three.Vector3(0,0,1),0),_tempVector2$3=new three.Vector2;new three.Vector3,new three.Matrix4,new three.Vector4;const _leftBottomPixel$1=new three.Vector2(-1,-1);new three.Vector2(-1,1),new three.Vector2(1,1);const _rightBottomPixel$1=new three.Vector2(1,-1);new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3;const _tempPoint=new three.Vector3,_BlankMap=class extends BaseMap{constructor(e,t,i={}){super(e,i),__publicField(this,"isBlankMap",!0),__publicField(this,"MERCATOR_LENGTH",20037508.3427892),__publicField(this,"projectionName","_web_mercator"),__publicField(this,"origin",[0,0]),__publicField(this,"center",[0,0]),__publicField(this,"zoom",0),__publicField(this,"pitch",0),__publicField(this,"heading",0),__publicField(this,"bounds",[[-this.MERCATOR_LENGTH,-this.MERCATOR_LENGTH],[this.MERCATOR_LENGTH,this.MERCATOR_LENGTH]]),__publicField(this,"near",100),__publicField(this,"_far",38e3),__publicField(this,"fov",35),__publicField(this,"_cameraLocation",new three.Vector3),__publicField(this,"handleViewChange",(()=>{this.onViewChanged&&this.onViewChanged()})),__publicField(this,"handleMapResize",(()=>{this.control&&this.control.handleResize(this.getResolution()),this.onResolutionChanged&&this.onResolutionChanged(this.getResolution())})),__publicField(this,"handleEventClick",(e=>{const t=this._engine.event,i=this._getPixelFromEvent(e);2===e.button?t._handleRightClick({pixel:i,event:e}):t._handleClick({pixel:i,event:e})})),__publicField(this,"handleEventDblClick",(e=>{const t=this._engine.event,i=this._getPixelFromEvent(e);2===e.button?t._handleRightDblClick({pixel:i,event:e}):t._handleDblClick({pixel:i,event:e})})),__publicField(this,"handleEventPointerDown",(e=>{const t=this._engine.event,i=this._getPixelFromEvent(e);t._handlePointerDown({pixel:i,event:e})})),__publicField(this,"handleEventPointerUp",(e=>{const t=this._engine.event,i=this._getPixelFromEvent(e);t._handlePointerUp({pixel:i,event:e})})),__publicField(this,"handleEventMouseMove",(e=>{const t=this._engine.event,i=this._getPixelFromEvent(e);t._handleMouseMove({pixel:i,event:e})})),__publicField(this,"_getPixelFromEvent",(e=>{const t=this._engine.rendering.canvas.getBoundingClientRect();return[e.clientX-t.left,e.clientY-t.top]})),this._engine=e,this.domContainer=t}afterInit(){this.camera.matrixAutoUpdate=!1,this.bindCanvas(),this.handleMapResize(),bind_1(this.domContainer,this.handleMapResize),this.initControl(),this.resetHome()}resetHome(){this.lookAt(_BlankMap.DEFAULT_CENTER,{zoom:4.5,pitch:0,heading:0})}initControl(){this.control=new MapControl(this),this.control.onEventPointerDown=this.handleEventPointerDown,this.control.onEventPointerUp=this.handleEventPointerUp,this.control.onEventClick=this.handleEventClick,this.control.onEventDblClick=this.handleEventDblClick,this.control.onEventMouseMove=this.handleEventMouseMove}bindCanvas(){this.domContainer.appendChild(this.canvas)}releaseCanvas(){this.domContainer.removeChild(this.canvas)}getContainerSize(){return[this.domContainer.clientWidth,this.domContainer.clientHeight]}getResolution(){return new three.Vector2(this.domContainer.clientWidth,this.domContainer.clientHeight)}getCenter(){return this.unprojectArrayCoordinate(this.center)}getZoom(){return this.zoom}getPitch(){return this.pitch}getZoomUnitsByZoom(e){return this.MERCATOR_LENGTH/128/Math.pow(2,e)}getCameraLocation(e){return e||(e=new three.Vector3),e.copy(this._cameraLocation),e}getZoomByZoomUnits(e){return Math.log2(this.MERCATOR_LENGTH/128/e)}getZoomUnits(){return this.getZoomUnitsByZoom(this.zoom)}getHeading(){return this.heading}enableControl(){this.control.enabled=!0}disableControl(){this.control.enabled=!1}setCameraMatrix(){this.handleViewChange()}_updateCameraLocation(){this.projection.unprojectCoordinate(this.camera.position,this._cameraLocation)}updateCamera(){this.computeMapCameraMatrix(this.camera,this.center,this.zoom,this.pitch,this.heading),this._updateCameraLocation()}computeMapCameraMatrix(e,t,i,n,r){const[s,a]=this.getContainerSize();let o=this.zoomUnits=this.getZoomUnitsByZoom(i);if(s*o>this.bounds[1][0]-this.bounds[0][0]){let e=(this.bounds[1][0]-this.bounds[0][0])/s;o=this.zoomUnits=e,this.zoom=this.getZoomByZoomUnits(e)}if(a*o>this.bounds[1][1]-this.bounds[0][1]){let e=(this.bounds[1][1]-this.bounds[0][1])/a;o=this.zoomUnits=e,this.zoom=this.getZoomByZoomUnits(e)}t[0]-s/2*o<this.bounds[0][0]&&(t[0]=this.bounds[0][0]+s/2*o),t[0]+s/2*o>this.bounds[1][0]&&(t[0]=this.bounds[1][0]-s/2*o),t[1]-a/2*o<this.bounds[0][1]&&(t[1]=this.bounds[0][1]+a/2*o),t[1]+a/2*o>this.bounds[1][1]&&(t[1]=this.bounds[1][1]-a/2*o),this.center=t;const l=a/2/Math.tan(this.fov/2*Math.PI/180)*o;this.cameraDistance=l,e.position.set(0,0,0),e.quaternion.set(0,0,0,1),e.up.set(0,0,1),e.translateX(t[0]),e.translateY(t[1]),t[2]&&e.translateZ(t[2]),e.rotateOnAxis(new three.Vector3(0,0,1),r*Math.PI/180),e.rotateOnAxis(new three.Vector3(1,0,0),n*Math.PI/180),e.translateZ(l),e.updateMatrix(),e.updateMatrixWorld(),e.aspect=s/a;let c=o;c<1&&(c=1),e.near=Math.min(Math.max(e.position.z/1e4,.1),10),e.far=this._far*c,e.fov=this.fov,e.updateProjectionMatrix()}setCenter(e){const t=this.projectArrayCoordinate(e);t&&(this.center=t),this.setCameraMatrix()}setProjectionCenter(e){const t=this.unprojectArrayCoordinate(e);this.setCenter(t)}setZoom(e){isNaN(e)||(this.zoom=e),this.setCameraMatrix()}zoomIn(){this.setZoom(this.zoom+1)}zoomOut(){this.setZoom(this.zoom-1)}setHeading(e){this.heading=e,this.setCameraMatrix()}setPitch(e){this.pitch=e,this.setCameraMatrix()}setMaxRange(e){console.warn("setMaxRange is only compatible with 3DMap Control,\n            please set options 'map: {is3DControl: true}' when Engine is created")}lookAt(e,t={}){let i=[];e.isVector3?e.toArray(i):i=e;let n=this.projectArrayCoordinate(i);n&&(this.center=n),void 0!==t.heading&&(this.heading=t.heading),void 0!==t.pitch&&(this.pitch=t.pitch),void 0!==t.zoom&&(this.zoom=t.zoom),this.updateCamera(),this.setCameraMatrix()}_getCameraQuaternion(e,t){_tempQuaternion1.setFromAxisAngle(new three.Vector3(0,0,1),e*Math.PI/180),_tempQuaternion2$1.setFromAxisAngle(new three.Vector3(1,0,0),t*Math.PI/180);const i=new three.Quaternion;return i.multiplyQuaternions(_tempQuaternion1,_tempQuaternion2$1),i}flyTo(e,t){this.cancelFlight();let i=[];e.isVector3?i=e.toArray():e.isVector2?i=[e.x,e.y,0]:e instanceof Array&&(i=[e[0],e[1],e[2]||0]),this.projectArrayCoordinate(i,i);const n=this._engine,r=n.map,s=this,a=defaultValue$1(t.heading,n.map.getHeading()),o=defaultValue$1(t.pitch,n.map.getPitch()),l=this._getCameraQuaternion(a,o),c=new three.Vector3(0,0,-1).applyQuaternion(l).negate(),h=(new three.Vector3).fromArray(i),u=t.range;isNaN(u)||h.add(c.multiplyScalar(u));const d={destination:h,heading:three.MathUtils.degToRad(a),pitch:three.MathUtils.degToRad(o),duration:t.duration,complete:function(){s._currentFlight=void 0,t.complete&&t.complete()},cancel:t.cancel},p=CameraFlightPath.createTween(r,d);if(0===p.duration)return"function"==typeof p.complete&&p.complete(),void this.updateView();const m=performance.now();function f(){const e=performance.now()-m,{duration:t,complete:i,update:r,easingFunction:s}=p;if(e>=t)return r({time:t,easingFunction:s}),n.removePrepareRenderListener(f),void i();r({time:e,easingFunction:s}),n.requestRender()}n.addPrepareRenderListener(f),p.listener=f,this._currentFlight=p,this.updateView()}cancelFlight(){if(this._currentFlight){const e=this._currentFlight.listener;this._engine.removePrepareRenderListener(e),this._currentFlight=void 0}}setBounds(e){this.bounds=[this.projectArrayCoordinate(e[0]),this.projectArrayCoordinate(e[1])]}getNdcYFactor(){const e=this.getPitch();if(e<45)return 1;const t=(e-45)/45,i=1-.5*Math.tan(t*Math.PI/2);return Math.max(-.1,Math.min(i,1))}getProjectionBounds(){const e=[],t=this.getNdcYFactor();_raycaster$3.setFromCamera(_leftBottomPixel$1,this.camera),_raycaster$3.ray.intersectPlane(_mapPlane$1,_tempPoint);const i=_tempPoint.x,n=_tempPoint.y;_raycaster$3.setFromCamera(_rightBottomPixel$1,this.camera),_raycaster$3.ray.intersectPlane(_mapPlane$1,_tempPoint);const r=_tempPoint.x,s=_tempPoint.y;_tempVector2$3.set(-1,t),_raycaster$3.setFromCamera(_tempVector2$3,this.camera),_raycaster$3.ray.intersectPlane(_mapPlane$1,_tempPoint);const a=_tempPoint.x,o=_tempPoint.y;_tempVector2$3.set(1,t),_raycaster$3.setFromCamera(_tempVector2$3,this.camera),_raycaster$3.ray.intersectPlane(_mapPlane$1,_tempPoint);const l=_tempPoint.x,c=_tempPoint.y;return e[0]=Math.min(i,r,a,l),e[1]=Math.min(n,s,o,c),e[2]=Math.max(i,r,a,l),e[3]=Math.max(n,s,o,c),new three.Box3(new three.Vector3(e[0],e[1],0),new three.Vector3(e[2],e[3],0))}getBounds(){const e=this.getProjectionBounds(),t=this.unprojectArrayCoordinate([e.min.x,e.min.y]),i=this.unprojectArrayCoordinate([e.max.x,e.max.y]);return new three.Box3(new three.Vector3(t[0],t[1],0),new three.Vector3(i[0],i[1],0))}updateView(){this.setCameraMatrix()}getCameraDistance(){return this.cameraDistance}getProjectionCenter(){return[this.center[0],this.center[1]]}dispose(){this.releaseCanvas(),clear_1(this.domContainer),this._engine.event,this.control.dispose(),super.dispose()}get far(){return this._far}set far(e){this._far=e}};let BlankMap=_BlankMap;__publicField(BlankMap,"EARTH_RADIUS",637e4),__publicField(BlankMap,"DEFAULT_CENTER",[107.9,35.8]);const _postionVector=new three.Vector2,_velocityVector=new three.Vector2;class PointerMovementAggregator{constructor(e={}){__publicField(this,"_lastTime",0),__publicField(this,"_lastPosition",new three.Vector2),__publicField(this,"_velocity",new three.Vector2),__publicField(this,"_acceleration",new three.Vector2),__publicField(this,"_resistance",.003),__publicField(this,"_inertiaSpeed",0),__publicField(this,"_inertiaDirection",new three.Vector2),__publicField(this,"_scale",1),void 0!==e.resistance&&(this._resistance=e.resistance)}start(e,t,i){this._lastPosition.set(e,t),this._velocity.set(0,0),this._acceleration.set(0,0),this._lastTime=void 0===i?performance.now():i}update(e,t,i){void 0===i&&(i=performance.now());const n=i-this._lastTime;_postionVector.set(e,t);const r=_postionVector.sub(this._lastPosition);_velocityVector.copy(r).divideScalar(n),this._acceleration.copy(_velocityVector).sub(this._velocity),this._lastPosition.set(e,t),this._velocity.copy(_velocityVector),this._lastTime=i}setInertiaState(e,t,i){this._inertiaSpeed=e,this._inertiaDirection.copy(t),this._lastTime=i}startInertia(){this._inertiaSpeed=this._velocity.length(),this._inertiaDirection.copy(this._velocity).normalize()}getInertiaPosition(e){void 0===e&&(e=performance.now());const t=e-this._lastTime,i=this._inertiaSpeed;let n=i-this._resistance*i*t;n<0&&(n=0);const r=this._inertiaDirection.clone().multiplyScalar(i*t).add(this._lastPosition);return this._inertiaSpeed=n*this._scale,this._lastPosition.copy(r),this._lastTime=e,[r,i]}get inertiaDirection(){return this._inertiaDirection}get scale(){return this._scale}set scale(e){this._scale=e}}class DraggingMovementAggregator{constructor(e={}){__publicField(this,"_lastTime",0),__publicField(this,"_dragEndTime",0),__publicField(this,"_inertiaPosition",new three.Vector2),__publicField(this,"_diffX",0),__publicField(this,"_diffY",0),__publicField(this,"_dir",new three.Vector2),__publicField(this,"_dragPoint",new three.Vector2),__publicField(this,"_lastDragPoint",new three.Vector2),__publicField(this,"_velocity",0),__publicField(this,"_lastDiffDistance",0),__publicField(this,"_amplitudeX",0),__publicField(this,"_amplitudeY",0),__publicField(this,"_targetX",0),__publicField(this,"_targetY",0),__publicField(this,"_scale",1)}start(e,t,i){this._lastTime=void 0===i?performance.now():i,this._lastDiffDistance=Math.sqrt(Math.pow(e,2)+Math.pow(t,2))}update(e,t,i){void 0===i&&(i=performance.now());const n=i-this._lastTime;if(0===n)return;this._diffX=e,this._diffY=t,this._dragPoint.set(e,t),this._dragPoint.x===this._lastDragPoint.x&&this._dragPoint.y===this._lastDragPoint.y?this._dir.set(this._diffX,this._diffY):this._dir.set(this._dragPoint.x-this._lastDragPoint.x,this._dragPoint.y-this._lastDragPoint.y);let r=Math.sqrt(Math.pow(this._diffX,2)+Math.pow(this._diffY,2)),s=500*Math.abs(r-this._lastDiffDistance)/n;s=Math.min(s,2e3),this._velocity=.6*s+.4*this._velocity,this._lastTime=i,this._lastDiffDistance=r,this._lastDragPoint.copy(this._dragPoint)}startInertia(e=!1){this._dragEndTime=performance.now(),this._dragEndTime-this._lastTime>30&&(this._velocity=0);let t=.5*this._velocity*this._scale;e&&(t=.1*this._velocity*this._scale);let i=0,n=0;if(0===this._dir.y)i=t;else{let e=Math.abs(this._dir.x/this._dir.y);n=Math.round(Math.sqrt(t*t/(1+e*e))),i=Math.round(e*n)}this._dir.x<0&&(i=-i),this._dir.y<0&&(n=-n),this._targetX=this._diffX+i,this._targetY=this._diffY+n,this._amplitudeX=i,this._amplitudeY=n,this._velocity=0,this._lastDiffDistance=0,this._lastTime=0}getInertiaPosition(e){void 0===e&&(e=performance.now());let t=e-this._dragEndTime,i=Math.exp(-t/200),n=this._targetX-this._amplitudeX*i,r=this._targetY-this._amplitudeY*i,s=Math.abs(this._amplitudeX*i)>5||Math.abs(this._amplitudeY*i)>5;return this._inertiaPosition.set(n,r),[this._inertiaPosition,s]}get scale(){return this._scale}set scale(e){this._scale=e}}const EventAction={NONE:0,PAN:1,ROTATE:2,PITCH:3,ZOOM:4},MouseButton$1={LEFT:0,MIDDLE:1,RIGHT:2},EVENT_WHEEL="wheel",EVENT_CONTEXTMENU="contextmenu",EVENT_DRAGGING="dragging";new three.Vector2;const _mouse=new three.Vector2,_raycaster$2=new three.Raycaster,_mapPlane=new three.Plane(new three.Vector3(0,0,1),0),_bottomCenterNdc=new three.Vector2(0,-1),_bottomCenterMcCoord=new three.Vector3;new three.Vector3,new three.Vector3;const _mapMcCoord=new three.Vector3,_mapMcCoord0=new three.Vector3,_mapMcCoord1=new three.Vector3,_tempCamera=new three.PerspectiveCamera;new three.PerspectiveCamera,_tempCamera.fov=35;const _tempPixel=new three.Vector2;class MapControl3D{constructor(e){__publicField(this,"map"),__publicField(this,"currentAction"),__publicField(this,"isPointerDown",!1),__publicField(this,"startX"),__publicField(this,"startY"),__publicField(this,"startCenterX"),__publicField(this,"startCenterY"),__publicField(this,"startPitch"),__publicField(this,"startHeading"),__publicField(this,"startZoom"),__publicField(this,"startZoomUnits"),__publicField(this,"startAtTop"),__publicField(this,"mapWidth"),__publicField(this,"mapHeight"),__publicField(this,"startCamera",new three.PerspectiveCamera),__publicField(this,"startCenter",new three.Vector3),__publicField(this,"startNdc",new three.Vector2),__publicField(this,"startPoint",new three.Vector3),__publicField(this,"startScaleX",1),__publicField(this,"startScaleY",1),__publicField(this,"startBoundX"),__publicField(this,"startBoundY"),__publicField(this,"startProjectionCenter",new three.Vector3),__publicField(this,"_enabled",!1),__publicField(this,"_enableRotate",!0),__publicField(this,"_enableZoom",!0),__publicField(this,"_enablePan",!0),__publicField(this,"_enableTilt",!0),__publicField(this,"enableInertia",!0),__publicField(this,"minPitch",0),__publicField(this,"maxPitch",88),__publicField(this,"zoomSpeed",.005),__publicField(this,"headingSpeed",.4),__publicField(this,"pitchSpeed",.3),__publicField(this,"doubleClickTimer",null),__publicField(this,"clickInterval",200),__publicField(this,"_rotationMode",1),__publicField(this,"_buttonDown",{LEFT:!1,MIDDLE:!1,RIGHT:!1}),__publicField(this,"_primaryStartPosition",new three.Vector2),__publicField(this,"_primaryPosition",new three.Vector2),__publicField(this,"_primaryPreviousPosition",new three.Vector2),__publicField(this,"_positions",new Map),__publicField(this,"_previousPositions",new Map),__publicField(this,"_isPinching",!1),__publicField(this,"_isTouchHolding",!1),__publicField(this,"_lastPinchDist",0),__publicField(this,"_lastSeenTouchEvent",-800),__publicField(this,"_whichKindOfPinch"),__publicField(this,"_pinchConnectPosition",{position1:new three.Vector2,position2:new three.Vector2}),__publicField(this,"_pinchActionPosition",{position1:new three.Vector2,position2:new three.Vector2}),__publicField(this,"_pinchActionTimer"),__publicField(this,"_touchHoldTimer"),__publicField(this,"_clickPixelTolerance",5),__publicField(this,"_holdPixelTolerance",25),__publicField(this,"lastMoveDistance",0),__publicField(this,"init",(()=>{const e=this.map.domContainer;e.addEventListener(EVENTS.DOWN,this.handlePointerDownWithThrottle),e.addEventListener(EVENT_WHEEL,this.handleWheelWithThrottle),e.addEventListener(EVENT_CONTEXTMENU,this.handleContextMenu),e.addEventListener(EVENTS.MOVE,this.handlePointerMoveWithThrottle),this.initCursorAnchor()})),__publicField(this,"handlePointerDownWithThrottle",(e=>{this._eventThrottle.putEvent(EVENTS.DOWN,e),this._tryToTriggerEvents()})),__publicField(this,"handleWheelWithThrottle",(e=>{this._eventThrottle.putEvent(EVENT_WHEEL,e),this._tryToTriggerEvents()})),__publicField(this,"handlePointerMoveWithThrottle",(e=>{this._eventThrottle.putEvent(EVENTS.MOVE,e),this._tryToTriggerEvents()})),__publicField(this,"handleMouseDraggingWithThrottle",(e=>{this._eventThrottle.putEvent(EVENT_DRAGGING,e),this._tryToTriggerEvents()})),__publicField(this,"handlePointerUpWithThrottle",(e=>{this._eventThrottle.putEvent(EVENTS.UP,e),this._tryToTriggerEvents()})),__publicField(this,"_tryToTriggerEvents",(async()=>{this._eventThrottle.isEmpty||this._eventThrottle.isBusy||await this._eventThrottle.triggerEvents(this._triggerEvents)})),__publicField(this,"_triggerEvents",(async e=>{e[EVENTS.DOWN]&&await this.handlePointerDown(e[EVENTS.DOWN]),e[EVENT_WHEEL]&&await this.handleWheel(e[EVENT_WHEEL]),e[EVENTS.MOVE]&&await this.handlePointerMove(e[EVENTS.MOVE]),e[EVENT_DRAGGING]&&await this.handleMouseDragging(e[EVENT_DRAGGING]),e[EVENTS.UP]&&await this.handlePointerUp(e[EVENTS.UP]),this._tryToTriggerEvents()})),__publicField(this,"initCursorAnchor",(()=>{const e=this.cursorAnchor=document.createElement("div");e.style.position="absolute",e.style.width="40px",e.style.height="40px",e.style.backgroundColor="rgba(255, 255, 255, 0.5)",e.style.zIndex=100,e.style.pointerEvents="none",e.style.display="none",this.map.domContainer.appendChild(e)})),__publicField(this,"showCursorAnchor",((e,t)=>{this._rotationMode<=1||(this.cursorAnchor.style.left=e-20+"px",this.cursorAnchor.style.top=t-20+"px",this.cursorAnchor.style.display="block")})),__publicField(this,"hideCursorAnchor",(()=>{this.cursorAnchor.style.display="none"})),__publicField(this,"handleResize",(e=>{const[t,i]=this.map.getContainerSize();this.mapWidth=t,this.mapHeight=i;const n=this.map.domContainer.getBoundingClientRect();this.startBoundX=n.left,this.startBoundY=n.top,this.startScaleX=n.width/t,this.startScaleY=n.height/i})),__publicField(this,"fireTouchEvents",(async e=>{const t=this.map;let i=this.mapWidth,n=this.mapHeight;const r=this._positions,s=r.size,a=this._isPinching;if(1!==s&&this._buttonDown[MouseButton$1.LEFT]){if(this._buttonDown[MouseButton$1.LEFT]=!1,this._touchHoldTimer&&(clearTimeout(this._touchHoldTimer),this._touchHoldTimer=void 0),e&&this.onEventPointerUp&&this.onEventPointerUp(e),0===s&&!this._isTouchHolding&&e&&this.onEventClick&&!this.hasMoved){checkPixelTolerance$1(this._primaryStartPosition,Array.from(this._previousPositions.values())[0],this._clickPixelTolerance)&&this.onEventClick(e)}this._isTouchHolding=!1,this.hasMoved=!1,this.currentAction,EventAction.NONE}if(s<=1&&a&&(this._pinchActionTimer&&(clearTimeout(this._pinchActionTimer),this._pinchActionTimer=void 0),this._isPinching=!1,this._whichKindOfPinch=void 0,this._lastPinchDist=0,this.currentAction,EventAction.NONE),1===s&&!a){const s=Array.from(r.values())[0];this._primaryPosition.copy(s),this._primaryStartPosition.copy(s),this._primaryPreviousPosition.copy(s),this._buttonDown[MouseButton$1.LEFT]=!0;const a=this.map.domContainer.getBoundingClientRect();this.startBoundX=a.left,this.startBoundY=a.top,this.startScaleX=a.width/i,this.startScaleY=a.height/n;const o=s.x,l=s.y;this.startProjectionCenter.fromArray(t.getProjectionCenter());const c=new three.Vector2(o/i*2-1,1-2*l/n),h=await this._pickPosition(c);this.startCamera.copy(t.camera),this.startCamera.updateMatrixWorld(),_mapPlane.constant=-h.z,this.startPoint.copy(h),this.currentAction=EventAction.PAN,e&&this.onEventPointerDown&&this.onEventPointerDown(e),this.startX=o,this.startY=l,this.startAtTop=l<n/2,document.addEventListener(EVENTS.UP,this.handlePointerUpWithThrottle),this._touchHoldTimer=setTimeout((function(){if(this._enabled&&(this._touchHoldTimer=void 0,this._isTouchHolding=!0,e&&this.onEventClick)){checkPixelTolerance$1(this._primaryStartPosition,Array.from(this._previousPositions.values())[0],this._clickPixelTolerance)&&this.onEventClick(e)}}),this.touchHoldDelayMilliseconds),e.preventDefault()}if(2===s&&!a){const i=Array.from(r.values())[0],n=Array.from(r.values())[1];this._isPinching=!0;const s=t.getProjectionCenter();this.startPoint.set(s[0],s[1],s[2]);const a=t.decomposeRotation();this.startHeading=a.heading,this.startPitch=a.pitch,this.startDistance=t.camera.position.distanceTo(this.startPoint);const o=i.x,l=i.y;this.showCursorAnchor(o,l),this.currentAction=EventAction.ROTATE,this.startX=n.x,this.startY=n.y,this._lastPinchDist=i.distanceTo(n),this._pinchConnectPosition.position1.copy(i),this._pinchConnectPosition.position2.copy(n),this._pinchActionTimer=setTimeout((()=>{this._enabled&&(clearTimeout(this._pinchActionTimer),this._pinchActionTimer=void 0)}),150),e.preventDefault()}})),__publicField(this,"fireTouchMoveEvents",(async e=>{const t=this.map,i=this._positions;this._previousPositions;const n=i.size;if(this.currentAction!==EventAction.NONE){if(this.hasMoved=!0,this.onMouseDragging){if(!this.onMouseDragging())return}if(this.map.domContainer.style.cursor="grabbing",1===n&&this._buttonDown[MouseButton$1.LEFT]&&this._enablePan){const n=Array.from(i.values())[0],r=n.x,s=n.y;this._primaryPosition.copy(n);const a=this._primaryPreviousPosition;if(this.getNdc(r,s,_mouse),!this.ndcToPoint(_mouse,this.startCamera,_mapMcCoord)||_mapMcCoord.distanceTo(t.camera.position)>.8*t.camera.far)return void(await this.handlePointerUp());_mapMcCoord.sub(this.startPoint),_mapMcCoord.subVectors(this.startCamera.position,_mapMcCoord),t.camera.position.copy(_mapMcCoord),t.center=[_mapMcCoord.x,_mapMcCoord.y],e&&this.onEventMouseMove&&this.onEventMouseMove(e),a.copy(n),e.preventDefault()}else if(2===n&&this._isPinching){const e=t.camera,n=Array.from(i.values())[0],r=Array.from(i.values())[1];if(this._pinchActionTimer)return this._pinchActionPosition.position1.copy(n),void this._pinchActionPosition.position2.copy(r);if(void 0===this._whichKindOfPinch){const e=new three.Vector2,t=new three.Vector2,i=new three.Vector2;e.subVectors(this._pinchConnectPosition.position1,this._pinchConnectPosition.position2),e.normalize(),t.subVectors(this._pinchActionPosition.position1,this._pinchConnectPosition.position1),t.normalize(),i.subVectors(this._pinchActionPosition.position2,this._pinchConnectPosition.position2),i.normalize();const n=t.dot(i),r=e.dot(i);n>.8?this._whichKindOfPinch=EventAction.PITCH:Math.abs(r)<.7?this._whichKindOfPinch=EventAction.ROTATE:this._whichKindOfPinch=EventAction.ZOOM}if(this._whichKindOfPinch===EventAction.PITCH&&this._enableTilt){const i=r.y-this.startY;let n=this.startPitch+i*this.pitchSpeed;if(n=this.makePitchSafe(n),this._rotationMode<=1)t._cameraLookAt(e,this.startPoint,{heading:this.startHeading,pitch:n,range:this.startDistance});else{t._cameraLookAt(_tempCamera,this.startPoint,{heading:this.startHeading,pitch:n,range:.2}),this.getNdc(this.startX,this.startY,_mouse),_raycaster$2.setFromCamera(_mouse,_tempCamera);const i=_raycaster$2.ray.direction.clone();_mouse.set(0,0),_raycaster$2.setFromCamera(_mouse,_tempCamera);const r=_raycaster$2.ray.direction.clone();i.angleTo(r);const s=new three.Vector3;s.copy(i),s.normalize(),s.multiplyScalar(this.startDistance),e.position.copy(_mapMcCoord.copy(this.startPoint).sub(s)),e.quaternion.copy(_tempCamera.quaternion)}t.pitch=n}else if(this._whichKindOfPinch===EventAction.ZOOM&&this._enableZoom){const i=n.distanceTo(r),s=2*(this._lastPinchDist-i),a=three.MathUtils.clamp(s*this.zoomSpeed*-1,-.5,.5);this.getNdc((n.x+r.x)/2,(n.y+r.y)/2,_mouse);const o=await this._pickPosition(_mouse),l=e.position.distanceTo(o);if(l>.95*e.far)return;let c=a*three.MathUtils.clamp(l,.5,1e7);c+.2>l?(c=l-.2,t.range=.2):t.range=l-c,t.maxRange&&t.maxRange<l&&a<0&&(c=0);const h=new three.Vector3;h.subVectors(o,e.position),h.normalize();const u=new three.Vector3;u.copy(h).multiplyScalar(c).add(e.position),e.position.copy(u),t.center=[u.x,u.y],this._lastPinchDist=i}else if(this._whichKindOfPinch===EventAction.ROTATE&&this._enableRotate){const i=new three.Vector2;i.subVectors(this._pinchConnectPosition.position2,this._pinchConnectPosition.position1),i.normalize();const s=new three.Vector2;s.subVectors(r,n),s.normalize();let a=vector2RotateTo(s,i),o=this.startHeading-a/Math.PI*180;o=this.makeHeadingSafe(o),t._cameraLookAt(e,this.startPoint,{heading:o,pitch:this.startPitch,range:this.startDistance})}}this.handleCameraBeforeRender(),this.map.updateView()}})),__publicField(this,"handlePointerMove",(async e=>{if(isPointerTouch(e)){const t=this._positions,i=e.pointerId;let n=t.get(i);if(!n)return;let r=this.getPixelPosition(e);n.set(r[0],r[1]),await this.fireTouchMoveEvents(e);this._previousPositions.get(i).copy(t.get(i))}else await this.handleMouseMove(e)})),__publicField(this,"handleMouseMove",(async e=>{this.onEventMouseMove&&this.onEventMouseMove(e)})),__publicField(this,"handlePointerDown",(async e=>{if(isPointerTouch(e)){const t=e.pointerId;let i=this.getPixelPosition(e);this._positions.set(t,new three.Vector2(i[0],i[1])),await this.fireTouchEvents(e),this._previousPositions.set(t,this._positions.get(t).clone())}else await this.handleMouseDown(e)})),__publicField(this,"handleMouseDown",(async e=>{const t=this.map;let i=this.mapWidth,n=this.mapHeight;const r=this.map.domContainer.getBoundingClientRect();this.startBoundX=r.left,this.startBoundY=r.top,this.startScaleX=r.width/i,this.startScaleY=r.height/n;const[s,a]=this.getPixelPosition(e);this.startProjectionCenter.fromArray(t.getProjectionCenter()),this.lastMoveDistance=0;const o=new three.Vector2(s/i*2-1,1-2*a/n);if(cancelAnimationFrame(this._inertiaAnimationHanlder),this._draggingMovementAggregator.start(s,a),0===e.button){const e=await this._pickPosition(o);this.startCamera.copy(t.camera),this.startCamera.updateMatrixWorld(),_mapPlane.constant=-e.z,this.startPoint.copy(e),this.currentAction=EventAction.PAN}else if(2===e.button){if(0===this._rotationMode){_tempPixel.set(0,0),_raycaster$2.setFromCamera(_tempPixel,t.camera),_raycaster$2.ray.intersectPlane(_mapPlane,_mapMcCoord0),this.startPoint.copy(_mapMcCoord0);const e=t.decomposeRotation();this.startHeading=e.heading,this.startPitch=e.pitch}else if(1===this._rotationMode){const e=await this._pickPosition(new three.Vector2);this.startPoint.copy(e);const i=t.decomposeRotation();this.startHeading=i.heading,this.startPitch=i.pitch}else{const e=await this._pickPosition(o);this.startCamera.copy(t.camera),this.startCamera.updateMatrixWorld();const i=new three.Vector3;i.subVectors(e,this.startCamera.position),i.normalize(),this.startPoint.copy(e);const n=t.decomposeRotationFromDirection(i);this.startHeading=n.heading,this.startPitch=n.pitch}this.startDistance=t.camera.position.distanceTo(this.startPoint),this.currentAction=EventAction.ROTATE,this.showCursorAnchor(s,a)}else this.currentAction=EventAction.NONE;this.currentAction!==EventAction.NONE&&(e&&this.onEventPointerDown&&(this.hasMoved||this.onEventPointerDown(e)),this.startX=s,this.startY=a,this.startAtTop=a<n/2,this.isPointerDown=!0,document.addEventListener(EVENTS.MOVE,this.handleMouseDraggingWithThrottle),document.addEventListener(EVENTS.UP,this.handlePointerUpWithThrottle))})),__publicField(this,"_reactDragging",(async(e,t)=>{this.currentAction===EventAction.PAN?(this.map.domContainer.style.cursor="grabbing",await this.handlePan(e,t)):this.currentAction===EventAction.ROTATE&&(this.map.domContainer.style.cursor="grabbing",await this.handleRotate(e,t)),this.handleCameraBeforeRender(),this.map.updateView()})),__publicField(this,"handleMouseDragging",(async e=>{if(this.currentAction===EventAction.NONE)return;this.hasMoved=!0;const[t,i]=this.getPixelPosition(e);if(this._draggingMovementAggregator.update(t,i),this.onMouseDragging){if(!this.onMouseDragging())return}await this._reactDragging(t,i)})),__publicField(this,"handlePointerUp",(async e=>{if(isPointerTouch(e)){const t=e.pointerId;this._positions.delete(t),this.fireTouchEvents(e),this._previousPositions.delete(t)}else await this.handleMouseUp(e)})),__publicField(this,"_startInertiaAnimation",(()=>{const[e,t]=this._draggingMovementAggregator.getInertiaPosition();t?(this._inInertia=!0,this._reactDragging(e.x,e.y),this._inertiaAnimationHanlder=requestAnimationFrame(this._startInertiaAnimation)):(this._inInertia=!1,this.currentAction=EventAction.NONE)})),__publicField(this,"handleMouseUp",(async e=>{this.enableInertia&&this.currentAction!==EventAction.NONE?(this._draggingMovementAggregator.startInertia(this.currentAction===EventAction.ROTATE),this._startInertiaAnimation()):this.currentAction=EventAction.NONE,this.map.domContainer.style.cursor="default",this.hideCursorAnchor(),document.removeEventListener(EVENTS.MOVE,this.handleMouseDraggingWithThrottle),document.removeEventListener(EVENTS.UP,this.handlePointerUpWithThrottle),e&&this.onEventPointerUp&&this.onEventPointerUp(e),e&&this.onEventClick&&(this.hasMoved||this.onEventClick(e)),e&&this.onEventDblClick&&(!this.hasMoved&&this.waitSecondClick?(this.onEventDblClick(e),this.clearDoubleClickTimer()):this.waitSecondClick=!0),clearTimeout(this.doubleClickTimer),this.doubleClickTimer=setTimeout((()=>{this.clearDoubleClickTimer()}),this.clickInterval),this.hasMoved=!1,this.isPointerDown=!1})),__publicField(this,"clearDoubleClickTimer",(()=>{this.doubleClickTimer&&clearTimeout(this.doubleClickTimer),this.waitSecondClick=!1,this.doubleClickTimer=null})),__publicField(this,"handleContextMenu",(e=>{e.preventDefault()})),__publicField(this,"_reactZoom",(async(e,t,i,n)=>{await this.handleZoom({deltaX:e,deltaY:t,pixelX:i,pixelY:n}),this.handleCameraBeforeRender(),this.map.updateView()})),__publicField(this,"_startZoomInertiaAnimation",((e,t)=>{this._zoomInertiaAnimationHandler=requestAnimationFrame((()=>{const[i,n]=this._zoomMovementAggregator.getInertiaPosition();if(n>.1){const i=this._zoomMovementAggregator.inertiaDirection.y<0;this._reactZoom(0,i?-1*n:n,e,t),this._startZoomInertiaAnimation(e,t)}}))})),__publicField(this,"handleWheel",(async e=>{e.preventDefault(),e.stopPropagation();const[t,i]=this.getPixelPosition(e);if(cancelAnimationFrame(this._inertiaAnimationHanlder),cancelAnimationFrame(this._zoomInertiaAnimationHandler),this.enableInertia){const n=performance.now(),r=e.deltaY<0;let s=Math.abs(e.deltaY);s>20&&(s=20),this._zoomMovementAggregator.setInertiaState(s,new three.Vector2(0,r?-1:1),n),this._startZoomInertiaAnimation(t,i)}else this._reactZoom(0,e.deltaY,t,i)})),__publicField(this,"_calculateViewDistance",((e,t,i)=>{const n=i/2,r=t*Math.PI/180,s=n*Math.PI/180,a=Math.min(r+s,this.maxPitch*Math.PI/180);_raycaster$2.setFromCamera(_bottomCenterNdc,this.startCamera),_raycaster$2.ray.intersectPlane(_mapPlane,_bottomCenterMcCoord);return{centerToNearDistance:_bottomCenterMcCoord.distanceTo(this.startProjectionCenter),centerToFarDistance:e*(Math.tan(a)-Math.tan(r)),cameraToFarDistance:e/Math.cos(a),overPitch:t+n>this.maxPitch}})),__publicField(this,"handlePan",(async(e,t)=>{if(!this._enablePan)return;const i=this.map,n=this.startCamera;this.getNdc(e,t,_mouse);let r=this.ndcToPoint(_mouse,n,_mapMcCoord);const s=i.getViewHeight(),a=i.getPitch(),o=i.camera.fov,{centerToNearDistance:l,centerToFarDistance:c,cameraToFarDistance:h,overPitch:u}=this._calculateViewDistance(s,a,o),d=h/(u?18:c/l)*15;if(!r)return this.currentAction=EventAction.NONE,this._inInertia=!1,void(this.isPointerDown&&(this.isPointerDown=!1,await this.handlePointerUp()));const p=_mapMcCoord.distanceTo(n.position);if(this.isPointerDown&&p>d)return this.isPointerDown=!1,void(await this.handlePointerUp());_mapMcCoord1.subVectors(_mapMcCoord,this.startPoint);let m=_mapMcCoord1.length(),f=this._getElasticValue(m,0,d/2,.9);m>d&&(f=this.lastMoveDistance+Math.min(f-this.lastMoveDistance,s)/50),this.lastMoveDistance=f,_mapMcCoord1.normalize().multiplyScalar(f),_mapMcCoord.subVectors(this.startCamera.position,_mapMcCoord1),i.camera.position.copy(_mapMcCoord),i.center=[_mapMcCoord.x,_mapMcCoord.y]})),__publicField(this,"handleRotate",(async(e,t)=>{if(!this._enableRotate&&!this._enableTilt)return;const i=this.map,n=i.camera;let r=e-this.startX;const s=t-this.startY;this.startAtTop||(r*=-1);let a=this.startHeading;this._enableRotate&&(a=this.startHeading+r*this.headingSpeed,a=this.makeHeadingSafe(a));let o=this.startPitch;if(this._enableTilt&&(o=this.getElasticPitch(s),o=this.makePitchSafe(o)),this._rotationMode<=1)i._cameraLookAt(n,this.startPoint,{heading:a,pitch:o,range:this.startDistance});else{i._cameraLookAt(_tempCamera,this.startPoint,{heading:a,pitch:o,range:.2}),this.getNdc(this.startX,this.startY,_mouse),_raycaster$2.setFromCamera(_mouse,_tempCamera);const e=_raycaster$2.ray.direction.clone();_mouse.set(0,0),_raycaster$2.setFromCamera(_mouse,_tempCamera);const t=_raycaster$2.ray.direction.clone();e.angleTo(t);const r=new three.Vector3;r.copy(e),r.normalize(),r.multiplyScalar(this.startDistance),n.position.copy(_mapMcCoord.copy(this.startPoint).sub(r)),n.quaternion.copy(_tempCamera.quaternion)}i.pitch=o,i.heading=a})),__publicField(this,"handleZoom",(async e=>{if(!this._enableZoom)return;const t=this.map,i=t.range;if(e.deltaY<0&&i<t.minRange)return;if(e.deltaY>0&&i>t.maxRange)return;let n=this.mapWidth,r=this.mapHeight;const s=this.map.domContainer.getBoundingClientRect();this.startBoundX=s.left,this.startBoundY=s.top,this.startScaleX=s.width/n,this.startScaleY=s.height/r;const a=t.camera,o=three.MathUtils.clamp(e.deltaY*this.zoomSpeed*-1,-.5,.5);this.getNdc(e.pixelX,e.pixelY,_mouse);const l=await this._pickPosition(_mouse),c=a.position.distanceTo(l);if(c>.95*a.far)return;let h=o*three.MathUtils.clamp(c,.5,1e7);h+.2>c?(h=c-.2,t.range=.2):t.range=c-h,t.maxRange&&t.maxRange<c&&o<0&&(h=0);const u=new three.Vector3;u.subVectors(l,a.position),u.normalize();const d=new three.Vector3;d.copy(u).multiplyScalar(h).add(a.position),a.position.copy(d),t.center=[d.x,d.y]})),__publicField(this,"makeHeadingSafe",(e=>((e%=360)<0&&(e+=360),e))),__publicField(this,"makePitchSafe",(e=>e<this.minPitch?this.minPitch:e>this.maxPitch?this.maxPitch:e)),__publicField(this,"getElasticPitch",(e=>{const t=this.maxPitch-8,i=(this.minPitch-this.startPitch)/this.pitchSpeed,n=Math.max(0,t-this.startPitch)/this.pitchSpeed,r=this._inInertia?.3:.4;return e=this._getElasticValue(e,i,n,r),this.startPitch+e*this.pitchSpeed})),__publicField(this,"_getElasticValue",((e,t,i,n=.4)=>(e>i?e=Math.pow(e-i+1,n)+i-1:e<t&&(e=t-Math.pow(t-e+1,n)+1),e))),__publicField(this,"_tiltBounceBack",(()=>{const e=this.map;let t=e.getPitch();t<this.minPitch&&this._rotationMode<=1&&(e._cameraLookAt(e.camera,this.startPoint,{heading:e.getHeading(),pitch:this.minPitch,range:this.startDistance}),e.pitch=this.minPitch),t>this.maxPitch&&this._rotationMode<=1&&(e._cameraLookAt(e.camera,this.startPoint,{heading:e.getHeading(),pitch:this.maxPitch,range:this.startDistance}),e.pitch=this.maxPitch)})),__publicField(this,"dispose",(()=>{const e=this.map.domContainer;e.removeEventListener(EVENTS.DOWN,this.handlePointerDownWithThrottle),e.removeEventListener(EVENT_WHEEL,this.handleWheelWithThrottle),e.removeEventListener(EVENT_CONTEXTMENU,this.handleContextMenu),document.removeEventListener(EVENTS.MOVE,this.handleMouseDraggingWithThrottle),document.removeEventListener(EVENTS.UP,this.handlePointerUpWithThrottle),e.removeEventListener(EVENTS.MOVE,this.handlePointerMoveWithThrottle),this.clearDoubleClickTimer(),this.cursorAnchor.remove()})),this.map=e,this.enabled=!0,this.currentAction=EventAction.NONE,this._eventThrottle=new EventThrottle,this._draggingMovementAggregator=new DraggingMovementAggregator,this._zoomMovementAggregator=new PointerMovementAggregator({resistance:.005})}handleCameraBeforeRender(){this.map.camera.updateMatrix(),this.map.camera.updateMatrixWorld();let e=!0;this.onEventCameraChange&&(e=this.onEventCameraChange()),e?(this.originCamera=this.map.camera.clone(),this.originMap={center:this.map.center,pitch:this.map.pitch,heading:this.map.heading}):(this.map.camera.copy(this.originCamera,!0),this.map._engine.camera.copy(this.originCamera,!0),this.map.camera.updateMatrix(),this.map.camera.updateMatrixWorld(),this.map.camera.updateProjectionMatrix(),this.map.pitch=this.originMap.pitch,this.map.center=this.originMap.center,this.map.heading=this.originMap.heading)}getPixelPosition(e){let t=e.clientX,i=e.clientY;isTouchEvent(e)&&(t=e.changedTouches[0].clientX,i=e.changedTouches[0].clientY);return[this.currentPixelX=(t-this.startBoundX)/this.startScaleX,this.currentPixelY=(i-this.startBoundY)/this.startScaleY]}ndcToPoint(e,t,i){return _raycaster$2.setFromCamera(e,t),!!_raycaster$2.ray.intersectsPlane(_mapPlane)&&(_raycaster$2.ray.intersectPlane(_mapPlane,i),!0)}getNdc(e,t,i){i.x=e/this.mapWidth*2-1,i.y=1-t/this.mapHeight*2}async _pickPosition(e){const t=this.map._engine.rendering.picking;return await t.pickWorldPositionFromNdc(e)}set enabled(e){e!==this._enabled&&(e?this.init():this.dispose(),this._enabled=e)}set enableRotate(e){this._enableRotate=e}set enableZoom(e){this._enableZoom=e}set enablePan(e){this._enablePan=e}set enableTilt(e){this._enableTilt=e}get inertiaDragging(){return this._draggingMovementAggregator.scale}set inertiaDragging(e){this._draggingMovementAggregator.scale=e}get inertiaZoom(){return this._zoomMovementAggregator.scale}set inertiaZoom(e){this._zoomMovementAggregator.scale=e}}function checkPixelTolerance$1(e,t,i){const n=e.x-t.x,r=e.y-t.y;return Math.sqrt(n*n+r*r)<i}const DEFAULT_DIRECTION=new three.Vector3(0,0,-1),UP_DIRECTION=new three.Vector3(0,1,0),_raycaster$1=new three.Raycaster;_raycaster$1.mouse=new three.Vector2;const _seaLevelPlane=new three.Plane(new three.Vector3(0,0,1),0),_tempVector3$7=new three.Vector3;new three.Matrix4;class BlankMap3DControl extends BlankMap{constructor(){super(...arguments),__publicField(this,"isBlankMap3D",!0),__publicField(this,"_viewStateDirty",!0),__publicField(this,"maxRange",1/0),__publicField(this,"minRange",1e-6),__publicField(this,"range"),__publicField(this,"bounds",[]),__publicField(this,"getPixelSize",(e=>{const[t,i]=this.getContainerSize();return Math.tan(three.MathUtils.degToRad(this.fov/2))*e/i*2})),__publicField(this,"handleEventCameraChange",(()=>{const[e,t]=this.bounds;if(e&&t){const[i,n]=e,[r,s]=t,[a,o,l]=this.projectArrayCoordinate(this.getCenter());let c=!1;return Math.ceil(a)<i&&(c=!0),Math.ceil(o)<n&&(c=!0),Math.floor(a)>r&&(c=!0),Math.floor(o)>s&&(c=!0),!c}return!0}))}resetHome(){this.lookAt(BlankMap.DEFAULT_CENTER,{range:1e7,pitch:0,heading:0})}initControl(){this.control=new MapControl3D(this),this.control.onEventPointerDown=this.handleEventPointerDown,this.control.onEventPointerUp=this.handleEventPointerUp,this.control.onEventClick=this.handleEventClick,this.control.onEventDblClick=this.handleEventDblClick,this.control.onEventMouseMove=this.handleEventMouseMove,this.control.onEventCameraChange=this.handleEventCameraChange}updateView(){this.handleViewChange()}getCenter(){return this.unprojectArrayCoordinate(this.getProjectionCenter())}getProjectionCenter(){return _raycaster$1.setFromCamera(new three.Vector2,this.camera),_raycaster$1.ray.intersectPlane(_seaLevelPlane,_tempVector3$7),[_tempVector3$7.x,_tempVector3$7.y,_tempVector3$7.z]}getPitch(){return this.pitch}getHeading(){return this.heading}getRange(){return this.getCalcRange()}getCalcRange(){const e=this.getProjectionCenter();if("string"==typeof this.camera.position.z)throw new Error("camera.position.z is string");return this.camera.position.distanceTo(_tempVector3$7.set(e[0],e[1],e[2]))}getZoom(){return this.getZoomByZoomUnits(this.getZoomUnits())}getZoomUnits(){const e=this.getRange();return this.getPixelSize(e)}getCameraDistance(e){if(this.range&&!e)return this.range;if(e){const e=this.getProjectionCenter(),t=this.camera.position.distanceTo(new three.Vector3(e[0],e[1],e[2]));return this.range=t,this.range}return _raycaster$1.setFromCamera(new three.Vector2,this.camera),_raycaster$1.ray.intersectPlane(_seaLevelPlane,_tempVector3$7),this.range=this.camera.position.distanceTo(_tempVector3$7),this.range}setCenter(e){this.setProjectionCenter(this.projectArrayCoordinate(e))}setProjectionCenter(e){const t=this.decomposeRotation();this._cameraLookAt(this.camera,e,{...t,height:this.camera.position.z}),this.center=e,this.updateView()}setZoom(e){const t=this.decomposeRotation(),i=this.getProjectionCenter(),n=this.getZoomUnitsByZoom(e),[r,s]=this.getContainerSize(),a=s/2*n/Math.tan(three.MathUtils.degToRad(this.fov/2));this._cameraLookAt(this.camera,i,{...t,range:.1*a,height:a}),this.range=.1*a,this.updateView()}setPitch(e){const t=this.decomposeRotation(),i=this.getProjectionCenter(),n=this.camera.position.distanceTo(_tempVector3$7.set(i[0],i[1],i[2]));this._cameraLookAt(this.camera,i,{heading:t.heading,pitch:e,range:n}),this.pitch=e,this.updateView()}setHeading(e){const t=this.decomposeRotation(),i=this.getProjectionCenter(),n=this.camera.position.distanceTo(_tempVector3$7.set(i[0],i[1],i[2]));this._cameraLookAt(this.camera,i,{heading:e,pitch:t.pitch,range:n}),this.heading=e,this.updateView()}setRange(e){const t=this.decomposeRotation(),i=this.getProjectionCenter();this._cameraLookAt(this.camera,i,{...t,range:e}),this.range=e,this.updateView()}setMaxRange(e){this.maxRange=e}setMinRange(e){this.minRange=e}zoomIn(){const e=this.decomposeRotation(),t=this.getProjectionCenter();let i=this.camera.position.distanceTo(_tempVector3$7.set(t[0],t[1],t[2])),n=.5*three.MathUtils.clamp(i,.5,1e7);n+.2>i?(n=i-.2,i=.2):i-=n,this._cameraLookAt(this.camera,t,{...e,range:i}),this.range=i,this.updateView()}zoomOut(){const e=this.decomposeRotation(),t=this.getProjectionCenter();let i=this.camera.position.distanceTo(_tempVector3$7.set(t[0],t[1],t[2])),n=-.5*three.MathUtils.clamp(i,.5,1e7);n+.2>i?(n=i-.2,i=.2):i-=n,this._cameraLookAt(this.camera,t,{...e,range:i}),this.range=i,this.updateView()}lookAt(e,t={}){let i=[];e.isVector3?e.toArray(i):i=e;let n=this.projectArrayCoordinate(i);const{heading:r,pitch:s,range:a}=t;isNaN(r)||(this.heading=r),isNaN(s)||(this.pitch=s),isNaN(a)||(this.range=a),this._cameraLookAt(this.camera,n,t),this.updateView()}_cameraLookAt(e,t,i){const{heading:n=this.heading,pitch:r=this.pitch,range:s=this.range,height:a}=i,o=this._getCameraQuaternion(n,r),l=new three.Vector3(0,0,-1);l.applyQuaternion(o),l.negate();const c=_tempVector3$7;Array.isArray(t)?c.set(t[0],t[1],t[2]||0):t.isVector3&&c.copy(t),isNaN(s)||c.add(l.multiplyScalar(three.MathUtils.clamp(s,this.minRange,this.maxRange))),e.position.copy(c),e.quaternion.copy(o),e.updateMatrix(),e.updateMatrixWorld()}offsetFromHeadingPitchRange(e=0,t=0,i=0){const n=new three.Quaternion;n.setFromAxisAngle(new three.Vector3(0,0,1),e*Math.PI/180);const r=new three.Quaternion;r.setFromAxisAngle(new three.Vector3(1,0,0),t*Math.PI/180);const s=new three.Quaternion;s.multiplyQuaternions(n,r);const a=new three.Vector3(0,0,-1);a.applyQuaternion(s),a.negate();const o=new three.Vector3;return o.copy(a).multiplyScalar(i),o}decomposeRotation(){const e=this.camera.quaternion,t=DEFAULT_DIRECTION.clone(),i=UP_DIRECTION.clone();return t.applyQuaternion(e),t.clampScalar(-1,1),i.applyQuaternion(e),this.decomposeRotationFromDirection(t,i)}decomposeRotationFromDirection(e,t){const i=180-three.MathUtils.radToDeg(Math.acos(e.z));let n=three.MathUtils.radToDeg(Math.atan2(e.y,e.x));return 0===e.x&&0===e.y&&(n=three.MathUtils.radToDeg(Math.atan2(t.y,t.x))),n=(n-90)%360,{heading:n,pitch:i}}setBounds(e){this.bounds=[this.projectArrayCoordinate(e[0]).map((e=>Math.ceil(e))),this.projectArrayCoordinate(e[1]).map((e=>Math.ceil(e)))]}lockDrag(e){this.control.onMouseDragging=e?()=>!1:null}updateCamera(){const e=this.camera;e.updateMatrix(),e.updateMatrixWorld();const[t,i]=this.getContainerSize();e.aspect=t/i;const n=e.position.z;let r=this.pitch+this.fov/2,s=1e6;s=n/Math.cos(three.MathUtils.degToRad(Math.min(r,89)))*1.25,e.near=Math.min(Math.max(n/1e4,.1),10),s<2e4&&(s=2e4),e.far=s,e.fov=this.fov,e.updateProjectionMatrix(),this._updateCameraLocation()}get controller(){return this.control}}new three.Vector3;class Globe extends three.Object3D{constructor(e,t){super(),this._ellipsoid=e,this._engine=t}onBeforeScenePrepareRender(e,t,i,n){}get ellipsoid(){return this._ellipsoid}}const CameraEventType={LEFT_DRAG:0,RIGHT_DRAG:1,MIDDLE_DRAG:2,WHEEL:3,PINCH:4};function returnTrue(){return!0}function destroyObject(e,t){function i(){throw new DeveloperError(t)}t=defaultValue(t,"This object was destroyed, i.e., destroy() was called.");for(const n in e)"function"==typeof e[n]&&(e[n]=i);e.isDestroyed=returnTrue}Object.freeze(CameraEventType);const KeyboardEventModifier={SHIFT:0,CTRL:1,ALT:2};function AssociativeArray(){this._array=[],this._hash={}}Object.freeze(KeyboardEventModifier),Object.defineProperties(AssociativeArray.prototype,{length:{get:function(){return this._array.length}},values:{get:function(){return this._array}}}),AssociativeArray.prototype.contains=function(e){if("string"!=typeof e&&"number"!=typeof e)throw new DeveloperError("key is required to be a string or number.");return defined$1(this._hash[e])},AssociativeArray.prototype.set=function(e,t){if("string"!=typeof e&&"number"!=typeof e)throw new DeveloperError("key is required to be a string or number.");t!==this._hash[e]&&(this.remove(e),this._hash[e]=t,this._array.push(t))},AssociativeArray.prototype.get=function(e){if("string"!=typeof e&&"number"!=typeof e)throw new DeveloperError("key is required to be a string or number.");return this._hash[e]},AssociativeArray.prototype.remove=function(e){if(defined$1(e)&&"string"!=typeof e&&"number"!=typeof e)throw new DeveloperError("key is required to be a string or number.");var t=this._hash[e],i=defined$1(t);if(i){var n=this._array;n.splice(n.indexOf(t),1),delete this._hash[e]}return i},AssociativeArray.prototype.removeAll=function(){var e=this._array;e.length>0&&(this._hash={},e.length=0)};const ScreenSpaceEventType={LEFT_DOWN:0,LEFT_UP:1,LEFT_CLICK:2,LEFT_DOUBLE_CLICK:3,RIGHT_DOWN:5,RIGHT_UP:6,RIGHT_CLICK:7,MIDDLE_DOWN:10,MIDDLE_UP:11,MIDDLE_CLICK:12,MOUSE_MOVE:15,WHEEL:16,PINCH_START:17,PINCH_END:18,PINCH_MOVE:19};function getPosition(e,t,i){var n=e._element;if(n===document)return i.x=t.clientX,i.y=t.clientY,i;var r=n.getBoundingClientRect();return i.x=t.clientX-r.left,i.y=t.clientY-r.top,i}function getInputEventKey(e,t){var i=e;return defined$1(t)&&(i+="+"+t),i}function getModifier(e){return e.shiftKey?KeyboardEventModifier.SHIFT:e.ctrlKey?KeyboardEventModifier.CTRL:e.altKey?KeyboardEventModifier.ALT:void 0}Object.freeze(ScreenSpaceEventType);const MouseButton={LEFT:0,MIDDLE:1,RIGHT:2};function registerListener(e,t,i,n){function r(t){n(e,t)}i.addEventListener(t,r,{capture:!1,passive:!1}),e._removalFunctions.push((function(){i.removeEventListener(t,r,!1)}))}function registerListeners(e){var t=e._element,i=defined$1(t.disableRootEvents)?t:document;"undefined"!=typeof PointerEvent?(registerListener(e,"pointerdown",t,handlePointerDown),registerListener(e,"pointerup",t,handlePointerUp),registerListener(e,"pointermove",t,handlePointerMove),registerListener(e,"pointercancel",t,handlePointerUp)):(registerListener(e,"mousedown",t,handleMouseDown),registerListener(e,"mouseup",i,handleMouseUp),registerListener(e,"mousemove",i,handleMouseMove),registerListener(e,"touchstart",t,handleTouchStart),registerListener(e,"touchend",i,handleTouchEnd),registerListener(e,"touchmove",i,handleTouchMove),registerListener(e,"touchcancel",i,handleTouchEnd)),registerListener(e,"dblclick",t,handleDblClick),registerListener(e,"onwheel"in t?"wheel":void 0!==document.onmousewheel?"mousewheel":"DOMMouseScroll",t,handleWheel)}function unregisterListeners(e){for(var t=e._removalFunctions,i=0;i<t.length;++i)t[i]()}var mouseDownEvent={position:new three.Vector2};function gotTouchEvent(e){e._lastSeenTouchEvent=Date.now()}function canProcessMouseEvent(e){return Date.now()-e._lastSeenTouchEvent>ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds}function checkPixelTolerance(e,t,i){var n=e.x-t.x,r=e.y-t.y;return Math.sqrt(n*n+r*r)<i}function handleMouseDown(e,t){if(canProcessMouseEvent(e)){var i,n=t.button;if(e._buttonDown[n]=!0,n===MouseButton.LEFT)i=ScreenSpaceEventType.LEFT_DOWN;else if(n===MouseButton.MIDDLE)i=ScreenSpaceEventType.MIDDLE_DOWN;else{if(n!==MouseButton.RIGHT)return;i=ScreenSpaceEventType.RIGHT_DOWN}var r=getPosition(e,t,e._primaryPosition);Cartesian2.clone(r,e._primaryStartPosition),Cartesian2.clone(r,e._primaryPreviousPosition);var s=getModifier(t),a=e.getInputAction(i,s);defined$1(a)&&(Cartesian2.clone(r,mouseDownEvent.position),mouseDownEvent.event=t,a(mouseDownEvent),t.preventDefault())}}var mouseUpEvent={position:new three.Vector2},mouseClickEvent={position:new three.Vector2};function cancelMouseEvent(e,t,i,n){var r=getModifier(n),s=e.getInputAction(t,r),a=e.getInputAction(i,r);if(defined$1(s)||defined$1(a)){var o=getPosition(e,n,e._primaryPosition);if(defined$1(s)&&(Cartesian2.clone(o,mouseUpEvent.position),mouseUpEvent.event=n,s(mouseUpEvent)),defined$1(a))checkPixelTolerance(e._primaryStartPosition,o,e._clickPixelTolerance)&&(Cartesian2.clone(o,mouseClickEvent.position),mouseClickEvent.event=n,a(mouseClickEvent))}}function handleMouseUp(e,t){if(canProcessMouseEvent(e)){var i=t.button;i!==MouseButton.LEFT&&i!==MouseButton.MIDDLE&&i!==MouseButton.RIGHT||(e._buttonDown[MouseButton.LEFT]&&(cancelMouseEvent(e,ScreenSpaceEventType.LEFT_UP,ScreenSpaceEventType.LEFT_CLICK,t),e._buttonDown[MouseButton.LEFT]=!1),e._buttonDown[MouseButton.MIDDLE]&&(cancelMouseEvent(e,ScreenSpaceEventType.MIDDLE_UP,ScreenSpaceEventType.MIDDLE_CLICK,t),e._buttonDown[MouseButton.MIDDLE]=!1),e._buttonDown[MouseButton.RIGHT]&&(cancelMouseEvent(e,ScreenSpaceEventType.RIGHT_UP,ScreenSpaceEventType.RIGHT_CLICK,t),e._buttonDown[MouseButton.RIGHT]=!1))}}var mouseMoveEvent={startPosition:new three.Vector2,endPosition:new three.Vector2};function handleMouseMove(e,t){if(canProcessMouseEvent(e)){var i=getModifier(t),n=getPosition(e,t,e._primaryPosition),r=e._primaryPreviousPosition,s=e.getInputAction(ScreenSpaceEventType.MOUSE_MOVE,i);defined$1(s)&&(Cartesian2.clone(r,mouseMoveEvent.startPosition),Cartesian2.clone(n,mouseMoveEvent.endPosition),mouseMoveEvent.event=t,s(mouseMoveEvent)),Cartesian2.clone(n,r),(e._buttonDown[MouseButton.LEFT]||e._buttonDown[MouseButton.MIDDLE]||e._buttonDown[MouseButton.RIGHT])&&t.preventDefault()}}var mouseDblClickEvent={position:new three.Vector2};function handleDblClick(e,t){var i;if(t.button===MouseButton.LEFT){i=ScreenSpaceEventType.LEFT_DOUBLE_CLICK;var n=getModifier(t),r=e.getInputAction(i,n);defined$1(r)&&(getPosition(e,t,mouseDblClickEvent.position),mouseDblClickEvent.event=t,r(mouseDblClickEvent))}}function handleWheel(e,t){var i;if(defined$1(t.deltaY)){var n=t.deltaMode;i=n===t.DOM_DELTA_PIXEL?-t.deltaY:n===t.DOM_DELTA_LINE?40*-t.deltaY:120*-t.deltaY}else i=t.detail>0?-120*t.detail:t.wheelDelta;if(defined$1(i)){var r=getModifier(t),s=e.getInputAction(ScreenSpaceEventType.WHEEL,r);defined$1(s)&&(s(i),t.preventDefault())}}function handleTouchStart(e,t){gotTouchEvent(e);var i,n,r,s=t.changedTouches,a=s.length,o=e._positions;for(i=0;i<a;++i)r=(n=s[i]).identifier,o.set(r,getPosition(e,n,new three.Vector2));fireTouchEvents(e,t);var l=e._previousPositions;for(i=0;i<a;++i)r=(n=s[i]).identifier,l.set(r,Cartesian2.clone(o.get(r)))}function handleTouchEnd(e,t){gotTouchEvent(e);var i,n,r=t.changedTouches,s=r.length,a=e._positions;for(i=0;i<s;++i)n=r[i].identifier,a.remove(n);fireTouchEvents(e,t);var o=e._previousPositions;for(i=0;i<s;++i)n=r[i].identifier,o.remove(n)}var touchStartEvent={position:new three.Vector2},touch2StartEvent={position1:new three.Vector2,position2:new three.Vector2},touchEndEvent={position:new three.Vector2},touchClickEvent={position:new three.Vector2},touchHoldEvent={position:new three.Vector2};function fireTouchEvents(e,t){var i,n,r=getModifier(t),s=e._positions,a=s.length,o=e._isPinching;if(1!==a&&e._buttonDown[MouseButton.LEFT]){if(e._buttonDown[MouseButton.LEFT]=!1,defined$1(e._touchHoldTimer)&&(clearTimeout(e._touchHoldTimer),e._touchHoldTimer=void 0),defined$1(i=e.getInputAction(ScreenSpaceEventType.LEFT_UP,r))&&(Cartesian2.clone(e._primaryPosition,touchEndEvent.position),touchEndEvent.event=t,i(touchEndEvent)),0===a&&!e._isTouchHolding)if(defined$1(n=e.getInputAction(ScreenSpaceEventType.LEFT_CLICK,r)))checkPixelTolerance(e._primaryStartPosition,e._previousPositions.values[0],e._clickPixelTolerance)&&(Cartesian2.clone(e._primaryPosition,touchClickEvent.position),touchClickEvent.event=t,n(touchClickEvent));e._isTouchHolding=!1}if(0===a&&o&&(e._isPinching=!1,defined$1(i=e.getInputAction(ScreenSpaceEventType.PINCH_END,r))&&i()),1===a&&!o){var l=s.values[0];Cartesian2.clone(l,e._primaryPosition),Cartesian2.clone(l,e._primaryStartPosition),Cartesian2.clone(l,e._primaryPreviousPosition),e._buttonDown[MouseButton.LEFT]=!0,defined$1(i=e.getInputAction(ScreenSpaceEventType.LEFT_DOWN,r))&&(Cartesian2.clone(l,touchStartEvent.position),touchStartEvent.event=t,i(touchStartEvent)),e._touchHoldTimer=setTimeout((function(){e.isDestroyed()||(e._touchHoldTimer=void 0,e._isTouchHolding=!0,defined$1(n=e.getInputAction(ScreenSpaceEventType.RIGHT_CLICK,r))&&checkPixelTolerance(e._primaryStartPosition,e._previousPositions.values[0],e._holdPixelTolerance)&&(Cartesian2.clone(e._primaryPosition,touchHoldEvent.position),touchHoldEvent.event=t,n(touchHoldEvent)))}),ScreenSpaceEventHandler.touchHoldDelayMilliseconds),t.preventDefault()}2!==a||o||(e._isPinching=!0,defined$1(i=e.getInputAction(ScreenSpaceEventType.PINCH_START,r))&&(Cartesian2.clone(s.values[0],touch2StartEvent.position1),Cartesian2.clone(s.values[1],touch2StartEvent.position2),touch2StartEvent.event=t,i(touch2StartEvent),t.preventDefault()))}function handleTouchMove(e,t){gotTouchEvent(e);var i,n,r,s=t.changedTouches,a=s.length,o=e._positions;for(i=0;i<a;++i){r=(n=s[i]).identifier;var l=o.get(r);defined$1(l)&&getPosition(e,n,l)}fireTouchMoveEvents(e,t);var c=e._previousPositions;for(i=0;i<a;++i)r=(n=s[i]).identifier,Cartesian2.clone(o.get(r),c.get(r))}var touchMoveEvent={startPosition:new three.Vector2,endPosition:new three.Vector2},touchPinchMovementEvent={distance:{startPosition:new three.Vector2,endPosition:new three.Vector2},angleAndHeight:{startPosition:new three.Vector2,endPosition:new three.Vector2}};function fireTouchMoveEvents(e,t){var i,n=getModifier(t),r=e._positions,s=e._previousPositions,a=r.length;if(1===a&&e._buttonDown[MouseButton.LEFT]){var o=r.values[0];Cartesian2.clone(o,e._primaryPosition);var l=e._primaryPreviousPosition;defined$1(i=e.getInputAction(ScreenSpaceEventType.MOUSE_MOVE,n))&&(Cartesian2.clone(l,touchMoveEvent.startPosition),Cartesian2.clone(o,touchMoveEvent.endPosition),touchMoveEvent.event=t,i(touchMoveEvent)),Cartesian2.clone(o,l),t.preventDefault()}else if(2===a&&e._isPinching&&defined$1(i=e.getInputAction(ScreenSpaceEventType.PINCH_MOVE,n))){var c=r.values[0],h=r.values[1],u=s.values[0],d=s.values[1],p=h.x-c.x,m=h.y-c.y,f=.25*Math.sqrt(p*p+m*m),g=d.x-u.x,_=d.y-u.y,A=.25*Math.sqrt(g*g+_*_),v=.125*(h.y+c.y),y=.125*(d.y+u.y),x=Math.atan2(m,p),b=Math.atan2(_,g);Cartesian2.fromElements(0,A,touchPinchMovementEvent.distance.startPosition),Cartesian2.fromElements(0,f,touchPinchMovementEvent.distance.endPosition),Cartesian2.fromElements(b,y,touchPinchMovementEvent.angleAndHeight.startPosition),Cartesian2.fromElements(x,v,touchPinchMovementEvent.angleAndHeight.endPosition),touchPinchMovementEvent.event=t,i(touchPinchMovementEvent)}}function handlePointerDown(e,t){if(t.target.setPointerCapture(t.pointerId),"touch"===t.pointerType){var i=e._positions,n=t.pointerId;i.set(n,getPosition(e,t,new three.Vector2)),fireTouchEvents(e,t),e._previousPositions.set(n,Cartesian2.clone(i.get(n)))}else handleMouseDown(e,t)}function handlePointerUp(e,t){if("touch"===t.pointerType){var i=e._positions,n=t.pointerId;i.remove(n),fireTouchEvents(e,t),e._previousPositions.remove(n)}else handleMouseUp(e,t)}function handlePointerMove(e,t){if("touch"===t.pointerType){var i=e._positions,n=t.pointerId,r=i.get(n);if(!defined$1(r))return;getPosition(e,t,r),fireTouchMoveEvents(e,t);var s=e._previousPositions;Cartesian2.clone(i.get(n),s.get(n))}else handleMouseMove(e,t)}function ScreenSpaceEventHandler(e){this._inputEvents={},this._buttonDown={LEFT:!1,MIDDLE:!1,RIGHT:!1},this._isPinching=!1,this._isTouchHolding=!1,this._lastSeenTouchEvent=-ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds,this._primaryStartPosition=new three.Vector2,this._primaryPosition=new three.Vector2,this._primaryPreviousPosition=new three.Vector2,this._positions=new AssociativeArray,this._previousPositions=new AssociativeArray,this._removalFunctions=[],this._touchHoldTimer=void 0,this._clickPixelTolerance=5,this._holdPixelTolerance=25,this._element=defaultValue(e,document),registerListeners(this)}function getKey(e,t){let i=e;return defined$1(t)&&(i+="+"+t),i}function clonePinchMovement(e,t){Cartesian2.clone(e.distance.startPosition,t.distance.startPosition),Cartesian2.clone(e.distance.endPosition,t.distance.endPosition),Cartesian2.clone(e.angleAndHeight.startPosition,t.angleAndHeight.startPosition),Cartesian2.clone(e.angleAndHeight.endPosition,t.angleAndHeight.endPosition)}function listenToPinch(e,t,i){const n=getKey(CameraEventType.PINCH,t),r=e._update,s=e._isDown,a=e._eventStartPosition,o=e._pressTime,l=e._releaseTime;r[n]=!0,s[n]=!1,a[n]=new three.Vector2;let c=e._movement[n];defined$1(c)||(c=e._movement[n]={}),c.distance={startPosition:new three.Vector2,endPosition:new three.Vector2},c.angleAndHeight={startPosition:new three.Vector2,endPosition:new three.Vector2},c.prevAngle=0,e._eventHandler.setInputAction((function(t){e._buttonsDown++,s[n]=!0,o[n]=new Date,Cartesian2.lerp(t.position1,t.position2,.5,a[n]),e._rendering.requestRender()}),ScreenSpaceEventType.PINCH_START,t),e._eventHandler.setInputAction((function(){e._buttonsDown=Math.max(e._buttonsDown-1,0),s[n]=!1,l[n]=new Date,e._rendering.requestRender()}),ScreenSpaceEventType.PINCH_END,t),e._eventHandler.setInputAction((function(t){if(s[n]){r[n]?(clonePinchMovement(t,c),r[n]=!1,c.prevAngle=c.angleAndHeight.startPosition.x):(Cartesian2.clone(t.distance.endPosition,c.distance.endPosition),Cartesian2.clone(t.angleAndHeight.endPosition,c.angleAndHeight.endPosition));let s=c.angleAndHeight.endPosition.x;const a=c.prevAngle,o=2*Math.PI;for(;s>=a+Math.PI;)s-=o;for(;s<a-Math.PI;)s+=o;c.angleAndHeight.endPosition.x=-s*i.clientWidth/12,c.angleAndHeight.startPosition.x=-a*i.clientWidth/12,e._rendering.requestRender()}}),ScreenSpaceEventType.PINCH_MOVE,t)}function listenToWheel(e,t){const i=getKey(CameraEventType.WHEEL,t),n=e._pressTime,r=e._releaseTime,s=e._update;s[i]=!0;let a=e._movement[i];defined$1(a)||(a=e._movement[i]={});let o=e._lastMovement[i];defined$1(o)||(o=e._lastMovement[i]={startPosition:new three.Vector2,endPosition:new three.Vector2,valid:!1}),a.startPosition=new three.Vector2,Cartesian2.clone(Cartesian2.ZERO,a.startPosition),a.endPosition=new three.Vector2,e._eventHandler.setInputAction((function(t){const l=7.5*CesiumMath.toRadians(t);n[i]=r[i]=new Date,a.endPosition.x=0,a.endPosition.y=l,Cartesian2.clone(a.endPosition,o.endPosition),o.valid=!0,s[i]=!1,e._rendering.requestRender()}),ScreenSpaceEventType.WHEEL,t)}function listenMouseButtonDownUp(e,t,i){const n=getKey(i,t),r=e._isDown,s=e._eventStartPosition,a=e._pressTime,o=e._releaseTime;r[n]=!1,s[n]=new three.Vector2;let l,c,h=e._lastMovement[n];defined$1(h)||(h=e._lastMovement[n]={startPosition:new three.Vector2,endPosition:new three.Vector2,valid:!1}),i===CameraEventType.LEFT_DRAG?(l=ScreenSpaceEventType.LEFT_DOWN,c=ScreenSpaceEventType.LEFT_UP):i===CameraEventType.RIGHT_DRAG?(l=ScreenSpaceEventType.RIGHT_DOWN,c=ScreenSpaceEventType.RIGHT_UP):i===CameraEventType.MIDDLE_DRAG&&(l=ScreenSpaceEventType.MIDDLE_DOWN,c=ScreenSpaceEventType.MIDDLE_UP),e._eventHandler.setInputAction((function(t){e._buttonsDown++,h.valid=!1,r[n]=!0,a[n]=new Date,Cartesian2.clone(t.position,s[n]),t&&e.onEventPointerDown&&e.onEventPointerDown(t)}),l,t),e._eventHandler.setInputAction((function(t){e._buttonsDown=Math.max(e._buttonsDown-1,0),r[n]=!1,o[n]=new Date,t&&e.onEventPointerUp&&e.onEventPointerUp(t),e._rendering.requestRender()}),c,t)}function cloneMouseMovement(e,t){Cartesian2.clone(e.startPosition,t.startPosition),Cartesian2.clone(e.endPosition,t.endPosition)}function listenMouseMove(e,t){const i=e._update,n=e._movement,r=e._lastMovement,s=e._isDown;for(const a in CameraEventType)if(CameraEventType.hasOwnProperty(a)){const n=CameraEventType[a];if(defined$1(n)){const r=getKey(n,t);i[r]=!0,defined$1(e._lastMovement[r])||(e._lastMovement[r]={startPosition:new three.Vector2,endPosition:new three.Vector2,valid:!1}),defined$1(e._movement[r])||(e._movement[r]={startPosition:new three.Vector2,endPosition:new three.Vector2})}}e._eventHandler.setInputAction((function(a){for(const o in CameraEventType)if(CameraEventType.hasOwnProperty(o)){const l=CameraEventType[o];if(defined$1(l)){const o=getKey(l,t);s[o]?(i[o]?(cloneMouseMovement(n[o],r[o]),r[o].valid=!0,cloneMouseMovement(a,n[o]),i[o]=!1):Cartesian2.clone(a.endPosition,n[o].endPosition),e._rendering.requestRender()):e.onEventMouseMove&&e.onEventMouseMove(a)}}Cartesian2.clone(a.endPosition,e._currentMousePosition)}),ScreenSpaceEventType.MOUSE_MOVE,t)}function listenMouseClick(e,t){e._eventHandler.setInputAction((function(t){t&&e.onEventClick&&e.onEventClick(t),e._rendering.requestRender()}),ScreenSpaceEventType.LEFT_CLICK,t),e._eventHandler.setInputAction((function(t){t&&e.onEventClick&&e.onEventClick(t),e._rendering.requestRender()}),ScreenSpaceEventType.RIGHT_CLICK,t),e._eventHandler.setInputAction((function(t){t&&e.onEventDblClick&&e.onEventDblClick(t),e._rendering.requestRender()}),ScreenSpaceEventType.LEFT_DOUBLE_CLICK,t)}function CameraEventAggregator(e,t){if(!defined$1(e))throw new DeveloperError("canvas is required.");this._eventHandler=new ScreenSpaceEventHandler(e),this._rendering=t,this._update={},this._movement={},this._lastMovement={},this._isDown={},this._eventStartPosition={},this._pressTime={},this._releaseTime={},this._buttonsDown=0,this._currentMousePosition=new three.Vector2,listenToWheel(this,void 0),listenToPinch(this,void 0,e),listenMouseButtonDownUp(this,void 0,CameraEventType.LEFT_DRAG),listenMouseButtonDownUp(this,void 0,CameraEventType.RIGHT_DRAG),listenMouseButtonDownUp(this,void 0,CameraEventType.MIDDLE_DRAG),listenMouseMove(this,void 0),listenMouseClick(this,void 0);for(const i in KeyboardEventModifier)if(KeyboardEventModifier.hasOwnProperty(i)){const t=KeyboardEventModifier[i];defined$1(t)&&(listenToWheel(this,t),listenToPinch(this,t,e),listenMouseButtonDownUp(this,t,CameraEventType.LEFT_DRAG),listenMouseButtonDownUp(this,t,CameraEventType.RIGHT_DRAG),listenMouseButtonDownUp(this,t,CameraEventType.MIDDLE_DRAG),listenMouseMove(this,t),listenMouseClick(this,t))}}ScreenSpaceEventHandler.prototype.setInputAction=function(e,t,i){if(!defined$1(e))throw new DeveloperError("action is required.");if(!defined$1(t))throw new DeveloperError("type is required.");var n=getInputEventKey(t,i);this._inputEvents[n]=e},ScreenSpaceEventHandler.prototype.getInputAction=function(e,t){if(!defined$1(e))throw new DeveloperError("type is required.");var i=getInputEventKey(e,t);return this._inputEvents[i]},ScreenSpaceEventHandler.prototype.removeInputAction=function(e,t){if(!defined$1(e))throw new DeveloperError("type is required.");var i=getInputEventKey(e,t);delete this._inputEvents[i]},ScreenSpaceEventHandler.prototype.isDestroyed=function(){return!1},ScreenSpaceEventHandler.prototype.destroy=function(){return unregisterListeners(this),destroyObject(this)},ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds=800,ScreenSpaceEventHandler.touchHoldDelayMilliseconds=1500,Object.defineProperties(CameraEventAggregator.prototype,{currentMousePosition:{get:function(){return this._currentMousePosition}},anyButtonDown:{get:function(){const e=!(this._update[getKey(CameraEventType.WHEEL)]&&this._update[getKey(CameraEventType.WHEEL,KeyboardEventModifier.SHIFT)]&&this._update[getKey(CameraEventType.WHEEL,KeyboardEventModifier.CTRL)]&&this._update[getKey(CameraEventType.WHEEL,KeyboardEventModifier.ALT)]);return this._buttonsDown>0||e}}}),CameraEventAggregator.prototype.isMoving=function(e,t){const i=getKey(e,t);return!this._update[i]},CameraEventAggregator.prototype.getMovement=function(e,t){const i=getKey(e,t);return this._movement[i]},CameraEventAggregator.prototype.getLastMovement=function(e,t){const i=getKey(e,t),n=this._lastMovement[i];if(n.valid)return n},CameraEventAggregator.prototype.isButtonDown=function(e,t){const i=getKey(e,t);return this._isDown[i]},CameraEventAggregator.prototype.getStartMousePosition=function(e,t){if(e===CameraEventType.WHEEL)return this._currentMousePosition;const i=getKey(e,t);return this._eventStartPosition[i]},CameraEventAggregator.prototype.getButtonPressTime=function(e,t){const i=getKey(e,t);return this._pressTime[i]},CameraEventAggregator.prototype.getButtonReleaseTime=function(e,t){const i=getKey(e,t);return this._releaseTime[i]},CameraEventAggregator.prototype.reset=function(){for(const e in this._update)this._update.hasOwnProperty(e)&&(this._update[e]=!0)},CameraEventAggregator.prototype.isDestroyed=function(){return!1},CameraEventAggregator.prototype.destroy=function(){return this._eventHandler=this._eventHandler&&this._eventHandler.destroy(),destroyObject(this)};var TerrainExaggeration={};function HeadingPitchRoll(e,t,i){this.heading=defaultValue(e,0),this.pitch=defaultValue(t,0),this.roll=defaultValue(i,0)}TerrainExaggeration.getHeight=function(e,t,i){return(e-i)*t+i},HeadingPitchRoll.fromQuaternion=function(e,t){if(!defined$1(e))throw new DeveloperError("quaternion is required");defined$1(t)||(t=new HeadingPitchRoll);const i=2*(e.w*e.y-e.z*e.x),n=1-2*(e.x*e.x+e.y*e.y),r=2*(e.w*e.x+e.y*e.z),s=1-2*(e.y*e.y+e.z*e.z),a=2*(e.w*e.z+e.x*e.y);return t.heading=-Math.atan2(a,s),t.roll=Math.atan2(r,n),t.pitch=-CesiumMath.asinClamped(i),t},HeadingPitchRoll.fromDegrees=function(e,t,i,n){if(!defined$1(e))throw new DeveloperError("heading is required");if(!defined$1(t))throw new DeveloperError("pitch is required");if(!defined$1(i))throw new DeveloperError("roll is required");return defined$1(n)||(n=new HeadingPitchRoll),n.heading=e*CesiumMath.RADIANS_PER_DEGREE,n.pitch=t*CesiumMath.RADIANS_PER_DEGREE,n.roll=i*CesiumMath.RADIANS_PER_DEGREE,n},HeadingPitchRoll.clone=function(e,t){if(defined$1(e))return defined$1(t)?(t.heading=e.heading,t.pitch=e.pitch,t.roll=e.roll,t):new HeadingPitchRoll(e.heading,e.pitch,e.roll)},HeadingPitchRoll.equals=function(e,t){return e===t||defined$1(e)&&defined$1(t)&&e.heading===t.heading&&e.pitch===t.pitch&&e.roll===t.roll},HeadingPitchRoll.equalsEpsilon=function(e,t,i,n){return e===t||defined$1(e)&&defined$1(t)&&CesiumMath.equalsEpsilon(e.heading,t.heading,i,n)&&CesiumMath.equalsEpsilon(e.pitch,t.pitch,i,n)&&CesiumMath.equalsEpsilon(e.roll,t.roll,i,n)},HeadingPitchRoll.prototype.clone=function(e){return HeadingPitchRoll.clone(this,e)},HeadingPitchRoll.prototype.equals=function(e){return HeadingPitchRoll.equals(this,e)},HeadingPitchRoll.prototype.equalsEpsilon=function(e,t,i){return HeadingPitchRoll.equalsEpsilon(this,e,t,i)},HeadingPitchRoll.prototype.toString=function(){return`(${this.heading}, ${this.pitch}, ${this.roll})`};const SceneTransforms={},actualPositionScratch=new three.Vector4(0,0,0,1),scratchViewport={x:0,y:0,width:0,height:0};new three.Vector3(Math.PI,CesiumMath.PI_OVER_TWO);let positionCC=new three.Vector4(0,0,0,0);new three.Vector3;const scratchCartesian4=new three.Vector4(0,0,0,0),scratchEyeOffset=new three.Vector3;function worldToClip(e,t,i,n){const r=i.viewMatrix,s=StaticMatrix4.multiplyByVector(r,Cartesian4.fromElements(e.x,e.y,e.z,1,scratchCartesian4),scratchCartesian4),a=Cartesian3.multiplyComponents(t,Cartesian3.normalize(s,scratchEyeOffset),scratchEyeOffset);return s.x+=t.x+a.x,s.y+=t.y+a.y,s.z+=a.z,StaticMatrix4.multiplyByVector(i.frustum.projectionMatrix,s,n)}SceneTransforms.computeActualEllipsoidPosition=function(e,t,i){if(e.mode===SceneMode$1.SCENE3D)return Cartesian3.clone(t,i)},SceneTransforms.worldToWindowCoordinates=function(e,t,i){return SceneTransforms.worldWithEyeOffsetToWindowCoordinates(e,t,Cartesian3.ZERO,i)},SceneTransforms.worldWithEyeOffsetToWindowCoordinates=function(e,t,i,n){if(!defined$1(e))throw new DeveloperError("scene is required.");if(!defined$1(t))throw new DeveloperError("position is required.");const r=SceneTransforms.computeActualEllipsoidPosition(e,t,actualPositionScratch);if(!defined$1(r))return;const s=e.canvas,a=scratchViewport;a.x=0,a.y=0,a.width=s.clientWidth,a.height=s.clientHeight;const o=e.camera;if(e.mode,SceneMode$1.SCENE2D,e.mode!==SceneMode$1.SCENE2D){if(positionCC=worldToClip(r,i,o,positionCC),positionCC.z<0)return;n=SceneTransforms.clipToGLWindowCoordinates(a,positionCC,n)}return n.y=s.clientHeight-n.y,n};const positionNDC=new three.Vector3,positionWC=new three.Vector3,viewportTransform=new three.Matrix4;function ScreenSpaceCameraController(e){if(!defined$1(e))throw new DeveloperError("scene is required.");this.enableInputs=!0,this.enableTranslate=!0,this.enableZoom=!0,this.enableRotate=!0,this.enableTilt=!0,this.enableLook=!0,this.enableFixCenter=!1,this.enableTerrainCollision=!1,this.inertiaSpin=.9,this.inertiaTranslate=.9,this.inertiaZoom=.8,this.maximumMovementRatio=.1,this.bounceAnimationTime=3,this.minimumZoomDistance=1,this.maximumZoomDistance=Number.POSITIVE_INFINITY,this.translateEventTypes=CameraEventType.LEFT_DRAG,this.zoomEventTypes=[CameraEventType.MIDDLE_DRAG,CameraEventType.WHEEL,CameraEventType.PINCH],this.rotateEventTypes=CameraEventType.LEFT_DRAG,this.tiltEventTypes=[CameraEventType.RIGHT_DRAG,CameraEventType.PINCH,{eventType:CameraEventType.LEFT_DRAG,modifier:KeyboardEventModifier.CTRL},{eventType:CameraEventType.RIGHT_DRAG,modifier:KeyboardEventModifier.CTRL}],this.lookEventTypes={eventType:CameraEventType.LEFT_DRAG,modifier:KeyboardEventModifier.SHIFT},this.minimumPickingTerrainHeight=15e4,this._minimumPickingTerrainHeight=this.minimumPickingTerrainHeight,this.minimumPickingTerrainDistanceWithInertia=4e3,this.minimumCollisionTerrainHeight=15e3,this._minimumCollisionTerrainHeight=this.minimumCollisionTerrainHeight,this.minimumTrackBallHeight=75e5,this._minimumTrackBallHeight=this.minimumTrackBallHeight,this.enableCollisionDetection=!0,this._scene=e,this._globe=void 0,this._ellipsoid=void 0,this._lastGlobeHeight=0,this._aggregator=new CameraEventAggregator(e.canvas,e.rendering),this._lastInertiaSpinMovement=void 0,this._lastInertiaZoomMovement=void 0,this._lastInertiaTranslateMovement=void 0,this._lastInertiaTiltMovement=void 0,this._inertiaDisablers={_lastInertiaZoomMovement:["_lastInertiaSpinMovement","_lastInertiaTranslateMovement","_lastInertiaTiltMovement"],_lastInertiaTiltMovement:["_lastInertiaSpinMovement","_lastInertiaTranslateMovement"]},this._horizontalRotationAxis=void 0,this._tiltCenterMousePosition=new three.Vector2(-1,-1),this._tiltCenter=new three.Vector3,this._translateMousePosition=new three.Vector2,this._rotateMousePosition=new three.Vector2(-1,-1),this._rotateStartPosition=new three.Vector3,this._strafeStartPosition=new three.Vector3,this._strafeMousePosition=new three.Vector2,this._strafeEndMousePosition=new three.Vector2,this._zoomMouseStart=new three.Vector2(-1,-1),this._zoomWorldPosition=new three.Vector3,this._useZoomWorldPosition=!1,this._panLastMousePosition=new three.Vector2,this._panLastWorldPosition=new three.Vector3,this._tiltCVOffMap=!1,this._looking=!1,this._rotating=!1,this._strafing=!1,this._zoomingOnVector=!1,this._zoomingUnderground=!1,this._rotatingZoom=!1,this._adjustedHeightForTerrain=!1,this._cameraUnderground=!1;const t=e.mapProjection;this._maxCoord=t.project(new three.Vector3(Math.PI,CesiumMath.PI_OVER_TWO)),this._zoomFactor=5,this._rotateFactor=void 0,this._rotateRateRangeAdjustment=void 0,this._maximumRotateRate=1.77,this._minimumRotateRate=2e-4,this._minimumZoomRate=20,this._maximumZoomRate=5906376272e3,this._minimumUndergroundPickDistance=2e3,this._maximumUndergroundPickDistance=1e4,Object.defineProperties(this,{enabled:{get:function(){return this.enableInputs},set:function(e){this.enableInputs=e}},enablePan:{get:function(){return this.enableTranslate},set:function(e){this.enableTranslate=e}},inertiaDragging:{get:function(){return this.inertiaSpin},set:function(e){this.inertiaSpin=e}}})}function decay(e,t){if(e<0)return 0;const i=25*(1-t);return Math.exp(-i*e)}function sameMousePosition(e){return Cartesian2.equalsEpsilon(e.startPosition,e.endPosition,CesiumMath.EPSILON14)}SceneTransforms.clipToGLWindowCoordinates=function(e,t,i){return Cartesian3.divideByScalar(t,t.w,positionNDC),StaticMatrix4.computeViewportTransformation(e,0,1,viewportTransform),StaticMatrix4.multiplyByPoint(viewportTransform,positionNDC,positionWC),Cartesian2.fromCartesian3(positionWC,i)};const inertiaMaxClickTimeThreshold=.4;function maintainInertia(e,t,i,n,r,s,a){let o=s[a];defined$1(o)||(o=s[a]={startPosition:new three.Vector2,endPosition:new three.Vector2,motion:new three.Vector2,inertiaEnabled:!0});const l=e.getButtonPressTime(t,i),c=e.getButtonReleaseTime(t,i),h=l&&c&&(c.getTime()-l.getTime())/1e3,u=new Date,d=c&&(u.getTime()-c.getTime())/1e3;if(l&&c&&h<inertiaMaxClickTimeThreshold){const a=decay(d,n),l=e.getLastMovement(t,i);if(!defined$1(l)||sameMousePosition(l)||!o.inertiaEnabled)return;if(o.motion.x=.5*(l.endPosition.x-l.startPosition.x),o.motion.y=.5*(l.endPosition.y-l.startPosition.y),o.startPosition=Cartesian2.clone(l.startPosition,o.startPosition),o.endPosition=Cartesian2.multiplyByScalar(o.motion,a,o.endPosition),o.endPosition=Cartesian2.add(o.startPosition,o.endPosition,o.endPosition),isNaN(o.endPosition.x)||isNaN(o.endPosition.y)||Cartesian2.distance(o.startPosition,o.endPosition)<.5)return;if(!e.isButtonDown(t,i)){r(s,e.getStartMousePosition(t,i),o)}}}function activateInertia(e,t){if(defined$1(t)){let i=e[t];defined$1(i)&&(i.inertiaEnabled=!0);const n=e._inertiaDisablers[t];if(defined$1(n)){const t=n.length;for(let r=0;r<t;++r)i=e[n[r]],defined$1(i)&&(i.inertiaEnabled=!1)}}}const scratchEventTypeArray=[];function reactToInput(e,t,i,n,r,s){if(!defined$1(i))return;const a=e._aggregator;Array.isArray(i)||(scratchEventTypeArray[0]=i,i=scratchEventTypeArray);const o=i.length;for(let l=0;l<o;++l){const o=i[l],c=defined$1(o.eventType)?o.eventType:o,h=o.modifier,u=a.isMoving(c,h)&&a.getMovement(c,h),d=a.getStartMousePosition(c,h);e.enableInputs&&t&&(u?(n(e,d,u),activateInertia(e,s)):r<1&&maintainInertia(a,c,h,r,n,e,s))}}const scratchZoomPickRay=new three.Ray,scratchPickCartesian=new three.Vector3,scratchZoomOffset=new three.Vector2,scratchZoomDirection=new three.Vector3,scratchCenterPixel=new three.Vector2,scratchCenterPosition=new three.Vector3,scratchPositionNormal$1=new three.Vector3,scratchPickNormal=new three.Vector3,scratchZoomAxis=new three.Vector3,scratchCameraPositionNormal=new three.Vector3,scratchTargetNormal=new three.Vector3,scratchCameraPosition=new three.Vector3,scratchCameraUpNormal=new three.Vector3,scratchCameraRightNormal=new three.Vector3,scratchForwardNormal=new three.Vector3,scratchPositionToTarget=new three.Vector3,scratchPositionToTargetNormal=new three.Vector3,scratchPan=new three.Vector3,scratchCenterMovement=new three.Vector3,scratchCenter$2=new three.Vector3,scratchCartesian$3=new three.Vector3,scratchCartesianTwo=new three.Vector3,scratchCartesianThree=new three.Vector3,scratchZoomViewOptions={orientation:new HeadingPitchRoll},scratchPosition$1=new three.Vector3;function zoomPitchDown(e,t,i){if(!t.enableFixCenter)return;const n=e.position.length(),r=CesiumMath.asinClamped(Ellipsoid.WGS84.maximumRadius/n),s=Math.cos(r)*n,a=r-e.position.clone().normalize().negate().angleTo(e.directionWC),o=Math.tan(a)*s,l=Math.cos(a)*o,c=Math.sin(a)*o,h=s/Math.cos(a)-c,u=three.MathUtils.degToRad(t._scene.rendering.camera.fov)/2-Math.atan(l/h);if(u<0)return;let d=n-.85*t._minimumTrackBallHeight;if(d<0)return;const p=5e6;d=three.MathUtils.clamp(d,0,p);const m=.1+.3*(1-d/p);let f=Math.max(i,.1);Cartesian3.negate(e.position,scratchPosition$1);const g=scratchPosition$1.normalize(),_=Cartesian3.dot(g,e.directionWC);let A=CesiumMath.acosClamped(_);A>.1&&(A=u-m/3),A*=f,A<0||(e.rotateAroundPoint(t._zoomWorldPosition,e.right,A),scratchZoomViewOptions.orientation.pitch-=A)}async function handleZoom(e,t,i,n,r,s){let a=1;defined$1(s)&&(a=CesiumMath.clamp(Math.abs(s),.25,1));const o=i.endPosition.y-i.startPosition.y,l=o>0?e.minimumZoomDistance*a:0,c=e.maximumZoomDistance;let h=n*(r-l);h=CesiumMath.clamp(h,e._minimumZoomRate,e._maximumZoomRate);let u=o/e._scene.canvas.clientHeight;u=Math.min(u,e.maximumMovementRatio);let d=h*u;if(e.enableCollisionDetection||0===e.minimumZoomDistance||!defined$1(e._globe)){if(d>0&&Math.abs(r-l)<1)return;if(d<0&&Math.abs(r-c)<1)return;r-d<l?d=r-l-1:r-d>c&&(d=r-c)}const p=e._scene,m=p.camera,f=p.mode;if(e.enableFixCenter&&m.positionWC.length()>6317e4&&o<0)return;const g=scratchZoomViewOptions.orientation;g.heading=m.heading,g.pitch=m.pitch,g.roll=m.roll;const _=defaultValue(i.inertiaEnabled,Cartesian2.equals(t,e._zoomMouseStart));let A,v=e._zoomingOnVector,y=e._rotatingZoom;if(_||(e._zoomMouseStart=Cartesian2.clone(t,e._zoomMouseStart),defined$1(e._globe)&&f===SceneMode.SCENE2D?(A=m.getPickRay(t,scratchZoomPickRay).origin,A=Cartesian3.fromElements(A.y,A.z,A.x)):defined$1(e._globe)&&(A=await pickPosition(e,t,scratchPickCartesian)),defined$1(A)?(e._useZoomWorldPosition=!0,e._zoomWorldPosition=Cartesian3.clone(A,e._zoomWorldPosition)):e._useZoomWorldPosition=!1,v=e._zoomingOnVector=!1,y=e._rotatingZoom=!1,e._zoomingUnderground=e._cameraUnderground),!e._useZoomWorldPosition)return f===SceneMode.SCENE3D&&d<0&&zoomPitchDown(m,e,d),void m.zoomIn(d);let x=f===SceneMode.COLUMBUS_VIEW;if(m.positionCartographic.z<2e6&&(y=!0),!_||y){if(f===SceneMode.SCENE2D){const i=e._zoomWorldPosition,n=m.position;if(!Cartesian3.equals(i,n)&&m.positionCartographic.z<2*e._maxCoord.x){const r=m.position.x,s=Cartesian3.subtract(i,n,scratchZoomDirection);Cartesian3.normalize(s,s);const a=Cartesian3.distance(i,n)*d/(.5*m.getMagnitude());m.move(s,.5*a),(m.position.x<0&&r>0||m.position.x>0&&r<0)&&(A=m.getPickRay(t,scratchZoomPickRay).origin,A=Cartesian3.fromElements(A.y,A.z,A.x),e._zoomWorldPosition=Cartesian3.clone(A,e._zoomWorldPosition))}}else if(f===SceneMode.SCENE3D){const t=Cartesian3.normalize(m.position,scratchCameraPositionNormal);if(e._cameraUnderground||e._zoomingUnderground||m.positionCartographic.z<3e3&&Math.abs(Cartesian3.dot(m.direction,t))<.6)x=!0;else{const i=p.canvas,n=scratchCenterPixel;n.x=i.clientWidth/2,n.y=i.clientHeight/2;const r=await pickPosition(e,n,scratchCenterPosition);if(defined$1(r))if(m.positionCartographic.z<1e6){if(!(Cartesian3.dot(m.direction,t)>=-.5)){const i=scratchCameraPosition;Cartesian3.clone(m.position,i);const n=e._zoomWorldPosition;let r=scratchTargetNormal;if(r=Cartesian3.normalize(n,r),Cartesian3.dot(r,t)<0)return;const s=scratchCenter$2,a=scratchForwardNormal;Cartesian3.clone(m.direction,a),Cartesian3.add(i,Cartesian3.multiplyByScalar(a,1e3,scratchCartesian$3),s);const o=scratchPositionToTarget,l=scratchPositionToTargetNormal;Cartesian3.subtract(n,i,o),Cartesian3.normalize(o,l);const c=Cartesian3.dot(t,l);if(c>=0)return void(e._zoomMouseStart.x=-1);const h=Math.acos(-c),u=Cartesian3.magnitude(i),p=Cartesian3.magnitude(n),g=u-d,_=Cartesian3.magnitude(o),A=Math.asin(CesiumMath.clamp(_/p*Math.sin(h),-1,1))-Math.asin(CesiumMath.clamp(g/p*Math.sin(h),-1,1))+h,v=scratchCameraUpNormal;Cartesian3.normalize(i,v);let y=scratchCameraRightNormal;y=Cartesian3.cross(l,v,y),y=Cartesian3.normalize(y,y),Cartesian3.normalize(Cartesian3.cross(v,y,scratchCartesian$3),a),Cartesian3.multiplyByScalar(Cartesian3.normalize(s,scratchCartesian$3),Cartesian3.magnitude(s)-d,s),Cartesian3.normalize(i,i),Cartesian3.multiplyByScalar(i,g,i);const x=scratchPan;Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(v,Math.cos(A)-1,scratchCartesianTwo),Cartesian3.multiplyByScalar(a,Math.sin(A),scratchCartesianThree),scratchCartesian$3),g,x),Cartesian3.add(i,x,i),Cartesian3.normalize(s,v),Cartesian3.normalize(Cartesian3.cross(v,y,scratchCartesian$3),a);const b=scratchCenterMovement;return Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(v,Math.cos(A)-1,scratchCartesianTwo),Cartesian3.multiplyByScalar(a,Math.sin(A),scratchCartesianThree),scratchCartesian$3),Cartesian3.magnitude(s),b),Cartesian3.add(s,b,s),Cartesian3.clone(i,m.position),Cartesian3.normalize(Cartesian3.subtract(s,i,scratchCartesian$3),m.direction),Cartesian3.clone(m.direction,m.direction),Cartesian3.cross(m.direction,m.up,m.right),Cartesian3.cross(m.right,m.direction,m.up),f===SceneMode.SCENE3D&&d<0&&zoomPitchDown(m,e,d),void m.setView(scratchZoomViewOptions)}x=!0}else{const t=Cartesian3.normalize(r,scratchPositionNormal$1),i=Cartesian3.normalize(e._zoomWorldPosition,scratchPickNormal),n=Cartesian3.dot(i,t);if(n>0&&n<1){const e=CesiumMath.acosClamped(n),r=Cartesian3.cross(i,t,scratchZoomAxis),s=d/(2*(Math.abs(e)>CesiumMath.toRadians(20)?.75*m.positionCartographic.z:m.positionCartographic.z-d));m.rotate(r,e*s)}}else x=!0}}e._rotatingZoom=!x}if(!_&&x||v){let i;const n=SceneTransforms.worldToWindowCoordinates(p,e._zoomWorldPosition,scratchZoomOffset);i=f!==SceneMode.COLUMBUS_VIEW&&Cartesian2.equals(t,e._zoomMouseStart)&&defined$1(n)?m.getPickRay(n,scratchZoomPickRay):m.getPickRay(t,scratchZoomPickRay);const r=i.direction;f!==SceneMode.COLUMBUS_VIEW&&f!==SceneMode.SCENE2D||Cartesian3.fromElements(r.y,r.z,r.x,r),m.move(r,d),e._zoomingOnVector=!0}else m.zoomIn(d);f===SceneMode.SCENE3D&&d<0&&zoomPitchDown(m,e,d),e._cameraUnderground||m.setView(scratchZoomViewOptions)}const translate2DStart=new three.Ray,translate2DEnd=new three.Ray,scratchTranslateP0=new three.Vector3;function translate2D(e,t,i){const n=e._scene.camera;let r=n.getPickRay(i.startPosition,translate2DStart).origin,s=n.getPickRay(i.endPosition,translate2DEnd).origin;r=Cartesian3.fromElements(r.y,r.z,r.x,r),s=Cartesian3.fromElements(s.y,s.z,s.x,s);const a=Cartesian3.subtract(r,s,scratchTranslateP0),o=Cartesian3.magnitude(a);o>0&&(Cartesian3.normalize(a,a),n.move(a,o))}async function zoom2D(e,t,i){defined$1(i.distance)&&(i=i.distance);const n=e._scene.camera;await handleZoom(e,t,i,e._zoomFactor,n.getMagnitude())}function update2D(e){StaticMatrix4.equals(StaticMatrix4.IDENTITY,e._scene.camera.transform)?(reactToInput(e,e.enableTranslate,e.translateEventTypes,translate2D,e.inertiaTranslate,"_lastInertiaTranslateMovement"),reactToInput(e,e.enableZoom,e.zoomEventTypes,zoom2D,e.inertiaZoom,"_lastInertiaZoomMovement")):reactToInput(e,e.enableZoom,e.zoomEventTypes,zoom2D,e.inertiaZoom,"_lastInertiaZoomMovement")}new three.Vector2,new three.Vector2;const pickGlobeScratchRay=new three.Ray;async function pickPosition(e,t,i){const n=e._scene;let r=await n.rendering.picking.pickWorldPosition(t);return r?(Cartesian3.clone(r,i),i):null}new three.Vector3,new three.Vector3;const scratchDistanceCartographic=new three.Vector3;function getDistanceFromSurface(e){const t=e._ellipsoid,i=e._scene,n=i.camera;let r=0;if(i.mode===SceneMode.SCENE3D){const e=t.cartesianToCartographic(n.position,scratchDistanceCartographic);defined$1(e)&&(r=e.z)}else r=n.position.z;const s=defaultValue(e._scene.globeHeight,0);return Math.abs(s-r)}const scratchSurfaceNormal=new three.Vector3;function getZoomDistanceUnderground(e,t){const i=t.origin,n=t.direction,r=getDistanceFromSurface(e),s=Cartesian3.normalize(i,scratchSurfaceNormal);let a=Math.abs(Cartesian3.dot(s,n));return a=2*Math.max(a,.5),r*a}function getTiltCenterUnderground(e,t,i,n){let r=Cartesian3.distance(t.origin,i);const s=getDistanceFromSurface(e);return r>CesiumMath.clamp(5*s,e._minimumUndergroundPickDistance,e._maximumUndergroundPickDistance)&&(r=Math.min(r,s/5),r=Math.max(r,100)),StaticRay.getPoint(t,r,n)}function getStrafeStartPositionUnderground(e,t,i,n){let r;return defined$1(i)?(r=Cartesian3.distance(t.origin,i),r>e._maximumUndergroundPickDistance&&(r=getDistanceFromSurface(e))):r=getDistanceFromSurface(e),StaticRay.getPoint(t,r,n)}const scratchInertialDelta=new three.Vector2;function continueStrafing(e,t){const i=t.endPosition,n=Cartesian2.subtract(t.endPosition,t.startPosition,scratchInertialDelta),r=e._strafeEndMousePosition;Cartesian2.add(r,n,r),t.endPosition=r,strafe(e,t,e._strafeStartPosition),t.endPosition=i}const translateCVStartRay=new three.Ray,translateCVEndRay=new three.Ray,translateCVStartPos=new three.Vector3,translateCVEndPos=new three.Vector3,translateCVDifference=new three.Vector3,translateCVOrigin=new three.Vector3,translateCVPlane=new three.Plane(new three.Vector3(1,0,0),0),translateCVStartMouse=new three.Vector2,translateCVEndMouse=new three.Vector2;async function translateCV(e,t,i){if(Cartesian3.equals(t,e._translateMousePosition)||(e._looking=!1),Cartesian3.equals(t,e._strafeMousePosition)||(e._strafing=!1),e._looking)return void look3D(e,t,i);if(e._strafing)return void continueStrafing(e,i);const n=e._scene.camera,r=e._cameraUnderground,s=Cartesian2.clone(i.startPosition,translateCVStartMouse),a=Cartesian2.clone(i.endPosition,translateCVEndMouse);let o=n.getPickRay(s,translateCVStartRay);const l=Cartesian3.clone(Cartesian3.ZERO,translateCVOrigin),c=Cartesian3.UNIT_X;let h;if(n.position.z<e._minimumPickingTerrainHeight&&(h=await pickPosition(e,s,translateCVStartPos),defined$1(h)&&(l.x=h.x)),r||l.x>n.position.z&&defined$1(h)){let n=h;return r&&(n=getStrafeStartPositionUnderground(e,o,h,translateCVStartPos)),Cartesian2.clone(t,e._strafeMousePosition),Cartesian2.clone(t,e._strafeEndMousePosition),Cartesian3.clone(n,e._strafeStartPosition),e._strafing=!0,void strafe(e,i,e._strafeStartPosition)}const u=StaticPlane.fromPointNormal(l,c,translateCVPlane);o=n.getPickRay(s,translateCVStartRay);const d=IntersectionTests.rayPlane(o,u,translateCVStartPos),p=n.getPickRay(a,translateCVEndRay),m=IntersectionTests.rayPlane(p,u,translateCVEndPos);if(!defined$1(d)||!defined$1(m))return e._looking=!0,look3D(e,t,i),void Cartesian2.clone(t,e._translateMousePosition);const f=Cartesian3.subtract(d,m,translateCVDifference),g=f.x;f.x=f.y,f.y=f.z,f.z=g;const _=Cartesian3.magnitude(f);_>CesiumMath.EPSILON6&&(Cartesian3.normalize(f,f),n.move(f,_))}const rotateCVWindowPos=new three.Vector2,rotateCVWindowRay=new three.Ray,rotateCVCenter=new three.Vector3,rotateCVVerticalCenter=new three.Vector3,rotateCVTransform=new three.Matrix4,rotateCVVerticalTransform=new three.Matrix4,rotateCVOrigin=new three.Vector3,rotateCVPlane=new three.Plane(new three.Vector3(1,0,0),0),rotateCVCartesian3=new three.Vector3,rotateCVCart=new three.Vector3,rotateCVOldTransform=new three.Matrix4,rotateCVQuaternion=new three.Quaternion,rotateCVMatrix=new three.Matrix3,tilt3DCartesian3=new three.Vector3;async function rotateCV(e,t,i){if(defined$1(i.angleAndHeight)&&(i=i.angleAndHeight),Cartesian2.equals(t,e._tiltCenterMousePosition)||(e._tiltCVOffMap=!1,e._looking=!1),e._looking)return void look3D(e,t,i);const n=e._scene.camera;e._tiltCVOffMap||!e.onMap()||Math.abs(n.position.z)>e._minimumPickingTerrainHeight?(e._tiltCVOffMap=!0,rotateCVOnPlane(e,t,i)):await rotateCVOnTerrain(e,t,i)}function rotateCVOnPlane(e,t,i){const n=e._scene,r=n.camera,s=n.canvas,a=rotateCVWindowPos;a.x=s.clientWidth/2,a.y=s.clientHeight/2;const o=r.getPickRay(a,rotateCVWindowRay),l=Cartesian3.UNIT_X,c=o.origin,h=o.direction;let u;const d=Cartesian3.dot(l,h);if(Math.abs(d)>CesiumMath.EPSILON6&&(u=-Cartesian3.dot(l,c)/d),!defined$1(u)||u<=0)return e._looking=!0,look3D(e,t,i),void Cartesian2.clone(t,e._tiltCenterMousePosition);const p=Cartesian3.multiplyByScalar(h,u,rotateCVCenter);Cartesian3.add(c,p,p);const m=n.mapProjection,f=m.ellipsoid;Cartesian3.fromElements(p.y,p.z,p.x,p);const g=m.unproject(p,rotateCVCart);f.cartographicToCartesian(g,p);const _=Transforms.eastNorthUpToFixedFrame(p,f,rotateCVTransform),A=e._globe,v=e._ellipsoid;e._globe=void 0,e._ellipsoid=Ellipsoid.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;const y=StaticMatrix4.clone(r.transform,rotateCVOldTransform);r._setTransform(_),rotate3D(e,t,i,Cartesian3.UNIT_Z),r._setTransform(y),e._globe=A,e._ellipsoid=v;const x=v.maximumRadius;e._rotateFactor=1/x,e._rotateRateRangeAdjustment=x}async function rotateCVOnTerrain(e,t,i){const n=e._scene,r=n.camera,s=e._cameraUnderground,a=n.mapProjection;let o,l;const c=Cartesian3.UNIT_X;if(Cartesian2.equals(t,e._tiltCenterMousePosition))o=Cartesian3.clone(e._tiltCenter,rotateCVCenter);else{if(r.position.z<e._minimumPickingTerrainHeight&&(o=await pickPosition(e,t,rotateCVCenter)),!defined$1(o)){l=r.getPickRay(t,rotateCVWindowRay);const n=l.origin,s=l.direction;let a;const h=Cartesian3.dot(c,s);if(Math.abs(h)>CesiumMath.EPSILON6&&(a=-Cartesian3.dot(c,n)/h),!defined$1(a)||a<=0)return e._looking=!0,look3D(e,t,i),void Cartesian2.clone(t,e._tiltCenterMousePosition);o=Cartesian3.multiplyByScalar(s,a,rotateCVCenter),Cartesian3.add(n,o,o)}s&&(defined$1(l)||(l=r.getPickRay(t,rotateCVWindowRay)),getTiltCenterUnderground(e,l,o,o)),Cartesian2.clone(t,e._tiltCenterMousePosition),Cartesian3.clone(o,e._tiltCenter)}const h=n.canvas,u=rotateCVWindowPos;u.x=h.clientWidth/2,u.y=e._tiltCenterMousePosition.y,l=r.getPickRay(u,rotateCVWindowRay);const d=Cartesian3.clone(Cartesian3.ZERO,rotateCVOrigin);d.x=o.x;const p=StaticPlane.fromPointNormal(d,c,rotateCVPlane),m=IntersectionTests.rayPlane(l,p,rotateCVVerticalCenter),f=a.ellipsoid;Cartesian3.fromElements(o.y,o.z,o.x,o);let g=a.unproject(o,rotateCVCart);f.cartographicToCartesian(g,o);const _=Transforms.eastNorthUpToFixedFrame(o,f,rotateCVTransform);let A;defined$1(m)?(Cartesian3.fromElements(m.y,m.z,m.x,m),g=a.unproject(m,rotateCVCart),f.cartographicToCartesian(g,m),A=Transforms.eastNorthUpToFixedFrame(m,f,rotateCVVerticalTransform)):A=_;const v=e._globe,y=e._ellipsoid;e._globe=void 0,e._ellipsoid=Ellipsoid.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;let x=Cartesian3.UNIT_Z;const b=StaticMatrix4.clone(r.transform,rotateCVOldTransform);r._setTransform(_);const S=Cartesian3.cross(Cartesian3.UNIT_Z,Cartesian3.normalize(r.position,rotateCVCartesian3),rotateCVCartesian3),C=Cartesian3.dot(r.right,S);if(rotate3D(e,t,i,x,!1,!0),r._setTransform(A),C<0){const n=i.startPosition.y-i.endPosition.y;(s&&n<0||!s&&n>0)&&(x=void 0);const a=r.constrainedAxis;r.constrainedAxis=void 0,rotate3D(e,t,i,x,!0,!1),r.constrainedAxis=a}else rotate3D(e,t,i,x,!0,!1);if(defined$1(r.constrainedAxis)){const e=Cartesian3.cross(r.direction,r.constrainedAxis,tilt3DCartesian3);Cartesian3.equalsEpsilon(e,Cartesian3.ZERO,CesiumMath.EPSILON6)||(Cartesian3.dot(e,r.right)<0&&Cartesian3.negate(e,e),Cartesian3.cross(e,r.direction,r.up),Cartesian3.cross(r.direction,r.up,r.right),Cartesian3.normalize(r.up,r.up),Cartesian3.normalize(r.right,r.right))}r._setTransform(b),e._globe=v,e._ellipsoid=y;const T=y.maximumRadius;e._rotateFactor=1/T,e._rotateRateRangeAdjustment=T;const E=Cartesian3.clone(r.positionWC,rotateCVCartesian3);if(e.enableCollisionDetection&&adjustHeightForTerrain(e,!0),!Cartesian3.equals(r.positionWC,E)){r._setTransform(A),r.worldToCameraCoordinatesPoint(E,E);const e=Cartesian3.magnitudeSquared(E);Cartesian3.magnitudeSquared(r.position)>e&&(Cartesian3.normalize(r.position,r.position),Cartesian3.multiplyByScalar(r.position,Math.sqrt(e),r.position));const t=Cartesian3.angleBetween(E,r.position),i=Cartesian3.cross(E,r.position,E);Cartesian3.normalize(i,i);const n=StaticQuaternion.fromAxisAngle(i,t,rotateCVQuaternion),s=StaticMatrix3.fromQuaternion(n,rotateCVMatrix);StaticMatrix3.multiplyByVector(s,r.direction,r.direction),StaticMatrix3.multiplyByVector(s,r.up,r.up),Cartesian3.cross(r.direction,r.up,r.right),Cartesian3.cross(r.right,r.direction,r.up),r._setTransform(b)}}const zoomCVWindowPos=new three.Vector2,zoomCVWindowRay=new three.Ray,zoomCVIntersection=new three.Vector3;async function zoomCV(e,t,i){defined$1(i.distance)&&(i=i.distance);const n=e._scene,r=n.camera,s=n.canvas,a=e._cameraUnderground;let o;a?o=t:(o=zoomCVWindowPos,o.x=s.clientWidth/2,o.y=s.clientHeight/2);const l=r.getPickRay(o,zoomCVWindowRay),c=l.origin,h=l.direction;let u,d;if(r.position.z<e._minimumPickingTerrainHeight&&(u=await pickPosition(e,o,zoomCVIntersection)),defined$1(u)&&(d=Cartesian3.distance(c,u)),a){const t=getZoomDistanceUnderground(e,l);d=defined$1(d)?Math.min(d,t):t}if(!defined$1(d)){const e=Cartesian3.UNIT_X;d=-Cartesian3.dot(e,c)/Cartesian3.dot(e,h)}await handleZoom(e,t,i,e._zoomFactor,d)}function updateCV(e){const t=e._scene.camera;StaticMatrix4.equals(StaticMatrix4.IDENTITY,t.transform)?(reactToInput(e,e.enableTilt,e.tiltEventTypes,rotateCV,e.inertiaSpin,"_lastInertiaTiltMovement"),reactToInput(e,e.enableTranslate,e.translateEventTypes,translateCV,e.inertiaTranslate,"_lastInertiaTranslateMovement"),reactToInput(e,e.enableZoom,e.zoomEventTypes,zoomCV,e.inertiaZoom,"_lastInertiaZoomMovement"),reactToInput(e,e.enableLook,e.lookEventTypes,look3D)):(reactToInput(e,e.enableRotate,e.rotateEventTypes,rotate3D,e.inertiaSpin,"_lastInertiaSpinMovement"),reactToInput(e,e.enableZoom,e.zoomEventTypes,zoom3D,e.inertiaZoom,"_lastInertiaZoomMovement"))}const scratchStrafeRay=new three.Ray,scratchStrafePlane=new three.Plane(new three.Vector3(1,0,0),0),scratchStrafeIntersection=new three.Vector3,scratchStrafeDirection=new three.Vector3;function strafe(e,t,i){const n=e._scene,r=n.camera,s=r.getPickRay(t.endPosition,scratchStrafeRay);let a=Cartesian3.clone(r.direction,scratchStrafeDirection);n.mode===SceneMode.COLUMBUS_VIEW&&Cartesian3.fromElements(a.z,a.x,a.y,a);const o=StaticPlane.fromPointNormal(i,a,scratchStrafePlane),l=IntersectionTests.rayPlane(s,o,scratchStrafeIntersection);defined$1(l)&&(a=Cartesian3.subtract(i,l,a),n.mode===SceneMode.COLUMBUS_VIEW&&Cartesian3.fromElements(a.y,a.z,a.x,a),Cartesian3.add(r.position,a,r.position))}const spin3DPick=new three.Vector3,scratchCartographic$2=new three.Vector3,scratchRadii=new three.Vector3,scratchEllipsoid=new Ellipsoid,scratchLookUp=new three.Vector3,scratchNormal=new three.Vector3,scratchMousePosition=new three.Vector3;async function spin3D(e,t,i){const n=e._scene.camera,r=e._cameraUnderground;let s,a,o=e._ellipsoid;if(!StaticMatrix4.equals(n.transform,StaticMatrix4.IDENTITY))return void rotate3D(e,t,i);const l=o.geodeticSurfaceNormal(n.position,scratchLookUp);if(Cartesian2.equals(t,e._rotateMousePosition)){if(e._looking)look3D(e,t,i,l);else if(e._rotating)rotate3D(e,t,i);else if(e._strafing)continueStrafing(e,i);else{if(Cartesian3.magnitude(n.position)<Cartesian3.magnitude(e._rotateStartPosition))return;s=Cartesian3.magnitude(e._rotateStartPosition),a=scratchRadii,a.x=a.y=a.z=s,o=Ellipsoid.fromCartesian3(a,scratchEllipsoid),await pan3D(e,t,i,o)}return}e._looking=!1,e._rotating=!1,e._strafing=!1;const c=o.cartesianToCartographic(n.positionWC,scratchCartographic$2).z;if(defined$1(e._globe)&&c<e._minimumPickingTerrainHeight){const c=await pickPosition(e,i.startPosition,scratchMousePosition);if(defined$1(c)){let l=!1;const h=n.getPickRay(i.startPosition,pickGlobeScratchRay);if(r)l=!0,getStrafeStartPositionUnderground(e,h,c,c);else{const e=o.geodeticSurfaceNormal(c,scratchNormal);l=!!(Math.abs(Cartesian3.dot(h.direction,e))<.05)||Cartesian3.magnitude(n.position)<Cartesian3.magnitude(c)}l?(Cartesian2.clone(t,e._strafeEndMousePosition),Cartesian3.clone(c,e._strafeStartPosition),e._strafing=!0,strafe(e,i,e._strafeStartPosition)):(s=Cartesian3.magnitude(c),a=scratchRadii,a.x=a.y=a.z=s,o=Ellipsoid.fromCartesian3(a,scratchEllipsoid),await pan3D(e,t,i,o),Cartesian3.clone(c,e._rotateStartPosition))}else e._looking=!0,look3D(e,t,i,l)}else defined$1(n.pickEllipsoid(i.startPosition,e._ellipsoid,spin3DPick))?(await pan3D(e,t,i,e._ellipsoid),Cartesian3.clone(spin3DPick,e._rotateStartPosition)):c>e._minimumTrackBallHeight?(e._rotating=!0,rotate3D(e,t,i)):(e._looking=!0,look3D(e,t,i,l));Cartesian2.clone(t,e._rotateMousePosition)}function rotate3D(e,t,i,n,r,s){if(!e.enableRotate&&!e.enableTilt)return;r=defaultValue(r,!1),s=defaultValue(s,!1),e.enableRotate||(r=!0),e.enableTilt||(s=!0);const a=e._scene,o=a.camera,l=a.canvas,c=o.constrainedAxis;defined$1(n)&&(o.constrainedAxis=n);const h=Cartesian3.magnitude(o.position);let u=e._rotateFactor*(h-e._rotateRateRangeAdjustment);u>e._maximumRotateRate&&(u=e._maximumRotateRate),u<e._minimumRotateRate&&(u=e._minimumRotateRate);let d=(i.startPosition.x-i.endPosition.x)/l.clientWidth,p=(i.startPosition.y-i.endPosition.y)/l.clientHeight;d=Math.min(d,e.maximumMovementRatio),p=Math.min(p,e.maximumMovementRatio);const m=u*d*Math.PI*2,f=u*p*Math.PI;r||o.rotateRight(m),s||o.rotateUp(f),o.constrainedAxis=c}const pan3DP0=Cartesian4.clone(Cartesian4.UNIT_W),pan3DP1=Cartesian4.clone(Cartesian4.UNIT_W),pan3DP03=new three.Vector3,pan3DP13=new three.Vector3,pan3DTemp0=new three.Vector3,pan3DTemp1=new three.Vector3,pan3DTemp2=new three.Vector3,pan3DTemp3=new three.Vector3,pan3DStartMousePosition=new three.Vector2,pan3DEndMousePosition=new three.Vector2,pan3DDiffMousePosition=new three.Vector2,pan3DPixelDimensions=new three.Vector2,panRay=new three.Ray;async function pan3D(e,t,i,n){if(!e.enableTranslate)return;const r=e._scene,s=r.camera,a=Cartesian2.clone(i.startPosition,pan3DStartMousePosition),o=Cartesian2.clone(i.endPosition,pan3DEndMousePosition),l=n.cartesianToCartographic(s.positionWC,scratchCartographic$2).z;let c,h;if(!i.inertiaEnabled&&l<e._minimumPickingTerrainHeight&&(c=Cartesian3.clone(e._panLastWorldPosition,pan3DP0),defined$1(e._globe)||Cartesian2.equalsEpsilon(a,e._panLastMousePosition)||(c=await pickPosition(e,a,pan3DP0)),!defined$1(e._globe)&&defined$1(c))){const t=Cartesian3.subtract(c,s.positionWC,pan3DTemp1),i=Cartesian3.multiplyByScalar(s.directionWC,Cartesian3.dot(s.directionWC,t),pan3DTemp1),n=Cartesian3.magnitude(i),l=s.frustum.getPixelDimensions(r.drawingBufferWidth,r.drawingBufferHeight,n,r.pixelRatio,pan3DPixelDimensions),u=Cartesian2.subtract(o,a,pan3DDiffMousePosition),d=Cartesian3.multiplyByScalar(s.rightWC,u.x*l.x,pan3DTemp1),p=Cartesian3.normalize(s.positionWC,scratchCameraPositionNormal),m=s.getPickRay(o,panRay).direction,f=Cartesian3.subtract(m,Cartesian3.projectVector(m,s.rightWC,pan3DTemp2),pan3DTemp2),g=Cartesian3.angleBetween(f,s.directionWC);let _=1;defined$1(s.frustum.fov)&&(_=Math.max(Math.tan(g),.1));let A=Math.abs(Cartesian3.dot(s.directionWC,p));const v=-u.y*l.y*2/Math.sqrt(_)*(1-A),y=Cartesian3.multiplyByScalar(m,v,pan3DTemp2);A=Math.abs(Cartesian3.dot(s.upWC,p));const x=Cartesian3.multiplyByScalar(s.upWC,-u.y*(1-A)*l.y,pan3DTemp3);h=Cartesian3.add(c,d,pan3DP1),h=Cartesian3.add(h,y,h),h=Cartesian3.add(h,x,h),Cartesian3.clone(h,e._panLastWorldPosition),Cartesian2.clone(o,e._panLastMousePosition)}if(defined$1(c)&&defined$1(h)||(c=s.pickEllipsoid(a,n,pan3DP0),h=s.pickEllipsoid(o,n,pan3DP1)),c&&(c.w=1),h&&(h.w=1),!defined$1(c)||!defined$1(h))return e._rotating=!0,void rotate3D(e,t,i);if(c=s.worldToCameraCoordinates(c,c),h=s.worldToCameraCoordinates(h,h),c=Cartesian3.fromCartesian4(c,pan3DP03),h=Cartesian3.fromCartesian4(h,pan3DP13),defined$1(s.constrainedAxis)){const e=s.constrainedAxis,t=Cartesian3.mostOrthogonalAxis(e,pan3DTemp0);Cartesian3.cross(t,e,t),Cartesian3.normalize(t,t);const i=Cartesian3.cross(e,t,pan3DTemp1),n=Cartesian3.magnitude(c),r=Cartesian3.dot(e,c),a=Math.acos(r/n),o=Cartesian3.multiplyByScalar(e,r,pan3DTemp2);Cartesian3.subtract(c,o,o),Cartesian3.normalize(o,o);const l=Cartesian3.magnitude(h),u=Cartesian3.dot(e,h),d=Math.acos(u/l),p=Cartesian3.multiplyByScalar(e,u,pan3DTemp3);Cartesian3.subtract(h,p,p),Cartesian3.normalize(p,p);let m=Math.acos(Cartesian3.dot(o,t));Cartesian3.dot(o,i)<0&&(m=CesiumMath.TWO_PI-m);let f=Math.acos(Cartesian3.dot(p,t));Cartesian3.dot(p,i)<0&&(f=CesiumMath.TWO_PI-f);const g=m-f;let _;_=Cartesian3.equalsEpsilon(e,s.position,CesiumMath.EPSILON2)?s.right:Cartesian3.cross(e,s.position,pan3DTemp0);const A=Cartesian3.cross(e,_,pan3DTemp0),v=Cartesian3.dot(A,Cartesian3.subtract(c,e,pan3DTemp1)),y=Cartesian3.dot(A,Cartesian3.subtract(h,e,pan3DTemp1));let x;x=v>0&&y>0?d-a:v>0&&y<=0?Cartesian3.dot(s.position,e)>0?-a-d:a+d:a-d,s.rotateRight(g),s.rotateUp(x)}else{Cartesian3.normalize(c,c),Cartesian3.normalize(h,h);const e=Cartesian3.dot(c,h),t=Cartesian3.cross(c,h,pan3DTemp0);if(e<1&&!Cartesian3.equalsEpsilon(t,Cartesian3.ZERO,CesiumMath.EPSILON14)){const i=Math.acos(e);s.rotate(t,i)}}}const zoom3DUnitPosition=new three.Vector3,zoom3DCartographic=new three.Vector3;let preIntersectionDistance=0;async function zoom3D(e,t,i){defined$1(i.distance)&&(i=i.distance);const n=i.inertiaEnabled,r=e._ellipsoid,s=e._scene,a=s.camera,o=s.canvas,l=e._cameraUnderground;let c;l?c=t:(c=zoomCVWindowPos,c.x=o.clientWidth/2,c.y=o.clientHeight/2);const h=a.getPickRay(c,zoomCVWindowRay);let u;const d=r.cartesianToCartographic(a.position,zoom3DCartographic).z,p=Math.abs(preIntersectionDistance)<e.minimumPickingTerrainDistanceWithInertia;let m;if((n?p:d<e._minimumPickingTerrainHeight)&&(u=await pickPosition(e,c,zoomCVIntersection)),defined$1(u)&&(m=Cartesian3.distance(h.origin,u),preIntersectionDistance=m),l){const t=getZoomDistanceUnderground(e,h);m=defined$1(m)?Math.min(m,t):t}defined$1(m)||(m=d);const f=Cartesian3.normalize(a.position,zoom3DUnitPosition);await handleZoom(e,t,i,e._zoomFactor,m,Cartesian3.dot(f,a.direction))}const tilt3DWindowPos=new three.Vector2,tilt3DRay=new three.Ray,tilt3DCenter=new three.Vector3,tilt3DVerticalCenter=new three.Vector3,tilt3DTransform=new three.Matrix4,tilt3DVerticalTransform=new three.Matrix4,tilt3DOldTransform=new three.Matrix4,tilt3DQuaternion=new three.Quaternion,tilt3DMatrix=new three.Matrix3,tilt3DCart=new three.Vector3,tilt3DLookUp=new three.Vector3;async function tilt3D(e,t,i){const n=e._scene.camera;if(!StaticMatrix4.equals(n.transform,StaticMatrix4.IDENTITY))return;if(defined$1(i.angleAndHeight)&&(i=i.angleAndHeight),Cartesian2.equals(t,e._tiltCenterMousePosition)||(e._tiltOnEllipsoid=!1,e._looking=!1),e._looking){const r=e._ellipsoid.geodeticSurfaceNormal(n.position,tilt3DLookUp);return void look3D(e,t,i,r)}const r=e._ellipsoid.cartesianToCartographic(n.position,tilt3DCart);e._tiltOnEllipsoid||r.z>e._minimumCollisionTerrainHeight?(e._tiltOnEllipsoid=!0,tilt3DOnEllipsoid(e,t,i)):await tilt3DOnTerrain(e,t,i)}const tilt3DOnEllipsoidCartographic=new three.Vector3;function tilt3DOnEllipsoid(e,t,i){const n=e._ellipsoid,r=e._scene,s=r.camera,a=.25*e.minimumZoomDistance,o=n.cartesianToCartographic(s.positionWC,tilt3DOnEllipsoidCartographic).z;if(o-a-1<CesiumMath.EPSILON3&&i.endPosition.y-i.startPosition.y<0)return;const l=r.canvas,c=tilt3DWindowPos;c.x=l.clientWidth/2,c.y=l.clientHeight/2;const h=s.getPickRay(c,tilt3DRay);let u;const d=IntersectionTests.rayEllipsoid(h,n);if(defined$1(d))u=StaticRay.getPoint(h,d.start,tilt3DCenter);else{if(!(o>e._minimumTrackBallHeight)){e._looking=!0;const n=e._ellipsoid.geodeticSurfaceNormal(s.position,tilt3DLookUp);return look3D(e,t,i,n),void Cartesian2.clone(t,e._tiltCenterMousePosition)}{const e=IntersectionTests.grazingAltitudeLocation(h,n);if(!defined$1(e))return;const t=n.cartesianToCartographic(e,tilt3DCart);t.z=0,u=n.cartographicToCartesian(t,tilt3DCenter)}}const p=Transforms.eastNorthUpToFixedFrame(u,n,tilt3DTransform),m=e._globe,f=e._ellipsoid;e._globe=void 0,e._ellipsoid=Ellipsoid.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;const g=StaticMatrix4.clone(s.transform,tilt3DOldTransform);s._setTransform(p),rotate3D(e,t,i,Cartesian3.UNIT_Z),s._setTransform(g),e._globe=m,e._ellipsoid=f;const _=f.maximumRadius;e._rotateFactor=1/_,e._rotateRateRangeAdjustment=_}async function tilt3DOnTerrain(e,t,i){const n=e._ellipsoid,r=e._scene,s=r.camera,a=e._cameraUnderground;let o,l,c;if(Cartesian2.equals(t,e._tiltCenterMousePosition))o=Cartesian3.clone(e._tiltCenter,tilt3DCenter);else{if(o=await pickPosition(e,t,tilt3DCenter),!defined$1(o)){if(l=s.getPickRay(t,tilt3DRay),c=IntersectionTests.rayEllipsoid(l,n),!defined$1(c)){if(n.cartesianToCartographic(s.position,tilt3DCart).z<=e._minimumTrackBallHeight){e._looking=!0;const n=e._ellipsoid.geodeticSurfaceNormal(s.position,tilt3DLookUp);look3D(e,t,i,n),Cartesian2.clone(t,e._tiltCenterMousePosition)}return}o=StaticRay.getPoint(l,c.start,tilt3DCenter)}a&&(defined$1(l)||(l=s.getPickRay(t,tilt3DRay)),getTiltCenterUnderground(e,l,o,o)),Cartesian2.clone(t,e._tiltCenterMousePosition),Cartesian3.clone(o,e._tiltCenter)}const h=r.canvas,u=tilt3DWindowPos;u.x=h.clientWidth/2,u.y=e._tiltCenterMousePosition.y,l=s.getPickRay(u,tilt3DRay);const d=Cartesian3.magnitude(o),p=Cartesian3.fromElements(d,d,d,scratchRadii),m=Ellipsoid.fromCartesian3(p,scratchEllipsoid);if(c=IntersectionTests.rayEllipsoid(l,m),!defined$1(c))return;const f=Cartesian3.magnitude(l.origin)>d?c.start:c.stop,g=StaticRay.getPoint(l,f,tilt3DVerticalCenter),_=Transforms.eastNorthUpToFixedFrame(o,n,tilt3DTransform),A=Transforms.eastNorthUpToFixedFrame(g,m,tilt3DVerticalTransform),v=e._globe,y=e._ellipsoid;e._globe=void 0,e._ellipsoid=Ellipsoid.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;let x=Cartesian3.UNIT_Z;const b=StaticMatrix4.clone(s.transform,tilt3DOldTransform);s._setTransform(A);const S=Cartesian3.cross(g,s.positionWC,tilt3DCartesian3);if(Cartesian3.dot(s.rightWC,S)<0){const n=i.startPosition.y-i.endPosition.y;(a&&n<0||!a&&n>0)&&(x=void 0);const r=s.constrainedAxis;s.constrainedAxis=void 0,rotate3D(e,t,i,x,!0,!1),s.constrainedAxis=r}else rotate3D(e,t,i,x,!0,!1);if(s._setTransform(_),rotate3D(e,t,i,x,!1,!0),defined$1(s.constrainedAxis)){const e=Cartesian3.cross(s.direction,s.constrainedAxis,tilt3DCartesian3);Cartesian3.equalsEpsilon(e,Cartesian3.ZERO,CesiumMath.EPSILON6)||(Cartesian3.dot(e,s.right)<0&&Cartesian3.negate(e,e),Cartesian3.cross(e,s.direction,s.up),Cartesian3.cross(s.direction,s.up,s.right),Cartesian3.normalize(s.up,s.up),Cartesian3.normalize(s.right,s.right))}s._setTransform(b),e._globe=v,e._ellipsoid=y;const C=y.maximumRadius;e._rotateFactor=1/C,e._rotateRateRangeAdjustment=C;const T=Cartesian3.clone(s.positionWC,tilt3DCartesian3);if(e.enableCollisionDetection&&adjustHeightForTerrain(e,!0),!Cartesian3.equals(s.positionWC,T)){s._setTransform(A),s.worldToCameraCoordinatesPoint(T,T);const e=Cartesian3.magnitudeSquared(T);Cartesian3.magnitudeSquared(s.position)>e&&(Cartesian3.normalize(s.position,s.position),Cartesian3.multiplyByScalar(s.position,Math.sqrt(e),s.position));const t=Cartesian3.angleBetween(T,s.position),i=Cartesian3.cross(T,s.position,T);Cartesian3.normalize(i,i);const n=StaticQuaternion.fromAxisAngle(i,t,tilt3DQuaternion),r=StaticMatrix3.fromQuaternion(n,tilt3DMatrix);StaticMatrix3.multiplyByVector(r,s.direction,s.direction),StaticMatrix3.multiplyByVector(r,s.up,s.up),Cartesian3.cross(s.direction,s.up,s.right),Cartesian3.cross(s.right,s.direction,s.up),s._setTransform(b)}}const look3DStartPos=new three.Vector2,look3DEndPos=new three.Vector2,look3DStartRay=new three.Ray,look3DEndRay=new three.Ray,look3DNegativeRot=new three.Vector3,look3DTan=new three.Vector3;function look3D(e,t,i,n){const r=e._scene.camera,s=look3DStartPos;s.x=i.startPosition.x,s.y=0;const a=look3DEndPos;a.x=i.endPosition.x,a.y=0;let o,l,c=r.getPickRay(s,look3DStartRay),h=r.getPickRay(a,look3DEndRay),u=0;o=c.direction,l=h.direction;let d=Cartesian3.dot(o,l);d<1&&(u=Math.acos(d)),u=i.startPosition.x>i.endPosition.x?-u:u;const p=e._horizontalRotationAxis;if(defined$1(n)?r.look(n,-u):defined$1(p)?r.look(p,-u):r.lookLeft(u),s.x=0,s.y=i.startPosition.y,a.x=0,a.y=i.endPosition.y,c=r.getPickRay(s,look3DStartRay),h=r.getPickRay(a,look3DEndRay),u=0,o=c.direction,l=h.direction,d=Cartesian3.dot(o,l),d<1&&(u=Math.acos(d)),u=i.startPosition.y>i.endPosition.y?-u:u,defined$1(n=defaultValue(n,p))){const e=r.direction,t=Cartesian3.negate(n,look3DNegativeRot),i=Cartesian3.equalsEpsilon(e,n,CesiumMath.EPSILON2),s=Cartesian3.equalsEpsilon(e,t,CesiumMath.EPSILON2);if(i||s)(i&&u<0||s&&u>0)&&r.look(r.right,-u);else{d=Cartesian3.dot(e,n);let i=CesiumMath.acosClamped(d);u>0&&u>i&&(u=i-CesiumMath.EPSILON4),d=Cartesian3.dot(e,t),i=CesiumMath.acosClamped(d),u<0&&-u>i&&(u=-i+CesiumMath.EPSILON4);const s=Cartesian3.cross(n,e,look3DTan);r.look(s,u)}}else r.lookUp(u)}function update3D(e){reactToInput(e,e.enableRotate||e.enableTranslate,e.rotateEventTypes,spin3D,e.inertiaSpin,"_lastInertiaSpinMovement"),reactToInput(e,e.enableZoom,e.zoomEventTypes,zoom3D,e.inertiaZoom,"_lastInertiaZoomMovement"),reactToInput(e,e.enableTilt||e.enableRotate,e.tiltEventTypes,tilt3D,e.inertiaSpin,"_lastInertiaTiltMovement"),reactToInput(e,e.enableLook,e.lookEventTypes,look3D)}const scratchAdjustHeightTransform=new three.Matrix4,scratchAdjustHeightCartographic=new three.Vector3;function adjustHeightForTerrain(e,t){e._adjustedHeightForTerrain=!0;const i=e._scene,n=i.mode,r=i.globe;if(!defined$1(r)||n===SceneMode.SCENE2D||n===SceneMode.MORPHING)return;const s=i.camera,a=r.ellipsoid,o=i.mapProjection;let l,c;StaticMatrix4.equals(s.transform,StaticMatrix4.IDENTITY)||(l=StaticMatrix4.clone(s.transform,scratchAdjustHeightTransform),c=Cartesian3.magnitude(s.position),s._setTransform(StaticMatrix4.IDENTITY));const h=scratchAdjustHeightCartographic;n===SceneMode.SCENE3D?a.cartesianToCartographic(s.position,h):o.unproject(s.position,h);let u=!1;if(h.z<e._minimumCollisionTerrainHeight){const i=defaultValue(e._scene.globeHeight,0);if(defined$1(i)){const r=i+e.minimumZoomDistance,l=i-e._lastGlobeHeight,c=l/e._lastGlobeHeight;h.z<r&&(t||Math.abs(c)<=.1)&&(h.z=r,n===SceneMode.SCENE3D?a.cartographicToCartesian(h,s.position):o.project(h,s.position),u=!0),t||Math.abs(c)<=.1?e._lastGlobeHeight=i:e._lastGlobeHeight+=.1*l}}defined$1(l)&&(s._setTransform(l),u&&(Cartesian3.normalize(s.position,s.position),Cartesian3.negate(s.position,s.direction),Cartesian3.multiplyByScalar(s.position,Math.max(c,e.minimumZoomDistance),s.position),Cartesian3.normalize(s.direction,s.direction),Cartesian3.cross(s.direction,s.up,s.right),Cartesian3.cross(s.right,s.direction,s.up)))}function isCameraUnderground(e){const t=e._scene,i=t.camera,n=t.mode,r=i.positionCartographic;if(!defined$1(r))return!1;if(!e.onMap()&&r.z<0)return!0;if(n===SceneMode.SCENE2D||n===SceneMode.MORPHING)return!1;const s=defaultValue(t.globeHeight,0);return defined$1(s)&&r.z<s}const scratchGetHeightCartesian=new three.Vector3,scratchGetHeightIntersection=new three.Vector3,scratchGetHeightCartographic=new three.Vector3,scratchGetHeightRay=new three.Ray;function getGlobeHeight(e){const t=e._scene;if(t.mode===SceneMode.MORPHING)return;const i=t.camera.positionCartographic;if(!defined$1(i))return;let n=Number.NEGATIVE_INFINITY;if(defined$1(t.globe)){const r=t.mapProjection.ellipsoid,s=Cartesian3.fromRadians(i.x,i.y,0,r,scratchGetHeightCartesian),a=scratchGetHeightRay;r.geodeticSurfaceNormal(s,a.direction),r.getSurfaceNormalIntersectionWithZAxis(s,111500,a.origin);const o=7e6;a.origin.add(a.direction.clone().multiplyScalar(o)),a.direction.negate(),e._cameraUnderground;let l=t.rendering.picking.pickTerrainWorldPosition(a);if(!defined$1(l)){let e=IntersectionTests.rayEllipsoid(a,r);if(defined$1(e)){let t=e.start>0?e.start:e.stop;l=StaticRay.getPoint(a,t,scratchGetHeightIntersection)}}defined$1(l)&&(n=r.cartesianToCartographic(l,scratchGetHeightCartographic).z)}return n>Number.NEGATIVE_INFINITY?n:void 0}function sceneInitializeFrame(e){const t=e._scene;e.enableTerrainCollision&&(t.globeHeight=getGlobeHeight(e)),t.cameraUnderground=isCameraUnderground(e)}ScreenSpaceCameraController.prototype.onMap=function(){const e=this._scene,t=e.mode,i=e.camera;return t!==SceneMode.COLUMBUS_VIEW||Math.abs(i.position.x)-this._maxCoord.x<0&&Math.abs(i.position.y)-this._maxCoord.y<0};const scratchPreviousPosition=new three.Vector3,scratchPreviousDirection=new three.Vector3;function EllipsoidalOccluder(e,t){this._ellipsoid=e,this._cameraPosition=new three.Vector3,this._cameraPositionInScaledSpace=new three.Vector3,this._distanceToLimbInScaledSpaceSquared=0,defined$1(t)&&(this.cameraPosition=t)}ScreenSpaceCameraController.prototype.update=function(){const e=this._scene,t=e.camera,i=e.globe,n=e.mode;sceneInitializeFrame(this),StaticMatrix4.equals(t.transform,StaticMatrix4.IDENTITY)?(this._globe=i,this._ellipsoid=defined$1(this._globe)?this._globe.ellipsoid:e.mapProjection.ellipsoid):(this._globe=void 0,this._ellipsoid=Ellipsoid.UNIT_SPHERE);const r=defined$1(this._globe)&&defined$1(this._globe.terrainExaggeration)?this._globe.terrainExaggeration:1,s=defined$1(this._globe)&&defined$1(this._globe.terrainExaggerationRelativeHeight)?this._globe.terrainExaggerationRelativeHeight:0;if(this._minimumCollisionTerrainHeight=TerrainExaggeration.getHeight(this.minimumCollisionTerrainHeight,r,s),this._minimumPickingTerrainHeight=TerrainExaggeration.getHeight(this.minimumPickingTerrainHeight,r,s),this._minimumTrackBallHeight=TerrainExaggeration.getHeight(this.minimumTrackBallHeight,r,s),this._cameraUnderground=e.cameraUnderground&&defined$1(this._globe),this._ellipsoid){const e=this._ellipsoid.maximumRadius;this._rotateFactor=1/e,this._rotateRateRangeAdjustment=e}this._adjustedHeightForTerrain=!1;const a=Cartesian3.clone(t.positionWC,scratchPreviousPosition),o=Cartesian3.clone(t.directionWC,scratchPreviousDirection);if(n===SceneMode.SCENE2D?update2D(this):n===SceneMode.COLUMBUS_VIEW?(this._horizontalRotationAxis=Cartesian3.UNIT_Z,updateCV(this)):n===SceneMode.SCENE3D&&(this._horizontalRotationAxis=void 0,update3D(this)),this.enableCollisionDetection&&!this._adjustedHeightForTerrain){adjustHeightForTerrain(this,!Cartesian3.equals(a,t.positionWC)||!Cartesian3.equals(o,t.directionWC))}this._aggregator.reset()},ScreenSpaceCameraController.prototype.isDestroyed=function(){return!1},ScreenSpaceCameraController.prototype.destroy=function(){return this._aggregator=this._aggregator&&this._aggregator.destroy(),destroyObject(this)},Object.defineProperties(EllipsoidalOccluder.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},cameraPosition:{get:function(){return this._cameraPosition},set:function(e){const t=this._ellipsoid.transformPositionToScaledSpace(e,this._cameraPositionInScaledSpace),i=Cartesian3.magnitudeSquared(t)-1;Cartesian3.clone(e,this._cameraPosition),this._cameraPositionInScaledSpace=t,this._distanceToLimbInScaledSpaceSquared=i}}});const scratchCartesian$2=new three.Vector3;EllipsoidalOccluder.prototype.isPointVisible=function(e){return isScaledSpacePointVisible(this._ellipsoid.transformPositionToScaledSpace(e,scratchCartesian$2),this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)},EllipsoidalOccluder.prototype.isScaledSpacePointVisible=function(e){return isScaledSpacePointVisible(e,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};const scratchCameraPositionInScaledSpaceShrunk=new Cartesian3;EllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid=function(e,t){const i=this._ellipsoid;let n,r;return defined$1(t)&&t<0&&i.minimumRadius>-t?(r=scratchCameraPositionInScaledSpaceShrunk,r.x=this._cameraPosition.x/(i.radii.x+t),r.y=this._cameraPosition.y/(i.radii.y+t),r.z=this._cameraPosition.z/(i.radii.z+t),n=r.x*r.x+r.y*r.y+r.z*r.z-1):(r=this._cameraPositionInScaledSpace,n=this._distanceToLimbInScaledSpaceSquared),isScaledSpacePointVisible(e,r,n)},EllipsoidalOccluder.prototype.computeHorizonCullingPoint=function(e,t,i){return computeHorizonCullingPointFromPositions(this._ellipsoid,e,t,i)};const scratchEllipsoidShrunk=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);EllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid=function(e,t,i,n){return computeHorizonCullingPointFromPositions(getPossiblyShrunkEllipsoid(this._ellipsoid,i,scratchEllipsoidShrunk),e,t,n)},EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices=function(e,t,i,n,r){return computeHorizonCullingPointFromVertices(this._ellipsoid,e,t,i,n,r)},EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid=function(e,t,i,n,r,s){return computeHorizonCullingPointFromVertices(getPossiblyShrunkEllipsoid(this._ellipsoid,r,scratchEllipsoidShrunk),e,t,i,n,s)};const subsampleScratch=[];EllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle=function(e,t,i){const n=Rectangle.subsample(e,t,0,subsampleScratch),r=new three.Sphere;if(r.setFromPoints(n),!(Cartesian3.magnitude(r.center)<.1*t.minimumRadius))return this.computeHorizonCullingPoint(r.center,n,i)};const scratchEllipsoidShrunkRadii=new three.Vector3;function getPossiblyShrunkEllipsoid(e,t,i){if(defined$1(t)&&t<0&&e.minimumRadius>-t){const n=Cartesian3.fromElements(e.radii.x+t,e.radii.y+t,e.radii.z+t,scratchEllipsoidShrunkRadii);e=Ellipsoid.fromCartesian3(n,i)}return e}function computeHorizonCullingPointFromPositions(e,t,i,n){defined$1(n)||(n=new three.Vector3);const r=computeScaledSpaceDirectionToPoint(e,t);let s=0;for(let a=0,o=i.length;a<o;++a){const t=computeMagnitude(e,i[a],r);if(t<0)return;s=Math.max(s,t)}return magnitudeToPoint(r,s,n)}const positionScratch$5=new three.Vector3;function computeHorizonCullingPointFromVertices(e,t,i,n,r,s){defined$1(s)||(s=new three.Vector3),n=defaultValue(n,3),r=defaultValue(r,Cartesian3.ZERO);const a=computeScaledSpaceDirectionToPoint(e,t);let o=0;for(let l=0,c=i.length;l<c;l+=n){positionScratch$5.x=i[l]+r.x,positionScratch$5.y=i[l+1]+r.y,positionScratch$5.z=i[l+2]+r.z;const t=computeMagnitude(e,positionScratch$5,a);if(t<0)return;o=Math.max(o,t)}return magnitudeToPoint(a,o,s)}function isScaledSpacePointVisible(e,t,i){const n=t,r=i,s=Cartesian3.subtract(e,n,scratchCartesian$2),a=-Cartesian3.dot(s,n);return!(r<0?a>0:a>r&&a*a/Cartesian3.magnitudeSquared(s)>r)}const scaledSpaceScratch=new three.Vector3,directionScratch$3=new three.Vector3;function computeMagnitude(e,t,i){const n=e.transformPositionToScaledSpace(t,scaledSpaceScratch);let r=Cartesian3.magnitudeSquared(n),s=Math.sqrt(r);const a=Cartesian3.divideByScalar(n,s,directionScratch$3);r=Math.max(1,r),s=Math.max(1,s);const o=1/s;return 1/(Cartesian3.dot(a,i)*o-Cartesian3.magnitude(Cartesian3.cross(a,i,a))*(Math.sqrt(r-1)*o))}function magnitudeToPoint(e,t,i){if(!(t<=0||t===1/0||isNaN(t)))return Cartesian3.multiplyByScalar(e,t,i)}const directionToPointScratch=new three.Vector3;function computeScaledSpaceDirectionToPoint(e,t){return Cartesian3.equals(t,Cartesian3.ZERO)?t:(e.transformPositionToScaledSpace(t,directionToPointScratch),Cartesian3.normalize(directionToPointScratch,directionToPointScratch))}new three.Vector3;const _tempVector3$6=new three.Vector3,_outputDegreeScratch=new three.Vector3;new three.Vector3;const directionScratch$2=new three.Vector3,positionScratch$4=new three.Vector3,upScratch$1=new three.Vector3,rightScratch$1=new three.Vector3,rotationMatrixScratch$2=new three.Matrix4,xAxisScratch=new three.Vector3,yAxisScratch=new three.Vector3;class Earth extends BaseMap{constructor(e,t,i){super(e,i),__publicField(this,"MERCATOR_LENGTH",20037508.3427892),__publicField(this,"projectionName","ecef"),__publicField(this,"near",.1),__publicField(this,"fov",35),__publicField(this,"_farScale",1.2),__publicField(this,"handleContextMenu",(e=>{e.preventDefault()})),__publicField(this,"handleEventPointerDown",(e=>{const t=this._engine.event,i=e.position.x,n=e.position.y;t._handlePointerDown({pixel:[i,n],event:e.event})})),__publicField(this,"handleEventPointerUp",(e=>{const t=this._engine.event,i=e.position.x,n=e.position.y;t._handlePointerUp({pixel:[i,n],event:e.event})})),__publicField(this,"handleEventClick",(e=>{const t=this._engine.event,i=e.position.x,n=e.position.y;2===e.event.button?t._handleRightClick({pixel:[i,n],event:e.event}):t._handleClick({pixel:[i,n],event:e.event})})),__publicField(this,"handleEventDblClick",(e=>{const t=this._engine.event,i=e.position.x,n=e.position.y;2===e.event.button?t._handleRightDblClick({pixel:[i,n],event:e.event}):t._handleDblClick({pixel:[i,n],event:e.event})})),__publicField(this,"handleEventMouseMove",(e=>{const t=this._engine.event,i=e.startPosition.x,n=e.startPosition.y;t._handleMouseMove({pixel:[i,n],event:e})})),__publicField(this,"handleViewChange",(()=>{this.onViewChanged&&this.onViewChanged()})),__publicField(this,"handleMapResize",(()=>{this.onResolutionChanged&&this.onResolutionChanged(this.getResolution())})),this._engine=e,this.domContainer=t,this._ellipsoid=Ellipsoid.WGS84,this.mode=SceneMode.SCENE3D,this.mapProjection=new GeographicProjection(this._ellipsoid)}afterInit(){this.bindCanvas(),this.camera.matrixAutoUpdate=!1,this.handleMapResize(),bind_1(this.domContainer,this.handleMapResize);const e=this._ellipsoidCamera=new EllipsoidCamera(this);e.frustum=this.camera,e.constrainedAxis=Cartesian3.UNIT_Z,this._globe=new Globe(this._ellipsoid,this._engine),this._occluder=new EllipsoidalOccluder(this._ellipsoid,this.camera.position),this._initControl()}bindCanvas(){this.domContainer.appendChild(this.canvas)}releaseCanvas(){this.domContainer.removeChild(this.canvas)}_initControl(){const e=this._controllerScene={camera:this._ellipsoidCamera,canvas:this.canvas,globe:this._globe,mode:this.mode,globeHeight:0,mapProjection:this.mapProjection,rendering:this._engine.rendering};this._controller=new ScreenSpaceCameraController(e),this.canvas.addEventListener("contextmenu",this.handleContextMenu),this._bindEvents()}_bindEvents(){this._controller._aggregator.onEventPointerDown=this.handleEventPointerDown,this._controller._aggregator.onEventPointerUp=this.handleEventPointerUp,this._controller._aggregator.onEventClick=this.handleEventClick,this._controller._aggregator.onEventDblClick=this.handleEventDblClick,this._controller._aggregator.onEventMouseMove=this.handleEventMouseMove}getContainerSize(){return[this.domContainer.clientWidth,this.domContainer.clientHeight]}getResolution(){return new three.Vector2(this.domContainer.clientWidth,this.domContainer.clientHeight)}getCenter(){let e=this.unprojectArrayCoordinate(this.getProjectionCenter());return isLngLatArrValid(e)?e:_outputDegreeScratch.toArray()}getProjectionCenter(){const[e,t]=this.getContainerSize(),i=new three.Vector2(e/2,t/2),n=this._ellipsoidCamera.pickEllipsoid(i);return n?[n.x,n.y,n.z]:[0,0,0]}getPitch(){return three.MathUtils.radToDeg(this._ellipsoidCamera.pitch)+90}getHeading(){return 360-three.MathUtils.radToDeg(this._ellipsoidCamera.heading)}getRoll(){return three.MathUtils.radToDeg(this._ellipsoidCamera.roll)}getRange(){const e=this.getProjectionCenter();return this._ellipsoidCamera.position.distanceTo(_tempVector3$6.set(e[0],e[1],e[2]))}getZoom(){return this.getZoomByZoomUnits(this.getZoomUnits())}getZoomUnits(){const[e,t]=this.getContainerSize();return this.getViewHeight()*Math.tan(three.MathUtils.degToRad(this.fov/2))*2/t}getCameraDistance(){return this.getRange()}getZoomUnitsByZoom(e){return this.MERCATOR_LENGTH/128/Math.pow(2,e)}getZoomByZoomUnits(e){return Math.log2(this.MERCATOR_LENGTH/128/e)}getProjectionBounds(){const e=this.getProjectionCenter(),t=this._ellipsoidCamera.position.distanceTo(_tempVector3$6.set(e[0],e[1],e[2])),[i,n]=this.getContainerSize(),r=i/n,s=three.MathUtils.degToRad(this.getHeading()),a=three.MathUtils.degToRad(Math.max(this.getPitch(),80)),o=Math.cos(a);let l=2*t*Math.tan(three.MathUtils.degToRad(this.fov/2)),c=l*r;c=Math.abs(Math.cos(s))*c+Math.abs(Math.sin(s))*l,l=Math.abs(Math.cos(s))*l+Math.abs(Math.sin(s))*c,c/=o,l/=o;const h=Transforms.eastNorthUpToFixedFrame(_tempVector3$6.fromArray(e)),u=rotationMatrixScratch$2.extractRotation(h);xAxisScratch.setFromMatrixColumn(u,0),yAxisScratch.setFromMatrixColumn(u,1);const d=xAxisScratch.multiplyScalar(c).add(yAxisScratch.multiplyScalar(l)),p=new three.Vector3,m=new three.Vector3;return p.fromArray(e).sub(d),m.fromArray(e).add(d),new three.Box3(p,m)}getBounds(){const e=this.getProjectionBounds(),t=this.unprojectArrayCoordinate([e.min.x,e.min.y,e.min.z]),i=this.unprojectArrayCoordinate([e.max.x,e.max.y,e.max.z]);return new three.Box3(new three.Vector3(t[0],t[1],t[2]),new three.Vector3(i[0],i[1],i[2]))}setCenter(e){this.setProjectionCenter(e)}setProjectionCenter(e){this.setView(e,{heading:this.getHeading(),pitch:this.getPitch(),roll:this.getRoll()})}setHeading(e){const t=this.getProjectionCenter(),i=this._ellipsoidCamera.position.distanceTo(_tempVector3$6.set(t[0],t[1],t[2]));this.unprojectArrayCoordinate(t,t),_tempVector3$6.fromArray(t),this.lookAt(_tempVector3$6,{heading:e,pitch:this.getPitch(),roll:this.getRoll(),range:i})}setPitch(e){const t=this.getProjectionCenter(),i=this._ellipsoidCamera.position.distanceTo(_tempVector3$6.set(t[0],t[1],t[2]));this.unprojectArrayCoordinate(t,t),_tempVector3$6.fromArray(t),this.lookAt(_tempVector3$6,{heading:this.getHeading(),pitch:e,roll:this.getRoll(),range:i})}setZoom(e){const t=this.getProjectionCenter(),i=this._ellipsoidCamera.directionWC,n=this.getZoomUnitsByZoom(e),[r,s]=this.getContainerSize(),a=s/2*n/Math.tan(three.MathUtils.degToRad(this.fov/2));_tempVector3$6.set(t[0],t[1],t[2]).add(i.clone().normalize().negate().multiplyScalar(.1*a)),this.unprojectArrayCoordinate(_tempVector3$6.toArray(),t),_tempVector3$6.fromArray(t),this.setView(_tempVector3$6,{heading:this.getHeading(),pitch:this.getPitch(),roll:this.getRoll()})}setRange(e){const t=this.getProjectionCenter();this.unprojectArrayCoordinate(t,t),_tempVector3$6.fromArray(t),this.lookAt(_tempVector3$6,{heading:this.getHeading(),pitch:this.getPitch(),roll:this.getRoll(),range:e})}zoomIn(){const e=directionScratch$2.set(this._ellipsoidCamera.directionWC.x,this._ellipsoidCamera.directionWC.y,this._ellipsoidCamera.directionWC.z);let t=this.getRange(),i=.5*three.MathUtils.clamp(t,.5,1e7);i+.2>t&&(i=t-.2);const n=this._ellipsoidCamera.positionWC;_tempVector3$6.set(n.x,n.y,n.z).add(e.normalize().multiplyScalar(i)),this.setView(_tempVector3$6,{heading:this.getHeading(),pitch:this.getPitch(),roll:this.getRoll()})}zoomOut(){const e=directionScratch$2.set(this._ellipsoidCamera.directionWC.x,this._ellipsoidCamera.directionWC.y,this._ellipsoidCamera.directionWC.z);let t=this.getRange(),i=.5*three.MathUtils.clamp(t,.5,1e7);i+.2>t&&(i=t-.2);const n=this._ellipsoidCamera.positionWC;_tempVector3$6.set(n.x,n.y,n.z).add(e.normalize().multiplyScalar(-i)),this.setView(_tempVector3$6,{heading:this.getHeading(),pitch:this.getPitch(),roll:this.getRoll()})}updateView(){this.handleViewChange()}flyTo(e,t={}){const i=this._ellipsoidCamera;directionScratch$2.copy(i.direction),positionScratch$4.copy(i.position),upScratch$1.copy(i.up),rightScratch$1.copy(i.right);const n=new three.Vector3;e instanceof Array?n.set(e[0],e[1],e[2]||0):n.copy(e),n.z=n.z||0,this._ellipsoid.cartographicDegreeToCartesian(n,n),t.heading=defaultValue$1(t.heading,this.getHeading()),t.pitch=defaultValue$1(t.pitch,this.getPitch()),void 0!==t.heading&&(t.heading=three.MathUtils.degToRad(360-t.heading)),void 0!==t.pitch&&(t.pitch=three.MathUtils.degToRad(t.pitch-90)),i.lookAt(n,t);const r={destination:i.position.clone(),orientation:{heading:t.heading,pitch:t.pitch,roll:t.roll},duration:t.duration,complete:t.complete};i.position.copy(positionScratch$4),i.direction.copy(directionScratch$2),i.up.copy(upScratch$1),i.right.copy(rightScratch$1),i.flyTo(r),this.updateView()}lookAt(e,t={}){const i=this._ellipsoidCamera,n=new three.Vector3;e instanceof Array?n.set(e[0],e[1],e[2]||0):n.copy(e),n.z=n.z||0,this._ellipsoid.cartographicDegreeToCartesian(n,n),void 0!==t.heading&&(t.heading=three.MathUtils.degToRad(360-t.heading)),t.pitch=t.pitch||.001,t.pitch=three.MathUtils.degToRad(t.pitch-90),i.lookAt(n,t),this._syncFromEllipsoidCamera(),this.updateView()}setView(e,t={}){const i=this._ellipsoidCamera,n=new three.Vector3;e instanceof Array?n.set(e[0],e[1],e[2]||100):n.copy(e),n.z=n.z||0,n.x>-180&&n.x<180&&n.y>-90&&n.y<90&&this._ellipsoid.cartographicDegreeToCartesian(n,n);const r={destination:n,orientation:t};void 0!==t.heading&&(t.heading=three.MathUtils.degToRad(360-t.heading)),void 0!==t.pitch&&(t.pitch=three.MathUtils.degToRad(t.pitch-90)),void 0!==t.roll&&(t.roll=three.MathUtils.degToRad(t.roll)),i.setView(r),this._syncFromEllipsoidCamera(),this.updateView()}_syncFromEllipsoidCamera(){const e=this.camera,t=this._ellipsoidCamera,i=t.viewMatrix,n=t.inverseViewMatrix;e.matrixWorld.copy(n),e.matrixWorldInverse.copy(i),e.matrixWorld.decompose(e.position,e.quaternion,e.scale)}updateCamera(){this._controller.update();const e=this.camera,t=this._ellipsoidCamera,i=t.viewMatrix,n=t.inverseViewMatrix;e.matrixWorld.copy(n),e.matrixWorldInverse.copy(i),e.matrixWorld.decompose(e.position,e.quaternion,e.scale);const r=e.position.length(),s=r-this._ellipsoid._maximumRadius;let a=r;a=r<20228866?r:r*this._farScale;const[o,l]=this.getContainerSize();e.aspect=o/l,this.near=e.near=Math.min(Math.max(s/1e4,.1),1e3),e.near=this.near,e.far=a,e.fov=this.fov,e.updateProjectionMatrix()}enableControl(){this._controller.enableInputs=!0}disableControl(){this._controller.enableInputs=!1}getViewHeight(){return this._ellipsoidCamera.positionCartographic.z}getCameraLocation(e){e||(e=new three.Vector3);const t=180*this._ellipsoidCamera.positionCartographic.x/Math.PI,i=180*this._ellipsoidCamera.positionCartographic.y/Math.PI,n=this._ellipsoidCamera.positionCartographic.z;return e.set(t,i,n),e}pickSeaLevelWorldPosition(e){return this._ellipsoidCamera.pickEllipsoid(e)}dispose(){this.releaseCanvas(),clear_1(this.domContainer,this.handleMapResize),this.canvas.removeEventListener("contextmenu",this.handleContextMenu)}setInputAction(e,t){this.eventHandler.setInputAction(e,t)}getInputAction(e){return this.eventHandler.getInputAction(e)}removeInputAction(e){this.eventHandler.removeInputAction(e)}get occluder(){return this._occluder}set canvas(e){this._canvas!==e&&(this._canvas=e,this._controller&&(this._controller.destroy(),this._initControl()))}get canvas(){return this._canvas}get farScale(){return this._farScale}set farScale(e){this._farScale=e}get controller(){return this._controller}}class TileQuadtree{constructor(e){this._grid=e,this._root=null,this._tiles={},this._reusedTiles={},this._tilesCount=0}getTileByKey(e){if(this._tiles[e])return this._tiles[e];const[t,i,n]=e.split("-");return this._getOrCreateTile(parseInt(t,10),parseInt(i,10),parseInt(n,10))}getTile(e,t,i,n=!1){const r=e+"-"+t+"-"+i;if(this._tiles[r])return this._tiles[r];let s=this._getOrCreateTile(e,t,i);if(!s&&n&&this._grid.supportLevelReuse){if(s=this._reusedTiles[r],void 0===s){const n=this._grid.getResuedTileConfig(e,t,i);if(n){const[e,t,i,a,o,l,c]=n,h=this._getOrCreateTile(e,t,i);s=this._grid.createSubTile(h,a,o,l,c),this._reusedTiles[r]=s}else this._reusedTiles[r]=null}return s}return s}getTileChildren(e){if(e.children)return e.children;if(e.z>=this._grid.maxLevel)return null;const t=this._grid.createTileChildren(e);return this._invokeTileCreateHook(t),e.children=t,t}_getOrCreateTile(e,t,i){return e>this._grid.maxLevel?null:this._selectOrCreateAncestralTiles(e,t,i,this.root)}isAncestralTile(e,t,i,n){const r=this._grid.getQuadTreeLevelGap(n.z,e);return t>>r===n.x&&i>>r===n.y}_selectOrCreateAncestralTiles(e,t,i,n){for(const r of n){if(r.z===e){if(r.x===t&&r.y===i)return r}else if(r.z>e)return null;if(this.isAncestralTile(e,t,i,r)){const n=this.getTileChildren(r);for(const e of n)this._tiles[e.key]=e,this._tilesCount++;return this._selectOrCreateAncestralTiles(e,t,i,n)}}return null}_invokeTileCreateHook(e){if(this.onTileCreated)for(const t of e)this.onTileCreated(t)}get root(){if(!this._root){this._root=this._grid.getAvailableRootTiles();for(const e of this._root)this._tiles[e.key]=e,this._tilesCount++;this._invokeTileCreateHook(this._root)}return this._root}}function TileBoundingRegion(e){this.rectangle=Rectangle.clone(e.rectangle),this.minimumHeight=defaultValue(e.minimumHeight,0),this.maximumHeight=defaultValue(e.maximumHeight,0),this.southwestCornerCartesian=new three.Vector3,this.northeastCornerCartesian=new three.Vector3,this.westNormal=new three.Vector3,this.southNormal=new three.Vector3,this.eastNormal=new three.Vector3,this.northNormal=new three.Vector3;const t=defaultValue(e.ellipsoid,Ellipsoid.WGS84);computeBox(this,e.rectangle,t),this._orientedBoundingBox=void 0,this._boundingSphere=void 0,defaultValue(e.computeBoundingVolumes,!0)&&this.computeBoundingVolumes(t)}Object.defineProperties(TileBoundingRegion.prototype,{boundingVolume:{get:function(){return this._orientedBoundingBox}},boundingSphere:{get:function(){return this._boundingSphere}}}),TileBoundingRegion.prototype.computeBoundingVolumes=function(e){this._orientedBoundingBox=OrientedBoundingBox.fromRectangle(this.rectangle,this.minimumHeight,this.maximumHeight,e)};const cartesian3Scratch=new three.Vector3,cartesian3Scratch2=new three.Vector3,cartesian3Scratch3=new three.Vector3,westNormalScratch=new three.Vector3,eastWestNormalScratch=new three.Vector3,westernMidpointScratch=new three.Vector3,easternMidpointScratch=new three.Vector3,cartographicScratch=new three.Vector3,planeScratch=new three.Plane(new three.Vector3(1,0,0),0),rayScratch=new three.Ray;function computeBox(e,t,i){i.cartographicToCartesian(Rectangle.southwest(t),e.southwestCornerCartesian),i.cartographicToCartesian(Rectangle.northeast(t),e.northeastCornerCartesian),cartographicScratch.x=t.west,cartographicScratch.y=.5*(t.south+t.north),cartographicScratch.z=0;const n=i.cartographicToCartesian(cartographicScratch,westernMidpointScratch),r=Cartesian3.cross(n,Cartesian3.UNIT_Z,westNormalScratch);Cartesian3.normalize(r,e.westNormal),cartographicScratch.x=t.east;const s=i.cartographicToCartesian(cartographicScratch,easternMidpointScratch),a=Cartesian3.cross(Cartesian3.UNIT_Z,s,cartesian3Scratch);Cartesian3.normalize(a,e.eastNormal);let o=Cartesian3.subtract(n,s,cartesian3Scratch);0===Cartesian3.magnitude(o)&&(o=Cartesian3.clone(r,o));const l=Cartesian3.normalize(o,eastWestNormalScratch),c=t.south;let h;if(c>0){cartographicScratch.x=.5*(t.west+t.east),cartographicScratch.y=c;const n=i.cartographicToCartesian(cartographicScratch,rayScratch.origin);Cartesian3.clone(l,rayScratch.direction);const r=StaticPlane.fromPointNormal(e.southwestCornerCartesian,e.westNormal,planeScratch);IntersectionTests.rayPlane(rayScratch,r,e.southwestCornerCartesian),h=i.geodeticSurfaceNormal(n,cartesian3Scratch2)}else h=i.geodeticSurfaceNormalCartographic(Rectangle.southeast(t),cartesian3Scratch2);const u=Cartesian3.cross(h,o,cartesian3Scratch3);Cartesian3.normalize(u,e.southNormal);const d=t.north;let p;if(d<0){cartographicScratch.x=.5*(t.west+t.east),cartographicScratch.y=d;const n=i.cartographicToCartesian(cartographicScratch,rayScratch.origin);Cartesian3.negate(l,rayScratch.direction);const r=StaticPlane.fromPointNormal(e.northeastCornerCartesian,e.eastNormal,planeScratch);IntersectionTests.rayPlane(rayScratch,r,e.northeastCornerCartesian),p=i.geodeticSurfaceNormal(n,cartesian3Scratch2)}else p=i.geodeticSurfaceNormalCartographic(Rectangle.northwest(t),cartesian3Scratch2);const m=Cartesian3.cross(o,p,cartesian3Scratch3);Cartesian3.normalize(m,e.northNormal)}const southwestCornerScratch=new three.Vector3,northeastCornerScratch=new three.Vector3,negativeUnitY=new three.Vector3(0,-1,0),negativeUnitZ=new three.Vector3(0,0,-1),vectorScratch=new three.Vector3;function distanceToCameraRegion(e,t,i,n,r){const s=t,a=(r=defaultValue(r,Ellipsoid.WGS84)).cartesianToCartographic(t);let o,l,c,h=0;if(!Rectangle.contains(e.rectangle,a)){let t=e.southwestCornerCartesian,r=e.northeastCornerCartesian,a=e.westNormal,o=e.southNormal,l=e.eastNormal,c=e.northNormal;i!==SceneMode.SCENE3D&&(t=n.project(Rectangle.southwest(e.rectangle),southwestCornerScratch),t.z=t.y,t.y=t.x,t.x=0,r=n.project(Rectangle.northeast(e.rectangle),northeastCornerScratch),r.z=r.y,r.y=r.x,r.x=0,a=negativeUnitY,l=Cartesian3.UNIT_Y,o=negativeUnitZ,c=Cartesian3.UNIT_Z);const u=Cartesian3.subtract(s,t,vectorScratch),d=Cartesian3.dot(u,a),p=Cartesian3.dot(u,o),m=Cartesian3.subtract(s,r,vectorScratch),f=Cartesian3.dot(m,l),g=Cartesian3.dot(m,c);d>0?h+=d*d:f>0&&(h+=f*f),p>0?h+=p*p:g>0&&(h+=g*g)}if(i===SceneMode.SCENE3D?(o=a.z,l=e.minimumHeight,c=e.maximumHeight):(o=s.x,l=0,c=0),o>c){const e=o-c;h+=e*e}else if(o<l){const e=l-o;h+=e*e}return Math.sqrt(h)}TileBoundingRegion.prototype.distanceToCamera=function(e,t,i,n){return distanceToCameraRegion(this,e,t,i,n)},TileBoundingRegion.prototype.intersectPlane=function(e){return this._orientedBoundingBox.intersectPlane(e)};class GroundSceneRenderer{constructor(){__publicField(this,"_renderTarget",null),__publicField(this,"_multipleRenderTarget",null),__publicField(this,"_currentRenderTarget",null),this._copyMesh=null}_prepareRenderTarget(e,t){const i=e.rendering.resolution,n=e.rendering.pixelRatio,r=e.rendering.features.antialias.samples;this._renderTarget&&this._renderTarget.samples!==r&&(this._renderTarget.dispose(),this._renderTarget=null),this._renderTarget?t.isResolutionOrPixelRatioChanged&&this._renderTarget.setSize(i.x*n,i.y*n):(this._renderTarget=new three.WebGLRenderTarget(i.x*n,i.y*n,{depthBuffer:!0,stencilBuffer:!1,samples:r}),this._fakeDepthTexture=new three.DataTexture(new Float32Array(4),1,1,three.FloatType));const s=this._copyMesh.material.uniforms;s.tDiffuse.value=this._renderTarget.texture,s.tDepth.value=this._fakeDepthTexture,this._currentRenderTarget=this._renderTarget}_prepareMultipleRenderTarget(e,t){const i=e.rendering.resolution,n=e.rendering.pixelRatio,r=e.rendering.features.antialias.samples;this._multipleRenderTarget&&this._multipleRenderTarget.samples!==r&&(this._multipleRenderTarget.dispose(),this._multipleRenderTarget=null),this._multipleRenderTarget?t.isResolutionOrPixelRatioChanged&&this._multipleRenderTarget.setSize(i.x*n,i.y*n):this._multipleRenderTarget=new three.WebGLRenderTarget(i.x*n,i.y*n,{depthBuffer:!0,stencilBuffer:!1,samples:r,count:2});const s=this._copyMesh.material.uniforms;s.tDiffuse.value=this._multipleRenderTarget.textures[0],s.tDepth.value=this._multipleRenderTarget.textures[1],this._currentRenderTarget=this._multipleRenderTarget}render(e,t,i,n,r){i.overrideMaterial?this._prepareRenderTarget(t,r):this._prepareMultipleRenderTarget(t,r);const s=t.renderer,a=s.getRenderTarget(),o=s.autoClear;s.autoClear=!1,s.setRenderTarget(this._currentRenderTarget),s.clear();const l=r.cameraOffset;e.position.set(-l.x,-l.y,-l.z),e.updateMatrix(),e.updateMatrixWorld(),e.overrideMaterial=i.overrideMaterial,s.render(e,n),e.position.set(0,0,0),e.updateMatrix(),e.updateMatrixWorld(),s.setRenderTarget(a),s.autoClear=o;const c=this._copyMesh.material.uniforms;c.viewMatrix.value.copy(n.matrixWorldInverse),c.projectionMatrix.value.copy(n.projectionMatrix)}get copyMesh(){if(!this._copyMesh){const e=new three.BufferGeometry;e.setAttribute("position",new three.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),e.setAttribute("uv",new three.Float32BufferAttribute([0,2,0,0,2,0],2));const t=new three.ShaderMaterial({name:"GroundSceneCopyShader",vertexShader:"\n                    varying vec2 vUv;\n                    #include <color_pars_vertex>\n                    void main() {\n                        vUv = uv;\n                        gl_Position = vec4(position, 1.0);\n                    }\n                ",fragmentShader:"\n                    #include <packing>\n                    #include <color_pars_fragment>\n                    uniform sampler2D tDiffuse;\n                    uniform sampler2D tDepth;\n                    uniform mat4 projectionMatrix;\n                    uniform float logDepthBufFC;\n                    varying vec2 vUv;\n\n                    void main() {\n                        gl_FragColor = texelFetch(tDiffuse, ivec2(gl_FragCoord.xy), 0);\n                        vec4 depthValue = texelFetch(tDepth, ivec2(gl_FragCoord.xy), 0);\n                        gl_FragDepthEXT = unpackRGBAToDepth(depthValue);\n                        // 半透明区域不写入深度，边缘由于抗锯齿会产生一些半透明区域，深度值会被写入错误值\n                        if (gl_FragColor.a < 0.99) {\n                            gl_FragDepthEXT = 1.0;\n                        }\n\n                        #include <tonemapping_fragment>\n                        #include <colorspace_fragment>\n                    }\n                ",uniforms:{tDiffuse:{value:null},tDepth:{value:null},viewMatrix:{value:new three.Matrix4},projectionMatrix:{value:new three.Matrix4}}});this._copyMesh=new three.Mesh(e,t),this._copyMesh.isFSQuad=!0,this._copyMesh.frustumCulled=!1,this._copyMesh.renderOrder=-1e6}return this._copyMesh}}class Strategy{constructor(e={}){__publicField(this,"_logLoadInCurrentFrame",!1),__publicField(this,"_loadSiblings",!0)}beginFrame(){}endFrame(){this._logLoadInCurrentFrame=!1}computeTiles(e,t,i,n,r){return{selectedTiles:[],requestTilesQueue:[]}}_pushSelectedTile(e,t,i=!1){const n=t.isMeetSSE;t.isMeetSSEChanged=n!==i,t.isMeetSSE=i;t.tile._horizonFactor<.05&&(t.isMeetSSE=!1),e.push(t)}get surface(){return this._surface}}const _MapTileRenderState=class{constructor(){__publicField(this,"state",0)}setInFrustum(){this.state|=_MapTileRenderState.STATE_IN_FRUSTUM}setNotReady(){this.state|=_MapTileRenderState.STATE_NOT_READY}setRendered(){this.state|=_MapTileRenderState.STATE_RENDERED}setChildRendered(){this.state|=_MapTileRenderState.STATE_CHILD_RENDERED}setForceKeep(){this.state|=_MapTileRenderState.STATE_FORCE_KEEP}setRenderReady(){this.state|=_MapTileRenderState.STATE_RENDER_READY}clearInFrustum(){this.state&=~_MapTileRenderState.STATE_IN_FRUSTUM}clearNotReady(){this.state&=~_MapTileRenderState.STATE_NOT_READY}clearRendered(){this.state&=~_MapTileRenderState.STATE_RENDERED}clearChildRendered(){this.state&=~_MapTileRenderState.STATE_CHILD_RENDERED}clearForceKeep(){this.state&=~_MapTileRenderState.STATE_FORCE_KEEP}clearRenderReady(){this.state&=~_MapTileRenderState.STATE_RENDER_READY}isInFrustum(){return 0!==(this.state&_MapTileRenderState.STATE_IN_FRUSTUM)}isNotReady(){return 0!==(this.state&_MapTileRenderState.STATE_NOT_READY)}isRendered(){return 0!==(this.state&_MapTileRenderState.STATE_RENDERED)}isChildRendered(){return 0!==(this.state&_MapTileRenderState.STATE_CHILD_RENDERED)}isForceKeep(){return 0!==(this.state&_MapTileRenderState.STATE_FORCE_KEEP)}isRenderReady(){return 0!==(this.state&_MapTileRenderState.STATE_RENDER_READY)}};let MapTileRenderState=_MapTileRenderState;function boxIntersectsBox(e,t){let i=!1;return e.isOrientedBoundingBox&&t.isOrientedBoundingBox?i=e.intersectsObb(t)||t.intersectsObb(e):e.isOrientedBoundingBox&&t.isBox3?i=_orientedBoundingBoxIntersectsBox3(e,t):e.isBox3&&t.isOrientedBoundingBox?i=_orientedBoundingBoxIntersectsBox3(t,e):e.isBox3&&t.isBox3&&(i=e.intersectsBox(t)),i}function _orientedBoundingBoxIntersectsBox3(e,t){const i=e.computeCorners().map((e=>({x:e.x,y:e.y,z:e.z})));for(const o of i)if(o.x>=t.min.x&&o.x<=t.max.x&&o.y>=t.min.y&&o.y<=t.max.y&&o.z>=t.min.z&&o.z<=t.max.z)return!0;const n=[new three.Vector3(t.min.x,t.min.y,t.min.z),new three.Vector3(t.max.x,t.min.y,t.min.z),new three.Vector3(t.min.x,t.max.y,t.min.z),new three.Vector3(t.max.x,t.max.y,t.min.z),new three.Vector3(t.min.x,t.min.y,t.max.z),new three.Vector3(t.max.x,t.min.y,t.max.z),new three.Vector3(t.min.x,t.max.y,t.max.z),new three.Vector3(t.max.x,t.max.y,t.max.z)];for(const o of n)if(0===e.distanceSquaredTo(o))return!0;const r=[new three.Vector3(1,0,0),new three.Vector3(0,1,0),new three.Vector3(0,0,1)],s=r,a=[...r,...s];for(const o of a){if(!_rangesOverlap(_projectBoundingBox(e,o),_projectBox3(t,o)))return!1}return!0}function _projectBoundingBox(e,t){const i=e.computeCorners();let n=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;for(const s of i){const e=s.dot(t);n=Math.min(n,e),r=Math.max(r,e)}return{min:n,max:r}}function _projectBox3(e,t){const i=[new three.Vector3(e.min.x,e.min.y,e.min.z),new three.Vector3(e.max.x,e.min.y,e.min.z),new three.Vector3(e.min.x,e.max.y,e.min.z),new three.Vector3(e.max.x,e.max.y,e.min.z),new three.Vector3(e.min.x,e.min.y,e.max.z),new three.Vector3(e.max.x,e.min.y,e.max.z),new three.Vector3(e.min.x,e.max.y,e.max.z),new three.Vector3(e.max.x,e.max.y,e.max.z)];let n=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;for(const s of i){const e=s.dot(t);n=Math.min(n,e),r=Math.max(r,e)}return{min:n,max:r}}function _rangesOverlap(e,t){return!(e.max<t.min||t.max<e.min)}__publicField(MapTileRenderState,"STATE_IN_FRUSTUM",1),__publicField(MapTileRenderState,"STATE_NOT_READY",2),__publicField(MapTileRenderState,"STATE_RENDERED",4),__publicField(MapTileRenderState,"STATE_CHILD_RENDERED",8),__publicField(MapTileRenderState,"STATE_FORCE_KEEP",16),__publicField(MapTileRenderState,"STATE_RENDER_READY",32),new three.Raycaster,new three.Plane(new three.Vector3(0,0,1),0),new three.Vector2;const _positionScratch=new three.Vector3,_leftBottomPixel=new three.Vector2(-1,-1),_rightBottomPixel=new three.Vector2(1,-1);new three.Vector2(-.5,-.5),new three.Vector2(.5,-.5),new three.Vector3;const _tempVector2$2=new three.Vector2;let _leftBottomPosition=new three.Vector3,_leftTopPosition=new three.Vector3,_rightBottomPosition=new three.Vector3,_rightTopPosition=new three.Vector3;const _chinaGeoBBox3=new three.Box3(new three.Vector3(74,3,-100),new three.Vector3(135,53,100));class FastTileLoaderStrategy extends Strategy{constructor(e={}){super(e),__publicField(this,"isFastTileLoaderStrategy",!0),__publicField(this,"_renderedTiles",[]),__publicField(this,"_renderedTilesMap",new Map),__publicField(this,"_viewportTilesMap",new Map),__publicField(this,"_lastViewportZLevel",0),__publicField(this,"_hysteresis",null),__publicField(this,"_showDebug",!1),__publicField(this,"_isAncestorTile",((e,t)=>{if(e.z<=t.z)return!1;return this.surface._quadtree.isAncestralTile(e.z,e.x,e.y,t)})),__publicField(this,"_preserveLastFrameChildrenTiles",((e,t,i)=>{const n=this._renderedTiles;let r=0;for(const s of n)if(this._isAncestorTile(s.dataTile,e)){const e=this._surfaceTileManager.getSurfaceTile(s.tile,i);e&&(this._pushSelectedTile(t,e,!1),r++)}return r})),__publicField(this,"_isTileRenderedInLastFrame",(e=>this._renderedTilesMap.has(e.key))),__publicField(this,"_isTileAncestorRenderedInLastFrame",(e=>{for(;e.parent;)if(e=e.parent,this._renderedTilesMap.has(e.key))return!0})),__publicField(this,"_hideChildrenTiles",((e,t,i)=>{let n,r,s=0;for(r=e.length-1;r>=0;r--)n=e[r].dataTile,this._isAncestorTile(n,i)&&(e.splice(r,1),s++);for(r=t.length-1;r>=0;r--)n=t[r],this._isAncestorTile(n,i)&&t.splice(r,1);return s})),__publicField(this,"_traverseViewportTiles",((e,t,i,n,r,s)=>{if(!e)return;const a=this.surface,o=a.engine,{mode:l,mapProjection:c,_ellipsoid:h}=o.map.map,u=o.map.isGlobe;for(const d of n){if(l===SceneMode$1.SCENE3D&&(a.updateTileBoundingRegion(d,s),a._enableHorizonCulling&&a._currentOccluder&&(d._occludeePointInScaledSpace||(d._occludeePointInScaledSpace=a._computeOccludeePoint(d,a._currentOccluder)),d._occludeePointInScaledSpace&&!a._currentOccluder.isScaledSpacePointVisiblePossiblyUnderEllipsoid(d._occludeePointInScaledSpace,0))))continue;if(!a._computeTileVisibility(t,d))continue;let n=!1;if(u?d.boundingRegion&&d.boundingRegion.boundingVolume&&(n=boxIntersectsBox(e,d.boundingRegion.boundingVolume)):n=boxIntersectsBox(e,d.targetBoundingBox),n){const n=a.computeDistanceToTile(d,i,s,l,c,h,!1);d._distance=n;const o=a.screenSpaceError(d)<2,u=d.z>=a._maxLevel;if(d.z>=a._minLevel&&(o||u)){r.push(d);continue}const p=a._quadtree.getTileChildren(d);p.length>0&&this._traverseViewportTiles(e,t,i,p,r,s)}}})),this._restrictViewportLevel=defaultValue$1(e.restrictViewportLevel,!0)}beginFrame(){super.beginFrame()}initDebugMeshes(){if(!this.mesh){const e=new three.SphereGeometry(1,32,32),t=new three.MeshBasicMaterial({color:new three.Color(16711680),transparent:!0,opacity:.9});(this.mesh=new three.Mesh(e,t)).scale.set(50,50,50);const i=new three.MeshBasicMaterial({color:new three.Color(255),transparent:!0,opacity:.9}),n=new three.MeshBasicMaterial({color:new three.Color(65280),transparent:!0,opacity:.9}),r=this.mesh1=new three.Mesh(e,i),s=this.mesh2=new three.Mesh(e,n);r.scale.set(50,50,50),s.scale.set(50,50,50)}}getViewportBounds(e){const t=[],i=e.map.getPitch();let n=this.getNdcYFactor(i);return _leftBottomPosition=e.rendering.picking.pickSeaLevelWorldPositionFromNdc(_leftBottomPixel),_rightBottomPosition=e.rendering.picking.pickSeaLevelWorldPositionFromNdc(_rightBottomPixel),_tempVector2$2.set(-1,n),_leftTopPosition=e.rendering.picking.pickSeaLevelWorldPositionFromNdc(_tempVector2$2),_tempVector2$2.set(1,n),_rightTopPosition=e.rendering.picking.pickSeaLevelWorldPositionFromNdc(_tempVector2$2),_leftBottomPosition&&_rightBottomPosition&&_leftTopPosition&&_rightTopPosition?(this._showDebug&&(this.mesh1.position.copy(_leftTopPosition),this.mesh2.position.copy(_rightTopPosition),this.mesh.scale.setScalar(e.map.getCameraDistance()/100),this.mesh1.scale.setScalar(e.map.getCameraDistance()/100),this.mesh2.scale.setScalar(e.map.getCameraDistance()/100)),t[0]=Math.min(_leftBottomPosition.x,_rightBottomPosition.x,_leftTopPosition.x,_rightTopPosition.x),t[1]=Math.min(_leftBottomPosition.y,_rightBottomPosition.y,_leftTopPosition.y,_rightTopPosition.y),t[2]=Math.min(_leftBottomPosition.z,_rightBottomPosition.z,_leftTopPosition.z,_rightTopPosition.z),t[3]=Math.max(_leftBottomPosition.x,_rightBottomPosition.x,_leftTopPosition.x,_rightTopPosition.x),t[4]=Math.max(_leftBottomPosition.y,_rightBottomPosition.y,_leftTopPosition.y,_rightTopPosition.y),t[5]=Math.max(_leftBottomPosition.z,_rightBottomPosition.z,_leftTopPosition.z,_rightTopPosition.z),new three.Box3(new three.Vector3(t[0],t[1],t[2]),new three.Vector3(t[3],t[4],t[5]))):null}getNdcYFactor(e,t=30,i=.3){if(e<t)return 1;const n=(e-t)/(90-t),r=1-Math.tan(n*Math.PI/2)*i;return Math.max(-.2,Math.min(r,1))}computeTiles(e,t,i,n){const r=this.surface,s=[],a=[],o=[],l=[],c=this._viewportTilesMap;c.clear();const h=e.map.getProjectionCenter();_positionScratch.set(h[0],h[1],h[2]),this._showDebug&&this.mesh.position.copy(_positionScratch);let u=0;if(this._restrictViewportLevel){let s=this.getViewportBounds(e),a=e.map.getViewHeight()>1e6;if(!s&&a&&(s=e.map.projection.projectedBoundingBox),this._traverseViewportTiles(s,i,t,r._quadtree.root,l,n),u=this.calcViewportWeightedZLevel(l,c),a&&r.tileProvider.isBaiduProvider){let t=e.map.projection.geoBoxToProjectedBox(_chinaGeoBBox3);l.forEach((i=>{if(!i.inStrictBounds){let n=!1;e.map.isGlobe?i.boundingRegion&&i.boundingRegion.boundingVolume&&(n=boxIntersectsBox(t,i.boundingRegion.boundingVolume)):n=boxIntersectsBox(t,i.targetBoundingBox),i.inStrictBounds=n}}))}const o=.5;let h,d=defaultValue$1(this._hysteresis,o);Math.abs(u-this._lastViewportZLevel)>d?this._lastViewportZLevel=u:u=this._lastViewportZLevel,u=Math.round(u);for(let e=0;e<l.length;e++)h=l[e],h.z<u&&h.inStrictBounds?h._shouldSplit=!0:h.z===u-1&&(h._shouldSplitOnce=!0)}for(const d of r._quadtree.root)this._computeIntersectTiles(i,t,d,a,s,o,u,n);return this._logLoadInCurrentFrame,this._renderedTiles=a,this._renderedTilesMap=new Map(a.map((e=>[e.dataTile.key,e.dataTile]))),{selectedTiles:a,requestTilesQueue:[[],s],placeholderTiles:o}}calcViewportWeightedZLevel(e,t){const i=this.surface,n=[];let r,s=0;i.engine.map.isGlobe;for(let o=0;o<e.length;o++){r=e[o];const s=i.projectBoundingBoxToNdc(r),a=i.reverseScreenSpaceErrorZ(r),l=this.clipPolygonToViewport(s);if(!l||l.length<3)continue;let c=this.getPolygonArea(l);n.push(c),t.set(r,{z:a,area:c})}const a=n.reduce(((e,t)=>e+t),0);return a<=0||(t.values().forEach((e=>{const t=e.area/a;e.areaProportion=t,e.ratio=t*e.z})),s=t.values().reduce(((e,t)=>e+t.ratio),0)),s}_computeIntersectTiles(e,t,i,n,r,s,a,o){const l=this.surface,c=l.engine,h=l._currentStatistics;h.visited+=1,this._logLoadInCurrentFrame;const u=new MapTileRenderState,{mode:d,mapProjection:p,_ellipsoid:m}=c.map.map;if(d===SceneMode$1.SCENE3D&&l.updateTileBoundingRegion(i,o),!l._computeTileVisibility(e,i))return this._logLoadInCurrentFrame,u;u.setInFrustum(),this._surfaceTileManager.markTileUsed(i),h.used++;let f=l.computeDistanceToTile(i,t,o,d,p,m,!1);i._distance=f;const g=this._surfaceTileManager.isTileRenderable(i,o);let _=l.screenSpaceError(i)<2&&!i._shouldSplit&&!i._shouldSplitOnce,A=i.z>=l._maxLevel||i.z>=a&&a>0;if(i.z>=l._minLevel&&(A||_)){const e=this._surfaceTileManager.getSurfaceTile(i,o);if(g)return this._logLoadInCurrentFrame,this._pushSelectedTile(n,e,!i.overMeetSse),delete i.overMeetSse,h.rendered+=1,u.setRendered(),u.setRenderReady(),u;this._logLoadInCurrentFrame,r.push(i),s.push(i),h.request+=1,u.setNotReady();const t=this._preserveLastFrameChildrenTiles(i,n,o);return t>0&&(this._logLoadInCurrentFrame,h.rendered+=t,u.setForceKeep(),u.setRenderReady()),u}const v=l._quadtree.getTileChildren(i);if(i.z===l._minLevel-1&&_)for(const x of v)x.overMeetSse=!0;if(delete i._shouldSplitOnce,i._shouldSplit){delete i._shouldSplit;for(const e of v)e.z<a?e._shouldSplit=!0:delete e._shouldSplit}i.childrenInFrustum=[];let y=!0;for(const x of v){x.parent=i;let l=this._computeIntersectTiles(e,t,x,n,r,s,a,o);l.isInFrustum()&&(i.childrenInFrustum.push(x),l.isForceKeep()&&u.setForceKeep(),l.isRenderReady()?u.setRenderReady():y=!1,l.isRendered())}if(u.isForceKeep())return u;if(!y){let e=!1;if(this._isTileRenderedInLastFrame(i)?(e=!0,g&&(this._logLoadInCurrentFrame,this._pushSelectedTile(n,this._surfaceTileManager.getSurfaceTile(i,o),!1),h.rendered+=1,u.setRenderReady(),u.setRendered())):this._isTileAncestorRenderedInLastFrame(i)&&(e=!0,u.clearRenderReady()),e){const e=this._hideChildrenTiles(n,s,i);h.rendered-=e}}return u}clipPolygonToViewport(e){if(!e||e.length<3)return null;const t=[{x:-1,y:0,isVertical:!0},{x:1,y:0,isVertical:!0},{x:0,y:-1,isVertical:!1},{x:0,y:1,isVertical:!1}];let i=e.slice();for(let n=0;n<t.length;n++){const e=t[n],r=i;if(i=[],0===r.length)return null;for(let t=0;t<r.length;t++){const n=r[t],s=r[(t+1)%r.length],a=this._isInsideEdge(n,e),o=this._isInsideEdge(s,e);if(a&&o)i.push(s);else if(a&&!o){const t=this._computeIntersection(n,s,e);t&&i.push(t)}else if(!a&&o){const t=this._computeIntersection(n,s,e);t&&i.push(t),i.push(s)}}}return i.length>=3?i:null}_isInsideEdge(e,t){const[i,n]=e;return t.isVertical?t.x<0?i>=t.x:i<=t.x:t.y<0?n>=t.y:n<=t.y}_computeIntersection(e,t,i){const[n,r]=e,[s,a]=t;if(i.isVertical){if(Math.abs(s-n)<1e-10)return null;const e=(i.x-n)/(s-n);return e<0||e>1?null:[i.x,r+e*(a-r)]}if(Math.abs(a-r)<1e-10)return null;const o=(i.y-r)/(a-r);return o<0||o>1?null:[n+o*(s-n),i.y]}getPolygonArea(e){let t=0;const i=e.length;for(let n=0;n<i;n++){const[r,s]=e[n],[a,o]=e[(n+1)%i];t+=r*o-a*s}return Math.abs(t)/2}set showDebug(e){if(!this.surface.engine)return;const t=this.surface.engine;this.initDebugMeshes(),e?(t.add(this.mesh1),t.add(this.mesh2),t.add(this.mesh)):(t.remove(this.mesh1),t.remove(this.mesh2),t.remove(this.mesh)),this._showDebug=e}get showDebug(){return this._showDebug}set restrictViewportLevel(e){this._restrictViewportLevel=e}get restrictViewportLevel(){return this._restrictViewportLevel}}class HierarchicalTileLoaderStrategy extends Strategy{constructor(){super(...arguments),__publicField(this,"isHierarchicalTileLoaderStrategy",!0),__publicField(this,"_computeHierarchicalIntersectTiles",((e,t,i,n,r,s,a,o,l)=>{const c=this.surface,h=c.engine,u=c._currentStatistics;u.visited+=1,this._logLoadInCurrentFrame;const{mode:d,mapProjection:p,_ellipsoid:m}=h.map.map;let f=c.computeDistanceToTile(i,e,l,d,p,m);i._distance=f;if(!this._surfaceTileManager.isTileComputable(i,l))return this._logLoadInCurrentFrame,o.push(i),!1;const g=this._surfaceTileManager.isTileRenderable(i,l),_=this._surfaceTileManager.isTileStable(i,l);if(!g)return this._logLoadInCurrentFrame,r.push(i),!1;u.used+=1,this._surfaceTileManager.markTileUsed(i);let A=c.screenSpaceError(i)<2;if(i.z>=c._minLevel&&(A||i.z>=c._maxLevel)){_||(r.push(i),u.request+=1,this._logLoadInCurrentFrame);const e=this._surfaceTileManager.getSurfaceTile(i,l);return n.push(e),this._logLoadInCurrentFrame,u.rendered+=1,!0}_||(this._logLoadInCurrentFrame,a.push(i));const v=c._quadtree.getTileChildren(i);if(!v||0===v.length){const e=this._surfaceTileManager.getSurfaceTile(i,l);return n.push(e),this._logLoadInCurrentFrame,u.rendered+=1,!0}let y=!0;const x=[];for(const b of v)if(d===SceneMode$1.SCENE3D&&c.updateTileBoundingRegion(b,l),c._computeTileVisibility(t,b))this._surfaceTileManager.isTileComputable(b,l)||(y=!1,this._logLoadInCurrentFrame),this._logLoadInCurrentFrame,x.push(b),this._surfaceTileManager.markTileUsed(b);else{if(this._logLoadInCurrentFrame,!this._loadSiblings)continue;this._surfaceTileManager.markTileUsed(b),u.used++,this._surfaceTileManager.isTileComputable(b,l)||(s.push(b),this._logLoadInCurrentFrame)}if(y){for(const i of x)this._computeHierarchicalIntersectTiles(e,t,i,n,r,s,a,o,l);this._logLoadInCurrentFrame}else{let e;this._logLoadInCurrentFrame,e=d===SceneMode$1.SCENE3D?h.map.map._ellipsoidCamera.positionCartographic:h.map.unprojectArrayCoordinate(h.camera.position.toArray());let t=v;4===v.length&&(t=c._naturalOrderChildTiles(v,e)),this._logLoadInCurrentFrame,t=t.filter((e=>x.includes(e))),t.forEach((e=>{this._surfaceTileManager.isTileComputable(e,l)||(this._logLoadInCurrentFrame,o.push(e),u.visited+=1,u.request+=1,this._logLoadInCurrentFrame)}));const r=this._surfaceTileManager.getSurfaceTile(i,l);n.push(r),u.rendered+=1,u.unstable+=1,this._logLoadInCurrentFrame}return!0}))}computeTiles(e,t,i,n){const r=this.surface,s=[],a=[],o=[],l=[],c=[];for(const h of r._quadtree.root){this._surfaceTileManager.isTileRenderable(h,n)?this._computeHierarchicalIntersectTiles(t,i,h,s,o,c,l,a,n):o.push(h)}return this._logLoadInCurrentFrame,{selectedTiles:s,requestTilesQueue:[a,o,l,c],placeholderTiles:[]}}}const vertexShader$o="#define GLSLIFY 1\n#include <common>\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\n#if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)\nattribute float layerIndex;\nvarying float vLayerIndex;\n#endif\n\nvoid main() {\n\n\tvUv = uv;\n\n    #include <begin_vertex>\n    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n\n    #if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)\n        vLayerIndex = layerIndex;\n    #endif\n\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n\n    #include <logdepthbuf_vertex>\n}\n\n",fragmentShader$m="#define GLSLIFY 1\n#include <common>\n#include <packing>\n\nvarying vec2 vUv;\nuniform vec3 color;\nuniform vec3 borderColor;\nuniform sampler2D map;\n\n#include <logdepthbuf_pars_fragment>\n#include <mvt_depth_range_pars_fragment>\n\nvoid main() {\n\n    vec4 diffuseColor = vec4(color, 1.0);\n    vec4 diffuseMap = texture2D(map, vUv);\n    if (diffuseMap.a > 0.1) {\n        diffuseMap.rgb = borderColor;\n    }\n\n    gl_FragColor.rgb = mix(diffuseColor, diffuseMap, diffuseMap.a).rgb;\n    gl_FragColor.a = 1.0;\n\n    // if (gl_FragColor.a <= 0.) {\n    //     discard;\n    // }\n\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n    #include <mvt_depth_range_fragment>\n}\n\n",uniforms$n=three.UniformsUtils.merge([{color:{value:[.95,.95,.95]},borderColor:{value:[.5,.5,.5]},vertexZIndexLegacy:{value:!1},isEmissive:{value:!1},depthRange:{value:new three.Vector2(0,1)},map:{value:null}}]);class PlaceholderMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="PlaceholderMaterial",this.type="PlaceholderMaterial",this.isPlaceholderMaterial=!0,this.transparent=!1,this.fragmentShader=fragmentShader$m,this.vertexShader=vertexShader$o,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$n)),defineMaterialNormalProperties(this,["isEmissive","map","depthRange"]),defineMaterialColorProperties(this,["color","borderColor"]),defineMaterialBoolDefineProperties(this,[["vertexZIndexLegacy","MVT_USE_VERTEX_ZINDEX_LEGACY"],["enableDepthRange","MVT_USE_DEPTH_RANGE"]]),this.setValues(e)}}const scratchCartographic$1=new three.Vector3,scratchCartesian$1=new three.Vector3,scratchProjectPointOntoPlaneRay=new three.Ray,scratchProjectPointOntoPlaneRayDirection=new three.Vector3,scratchProjectPointOntoPlaneCartesian3=new three.Vector3,_Stereographic=class{constructor(e,t){this.position=e,this.position||(e=new three.Vector2),this.tangentPlane=t,this.tangentPlane||(this.tangentPlane=_Stereographic.NORTH_POLE_TANGENT_PLANE)}getLatitude(e){e||(e=Ellipsoid.WGS84),scratchCartographic$1.x=this.longitude,scratchCartographic$1.y=this.conformalLatitude,scratchCartographic$1.z=0;const t=this.ellipsoid.cartographicToCartesian(scratchCartographic$1,scratchCartesian$1);return e.cartesianToCartographic(t,scratchCartographic$1),scratchCartographic$1.y}static fromCartesian(e,t){const i=e.z<0?-1:1;let n=_Stereographic.NORTH_POLE_TANGENT_PLANE,r=_Stereographic.SOUTH_POLE;i<0&&(n=_Stereographic.SOUTH_POLE_TANGENT_PLANE,r=_Stereographic.NORTH_POLE);const s=scratchProjectPointOntoPlaneRay;s.origin=n.ellipsoid.scaleToGeocentricSurface(e,s.origin),s.direction=Cartesian3.subtract(s.origin,r,scratchProjectPointOntoPlaneRayDirection),Cartesian3.normalize(s.direction,s.direction);const a=IntersectionTests.rayPlane(s,n.plane,scratchProjectPointOntoPlaneCartesian3),o=Cartesian3.subtract(a,r,a),l=Cartesian3.dot(n.xAxis,o),c=i*Cartesian3.dot(n.yAxis,o);return t?(t.position=new three.Vector2(l,c),t.tangentPlane=n,t):new _Stereographic(new three.Vector2(l,c),n)}clone(e){return _Stereographic.clone(this,e)}static clone(e,t){if(e)return t?(t.position=e.position,t.tangentPlane=e.tangentPlane,t):new _Stereographic(e.position,e.tangentPlane)}get ellipsoid(){return this.tangentPlane.ellipsoid}get x(){return this.position.x}get y(){return this.position.y}get conformalLatitude(){const e=this.position.length(),t=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(CesiumMath.PI_OVER_TWO-2*Math.atan2(e,t))}get longitude(){let e=CesiumMath.PI_OVER_TWO+Math.atan2(this.y,this.x);return e>Math.PI&&(e-=CesiumMath.TWO_PI),e}};let Stereographic=_Stereographic;__publicField(Stereographic,"HALF_UNIT_SPHERE",Object.freeze(new Ellipsoid(.5,.5,.5))),__publicField(Stereographic,"NORTH_POLE",Object.freeze(new three.Vector3(0,0,.5))),__publicField(Stereographic,"SOUTH_POLE",Object.freeze(new three.Vector3(0,0,-.5))),__publicField(Stereographic,"NORTH_POLE_TANGENT_PLANE",Object.freeze(new EllipsoidTangentPlane(_Stereographic.NORTH_POLE,_Stereographic.HALF_UNIT_SPHERE))),__publicField(Stereographic,"SOUTH_POLE_TANGENT_PLANE",Object.freeze(new EllipsoidTangentPlane(_Stereographic.SOUTH_POLE,_Stereographic.HALF_UNIT_SPHERE)));const scratchPolar=new Stereographic,scratchPolarPrevious=new Stereographic,polygon={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0},scratchCartesian0=new three.Vector2,scratchCartesian1=new three.Vector2,scratchPolarClosest=new Stereographic;new three.Vector2;const expandRectangle=(e,t,i,n,r)=>{const s=e.longitude,a=s>=0?s:s+CesiumMath.TWO_PI;n.westOverIdl=Math.min(n.westOverIdl,a),n.eastOverIdl=Math.max(n.eastOverIdl,a),r.west=Math.min(r.west,s),r.east=Math.max(r.east,s);const o=e.getLatitude(i);let l=o;r.south=Math.min(r.south,o),r.north=Math.max(r.north,o);const c=Cartesian2.subtract(t.position,e.position,scratchCartesian0),h=Cartesian2.dot(t.position,c)/Cartesian2.dot(c,c);if(h>0&&h<1){const e=Cartesian2.add(t.position,Cartesian2.multiplyByScalar(c,-h,c),scratchCartesian1),n=Stereographic.clone(t,scratchPolarClosest);n.position=e;const s=n.getLatitude(i);r.south=Math.min(r.south,s),r.north=Math.max(r.north,s),Math.abs(o)>Math.abs(s)&&(l=s)}const u=t.x*e.y-e.x*t.y;let d=Math.sign(u);0!==d&&(d*=Cartesian2.angleBetween(t.position,e.position)),l>=0&&(n.northAngle+=d),l<=0&&(n.southAngle+=d)},computeRectangleFromPositions=(e,t,i)=>{if(i||(i=new Rectangle),e.length<3)return i;i.west=Number.POSITIVE_INFINITY,i.east=Number.NEGATIVE_INFINITY,i.south=Number.POSITIVE_INFINITY,i.north=Number.NEGATIVE_INFINITY,polygon.northAngle=0,polygon.southAngle=0,polygon.westOverIdl=Number.POSITIVE_INFINITY,polygon.eastOverIdl=Number.NEGATIVE_INFINITY;const n=e.length;let r=Stereographic.fromCartesian(new three.Vector3(...e[0]),scratchPolarPrevious);for(let s=1;s<n;s++){const n=Stereographic.fromCartesian(new three.Vector3(...e[s]),scratchPolar);expandRectangle(n,r,t,polygon,i),r=Stereographic.clone(n,r)}return expandRectangle(Stereographic.fromCartesian(new three.Vector3(...e[0]),scratchPolar),r,t,polygon,i),i.east-i.west>polygon.eastOverIdl-polygon.westOverIdl&&(i.west=polygon.westOverIdl,i.east=polygon.eastOverIdl,i.east>CesiumMath.PI&&(i.east=i.east-CesiumMath.TWO_PI),i.west<CesiumMath.PI&&(i.west=i.west+CesiumMath.TWO_PI)),CesiumMath.equalsEpsilon(Math.abs(polygon.northAngle),CesiumMath.TWO_PI,CesiumMath.EPSILON10)&&(i.north=CesiumMath.PI_OVER_TWO,i.east=CesiumMath.PI,i.west=-CesiumMath.PI),CesiumMath.equalsEpsilon(Math.abs(polygon.southAngle),CesiumMath.TWO_PI,CesiumMath.EPSILON10)&&(i.south=-CesiumMath.PI_OVER_TWO,i.east=CesiumMath.PI,i.west=-CesiumMath.PI),i},createTangentPlane=(e,t)=>{let i=e[0][0],n=e[0][1],r=e[0][2],s=e[0][0],a=e[0][1],o=e[0][2];const l=e.length;for(let h=0;h<l;h++){const t=e[h],l=t[0],c=t[1],u=t[2];i=Math.min(l,i),n=Math.min(c,n),r=Math.min(u,r),s=Math.max(l,s),a=Math.max(c,a),o=Math.max(u,o)}const c=new three.Vector3((i+s)/2,(n+a)/2,(r+o)/2);return new EllipsoidTangentPlane(c,t)},createProjectTo2D=(e,t,i)=>{if(e.height>=CesiumMath.PI||e.width>=CesiumMath.PI)return;const n=t.map((e=>new three.Vector3(...e)));return createTangentPlane(t,i).projectPointsOntoPlane(n)};function sortPolygonPoints(e){if(e.length<3)throw new Error("点的数量必须大于等于3个才能形成多边形");const t=calculateCentroid(e),i=e.map(((e,i)=>({index:i,angle:Math.atan2(e.y-t.y,e.x-t.x)})));return i.sort(((e,t)=>e.angle-t.angle)),i.map((e=>e.index))}function calculateCentroid(e,t){t||(t=new three.Vector2);const i=e.length;let n=0,r=0;return e.forEach((e=>{n+=e.x,r+=e.y})),t.set(n/i,r/i)}function getLineIntersection(e,t,i,n,r,s){const a=e.x,o=e.y,l=t.x,c=t.y,h=i.x,u=i.y,d=n.x,p=n.y,m=(a-l)*(u-p)-(o-c)*(h-d);if(Math.abs(m)<1e-4)return null;const f=((a-h)*(u-p)-(o-u)*(h-d))/m,g=-((a-l)*(o-u)-(o-c)*(a-h))/m;return f>=0&&f<=1&&g>=0&&g<=1?{point:e.clone().lerp(t,f),uv:r.clone().lerp(s,f)}:null}function isPointInTriangle(e,t,i,n){const r=i.x-t.x,s=i.y-t.y,a=n.x-t.x,o=n.y-t.y,l=e.x-t.x,c=e.y-t.y,h=r*o-s*a,u=(l*o-c*a)/h,d=(r*c-s*l)/h;return u>=0&&d>=0&&u+d<=1}function isPointInRectangle(e,t,i,n,r){return e.x>=t&&e.x<=i&&e.y>=n&&e.y<=r}function getRectanglePoints(e,t,i,n){return[new three.Vector3(e,i,0),new three.Vector3(t,i,0),new three.Vector3(t,n,0),new three.Vector3(e,n,0)]}function getRectangleEdges(e){return[[e[0],e[1]],[e[1],e[2]],[e[2],e[3]],[e[3],e[0]]]}function calculateIntersection(e,t,i){const n=[];e.forEach(((e,r)=>{if(isPointInRectangle(e,i[0].x,i[2].x,i[0].y,i[2].y)){const i=e.x+","+e.y+","+e.z;n[i]||(n[i]={point:e,uv:t[r]})}}));const r=Math.min(e[0].x,Math.min(e[1].x,e[2].x)),s=Math.max(e[0].x,Math.max(e[1].x,e[2].x)),a=Math.min(e[0].y,Math.min(e[1].y,e[2].y)),o=Math.max(e[0].y,Math.max(e[1].y,e[2].y)),l=Math.min(t[0].x,Math.min(t[1].x,t[2].x)),c=Math.max(t[0].x,Math.max(t[1].x,t[2].x)),h=Math.min(t[0].y,Math.min(t[1].y,t[2].y)),u=Math.max(t[0].y,Math.max(t[1].y,t[2].y)),d=s-r,p=o-a,m=c-l,f=u-h;i.forEach((t=>{if(isPointInTriangle(t,...e)){const e=t.x+","+t.y+","+t.z;if(!n[e]){const i=l+m*(t.x-r)/d,s=h+f*(t.y-a)/p;n[e]={point:t,uv:new three.Vector2(i,s)}}}}));const g=getRectangleEdges(i);return[[0,1],[1,2],[2,0]].forEach((([i,r])=>{g.forEach((([s,a])=>{const o=getLineIntersection(e[i],e[r],s,a,t[i],t[r]);if(o){const{point:e}=o,t=e.x+","+e.y+","+e.z;n[t]||(n[t]=o)}}))})),Object.values(n)}const subdivisionV0Scratch$1=new three.Vector3,subdivisionV1Scratch$1=new three.Vector3,subdivisionV2Scratch$1=new three.Vector3;new three.Vector3,new three.Vector3,new three.Vector3;const subdivisionMidScratch$1=new three.Vector3,subdivisionT0Scratch$1=new three.Vector2,subdivisionT1Scratch$1=new three.Vector2,subdivisionT2Scratch$1=new three.Vector2,subdivideWithRange=(e,t,i,n,r,s,a,o,l)=>{const c=[];for(let m=0;m<e.length;m++){const t=e[m];l[`${t.x},${t.y},${t.z}`]=i[m];isPointInRectangle(t,o[0],o[1],o[0],o[1])&&c.push(m)}if(3===c.length)return!1;const h=getRectanglePoints(o[0],o[1],o[0],o[1]),u=calculateIntersection([e[0],e[1],e[2]],t,h),d=u.map((e=>e.point)),p=u.map((e=>e.uv));if(d.length>2){const e=sortPolygonPoints(d),t=[];for(let i=0,a=e.length;i<a;i++){const a=e[i],o=d[a],c=p[a],h=`${o.x},${o.y},${o.z}`;defined$2(l[h])||(r.push(o.x,o.y,o.z),n&&s.push(c.x,c.y),l[h]=r.length/3-1);const u=l[h];t.push(u)}3===d.length?a.push(t[1],t[2],t[0]):4===d.length?a.push(t[2],t[3],t[0],t[0],t[1],t[2]):5===d.length&&a.push(t[3],t[4],t[0],t[0],t[1],t[2],t[2],t[3],t[0])}return!0},subdivideMesh=(e,t,i,n,r=0,s=[-.501,.501])=>{const a=!!i,o=Array.from(t);let l=0;const c=e.length;let h=null,u=null;if(Array.isArray(e[0])){h=[];let t=0;for(l=0;l<c;l++){const i=e[l];h[t++]=i[0],h[t++]=i[1],h[t++]=i[2]}}else h=e.slice(0);if(a){if(Array.isArray(i[0])){u=[];let e=0;for(l=0;l<i.length;l++){const t=i[l];u[e++]=t[0],u[e++]=t[1]}}else u=i.slice(0)}const d=[],p={},m={},f=n*n;for(;o.length>0;){const e=o.pop(),t=o.pop(),i=o.pop(),n=subdivisionV0Scratch$1.fromArray(h,3*i),c=subdivisionV1Scratch$1.fromArray(h,3*t),g=subdivisionV2Scratch$1.fromArray(h,3*e);let _,A,v;a&&(_=subdivisionT0Scratch$1.fromArray(u,2*i),A=subdivisionT1Scratch$1.fromArray(u,2*t),v=subdivisionT2Scratch$1.fromArray(u,2*e));const y=Cartesian3.magnitudeSquared(Cartesian3.subtract(n,c,subdivisionMidScratch$1)),x=Cartesian3.magnitudeSquared(Cartesian3.subtract(c,g,subdivisionMidScratch$1)),b=Cartesian3.magnitudeSquared(Cartesian3.subtract(g,n,subdivisionMidScratch$1)),S=Math.max(y,x,b);let C,T,E;if(S>f)y===S?(C=`${Math.min(i,t)} ${Math.max(i,t)}`,l=p[C],null==l&&(T=Cartesian3.add(n,c,subdivisionMidScratch$1),Cartesian3.multiplyByScalar(T,.5,T),h.push(T.x,T.y,T.z),l=h.length/3-1,p[C]=l,a&&(E=Cartesian2.add(_,A,subdivisionMidScratch$1),Cartesian2.multiplyByScalar(E,.5,E),u.push(E.x,E.y))),o.push(i,l,e),o.push(l,t,e)):x===S?(C=`${Math.min(t,e)} ${Math.max(t,e)}`,l=p[C],l||(T=Cartesian3.add(c,g,subdivisionMidScratch$1),Cartesian3.multiplyByScalar(T,.5,T),h.push(T.x,T.y,T.z),l=h.length/3-1,p[C]=l,a&&(E=Cartesian2.add(A,v,subdivisionMidScratch$1),Cartesian2.multiplyByScalar(E,.5,E),u.push(E.x,E.y))),o.push(t,l,i),o.push(l,e,i)):b===S&&(C=`${Math.min(e,i)} ${Math.max(e,i)}`,l=p[C],l||(T=Cartesian3.add(g,n,subdivisionMidScratch$1),Cartesian3.multiplyByScalar(T,.5,T),h.push(T.x,T.y,T.z),l=h.length/3-1,p[C]=l,a&&(E=Cartesian2.add(v,_,subdivisionMidScratch$1),Cartesian2.multiplyByScalar(E,.5,E),u.push(E.x,E.y))),o.push(e,l,t),o.push(l,i,t));else{if(subdivideWithRange([n,c,g],[_,A,v],[i,t,e],a,h,u,o,s,m))continue;d.push(i+r),d.push(t+r),d.push(e+r)}}return{vertices:h,uvs:u,indices:d}},_pointIn=new three.Vector3,_pointOut=new three.Vector3,reprojectCoordinate=(e,t,i,n,r,s)=>{let a=CoordTransformer.canTransform(e,t);return i!==n&&i&&n||a?(i.unprojectCoordinate(r,_pointOut),a?CoordTransformer.transform(e,t,_pointOut,_pointIn):_pointIn.copy(_pointOut),n.projectCoordinate(_pointIn,s),s):(s.copy(r),s)},projectVertices=(e,t,i=!0,n=!0,r=!1)=>{if(!t.forceProjectCoordinates&&!r&&t.targetProjectionName===t.sourceProjectionName)return;const s=t.sourceProjection,a=t.targetProjection,o=t.sourceCoordType,l=t.targetCoordType,[c,h,u]=t.targetCenter,d=t.forceUseGeoBoundingBox||s.isGeo,p=d?t.geoBoundingBox:t.projectedBoundingBox;let m,f,g,_;if(p.isBox3){const e=p.min,t=p.max;m=e.x,f=e.y,g=t.x,_=t.y}else[m,f,,g,_]=p;const A=g-m,v=_-f;if(i)for(let y=0,x=e.length-2;y<x;y+=3){const t=e[y],i=e[y+1],r=e[y+2];_pointIn.set(m+(t+.5)*A,f+(i+.5)*v,r),d?(o!==l&&CoordTransformer.transform(o,l,_pointIn,_pointIn),a.projectCoordinate(_pointIn,_pointOut)):reprojectCoordinate(o,l,s,a,_pointIn,_pointOut),e[y]=_pointOut.x,e[y+1]=_pointOut.y,e[y+2]=_pointOut.z,n&&(e[y]-=c,e[y+1]-=h,e[y+2]-=u)}else for(let y=0,x=e.length;y<x;y+=1){const t=e[y],i=t[0],r=t[1],p=t[2];_pointIn.set(m+(i+.5)*A,f+(r+.5)*v,p),d?(o!==l&&CoordTransformer.transform(o,l,_pointIn,_pointIn),a.projectCoordinate(_pointIn,_pointOut)):reprojectCoordinate(o,l,s,a,_pointIn,_pointOut),t[0]=_pointOut.x,t[1]=_pointOut.y,t[2]=_pointOut.z,n&&(t[0]-=c,t[1]-=h,t[2]-=u)}},subdivideVertices=(e,t,i,n)=>{if(n.sourceProjectionName===n.targetProjectionName)return{vertices:e,indices:t,uvs:i};const r=Math.max(2,16-n.z);return subdivideMesh(e,t,i,1/r)},computeNormals=(e,t=3,i=0)=>{const{vertices:n,indices:r}=e,s=n.length/t,a=new Array(3*s).fill(0),o=new Array(s).fill(0);for(let l=0;l<r.length;l+=3){const e=r[l],s=r[l+1],c=r[l+2],h=n[e*t+i],u=n[e*t+i+1],d=n[e*t+i+2],p=n[s*t+i]-h,m=n[s*t+i+1]-u,f=n[s*t+i+2]-d,g=n[c*t+i]-h,_=n[c*t+i+1]-u,A=n[c*t+i+2]-d,v=m*A-f*_,y=f*g-p*A,x=p*_-m*g;a[3*e]+=v,a[3*e+1]+=y,a[3*e+2]+=x,o[e]++,a[3*s]+=v,a[3*s+1]+=y,a[3*s+2]+=x,o[s]++,a[3*c]+=v,a[3*c+1]+=y,a[3*c+2]+=x,o[c]++}for(let l=0;l<s;l++){const e=o[l];if(e>0){let t=a[3*l]/e,i=a[3*l+1]/e,n=a[3*l+2]/e;const r=Math.sqrt(t*t+i*i+n*n);if(r>0){const e=1/r;t*=e,i*=e,n*=e}else t=0,i=0,n=1;a[3*l]=t,a[3*l+1]=i,a[3*l+2]=n}}e.normals=a},createGroundTileMesh=(e,t,i=!0)=>{const{vertices:n,uvs:r,indices:s}=subdivideVertices([-.5,-.5,0,-.5,.5,0,.5,.5,0,.5,-.5,0],[0,2,1,0,3,2],[0,0,0,1,1,1,1,0],e);projectVertices(n,e);const a={vertices:n,uvs:r,indices:s};if(t){const e=n.length/3;for(const i of Object.keys(t)){const n=t[i],r=Array.isArray(n),s=r?n.length:1,o=[];if(r)for(let t=0;t<e;t++)for(let e=0;e<s;e++)o.push(n[e]);else for(let t=0;t<e;t++)o.push(n);a[i]=o}}return i&&computeNormals(a),a},textureLoader$7=new three.TextureLoader;let textureUrl="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAUdJREFUeNrs2sENwyAQRcE4ckf0RBv04Z7ck30wFXBi/4wU5bScXhQk9hhj9B+xzu/7WjijvZ/b/Jbz/e83kE0AAkAACAABIAAEgAAQAAJAAAgAAVDYfA5ui+eY33R+BuA9PXO++QtwB0AACAABIAAEgAAQAAJAAAgAASAAqrIPED5vH8A+AO4ACAABIAAEgAAQAAJAAAgAASAABEBJ9gHC5+0D2AfAHQABIAAEgAAQAAJAAAgAASAABIAAKMk+QPi8fQD7ALgDIAAEgAAQAAJAAAgAASAABIAAEAAl2QcIn7cPYB8AdwAEgAAQAAJAAAgAASAABIAAEAACoCT7AOHz9gHsA+AOgAAQAAJAAAgAASAABIAAEAACQACUZB8gfN4+gH0A3AEQAAJAAAgAASAABIAAEAACQABUNV8D++I5nmM3nX8EGADa0U/2xPbBVwAAAABJRU5ErkJggg==",texture$1=null;class Placeholder{constructor(e={},t){if(__publicField(this,"_maxCacheSize",1e3),__publicField(this,"handleRemove",((e,t)=>{e.geometry.dispose()})),this._cache=new LRUCache$1({max:this._maxCacheSize,onRemove:this.handleRemove}),!texture$1){const i=defaultValue$1(e.backgroundColor,defaultValue$1(t,16382457)),n=defaultValue$1(e.borderColor,13224393);let r;texture$1=textureLoader$7.load(textureUrl),r=i instanceof three.Color?new three.Color(i.r,i.g,i.b):new three.Color(i),this._material=new PlaceholderMaterial({color:r,borderColor:new three.Color(n),map:texture$1,enableDepthRange:!0,depthRange:new three.Vector2(1,1)})}}createMesh(e){let t=null;const i=e.grid.targetProjection;if(i.isAxisAligned)return this._geometry||(this._geometry=new three.PlaneGeometry(1,1)),t=new three.Mesh(this._geometry,this._material),t.position.copy(e.targetCenter),e.targetBoundingBox.getSize(t.scale),t;const n={x:e.x,y:e.y,z:e.z,targetProjection:i,sourceProjection:e.grid.sourceProjection,targetProjectionName:i.name,sourceProjectionName:e.grid.sourceProjection.name,targetCenter:e.targetCenter.toArray(),geoBoundingBox:e.availableGeoBoundingBox,forceUseGeoBoundingBox:!0,forceProjectCoordinates:!0,projectedBoundingBox:e.projectedBoundingBox.isBox3?e.projectedBoundingBox:[]},r=createGroundTileMesh(n,{layerIndices:0}),s=new three.BufferGeometry;return s.setIndex(r.indices),s.setAttribute("position",new three.BufferAttribute(new Float32Array(r.vertices),3)),s.setAttribute("layerIndex",new three.BufferAttribute(new Float32Array(r.layerIndices),1)),s.setAttribute("uv",new three.BufferAttribute(new Float32Array(r.uvs),2)),t=new three.Mesh(s,this._material),t.position.copy(e.targetCenter),t}get(e){let t=this._cache.get(e.key);return t||(t=this.createMesh(e),this._cache.set(e.key,t),t)}clear(){this._cache.clear()}get maxCacheSize(){return this._maxCacheSize}set maxCacheSize(e){this._maxCacheSize=e}get backgroundColor(){return this._material.color}set backgroundColor(e){e instanceof three.Color?this._material.color.copy(e):this._material.color.set(e)}get borderColor(){return this._material.borderColor}set borderColor(e){e instanceof three.Color?this._material.borderColor.copy(e):this._material.borderColor.set(e)}}const TILELOADER_STRATEGY_FAST="fast",TILELOADER_STRATEGY_HIERARCHICAL="hierarchical",MAP_GRID_NAME_GEO="geo",MAP_GRID_NAME_WEB_MERCATOR="web_mercator",MAP_GRID_NAME_BD_VECTOR_ONLINE="bd_vector_online",MAP_GRID_NAME_BD_VECTOR_OFFLINE="bd_vector_offline",MAP_GRID_NAME_BD_LANE_VECTOR="bd_lane_vector",BING_MAP_STYLE_AERIAL="Aerial",BING_MAP_STYLE_AERIAL_WITH_LABELS="AerialWithLabels",BING_MAP_STYLE_ROAD="Road",STADIA_MAP_STYLE_STAMEN_WATERCOLOR="StamenWatercolor",STADIA_MAP_STYLE_STAMEN_TONER="StamenToner",STADIA_MAP_STYLE_ALIDE_SMOOTH="AlidadeSmooth",STADIA_MAP_STYLE_ALIDE_SMOOTH_DARK="AlidadeSmoothDark",STADIA_MAP_STYLE_OUTDOORS="Outdoors",constants=Object.freeze(Object.defineProperty({__proto__:null,TILELOADER_STRATEGY_FAST:TILELOADER_STRATEGY_FAST,TILELOADER_STRATEGY_HIERARCHICAL:TILELOADER_STRATEGY_HIERARCHICAL,MAP_GRID_NAME_GEO:MAP_GRID_NAME_GEO,MAP_GRID_NAME_WEB_MERCATOR:MAP_GRID_NAME_WEB_MERCATOR,MAP_GRID_NAME_BD_VECTOR_ONLINE:MAP_GRID_NAME_BD_VECTOR_ONLINE,MAP_GRID_NAME_BD_VECTOR_OFFLINE:MAP_GRID_NAME_BD_VECTOR_OFFLINE,MAP_GRID_NAME_BD_LANE_VECTOR:MAP_GRID_NAME_BD_LANE_VECTOR,BING_MAP_STYLE_AERIAL:BING_MAP_STYLE_AERIAL,BING_MAP_STYLE_AERIAL_WITH_LABELS:BING_MAP_STYLE_AERIAL_WITH_LABELS,BING_MAP_STYLE_ROAD:BING_MAP_STYLE_ROAD,STADIA_MAP_STYLE_STAMEN_WATERCOLOR:STADIA_MAP_STYLE_STAMEN_WATERCOLOR,STADIA_MAP_STYLE_STAMEN_TONER:STADIA_MAP_STYLE_STAMEN_TONER,STADIA_MAP_STYLE_ALIDE_SMOOTH:STADIA_MAP_STYLE_ALIDE_SMOOTH,STADIA_MAP_STYLE_ALIDE_SMOOTH_DARK:STADIA_MAP_STYLE_ALIDE_SMOOTH_DARK,STADIA_MAP_STYLE_OUTDOORS:STADIA_MAP_STYLE_OUTDOORS},Symbol.toStringTag,{value:"Module"})),scratchPlane=new three.Plane(new three.Vector3(1,0,0),0),cornerPositionsScratch=[new three.Vector3,new three.Vector3,new three.Vector3,new three.Vector3],vertexScratch=new three.Vector4,directionScratch$1=new three.Vector3,fixedTransformScratch=new three.Matrix4,projectionMatrixScratch=new three.Matrix4,viewMatrixScratch=new three.Matrix4,mvpMatrixScratch=new three.Matrix4;let globalId=0;class MapSurface extends three.Object3D{constructor(e={}){super(e),__publicField(this,"name","MapSurface"),__publicField(this,"_lodScaleFactor",1),__publicField(this,"_sseFactor",.8),__publicField(this,"_minLevel",0),__publicField(this,"_maxLevel",21),__publicField(this,"_surfaceTileManager",null),__publicField(this,"_showTileBoundingBox",!1),__publicField(this,"_showTileDebugLabel",!1),__publicField(this,"_debugLabelIds",{}),__publicField(this,"_placeholderMeshesLastFrame",[]),__publicField(this,"_freezeUpdate",!1),__publicField(this,"_maxRequestTilesPerFrame",20),__publicField(this,"_enableHorizonCulling",!0),__publicField(this,"_selectedTilesMapLastFrame",{}),__publicField(this,"_selectedTilesLastFrame",[]),__publicField(this,"_showGroundWireframe",!1),__publicField(this,"_pendingRequests",new Map),__publicField(this,"onAfterColorPass",(e=>{this.add(this._groundObjectGroup)})),__publicField(this,"onAfterMainPass",(e=>{this.remove(this._groundObjectGroup)})),this._id=globalId++,this._quadtree=null,this._placeholder=null,this._options=e,this.statistics={visited:0,used:0,rendered:0,request:0,unstable:0},this._currentStatistics=Object.assign({},this.statistics),this._objectGroup=new three.Group,this.add(this._objectGroup),this._boundingBoxGroup=new three.Group,this.add(this._boundingBoxGroup),this._groundObjectGroup=new three.Scene,e.strategy===TILELOADER_STRATEGY_FAST?this.strategy=new FastTileLoaderStrategy(e):e.strategy===TILELOADER_STRATEGY_HIERARCHICAL&&(this.strategy=new HierarchicalTileLoaderStrategy(e))}_getCurrentGrid(){}computeDistanceToTile(e,t,i,n,r,s,a=!0){let o;if(n===SceneMode$1.SCENE3D){this.updateTileBoundingRegion(e,i);if(!e.boundingVolumeSourceTile&&e.z>=this._minLevel)return a?9999999999:e.boundingRegion.distanceToCamera(t,n,r,s);const l=e.boundingRegion,c=l.minimumHeight,h=l.maximumHeight;if(e.boundingVolumeSourceTile&&e.boundingVolumeSourceTile.tile!==e){const e=this.engine.map.map._ellipsoidCamera.positionCartographic.z;Math.abs(e-c)>Math.abs(e-h)?(l.minimumHeight=c,l.maximumHeight=c):(l.minimumHeight=h,l.maximumHeight=h)}return o=l.distanceToCamera(t,n,r,s),o}return o=e.targetBoundingBox.distanceToPoint(t),o}refresh(){for(const e of this._selectedTilesLastFrame)this.onSurfaceTileRefresh(e)}clearTilesInView(){this._groundObjectGroup.clear(),this._boundingBoxGroup.clear();const e=this._objectGroup;for(const t of this._selectedTilesLastFrame)e.remove(t.object),this.onSurfaceTileRemoved(t);this._selectedTilesLastFrame=[],this._selectedTilesMapLastFrame={}}updateView(e,t,i,n){if(this._freezeUpdate)return;if(!1===this.beginFrame(n))return;const r=this._getCurrentGrid();if(!r)return;this._quadtree||(this._quadtree=new TileQuadtree(r),this._quadtree.onTileCreated=this._onTileCreated);const s=this._currentOccluder=e.map._map.occluder;s&&(s.cameraPosition=t);let a=this._strategy;a._surfaceTileManager||(a._surfaceTileManager=this._surfaceTileManager);let{selectedTiles:o,requestTilesQueue:l,placeholderTiles:c}=a.computeTiles(e,t,i,n);const h=this._collectionCancelTiles(l);h.length>0&&this._cancelTileInArray(h);let u=[];c.length>0&&this._shouldRenderPlaceholder&&(this._placeholder||(this._placeholder=new Placeholder(this._options,this._placeholderColor),this._placeholder.engine=e),u=c.map((e=>this._placeholder.get(e))));let d=this._maxRequestTilesPerFrame;d-=Math.min(2,this._currentStatistics.unstable);const p=d;for(let y=0;y<l.length;y++){const e=l[y],t=Math.min(d,e.length);this._requestTilesInArray(e,t,0===y),d-=t}p>d&&this._quadMap._engine.requestRender();const m=this._selectedTilesLastFrame,f=this._selectedTilesMapLastFrame,g={};for(const y of o)g[y.tile.key]=y;const _=this._objectGroup;let A=this._groundObjectGroup;e.scene.overrideMaterial;const v=this._boundingBoxGroup;v.clear();for(const y of m)if(!g[y.tile.key]&&(_.remove(y.object),A.remove(y.groundObject),this.onSurfaceTileRemoved(y),this._showTileDebugLabel)){const t=this._getDebugLabelId(y);this._debugLabelIds[t]&&(delete this._debugLabelIds[t],e.rendering.label.removeLabel({id:t,type:"text_flat"}))}for(const y of this._placeholderMeshesLastFrame)A.remove(y);for(const y of u)A.add(y);for(const y of o)if(y){if(this._showTileBoundingBox&&v.add(y.boxHelper),this._showTileDebugLabel){const t=this._getDebugLabelId(y);if(!this._debugLabelIds[t]){this._debugLabelIds[t]=!0;const i={crs:e.map.projectionName,id:t,position:y.tile.targetCenter,text:y.tile.key,textSize:24,textFillStyle:[255,0,0,1],textStrokeStyle:[255,255,255,1],textStrokeWidth:2,type:"text_flat",rank:1e7};e.rendering.label.addLabel(i)}}f[y.tile.key]?y.isMeetSSEChanged&&this.onSurfaceTileSSEChanged(y):(y.object&&this._objectGroup.add(y.object),y.groundObject&&A.add(y.groundObject),this.onSurfaceTileAdded(y))}this._placeholderMeshesLastFrame=u,this._selectedTilesLastFrame=o,this._selectedTilesMapLastFrame=g,this.endFrame(n)}isInStableRenderState(){return 0===this.statistics.unstable&&0===this.statistics.request}_getDebugLabelId(e){return"mapsurface-"+this._id+"-debuglabel-"+e.tile.key}_onBeforeSceneRender(e,t,i,n){if(t.overrideMaterial)return this.add(this._groundObjectGroup),void this.remove(this._groundSceneRenderer.copyMesh);0!==this._groundObjectGroup.children.length?(this._groundSceneRenderer||(this._groundSceneRenderer=new GroundSceneRenderer),this.add(this._groundSceneRenderer.copyMesh),this._groundSceneRenderer.render(this._groundObjectGroup,e,t,i,n)):this._groundSceneRenderer&&this.remove(this._groundSceneRenderer.copyMesh)}_cancelTileInArray(e){this._surfaceTileManager.cancelSurfaceTiles(e)}_requestTilesInArray(e,t,i=!1){if(t<=0)return;let n=e.slice(0,t);for(const r of n)this._pendingRequests.set(r.key,r),this._surfaceTileManager.requestSurfaceTile(r,i)}_collectionCancelTiles(e){const t=e.flat(),i=[];for(const[n,r]of this._pendingRequests.entries())t.includes(r)||(i.push(r),this._pendingRequests.delete(n));return i}_selectCurrentFrameRequestTiles(e,t){return e.length<t?e:(e.sort(((e,t)=>e.z!==t.z?t.z-e.z:e._distance-t._distance)),e.slice(0,t))}beginFrame(e){this._currentStatistics.visited=0,this._currentStatistics.used=0,this._currentStatistics.rendered=0,this._currentStatistics.request=0,this._currentStatistics.unstable=0,this.updatePendingRequest(e),this._strategy.beginFrame(),this._surfaceTileManager.beginFrame(e)}updatePendingRequest(e){const t=this._surfaceTileManager,i=[];for(const[n,r]of this._pendingRequests.entries()){t.getSurfaceTile(r,e)&&i.push(n)}for(const n of i)this._pendingRequests.delete(n)}endFrame(e){this.statistics.visited=this._currentStatistics.visited,this.statistics.used=this._currentStatistics.used,this.statistics.rendered=this._currentStatistics.rendered,this.statistics.request=this._currentStatistics.request,this.statistics.unstable=this._currentStatistics.unstable,this._strategy.endFrame(),this._surfaceTileManager.endFrame(e)}_computeOccludeePoint(e,t){const i=e.boundingRegion.boundingVolume.center,n=e.geoBoundingBox,r=Rectangle.fromBox(n),s=this.engine.map.map._ellipsoid,a=cornerPositionsScratch;return Cartesian3.fromRadians(r.west,r.south,0,s,a[0]),Cartesian3.fromRadians(r.east,r.south,0,s,a[1]),Cartesian3.fromRadians(r.west,r.north,0,s,a[2]),Cartesian3.fromRadians(r.east,r.north,0,s,a[3]),t.computeHorizonCullingPointPossiblyUnderEllipsoid(i,a,0)}_computeOccludeePoint2(e,t){const i=e.boundingBox,n=e.center,r=i.min,s=i.max,a=[r,s,new three.Vector3(r.x,r.y,s.z),new three.Vector3(r.x,s.y,r.z)];return t.computeHorizonCullingPointPossiblyUnderEllipsoid(n,a,0)}updateTileBoundingRegion(e,t){const i=this.engine.map.map._ellipsoid;if(!e.boundingRegion){const t=Rectangle.fromBox(e.geoBoundingBox,new Rectangle,!0);e.boundingRegion=new TileBoundingRegion({computeBoundingVolumes:!1,rectangle:t,ellipsoid:i,minimumHeight:e.geoBoundingBox.min.z,maximumHeight:e.geoBoundingBox.max.z})}let n=this._surfaceTileManager.getSurfaceTile(e,t);const r=n&&n.object,s=e._heights,a=e.boundingRegion,o=a.minimumHeight,l=a.maximumHeight;let c=!1;if(r)s&&(a.minimumHeight=s[0],a.maximumHeight=s[1]),c=!0;else{let i=e.parent;for(;void 0!==i;){const e=i._heights,n=this._surfaceTileManager.getSurfaceTile(i,t);if(n){const t=n.object,r=void 0!==i._heights;if(t){r&&(a.minimumHeight=e[0],a.maximumHeight=e[1]);break}}i=i.parent}n=i}if(void 0!==n){const t=void 0===a._orientedBoundingBox;(a.minimumHeight!==o||a.maximumHeight!==l||t)&&a.computeBoundingVolumes(i),e.boundingVolumeSourceTile=n,e.boundingVolumeIsFromMesh=c}else{void 0===a._orientedBoundingBox&&a.computeBoundingVolumes(i),e.boundingVolumeSourceTile=void 0,e.boundingVolumeIsFromMesh=!1}}screenSpaceError(e){const t=this.quadMap;let i=e.z;const n=this.engine.map;let r=n.isGlobe,s=1,a=!0;if(r){a=e.targetCenter.length()>n.map._ellipsoid.minimumRadius}if(a){directionScratch$1.copy(this.engine.camera.position),r?(Transforms.eastNorthUpToFixedFrame(e.targetCenter,null,fixedTransformScratch),fixedTransformScratch.invert(),directionScratch$1.applyMatrix4(fixedTransformScratch).normalize()):directionScratch$1.sub(e.targetCenter).normalize(),s=Math.exp(-this._sseFactor*(1-three.MathUtils.clamp(directionScratch$1.z,0,1)));let t=three.MathUtils.clamp(directionScratch$1.z,0,1);e._distance<2e3&&(s=1,t=1),e._horizonFactor=t}const o=e.grid.getPixelSizeByLevel(i),l=e._distance;let c=o*this.engine.rendering.resolution.y/(l*t._sseDenominator)*this.computedLodScaleFactor*s;return c*=e.targetLODScaleRatio,c}reverseScreenSpaceErrorZ(e){const t=this.quadMap,i=this.engine.map;let n=i.isGlobe,r=1,s=!0;if(n){s=e.targetCenter.length()>i.map._ellipsoid.minimumRadius}s&&(directionScratch$1.copy(this.engine.camera.position),n?(Transforms.eastNorthUpToFixedFrame(e.targetCenter,null,fixedTransformScratch),fixedTransformScratch.invert(),directionScratch$1.applyMatrix4(fixedTransformScratch).normalize()):directionScratch$1.sub(e.targetCenter).normalize(),r=Math.exp(-this._sseFactor*(1-three.MathUtils.clamp(directionScratch$1.z,0,1))),e._distance<2e3&&(r=1));const a=e._distance,o=this.engine.rendering.resolution.y;let l=2*a*t._sseDenominator/(o*this.computedLodScaleFactor*r);l/=e.targetLODScaleRatio;const c=Math.log2(2*e.grid.zeroLevelPixelSize/l);return isNaN(c)?0:isFinite(c)?Math.max(c,0):30}projectBoundingBoxToNdc(e){const t=this.engine.camera;viewMatrixScratch.copy(t.matrixWorldInverse),projectionMatrixScratch.copy(t.projectionMatrix),mvpMatrixScratch.multiplyMatrices(projectionMatrixScratch,viewMatrixScratch);let i;if(this.engine.map.isGlobe){const t=e.boundingRegion;if(!t||!t.boundingVolume)return[[0,0],[0,0],[0,0],[0,0]];const n=t.boundingVolume.computeCorners();i=[n[0],n[2],n[6],n[4]]}else{const t=e.targetBoundingBox;i=[new three.Vector3(t.min.x,t.min.y,0),new three.Vector3(t.min.x,t.max.y,0),new three.Vector3(t.max.x,t.max.y,0),new three.Vector3(t.max.x,t.min.y,0)]}return i.map((e=>(vertexScratch.set(e.x,e.y,e.z,1),vertexScratch.applyMatrix4(mvpMatrixScratch),vertexScratch.divideScalar(vertexScratch.w),[vertexScratch.x,vertexScratch.y])))}_computeTileVisibility(e,t){const{mode:i}=this.engine.map.map;if(i===SceneMode$1.SCENE3D){const i=t.boundingRegion.boundingVolume;return!!(this._computeTileVisibility3D(e,i)!==Intersect$1.OUTSIDE)&&!(this._enableHorizonCulling&&this._currentOccluder&&(t._occludeePointInScaledSpace||(t._occludeePointInScaledSpace=this._computeOccludeePoint(t,this._currentOccluder)),t._occludeePointInScaledSpace&&!this._currentOccluder.isScaledSpacePointVisiblePossiblyUnderEllipsoid(t._occludeePointInScaledSpace,0)))}const n=t.targetBoundingBox;return e.intersectsBox(n)}_computeTileVisibility3D(e,t){if(!defined$1(t))throw new DeveloperError("boundingVolume is required.");const i=e.planes;let n=!1;for(let r=0,s=i.length;r<s;++r){const e=i[r],s=e.normal.clone().normalize(),a=e.constant,o=new three.Vector4(...s.toArray(),a),l=t.intersectPlane(StaticPlane.fromCartesian4(o,scratchPlane));if(l===Intersect$1.OUTSIDE)return Intersect$1.OUTSIDE;l===Intersect$1.INTERSECTING&&(n=!0)}return n?Intersect$1.INTERSECTING:Intersect$1.INSIDE}_naturalOrderChildTiles(e,t){const i=e[0],n=e[1],r=e[2],s=e[3],a=t.x/Math.PI*180,o=t.y/Math.PI*180;return a<i.geoBoundingBox.max.x?o<i.geoBoundingBox.max.y?[i,r,n,s]:[n,i,s,r]:o<i.geoBoundingBox.max.y?[r,i,s,n]:[s,n,r,i]}showLoadLogInOneFrame(){this._strategy._logLoadInCurrentFrame=!0}onSurfaceTileAdded(e){}onSurfaceTileRemoved(e){}onSurfaceTileRefresh(e){}onSurfaceTileSSEChanged(e){}dispose(){this._quadtree=null,this._surfaceTileManager.dispose(),this._surfaceTileManager=null}set quadMap(e){this._quadMap=e}get quadMap(){return this._quadMap}get showTileBoundingBox(){return this._showTileBoundingBox}set showTileBoundingBox(e){this._showTileBoundingBox=e,this._quadMap._engine.requestRender()}get showTileDebugLabel(){return this._showTileDebugLabel}set showTileDebugLabel(e){if(this._showTileDebugLabel=e,!1===e){const e=this._quadMap._engine.rendering.label;for(const t of Object.keys(this._debugLabelIds))e.removeLabel({id:t,type:"text_flat"});this._debugLabelIds={}}this._quadMap._engine.requestRender()}get freezeUpdate(){return this._freezeUpdate}set freezeUpdate(e){this._freezeUpdate=e}get enableHorizonCulling(){return this._enableHorizonCulling}set enableHorizonCulling(e){this._enableHorizonCulling=e}get tileManager(){return this._surfaceTileManager}get loadSiblings(){return this._strategy._loadSiblings}set loadSiblings(e){this._strategy._loadSiblings=e}get sseFactor(){return this._sseFactor}set sseFactor(e){this._sseFactor=e}get lodScaleFactor(){return this._lodScaleFactor}set lodScaleFactor(e){this._lodScaleFactor=e}get computedLodScaleFactor(){let e=this._lodScaleFactor;const t=this._tileProvider;if(t){e*=defaultValue(t._lodScaleFactor,1)}return e}get showGroundWireframe(){return this._showGroundWireframe}set showGroundWireframe(e){this._showGroundWireframe=e,e?(this._groundWireframeMaterial||(this._groundWireframeMaterial=new three.MeshBasicMaterial({wireframe:!0,color:16746496})),this._groundObjectGroup.overrideMaterial=this._groundWireframeMaterial):(this._groundObjectGroup.overrideMaterial=null,this._groundWireframeMaterial&&(this._groundWireframeMaterial.dispose(),this._groundWireframeMaterial=null))}set strategy(e){this._strategy=e,this._strategy._surface=this,this._strategy._surfaceTileManager=this._surfaceTileManager}get strategy(){return this._strategy}get placeholder(){return this._placeholder||(this._placeholder=new Placeholder(this._options,this._placeholderColor),this._placeholder.engine=this._quadMap._engine),this._placeholder}}class SurfaceTileManager{constructor(e){__publicField(this,"_surface",null),this._surface=e,this._pendingCount=0}beginFrame(e){}endFrame(e){}getSurfaceTile(e,t){}requestSurfaceTile(e){}cancelSurfaceTiles(e){}dispose(){console.warn("SurfaceTileManager.dispose not implemented")}get pendingCount(){return this._pendingCount}}const TILE_STATE_CREATED=1,TILE_STATE_LOADING=2,TILE_STATE_COMPLETED=3,TILE_STATE_FAILED=4,TILE_STATE_DISPOSED=5,_tempVector3$5=new three.Vector3;class MapTile{constructor(e,t,i,n){__publicField(this,"x"),__publicField(this,"y"),__publicField(this,"z"),__publicField(this,"compeleted",!1),__publicField(this,"siblingIndex",0),__publicField(this,"_grid"),__publicField(this,"_geoBoundingBox"),__publicField(this,"_projectedCenter"),__publicField(this,"_projectedBoundingBox"),__publicField(this,"_targetCenter"),__publicField(this,"_targetBoundingBox"),__publicField(this,"_targetLODScaleRatio"),__publicField(this,"_targetSSESize"),this._grid=e,this.z=t,this.x=i,this.y=n,this.key=t+"-"+i+"-"+n,this.state=TILE_STATE_CREATED,this.epoch=0,this.childrenKeys=[],e.getTileLoaderConfig&&(this.loaderConfig=e.getTileLoaderConfig(this))}updateBoundingBoxZ(e,t){const i=this._projectedBoundingBox;i.min.z=e,i.max.z=t,i.getCenter(this._projectedCenter)}get boundingBox(){return console.warn("boundingBox is renamed to projectedBoundingBox"),this.projectedBoundingBox}set boundingBox(e){console.warn("boundingBox is renamed to projectedBoundingBox"),this.projectedBoundingBox=e}get projectedBoundingBox(){return this._projectedBoundingBox}set projectedBoundingBox(e){e?(this._projectedBoundingBox=e,this._projectedCenter||(this._projectedCenter=new three.Vector3),e.getCenter(this._projectedCenter)):console.warn("Invalid bounding",e)}get geoBoundingBox(){return this._geoBoundingBox}set geoBoundingBox(e){this._geoBoundingBox=e}get reverseY(){return void 0===this._reverseY&&(this._reverseY=this._grid.getTileReverseY(this)),this._reverseY}set grid(e){this._grid=e}get grid(){return this._grid}get center(){return console.warn("center is renamed to projectedCenter"),this.projectedCenter}set center(e){console.warn("center is renamed to projectedCenter"),this.projectedCenter=e}get projectedCenter(){return this._projectedCenter}set projectedCenter(e){this._projectedCenter=e}set targetBoundingBox(e){console.warn("targetBoundingBox is readonly")}get targetGeoBoundingBox(){return this._targetGeoBoundingBox||(this._grid.shouldConvertCoord?(this._targetGeoBoundingBox=new three.Box3,CoordTransformer.transform(this._grid.sourceCoordType,this._grid.targetCoordType,this.geoBoundingBox.min,this._targetGeoBoundingBox.min),CoordTransformer.transform(this._grid.sourceCoordType,this._grid.targetCoordType,this.geoBoundingBox.max,this._targetGeoBoundingBox.max)):this._targetGeoBoundingBox=this.geoBoundingBox),this._targetGeoBoundingBox}get targetBoundingBox(){return this._targetBoundingBox||(this._grid.targetProjection.name!==this._grid.sourceProjection.name||this._grid.shouldConvertCoord?this._targetBoundingBox=this._grid.targetProjection.geoBoxToProjectedBox(this.targetGeoBoundingBox,null,this._grid.useExtendTargetBoundingBox):(this._targetBoundingBox=new three.Box3,this._targetBoundingBox.copy(this.projectedBoundingBox))),this._targetBoundingBox}get targetCenter(){return this._targetCenter||(this._targetCenter=new three.Vector3,this._grid.targetProjection.name!==this._grid.sourceProjection.name?this.targetBoundingBox.getCenter(this._targetCenter):this._projectedBoundingBox.getCenter(this._targetCenter)),this._targetCenter}get geoIntersectionOfTargetProjection(){const e=this._grid.targetProjection.geoBoundingBox;if(!e||e.isDefault)return Intersect$1.INSIDE;const{x:t,y:i}=this.geoBoundingBox.min,{x:n,y:r}=this.geoBoundingBox.max,{x:s,y:a}=e.min,{x:o,y:l}=e.max;return n<s||t>o||r<a||i>l?Intersect$1.OUTSIDE:t>=s&&n<=o&&i>=a&&r<=l?Intersect$1.INSIDE:Intersect$1.INTERSECT}_computeAvailableGeoBoundingBox(){const e=this._grid.targetProjection.geoBoundingBox;let{x:t,y:i,z:n}=this.geoBoundingBox.min,{x:r,y:s,z:a}=this.geoBoundingBox.max;const{x:o,y:l}=e.min,{x:c,y:h}=e.max;t<o&&(t=o),r>c&&(r=c),i<l&&(i=l),s>h&&(s=h),this._availableGeoBoundingBox=new three.Box3(new three.Vector3(t,i,n),new three.Vector3(r,s,a))}get availableGeoBoundingBox(){return this.geoIntersectionOfTargetProjection===Intersect$1.OUTSIDE?null:this.geoIntersectionOfTargetProjection===Intersect$1.INTERSECT?(this._availableGeoBoundingBox||this._computeAvailableGeoBoundingBox(),this._availableGeoBoundingBox):this.geoBoundingBox}_computeTargetLODScaleRatio(){let e;if(this._grid.targetProjection.getLODSacleOfGeoBoundingBox&&(e=this._grid.targetProjection.getLODSacleOfGeoBoundingBox(this.geoBoundingBox),void 0!==e))return e;const t=this.projectedBoundingBox;let i=t.max.x-t.min.x,n=t.max.y-t.min.y;const r=this.targetBoundingBox;let s,a;r.isOrientedBoundingBox?(_tempVector3$5.fromArray(r.halfAxes.elements,0),s=2*_tempVector3$5.length(),_tempVector3$5.fromArray(r.halfAxes.elements,3),a=2*_tempVector3$5.length()):(s=r.max.x-r.min.x,a=r.max.y-r.min.y);let o=s/i,l=a/n;return e=Math.min(o,l),e}get targetLODScaleRatio(){return void 0===this._targetLODScaleRatio&&(this._grid.sourceProjection.equals(this._grid.targetProjection)?this._targetLODScaleRatio=1:this._targetLODScaleRatio=this._computeTargetLODScaleRatio()),this._targetLODScaleRatio}}function enqueueMicrotask(e){Promise.resolve().then(e)}class LRUCache{constructor(e){this.maxSize=e||800,this.minSize=Math.round(.75*this.maxSize),this.unloadPercent=.05,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadPriorityCallback=null;const t=this.itemSet;this.defaultPriorityCallback=e=>t.get(e)}setMaxSize(e){this.maxSize=e,this.minSize=Math.round(.75*this.maxSize)}isFull(){return this.itemSet.size>=this.maxSize}add(e,t){const i=this.itemSet;if(i.has(e))return!1;if(this.isFull())return!1;const n=this.usedSet,r=this.itemList,s=this.callbacks;return r.push(e),n.add(e),i.set(e,Date.now()),s.set(e,t),!0}remove(e){const t=this.usedSet,i=this.itemSet,n=this.itemList,r=this.callbacks;if(i.has(e)){r.get(e)(e);const s=n.indexOf(e);return n.splice(s,1),t.delete(e),i.delete(e),r.delete(e),!0}return!1}clear(){const e=this.usedSet,t=this.itemSet,i=this.itemList,n=this.callbacks;for(let r=0;r<i.length;r++){const e=i[r];n.get(e)(e)}this.itemList=[],e.clear(),t.clear(),n.clear()}foreachItem(e){for(const t of this.itemList)e(t)}markUsed(e){const t=this.itemSet,i=this.usedSet;t.has(e)&&!i.has(e)&&(t.set(e,Date.now()),i.add(e))}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const e=this.unloadPercent,t=this.minSize,i=this.itemList,n=this.itemSet,r=this.usedSet,s=this.callbacks,a=i.length-r.size,o=i.length-t,l=this.unloadPriorityCallback||this.defaultPriorityCallback;if(o>0&&a>0){i.sort(((e,t)=>{const i=r.has(e),n=r.has(t);return i&&n?0:i||n?i?1:-1:l(t)-l(e)}));const c=Math.min(o,a),h=Math.max(t*e,c*e);let u=Math.min(h,a);u=Math.ceil(u);const d=i.splice(0,u);for(let e=0,t=d.length;e<t;e++){const t=d[e];s.get(t)(t),n.delete(t),s.delete(t)}}}scheduleUnload(e=!0){this.scheduled||(this.scheduled=!0,enqueueMicrotask((()=>{this.scheduled=!1,this.unloadUnusedContent(),e&&this.markAllUnused()})))}}const EPISLON6=1e-6;class Grid{constructor(e,t,i){__publicField(this,"_minLevel",0),__publicField(this,"_maxLevel",18),__publicField(this,"_useGeoSubdivision",!1),__publicField(this,"_projectBoxWithFourConrner",!1),__publicField(this,"_unprojectBoxWithFourConrner",!1),__publicField(this,"_shouldCheckTileBoundingRange",!1),__publicField(this,"_pixelSizes",[]),this._engine=e,this._sourceProjection=t,this._targetProjection=i}initFromTileProvider(e){this._sourceProjection=e.sourceProjection,this._targetProjection=e.targetProjection,this._sourceCoordType=e.sourceCoordType,this._targetCoordType=e.targetCoordType,this._sourceCoordType&&this._targetCoordType&&this._sourceCoordType!==this._targetCoordType?(this._shouldConvertCoord=CoordTransformer.canTransform(this._sourceCoordType,this._targetCoordType),this._shouldConvertCoord||console.warn(`can not convert coord from ${this._sourceCoordType} to ${this._targetCoordType}`)):this._shouldConvertCoord=!1,this.useExtendTargetBoundingBox=e.useExtendTargetBoundingBox||!1}getRootTiles(){return console.warn("getRootTiles is not implemented"),[]}getAvailableRootTiles(){return this.getRootTiles().filter((e=>e.geoIntersectionOfTargetProjection!==Intersect$1.OUTSIDE))}getRootBoundingBox(){return console.warn("getRootBoundingBox is not implemented"),null}getPixelSizeByLevel(e){return this._pixelSizes[e]}getNextLevel(e){return e+1}shouldCreateChildren(e){return!0}getNextLevelTileCount(e,t){return Math.pow(2,t-e)}getQuadTreeLevelGap(e,t){return t-e}createTileChildren(e){const t=[];e.childrenKeys=[];const i=this.getNextLevel(e.z);if(!this.shouldCreateChildren(e))return[];let n=null,r=null;if(this._useGeoSubdivision){const t=e.geoBoundingBox;n=t.min,r=t.max}else{const t=e.projectedBoundingBox;n=t.min,r=t.max}const s=this.getQuadTreeLevelGap(e.z,i),a=Math.pow(2,s),o=(r.x-n.x)/a,l=(r.y-n.y)/a;let c=e.x*a,h=e.y*a,u=null;for(let d=0;d<a;d++)for(let s=0;s<a;s++){const p=new MapTile(this,i,c+d,h+s);u=new three.Box3(new three.Vector3(n.x+d*o,n.y+s*l,n.z),new three.Vector3(n.x+(d+1)*o,n.y+(s+1)*l,r.z)),this._useGeoSubdivision?(p.geoBoundingBox=u,p.projectedBoundingBox=this._sourceProjection.geoBoxToProjectedBox(u)):(p.projectedBoundingBox=u,p.geoBoundingBox=this._sourceProjection.projectedBoxToGeoBox(u)),this._shouldCheckTileBoundingRange&&!this.isTileInBoundingRange(p)||p.geoIntersectionOfTargetProjection!==Intersect$1.OUTSIDE&&(p.siblingIndex=d*a+s,p.parentKey=e.key,p.parent=e,t.push(p),e.childrenKeys.push(p.key))}return t}createSubTile(e,t,i,n,r){const s=new MapTile(this,e.z,e.x,e.y);let a=null,o=null;if(this._useGeoSubdivision){const t=e.geoBoundingBox;a=t.min,o=t.max}else{const t=e.projectedBoundingBox;a=t.min,o=t.max}const l=o.x-a.x,c=o.y-a.y,h=a.x+t*l,u=a.y+i*c,d=h+n*l,p=u+r*c,m=new three.Box3(new three.Vector3(h,u,a.z),new three.Vector3(d,p,o.z));return this._useGeoSubdivision?(s.geoBoundingBox=m,s.projectedBoundingBox=this._sourceProjection.geoBoxToProjectedBox(m)):(s.projectedBoundingBox=m,s.geoBoundingBox=this._sourceProjection.projectedBoxToGeoBox(m)),s._rect=[t,i,n,r],s.key=e.key+"-"+Math.random().toFixed(5),s.parent=e,s._sourceTile=e,s}isTileInBoundingRange(e){const t=e.geoBoundingBox,i=t.min,n=t.max;return!(i.x>180||n.x<-180||i.y>90||n.y<-90)}getTileSizeAtLevel(e){console.warn("getTileSizeXAtLevel is not implemented")}getTileCoordX(e,t,i=!1){console.warn("getTileCoordX is not implemented")}getTileCoordY(e,t,i=!1){console.warn("getTileCoordY is not implemented")}_alignTileCoord(e){let t=Math.round(e);return Math.abs(e-t)<EPISLON6?t:e}computeCoverageTilesCoord(e,t=0,i=100){const n=[],r=e.grid;let s=null;if(r.useGeoSubdivision)s=this._useGeoSubdivision?e.geoBoundingBox:this._sourceProjection.geoBoxToProjectedBox(e.geoBoundingBox);else if(this._useGeoSubdivision)s=e.projectedBoundingBox;else{let t=r.targetProjection.projectedBoxToGeoBox(e.projectedBoundingBox);s=this._sourceProjection.geoBoxToProjectedBox(t)}const a=this.zeroLevelPixelSize/r.zeroLevelPixelSize;let o=Math.round(e.z+a-1);const l=Math.max(this._minLevel,t),c=Math.min(this._maxLevel,i);o<l&&(o=l),o>c&&(o=c);let h=0,u=0,d=0,p=0,m=0;for(;o>=l;){const t=this.getTileSizeAtLevel(o);if(u=this._alignTileCoord(this.getTileCoordX(s.min.x,t,!0)),d=this._alignTileCoord(this.getTileCoordY(s.min.y,t,!0)),p=this._alignTileCoord(this.getTileCoordX(s.max.x,t,!0)),m=this._alignTileCoord(this.getTileCoordY(s.max.y,t,!0)),u=Math.floor(u),d=Math.floor(d),p=Math.ceil(p),m=Math.ceil(m),h=(p-u)*(m-d),h<8)break;if(o===l)return console.warn(`tile count ${h} is too large for one mapped target tile ${e.key}`),[];o--}for(let f=u;f<p;f++)for(let e=d;e<m;e++)n.push([o,f,e]);return n}computeTileCoverageRect(e,t){if(e.z===t.z&&e.x===t.x&&e.y===t.y)return[-1,-1,-1,-1];let i=null,n=null;e.grid.useGeoSubdivision?(i=e.geoBoundingBox,n=t.geoBoundingBox):(i=e.projectedBoundingBox,n=t.projectedBoundingBox);const r=i.min,s=i.max,a=n.min,o=n.max;return[(a.x-r.x)/(s.x-r.x),(a.y-r.y)/(s.y-r.y),(o.x-r.x)/(s.x-r.x),(o.y-r.y)/(s.y-r.y)]}updateTileHeights(e,t){e._heights=t,e.z<2||(this.useGeoSubdivision?(e.geoBoundingBox.min.z=t[0],e.geoBoundingBox.max.z=t[1],e.projectedBoundingBox=this._sourceProjection.geoBoxToProjectedBox(e.geoBoundingBox)):(e.projectedBoundingBox.min.z=t[0],e.projectedBoundingBox.max.z=t[1],e.center.z=(t[0]+t[1])/2,e.geoBoundingBox=this.projectionBoxToGeoBox(e.projectedBoundingBox,this._unprojectBoxWithFourConrner)))}getTileReverseY(e){return Math.pow(2,e.z)-e.y-1}_updateLODConfig(){const e=[];let t=this.zeroLevelPixelSize;for(let i=0;i<=this._maxLevel;i++)e.push(t),t/=2;this._pixelSizes=e}update(){this._updateLODConfig()}set engine(e){this._engine=e}get engine(){return this._engine}set maxLevel(e){this._maxLevel=e}get maxLevel(){return this._maxLevel}set minLevel(e){this._minLevel=e}get minLevel(){return this._minLevel}get useGeoSubdivision(){return this._useGeoSubdivision}get sourceProjection(){return this._sourceProjection}get targetProjection(){return this._targetProjection}get sourceCoordType(){return this._sourceCoordType}get targetCoordType(){return this._targetCoordType}get shouldConvertCoord(){return this._shouldConvertCoord}get zeroLevelPixelSize(){return this._zeroLevelPixelSize||(this._zeroLevelPixelSize=156543.03392804062),this._zeroLevelPixelSize}}const EARTH_RADIUS$1=20037508.3427892;class WebMercatorGrid extends Grid{constructor(){super(...arguments),__publicField(this,"name",MAP_GRID_NAME_WEB_MERCATOR),__publicField(this,"_maxLevel",21),__publicField(this,"_rootBoundingBox",new three.Box3(new three.Vector3(-EARTH_RADIUS$1,-EARTH_RADIUS$1,-.1),new three.Vector3(EARTH_RADIUS$1,EARTH_RADIUS$1,.1)))}getRootTiles(){const e=new MapTile(this,0,0,0);return e.projectedBoundingBox=this._rootBoundingBox,e.geoBoundingBox=new three.Box3(new three.Vector3(-180,-90,-.1),new three.Vector3(180,90,.1)),[e]}getRootBoundingBox(){return this._rootBoundingBox}getTileSizeAtLevel(e){return EARTH_RADIUS$1/Math.pow(2,e-1)}getTileCoordX(e,t,i){return i&&(e<-EARTH_RADIUS$1?e=-EARTH_RADIUS$1:e>EARTH_RADIUS$1&&(e=EARTH_RADIUS$1)),(e+EARTH_RADIUS$1)/t}getTileCoordY(e,t,i){return this.getTileCoordX(e,t,i)}get textureMaxLevel(){return this._textureMaxLevel}set textureMaxLevel(e){this._textureMaxLevel=e}}const INIT_STATE_UNINITIALIZED=0,INIT_STATE_INITIALIZING=1,INIT_STATE_INITIALIZED=2,INIT_STATE_FAILED=3;let _globalId$1=1;class TileProvider{constructor(e={}){__publicField(this,"name","TileProvider"),__publicField(this,"visible",!0),__publicField(this,"_sourceProjection"),__publicField(this,"_targetProjection"),__publicField(this,"_quadtree"),__publicField(this,"_cache"),__publicField(this,"_grid"),__publicField(this,"_supportedTargetProjectionNames",[]),__publicField(this,"_supportAllProjections",!1),__publicField(this,"_compatible",!1),__publicField(this,"_initState",INIT_STATE_UNINITIALIZED),__publicField(this,"_desiredUpperSampleLevel",100),__publicField(this,"_loadingUpperSampleLevel",1),__publicField(this,"_maxCacheSize",1e3),__publicField(this,"_maxLevel"),__publicField(this,"_minLevel"),__publicField(this,"_startLevel"),__publicField(this,"_shouldCheckTileAvailable",!1),__publicField(this,"ignoreLoadingState",!1),__publicField(this,"_requestingCount",0),__publicField(this,"_maxParallelRequestNum",6),__publicField(this,"enablePeriodRequestLog",!1),__publicField(this,"_periodRequestLogCount",0),__publicField(this,"_periodRequestLogStartTime",0),__publicField(this,"_canUpsample",!1),__publicField(this,"_useWebMeractorProjectionAndGrid",!1),__publicField(this,"_requestDataVersion",0),__publicField(this,"_needsClearCache",!1),__publicField(this,"_needsIncreTilesEpoch",!1),__publicField(this,"handleRemove",((e,t)=>{this.onTileDispose(e),e.state=TILE_STATE_DISPOSED,e.data=null,e.epoch++})),__publicField(this,"_logRequestStart",(()=>{this.enablePeriodRequestLog&&(0===this._requestingCount&&(this._periodRequestLogCount=0,this._periodRequestLogStartTime=performance.now()),this._periodRequestLogCount++)})),__publicField(this,"_logRequestEnd",(()=>{this.enablePeriodRequestLog&&0===this._requestingCount&&(performance.now(),this._periodRequestLogStartTime)})),__publicField(this,"_markTileStateListenersNeedsUpdate",(e=>{for(const t of e._stateListenerObjects)t.needsUpdate=!0})),__publicField(this,"_initOrUpdateTileStateListeners",((e,t)=>{e._stateListenerObjects||(e._stateListenerObjects=[]),e._stateListenerObjects.indexOf(t)<0&&e._stateListenerObjects.push(t)})),this._id=_globalId$1++,e.targetProjection&&(this._targetProjection=e.targetProjection),void 0!==e.minLevel&&(this._minLevel=e.minLevel),void 0!==e.maxLevel&&(this._maxLevel=e.maxLevel),void 0!==e.startLevel&&(this._startLevel=e.startLevel),this._maxCacheSize=e.maxCacheSize||800,this._needFallback=defaultValue$1(e.needFallback,!0),this.statistics={loading:0,cached:0}}_init(){if(this._initState===INIT_STATE_UNINITIALIZED){if(void 0===this._minLevel&&(this._minLevel=this._defaultMinLevel||0),void 0===this._startLevel&&(this._startLevel=this._defaultStartLevel||0),void 0===this._maxLevel&&(this._maxLevel=this._defaultMaxLevel||1/0),this._initState=INIT_STATE_INITIALIZING,!(this._supportAllProjections||this._supportedTargetProjectionNames.indexOf(this._targetProjection.name)>=0))return this._compatible=!1,console.warn(`${this.name}: not supported target projection ${this._targetProjection.name}, supported target projections: ${this._supportedTargetProjectionNames.join(",")}`),this._inited=!0,void(this._initState=INIT_STATE_FAILED);this._compatible=!0,this._cache=new LRUCache(this._maxCacheSize),this._asyncInit?this._asyncInit().then((()=>{this._inited=!0,this._initState=INIT_STATE_INITIALIZED,this._useWebMeractorProjectionAndGrid?this._initWebMercatorProjectionAndGrid():this.initProjectionAndGrid(),this._grid.initFromTileProvider(this),this._grid.update(),this._quadtree=new TileQuadtree(this._grid),this._engine.requestRender()})).catch((e=>{console.error(e),this._inited=!0,this._initState=INIT_STATE_FAILED})):(this._inited=!0,this._initState=INIT_STATE_INITIALIZED,this._useWebMeractorProjectionAndGrid?this._initWebMercatorProjectionAndGrid():this.initProjectionAndGrid(),this._grid.initFromTileProvider(this),this._grid.update(),this._quadtree=new TileQuadtree(this._grid))}}_initWebMercatorProjectionAndGrid(){this._sourceProjection=getProjection(PROJECTION_WEB_MERCATOR),this._grid=new WebMercatorGrid(this._engine,this._sourceProjection,this._targetProjection)}initProjectionAndGrid(){throw new Error(this.name+": initProjectionAndGrid should be overriden in subclass or set _useWebMeractorProjectionAndGrid to true")}_freeResources(){this._cache=null,this._grid=null,this._quadtree=null}beginFrame(e){this._usedTilesNum=0,this._usedTiles={},this._init(),this._needsClearCache&&(this._clearCache(),this._needsClearCache=!1),this._needsIncreTilesEpoch&&(this._increTilesEpoch(),this._needsIncreTilesEpoch=!1)}endFrame(e){this._cache&&(this._cache.scheduleUnload(),this.statistics.cached=this._cache.itemList.length)}isReady(){return this._initState===INIT_STATE_INITIALIZED}onTileDispose(e){console.warn("onTileDispose should be overriden in subclass")}async requestTileData(e,t){if(!(e.z<this._minLevel)&&this._initState===INIT_STATE_INITIALIZED){if(!e)return window.__debug&&console.warn("tile not found"),void console.warn("tile not found");if(t&&this._initOrUpdateTileStateListeners(e,t),e.state!==TILE_STATE_LOADING)if(e.state!==TILE_STATE_COMPLETED){if(e.geoIntersectionOfTargetProjection===Intersect$1.OUTSIDE)return e.state=TILE_STATE_COMPLETED,void this._markTileStateListenersNeedsUpdate(e);if(e.geoIntersectionOfTargetProjection,Intersect$1.INTERSECT,e.state===TILE_STATE_FAILED)if(Date.now()-e._lastFailTime<9e5){if(e._failTimes>2)return}else e._failTimes=0;if(!(this._requestingCount>=this._maxParallelRequestNum)){this._logRequestStart(),this._requestingCount++;try{e.requestDataVersion=this._requestDataVersion,e.state=TILE_STATE_LOADING,this.statistics.loading++,this._markTileStateListenersNeedsUpdate(e),window.__debug;const i=await this.doRequestTileData(e,t);e.requestDataVersion===this._requestDataVersion&&(e.data=i,e.state=TILE_STATE_COMPLETED,this._cache.add(e,this.handleRemove))}catch(i){if(i&&"AbortError"===i.name)return void(e.state=TILE_STATE_CREATED);e.state=TILE_STATE_FAILED,e._failTimes||(e._failTimes=0),e._failTimes++,e._lastFailTime=Date.now(),console.warn(`tile ${e.key} load error in ${this.name}`,i)}finally{this._markTileStateListenersNeedsUpdate(e),this.statistics.loading--,this._requestingCount--,this._logRequestEnd()}}}else this._markTileStateListenersNeedsUpdate(e)}}getGroundTileData(e){return null}getTile(e,t,i,n,r){if(!this._compatible)return null;let s=e,a=t,o=i,l=s-this._maxLevel;if(l>0&&(s=this._maxLevel,a=t>>l,o=i>>l),this._shouldCheckTileAvailable)for(;!this.isTileAvailable(s,a,o);)if(l++,s--,a>>=1,o>>=1,s<0)return null;this._canUpsample||(t=a,i=o,e=s);const c=this._quadtree.getTile(e,t,i,r.isRasterSurfaceTile);return this._canUpsample&&e!==s|t!==a&&i!==o&&(c.needUpSample=!0),c?(this._initOrUpdateTileStateListeners(c,r),c):null}markTileUsed(e){this._usedTilesNum++,this._usedTiles[e.key]=!0,this._cache.markUsed(e)}_tileLevelInRange(e){return e>=this._startLevel&&e<=this._maxLevel}computeCoverageTilesCoord(e){const t=this._grid,i=e.grid,n=this._sourceProjection,r=i.targetProjection;return t.name===i.name&&n.name===r.name&&this._tileLevelInRange(e.z)?[[e.z,e.x,e.y]]:this.grid.computeCoverageTilesCoord(e,Math.max(this._startLevel,this._minLevel),this.grid.maxLevel)}_clearCache(){this._cache&&this._cache.clear(),this._requestDataVersion++}_increTilesEpoch(){this._cache.foreachItem((e=>{e.epoch++}))}get id(){return this._id}get maxCacheSize(){return this._maxCacheSize}set maxCacheSize(e){this._maxCacheSize=e}get desiredUpperSampleLevel(){return this._desiredUpperSampleLevel}set desiredUpperSampleLevel(e){this._desiredUpperSampleLevel=e}get loadingUpperSampleLevel(){return this._loadingUpperSampleLevel}set loadingUpperSampleLevel(e){this._loadingUpperSampleLevel=e}get grid(){return this._grid}get compatible(){return this._compatible}get projection(){return this._sourceProjection}get sourceProjection(){return this._sourceProjection}get targetProjection(){return this._targetProjection}set targetProjection(e){this._targetProjection=e}get initState(){return this._initState}get maxLevel(){return this._maxLevel}set maxLevel(e){this._maxLevel=e}get minLevel(){return this._minLevel}set minLevel(e){this._minLevel=e}get maxParallelRequestNum(){return this._maxParallelRequestNum}set maxParallelRequestNum(e){this._maxParallelRequestNum=e}get cacheMaxSize(){return this._cache&&this._cache.maxSize||0}set cacheMaxSize(e){this._cache&&this._cache.setMaxSize(e)}}const vertexShader$n="#define GLSLIFY 1\n#include <common>\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    #include <logdepthbuf_vertex>\n\n}\n\n",fragmentShader$l="#define GLSLIFY 1\n#include <common>\n\nvarying vec2 vUv;\n\nuniform float opacity;\n\n#include <logdepthbuf_pars_fragment>\n\n#if NUM_TEXTURES > 0\n    uniform sampler2D diffuseTextures[NUM_TEXTURES];\n    uniform vec4 textureTranslationAndScales[NUM_TEXTURES];\n    uniform vec4 colorAdjustments[NUM_TEXTURES];\n    uniform vec4 boundingRect;\n#endif\n\nvec4 sampleAndBlendColor(vec4 oldColor, sampler2D sampleTexture, vec4 translationAndScale, vec4 colorAdjustment) {\n    vec2 transformedUv = clamp(vUv, vec2(0.0), vec2(1.0));\n    transformedUv *= translationAndScale.zw;\n    transformedUv -= translationAndScale.xy;\n    if (transformedUv.x < 0.0 || transformedUv.y < 0.0 || transformedUv.x > 1.0 || transformedUv.y > 1.0) {\n        return oldColor;\n    }\n    vec4 sampleColor = texture2D(sampleTexture, transformedUv);\n    sampleColor *= colorAdjustment;\n    // sampleColor.a *= colorAdjustment.a;\n    vec3 mixColor = mix(oldColor.rgb, sampleColor.rgb, sampleColor.a);\n    return vec4(mixColor, oldColor.a + sampleColor.a);\n}\nvoid main() {\n\n    // gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);\n    // return;\n    #if NUM_TEXTURES > 0\n        if (boundingRect.x > -0.5 && (vUv.x < boundingRect.x || vUv.y < boundingRect.y || vUv.x > boundingRect.z || vUv.y > boundingRect.w)) {\n            discard;\n        }\n\n    #endif\n   \n    vec4 color = vec4(0);\n\n    #if NUM_TEXTURES > 0\n        color = sampleAndBlendColor(color, diffuseTextures[0], textureTranslationAndScales[0], colorAdjustments[0]);\n    #endif\n    #if NUM_TEXTURES > 1\n        color = sampleAndBlendColor(color, diffuseTextures[1], textureTranslationAndScales[1], colorAdjustments[1]);\n    #endif\n    #if NUM_TEXTURES > 2\n        color = sampleAndBlendColor(color, diffuseTextures[2], textureTranslationAndScales[2], colorAdjustments[2]);\n    #endif\n    #if NUM_TEXTURES > 3\n        color = sampleAndBlendColor(color, diffuseTextures[3], textureTranslationAndScales[3], colorAdjustments[3]);\n    #endif\n    #if NUM_TEXTURES > 4\n        color = sampleAndBlendColor(color, diffuseTextures[4], textureTranslationAndScales[4], colorAdjustments[4]);\n    #endif\n    #if NUM_TEXTURES > 5\n        color = sampleAndBlendColor(color, diffuseTextures[5], textureTranslationAndScales[5], colorAdjustments[5]);\n    #endif\n    #if NUM_TEXTURES > 6\n        color = sampleAndBlendColor(color, diffuseTextures[6], textureTranslationAndScales[6], colorAdjustments[6]);\n    #endif\n    #if NUM_TEXTURES > 7\n        color = sampleAndBlendColor(color, diffuseTextures[7], textureTranslationAndScales[7], colorAdjustments[7]);\n    #endif\n    #if NUM_TEXTURES > 8\n        color = sampleAndBlendColor(color, diffuseTextures[8], textureTranslationAndScales[8], colorAdjustments[8]);\n    #endif\n    #if NUM_TEXTURES > 9\n        color = sampleAndBlendColor(color, diffuseTextures[9], textureTranslationAndScales[9], colorAdjustments[9]);\n    #endif\n    #if NUM_TEXTURES > 10\n        color = sampleAndBlendColor(color, diffuseTextures[10], textureTranslationAndScales[10], colorAdjustments[10]);\n    #endif\n    #if NUM_TEXTURES > 11\n        color = sampleAndBlendColor(color, diffuseTextures[11], textureTranslationAndScales[11], colorAdjustments[11]);\n    #endif\n    #if NUM_TEXTURES > 12\n        color = sampleAndBlendColor(color, diffuseTextures[12], textureTranslationAndScales[12], colorAdjustments[12]);\n    #endif\n    #if NUM_TEXTURES > 13\n        color = sampleAndBlendColor(color, diffuseTextures[13], textureTranslationAndScales[13], colorAdjustments[13]);\n    #endif\n    #if NUM_TEXTURES > 14\n        color = sampleAndBlendColor(color, diffuseTextures[14], textureTranslationAndScales[14], colorAdjustments[14]);\n    #endif\n    #if NUM_TEXTURES > 15\n        color = sampleAndBlendColor(color, diffuseTextures[15], textureTranslationAndScales[15], colorAdjustments[15]);\n    #endif\n    #if NUM_TEXTURES > 16\n        color = sampleAndBlendColor(color, diffuseTextures[16], textureTranslationAndScales[16], colorAdjustments[16]);\n    #endif\n\n    gl_FragColor = color;\n    // gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}\n\n",uniforms$m=three.UniformsUtils.merge([{opacity:{value:1},diffuseTextures:{value:null},textureTranslationAndScales:{value:null},colorAdjustments:{value:null},boundingRect:{value:new three.Vector4}}]);class RasterSurfaceMaterial extends three.ShaderMaterial{constructor(e={}){super(),__publicField(this,"updateTextures",((e,t)=>{let i=[],n=[],r=[];for(const s of e){i.push(s.texture),n.push(new three.Vector4(s.offsetX,s.offsetY,s.scaleX,s.scaleY));const e=s.colorTint;r.push(new three.Vector4(e[0],e[1],e[2],s.opacity))}this.uniforms.boundingRect.value.fromArray(t),this.uniforms.diffuseTextures.value=i,this.uniforms.textureTranslationAndScales.value=n,this.uniforms.colorAdjustments.value=r,this.defines.NUM_TEXTURES!==e.length&&(this.defines.NUM_TEXTURES=e.length,this.needsUpdate=!0)})),__publicField(this,"forceUpdateTextureCount",(e=>{this.defines.NUM_TEXTURES=e,this.needsUpdate=!0})),this.name="RasterSurfaceMaterial",this.fragmentShader=fragmentShader$l,this.vertexShader=vertexShader$n,this.defines={NUM_TEXTURES:0},this.uniforms=three.UniformsUtils.clone(uniforms$m),e.textures&&this.updateTextures(e.textures,e.boundRect)}get textureCount(){return this.defines.NUM_TEXTURES}dispose(){super.dispose()}}const sharedRasterMaterials={},getSharedRasterMaterial=e=>{if(!sharedRasterMaterials[e]){const t=new RasterSurfaceMaterial;t.name="RasterSurfaceMaterial_"+e,t.forceUpdateTextureCount(e),t.onBeforeRender=function(e,i,n,r,s,a){s.userData._boundingRect&&(t.uniforms.boundingRect.value=s.userData._boundingRect,t.uniforms.diffuseTextures.value=s.userData._diffuseTextures,t.uniforms.textureTranslationAndScales.value=s.userData._textureTranslationAndScales,t.uniforms.colorAdjustments.value=s.userData._colorAdjustments,t.uniformsNeedUpdate=!0)},sharedRasterMaterials[e]=t}return sharedRasterMaterials[e]},bindMaterialInfoToMesh=(e,t,i)=>{let n=[],r=[],s=[];for(const a of t){n.push(a.texture),r.push(new three.Vector4(a.offsetX,a.offsetY,a.scaleX,a.scaleY));const e=a.colorTint;s.push(new three.Vector4(e[0],e[1],e[2],a.opacity))}e.userData._boundingRect=(new three.Vector4).fromArray(i),e.userData._diffuseTextures=n,e.userData._textureTranslationAndScales=r,e.userData._colorAdjustments=s};class OrientedBoundingBoxHelper extends three.LineSegments{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new three.BufferGeometry;n.setIndex(new three.BufferAttribute(i,1)),n.setAttribute("position",new three.Float32BufferAttribute([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(n,new three.LineBasicMaterial({color:t,toneMapped:!1})),this.obb=e,this.type="OrientedBoundingBoxHelper",this.needsUpdateOBB=!0}setOBB(e,t){this.obb.center.copy(e),this.obb.halfAxes.copy(t),this.needsUpdateOBB=!0}updateMatrixWorld(e){if(this.needsUpdateOBB||e){this.needsUpdateOBB=!1;const e=this.obb.center,t=this.obb.halfAxes;this.position.copy(e);const i=new three.Vector3,n=new three.Matrix4;for(let r=0;r<3;r++){let e=3*r;const s=new three.Vector3(t.elements[e],t.elements[e+1],t.elements[e+2]);i.setComponent(r,s.length()),s.normalize(),e=4*r,n.elements[e]=s.x,n.elements[e+1]=s.y,n.elements[e+2]=s.z}this.scale.copy(i),this.quaternion.setFromRotationMatrix(n)}super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}class SurfaceTile{constructor(e){this.tile=e}get boxHelper(){return this._boxHelper||(this.tile.boundingRegion?this._boxHelper=new OrientedBoundingBoxHelper(this.tile.boundingRegion._orientedBoundingBox,16711680):this.tile.targetBoundingBox?this._boxHelper=new three.Box3Helper(this.tile.targetBoundingBox,16711680):console.warn("No bounding box")),this._boxHelper}}const DATA_STATE_UNRENDERABLE$1=0,DATA_STATE_CAN_RENDER=1,DATA_STATE_STABLE$1=2;class RasterSurfaceTileManager extends SurfaceTileManager{constructor(){super(...arguments),__publicField(this,"_tiles",new WeakMap),__publicField(this,"_layersKey","")}beginFrame(e){const t=this._surface.terrainProvider,i=this._surface.imageryProviders,n=[];n.push(t.id+"#"+t.visible);for(const s of i)n.push(s.id+"#"+s.visible);const r=n.join("|");r!==this._layersKey&&(this.clear(),this._layersKey=r)}endFrame(e){}forceUpdateTileState(e){const t=this._tiles.get(e);t&&(t.needsUpdate=!0,this._updateSurfaceTileData(t))}isTileComputable(e,t){const i=this._tiles.get(e);return!!i&&(i.frameCount!==t.frameCount&&(this._updateSurfaceTileData(i),i.frameCount=t.frameCount),i.terrainTile&&i.terrainTile.state===TILE_STATE_COMPLETED)}isTileRenderable(e,t){const i=this._tiles.get(e);return!!i&&(i.frameCount!==t.frameCount&&(this._updateSurfaceTileData(i),i.frameCount=t.frameCount),i.state!==DATA_STATE_UNRENDERABLE$1)}isTileStable(e,t){const i=this._tiles.get(e);return!!i&&(i.frameCount!==t.frameCount&&(this._updateSurfaceTileData(i),i.frameCount=t.frameCount),i.state===DATA_STATE_STABLE$1)}markTileUsed(e){const t=this._tiles.get(e);if(!t)return null;const i=this._surface.terrainProvider,n=t.terrainTile;n&&i.markTileUsed(n);const r=t.imageryTiles,s=this._surface.imageryProviders;for(let a=0;a<r.length;++a){const e=r[a];if(!e)continue;const t=s[a];if(t.visible)for(let i=0;i<e.length;++i){const n=e[i];n&&t.markTileUsed(n)}}}getSurfaceTile(e,t){const i=this._tiles.get(e);return i?(i.frameCount!==t.frameCount&&(this._updateSurfaceTileData(i),i.frameCount=t.frameCount),i.state!==DATA_STATE_UNRENDERABLE$1?i:void 0):null}_updateSurfaceTileData(e){e.needsUpdate=!1,e.state;const t=e.terrainTile;if(!t)return void console.error("terrainTile is undefined",e);if(t.state!==TILE_STATE_COMPLETED)return e.state=DATA_STATE_UNRENDERABLE$1,void this._surface.quadMap._engine.requestRender();const i=e.imageryTiles,n=this._surface.imageryProviders;let r=0,s=0,a=0;const o=[],l=[];for(let u=0;u<i.length;++u){const e=i[u],c=n[u];if(c.ignoreLoadingState&&a++,!e||!c.compatible){o.push(""),r++;continue}let h=!1,d=!1;for(let i=0;i<e.length;++i){const n=e[i];if(n)if(n.state===TILE_STATE_COMPLETED){c.markTileUsed(n);const e=this._getTileCoordConfig(t,n);l.push({texture:n.data,opacity:c.opacity,colorTint:c.randomColorTint?[Math.random(),Math.random(),Math.random()]:c.colorTint,...e}),o.push(n.key+"#"+n.epoch)}else{let e=this._getUpperSampleReadyTile(n,c);if(e){c.markTileUsed(e);const i=this._getTileCoordConfig(t,e);l.push({texture:e.data,opacity:c.opacity,colorTint:c.randomColorTint?[Math.random(),Math.random(),Math.random()]:c.colorTint,...i}),o.push(e.key+"#"+e.epoch),h=!0}else o.push(""),d=!0}}d&&0===l.length?s++:h||r++}const c=o.join("|");let h=DATA_STATE_CAN_RENDER;if(0===i.length||r>0&&r===n.length?h=DATA_STATE_STABLE$1:s+a===n.length&&(h=DATA_STATE_UNRENDERABLE$1),h===DATA_STATE_UNRENDERABLE$1)return e.state=h,void(e.loadStateKey=c);if(void 0===e.object){const i=t.data;if(i){const n=getSharedRasterMaterial(l.length),r=new three.Mesh(i,n);bindMaterialInfoToMesh(r,l,e.terrainBoundRect),r.position.copy(t.targetCenter),i._heights&&!e.tile._heights&&e.tile.grid.updateTileHeights(e.tile,i._heights),r.frustumCulled=!1,r.isTerrainTile=!0,e.object=r}else e.object=null}else if(c!==e.loadStateKey){const t=e.object;if(t){const i=getSharedRasterMaterial(l.length);t.material=i,bindMaterialInfoToMesh(t,l,e.terrainBoundRect)}}e.state=h,e.loadStateKey=c}_getTileCoordConfig(e,t){const i=e.grid,n=t.grid,r=i.rasterProjection,s=n.sourceProjection;if(r.name===s.name&&i.name===n.name&&e.z===t.z&&e.x===t.x&&e.y===t.y)return{offsetX:0,offsetY:0,scaleX:1,scaleY:1};let a=null,o=null;r.isGeo?(a=t.geoBoundingBox,o=e.geoBoundingBox):(a=t.targetBoundingBox,o=e.targetBoundingBox);const l=(o.max.x-o.min.x)/(a.max.x-a.min.x),c=(o.max.y-o.min.y)/(a.max.y-a.min.y);return{offsetX:(a.min.x-o.min.x)/(a.max.x-a.min.x),offsetY:(a.min.y-o.min.y)/(a.max.y-a.min.y),scaleX:l,scaleY:c}}_getUpperSampleReadyTile(e,t){let i=t.loadingUpperSampleLevel;if(0===i)return null;for(e=e.parent;i>0&&e;){if(e.state===TILE_STATE_COMPLETED)return e;e=e.parent,i--}return null}_getCoverageTilesFromProvider(e,t){return t.computeCoverageTilesCoord(e)}_onlyRequestTileContents(e,t=!1){const i=e.terrainTile,n=e.imageryTiles,r=this._surface.terrainProvider,s=this._surface.imageryProviders;if(i&&r.requestTileData(i,e),!t)for(let a=0;a<n.length;++a){const t=n[a];if(!t)continue;const i=s[a];for(let n=0;n<t.length;++n){const r=t[n];r&&i.requestTileData(r,e)}}}requestSurfaceTile(e,t=!1){if(this._tiles.has(e)){const i=this._tiles.get(e);return i.needsUpdate&&this._updateSurfaceTileData(i),t?void(i.state!==DATA_STATE_CAN_RENDER&&i.state!==DATA_STATE_STABLE$1&&this._onlyRequestTileContents(i,!0)):void(i.state!==DATA_STATE_STABLE$1&&this._onlyRequestTileContents(i))}const i=this._surface,n=i.terrainProvider;if(n.initState!==INIT_STATE_INITIALIZED)return;const r=i.imageryProviders;for(const l of r)if(l.initState!==INIT_STATE_INITIALIZED&&l.initState!==INIT_STATE_FAILED)return;const s=new SurfaceTile(e);s.isRasterSurfaceTile=!0,s.state=DATA_STATE_UNRENDERABLE$1;const a=n.getTile(e.z,e.x,e.y,e,s);s.terrainBoundRect=n.grid.computeTileCoverageRect(a,e),n.requestTileData(a,s),s.terrainTile=a;const o=[];for(const l of r){if(!l.compatible||!l.visible){o.push(null);continue}const i=this._getCoverageTilesFromProvider(e,l),n=[];for(const r of i){const i=l.getTile(r[0],r[1],r[2],e,s);i&&(n.push(i),t||l.requestTileData(i,s))}o.push(n)}s.imageryTiles=o,t&&(s.needsUpdate=!0),this._tiles.set(e,s)}clear(){this._tiles=new WeakMap}dispose(){}}class RasterSurface extends MapSurface{constructor(e,t,i={}){super(i),__publicField(this,"name","RasterSurface"),__publicField(this,"isMapRasterSurface",!0),this._terrainProvider=e,this._imageryProviders=t||[],this._surfaceTileManager=new RasterSurfaceTileManager(this),this.strategy||(this.strategy=new HierarchicalTileLoaderStrategy(i))}addImageryLayer(e){this._imageryProviders.push(e)}removeImageryLayer(e){const t=this._imageryProviders.indexOf(e);t>-1&&this._imageryProviders.splice(t,1)}_getCurrentGrid(){return this._terrainProvider.grid}_updateMaxLevel(){let e=0;this._terrainProvider&&this._terrainProvider.maxLevel!==1/0&&(e=Math.max(e,this._terrainProvider.maxLevel));for(let t=0;t<this._imageryProviders.length;++t)this._imageryProviders[t].ignoreLevelLimit||this._imageryProviders[t].maxLevel!==1/0&&(e=Math.max(e,this._imageryProviders[t].maxLevel));this._maxLevel=e,this._minLevel=this._terrainProvider.minLevel}beginFrame(e){if(super.beginFrame(e),!this._terrainProvider)return!1;const t=this._quadMap._engine,i=t.map.projection,n=t.map.coordType;let r=null;if(this._terrainProvider&&(this._terrainProvider._engine=t,this._terrainProvider.targetProjection=i,this._terrainProvider.targetCoordType=n,this._terrainProvider.beginFrame(e),r=this._terrainProvider.rasterProjection,this._terrainProvider.isReady()))for(let s=0;s<this._imageryProviders.length;++s)this._imageryProviders[s]._engine=t,this._imageryProviders[s].targetProjection=r,this._imageryProviders[s].targetCoordType=n,this._imageryProviders[s].beginFrame(e);this._updateMaxLevel()}endFrame(e){this._terrainProvider&&this._terrainProvider.endFrame(e);for(let t=0;t<this._imageryProviders.length;++t)this._imageryProviders[t].endFrame(e);super.endFrame(e)}get terrainProvider(){return this._terrainProvider}set terrainProvider(e){this._terrainProvider!==e&&(this._terrainProvider&&this.clearTilesInView(),this._terrainProvider=e,this._surfaceTileManager.clear(),this._quadMap._engine.requestRender())}get imageryProviders(){return this._imageryProviders}set imageryProviders(e){this._imageryProviders=e,this._surfaceTileManager.clear(),this._quadMap._engine.requestRender()}}const DATA_STATE_UNRENDERABLE=0,DATA_STATE_STABLE=2;class VectorSurfaceTileManager extends SurfaceTileManager{constructor(){super(...arguments),__publicField(this,"_tiles",new WeakMap)}isTileRenderable(e,t){const i=this._tiles.get(e);return!!i&&(i.frameCount!==t.frameCount&&(this._updateSurfaceTileData(i),i.frameCount=t.frameCount),i.state!==DATA_STATE_UNRENDERABLE)}markTileUsed(e){const t=this._tiles.get(e);if(!t)return null;const i=this._surface.tileProvider,n=t.dataTile;n&&i.markTileUsed(n)}isTileComputable(e,t){const i=this._tiles.get(e);return!!i&&(i.frameCount!==t.frameCount&&(this._updateSurfaceTileData(i),i.frameCount=t.frameCount),i.dataTile&&i.dataTile.state===TILE_STATE_COMPLETED)}isTileStable(e,t){const i=this._tiles.get(e);return!!i&&(i.frameCount!==t.frameCount&&(this._updateSurfaceTileData(i),i.frameCount=t.frameCount),i.state===DATA_STATE_STABLE)}_updateSurfaceTileData(e){e.needsUpdate=!1;const t=e.dataTile,i=this._surface.quadMap._engine;if(t.state!==TILE_STATE_COMPLETED)return e.state=DATA_STATE_UNRENDERABLE,void i.requestRender();e.state=DATA_STATE_STABLE;const n=t.data;if(n&&n[0]){const t=n[0];e.object=t}if(n&&n[1]){const t=n[1];e.groundObject=t}}getSurfaceTile(e,t){const i=this._tiles.get(e);return i?(i.frameCount!==t.frameCount&&(this._updateSurfaceTileData(i),i.frameCount=t.frameCount),i.state!==DATA_STATE_UNRENDERABLE?i:void 0):null}_onlyRequestTileContents(e){const t=e.dataTile,i=this._surface.tileProvider;t&&i.requestTileData(t,e)}cancelSurfaceTiles(e){const t=[];for(let n=0;n<e.length;n++){const i=e[n],r=this._tiles.get(i);r&&(r.dataTile&&t.push(i))}const i=this._surface.tileProvider;i.cancelTiles&&i.cancelTiles(t)}requestSurfaceTile(e){if(this._tiles.has(e)){const t=this._tiles.get(e);return t.needsUpdate&&this._updateSurfaceTileData(t),void(t.state!==DATA_STATE_STABLE&&this._onlyRequestTileContents(t))}const t=this._surface.tileProvider;if(t.initState!==INIT_STATE_INITIALIZED)return;const i=new SurfaceTile(e);i.state=DATA_STATE_UNRENDERABLE;const n=t.getTile(e.z,e.x,e.y,null,i);t.requestTileData(n,i),i.dataTile=n,this._tiles.set(e,i)}clear(){this._tiles=new WeakMap}dispose(){}}class VectorSurface extends MapSurface{constructor(e,t={}){super(t),__publicField(this,"name","VectorSurface"),__publicField(this,"isMapVectorSurface",!0),__publicField(this,"_useTargetProjectionBoundingBox",!0),__publicField(this,"_onTileCreated",(e=>{})),this._tileProvider=e,this._surfaceTileManager=new VectorSurfaceTileManager(this),this.strategy||(this.strategy=new FastTileLoaderStrategy(t))}_getCurrentGrid(){return this._tileProvider.grid}beginFrame(e){if(super.beginFrame(e),!this._tileProvider)return!1;const t=this._quadMap._engine,i=t.map.projection,n=t.map.coordType;this._tileProvider&&(this._shouldRenderPlaceholder=this._tileProvider._shouldRenderPlaceholder,this._placeholderColor=this._tileProvider._placeholderColor,this._tileProvider._engine=t,this._tileProvider.targetProjection=i,this._tileProvider.targetCoordType=n,this._tileProvider.beginFrame(e)),this._maxLevel=this._tileProvider.maxLevel,this._minLevel=this._tileProvider.minLevel}endFrame(e){super.endFrame(e)}onSurfaceTileAdded(e){this._tileProvider.onSurfaceTileAdded&&this._tileProvider.onSurfaceTileAdded(e,this.engine)}onSurfaceTileRemoved(e){this._tileProvider.onSurfaceTileRemoved&&this._tileProvider.onSurfaceTileRemoved(e,this.engine)}onSurfaceTileRefresh(e){this._tileProvider.onSurfaceTileRefresh&&this._tileProvider.onSurfaceTileRefresh(e,this.engine)}onSurfaceTileSSEChanged(e){this._tileProvider.onSurfaceTileSSEChanged&&this._tileProvider.onSurfaceTileSSEChanged(e,this.engine)}dispose(){super.dispose()}get tileProvider(){return this._tileProvider}set tileProvider(e){this._tileProvider!==e&&(this._tileProvider&&this.clearTilesInView(),this._tileProvider=e,this._surfaceTileManager.clear(),this._quadMap._engine.requestRender())}}class TerrainTileProvider extends TileProvider{async doRequestTileData(e){}onTileDispose(e){const t=e.data;t&&t.dispose()}}TerrainTileProvider.heightmapTerrainQuality=.25,TerrainTileProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap=function(e,t,i){return 2*e.maximumRadius*Math.PI*TerrainTileProvider.heightmapTerrainQuality/(t*i)};class GeoGrid extends Grid{constructor(){super(...arguments),__publicField(this,"name",MAP_GRID_NAME_GEO),__publicField(this,"_useGeoSubdivision",!0),__publicField(this,"_minLevel",1)}getRootTiles(){const e=new MapTile(this,1,0,0);e.geoBoundingBox=new three.Box3(new three.Vector3(-180,-90,-.1),new three.Vector3(0,90,.1)),e.projectedBoundingBox=new three.Box3(new three.Vector3(-180,-90,0),new three.Vector3(0,90,0));const t=new MapTile(this,1,1,0);return t.geoBoundingBox=new three.Box3(new three.Vector3(0,-90,-.1),new three.Vector3(180,90,.1)),t.projectedBoundingBox=new three.Box3(new three.Vector3(0,-90,0),new three.Vector3(180,90,0)),[e,t]}getTileReverseY(e){return Math.pow(2,e.z-1)-e.y-1}getTileSizeAtLevel(e){return 360/Math.pow(2,e)}getTileCoordX(e,t){return(e+180)/t}getTileCoordY(e,t){return(e+90)/t}}new three.Vector3,new three.Vector3;class PlaneTerrainTileProvider extends TerrainTileProvider{constructor(){super(...arguments),__publicField(this,"name","PlaneTerrainTileProvider"),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_WEB_MERCATOR,PROJECTION_ECEF,PROJECTION_GEO]),__publicField(this,"_supportAllProjections",!0),__publicField(this,"_levelZeroMaximumGeometricError",TerrainTileProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(Ellipsoid.WGS84,64,2))}initProjectionAndGrid(){this._targetProjection.name===PROJECTION_WEB_MERCATOR?(this._sourceProjection=this._targetProjection,this._grid=new WebMercatorGrid(this._engine,this._sourceProjection,this._targetProjection)):(this._sourceProjection=getProjection(PROJECTION_GEO),this._grid=new GeoGrid(this._engine,this._sourceProjection,this._targetProjection));const e=this._targetProjection.name;let t=null;t=getProjection(e===PROJECTION_WEB_MERCATOR?PROJECTION_WEB_MERCATOR:PROJECTION_GEO),this.rasterProjection=t,this._grid.rasterProjection=t}doRequestTileData(e){const t={x:e.x,y:e.y,z:e.z,targetProjection:this._targetProjection,sourceProjection:this._sourceProjection,targetProjectionName:this._targetProjection.name,sourceProjectionName:this._sourceProjection.name,targetCenter:this._vectorToArray(e.targetCenter),geoBoundingBox:this._boxToArray(e.geoBoundingBox),forceProjectCoordinates:!0,projectedBoundingBox:e.projectedBoundingBox.isBox3?this._boxToArray(e.projectedBoundingBox):[]},i=createGroundTileMesh(t,{}),n=new three.BufferGeometry;return n.setIndex(i.indices),n.setAttribute("position",new three.Float32BufferAttribute(i.vertices,3)),n.setAttribute("normal",new three.Float32BufferAttribute(i.normals,3)),n.setAttribute("uv",new three.Float32BufferAttribute(i.uvs,2)),n}_vectorToArray(e){return[e.x,e.y,e.z]}_boxToArray(e){return[e.min.x,e.min.y,e.min.z,e.max.x,e.max.y,e.max.z]}}const _copyVector=new three.Vector2,_currentClearColor$1=new three.Color(0);let _currentClearAlpha$1=1,_currentAutoClear$1=!0;const vertexShader$m="\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader$k="\n    uniform sampler2D baseMap;\n    uniform sampler2D labelMap;\n    uniform float labelIndex;\n    varying vec2 vUv;\n    void main() {\n        if (vUv.x < 0.004 || vUv.x > 0.996 || vUv.y < 0.004 || vUv.y > 0.996) {\n            gl_FragColor = vec4(0, 0.7, 0, 1.0);\n        }\n        else {\n            vec4 baseColor = texture2D(baseMap, vUv);\n            vec2 labelUv = vec2(vUv.x, vUv.y * 10.0 - labelIndex);\n            if (labelUv.y >= 0.0 && labelUv.y <= 1.0) {\n                vec4 labelColor = texture2D(labelMap, labelUv);\n                baseColor = mix(baseColor, labelColor, labelColor.a);\n            }\n            gl_FragColor = baseColor;\n            // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n    }\n";class ImageTileLabelRenderer{static _initResource(){this._renderTarget=new three.WebGLRenderTarget(512,512),this._renderTarget.name="ImageTileLabelRenderer",this._renderTarget.texture.name="ImageTileLabelRenderer",this._camera=new three.OrthographicCamera(-.5,.5,.5,-.5,0,1);const e=new three.PlaneGeometry(1,1,1),t=new three.ShaderMaterial({vertexShader:vertexShader$m,fragmentShader:fragmentShader$k,uniforms:{baseMap:{value:null},labelMap:{value:null},labelIndex:{value:0}},transparent:!0});this._mesh=new three.Mesh(e,t);const i=this._canvas=document.createElement("canvas");i.width=256,i.height=32;const n=this._ctx=i.getContext("2d");n.fillStyle="rgba(0, 180, 0, 1)",n.font="16px arial",n.textBaseline="bottom",n.shadowColor="rgba(255, 255, 255, 1)",n.shadowBlur=0,n.shadowOffsetX=1,n.shadowOffsetY=1;const r=this._canvasTexture=new three.CanvasTexture(i);t.uniforms.labelMap.value=r}static render(e,t,i){this._renderTarget||this._initResource();const n=e.getRenderTarget();e.getClearColor(_currentClearColor$1),_currentClearAlpha$1=e.getClearAlpha(),_currentAutoClear$1=e.autoClear;const r=this._camera;let s=256,a=256;t.image&&(s=t.image.width,a=t.image.height);const o=this._renderTarget;o.width===s&&o.height===a||o.setSize(s,a);const l=this._canvas,c=this._ctx;c.clearRect(0,0,l.width,l.height),c.fillText(i.key,0,32),this._canvasTexture.needsUpdate=!0,e.setRenderTarget(o),e.autoClear=!1,e.clear();this._mesh.material.uniforms.baseMap.value=t,e.render(this._mesh,r);const h=new three.FramebufferTexture(s,a);return h.minFilter=three.LinearFilter,h.magFilter=three.LinearFilter,e.copyFramebufferToTexture(h,_copyVector),e.setRenderTarget(n),e.setClearColor(_currentClearColor$1,_currentClearAlpha$1),e.autoClear=_currentAutoClear$1,h}}class BaseImageryTileProvider extends TileProvider{constructor(e={}){super(e),__publicField(this,"_loadingUpperSampleLevel",100),__publicField(this,"isBaseImageryTileProvider",!0),__publicField(this,"name","BaseImageryTileProvider"),__publicField(this,"_opacity",1),__publicField(this,"_colorTint",[1,1,1]),__publicField(this,"_randomColorTint",!1),__publicField(this,"_addDebugLabel",!1),this._opacity=e.opacity,this._colorTint=e.colorTint||[1,1,1],this._randomColorTint=e.randomColorTint||!1,this._placeholderColor=e.placeholderColor,void 0===this._opacity&&(this._opacity=1)}async doRequestTileData(e,t){const i=await this.doRequestImageTileData(e,t);return this._addDebugLabel?ImageTileLabelRenderer.render(this._engine.renderer,i,e):i}set opacity(e){this._opacity=e,this._needsIncreTilesEpoch=!0}get opacity(){return this._opacity}set colorTint(e){this._colorTint=e,this._needsIncreTilesEpoch=!0}get colorTint(){return this._colorTint}set randomColorTint(e){this._randomColorTint!==e&&(this._randomColorTint=e,this._needsClearCache=!0)}get randomColorTint(){return this._randomColorTint}set addDebugLabel(e){this._addDebugLabel!==e&&(this._addDebugLabel=e,this._needsClearCache=!0)}get addDebugLabel(){return this._addDebugLabel}}const vertexShader$l="\n// attribute vec3 position;\n// attribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader$j="\nuniform sampler2D map;\nuniform vec3 color;\nvarying vec2 vUv;\nvoid main() {\n    gl_FragColor = texture2D(map, vUv);\n    // gl_FragColor = vec4(color, 1.0);\n}\n";class ImageryReprojectMaterial extends three.ShaderMaterial{constructor(e={}){super(),this.name="ImageryReprojectMaterial",this.fragmentShader=fragmentShader$j,this.vertexShader=vertexShader$l,this.uniforms={map:{value:null},color:{value:new three.Vector3(1,1,1)}}}dispose(){super.dispose()}}const _camera=new three.OrthographicCamera(-.5,.5,.5,-.5,0,1),_vector$4=new three.Vector2,_tempInput=new three.Vector3,_tempOutput=new three.Vector3;class ImageryReprojector{_initResource(){this._renderTarget=new three.WebGLRenderTarget(256,256),this._renderTarget.name="ImageryReprojector",this._renderTarget.texture.name="ImageryReprojector";const e=this._geometry=new three.PlaneGeometry(1,1,1,63);this._material=new ImageryReprojectMaterial,this._mesh=new three.Mesh(e,this._material)}reprojectImagery(e,t,i,n,r,s){this._mesh||this._initResource(),this._material.uniforms.map.value=i;const a=this._geometry.attributes.uv.array;let o=t.projectedBoundingBox.min.y,l=t.projectedBoundingBox.max.y;const c=t.geoBoundingBox.min.y,h=t.geoBoundingBox.max.y;if(r.name,s.name,r.isGeo){if(s.isGeo)throw new Error("Not implemented");{const e=1/(h-c);let i=t.targetBoundingBox.min.y,n=t.targetBoundingBox.max.y;for(let t=0;t<64;++t){let s=1-t/63,o=three.MathUtils.lerp(i,n,s);_tempInput.set(0,o,0),r.unprojectCoordinate(_tempInput,_tempOutput);let l=(_tempOutput.y-c)*e;a[4*t+1]=l,a[4*t+3]=l}throw new Error("Need double check")}}{const e=1/(l-o);if(s.isGeo)for(let t=0;t<64;++t){let i=1-t/63,n=three.MathUtils.lerp(c,h,i);_tempInput.set(0,n,0),r.projectCoordinate(_tempInput,_tempOutput);let s=(_tempOutput.y-o)*e;a[4*t+1]=s,a[4*t+3]=s}else for(let t=0;t<64;++t){let e=1-t/63,i=three.MathUtils.lerp(o,l,e);_tempInput.set(0,i,0),s.unprojectCoordinate(_tempInput,_tempOutput),_tempInput.copy(_tempOutput),r.projectCoordinate(_tempInput,_tempOutput),a[4*t+1]=e,a[4*t+3]=e}}this._geometry.attributes.uv.needsUpdate=!0;const u=this._renderTarget;let d=e.getRenderTarget();return u.width===n.image.width&&u.height===n.image.height||u.setSize(n.image.width,n.image.height),e.setRenderTarget(u),e.clear(),e.render(this._mesh,_camera),e.copyFramebufferToTexture(n,_vector$4),e.setRenderTarget(d),u}dispose(){this._renderTarget.dispose(),this._mesh.geometry.dispose(),this._mesh.material.dispose()}}let fallbackTexture;function getFallbackTexture(){if(!fallbackTexture){const e=1,t=new Uint8Array(4*e);for(let i=0;i<t.length;++i)t[i]=0;fallbackTexture=new three.DataTexture(t,e,e,three.RGBAFormat),fallbackTexture.needsUpdate=!0}return fallbackTexture}ImageryReprojector.DEFAULT=new ImageryReprojector;const _tempInputCoord=new three.Vector3,_tempOutputCoord=new three.Vector3,textureLoader$6=new three.TextureLoader;class ImageryTileProvider extends BaseImageryTileProvider{constructor(){super(...arguments),__publicField(this,"name","ImageryTileProvider"),__publicField(this,"isImageryTileProvider",!0),__publicField(this,"useExtendTargetBoundingBox",!0)}getTileURL(e,t,i,n){}shouldReproject(e,t,i,n){const r=e.name,s=t.name,a=n.grid.useGeoSubdivision;if(i.grid.useGeoSubdivision===a&&r===s)return!1;if(e.isGeo){if(t.isGeo)return!1;throw new Error("Not implemented")}if(t.isGeo){const t=(i.geoBoundingBox.min.y+i.geoBoundingBox.max.y)/2,n=(i.projectedBoundingBox.min.y+i.projectedBoundingBox.max.y)/2;_tempInputCoord.set(0,t,0),e.projectCoordinate(_tempInputCoord,_tempOutputCoord);return Math.abs(_tempOutputCoord.y-n)/i.grid.getPixelSizeByLevel(i.z)>.1}{const n=(i.projectedBoundingBox.min.y+i.projectedBoundingBox.max.y)/2;_tempInputCoord.set(0,n,0),e.unprojectCoordinate(_tempInputCoord,_tempOutputCoord),_tempInputCoord.copy(_tempOutputCoord),t.projectCoordinate(_tempInputCoord,_tempOutputCoord);return Math.abs(_tempOutputCoord.y-n)/i.grid.getPixelSizeByLevel(i.z)>.1}}doRequestImageTileData(e,t){const i=t.terrainTile,n=this.getTileURL(e.z,e.x,e.y,e);return e._url=n,new Promise(((t,r)=>{textureLoader$6.load(n,(n=>{n.colorSpace=three.SRGBColorSpace,n.generateMipmaps=!1;let r=256,s=256;if(n.image&&(r=n.image.width,s=n.image.height),this.shouldReproject(this._sourceProjection,this._targetProjection,e,i)){const i=new three.FramebufferTexture(r,s);i.minFilter=three.LinearFilter,i.magFilter=three.LinearFilter,ImageryReprojector.DEFAULT.reprojectImagery(this._engine.renderer,e,n,i,this._sourceProjection,this._targetProjection),i.colorSpace=three.SRGBColorSpace,t(i),n.dispose()}else t(n)}),null,r)}))}errorFallback(){return getFallbackTexture()}onTileDispose(e){const t=e.data;t&&t.dispose()}}const http$b="https:",createUrlGenerator=e=>{switch(e){case BING_MAP_STYLE_AERIAL:return e=>`${http$b}//ecn.t${e%4}.tiles.virtualearth.net/tiles/a${e}.jpeg?g=13651`;case BING_MAP_STYLE_AERIAL_WITH_LABELS:return e=>`${http$b}//t${e%4}.ssl.ak.dynamic.tiles.virtualearth.net/comp/ch/${e}?mkt=en-US&it=A,G,L&og=2697&n=z`;case BING_MAP_STYLE_ROAD:return e=>`${http$b}//t${e%4}.ssl.ak.dynamic.tiles.virtualearth.net/comp/ch/${e}?mkt=en-US&it=G,L&shading=hill&og=2697&n=z`;default:return e=>`${http$b}//ecn.t${e%4}.tiles.virtualearth.net/tiles/a${e}.jpeg?g=13651`}},urlGeneratorCache=new Map;class BingImageryTileProvider extends ImageryTileProvider{constructor(e={}){super({...e,projection:PROJECTION_WEB_MERCATOR}),__publicField(this,"name","BingImageryTileProvider"),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_WEB_MERCATOR,PROJECTION_GEO]),__publicField(this,"_defaultStartLevel",1),__publicField(this,"_defaultMaxLevel",18),__publicField(this,"_maxParallelRequestNum",24),__publicField(this,"_useWebMeractorProjectionAndGrid",!0),__publicField(this,"_urlGenerator",null),this._style=e.style||BING_MAP_STYLE_AERIAL,urlGeneratorCache.has(this._style)||urlGeneratorCache.set(this._style,createUrlGenerator(this._style)),this._urlGenerator=urlGeneratorCache.get(this._style)}get style(){return this._style}set style(e){this._style!==e&&(this._style=e,urlGeneratorCache.has(this._style)||urlGeneratorCache.set(this._style,createUrlGenerator(this._style)),this._urlGenerator=urlGeneratorCache.get(this._style),this._needsClearCache=!0)}getTileURL(e,t,i,n){if(0===e)return!1;const r=this.quadKey(e,t,n.reverseY);return this._urlGenerator(r)}quadKey(e,t,i){let n="";for(let r=e;r>0;r--){const e=1<<r-1;let s=0;0!==(t&e)&&s++,0!==(i&e)&&(s+=2),n+=s}return n}}const _projection=new three.Matrix4,_frustum=new three.Frustum,_vector$3=new three.Vector3,_vector2=new three.Vector3;class MapView extends three.Object3D{constructor(e={}){super(),__publicField(this,"isRenderAsyncObject",!0),__publicField(this,"isQuadMap",!0),__publicField(this,"supportRenderPassCallbacks",!0),__publicField(this,"_freezeUpdate",!1),__publicField(this,"_lodScaleFactor",2),__publicField(this,"_cameraFarRatio",1),__publicField(this,"_camera",null),__publicField(this,"_lastUpdateTime",0),__publicField(this,"_delayUpdateTime",15),__publicField(this,"_delayUpdateTimeHandler",null),__publicField(this,"_restrictedBounds",[]),__publicField(this,"_engine"),__publicField(this,"_grid"),__publicField(this,"_options"),__publicField(this,"_surfaces",[]),__publicField(this,"onAfterColorPass",(e=>{for(let t=0;t<this._surfaces.length;t++){const i=this._surfaces[t];i.onAfterColorPass&&i.onAfterColorPass(e)}})),__publicField(this,"onAfterMainPass",(e=>{for(let t=0;t<this._surfaces.length;t++){const i=this._surfaces[t];i.onAfterMainPass&&i.onAfterMainPass(e)}})),__publicField(this,"_updateCameraInfo",((e,t)=>{e.rendering.resolution,t.projectionMatrix.elements;const i=t.matrixWorldInverse.elements;this._sseDenominator=2*Math.tan(.5*t.fov/180*Math.PI),_vector$3.set(i[2],i[6],i[10]).normalize().negate(),e.map.isGlobe?_vector2.copy(t.position).normalize():_vector2.set(0,0,1),this._pitchRatio=_vector$3.dot(_vector2)})),__publicField(this,"getKeyByValue",((e,t)=>{for(let i in e)if(e.hasOwnProperty(i)&&e[i].includes(t))return i===String(t)?null:i;return null})),__publicField(this,"addRestrictedBoundingBox",((e,t)=>{const i=this._engine.map;let n=i.projectArrayCoordinate(e),r=i.projectArrayCoordinate(t);const s=new three.Box3;return s.min.set(n[0],n[1],n[2]||-100),s.max.set(r[0],r[1],n[2]||100),this._restrictedBounds.push(s),s})),__publicField(this,"removeRestrictedBounds",(e=>{this._restrictedBounds.includes(e)&&this._restrictedBounds.splice(e,1)})),this._options=e}addSurface(e){e.quadMap=this,e.engine=this._engine,this._surfaces.push(e),this.add(e)}addRasterSurface(e,t,i){const n=new RasterSurface(e,t,i);return this.addSurface(n),n}addVectorSurface(e,t){const i=new VectorSurface(e,t);return this.addSurface(i),i}removeSurface(e){const t=this._surfaces.indexOf(e);if(t>-1){const e=this._surfaces.splice(t,1)[0];e.clearTilesInView(),this.remove(e),e.quadMap=null}}setTerrainProvider(e){this._rasterSurface?this._rasterSurface.terrainProvider=e:console.warn("No raster surface")}setImageryProviders(e){this._rasterSurface?this._rasterSurface.imageryProviders=e:console.warn("No raster surface")}setImageryProvider(e){this.setImageryProviders([e])}setVectorProvider(e,t){if(this._vectorSurface)this._vectorSurface.tileProvider=e;else{if(!e)return;this._vectorSurface=this.addVectorSurface(e,t)}}getImageryProviders(){return this._rasterSurface?this._rasterSurface.imageryProviders:null}createTileLoader(){}createGrid(e){}afterAddToEngine(e){this._projection=e.map.projection,this._engine=e,this._initDefaultSurfaces()}_initDefaultSurfaces(){const e=this._options;if(e.rasterSurface)this._rasterSurface=e.rasterSurface,this.addSurface(e.rasterSurface);else{let t=e.terrainProvider;void 0===t&&(t=new PlaneTerrainTileProvider({}));let i=e.imageryProviders;void 0===i&&(e.imageryProvider?i=[e.imageryProvider]:void 0===e.imageryProvider&&(i=[new BingImageryTileProvider({})])),t&&(this._rasterSurface=this.addRasterSurface(t,i))}e.vectorSurface?(this._vectorSurface=e.vectorSurface,this.addSurface(e.vectorSurface)):e.vectorProvider&&(this._vectorSurface=this.addVectorSurface(e.vectorProvider,e.vectorSurfaceOptions))}beforeRemoveFromEngine(e){this.dispose()}onBeforeScenePrepareRender(e,t,i,n){if(this._freezeUpdate||!this.visible)return clearTimeout(this._delayUpdateTimeHandler),void(this._delayUpdateTimeHandler=null);if(this._delayUpdateTimeHandler)return;const r=Date.now(),s=r-this._lastUpdateTime;if(s<this._delayUpdateTime)return void(this._delayUpdateTimeHandler=setTimeout((()=>{this._delayUpdateTimeHandler=null,e.requestRender()}),this._delayUpdateTime-s+1));let a=i;this._cameraFarRatio<1&&(this._camera||(this._camera=i.clone()),a=this._camera,a.copy(i),a.far=i.far*this._cameraFarRatio,a.updateProjectionMatrix()),this._updateCameraInfo(e,i),this._updateSurfaces(e,t,a,n),this._lastUpdateTime=r}onBeforeSceneRender(e,t,i,n){for(let r=0;r<this._surfaces.length;r++){const s=this._surfaces[r];s._onBeforeSceneRender&&s._onBeforeSceneRender(e,t,i,n)}}_updateSurfaces(e,t,i,n){_projection.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),_frustum.setFromProjectionMatrix(_projection),_vector$3.copy(i.position);for(let r=0;r<this._surfaces.length;r++){this._surfaces[r].updateView(e,_vector$3,_frustum,n)}}refresh(){for(let e=0;e<this._surfaces.length;e++){const t=this._surfaces[e];t.refresh&&t.refresh()}}onTileAdded(e){}onTileRemoved(e){}onTileDisposed(e){}getTileProvidersByName(e){const t=[];for(let i=0;i<this._surfaces.length;i++){const n=this._surfaces[i];n.tileProvider.name===e&&t.push(n.tileProvider)}return t}dispose(){this._vectorSurface&&this.removeSurface(this._vectorSurface)}printSurfacesStatistics(){for(let e=0;e<this._surfaces.length;e++)this._surfaces[e]}_getCurrentCamera(){return this._cameraFarRatio<1&&this._camera||this._engine.camera}showCameraFrustum(){const e=this._engine;this.destroyCameraHelper();const t=this._getCurrentCamera(),i=this._lockedCamera=t.clone(),n=this._cameraHelper=new three.CameraHelper(i);e.add(n)}destroyCameraHelper(){const e=this._engine;this._cameraHelper&&(e.remove(this._cameraHelper),this._cameraHelper.dispose(),this._cameraHelper=null)}isInStableRenderState(){for(let e=0;e<this._surfaces.length;e++){if(!this._surfaces[e].isInStableRenderState())return!1}return!0}get freezeUpdate(){return this._freezeUpdate}set freezeUpdate(e){this._freezeUpdate=e}get lodScaleFactor(){return this._lodScaleFactor}set lodScaleFactor(e){this._lodScaleFactor=e,this._engine.requestRender()}get cameraFarRatio(){return this._cameraFarRatio}set cameraFarRatio(e){this._cameraFarRatio=e}get rasterSurface(){return this._rasterSurface}get vectorSurface(){return this._vectorSurface}get surfaces(){return this._surfaces}}const _tempVector3$4=new three.Vector3,_tempVector2$1=new three.Vector2,_currentClearColor=new three.Color(0);let _currentClearAlpha=1,_currentAutoClear=!0,fallbackMesh;class VectorTileImageRenderer{static _initResource(){this._renderTarget=new three.WebGLRenderTarget(512,512),this._renderTarget.name="VectorTileImageRenderer",this._renderTarget.texture.name="VectorTileImageRenderer",this._camera=new three.OrthographicCamera(-1,1,1,-1,.1,1e3),this._testMesh=new three.Mesh(new three.BoxGeometry(100,100,100),[new three.MeshBasicMaterial({color:65280,side:three.DoubleSide}),new three.MeshBasicMaterial({color:255,side:three.DoubleSide}),new three.MeshBasicMaterial({color:16711680,side:three.DoubleSide}),new three.MeshBasicMaterial({color:16776960,side:three.DoubleSide}),new three.MeshBasicMaterial({color:65535,side:three.DoubleSide}),new three.MeshBasicMaterial({color:16711935,side:three.DoubleSide})])}static render(e,t,i,n){this._renderTarget||this._initResource();const r=e.getRenderTarget();e.getClearColor(_currentClearColor),_currentClearAlpha=e.getClearAlpha(),_currentAutoClear=e.autoClear;const s=this._camera;i.targetBoundingBox.getSize(_tempVector3$4);const a=_tempVector3$4.x/2,o=_tempVector3$4.y/2,l=_tempVector3$4.z/2;s.left=-a,s.right=a,s.top=o,s.bottom=-o,s.near=.1,s.far=_tempVector3$4.z+1e3,s.updateProjectionMatrix(),_tempVector3$4.copy(i.targetCenter),_tempVector3$4.z+=l+10,s.position.copy(_tempVector3$4),s.lookAt(i.targetCenter),s.updateMatrix(),s.updateMatrixWorld(),e.setRenderTarget(this._renderTarget),e.autoClear=!1,e.clear();const c=i.grid.getPixelSizeByLevel(i.z);if(t[1]&&t[1].children.length>0){for(const e of t[1].children){if(!e||!e.material)continue;const t=e.material;t.isShaderMaterial&&t.uniforms.zoomUnits&&(t.uniforms.zoomUnits.value=c)}e.render(t[1],s)}if(t[0]&&t[0].children.length>0){for(const e of t[0].children){const t=e.material;t.isShaderMaterial&&t.uniforms.zoomUnits&&(t.uniforms.zoomUnits.value=c)}e.render(t[0],s)}const h=new three.FramebufferTexture(2*n,2*n);return h.minFilter=three.LinearFilter,h.magFilter=three.LinearFilter,e.copyFramebufferToTexture(h,_tempVector2$1),e.setRenderTarget(r),e.setClearColor(_currentClearColor,_currentClearAlpha),e.autoClear=_currentAutoClear,h}}function getFallbackMesh(){if(!fallbackMesh){fallbackMesh=new three.Group;const e=new three.Mesh(new three.BufferGeometry,new three.MeshBasicMaterial);fallbackMesh.add(e)}return[fallbackMesh,fallbackMesh]}class VectorTileProvider extends BaseImageryTileProvider{constructor(){super(...arguments),__publicField(this,"isVectorTileProvider",!0),__publicField(this,"name","VectorTileProvider"),__publicField(this,"_imageryTileSize",256)}errorFallback(){return getFallbackMesh()}async doRequestImageTileData(e,t){let i=e;t.isRasterSurfaceTile&&this._grid.supportLevelReuse&&e._sourceTile&&(i=e._sourceTile);const n=await this.doRequestVectorTileData(i);if(!t||!t.isRasterSurfaceTile)return n;return VectorTileImageRenderer.render(this._engine.renderer,n,e,this._imageryTileSize)}getGroundTileData(e){const t={x:e.x,y:e.y,z:e.z,targetProjection:e.grid.targetProjection,sourceProjection:e.grid.sourceProjection,targetProjectionName:e.grid.targetProjection.name,sourceProjectionName:e.grid.sourceProjection.name,targetCenter:e.targetCenter.toArray(),geoBoundingBox:e.availableGeoBoundingBox,forceUseGeoBoundingBox:!0,forceProjectCoordinates:!0,projectedBoundingBox:e.projectedBoundingBox.isBox3?e.projectedBoundingBox:[]},i=createGroundTileMesh(t,{layerIndices:0}),n=new three.BufferGeometry;n.setIndex(i.indices),n.setAttribute("position",new three.BufferAttribute(new Float32Array(i.vertices),3)),n.setAttribute("layerIndex",new three.BufferAttribute(new Float32Array(i.layerIndices),1)),n.setAttribute("uv",new three.BufferAttribute(new Float32Array(i.uvs),2)),n.setAttribute("normal",new three.BufferAttribute(new Float32Array(i.normals),3)),this._groundTileMaterial||(this._groundTileMaterial=new three.MeshBasicMaterial({color:8947848}));const r=new three.Mesh(n,this._groundTileMaterial);return r.position.copy(e.targetCenter),[null,r]}}class WorkerTaskScheduler{constructor(e,t){__publicField(this,"_size",1),__publicField(this,"_workerClass",null),__publicField(this,"_workers",[]),__publicField(this,"_currentRequestId",1),__publicField(this,"_requestMap",{}),__publicField(this,"_handleWorkerMessage",(async e=>{const t=e.data,i=this.getResponseMessageId(t,e);if(null==i)return void console.warn("no valid id in response message",e);const n=this._requestMap[i];if(!n)return void console.warn(`id ${i} not found in pending request`);this.onMessageReceived&&this.onMessageReceived(t,e);const r=this.isMessageCompleted(t,e),s=this.isMessageRefreshed(t,e);if(!r&&!s)return;delete this._requestMap[i];const a=n[3];this._workers[a].use--;const o=await this.onMessageCompleted(t,e,n[2]);n[0](o)})),this._workerClass=e,this._size=t}getRequestMessageId(e){return this._currentRequestId++}getResponseMessageId(e,t){return e.id}_getAvailableWorker(){if(1===this._size)return this._workers[0].instance;let e=-1,t=1/0;for(let i=0;i<this._size;i++){const n=this._workers[i];n.use<t&&(e=i,t=n.use)}return[e,this._workers[e].instance]}initWorkers(){if(0===this._workers.length)for(let e=0;e<this._size;e++){const e=new this._workerClass;e.addEventListener("message",this._handleWorkerMessage),e.addEventListener("error",this.onWorkerError),this._workers.push({instance:e,use:0})}}async postMessage(e,t,i){null==i&&(i=this.getRequestMessageId(e)),this.initWorkers();const[n,r]=this._getAvailableWorker();return void 0!==e.id&&null!==e.id||(e.id=i),r.postMessage(e,t),this._workers[n].use++,new Promise(((t,r)=>{this._requestMap[i]=[t,r,e,n]}))}async onMessageCompleted(e,t){return e}isMessageCompleted(e,t){return!0}isMessageRefreshed(e,t){return!1}postMessageToAll(e,t){this.initWorkers();for(const i of this._workers)i.instance.postMessage(e,t)}get size(){return this._size}}const ResponseMessageType={RESPONSE_TILE:"responseTile",REFRESH_TILE:"refreshTile"};class AsyncDataTileLoader{constructor(e,t,i){this.provider=e,this._workerTaskScheduler=new WorkerTaskScheduler(t,i),this._workerTaskScheduler.getResponseMessageId=this.getResponseMessageId,this._workerTaskScheduler.isMessageCompleted=this.isMessageCompleted,this._workerTaskScheduler.isMessageRefreshed=this.isMessageRefreshed;const n={type:"initCoordTransformer",data:CoordTransformer.serialize()};if(e.getWorkerOptions){const t=e.getWorkerOptions();n.workerOptions=t}this._workerTaskScheduler.postMessageToAll(n)}isMessageCompleted(e,t){return e.type===ResponseMessageType.RESPONSE_TILE}isMessageRefreshed(e,t){return e.type===ResponseMessageType.REFRESH_TILE}getResponseMessageId(e,t){const i=t.data;return i&&i.id?i.id:e.tileKey}_vectorToArray(e){return[e.x,e.y,e.z]}_boxToArray(e){return[e.min.x,e.min.y,e.min.z,e.max.x,e.max.y,e.max.z]}async requestTile(e){const t=this.provider;let i=t.getTileURL(e.z,e.x,e.y,e);const n={type:"requestTile",tileKey:e.key,sourceProjectionName:t.sourceProjection.name,targetProjectionName:t.targetProjection.name,projectedBoundingBox:this._boxToArray(e.projectedBoundingBox),geoBoundingBox:this._boxToArray(e.geoBoundingBox),projectedCenter:this._vectorToArray(e.projectedCenter),targetCenter:this._vectorToArray(e.targetCenter),x:e.x,y:e.y,z:e.z,reverseY:e.reverseY,url:i,timeStart:performance.now(),sourceCoordType:t.sourceCoordType||void 0,targetCoordType:t.targetCoordType||void 0};if(t.getFetchOptions){const i=t.getFetchOptions(e);n.fetchOptions=i}if(t.getWorkerOptions){const i=t.getWorkerOptions(e);n.workerOptions=i}const r=await this._workerTaskScheduler.postMessage(n,[]);if(r.isCancelled){const e=new Error("Tile request cancelled");throw e.name="AbortError",e}return r}async refreshTile(e){const t=this.provider,i=t.getTileURL(e.z,e.x,e.y,e),n={type:"refreshTile",tileKey:e.key,sourceProjectionName:t.sourceProjection.name,targetProjectionName:t.targetProjection.name,projectedBoundingBox:this._boxToArray(e.projectedBoundingBox),geoBoundingBox:this._boxToArray(e.geoBoundingBox),projectedCenter:this._vectorToArray(e.projectedCenter),targetCenter:this._vectorToArray(e.targetCenter),x:e.x,y:e.y,z:e.z,reverseY:e.reverseY,url:i,timeStart:performance.now()};if(t.getFetchOptions){const i=t.getFetchOptions(e);n.fetchOptions=i}if(t.getWorkerOptions){const i=t.getWorkerOptions(e);n.workerOptions=i}return await this._workerTaskScheduler.postMessage(n,[])}cancelTiles(e){const t=[];for(let i=0;i<e.length;i++){const n=e[i];t.push(n.key)}this.postMessageToAll({type:"cancelTiles",tileKeys:t})}postMessageToAll(e,t){this._workerTaskScheduler.postMessageToAll(e,t)}}function WorkerWrapper$2(){return new Worker(getAssetUrl('assets/workers/BaiduVectorParser.worker-486240e8.js'),{type:"module"})}function reFetch(e="",t={},i=3){return function e(t,n){return i--,fetch(t,n).then((e=>{if(200===e.status)return e;if(404===e.status)throw new Error("404")})).catch((r=>{if(n.signal&&"AbortError"===r.name)throw r;if(i>0)return e(t,n);throw r}))}(e,t)}function jsonp(t,i,n={}){let r,s,a,o="";n=Object.assign({},{autoCallback:!0,jsonp:"callback",timeout:5e4},n);const l=[];let c="jsonp"+Math.ceil(1e5*Math.random());if(n.callbackName&&!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(n.callbackName))throw new Error("Invalid callback name");n.callbackName&&(c=n.callbackName);const h=t.indexOf("?")>0?"&":"?";for(let e in i)({}).hasOwnProperty.call(i,e)&&(o="object"==typeof i[e]?e+"="+JSON.stringify(i[e]):e+"="+i[e],l.push(o));function u(){s.parentNode&&s.parentNode.removeChild(s),r&&clearTimeout(r),window[c]=null}return l.length>0&&(t+=h+l.join("&")),a=document.getElementsByTagName("script")[0]||document.head,n.autoCallback&&(t=t+"&"+n.jsonp+"="+c),s=document.createElement("script"),s.src=t,s.type="text/javascript",a.parentNode.appendChild(s,a),new Promise(((t,i)=>{window[c]=i=>{if(i&&"string"==typeof i)try{i=JSON.parse(i)}catch(e){i={},console.error("[ERROR] Parse Error.")}t(i),u()},s.onerror=e=>{u(),i({errno:-2,errmsg:`[ERROR] Load Error: ${e}`,data:{}})},n.timeout&&(r=setTimeout((()=>{u(),i({errno:-3,errmsg:"[ERROR] Time out.",data:{}})}),n.timeout))}))}const request=(e,t)=>fetch(e,Object.assign(t,{credentials:"include"})).then((e=>{if(e.ok)return e.json();throw Error("")})).then((e=>e)).catch((()=>{})),get$1=e=>request(e,{method:"GET"}),post=(e,t)=>request(e,{method:"POST",body:t});function defer(){let e,t;const i=new Promise((function(i,n){e=i,t=n}));return{resolve:e,reject:t,promise:i}}const request$1=Object.freeze(Object.defineProperty({__proto__:null,reFetch:reFetch,jsonp:jsonp,request:request,get:get$1,post:post,defer:defer},Symbol.toStringTag,{value:"Module"})),vertexShader$k="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#endif\n\n#include <normal_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\n#if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)\n    attribute float layerIndex;\n    varying float vLayerIndex;\n#endif\n\n#ifdef USE_AO\n    attribute vec2 heightAndConcave;\n    varying float v_concave;\n    varying float v_h;\n    varying float v_ground;\n#endif\n\n#ifdef MVT_USE_VERTEX_COLOR\n    #ifdef MVT_USE_COLOR4\n        attribute vec4 aColor;\n    #endif\n#endif\n\nvoid main() {\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        #ifdef MVT_USE_COLOR4\n            vColor = aColor;\n        #else \n            vColor = vec4(color, 1.0);\n        #endif\n    #endif\n\n    #include <begin_vertex>\n    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n\n    #if defined(MVT_USE_VERTEX_ZINDEX_LEGACY) || defined(MVT_USE_VERTEX_ZINDEX)\n        vLayerIndex = layerIndex;\n    #endif\n\n    #ifdef USE_AO\n        v_h = heightAndConcave.x;\n        float encodeConcave = heightAndConcave.y;\n        v_ground = mod(encodeConcave, 2.0);\n        float concave = mod(floor(encodeConcave * 0.5), 2.0);\n        float start = mod(floor(encodeConcave * 0.25), 2.0);\n        concave = pow(concave, 2.2);\n        v_concave = mix(concave, -concave, start);\n    #endif\n\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <normal_vertex>\n\n    #include <fog_vertex>\n    #include <logdepthbuf_vertex>\n\n}\n\n",fragmentShader$i="#define GLSLIFY 1\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec3 color;\n#endif\nuniform float opacity;\n\n#ifdef USE_AO\n    uniform float concaveIntensity;\n    uniform float heightIntensity;\n\n    varying float v_concave;\n    varying float v_ground;\n    varying float v_h;\n#endif\n\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\n#include <mvt_depth_range_pars_fragment>\n\nvoid main() {\n\n    vec4 diffuseColor = vec4(0.0);\n    #ifdef MVT_USE_VERTEX_COLOR\n        diffuseColor = vColor;\n    #else\n        diffuseColor = vec4(color, 1.0);\n    #endif\n\n    diffuseColor.a *= opacity;\n    if (diffuseColor.a <= 0.) {\n        discard;\n    }\n\n    #if ( NUM_DIR_LIGHTS > 0 )\n        // 根据方向光的方向与法向，来计算颜色衰减程度，值范围为-1~1，给重映射到0.8~1的范围\n        float normalLightIntensity = dot(vNormal, directionalLights[0].direction);\n        gl_FragColor = vec4(diffuseColor.rgb * (normalLightIntensity / 10.0 + 0.9), diffuseColor.a);\n    #else \n        gl_FragColor = diffuseColor;\n    #endif\n\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #ifdef USE_AO\n        float ao_shade = 1.0;\n        float concave = v_concave * v_concave;\n        float intensity = concaveIntensity;\n        float x_shade = mix(1.0, mix(0.6, 0.75, min(0.01, 1.0)), intensity) + 0.1 * intensity;\n        ao_shade *= mix(1.0, x_shade * x_shade * x_shade, concave);\n\n        intensity = heightIntensity;\n        float h_floors = v_h / 3.0;\n        float y_shade = 1.0 - 0.9 * intensity * min(v_ground, 1.0);\n        ao_shade *= (1.0 - 0.08 * intensity) * (y_shade + (1.0 - y_shade) * (1.0 - pow(1.0 - min(h_floors / 16.0, 1.0), 16.0))) + 0.08 * intensity * min(h_floors / 160.0, 1.0);\n\n        gl_FragColor.rgb *= ao_shade;\n    #endif\n\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n    #include <mvt_depth_range_fragment>\n}\n\n",uniforms$l=three.UniformsUtils.merge([three.UniformsLib.fog,three.UniformsLib.lights,{opacity:{value:1},uColor:{value:[0,1,1]},vertexColors:{value:!1},vertexZIndexLegacy:{value:!1},vertexZIndex:{value:!1},isEmissive:{value:!1},depthRange:{value:new three.Vector2(0,1)},concaveIntensity:{value:.2},heightIntensity:{value:.4}}]);class BaiduVectorMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="BaiduVectorMaterial",this.type="BaiduVectorMaterial",this.isBaiduVectorMaterial=!0,this.lights=!0,this.fog=!0,this.fragmentShader=fragmentShader$i,this.vertexShader=vertexShader$k,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$l)),defineMaterialNormalProperties(this,["opacity","isEmissive","concaveIntensity","heightIntensity","depthRange"]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexZIndexLegacy","MVT_USE_VERTEX_ZINDEX_LEGACY"],["vertexZIndex","MVT_USE_VERTEX_ZINDEX"],["enableDepthRange","MVT_USE_DEPTH_RANGE"],["isColor4","MVT_USE_COLOR4"],["useAO","USE_AO"]]),this.setValues(e)}}const vertexShader$j="#define GLSLIFY 1\n#include <common>\n\nattribute vec3 a_diff;\nattribute vec3 a_normal;\nattribute vec2 a_uv;\n\nvarying vec2 vUv;\n\n// uniform float u_scale;\n// uniform bool u_flat;\n\n#ifdef MVT_USE_VERTEX_ZINDEX_LEGACY\nattribute float layerIndex;\n#endif\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\nvoid main() {\n    #include <mvt_selective_vertex>\n    \n    vec3 currentPosition = position;\n\n    vec4 worldPosition = modelMatrix * vec4(currentPosition, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz) * 1.0;\n\n    float scale = 1.4;\n    currentPosition.xyz = currentPosition.xyz + (a_diff * scale * pixelSize) + a_normal * scale * pixelSize;\n\n    worldPosition = modelMatrix * vec4(currentPosition, 1.0);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(currentPosition, 1.0);\n\n    vUv = a_uv;\n\n    #include <logdepthbuf_vertex>\n    // gl_PointSize = 10000000000.0; // 设置点的大小\n}",fragmentShader$h="#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D u_image;\nuniform int u_draw_part;\n\nvarying vec2 vUv;\n// varying float v_z;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n    // if (u_draw_part == 1) {\n    //     if (v_z > 0.0) {\n    //         discard;\n    //     }\n    // } else if (u_draw_part == 2) {\n    //     if (v_z == 0.0) {\n    //        discard;\n    //     }\n    // }\n\n    gl_FragColor = texture2D(u_image, vUv);\n    gl_FragColor.rgb *= (1.0 - max(0.6, 1.0 - gl_FragColor.a));\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}\n",texture=(new three.TextureLoader).load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ5JREFUeNrsllEKgCAMhp14rsqT1X08Q6VdbDmYLxGUoO5lg72J+9i/3wmIaCTDGuFQAAVQANfyshCCSkBx5pwlAZackUEmSQkIJH2BjJiBAnK8gQBtwzy9I1cidWTLeUm5wHNHduqIlXagEyhMDlmLBNDyR8QvIf4pPNIFkZ3gn8V7SxB52tOwZVRTuCeArzkM+i1XAAVQAGmAW4ABAOOjKXrLR4xWAAAAAElFTkSuQmCC");texture.anisotropy=8;let uniforms$k=three.UniformsUtils.merge([{u_draw_part:{value:0},u_image:{value:texture},color:{value:new three.Color(16711680)},vertexZIndexLegacy:{value:!1},vertexZIndex:{value:!1},u_scale:{value:1},isGlobe:{value:!1}}]);class ArrowMaterial extends CommonShaderMaterial{constructor(e){super(),__publicField(this,"name","ArrowMaterial"),__publicField(this,"isArrowMaterial",!0),this.vertexShader=vertexShader$j,this.fragmentShader=fragmentShader$h,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$k)),defineMaterialColorProperties(["color"]),defineMaterialNormalProperties(this,["u_draw_part","u_image"]),defineMaterialBoolDefineProperties(this,[["vertexZIndexLegacy","MVT_USE_VERTEX_ZINDEX_LEGACY"],["vertexZIndex","MVT_USE_VERTEX_ZINDEX"],["isGlobe","IS_GLOBE"]]),this.setValues(e)}set color(e){this.uniforms.color.value=e}}const halfZeroLevelSize=256*Math.pow(2,18)/2,halfEarthSize=20037724.16,exceedRatio=halfZeroLevelSize/halfEarthSize;class BaiduImageryGrid extends Grid{constructor(e,t,i){super(e,t,i),__publicField(this,"_maxLevel",19),__publicField(this,"_shouldCheckTileBoundingRange",!0),this._coordLevelTileCounts=[1];let n=1;for(let r=1;r<=19;++r)this._coordLevelTileCounts[r]=n,n*=2}getRootTiles(){const e=new MapTile(this,0,0,0);return e.projectedBoundingBox=new three.Box3(new three.Vector3(-halfZeroLevelSize,-halfZeroLevelSize,-.1),new three.Vector3(halfZeroLevelSize,halfZeroLevelSize,.1)),e.geoBoundingBox=new three.Box3(new three.Vector3(-180*exceedRatio,-90*exceedRatio,-.1),new three.Vector3(180*exceedRatio,90*exceedRatio,.1)),[e]}getRootBoundingBox(){return this._rootBoundingBox}getTileReverseY(e){return Math.pow(2,e.z-1)-e.y-1}getTileSizeAtLevel(e){return 256*Math.pow(2,18-e)}getTileCoordX(e,t,i){return(e+halfZeroLevelSize)/t}getTileCoordY(e,t,i){return(e+halfZeroLevelSize)/t}_quadCoordToTileCoord(e,t){return e>=t?e-t:"M"+(t-e)}getRasterTileCoord(e,t,i){const n=this._coordLevelTileCounts[e];return[e,this._quadCoordToTileCoord(t,n),this._quadCoordToTileCoord(i,n)]}get zeroLevelPixelSize(){return this._zeroLevelPixelSize||(this._zeroLevelPixelSize=262216.13723289885),this._zeroLevelPixelSize}}class BaiduVectorOnlineGrid extends BaiduImageryGrid{constructor(){super(...arguments),__publicField(this,"name",MAP_GRID_NAME_BD_VECTOR_ONLINE),__publicField(this,"_maxLevel",21),__publicField(this,"_levels",[0,1,2,3,5,7,9,10,12,15,17,19]),__publicField(this,"_tileCountMap",{3:2,5:4,7:4,9:4,10:2,12:8,15:2,17:4}),__publicField(this,"_zLevelToQuadTreeLevelMap",{0:0,1:1,2:2,3:3,5:4,7:6,9:8,10:10,12:11,15:14,17:15,19:17}),__publicField(this,"_zoomBaseMap",{0:{start:0,base:0},1:{start:0,base:1},2:{start:2,base:2},3:{start:3,base:3},4:{start:4,base:5},5:{start:4,base:5},6:{start:6,base:7},7:{start:6,base:7},8:{start:8,base:9},9:{start:8,base:9},10:{start:10,base:10},11:{start:11,base:12},12:{start:11,base:12},13:{start:11,base:12},14:{start:14,base:15},15:{start:14,base:15},16:{start:16,base:17},17:{start:16,base:17},18:{start:18,base:19},19:{start:18,base:19},20:{start:18,base:19},21:{start:18,base:19}}),__publicField(this,"_defaultCoordLevelTileCounts",{0:1,1:1}),__publicField(this,"supportLevelReuse",!0)}_quadCoordToTileCoord(e,t,i){let n=e-t;return Math.floor(n/1)}getRasterTileCoord(e,t,i){let n=this._coordLevelTileCounts[e];return[e,this._quadCoordToTileCoord(t,n,e),this._quadCoordToTileCoord(i,n,e)]}getNextLevelTileCount(e){return this._tileCountMap[e]||2}getQuadTreeLevelGap(e,t){const i=this._zoomBaseMap[e].base,n=this._zoomBaseMap[t].base,r=this._zLevelToQuadTreeLevelMap[i];return this._zLevelToQuadTreeLevelMap[n]-r}getTileLoaderConfig(e){const t=this._zoomBaseMap[e.z];return{baseZ:t.base,startZ:t.start}}getResuedTileConfig(e,t,i){const n=this._zoomBaseMap[e].base,r=this._zLevelToQuadTreeLevelMap[n];if(!r>=e)return console.warn(`${e}-${t}-${i} is a node of quadtree`),null;const s=e-r,a=t>>s,o=i>>s,l=t-(a<<s),c=i-(o<<s),h=Math.pow(2,s);return[e,a,o,l/h,c/h,1/h,1/h]}update(){super.update(),this._updateCoordLevelTileCounts()}_updateCoordLevelTileCounts(){let e=1;this._coordLevelTileCounts=Object.assign({},this._defaultCoordLevelTileCounts);for(let t=1;t<this._levels.length;t++){const i=this._levels[t],n=this._levels[t-1];t<2||(void 0!==this._tileCountMap[n]?e*=this._tileCountMap[n]:e*=2,this._coordLevelTileCounts[i]=e)}}}const zoomBaseMap={0:{start:0,end:0,base:0},1:{start:1,end:1,base:1},2:{start:2,end:2,base:2},3:{start:3,end:4,base:3},4:{start:3,end:4,base:3},5:{start:5,end:6,base:5},6:{start:5,end:6,base:5},7:{start:7,end:8,base:7},8:{start:7,end:8,base:7},9:{start:9,end:9,base:9},10:{start:10,end:12,base:10},11:{start:10,end:12,base:10},12:{start:10,end:12,base:10},13:{start:13,end:14,base:13},14:{start:13,end:14,base:13},15:{start:15,end:16,base:14},16:{start:15,end:16,base:14},17:{start:17,end:23,base:16},18:{start:17,end:23,base:16},19:{start:17,end:23,base:16},20:{start:17,end:23,base:16},21:{start:17,end:23,base:16},22:{start:17,end:23,base:16},23:{start:17,end:23,base:16}},EARTH_RADIUS=20037508.3427892;Object.freeze(zoomBaseMap);class BaiduVectorOfflineGrid extends Grid{constructor(){super(...arguments),__publicField(this,"name",MAP_GRID_NAME_BD_VECTOR_OFFLINE),__publicField(this,"_maxLevel",21),__publicField(this,"supportLevelReuse",!0),__publicField(this,"_rootBoundingBox",new three.Box3(new three.Vector3(-20037508.3427892,-20037508.3427892,-.1),new three.Vector3(20037508.3427892,20037508.3427892,.1)))}getRootTiles(){const e=new MapTile(this,0,0,0);return e.projectedBoundingBox=this._rootBoundingBox,e.geoBoundingBox=new three.Box3(new three.Vector3(-180,-90,-.1),new three.Vector3(180,90,.1)),[e]}getRootBoundingBox(){return this._rootBoundingBox}getTileSizeAtLevel(e){return EARTH_RADIUS/Math.pow(2,e-1)}getTileCoordX(e,t,i){return i&&(e<-EARTH_RADIUS?e=-EARTH_RADIUS:e>EARTH_RADIUS&&(e=EARTH_RADIUS)),(e+EARTH_RADIUS)/t}getTileCoordY(e,t,i){return this.getTileCoordX(e,t,i)}getQuadTreeLevelGap(e,t){const i=zoomBaseMap[e].base;return zoomBaseMap[t].base-i}getResuedTileConfig(e,t,i){const n=e-zoomBaseMap[e].base,r=t>>n,s=i>>n,a=t-(r<<n),o=i-(s<<n),l=Math.pow(2,n);return[e,r,s,a/l,o/l,1/l,1/l]}getTileLoaderConfig(e){const t=zoomBaseMap[e.z];return{baseZ:t.base,startZ:t.start}}}const loadScript=e=>new Promise(((t,i)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onload=t,n.onerror=()=>i(new Error(`failed to load script: ${e}`)),document.head.appendChild(n)}));class PromisedSingleton{constructor(){__publicField(this,"_retryTimes",3),__publicField(this,"_queued",{}),__publicField(this,"_cached",{})}async generate(e){return{}}async get(e){if(this._cached[e])return this._cached[e];let t=!1;this._queued[e]||(this._queued[e]=[],t=!0);const i=new Promise(((t,i)=>{this._queued[e].push([t,i])})),n=this._queued[e];if(t){for(let t=0;t<this._retryTimes;t++)try{const t=await this.generate(e);this._cached[e]=t;for(const e of n)e[0](t);break}catch(r){console.warn(r)}for(const e of n)e[1]()}return i}get keys(){return Object.keys(this._cached)}delete(e){delete this._cached[e],delete this._queued[e]}clear(){this._cached={},this._queued={}}}class BaiduMapConfig{static get ak(){return this._ak}static set ak(e){e&&e!==this._ak&&(this._ak=e,fetch(`https://api.map.baidu.com/api?type=three&v=1.4.1&ak=${e}`,{method:"GET",mode:"no-cors"}))}}__publicField(BaiduMapConfig,"_ak",null);class CesiumConfig{}__publicField(CesiumConfig,"accessToken",null);class MapboxConfig{}__publicField(MapboxConfig,"accessToken",null);class TiandituConfig{}__publicField(TiandituConfig,"tk",null);var md5$1={exports:{}};const __viteBrowserExternal=new Proxy({},{get(e,t){throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${t}" in client code.`)}}),__viteBrowserExternal$1=Object.freeze(Object.defineProperty({__proto__:null,default:__viteBrowserExternal},Symbol.toStringTag,{value:"Module"})),require$$1=getAugmentedNamespace(__viteBrowserExternal$1);
/**
   * [js-md5]{@link https://github.com/emn178/js-md5}
   *
   * @namespace md5
   * @version 0.8.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2023
   * @license MIT
   */
!function(e){!function(){var t="input is invalid type",i="object"==typeof window,n=i?window:{};n.JS_MD5_NO_WINDOW&&(i=!1);var r=!i&&"object"==typeof self,s=!n.JS_MD5_NO_NODE_JS&&"object"==typeof process&&process.versions&&process.versions.node;s?n=commonjsGlobal:r&&(n=self);var a,o=!n.JS_MD5_NO_COMMON_JS&&e.exports,l=!n.JS_MD5_NO_ARRAY_BUFFER&&"undefined"!=typeof ArrayBuffer,c="0123456789abcdef".split(""),h=[128,32768,8388608,-2147483648],u=[0,8,16,24],d=["hex","array","digest","buffer","arrayBuffer","base64"],p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),m=[];if(l){var f=new ArrayBuffer(68);a=new Uint8Array(f),m=new Uint32Array(f)}var g=Array.isArray;!n.JS_MD5_NO_NODE_JS&&g||(g=function(e){return"[object Array]"===Object.prototype.toString.call(e)});var _=ArrayBuffer.isView;!l||!n.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW&&_||(_=function(e){return"object"==typeof e&&e.buffer&&e.buffer.constructor===ArrayBuffer});var A=function(e){var i=typeof e;if("string"===i)return[e,!0];if("object"!==i||null===e)throw new Error(t);if(l&&e.constructor===ArrayBuffer)return[new Uint8Array(e),!1];if(!g(e)&&!_(e))throw new Error(t);return[e,!1]},v=function(e){return function(t){return new b(!0).update(t)[e]()}},y=function(e){var i,r=require$$1,s=require$$1.Buffer;i=s.from&&!n.JS_MD5_NO_BUFFER_FROM?s.from:function(e){return new s(e)};return function(n){if("string"==typeof n)return r.createHash("md5").update(n,"utf8").digest("hex");if(null==n)throw new Error(t);return n.constructor===ArrayBuffer&&(n=new Uint8Array(n)),g(n)||_(n)||n.constructor===s?r.createHash("md5").update(i(n)).digest("hex"):e(n)}},x=function(e){return function(t,i){return new S(t,!0).update(i)[e]()}};function b(e){if(e)m[0]=m[16]=m[1]=m[2]=m[3]=m[4]=m[5]=m[6]=m[7]=m[8]=m[9]=m[10]=m[11]=m[12]=m[13]=m[14]=m[15]=0,this.blocks=m,this.buffer8=a;else if(l){var t=new ArrayBuffer(68);this.buffer8=new Uint8Array(t),this.blocks=new Uint32Array(t)}else this.blocks=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];this.h0=this.h1=this.h2=this.h3=this.start=this.bytes=this.hBytes=0,this.finalized=this.hashed=!1,this.first=!0}function S(e,t){var i,n=A(e);if(e=n[0],n[1]){var r,s=[],a=e.length,o=0;for(i=0;i<a;++i)(r=e.charCodeAt(i))<128?s[o++]=r:r<2048?(s[o++]=192|r>>>6,s[o++]=128|63&r):r<55296||r>=57344?(s[o++]=224|r>>>12,s[o++]=128|r>>>6&63,s[o++]=128|63&r):(r=65536+((1023&r)<<10|1023&e.charCodeAt(++i)),s[o++]=240|r>>>18,s[o++]=128|r>>>12&63,s[o++]=128|r>>>6&63,s[o++]=128|63&r);e=s}e.length>64&&(e=new b(!0).update(e).array());var l=[],c=[];for(i=0;i<64;++i){var h=e[i]||0;l[i]=92^h,c[i]=54^h}b.call(this,t),this.update(c),this.oKeyPad=l,this.inner=!0,this.sharedMemory=t}b.prototype.update=function(e){if(this.finalized)throw new Error("finalize already called");var t=A(e);e=t[0];for(var i,n,r=t[1],s=0,a=e.length,o=this.blocks,c=this.buffer8;s<a;){if(this.hashed&&(this.hashed=!1,o[0]=o[16],o[16]=o[1]=o[2]=o[3]=o[4]=o[5]=o[6]=o[7]=o[8]=o[9]=o[10]=o[11]=o[12]=o[13]=o[14]=o[15]=0),r)if(l)for(n=this.start;s<a&&n<64;++s)(i=e.charCodeAt(s))<128?c[n++]=i:i<2048?(c[n++]=192|i>>>6,c[n++]=128|63&i):i<55296||i>=57344?(c[n++]=224|i>>>12,c[n++]=128|i>>>6&63,c[n++]=128|63&i):(i=65536+((1023&i)<<10|1023&e.charCodeAt(++s)),c[n++]=240|i>>>18,c[n++]=128|i>>>12&63,c[n++]=128|i>>>6&63,c[n++]=128|63&i);else for(n=this.start;s<a&&n<64;++s)(i=e.charCodeAt(s))<128?o[n>>>2]|=i<<u[3&n++]:i<2048?(o[n>>>2]|=(192|i>>>6)<<u[3&n++],o[n>>>2]|=(128|63&i)<<u[3&n++]):i<55296||i>=57344?(o[n>>>2]|=(224|i>>>12)<<u[3&n++],o[n>>>2]|=(128|i>>>6&63)<<u[3&n++],o[n>>>2]|=(128|63&i)<<u[3&n++]):(i=65536+((1023&i)<<10|1023&e.charCodeAt(++s)),o[n>>>2]|=(240|i>>>18)<<u[3&n++],o[n>>>2]|=(128|i>>>12&63)<<u[3&n++],o[n>>>2]|=(128|i>>>6&63)<<u[3&n++],o[n>>>2]|=(128|63&i)<<u[3&n++]);else if(l)for(n=this.start;s<a&&n<64;++s)c[n++]=e[s];else for(n=this.start;s<a&&n<64;++s)o[n>>>2]|=e[s]<<u[3&n++];this.lastByteIndex=n,this.bytes+=n-this.start,n>=64?(this.start=n-64,this.hash(),this.hashed=!0):this.start=n}return this.bytes>4294967295&&(this.hBytes+=this.bytes/4294967296|0,this.bytes=this.bytes%4294967296),this},b.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var e=this.blocks,t=this.lastByteIndex;e[t>>>2]|=h[3&t],t>=56&&(this.hashed||this.hash(),e[0]=e[16],e[16]=e[1]=e[2]=e[3]=e[4]=e[5]=e[6]=e[7]=e[8]=e[9]=e[10]=e[11]=e[12]=e[13]=e[14]=e[15]=0),e[14]=this.bytes<<3,e[15]=this.hBytes<<3|this.bytes>>>29,this.hash()}},b.prototype.hash=function(){var e,t,i,n,r,s,a=this.blocks;this.first?t=((t=((e=((e=a[0]-680876937)<<7|e>>>25)-271733879|0)^(i=((i=(-271733879^(n=((n=(-1732584194^2004318071&e)+a[1]-117830708)<<12|n>>>20)+e|0)&(-271733879^e))+a[2]-1126478375)<<17|i>>>15)+n|0)&(n^e))+a[3]-1316259209)<<22|t>>>10)+i|0:(e=this.h0,t=this.h1,i=this.h2,t=((t+=((e=((e+=((n=this.h3)^t&(i^n))+a[0]-680876936)<<7|e>>>25)+t|0)^(i=((i+=(t^(n=((n+=(i^e&(t^i))+a[1]-389564586)<<12|n>>>20)+e|0)&(e^t))+a[2]+606105819)<<17|i>>>15)+n|0)&(n^e))+a[3]-1044525330)<<22|t>>>10)+i|0),t=((t+=((e=((e+=(n^t&(i^n))+a[4]-176418897)<<7|e>>>25)+t|0)^(i=((i+=(t^(n=((n+=(i^e&(t^i))+a[5]+1200080426)<<12|n>>>20)+e|0)&(e^t))+a[6]-1473231341)<<17|i>>>15)+n|0)&(n^e))+a[7]-45705983)<<22|t>>>10)+i|0,t=((t+=((e=((e+=(n^t&(i^n))+a[8]+1770035416)<<7|e>>>25)+t|0)^(i=((i+=(t^(n=((n+=(i^e&(t^i))+a[9]-1958414417)<<12|n>>>20)+e|0)&(e^t))+a[10]-42063)<<17|i>>>15)+n|0)&(n^e))+a[11]-1990404162)<<22|t>>>10)+i|0,t=((t+=((e=((e+=(n^t&(i^n))+a[12]+1804603682)<<7|e>>>25)+t|0)^(i=((i+=(t^(n=((n+=(i^e&(t^i))+a[13]-40341101)<<12|n>>>20)+e|0)&(e^t))+a[14]-1502002290)<<17|i>>>15)+n|0)&(n^e))+a[15]+1236535329)<<22|t>>>10)+i|0,t=((t+=((n=((n+=(t^i&((e=((e+=(i^n&(t^i))+a[1]-165796510)<<5|e>>>27)+t|0)^t))+a[6]-1069501632)<<9|n>>>23)+e|0)^e&((i=((i+=(e^t&(n^e))+a[11]+643717713)<<14|i>>>18)+n|0)^n))+a[0]-373897302)<<20|t>>>12)+i|0,t=((t+=((n=((n+=(t^i&((e=((e+=(i^n&(t^i))+a[5]-701558691)<<5|e>>>27)+t|0)^t))+a[10]+38016083)<<9|n>>>23)+e|0)^e&((i=((i+=(e^t&(n^e))+a[15]-660478335)<<14|i>>>18)+n|0)^n))+a[4]-405537848)<<20|t>>>12)+i|0,t=((t+=((n=((n+=(t^i&((e=((e+=(i^n&(t^i))+a[9]+568446438)<<5|e>>>27)+t|0)^t))+a[14]-1019803690)<<9|n>>>23)+e|0)^e&((i=((i+=(e^t&(n^e))+a[3]-187363961)<<14|i>>>18)+n|0)^n))+a[8]+1163531501)<<20|t>>>12)+i|0,t=((t+=((n=((n+=(t^i&((e=((e+=(i^n&(t^i))+a[13]-1444681467)<<5|e>>>27)+t|0)^t))+a[2]-51403784)<<9|n>>>23)+e|0)^e&((i=((i+=(e^t&(n^e))+a[7]+1735328473)<<14|i>>>18)+n|0)^n))+a[12]-1926607734)<<20|t>>>12)+i|0,t=((t+=((s=(n=((n+=((r=t^i)^(e=((e+=(r^n)+a[5]-378558)<<4|e>>>28)+t|0))+a[8]-2022574463)<<11|n>>>21)+e|0)^e)^(i=((i+=(s^t)+a[11]+1839030562)<<16|i>>>16)+n|0))+a[14]-35309556)<<23|t>>>9)+i|0,t=((t+=((s=(n=((n+=((r=t^i)^(e=((e+=(r^n)+a[1]-1530992060)<<4|e>>>28)+t|0))+a[4]+1272893353)<<11|n>>>21)+e|0)^e)^(i=((i+=(s^t)+a[7]-155497632)<<16|i>>>16)+n|0))+a[10]-1094730640)<<23|t>>>9)+i|0,t=((t+=((s=(n=((n+=((r=t^i)^(e=((e+=(r^n)+a[13]+681279174)<<4|e>>>28)+t|0))+a[0]-358537222)<<11|n>>>21)+e|0)^e)^(i=((i+=(s^t)+a[3]-722521979)<<16|i>>>16)+n|0))+a[6]+76029189)<<23|t>>>9)+i|0,t=((t+=((s=(n=((n+=((r=t^i)^(e=((e+=(r^n)+a[9]-640364487)<<4|e>>>28)+t|0))+a[12]-421815835)<<11|n>>>21)+e|0)^e)^(i=((i+=(s^t)+a[15]+530742520)<<16|i>>>16)+n|0))+a[2]-995338651)<<23|t>>>9)+i|0,t=((t+=((n=((n+=(t^((e=((e+=(i^(t|~n))+a[0]-198630844)<<6|e>>>26)+t|0)|~i))+a[7]+1126891415)<<10|n>>>22)+e|0)^((i=((i+=(e^(n|~t))+a[14]-1416354905)<<15|i>>>17)+n|0)|~e))+a[5]-57434055)<<21|t>>>11)+i|0,t=((t+=((n=((n+=(t^((e=((e+=(i^(t|~n))+a[12]+1700485571)<<6|e>>>26)+t|0)|~i))+a[3]-1894986606)<<10|n>>>22)+e|0)^((i=((i+=(e^(n|~t))+a[10]-1051523)<<15|i>>>17)+n|0)|~e))+a[1]-2054922799)<<21|t>>>11)+i|0,t=((t+=((n=((n+=(t^((e=((e+=(i^(t|~n))+a[8]+1873313359)<<6|e>>>26)+t|0)|~i))+a[15]-30611744)<<10|n>>>22)+e|0)^((i=((i+=(e^(n|~t))+a[6]-1560198380)<<15|i>>>17)+n|0)|~e))+a[13]+1309151649)<<21|t>>>11)+i|0,t=((t+=((n=((n+=(t^((e=((e+=(i^(t|~n))+a[4]-145523070)<<6|e>>>26)+t|0)|~i))+a[11]-1120210379)<<10|n>>>22)+e|0)^((i=((i+=(e^(n|~t))+a[2]+718787259)<<15|i>>>17)+n|0)|~e))+a[9]-343485551)<<21|t>>>11)+i|0,this.first?(this.h0=e+1732584193|0,this.h1=t-271733879|0,this.h2=i-1732584194|0,this.h3=n+271733878|0,this.first=!1):(this.h0=this.h0+e|0,this.h1=this.h1+t|0,this.h2=this.h2+i|0,this.h3=this.h3+n|0)},b.prototype.hex=function(){this.finalize();var e=this.h0,t=this.h1,i=this.h2,n=this.h3;return c[e>>>4&15]+c[15&e]+c[e>>>12&15]+c[e>>>8&15]+c[e>>>20&15]+c[e>>>16&15]+c[e>>>28&15]+c[e>>>24&15]+c[t>>>4&15]+c[15&t]+c[t>>>12&15]+c[t>>>8&15]+c[t>>>20&15]+c[t>>>16&15]+c[t>>>28&15]+c[t>>>24&15]+c[i>>>4&15]+c[15&i]+c[i>>>12&15]+c[i>>>8&15]+c[i>>>20&15]+c[i>>>16&15]+c[i>>>28&15]+c[i>>>24&15]+c[n>>>4&15]+c[15&n]+c[n>>>12&15]+c[n>>>8&15]+c[n>>>20&15]+c[n>>>16&15]+c[n>>>28&15]+c[n>>>24&15]},b.prototype.toString=b.prototype.hex,b.prototype.digest=function(){this.finalize();var e=this.h0,t=this.h1,i=this.h2,n=this.h3;return[255&e,e>>>8&255,e>>>16&255,e>>>24&255,255&t,t>>>8&255,t>>>16&255,t>>>24&255,255&i,i>>>8&255,i>>>16&255,i>>>24&255,255&n,n>>>8&255,n>>>16&255,n>>>24&255]},b.prototype.array=b.prototype.digest,b.prototype.arrayBuffer=function(){this.finalize();var e=new ArrayBuffer(16),t=new Uint32Array(e);return t[0]=this.h0,t[1]=this.h1,t[2]=this.h2,t[3]=this.h3,e},b.prototype.buffer=b.prototype.arrayBuffer,b.prototype.base64=function(){for(var e,t,i,n="",r=this.array(),s=0;s<15;)e=r[s++],t=r[s++],i=r[s++],n+=p[e>>>2]+p[63&(e<<4|t>>>4)]+p[63&(t<<2|i>>>6)]+p[63&i];return e=r[s],n+=p[e>>>2]+p[e<<4&63]+"=="},S.prototype=new b,S.prototype.finalize=function(){if(b.prototype.finalize.call(this),this.inner){this.inner=!1;var e=this.array();b.call(this,this.sharedMemory),this.update(this.oKeyPad),this.update(e),b.prototype.finalize.call(this)}};var C=function(){var e=v("hex");s&&(e=y(e)),e.create=function(){return new b},e.update=function(t){return e.create().update(t)};for(var t=0;t<d.length;++t){var i=d[t];e[i]=v(i)}return e}();C.md5=C,C.md5.hmac=function(){var e=x("hex");e.create=function(e){return new S(e)},e.update=function(t,i){return e.create(t).update(i)};for(var t=0;t<d.length;++t){var i=d[t];e[i]=x(i)}return e}(),o?e.exports=C:n.md5=C}()}(md5$1);const md5=md5$1.exports;var b0f=function(e,t){var i="xea",n="aeai",r=function(e,t){return e(t)},s="dae",a="mda",o=function(e,t){return e+t},l=function(e,t){return e(t)},c=function(e,t,i){return e(t,i)},h=function(e,t){return e(t)},u=function(e,t){return e(t)},d=function(e,t){return e+t},p=function(e,t){return e(t)},m=function(e,t){return e<t};function f(e,t){for(var o=i;o!==n;)switch(o){case"ail":return u;case"mda":for(var l=0;l<h;l++){var c=r(t,e[l]);u.push(c)}o="ail";break;case"xea":var h=e.length;o=s;break;case s:var u=[];o=a}}var g,_,A=decodeURIComponent;E="de",_=o("fro","m"),g=d("Co",E);var v=function(e){return o(e,"").constructor[_+"Char"+g](e)},y=function(e){var t=function(e,t){return l(e,t)};return c(f,e,(function(e){return t(v,e)}))},x=y.call(v,[39,34,37,96,60,120,97,65,98,66,99,67,100,68,101,69,102,70,103,110,109,111,112,48,49,50,51,52,53,54,55,56,57]),b=f([28782,27702,26416,25167,24183],(function(e){return h(A,e)})),S=y.call(b,[22354,22749,24415,23346,22257,22688,24306,25174,23595,25547,22984,25690,22212,27547,21594,27210,23090,29193,22394,29368,29532,29459,29530,24146,24500,26352,27441,28788,29370,27673,26925,25249,24430]),C={};b=p(y,b);for(var T=new RegExp(b.join("|")),E=0;m(E,x.length);E++)C[S[E]]=x[E];return f((t=c(f,t.split(""),(function(e){return C[e]||e})).join("")).split(T),(function(e){return u(A,e)}))}(globalThis,"l呚犸坺th扏呚獜廲獜呚氶i廲呚呚墠幷囄墠姈li氶呚囄墠姈呚氶囄囄呚呚姈幷su尫str扏姈墠囄廲獜扏i犸囄呚墠O娲氶h墠呚呚獜幷墠l呚ll幷h廲廲氶獜呚獜朰H幒扖彮P抡P椭Y氙扖揋QO幒灮姈il氶l墠姈灮呚廲廲扏爉犺L曰O氙R氙扖殛抡彮彮幒O幷囄l呚囄i朰姈呚呚呚灮呚墠l廲獜朰彟曰氙si坺犸彟欱殛朰su尫stri犸坺灮廲墠呚l囄"),i,j;i=b0f,j=491,function(e){for(;--e;)i.push(i.shift())}(++j);var b0h=function(e,t){return b0f[e-=0]};function appendSign(e){for(var t={dledi:function(e,t){return e!==t},exlam:b0h("0x0"),axeld:function(e,t){return e-t},emame:b0h("0x1"),iaeex:b0h("0x2"),dxcli:b0h("0x3"),edxce:b0h("0x4"),dhcmh:function(e,t){return e(t)},ddeec:function(e,t){return e(t)},cxdam:function(e,t){return e+t},hxeem:b0h("0x5"),xlell:b0h("0x6")},i=b0h("0x5");t[b0h("0x7")](i,b0h("0x8"));)switch(i){case t[b0h("0x9")]:return b0h("0xa")+r[b0h("0xb")](t[b0h("0xc")](r[b0h("0xd")],12));case t[b0h("0xe")]:var n=t[b0h("0xf")];i=t[b0h("0x10")];break;case t[b0h("0x11")]:var r=t.dhcmh(md5,t[b0h("0x12")](md5,s+a)+n);i=t[b0h("0x9")];break;case t[b0h("0x10")]:var s=e[b0h("0x13")](t[b0h("0x14")](e[b0h("0x15")]("?"),1));i=b0h("0x4");break;case t[b0h("0x16")]:var a=t[b0h("0x17")];i=t.emame}}let urlProtocol$1="http:"===window.location.protocol?"http:":"https:";const apiHost$1=urlProtocol$1+"//api.map.baidu.com",mapStyleHelper={ak:"",getStyleJson:async function(e){if(e.styleJson)return e.styleJson;if(e.styleId){let t=e.styleId,i=`${apiHost$1}/?qt=custom_map&v=3.0&style_id=${t}&type=publish&ak=${this.ak}`,n=await jsonp(i),r=[];return n.result&&0===n.result.error&&n.content&&0===n.content.status?(r=this.parseJson(n.content.data.json),r):null}return null},parseJson:function(e){if(null===e||""===e)return[];let t={t:"featureType",e:"elementType",v:"visibility",c:"color",o:"opacity",l:"lightness",s:"saturation",w:"weight",z:"level",h:"hue",f:"fontsize",zri:"curZoomRegionId",zr:"curZoomRegion",i:"image"},i={all:"all",g:"geometry","g.f":"geometry.fill","g.s":"geometry.stroke",l:"labels","l.t.f":"labels.text.fill","l.t.s":"labels.text.stroke","l.t":"labels.text","l.i":"labels.icon","g.tf":"geometry.topfill","g.sf":"geometry.sidefill",t:"texture"},n=e.split(",").map((function(e){let n=e.split("|").map((function(e){let n=t[e.split(":")[0]],r=i[e.split(":")[1]]?i[e.split(":")[1]]:e.slice(e.indexOf(":")+1,e.length);switch(r){case"poi":r="poilabel";break;case"districtlabel":r="districtlabel"}let s={};return s[n]=r,s})),r=n[0],s=1;n[1].elementType&&(s=2,Object.assign(r,n[1]));let a={};for(let t=s;t<n.length;t++)Object.assign(a,n[t]);return Object.assign(r,{stylers:a})}));return n},getStyleUrl:function(e,t){let i=apiHost$1+"/custom/v2/mapstyle?version=4&ak="+this.ak+"&qt=custom_v2&is_all=true&is_new=1&",n=this.styleJson2styleStringV2(e,t);return i+="styles="+encodeURIComponent(n),i+="&timeStamp="+(new Date).getTime(),i+=appendSign(i),i},styleJson2styleStringV2:function(e,t){let i={featureType:"t",elementType:"e",visibility:"v",color:"c",opacity:"o",lightness:"l",saturation:"s",weight:"w",level:"z",hue:"h",fontsize:"f",image:"i"},n={all:"all",geometry:"g","geometry.fill":"g.f","geometry.stroke":"g.s",labels:"l","labels.text.fill":"l.t.f","labels.text.stroke":"l.t.s","labels.text":"l.t","labels.icon":"l.i","geometry.topfill":"g.tf","geometry.sidefill":"g.sf",texture:"t"},r=[];for(let a=0;a<=23;a++)t.zoomFrontStyle[a]={};t.zoomFrontStyle.main={};let s=!1;for(let a=0;e[a];a++){let o=e[a];if(this.isOnlyZoomStyler(o))continue;let l=this.getFrontZoom(o);if("land"!==o.featureType&&"all"!==o.featureType&&"background"!==o.featureType||"string"!=typeof o.elementType||"geometry"!==o.elementType&&"texture"!==o.elementType&&"geometry.fill"!==o.elementType&&"all"!==o.elementType||!o.stylers||s||(o.stylers.color&&(t.bmapLandColor=o.stylers.color),o.stylers.image&&(t.bmapLandFillTexture=o.stylers.image),o.stylers.opacity&&(t.bmapLandColor=o.stylers.opacity),o.stylers.visibility&&"off"===o.stylers.visibility&&(t.bmapLandColor="#00000000"),"land"===o.featureType&&(s=!0)),"building"===o.featureType&&"string"==typeof o.elementType&&"geometry.fill"===o.elementType&&(t.buildingFill=!0),"roadarrow"===o.featureType&&"labels.icon"===o.elementType&&o.stylers){let e=o.stylers.visibility;t.zoomFrontStyle[l].bmapRoadarrowVisibility=e}let c={};Object.assign(c,o);let h=c.stylers;delete c.stylers,Object.assign(c,h);let u=[];for(let e in i)if(c[e]){if(this.isEditorZoomKeys(e))continue;if("elementType"===e)u.push(i[e]+":"+n[c[e]]);else if("image"===e)u.push(i[e]+":"+encodeURIComponent(encodeURIComponent(c[e])));else{switch(c[e]){case"poilabel":c[e]="poi";break;case"districtlabel":c[e]="label"}u.push(i[e]+":"+c[e])}}u.length>2&&r.push(u.join("|"))}return r.join(",")},getFrontZoom:function(e){let t=e.stylers.level;return void 0===t?"main":parseInt(t,10)},isOnlyZoomStyler:function(e){let t={};return Object.assign(t,e.stylers),delete t.curZoomRegionId,delete t.curZoomRegion,delete t.level,0===Object.keys(t).length},isEditorZoomKeys:function(e){return!!{curZoomRegionId:!0,curZoomRegion:!0}[e]},getFeatureStyles:async function(e){let t=await this.getStyleJson(e);const i=this.getStyleUrl(t,{zoomRegion:{},zoomStyleBody:[],zoomFrontStyle:{}});let n=i.split("?")[0],r=i.split("?")[1],s=null;if(n.indexOf("jsonp")>-1)s=await jsonp(n);else{let e=new FormData;r.split("&").forEach((t=>{const[i,n]=t.split("=");e.append(decodeURIComponent(i),decodeURIComponent(n||""))})),s=await fetch(n,{method:"POST",body:e}).then((e=>{if(e.ok)return e.json()}))}return s}},urlProtocol="http:"===window.location.protocol?"http:":"https:",apiHost=urlProtocol+"//api.map.baidu.com";class FetchTrack{constructor(){__publicField(this,"sendMessage",(e=>{})),this.device={PC:0,NA:1},this.config={mask:["FFFFFFFF"],open:!1,reset:36e5},this.url=apiHost+"?qt=jsapi_log",this.startTime=Date.now(),this.mark={},this.records={},this.ak=""}init(e,t){this.kill();let i=this;this.config.open=!!e,(t=t||{}).reset&&(this.config.reset=t.reset),this.sendMessage=function(e){let t=e||1e3;var n;return i._idleWorkerTicker=(n=i,function(){n.runJob()}),function(e){if(window.navigator&&!navigator.onLine)return;Date.now()-i.startTime>i.config.reset&&(i.startTime=Date.now(),i.mark={},i.records={});const n=e.join("-");i.mark[n]||(i.mark[n]=!0,i.records[n]=e),i.checkJob(t)}}(t.timers)}runJob(){if(0===Object.keys(this.records).length)return clearInterval(this.idleWork),void(this.idleWork=null);let t=Object.keys(this.records)[0],i=(new Date).getTime();if(this.config.open)try{const e=this.ak||BaiduMapConfig.ak;jsonp(this.url,{ak:e,mapvthree:1,device:0,module:this.records[t][0]||"",func:this.records[t][1]||"",subfunc:this.records[t][2]||"",t:i}).then((e=>{delete this.records[t]}))}catch(e){}0===Object.keys(this.records).length&&(clearInterval(this.idleWork),this.idleWork=null)}checkJob(e){!this.idleWork&&this._idleWorkerTicker&&(this.idleWork=setInterval(this._idleWorkerTicker,e))}kill(){this.idleWork&&(clearInterval(this.idleWork),this.idleWork=null),this._idleWorkerTicker=null,this.mark={},this.records={}}}const tongjiTrack=new FetchTrack;tongjiTrack.init(!0,{reset:12e5}),new three.Vector3,new three.Vector3;const http$a="http:"===window.location.protocol?"http:":"https:",onlineHosts=[`${http$a}//apimaponline0.bdimg.com`,`${http$a}//apimaponline1.bdimg.com`,`${http$a}//apimaponline2.bdimg.com`,`${http$a}//apimaponline3.bdimg.com`],getPixelSize$2=(e,t,i)=>.2*Math.tan(t/2)*e/i,textureLoader$5=new three.TextureLoader,dashTextureSingleton=new PromisedSingleton;dashTextureSingleton.generate=async e=>new Promise(((t,i)=>{textureLoader$5.load(e,(e=>{t(e)}),null,i)}));let globalDefaultStyleConfig=null;function encodeTileUrl(e){let t,i,n="";for(t=0;t<e.length;t++){i=e.charCodeAt(t)<<1;let r=i.toString(2),s=r;r.length<8&&(s="00000000"+r,s=s.substr(r.length,8)),n+=s}let r=5-n.length%5,s=[];for(t=0;t<r;t++)s[t]="0";n=s.join("")+n;let a=[];for(t=0;t<n.length/5;t++){i=n.substr(5*t,5);let e=parseInt(i,2)+50;a.push(String.fromCharCode(e))}return a.join("")+r.toString()}const mapStyleNameIdPair={default:0,"grayed-out":1},defaultStyleConfig={fontRgba:[0,0,0,0],fontSize:16,fontWeight:"400",haloRgba:[0,0,0,0],haloSize:0};async function loadIconSet(e){try{const t=document.createElement("script");return t.src=e,document.head.appendChild(t),new Promise(((i,n)=>{t.onload=()=>{i(window.iconSetInfo_high)},t.onerror=()=>{n(new Error(`Failed to load script: ${e}`))}}))}catch(t){throw console.error("Error loading icon set:",t),t}}const direction={0:"top",1:"left",2:"bottom",3:"right"};class BaiduVectorTileProvider extends VectorTileProvider{constructor(e={}){super(e),__publicField(this,"name","BaiduVectorTileProvider"),__publicField(this,"isBaiduProvider",!0),__publicField(this,"_shouldRenderPlaceholder",!0),__publicField(this,"_isAttach",!0),__publicField(this,"_supportAllProjections",!0),__publicField(this,"_defaultStartLevel",2),__publicField(this,"_defaultMaxLevel",16),__publicField(this,"_labels",{}),__publicField(this,"_ak",null),__publicField(this,"_loadStyle",(async()=>{let e=null;if(this._isOffline){let t=this._styleUrl||getAssetUrl("assets/map/style/default.json");e=await reFetch(t).then((e=>e.json())),e.data&&e.data.style&&(e=e.data.style)}else this._styleId||this._styleJson?(e=await mapStyleHelper.getFeatureStyles({styleId:this._styleId,styleJson:this._styleJson}),e.data&&e.data.style?e=e.data.style:0!==e.status&&console.error("An error occurred when setMapStyle in BaiduVectorProvider: ",e.message)):(globalDefaultStyleConfig||(await loadScript("https://maponline0.bdimg.com/sty/fs.js"),globalDefaultStyleConfig=window.FeatureStyle),e=globalDefaultStyleConfig);this._dataLoader.postMessageToAll({type:"changeStyle",featureStyles:e})})),__publicField(this,"_getIconStyleFile",(async e=>{const t=this._getMapStyleFiles(e),i=await loadIconSet(t[0]);this._dataLoader.postMessageToAll({type:"changeIconSetInfo",iconSetInfo:i})}));const t=e.ak||BaiduMapConfig.ak,i=e.offlineAk||"USER_AK";if(this._displayOptions=e.displayOptions,this._url=e.url,this._styleUrl=e.styleUrl,this._styleId=e.styleId,this._styleJson=e.styleJson,this._isOffline=e.isOffline,this._isOffline)this._staticUrl=e.staticUrl,this._sourceProjectionName=defaultValue$1(e.projection,PROJECTION_WEB_MERCATOR),this._isWebMercator=!(this._sourceProjectionName!==PROJECTION_WEB_MERCATOR),this._offlineAk=i,this._customid=window.BMAPGL_TILE_DIR_TYPE||"vector-tile";else{if(!t)throw new Error("没有有效百度地图AK，请设置BaiduMapConfig.ak或options.ak");this._staticUrl="https://maponline0.bdimg.com",this._sourceProjectionName=PROJECTION_BD_MERCATOR,this._isWebMercator=!1,this.sourceCoordType="BD09",mapStyleHelper.ak=t,tongjiTrack.ak=t,tongjiTrack.sendMessage(["layer","vector","normal"]),this._ak=t}this._isWebMercator?(this._isAttach=defaultValue$1(e.isAttach,!0),this._defaultMinLevel=2,this._defaultMaxLevel=20):(this._isAttach=!1,this._defaultMinLevel=3,this._defaultMaxLevel=21)}initProjectionAndGrid(){this._sourceProjection=getProjection(this._sourceProjectionName),this._sourceProjectionName===PROJECTION_BD_MERCATOR?this._grid=new BaiduVectorOnlineGrid(this._engine,this._sourceProjection,this._targetProjection):this._grid=new BaiduVectorOfflineGrid(this._engine,this._sourceProjection,this._targetProjection)}async setMapStyle(e){if(!e||!e.styleId&&!e.styleJson)return;if(e.styleId&&e.styleId===this._styleId||e.styleJson&&e.styleJson===this._styleJson)return;this._styleId=e.styleId,this._styleJson=e.styleJson;let t=await mapStyleHelper.getFeatureStyles(e);t&&(t.data&&t.data.style?t=t.data.style:0!==t.status&&console.error("An error occurred when setMapStyle in BaiduVectorProvider: ",t.message),this._dataLoader&&(this._dataLoader.postMessageToAll({type:"changeStyle",featureStyles:t}),this._needsClearCache=!0,this._engine.requestRender()))}async _asyncInit(){this._dataLoader||(this._dataLoader=new AsyncDataTileLoader(this,WorkerWrapper$2,2)),await this._loadStyle(),await this._getIconStyleFile("default")}_getMapStyleFiles(e){let t=!0;"string"==typeof e&&"default"!==e&&(t=!1);const i=t?"":"_"+(mapStyleNameIdPair[e]-1);if(!this._vctMapStyleDomain){let e="http://10.27.57.8:8837/dugis-demo-3d";this._staticUrl?e=this._staticUrl:window.BMAPGL_STATIC_URL?e=window.BMAPGL_STATIC_URL:this._url&&(e=this._url),this._vctMapStyleDomain=`${e}/sty/`}const n=this._vctMapStyleDomain;return[n+"icons_2x"+i+".js?",n+"fs"+i+".js?",n+"indoor_fs.js?"]}getTileURL(e,t,i,n){return n.loaderConfig&&(e=n.loaderConfig.baseZ),this._isOffline?this._getOfflineTileURL(e,t,i,n):this._getOnlineTileURL(e,t,i,n)}_getOnlineTileURL(e,t,i,n){const[r,s,a]=n.grid.getRasterTileCoord(e,t,i);const o=`x=${s}&y=${a}&z=${r}&styles=pl&textimg=0&v=088&udt=20190618&json=0`;return`${onlineHosts[Math.abs(t+i)%4]}/pvd/?qt=vtile&v=three&ak=${this._ak}&param=`+window.encodeURIComponent(encodeTileUrl(o))}_getOfflineTileURL(e,t,i,n){let r=e,s=t,a=i;this._isWebMercator||([r,s,a]=n.grid.getRasterTileCoord(e,t,i));let o=`http://10.27.57.8:8837/maptile/v1/pvd/?qt=vtile&x=${s}&y=${a}&z=${r}&styles=pl&textimg=0&v=088&udt=20190618&json=0&ApiAuthorization=${this._offlineAk}`;return this._url?o=`${this._url}/pvd?qt=vtile&x=${s}&y=${a}&z=${r}&styles=pl&textimg=0&v=088&udt=20190618&json=0&ApiAuthorization=${this._offlineAk}`:window.BMAPGL_URL&&(o=`${window.BMAPGL_URL}/pvd?qt=vtile&x=${s}&y=${a}&z=${r}&styles=pl&textimg=0&v=088&udt=20190618&json=0&ApiAuthorization=${this._offlineAk}`),o+=`&customid=${this._customid}`,o}getWorkerOptions(){return{isAttach:this._isAttach,displayOptions:this._displayOptions,styleZoomOffset:this._isWebMercator?0:-1}}getFetchOptions(e){return{...e.loaderConfig}}async doRequestVectorTileData(e){const t=await this._dataLoader.requestTile(e),{polygon:i,polygonOpacity:n,line:r,dashLine:s,textureLine:a,gaoqingLine:o,polygon3d:l,building3d:c,poi:h,arrow:u}=t.content,d=t.isNormalized,p=this._engine.rendering.features.antialias.samples>0,m=new three.Group,f=new three.Group;if(i&&i.indices){const e=new three.BufferGeometry,t=new three.InterleavedBuffer(i.attributes,10);e.setAttribute("position",new three.InterleavedBufferAttribute(t,3,0)),e.setAttribute("normal",new three.InterleavedBufferAttribute(t,3,3)),e.setAttribute("color",new three.InterleavedBufferAttribute(t,3,6)),e.setAttribute("layerIndex",new three.InterleavedBufferAttribute(t,1,9)),e.setIndex(new three.BufferAttribute(i.indices,1));const n=new BaiduVectorMaterial({depthTest:!0,vertexColors:!0,vertexZIndexLegacy:!0,enableDepthRange:!0});n.setCommonUniforms(this._engine.rendering.uniforms);const r=new three.Mesh(e,n);r.name="Polygons",f.add(r)}if(n&&n.indices){const e=new three.BufferGeometry,t=new three.InterleavedBuffer(n.attributes,11);e.setAttribute("position",new three.InterleavedBufferAttribute(t,3,0)),e.setAttribute("normal",new three.InterleavedBufferAttribute(t,3,3)),e.setAttribute("aColor",new three.InterleavedBufferAttribute(t,4,6)),e.setAttribute("layerIndex",new three.InterleavedBufferAttribute(t,1,10)),e.setIndex(new three.BufferAttribute(n.indices,1));const i=new BaiduVectorMaterial({depthTest:!0,transparent:!0,isColor4:!0,vertexColors:!0,vertexZIndexLegacy:!0,enableDepthRange:!0});i.setCommonUniforms(this._engine.rendering.uniforms);const r=new three.Mesh(e,i);r.name="Polygons",f.add(r)}if(r&&r.indices){const e=new three.BufferGeometry,t=new three.InterleavedBuffer(r.attributes,12);e.setAttribute("position",new three.InterleavedBufferAttribute(t,3,0)),e.setAttribute("normal",new three.InterleavedBufferAttribute(t,3,3)),e.setAttribute("aColor",new three.InterleavedBufferAttribute(t,4,6)),e.setAttribute("layerIndex",new three.InterleavedBufferAttribute(t,1,10)),e.setAttribute("aWidth",new three.InterleavedBufferAttribute(t,1,11)),e.setIndex(new three.BufferAttribute(r.indices,1));const i=new FatLineMaterial({keepSize:!0,depthTest:!0,transparent:!p,antialias:!p,lineWidth:1,vertexColors:!0,vertexZIndexLegacy:!0,enableDepthRange:!0});i.setCommonUniforms(this._engine.rendering.uniforms);const n=new three.Mesh(e,i);n.name="Links",f.add(n)}if(s){const t=Object.keys(s);for(let i=0;i<t.length;i++){const n=t[i],r=s[n],a=this._vctMapStyleDomain+"map_icons2x/"+n+".png",o=new three.BufferGeometry,l=new three.InterleavedBuffer(r.attributes,14);o.setAttribute("position",new three.InterleavedBufferAttribute(l,3,0)),o.setAttribute("normal",new three.InterleavedBufferAttribute(l,3,3)),o.setAttribute("aColor",new three.InterleavedBufferAttribute(l,4,6)),o.setAttribute("layerIndex",new three.InterleavedBufferAttribute(l,1,10)),o.setAttribute("aWidth",new three.InterleavedBufferAttribute(l,1,11)),o.setAttribute("uv",new three.InterleavedBufferAttribute(l,2,12)),o.setIndex(new three.BufferAttribute(r.indices,1));const c=new FatLineMaterial({keepSize:!0,antialias:!0,depthTest:!0,transparent:!0,lineWidth:100,mapGap:0,vertexColors:!0,vertexZIndexLegacy:!0,enableDepthRange:!0});c.flipUv=!0,c.setCommonUniforms(this._engine.rendering.uniforms);const h=new three.Mesh(o,c);h.onBeforeRender=()=>{const t=e.targetCenter,i=this._engine.camera,n=this._engine.rendering.renderState,r=i.position,s=t.clone();s.x-=n.cameraOffset.x,s.y-=n.cameraOffset.y,s.z-=n.cameraOffset.z;const a=r.distanceTo(s),o=getPixelSize$2(a,i.fov*Math.PI/180,this._engine.container.clientHeight);c.zoomUnits=o},h.name="Links",dashTextureSingleton.get(a).then((e=>{e.wrapS=e.wrapT=three.RepeatWrapping,e.generateMipmaps=!1,e.colorSpace=three.SRGBColorSpace,c.useMap=!0,c.map=e,f.add(h)}))}}if(a){const e=Object.keys(a);for(let t=0;t<e.length;t++){const i=e[t],n=a[i],r=this._vctMapStyleDomain+"map_icons2x/"+i+".png",s=new three.BufferGeometry,o=new three.InterleavedBuffer(n.attributes,15);s.setAttribute("position",new three.InterleavedBufferAttribute(o,3,0)),s.setAttribute("normal",new three.InterleavedBufferAttribute(o,3,3)),s.setAttribute("aColor",new three.InterleavedBufferAttribute(o,4,6)),s.setAttribute("layerIndex",new three.InterleavedBufferAttribute(o,1,10)),s.setAttribute("aWidth",new three.InterleavedBufferAttribute(o,1,11)),s.setAttribute("uv",new three.InterleavedBufferAttribute(o,2,12)),s.setAttribute("totalLength",new three.InterleavedBufferAttribute(o,1,14)),s.setIndex(new three.BufferAttribute(n.indices,1));const l=new FatLineMaterial({keepSize:!1,depthTest:!0,transparent:!0,mapGap:0,lineWidth:100,vertexColors:!0,vertexZIndexLegacy:!0,enableDepthRange:!0});l.isSingle=!0,l.flipUv=!0,l.setCommonUniforms(this._engine.rendering.uniforms);const c=new three.Mesh(s,l);c.name="Links",dashTextureSingleton.get(r).then((e=>{e.wrapS=e.wrapT=three.RepeatWrapping,e.generateMipmaps=!1,e.colorSpace=three.SRGBColorSpace,l.useMap=!0,l.map=e,f.add(c)}))}}if(o){const e=Object.keys(o);for(let t=0;t<e.length;t++){const i=e[t],n=o[i],r=this._vctMapStyleDomain+"map_icons2x/"+i+".png",s=new three.BufferGeometry,a=new three.InterleavedBuffer(n.attributes,14);s.setAttribute("position",new three.InterleavedBufferAttribute(a,3,0)),s.setAttribute("normal",new three.InterleavedBufferAttribute(a,3,3)),s.setAttribute("aColor",new three.InterleavedBufferAttribute(a,4,6)),s.setAttribute("layerIndex",new three.InterleavedBufferAttribute(a,1,10)),s.setAttribute("aWidth",new three.InterleavedBufferAttribute(a,1,11)),s.setAttribute("uv",new three.InterleavedBufferAttribute(a,2,12)),s.setIndex(new three.BufferAttribute(n.indices,1));const l=new FatLineMaterial({keepSize:!1,antialias:!0,depthTest:!0,transparent:!0,lineWidth:1,mapGap:0,vertexColors:!0,vertexZIndexLegacy:!0,enableDepthRange:!0});l.flipUv=!0,l.setCommonUniforms(this._engine.rendering.uniforms);const c=new three.Mesh(s,l);c.name="Links",dashTextureSingleton.get(r).then((e=>{e.wrapS=e.wrapT=three.RepeatWrapping,e.generateMipmaps=!1,e.colorSpace=three.SRGBColorSpace,l.useMap=!0,l.map=e,f.add(c)}))}}if(l&&l.indices){const e=new three.BufferGeometry,t=new three.InterleavedBuffer(l.attributes,10);e.setAttribute("position",new three.InterleavedBufferAttribute(t,3,0)),e.setAttribute("normal",new three.InterleavedBufferAttribute(t,3,3)),e.setAttribute("color",new three.InterleavedBufferAttribute(t,3,6)),e.setAttribute("layerIndex",new three.InterleavedBufferAttribute(t,1,9)),e.setIndex(new three.BufferAttribute(l.indices,1));const i=new BaiduVectorMaterial({depthTest:!0,vertexColors:!0,vertexZIndexLegacy:!0,enableDepthRange:!0});i.setCommonUniforms(this._engine.rendering.uniforms);const n=new three.Mesh(e,i);n.name="Polygons3D",f.add(n)}if(c&&c.indices){const e=new three.BufferGeometry,t=new three.InterleavedBuffer(c.attributes,11);e.setAttribute("position",new three.InterleavedBufferAttribute(t,3,0)),e.setAttribute("normal",new three.InterleavedBufferAttribute(t,3,3)),e.setAttribute("color",new three.InterleavedBufferAttribute(t,3,6)),e.setAttribute("heightAndConcave",new three.InterleavedBufferAttribute(t,2,9)),e.setIndex(new three.BufferAttribute(c.indices,1));const i=new BaiduVectorMaterial({depthTest:!0,vertexColors:!0});i.useAO=!0,i.setCommonUniforms(this._engine.rendering.uniforms);const n=new three.Mesh(e,i);n.name="Building3D",m.add(n)}if(u&&u.indices){const e=new three.BufferGeometry,t=new three.InterleavedBuffer(u.attributes,12);e.setAttribute("position",new three.InterleavedBufferAttribute(t,3,0)),e.setAttribute("a_normal",new three.InterleavedBufferAttribute(t,3,3)),e.setAttribute("a_uv",new three.InterleavedBufferAttribute(t,2,6)),e.setAttribute("a_diff",new three.InterleavedBufferAttribute(t,3,8)),e.setAttribute("layerIndex",new three.InterleavedBufferAttribute(t,1,11)),e.setIndex(new three.BufferAttribute(u.indices,1));const i=new ArrowMaterial({transparent:!0,vertexZIndexLegacy:!0,isGlobe:!!this._engine.map.isGlobe});i.setCommonUniforms(this._engine.rendering.uniforms);const n=new three.Mesh(e,i);n.name="Arrow",m.add(n)}if(h&&h.length){let t=[];const i=this._engine.map.projectionName,n=`${e.x}-${e.y}-${e.z}`;for(let e=0;e<h.length;e++){const r=h[e].position,s=`${r[0]}-${r[1]}-${r[2]}`;let a=h[e].uid?`${h[e].uid}_${n}`:`${h[e].name}-${s}`;const o=h[e].hasText?h[e].styleConfig:defaultStyleConfig,l=defaultValue$1(h[e].iconConfig,{}),c=l.icon?this._vctMapStyleDomain+"map_icons2x/"+l.icon+".png":"",u=defaultValue$1(l.size,[0,0]),d=defaultValue$1(direction[h[e].direction],"center"),p=l.textDrawOnIcon,m=h[e].hasText;let f="text_fix";c&&(f="icon",m&&(f="icon_text")),m&&!h[e].text||t.push({crs:i,id:a,forceProjected:i===PROJECTION_GEO,type:h[e].type?h[e].type:f,rotateZ:"rotateZ"in h[e]?h[e].rotateZ:void 0,position:r,text:h[e].text,rank:h[e].rank,textFillStyle:o.fontRgba,textSize:o.fontSize/2,textStrokeStyle:o.haloRgba,textStrokeWidth:Math.min(o.haloSize/2,4),textAnchor:d,styleId:h[e].styleId,icon:c,iconSize:u,hasText:h[e].hasText,textDrawOnIcon:p})}m.poiLabels=t}return d?(e.projectedBoundingBox.getSize(m.scale),m.scale.z=1,f.scale.copy(m.scale),m.position.copy(e.targetCenter),f.position.copy(e.targetCenter)):(m.position.copy(e.targetCenter),f.position.copy(e.targetCenter)),[m,f]}updateDisplayOptions(e){Object.assign(this._displayOptions,e),this._needsClearCache=!0,this._engine.requestRender()}_calculateTolerance(e,t,i){const n=e.tile.z;let r=0;return 5===n&&"中华人民共和国"===i.text&&(r=-3),6===n&&"广州"===i.text&&(r=-4),7===n?(r=4,"三沙"!==i.text&&"三亚"!==i.text&&"儋州"!==i.text||(r=-1)):n>7&&(r=12),"香港"!==i.text&&"澳门"!==i.text&&"台北"!==i.text||(r=-3),r}_addTilePOI(e,t){if(e.object&&e.object.poiLabels){const i=e.dataTile.key,n=e.tile._distance,r=e.tile.z<10,s=[];for(let o=0;o<e.object.poiLabels.length;o++){const a=e.object.poiLabels[o];this._labels[a.id]||(this._labels[a.id]=a,a.bucket=i,a.distance=n,a.checkVisible=r,a.tolerance=this._calculateTolerance(e,t,a),s.push(a))}const a=e.dataTile.key;t.rendering.label.addLabels(s,a)}}_removeTilePOI(e,t){if(e.object&&e.object.poiLabels){const i=[],n=e.dataTile.key;for(let t=0;t<e.object.poiLabels.length;t++){const n=e.object.poiLabels[t];this._labels[n.id]&&(delete this._labels[n.id],i.push(n))}t.rendering.label.removeLabels(i,n)}}onTileDispose(e){}onSurfaceTileAdded(e,t){e.isMeetSSE&&this._addTilePOI(e,t)}onSurfaceTileRemoved(e,t){this._removeTilePOI(e,t)}onSurfaceTileSSEChanged(e,t){e.isMeetSSE?this._addTilePOI(e,t):this._removeTilePOI(e,t)}addAllSymbols(){Object.keys(this._labels).forEach((e=>{const t=this._labels[e];t.isHidden&&(t.isHidden=!1,this._engine.rendering.label.addLabel(t))}))}removeAllSymbols(){Object.keys(this._labels).forEach((e=>{const t=this._labels[e];t.isHidden||(t.isHidden=!0,this._engine.rendering.label.removeLabel(t))}))}}class EngineMap extends three.EventDispatcher{constructor(e,t={}){super(),__publicField(this,"_engine"),__publicField(this,"_map"),__publicField(this,"_container"),__publicField(this,"_mapType"),__publicField(this,"handleViewChange",(()=>{this._engine.rendering.requestRender()})),__publicField(this,"handleResolutionChange",(e=>{this._engine.rendering.resolution=e})),this._engine=e,this._options=t;const i=e.container;let n=null;n=t.projection&&t.projection.isProjection?t.projection:getProjection(t.projection||PROJECTION_WEB_MERCATOR);let r=n.name;if(i instanceof HTMLElement)if(t.customMap){const r=t.customMap;this._map=new r(e,i,t),this._container=i,this._mapType="custom",n=getProjection(this._map.projectionName||PROJECTION_WEB_MERCATOR)}else r===PROJECTION_ECEF?(this._map=new Earth(e,i,t),this._container=i,this._mapType="earth",this.isGlobe=!0):!1===t.is3DControl?(this._map=new BlankMap(e,i,t),this._container=i,this._mapType="blank"):(this._map=new BlankMap3DControl(e,i,t),this._container=i,this._mapType="blank_3dcontrol");if(!this._map)throw new Error("map is invalid");this._projection=n,this._map.projection=n,this._map.projectionName=n.name,this._coordType=t.coordType||void 0}init(){this._map.init(),this._map.onViewChanged=this.handleViewChange,this._map.onResolutionChanged=this.handleResolutionChange}afterInit(){const e=this._engine,t=this._map;t.canvas=e.rendering.canvas,t.camera=e.rendering.camera,addClass(this._container,`${CSS_NAMESPACE}-container`),t.afterInit();const i=this._options;defined$2(i.center)?t.lookAt(i.center,{range:i.range,heading:i.heading,pitch:i.pitch}):(defined$2(i.heading)&&t.setHeading(i.heading),defined$2(i.pitch)&&t.setPitch(i.pitch),defined$2(i.range)&&t.setRange(i.range));let n=i.provider;if(null===n)return;if(n||(n=new BaiduVectorTileProvider),!n)return;let r,s=null,a=null;if(n.isVectorTileProvider)a=n,r=null;else{if(!n.isImageryTileProvider)throw new Error("invalid tile provider");s=n}this._mapView=this._engine.add(new MapView({vectorProvider:a,imageryProvider:s,terrainProvider:r}))}setCenter(e){this._map.setCenter(e)}setZoom(e){this._map.setZoom(e)}setHeading(e){this._map.setHeading(e)}setPitch(e){this._map.setPitch(e)}setRange(e){this._map.setRange(e)}setBounds(e){this._map.setBounds(e)}lockDrag(e){this._map.lockDrag(e)}setMaxRange(e){this._map.setMaxRange(e)}setMinRange(e){this._map.setMinRange(e)}lookAt(e,t={}){e?this._map.lookAt(e,t):console.error("engine.map.lookAt: target is required")}getBoundingBox(){return this._map.getBounds()}getCenter(){return this._map.getCenter()}getRange(){return this._map.getRange()}getZoom(){return this._map.getZoom()}getZoomUnits(){return this._map.getZoomUnits()}getZoomByZoomUnits(e){return this._map.getZoomByZoomUnits(e)}getZoomUnitsByZoom(e){return this._map.getZoomUnitsByZoom(e)}getHeading(){return this._map.getHeading()}flyTo(e,t={}){if(this._map.flyTo)return this._map.flyTo(e,t);errorOnce("flyTo is not supported by this map")}getPitch(){return this._map.getPitch()}getProjectionCenter(){return this._map.getProjectionCenter()}getCameraDistance(e){return this._map.getCameraDistance(e)}getBounds(){return this._map.getBounds()}getProjectionBounds(){return this._map.getProjectionBounds()}getResolution(){return this._map.getResolution()}projectArrayCoordinate(e,t){return this._map.projectArrayCoordinate(e,t)}unprojectArrayCoordinate(e,t){return this._map.unprojectArrayCoordinate(e,t)}projectPointArr(e,t){return console.warn("projectPointArr is deprecated, use projectArrayCoordinate instead"),this.projectArrayCoordinate(e,t)}unprojectPointArr(e,t){return console.warn("unprojectPointArr is deprecated, use unprojectArrayCoordinate instead"),this.unprojectArrayCoordinate(e,t)}projectCoordinate(e,t){return this._projection.projectCoordinate(e,t)}unprojectCoordinate(e,t){return this._projection.unprojectCoordinate(e,t)}projectArrayCoordinates(e){if(Array.isArray(e[0])){const t=[];for(let i of e)t.push(this.projectArrayCoordinates(i));return t}if("number"==typeof e[0]||"string"==typeof e[0])return this.projectArrayCoordinate(e)}enableControl(){console.warn("enableControl is deprecated, use engine.controller.enabled = true instead"),this._map.enableControl()}disableControl(){console.warn("disableControl is deprecated, use engine.controller.enabled = false instead"),this._map.disableControl()}updateCamera(){this._map.updateCamera()}getScaleAt(e){return 1/Math.cos(Math.PI*e[1]/180)}zoomIn(){this._map.zoomIn()}zoomOut(){this._map.zoomOut()}zoomTo(e,t={range:0,zoom:0}){let i=null;if(e.is3DTiles)i=e.getBounds();else if(e.isInstancedMesh)e.computeBoundingBox(),i=e.boundingBox,i=i.clone(),i.applyMatrix4(e.matrixWorld);else if(e.isMesh||e.isPoints){const t=e.geometry;i=t.boundingBox,i||(t.computeBoundingBox(),i=t.boundingBox),i=i.clone(),i.applyMatrix4(e.matrixWorld)}else e.boundingBox&&(i=e.boundingBox,i=i.clone(),i.applyMatrix4(e.matrixWorld));if(!i)return;const n=this.getResolution(),r=(i.max.x-i.min.x)/n.x,s=(i.max.y-i.min.y)/n.y,a=Math.max(r,s),o=this._map.getZoomByZoomUnits(a),l=[(i.max.x+i.min.x)/2,(i.max.y+i.min.y)/2,(i.max.z+i.min.z)/2];if(this._map.isBlankMap3D||this.isGlobe){let e=Math.max(i.max.x-i.min.x,i.max.y-i.min.y)/Math.tan(this.fov/2*Math.PI/180);const n=this._map.unprojectArrayCoordinate(l);this.lookAt(n,{range:e+t.range}),this._map.range=e+t.range}else this._map.setProjectionCenter(l),this._map.setZoom(o+t.zoom);this._engine.requestRender()}getViewHeight(){return this._map.getViewHeight()}getCameraLocation(e){return this._map.getCameraLocation(e)}setViewport(e,t={range:0,zoom:0}){if(!e||e.length<2)return void console.warn("setViewport: points require Array with at least 2 points");let i=new three.Box3,n=e.map((e=>{if(e.isVector3||e.isVector2)return this.projectCoordinate(e);let t=this.projectArrayCoordinate(e);return new three.Vector3(t[0],t[1],t[2]||0)}));i.setFromPoints(n);const r=this.getResolution(),s=(i.max.x-i.min.x)/r.x,a=(i.max.y-i.min.y)/r.y,o=Math.max(s,a),l=Math.min(30,this._map.getZoomByZoomUnits(o)),c=[(i.max.x+i.min.x)/2,(i.max.y+i.min.y)/2,(i.max.z+i.min.z)/2];if(this._map.isBlankMap3D||this.isGlobe){let e=Math.max(i.max.x-i.min.x,i.max.y-i.min.y)/Math.tan(this.fov/2*Math.PI/180),n=this.unprojectArrayCoordinate(c);this.lookAt(n,{range:e+t.range}),this._map.range=e+t.range}else this._map.setProjectionCenter(c),this._map.setZoom(l+t.zoom);this._engine.requestRender()}bindCanvas(){this._map.bindCanvas()}releaseCanvas(){this._map.releaseCanvas()}pickSeaLevelWorldPosition(e){return this._map.pickSeaLevelWorldPosition(e)}dispose(){this._map.dispose()}set onResolutionChanged(e){this._map.onResolutionChanged=e}get projectionName(){return this._projection.name}get map(){return this._map}get mapType(){return this._mapType}get container(){return console.warn("container is deprecated, use engine.container instead"),this._container}get fov(){return this._map.fov}set fov(e){this._map.fov=e,this._engine.camera.fov=e}get near(){return this._map.near}get far(){return this._map.far}get projection(){return this._projection}set projection(e){this._projection=e}get mapView(){return this._mapView}get coordType(){return this._coordType}}class BoundingBoxHelper extends three.Object3D{constructor(){super(),__publicField(this,"_boxGeometry"),__publicField(this,"_boxMesh"),this._boxMaterial=new three.MeshBasicMaterial({transparent:!0,color:16711680,opacity:.3})}attach(e){this._object=e;const t=e.geometry;t.boundingBox||t.computeBoundingBox(),this._boxGeometry&&this._boxGeometry.dispose();const i=t.boundingBox;if(this._boxGeometry=new three.BoxGeometry(i.max.x-i.min.x,i.max.y-i.min.y,i.max.z-i.min.z),this._boxMesh)this._boxMesh.geometry=this._boxGeometry;else{const e=this._boxMesh=new three.Mesh(this._boxGeometry,this._boxMaterial);this.add(e)}}detach(){this._object=null,this.remove(this._boxMesh),this._boxMesh=null}onBeforeScenePrepareRender(){if(this._object){this._object.updateMatrixWorld();const e=this._boxMesh;this._object.matrixWorld.decompose(e.position,e.rotation,e.scale)}}}const _raycaster=new three.Raycaster,_tempVector=new three.Vector3,_tempVector2=new three.Vector3,_tempQuaternion=new three.Quaternion,_unit={X:new three.Vector3(1,0,0),Y:new three.Vector3(0,1,0),Z:new three.Vector3(0,0,1)},_changeEvent$1={type:"change"},_mouseDownEvent={type:"pointerdown"},_mouseUpEvent={type:"pointerup",mode:null},_mouseMoveEvent={type:"pointermove",mode:null},_objectChangeEvent={type:"objectChange"};class TransformControls extends three.Object3D{constructor(e,t){super(),__publicField(this,"_cameraScale"),__publicField(this,"_endNorm"),__publicField(this,"_gizmo"),__publicField(this,"_getPointer"),__publicField(this,"_onPointerDown"),__publicField(this,"_onPointerHover"),__publicField(this,"_onPointerMove"),__publicField(this,"_onPointerUp"),__publicField(this,"_parentPosition"),__publicField(this,"_parentQuaternion"),__publicField(this,"_parentQuaternionInv"),__publicField(this,"_parentScale"),__publicField(this,"_plane"),__publicField(this,"_positionStart"),__publicField(this,"_quaternionStart"),__publicField(this,"_scaleStart"),__publicField(this,"_startNorm"),__publicField(this,"_worldQuaternionInv"),__publicField(this,"_worldScale"),__publicField(this,"_worldScaleStart"),__publicField(this,"_offset"),__publicField(this,"isTransformControls"),void 0===t&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),t=document),this.visible=!1,this.domElement=t,this.domElement.style.touchAction="none";const i=new TransformControlsGizmo;this._gizmo=i,this.add(i);const n=new TransformControlsPlane;this._plane=n,this.add(n);const r=this;function s(e,t){let s=t;Object.defineProperty(r,e,{get:function(){return void 0!==s?s:t},set:function(t){s!==t&&(s=t,n[e]=t,i[e]=t,r.dispatchEvent({type:e+"-changed",value:t}),r.dispatchEvent(_changeEvent$1))}}),r[e]=t,n[e]=t,i[e]=t}s("camera",e),s("object",void 0),s("enabled",!0),s("axis",null),s("mode","translate"),s("translationSnap",null),s("rotationSnap",null),s("scaleSnap",null),s("space","local"),s("size",.7),s("dragging",!1),s("showX",!0),s("showY",!0),s("showZ",!0);const a=new three.Vector3,o=new three.Vector3,l=new three.Quaternion,c=new three.Quaternion,h=new three.Vector3,u=new three.Quaternion,d=new three.Vector3,p=new three.Vector3,m=new three.Vector3,f=new three.Vector3;s("worldPosition",a),s("worldPositionStart",o),s("worldQuaternion",l),s("worldQuaternionStart",c),s("cameraPosition",h),s("cameraQuaternion",u),s("pointStart",d),s("pointEnd",p),s("rotationAxis",m),s("rotationAngle",0),s("eye",f),this._offset=new three.Vector3,this._startNorm=new three.Vector3,this._endNorm=new three.Vector3,this._cameraScale=new three.Vector3,this._parentPosition=new three.Vector3,this._parentQuaternion=new three.Quaternion,this._parentQuaternionInv=new three.Quaternion,this._parentScale=new three.Vector3,this._worldScaleStart=new three.Vector3,this._worldQuaternionInv=new three.Quaternion,this._worldScale=new three.Vector3,this._positionStart=new three.Vector3,this._quaternionStart=new three.Quaternion,this._scaleStart=new three.Vector3,this._getPointer=getPointer.bind(this),this._onPointerDown=onPointerDown.bind(this),this._onPointerHover=onPointerHover.bind(this),this._onPointerMove=onPointerMove.bind(this),this._onPointerUp=onPointerUp.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(e){if(void 0===this.object||!0===this.dragging)return;_raycaster.setFromCamera(e,this.camera);const t=intersectObjectWithRay(this._gizmo.picker[this.mode],_raycaster);this.axis=t?t.object.name:null}pointerDown(e){if(void 0!==this.object&&!0!==this.dragging&&0===e.button&&null!==this.axis){_raycaster.setFromCamera(e,this.camera);const t=intersectObjectWithRay(this._plane,_raycaster,!0);t&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(t.point).sub(this.worldPositionStart)),this.dragging=!0,_mouseDownEvent.mode=this.mode,this.dispatchEvent(_mouseDownEvent)}}pointerMove(e){const t=this.axis,i=this.mode,n=this.object;let r=this.space;if("scale"===i?r="local":"E"!==t&&"XYZE"!==t&&"XYZ"!==t||(r="world"),void 0===n||null===t||!1===this.dragging||-1!==e.button)return;_raycaster.setFromCamera(e,this.camera);const s=intersectObjectWithRay(this._plane,_raycaster,!0);if(s){if(this.pointEnd.copy(s.point).sub(this.worldPositionStart),"translate"===i)this._offset.copy(this.pointEnd).sub(this.pointStart),"local"===r&&"XYZ"!==t&&this._offset.applyQuaternion(this._worldQuaternionInv),-1===t.indexOf("X")&&(this._offset.x=0),-1===t.indexOf("Y")&&(this._offset.y=0),-1===t.indexOf("Z")&&(this._offset.z=0),"local"===r&&"XYZ"!==t?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),n.position.copy(this._offset).add(this._positionStart),this.translationSnap&&("local"===r&&(n.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert()),-1!==t.search("X")&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),-1!==t.search("Y")&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),-1!==t.search("Z")&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.position.applyQuaternion(this._quaternionStart)),"world"===r&&(n.parent&&n.position.add(_tempVector.setFromMatrixPosition(n.parent.matrixWorld)),-1!==t.search("X")&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),-1!==t.search("Y")&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),-1!==t.search("Z")&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.parent&&n.position.sub(_tempVector.setFromMatrixPosition(n.parent.matrixWorld))));else if("scale"===i){if(-1!==t.search("XYZ")){let e=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(e*=-1),_tempVector2.set(e,e,e)}else _tempVector.copy(this.pointStart),_tempVector2.copy(this.pointEnd),_tempVector.applyQuaternion(this._worldQuaternionInv),_tempVector2.applyQuaternion(this._worldQuaternionInv),_tempVector2.divide(_tempVector),-1===t.search("X")&&(_tempVector2.x=1),-1===t.search("Y")&&(_tempVector2.y=1),-1===t.search("Z")&&(_tempVector2.z=1);n.scale.copy(this._scaleStart).multiply(_tempVector2),this.scaleSnap&&(-1!==t.search("X")&&(n.scale.x=Math.round(n.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==t.search("Y")&&(n.scale.y=Math.round(n.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==t.search("Z")&&(n.scale.z=Math.round(n.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===i){this._offset.copy(this.pointEnd).sub(this.pointStart);const e=20/this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));"E"===t?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):"XYZE"===t?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye))*e):"X"!==t&&"Y"!==t&&"Z"!==t||(this.rotationAxis.copy(_unit[t]),_tempVector.copy(_unit[t]),"local"===r&&_tempVector.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(_tempVector.cross(this.eye).normalize())*e),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),"local"===r&&"E"!==t&&"XYZE"!==t?(n.quaternion.copy(this._quaternionStart),n.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),n.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),n.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(_changeEvent$1),this.dispatchEvent(_objectChangeEvent),_mouseMoveEvent.mode=this.mode,this.dispatchEvent(_mouseMoveEvent)}}pointerUp(e){0===e.button&&(this.dragging&&null!==this.axis&&(_mouseUpEvent.mode=this.mode,this.dispatchEvent(_mouseUpEvent)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse((function(e){e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}))}attach(e){return this.object=e,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(_changeEvent$1),this.dispatchEvent(_objectChangeEvent),this.pointStart.copy(this.pointEnd))}getRaycaster(){return _raycaster}getMode(){return this.mode}setMode(e){this.mode=e}setTranslationSnap(e){this.translationSnap=e}setRotationSnap(e){this.rotationSnap=e}setScaleSnap(e){this.scaleSnap=e}setSize(e){this.size=e}setSpace(e){this.space=e}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}function getPointer(e){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:e.button};{const t=this.domElement.getBoundingClientRect();return{x:(e.clientX-t.left)/t.width*2-1,y:-(e.clientY-t.top)/t.height*2+1,button:e.button}}}function onPointerHover(e){if(this.enabled)switch(e.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(e))}}function onPointerDown(e){this.enabled&&(this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(e)),this.pointerDown(this._getPointer(e)))}function onPointerMove(e){this.enabled&&this.pointerMove(this._getPointer(e))}function onPointerUp(e){this.enabled&&(this.domElement.releasePointerCapture(e.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(e)))}function intersectObjectWithRay(e,t,i){const n=t.intersectObject(e,!0);for(let r=0;r<n.length;r++)if(n[r].object.visible||i)return n[r];return!1}TransformControls.prototype.isTransformControls=!0;const _tempEuler=new three.Euler,_alignVector=new three.Vector3(0,1,0),_zeroVector=new three.Vector3(0,0,0),_lookAtMatrix=new three.Matrix4,_tempQuaternion2=new three.Quaternion,_identityQuaternion=new three.Quaternion,_dirVector=new three.Vector3,_tempMatrix$1=new three.Matrix4,_unitX=new three.Vector3(1,0,0),_unitY=new three.Vector3(0,1,0),_unitZ=new three.Vector3(0,0,1),_v1=new three.Vector3,_v2=new three.Vector3,_v3=new three.Vector3;class TransformControlsGizmo extends three.Object3D{constructor(){super(),this.type="TransformControlsGizmo";const e=new three.MeshBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),t=new three.LineBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),i=e.clone();i.opacity=.15;const n=t.clone();n.opacity=.5;const r=e.clone();r.color.setHex(16711680);const s=e.clone();s.color.setHex(65280);const a=e.clone();a.color.setHex(255);const o=e.clone();o.color.setHex(16711680),o.opacity=.5;const l=e.clone();l.color.setHex(65280),l.opacity=.5;const c=e.clone();c.color.setHex(255),c.opacity=.5;const h=e.clone();h.opacity=.25;const u=e.clone();u.color.setHex(16776960),u.opacity=.25;e.clone().color.setHex(16776960);const d=e.clone();d.color.setHex(7895160);const p=new three.CylinderGeometry(0,.04,.1,12);p.translate(0,.05,0);const m=new three.BoxGeometry(.08,.08,.08);m.translate(0,.04,0);const f=new three.BufferGeometry;f.setAttribute("position",new three.Float32BufferAttribute([0,0,0,1,0,0],3));const g=new three.CylinderGeometry(.0075,.0075,.5,3);function _(e,t){const i=new three.TorusGeometry(e,.0075,3,64,t*Math.PI*2);return i.rotateY(Math.PI/2),i.rotateX(Math.PI/2),i}g.translate(0,.25,0);const A={X:[[new three.Mesh(p,r),[.5,0,0],[0,0,-Math.PI/2]],[new three.Mesh(p,r),[-.5,0,0],[0,0,Math.PI/2]],[new three.Mesh(g,r),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new three.Mesh(p,s),[0,.5,0]],[new three.Mesh(p,s),[0,-.5,0],[Math.PI,0,0]],[new three.Mesh(g,s)]],Z:[[new three.Mesh(p,a),[0,0,.5],[Math.PI/2,0,0]],[new three.Mesh(p,a),[0,0,-.5],[-Math.PI/2,0,0]],[new three.Mesh(g,a),null,[Math.PI/2,0,0]]],XYZ:[[new three.Mesh(new three.OctahedronGeometry(.1,0),h.clone()),[0,0,0]]],XY:[[new three.Mesh(new three.BoxGeometry(.15,.15,.01),c.clone()),[.15,.15,0]]],YZ:[[new three.Mesh(new three.BoxGeometry(.15,.15,.01),o.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new three.Mesh(new three.BoxGeometry(.15,.15,.01),l.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},v={X:[[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[.3,0,0],[0,0,-Math.PI/2]],[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[0,.3,0]],[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[0,-.3,0],[0,0,Math.PI]]],Z:[[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[0,0,.3],[Math.PI/2,0,0]],[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new three.Mesh(new three.OctahedronGeometry(.2,0),i)]],XY:[[new three.Mesh(new three.BoxGeometry(.2,.2,.01),i),[.15,.15,0]]],YZ:[[new three.Mesh(new three.BoxGeometry(.2,.2,.01),i),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new three.Mesh(new three.BoxGeometry(.2,.2,.01),i),[.15,0,.15],[-Math.PI/2,0,0]]]},y={START:[[new three.Mesh(new three.OctahedronGeometry(.01,2),n),null,null,null,"helper"]],END:[[new three.Mesh(new three.OctahedronGeometry(.01,2),n),null,null,null,"helper"]],DELTA:[[new three.Line(function(){const e=new three.BufferGeometry;return e.setAttribute("position",new three.Float32BufferAttribute([0,0,0,1,1,1],3)),e}(),n),null,null,null,"helper"]],X:[[new three.Line(f,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new three.Line(f,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new three.Line(f,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},x={XYZE:[[new three.Mesh(_(.5,1),d),null,[0,Math.PI/2,0]]],X:[[new three.Mesh(_(.5,.5),r)]],Y:[[new three.Mesh(_(.5,.5),s),null,[0,0,-Math.PI/2]]],Z:[[new three.Mesh(_(.5,.5),a),null,[0,Math.PI/2,0]]],E:[[new three.Mesh(_(.75,1),u),null,[0,Math.PI/2,0]]]},b={AXIS:[[new three.Line(f,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},S={XYZE:[[new three.Mesh(new three.SphereGeometry(.25,10,8),i)]],X:[[new three.Mesh(new three.TorusGeometry(.5,.1,4,24),i),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new three.Mesh(new three.TorusGeometry(.5,.1,4,24),i),[0,0,0],[Math.PI/2,0,0]]],Z:[[new three.Mesh(new three.TorusGeometry(.5,.1,4,24),i),[0,0,0],[0,0,-Math.PI/2]]],E:[[new three.Mesh(new three.TorusGeometry(.75,.1,2,24),i)]]},C={X:[[new three.Mesh(m,r),[.5,0,0],[0,0,-Math.PI/2]],[new three.Mesh(g,r),[0,0,0],[0,0,-Math.PI/2]],[new three.Mesh(m,r),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new three.Mesh(m,s),[0,.5,0]],[new three.Mesh(g,s)],[new three.Mesh(m,s),[0,-.5,0],[0,0,Math.PI]]],Z:[[new three.Mesh(m,a),[0,0,.5],[Math.PI/2,0,0]],[new three.Mesh(g,a),[0,0,0],[Math.PI/2,0,0]],[new three.Mesh(m,a),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new three.Mesh(new three.BoxGeometry(.15,.15,.01),c),[.15,.15,0]]],YZ:[[new three.Mesh(new three.BoxGeometry(.15,.15,.01),o),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new three.Mesh(new three.BoxGeometry(.15,.15,.01),l),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new three.Mesh(new three.BoxGeometry(.1,.1,.1),h.clone())]]},T={X:[[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[.3,0,0],[0,0,-Math.PI/2]],[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[0,.3,0]],[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[0,-.3,0],[0,0,Math.PI]]],Z:[[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[0,0,.3],[Math.PI/2,0,0]],[new three.Mesh(new three.CylinderGeometry(.2,0,.6,4),i),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new three.Mesh(new three.BoxGeometry(.2,.2,.01),i),[.15,.15,0]]],YZ:[[new three.Mesh(new three.BoxGeometry(.2,.2,.01),i),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new three.Mesh(new three.BoxGeometry(.2,.2,.01),i),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new three.Mesh(new three.BoxGeometry(.2,.2,.2),i),[0,0,0]]]},E={X:[[new three.Line(f,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new three.Line(f,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new three.Line(f,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function M(e){const t=new three.Object3D;for(const i in e)for(let n=e[i].length;n--;){const r=e[i][n][0].clone(),s=e[i][n][1],a=e[i][n][2],o=e[i][n][3],l=e[i][n][4];r.name=i,r.tag=l,s&&r.position.set(s[0],s[1],s[2]),a&&r.rotation.set(a[0],a[1],a[2]),o&&r.scale.set(o[0],o[1],o[2]),r.updateMatrix();const c=r.geometry.clone();c.applyMatrix4(r.matrix),r.geometry=c,r.renderOrder=1/0,r.position.set(0,0,0),r.rotation.set(0,0,0),r.scale.set(1,1,1),t.add(r)}return t}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=M(A)),this.add(this.gizmo.rotate=M(x)),this.add(this.gizmo.scale=M(C)),this.add(this.picker.translate=M(v)),this.add(this.picker.rotate=M(S)),this.add(this.picker.scale=M(T)),this.add(this.helper.translate=M(y)),this.add(this.helper.rotate=M(b)),this.add(this.helper.scale=M(E)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}onBeforeScenePrepareRender(){const e="local"===("scale"===this.mode?"local":this.space)?this.worldQuaternion:_identityQuaternion;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;let t=[];t=t.concat(this.picker[this.mode].children),t=t.concat(this.gizmo[this.mode].children),t=t.concat(this.helper[this.mode].children);for(let i=0;i<t.length;i++){const n=t[i];let r;if(n.visible=!0,n.rotation.set(0,0,0),n.position.copy(this.worldPosition),r=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),n.scale.set(1,1,1).multiplyScalar(r*this.size/4),"helper"!==n.tag){if(n.quaternion.copy(e),"translate"===this.mode||"scale"===this.mode){const t=.99,i=.2;"X"===n.name&&Math.abs(_alignVector.copy(_unitX).applyQuaternion(e).dot(this.eye))>t&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),"Y"===n.name&&Math.abs(_alignVector.copy(_unitY).applyQuaternion(e).dot(this.eye))>t&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),"Z"===n.name&&Math.abs(_alignVector.copy(_unitZ).applyQuaternion(e).dot(this.eye))>t&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),"XY"===n.name&&Math.abs(_alignVector.copy(_unitZ).applyQuaternion(e).dot(this.eye))<i&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),"YZ"===n.name&&Math.abs(_alignVector.copy(_unitX).applyQuaternion(e).dot(this.eye))<i&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1),"XZ"===n.name&&Math.abs(_alignVector.copy(_unitY).applyQuaternion(e).dot(this.eye))<i&&(n.scale.set(1e-10,1e-10,1e-10),n.visible=!1)}else"rotate"===this.mode&&(_tempQuaternion2.copy(e),_alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(e).invert()),-1!==n.name.search("E")&&n.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye,_zeroVector,_unitY)),"X"===n.name&&(_tempQuaternion.setFromAxisAngle(_unitX,Math.atan2(-_alignVector.y,_alignVector.z)),_tempQuaternion.multiplyQuaternions(_tempQuaternion2,_tempQuaternion),n.quaternion.copy(_tempQuaternion)),"Y"===n.name&&(_tempQuaternion.setFromAxisAngle(_unitY,Math.atan2(_alignVector.x,_alignVector.z)),_tempQuaternion.multiplyQuaternions(_tempQuaternion2,_tempQuaternion),n.quaternion.copy(_tempQuaternion)),"Z"===n.name&&(_tempQuaternion.setFromAxisAngle(_unitZ,Math.atan2(_alignVector.y,_alignVector.x)),_tempQuaternion.multiplyQuaternions(_tempQuaternion2,_tempQuaternion),n.quaternion.copy(_tempQuaternion)));n.visible=n.visible&&(-1===n.name.indexOf("X")||this.showX),n.visible=n.visible&&(-1===n.name.indexOf("Y")||this.showY),n.visible=n.visible&&(-1===n.name.indexOf("Z")||this.showZ),n.visible=n.visible&&(-1===n.name.indexOf("E")||this.showX&&this.showY&&this.showZ),n.material._color=n.material._color||n.material.color.clone(),n.material._opacity=n.material._opacity||n.material.opacity,n.material.color.copy(n.material._color),n.material.opacity=n.material._opacity,this.enabled&&this.axis&&(n.name===this.axis||this.axis.split("").some((function(e){return n.name===e})))&&(n.material.color.setHex(16776960),n.material.opacity=1)}else n.visible=!1,"AXIS"===n.name?(n.position.copy(this.worldPositionStart),n.visible=!!this.axis,"X"===this.axis&&(_tempQuaternion.setFromEuler(_tempEuler.set(0,0,0)),n.quaternion.copy(e).multiply(_tempQuaternion),Math.abs(_alignVector.copy(_unitX).applyQuaternion(e).dot(this.eye))>.9&&(n.visible=!1)),"Y"===this.axis&&(_tempQuaternion.setFromEuler(_tempEuler.set(0,0,Math.PI/2)),n.quaternion.copy(e).multiply(_tempQuaternion),Math.abs(_alignVector.copy(_unitY).applyQuaternion(e).dot(this.eye))>.9&&(n.visible=!1)),"Z"===this.axis&&(_tempQuaternion.setFromEuler(_tempEuler.set(0,Math.PI/2,0)),n.quaternion.copy(e).multiply(_tempQuaternion),Math.abs(_alignVector.copy(_unitZ).applyQuaternion(e).dot(this.eye))>.9&&(n.visible=!1)),"XYZE"===this.axis&&(_tempQuaternion.setFromEuler(_tempEuler.set(0,Math.PI/2,0)),_alignVector.copy(this.rotationAxis),n.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector,_alignVector,_unitY)),n.quaternion.multiply(_tempQuaternion),n.visible=this.dragging),"E"===this.axis&&(n.visible=!1)):"START"===n.name?(n.position.copy(this.worldPositionStart),n.visible=this.dragging):"END"===n.name?(n.position.copy(this.worldPosition),n.visible=this.dragging):"DELTA"===n.name?(n.position.copy(this.worldPositionStart),n.quaternion.copy(this.worldQuaternionStart),_tempVector.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),_tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()),n.scale.copy(_tempVector),n.visible=this.dragging):(n.quaternion.copy(e),this.dragging?n.position.copy(this.worldPositionStart):n.position.copy(this.worldPosition),this.axis&&(n.visible=-1!==this.axis.search(n.name)))}}}TransformControlsGizmo.prototype.isTransformControlsGizmo=!0;class TransformControlsPlane extends three.Mesh{constructor(){super(new three.PlaneGeometry(1e5,1e5,2,2),new three.MeshBasicMaterial({visible:!1,wireframe:!0,side:three.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane"}updateMatrixWorld(e){let t=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(t="local"),_v1.copy(_unitX).applyQuaternion("local"===t?this.worldQuaternion:_identityQuaternion),_v2.copy(_unitY).applyQuaternion("local"===t?this.worldQuaternion:_identityQuaternion),_v3.copy(_unitZ).applyQuaternion("local"===t?this.worldQuaternion:_identityQuaternion),_alignVector.copy(_v2),this.mode){case"translate":case"scale":switch(this.axis){case"X":_alignVector.copy(this.eye).cross(_v1),_dirVector.copy(_v1).cross(_alignVector);break;case"Y":_alignVector.copy(this.eye).cross(_v2),_dirVector.copy(_v2).cross(_alignVector);break;case"Z":_alignVector.copy(this.eye).cross(_v3),_dirVector.copy(_v3).cross(_alignVector);break;case"XY":_dirVector.copy(_v3);break;case"YZ":_dirVector.copy(_v1);break;case"XZ":_alignVector.copy(_v3),_dirVector.copy(_v2);break;case"XYZ":case"E":_dirVector.set(0,0,0)}break;default:_dirVector.set(0,0,0)}0===_dirVector.length()?this.quaternion.copy(this.cameraQuaternion):(_tempMatrix$1.lookAt(_tempVector.set(0,0,0),_dirVector,_alignVector),this.quaternion.setFromRotationMatrix(_tempMatrix$1)),super.updateMatrixWorld(e)}raycast(e,t){t.length||super.raycast(e,t)}}TransformControlsPlane.prototype.isTransformControlsPlane=!0;class TransformControl extends TransformControls{constructor(e){super(e.camera,e.map.container),__publicField(this,"_enableKeyboardEvent",!1),__publicField(this,"handleKeyboardEvent",(e=>{switch(e.keyCode){case 81:this.setSpace("local"===this.space?"world":"local");break;case 87:this.setMode("translate");break;case 69:this.setMode("rotate");break;case 82:this.setMode("scale");break;case 187:case 107:this.setSize(this.size+.1);break;case 189:case 109:this.setSize(Math.max(this.size-.1,.1));break;case 88:this.showX=!this.showX;break;case 89:this.showY=!this.showY;break;case 90:this.showZ=!this.showZ;break;case 32:this.enabled=!this.enabled;break;case 27:this.reset()}})),this.engine=e,this.addEventListener("change",(t=>{e.requestRender()})),this.addEventListener("objectChange",(t=>{e.requestRender()})),this.addEventListener("dragging-changed",(t=>{t.value?e.map.disableControl():e.map.enableControl()}))}dispose(){super.dispose(),this.enableKeyboardEvent=!1}set enableKeyboardEvent(e){e!==this._enableKeyboardEvent&&(this._enableKeyboardEvent=e,e?window.addEventListener("keydown",this.handleKeyboardEvent):window.removeEventListener("keydown",this.handleKeyboardEvent))}}class EngineSelection extends three.EventDispatcher{constructor(e,t={}){super(),__publicField(this,"_engine"),__publicField(this,"_boundingBoxHelper"),__publicField(this,"_selectedObject"),__publicField(this,"_transformControl"),this._engine=e}isSelected(e){return e===this._selectedObject}select(e){e.__engine_selected||(this._selectedObject&&(this._selectedObject.__engine_selected=!1),this._boundingBoxHelper||(this._boundingBoxHelper=new BoundingBoxHelper,this._engine.add(this._boundingBoxHelper)),this._boundingBoxHelper.attach(e),this._selectedObject=e,e.__engine_selected=!0,this._engine.requestRender())}deselect(e){this.isSelected(e)&&(this._boundingBoxHelper.detach(),this._selectedObject=null,e.__engine_selected=!1,this._engine.requestRender())}get transformControl(){return this._transformControl||(this._transformControl=new TransformControl(this._engine),this._transformControl.enableKeyboardEvent=!0),this._transformControl}attachTransform(e){const t=this._engine,i=this.transformControl;t.add(i),i.attach(e),i.updateMatrixWorld(),t.requestRender()}detachTransform(){const e=this._engine,t=this.transformControl;e.remove(t),t.detach()}dispose(){}}class BaseWidgets{constructor(e,t,i=null){__publicField(this,"_container"),__publicField(this,"_enabled"),__publicField(this,"_options",{}),__publicField(this,"_element"),__publicField(this,"_engine"),this._container=e,this._engine=i,t&&"object"==typeof t?(this._options=t,this._enabled=t.enabled):this._enabled=!1,this._element=null,this._enabled&&this.init()}init(){let e=this._element=this.createDom();this._container.appendChild(e),this.afterInit()}afterInit(){}createDom(){return null}dispose(){this._element&&(this.onDispose(),this._element.remove())}onDispose(){}get container(){return this._container}get element(){return this._element}get enabled(){return this._enabled}set enabled(e){const t=!!e;if(this._enabled!==t){const e=t?"visible":"hidden";this._element?(this._element.style.visibility=e,this.onDispose()):e&&this.init(),this._enabled=t}}}class Logo extends BaseWidgets{afterInit(){this._options&&this._options.url&&(this.url=this._options.url)}createDom(){return this._element=document.createElement("img"),addClass(this._element,"logo"),this._url=this._url||getAssetUrl("assets/images/bdImg.png"),this._element.src=this._url,this._element}set url(e){this._element&&(this._element.src=e),this._url=e}get url(){return this._url}}class Zoom extends BaseWidgets{createDom(){this.handleZoomIn=this.handleZoomIn.bind(this),this.handleZoomOut=this.handleZoomOut.bind(this),this._element=document.createElement("div"),addClass(this._element,"zoom");const e=this._zoomAdd=document.createElement("div");addClass(e,"zoom-add");const t=document.createElement("div");addClass(t,"zoom-add-tag"),t.setAttribute("style",`background-image: url(${getAssetUrl("assets/images/mapZoom2x.png")});`),e.addEventListener(EVENTS.DOWN,this.handleZoomIn),e.appendChild(t);const i=this._zoomSub=document.createElement("div");addClass(i,"zoom-sub");const n=document.createElement("div");return addClass(n,"zoom-sub-tag"),n.setAttribute("style",`background-image: url(${getAssetUrl("assets/images/mapZoom2x.png")});`),i.addEventListener(EVENTS.DOWN,this.handleZoomOut),i.appendChild(n),this._element.appendChild(e),this._element.appendChild(i),this._element}handleZoomIn(){this._engine.map.zoomIn()}handleZoomOut(){this._engine.map.zoomOut()}onDispose(){this._zoomAdd.removeEventListener(EVENTS.DOWN,this.handleZoomIn),this._zoomSub.removeEventListener(EVENTS.DOWN,this.handleZoomOut)}}class Scale extends BaseWidgets{createDom(){this._element=document.createElement("div"),addClass(this._element,"scale"),this._text=document.createElement("div"),addClass(this._text,"scale-text"),this._text.innerText="20km";const e=document.createElement("div");addClass(e,"scale-line");const t=document.createElement("div");addClass(t,"scale-line-mid");const i=document.createElement("div");addClass(i,"scale-line-left");const n=document.createElement("div");return addClass(n,"scale-line-right"),e.appendChild(t),e.appendChild(i),e.appendChild(n),this._element.appendChild(this._text),this._element.appendChild(e),this.calculateScale=this.calculateScale.bind(this),this._engine.rendering.addPrepareRenderListener(this.calculateScale),this._element}calculateScale(){const e=this._engine.map.getZoomUnitsByZoom(this._engine.map.getZoom());let t=0;const i=[.05,.1,.2];for(let n=0;n<3&&t<7;n++){const r=i[n]*Math.pow(10,t),s=r/e;if(s>=50&&s<=150){if(this._element.style.width=s+"px",t<1)this._text.innerText=(r<.1?5:100*r)+"cm";else if(t<2)this._text.innerText=(r<1?5:10*r)+"dm";else{const e=r/1e3,t=e<1;this._text.innerText=t?r+"m":e+"km"}break}n<1&&t<1&&s>150&&(this._element.style.width="150px",this._text.innerText="< 5cm"),n>1&&(t++,n=0)}}onDispose(){this._engine.rendering.removePrepareRenderListener(this.calculateScale)}}const full="M358.4 768H426.666667v85.333333H213.333333v-213.333333h85.333334v68.266667l128-128 59.733333 59.733333-128 128z m345.6 0l-128-128 59.733333-59.733333 132.266667 132.266666V640h85.333333v213.333333h-213.333333v-85.333333h64zM358.4 298.666667l128 128-59.733333 59.733333-128-128V426.666667H213.333333V213.333333h213.333334v85.333334H358.4z m345.6 0H640V213.333333h213.333333v213.333334h-85.333333V354.133333l-132.266667 132.266667-59.733333-59.733333 128-128z",exit="M298.666667 631.466667H226.133333v-81.066667h217.6v204.8h-85.333333v-68.266667l-128 128L170.666667 759.466667l128-128z m422.4 0l128 128-59.733334 59.733333-128-128v68.266667h-85.333333V554.666667h217.6v81.066666h-72.533333zM298.666667 341.333333L187.733333 230.4 243.2 170.666667l115.2 115.2V217.6h85.333333v204.8H226.133333V341.333333H298.666667z m430.933333 0h64v81.066667h-217.6V217.6h85.333333v72.533333L780.8 170.666667l59.733333 59.733333L729.6 341.333333z";class Fullscreen extends BaseWidgets{createDom(){this.handleClick=this.handleClick.bind(this),this.handleFullscreenChange=this.handleFullscreenChange.bind(this),this._element=document.createElement("div"),addClass(this._element,"fullscreen");const e=document.createElementNS("http://www.w3.org/2000/svg","svg");return e.setAttribute("class","widgets-group-svg fullscreen-svg"),e.setAttribute("viewBox","0 0 1024 1024"),e.setAttribute("version","1.1"),this._path=document.createElementNS("http://www.w3.org/2000/svg","path"),this._path.setAttribute("d",full),this._path.setAttribute("class","fullscreen-path"),e.appendChild(this._path),this._flag=!0,this._element.addEventListener(EVENTS.DOWN,this.handleClick),document.addEventListener("fullscreenchange",this.handleFullscreenChange),this._element.appendChild(e),this._element}handleClick(){const e=this._engine.container,t=e instanceof HTMLElement||e&&"object"==typeof e&&1===e.nodeType&&"string"==typeof e.nodeName?e:e.container||e._container;this._flag?t.requestFullscreen?t.requestFullscreen():t.msRequestFullscreen?t.msRequestFullscreen():t.mozRequestFullScreen?t.mozRequestFullScreen():t.webkitRequestFullScreen&&t.webkitRequestFullScreen():document.exitFullscreen?document.exitFullscreen():document.msExitFullscreen?document.msExitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitCancelFullScreen&&document.webkitCancelFullScreen()}handleFullscreenChange(){this._flag=!this._flag,this._flag?this._path.setAttribute("d",full):this._path.setAttribute("d",exit)}onDispose(){this._element.removeEventListener(EVENTS.DOWN,this.handleClick),document.removeEventListener("fullscreenchange",this.handleFullscreenChange)}}class GeoLocate extends BaseWidgets{createDom(){this.locate=this.locate.bind(this),this._element=document.createElement("div"),addClass(this._element,"geo-locate");const e=document.createElementNS("http://www.w3.org/2000/svg","svg");e.setAttribute("class","widgets-group-svg geo-locate-svg"),e.setAttribute("viewBox","0 0 1024 1024"),e.setAttribute("version","1.1");const t=document.createElementNS("http://www.w3.org/2000/svg","path");return t.setAttribute("d","M87.424 469.312A426.816 426.816 0 0 1 469.312 87.424V0h85.376v87.424a426.816 426.816 0 0 1 381.888 381.888H1024v85.376h-87.424a426.816 426.816 0 0 1-381.888 381.888V1024h-85.376v-87.424A426.816 426.816 0 0 1 87.424 554.688H0v-85.376h87.424z m424.576 384a341.312 341.312 0 1 0 0-682.624 341.312 341.312 0 0 0 0 682.624z m0-170.624a170.688 170.688 0 1 0 0-341.376 170.688 170.688 0 0 0 0 341.376z"),t.setAttribute("class","geo-locate-path"),e.appendChild(t),this._element.addEventListener(EVENTS.DOWN,this.locate),this._element.appendChild(e),this._element}locate(){window.navigator.geolocation.getCurrentPosition((e=>{var t;const{longitude:i,latitude:n}=null!=(t=e.coords)?t:{};isNaN(i)||isNaN(n)?console.error("定位出错，请重新定位！"):(this._engine.map.setCenter([i,n]),this._engine.map.setZoom(18))}),(e=>{console.error("定位未开启")}))}onDispose(){this._element.removeEventListener(EVENTS.DOWN,this.locate)}}class ExportImage extends BaseWidgets{constructor(){super(...arguments),__publicField(this,"screenshot",((e,t)=>{const i=this._engine.rendering.canvas,n=this._engine.map.mapType,r=document.createElement("canvas"),s=r.getContext("2d");if(r.width=i.width,r.height=i.height,"bmapgl"===n){const e=this._engine.container._webglPainter._canvas;s.drawImage(e,0,0,e.width,e.height)}else if("mapbox"===n){const e=this._engine.container._canvas;s.drawImage(e,0,0,e.width,e.height)}s.drawImage(i,0,0,i.width,i.height);let a=r.toDataURL();if(t){e=e||"download.png";const t=document.createElement("a");t.href=a,t.download=e,t.click()}return a}))}createDom(){this.handleClick=this.handleClick.bind(this),this._element=document.createElement("div"),addClass(this._element,"export-image");const e=document.createElementNS("http://www.w3.org/2000/svg","svg");e.setAttribute("class","widgets-group-svg export-image-svg"),e.setAttribute("viewBox","0 0 1024 1024"),e.setAttribute("version","1.1");const t=document.createElementNS("http://www.w3.org/2000/svg","path");return t.setAttribute("d","M867.90864 574.538232V257.779543a50.844091 50.844091 0 0 0-50.844092-50.844091h-610.129096a50.844091 50.844091 0 0 0-50.844092 50.844091v499.797418l430.141013-257.779543a152.532274 152.532274 0 0 1 157.108243 0z m0 118.466733l-177.445879-106.264151a50.844091 50.844091 0 0 0-50.844092 0L254.220457 817.064548h562.844091a50.844091 50.844091 0 0 0 50.844092-50.844091z m-660.973188-587.757696h610.129096a152.532274 152.532274 0 0 1 152.532274 152.532274v508.440914a152.532274 152.532274 0 0 1-152.532274 152.532274h-610.129096a152.532274 152.532274 0 0 1-152.532274-152.532274v-508.440914a152.532274 152.532274 0 0 1 152.532274-152.532274z m127.110228 355.90864a76.266137 76.266137 0 1 1 76.266137-76.266137 76.266137 76.266137 0 0 1-76.266137 76.266137z"),e.appendChild(t),this._element.addEventListener(EVENTS.DOWN,this.handleClick),this._element.appendChild(e),this._element}handleClick(){this.screenshot("download.png",!0)}onDispose(){this._element.removeEventListener(EVENTS.DOWN,this.handleClick)}}class MapInfo extends BaseWidgets{constructor(){super(...arguments),__publicField(this,"_mapInfo",{pitch:0,heading:0,zoom:0,range:0,center:[0,0],mousePoint:[0,0]}),__publicField(this,"_prefix",{M:"指针位置",C:"中心点",Z:"级别",H:"旋转角",P:"倾角",R:"视野距离"}),__publicField(this,"_separator"," | "),__publicField(this,"_template","CR")}afterInit(){this._options&&this._options.template&&(this.template=this._options.template),this._options&&this._options.prefix&&(this.prefix=this._options.prefix),this._options&&this._options.separator&&(this.separator=this._options.separator)}createDom(){return this._element=document.createElement("div"),addClass(this._element,"mouse-location"),this._enableMousePositionTracking=!1,this._eventName="pointerdown",this.eventCallback=this.update.bind(this),this._engine.map.addEventListener(this._eventName,this.eventCallback),this._viewChangedCallback=()=>{if(this._engine.rendering.renderState.viewChanged){const e=this._engine.map,t=e.getCenter();this._mapInfo.pitch=toFixed(e.getPitch()),this._mapInfo.heading=toFixed(e.getHeading()),this._mapInfo.zoom=toFixed(e.getZoom()),this._mapInfo.center=[t[0].toFixed(6),t[1].toFixed(6)],this._mapInfo.range=toFixed(e.getRange()),this.updateInfoText()}},this._engine.rendering.addPrepareRenderListener(this._viewChangedCallback),this._element}update(e){const t=e.point;t&&/M/gi.test(this._template)&&(this._mapInfo.mousePoint=[t[0].toFixed(6),t[1].toFixed(6)],this.updateInfoText())}updateInfoText(){const{center:e,heading:t,pitch:i,zoom:n,range:r,mousePoint:s}=this._mapInfo,a={M:s,C:e,Z:n,H:t,P:i,R:r},o=this.template.replace(/[MCZHPR]/gi,(e=>`${this.prefix[e.toUpperCase()]}: ${a[e.toUpperCase()]}${this.separator}`)).slice(0,-this.separator.length);this._element.innerText=o}get enableMousePositionTracking(){return this._enableMousePositionTracking}set enableMousePositionTracking(e){this._enableMousePositionTracking!==e&&(this._enableMousePositionTracking=e,this._engine.map.removeEventListener(this._eventName,this.eventCallback),this._eventName=e?"mousemove":"pointerdown",this._engine.map.addEventListener(this._eventName,this.eventCallback))}get template(){return this._template}set template(e){this._template=e,this.updateInfoText()}get separator(){return this._separator}set separator(e){this._separator=e,this.updateInfoText()}get prefix(){return this._prefix}set prefix(e){this._prefix=e,this.updateInfoText()}onDispose(){this._engine.map.removeEventListener(this._eventName,this.eventCallback),this._engine.rendering.removePrepareRenderListener(this._viewChangedCallback)}}function toFixed(e,t){if(!t)return Math.round(e);const i=10*t;return Math.round(e*i)/i}class Drawer extends BaseWidgets{afterInit(){if(this._options&&this._options.draws){const e=this._options.draws,t=e&&e.length>0?e.length:0,i=document.getElementById(`${CSS_NAMESPACE}-drawer-content`);if(this._drawerCheckboxs=[],t>0){const n=this.addChangeListener.bind(this);for(let r=0;r<t;r++){const t=e[r],s=document.createElement("div");addClass(s,"drawer-item");const a=document.createElement("input");addClass(a,"drawer-item-check"),n(a,(e=>{e.stopPropagation();const i=e.target.checked;t.onChange&&t.onChange(i,t.data,this._engine)})),a.setAttribute("type","checkbox"),t.defaultChecked&&(a.setAttribute("checked",t.defaultChecked),t.onChange&&t.onChange(!0,t.data,this._engine)),this._drawerCheckboxs.push(a);const o=document.createElement("span");addClass(o,"drawer-item-name"),o.innerText=t.name,o.onclick=()=>{a.click()},s.appendChild(a),s.appendChild(o),i.appendChild(s)}}}}createDom(){this._element=document.createElement("div"),addClass(this._element,"drawer");const e=this._drawerBtn=document.createElement("div");addClass(e,"drawer-btn");const t=document.createElementNS("http://www.w3.org/2000/svg","svg");t.setAttribute("class","drawer-icon"),t.setAttribute("viewBox","0 0 1024 1024"),t.setAttribute("version","1.1");const i=document.createElementNS("http://www.w3.org/2000/svg","path");i.setAttribute("d","M512 821.504l-416-208-96 48 512 256 512-256-96-48-416 208z m0-181.173333l-416-208-96 48 512 256 512-256-96-48-416 208zM1024 298.666667L512 42.666667 0 298.666667l512 256 512-256zM512 138.058667L833.184 298.666667 512 459.274667 190.816 298.666667 512 138.058667z"),t.appendChild(i),e.addEventListener(EVENTS.DOWN,this.openDrawer.bind(this)),e.appendChild(t);const n=this._drawerList=document.createElement("div");addClass(n,"drawer-list"),n.setAttribute("id",`${CSS_NAMESPACE}-drawer-list`),n.style.display="none";const r=document.createElement("div");addClass(r,"drawer-content"),r.setAttribute("id",`${CSS_NAMESPACE}-drawer-content`);const s=document.createElement("div");return addClass(s,"drawer-arrow"),n.appendChild(r),n.appendChild(s),this._element.appendChild(e),this._element.appendChild(n),this._element}addChangeListener(e,t){this._eventMap||(this._eventMap=new WeakMap),e.addEventListener("change",t),this._eventMap.set(e,t)}removeChangeListener(e){const t=this._eventMap.get(e);e.removeEventListener("change",t),this._eventMap.delete(e)}openDrawer(){const e=this._drawerList;e.style.display="none"===e.style.display?"block":"none"}onDispose(){this._drawerBtn.removeEventListener(EVENTS.DOWN,this.openDrawer.bind(this));for(let e=0;e<this._drawerCheckboxs.length;e++)this.removeChangeListener(this._drawerCheckboxs[e])}}class Compass extends BaseWidgets{createDom(){this.handleUpBtnClick=this.handleUpBtnClick.bind(this),this.handleDownBtnClick=this.handleDownBtnClick.bind(this),this.handleLeftBtnClick=this.handleLeftBtnClick.bind(this),this.handleRightBtnClick=this.handleRightBtnClick.bind(this),this.handleCenterBtnClick=this.handleCenterBtnClick.bind(this),this._element=document.createElement("div"),addClass(this._element,"compass"),this._element.setAttribute("style",`background-image: url(${getAssetUrl("assets/images/mapCompass.png")});`),this._up=document.createElementNS("http://www.w3.org/2000/svg","svg"),this._up.setAttribute("class","compass-up"),this._up.setAttribute("viewBox","0 0 1024 1024"),this._up.setAttribute("version","1.1");const e=document.createElementNS("http://www.w3.org/2000/svg","path");e.setAttribute("d","M910.222222 796.444444c-17.066667 0-34.133333-5.688889-45.511111-17.066666L551.822222 409.6c-11.377778-5.688889-17.066667-11.377778-34.133333-11.377778-5.688889 0-22.755556 5.688889-28.444445 11.377778l-329.955555 364.088889c-22.755556 22.755556-56.888889 22.755556-79.644445 5.688889-22.755556-22.755556-22.755556-56.888889-5.688888-79.644445l329.955555-364.088889c28.444444-34.133333 73.955556-51.2 119.466667-51.2s85.333333 22.755556 119.466666 56.888889l312.888889 364.088889c22.755556 22.755556 17.066667 56.888889-5.688889 79.644445-11.377778 5.688889-28.444444 11.377778-39.822222 11.377777z"),this._up.addEventListener(EVENTS.DOWN,this.handleUpBtnClick),this._up.appendChild(e),this._down=document.createElementNS("http://www.w3.org/2000/svg","svg"),this._down.setAttribute("class","compass-down"),this._down.setAttribute("viewBox","0 0 1024 1024"),this._down.setAttribute("version","1.1");const t=document.createElementNS("http://www.w3.org/2000/svg","path");return t.setAttribute("d","M517.688889 796.444444c-45.511111 0-85.333333-17.066667-119.466667-51.2L73.955556 381.155556c-22.755556-22.755556-17.066667-56.888889 5.688888-79.644445 22.755556-22.755556 56.888889-17.066667 79.644445 5.688889l329.955555 364.088889c5.688889 5.688889 17.066667 11.377778 28.444445 11.377778s22.755556-5.688889 34.133333-17.066667l312.888889-364.088889c22.755556-22.755556 56.888889-28.444444 79.644445-5.688889 22.755556 22.755556 28.444444 56.888889 5.688888 79.644445L637.155556 739.555556c-28.444444 39.822222-68.266667 56.888889-119.466667 56.888888 5.688889 0 0 0 0 0z"),this._down.addEventListener(EVENTS.DOWN,this.handleDownBtnClick),this._down.appendChild(t),this._left=document.createElement("div"),addClass(this._left,"compass-left"),this._left.setAttribute("style",`background-image: url(${getAssetUrl("assets/images/mapCompass.png")});`),this._left.addEventListener(EVENTS.DOWN,this.handleLeftBtnClick),this._right=document.createElement("div"),addClass(this._right,"compass-right"),this._right.setAttribute("style",`background-image: url(${getAssetUrl("assets/images/mapCompass.png")});`),this._right.addEventListener(EVENTS.DOWN,this.handleRightBtnClick),this._compass=document.createElement("div"),addClass(this._compass,"compass-center"),this._compass.setAttribute("style",`background-image: url(${getAssetUrl("assets/images/mapCompass.png")});`),this._compass.addEventListener(EVENTS.DOWN,this.handleCenterBtnClick),this._element.appendChild(this._up),this._element.appendChild(this._down),this._element.appendChild(this._left),this._element.appendChild(this._right),this._element.appendChild(this._compass),this._engine.rendering.addPrepareRenderListener((()=>{this._compass.style.transform=`rotate(-${this._engine.map.getHeading()}deg)`})),this._element}handleUpBtnClick(){const e=this._engine.map.getPitch();let t=e+2;t=t>89?89:t<0?0:t,e!==t&&this._engine.map.setPitch(t)}handleDownBtnClick(){const e=this._engine.map.getPitch();let t=e-2;t=t>89?89:t<0?0:t,e!==t&&this._engine.map.setPitch(t)}handleLeftBtnClick(){let e=this._engine.map.getHeading()-2;this._engine.map.setHeading((e+360)%360)}handleRightBtnClick(){let e=this._engine.map.getHeading()+2;this._engine.map.setHeading(e%360)}handleCenterBtnClick(){this._engine.map.setHeading(0)}onDispose(){this._up.removeEventListener(EVENTS.DOWN,this.handleUpBtnClick),this._down.removeEventListener(EVENTS.DOWN,this.handleDownBtnClick),this._left.removeEventListener(EVENTS.DOWN,this.handleLeftBtnClick),this._right.removeEventListener(EVENTS.DOWN,this.handleRightBtnClick),this._compass.removeEventListener(EVENTS.DOWN,this.handleCenterBtnClick)}}class EngineWidgets{constructor(e,t={}){__publicField(this,"_container"),__publicField(this,"_engine"),__publicField(this,"_logo"),__publicField(this,"_zoom"),__publicField(this,"_scale"),__publicField(this,"_fullscreen"),__publicField(this,"_geoLocate"),__publicField(this,"_exportImage"),__publicField(this,"_mapInfo"),__publicField(this,"_compass"),__publicField(this,"_drawer");const i=e.container,n=i instanceof HTMLElement||i&&"object"==typeof i&&1===i.nodeType&&"string"==typeof i.nodeName;this._container=n?i:i.container||i._container;const r=this._control=document.createElement("div");r.id=`${CSS_NAMESPACE}-widgets-${e.id}`,addClass(r,`${CSS_NAMESPACE}-widgets-pane`),this._container.appendChild(r);const s=document.createElement("div");addClass(s,"bottom-right-anchor"),this._zoom=new Zoom(s,t.zoom,e),this._compass=new Compass(s,t.compass,e),r.appendChild(s);const a=document.createElement("div");addClass(a,"bottom-left-anchor"),r.appendChild(a),this._fullscreen=new Fullscreen(a,t.fullscreen,e),this._exportImage=new ExportImage(a,t.exportImage,e),this._geoLocate=new GeoLocate(a,t.geoLocate,e),this._logo=new Logo(r,t.logo,e),this._scale=new Scale(r,t.scale,e),this._mapInfo=new MapInfo(r,t.mapInfo,e),this._drawer=new Drawer(r,t.drawer,e)}dispose(){this._logo.dispose(),this._zoom.dispose(),this._scale.dispose(),this._fullscreen.dispose(),this._geoLocate.dispose(),this._exportImage.dispose(),this._mapInfo.dispose(),this._compass.dispose(),this._drawer.dispose(),this._control.remove()}get container(){return this._container}get engine(){return this._engine}get compass(){return this._compass}get logo(){return this._logo}get zoom(){return this._zoom}get scale(){return this._scale}get fullscreen(){return this._fullscreen}get geoLocate(){return this._geoLocate}get exportImage(){return this._exportImage}get mapInfo(){return this._mapInfo}get drawer(){return this._drawer}}const _EngineClock=class{constructor(e={}){this._timeZoneOffset=void 0!==e.timeZoneOffset?e.timeZoneOffset:8;const t=this._tzMs=3600*this._timeZoneOffset*1e3;let i=0,n=0,r=0;if(e.currentTime)i=e.currentTime.getTime()-t;else{const e=new Date;e.setHours(10,0,0,0),i=e.getTime()-t}n=e.startTime?e.startTime.getTime()-t:i,r=e.stopTime?e.stopTime.getTime()-t:i,this._currentTimeUTC=new Date(i),this._startMs=n,this._stopMs=r,this._currentTime=new Date(this._currentTimeUTC.getTime()+t),this._speed=e.speed||1,this._tickMode=void 0!==e.tickMode?e.tickMode:_EngineClock.TICK_NONE}tick(e){if(this._tickMode===_EngineClock.TICK_NONE)return;const t=e*this.speed;let i=this._currentTimeUTC.getTime()+t;if(this._tickMode===_EngineClock.TICK_CLAMP)i<this._startMs&&(i=this._startMs),i>this._stopMs&&(i=this._stopMs);else if(this._tickMode===_EngineClock.TICK_LOOP){const e=this._stopMs-this._startMs,t=(i-this._startMs)%e;i=this._startMs+t}this._setTimeValueUTC(i)}_setTimeLegacy(e){const t=Math.floor(e/3600),i=Math.floor(e%3600/60),n=e%60,r=this._currentTime;r.setHours(t,i,n,0),this._setTimeValue(r.getTime())}_setTimeValue(e){this._currentTimeUTC.setTime(e-this._tzMs),this._currentTime.setTime(e)}_setTimeValueUTC(e){this._currentTimeUTC.setTime(e),this._currentTime.setTime(e+this._tzMs)}reset(){this._setTimeValue(this._startMs)}get currentTime(){return this._currentTime}set currentTime(e){this._setTimeValue(e.getTime())}get currentTimeUTC(){return this._currentTimeUTC}set currentTimeUTC(e){this._setTimeValueUTC(e.getTime())}get startTime(){return new Date(this._startMs+this._tzMs)}set startTime(e){this._startMs=e.getTime()-this._tzMs}get stopTime(){return new Date(this._stopMs+this._tzMs)}set stopTime(e){this._stopMs=e.getTime()-this._tzMs}set timeZoneOffset(e){this._timeZoneOffset=e,this._tzMs=3600*e*1e3,this._currentTime.setTime(this._currentTimeUTC.getTime()+this._tzMs)}get timeZoneOffset(){return this._timeZoneOffset}get speed(){return this._speed}set speed(e){this._speed=e}get tickMode(){return this._tickMode}set tickMode(e){this._tickMode=e}};let EngineClock=_EngineClock;__publicField(EngineClock,"TICK_NONE",0),__publicField(EngineClock,"TICK_NORMAL",1),__publicField(EngineClock,"TICK_LOOP",2),__publicField(EngineClock,"TICK_CLAMP",3);class EngineController{constructor(e,t={}){__publicField(this,"_engine"),__publicField(this,"_enabled",!0),__publicField(this,"_enableRotate",!0),__publicField(this,"_enableZoom",!0),__publicField(this,"_enablePan",!0),__publicField(this,"_enableTilt",!0),__publicField(this,"_enableFixCenter",!1),__publicField(this,"_enableTerrainCollision",!1),__publicField(this,"_inertiaDragging",.9),__publicField(this,"_inertiaZoom",.8),__publicField(this,"_maximumMovementRatio",.1),__publicField(this,"_bounceAnimationTime",3),__publicField(this,"_minimumZoomDistance",1),__publicField(this,"_maximumZoomDistance",Number.POSITIVE_INFINITY),this._engine=e,this.enabled=defaultValue$1(t.enabled,!0),this.enableRotate=defaultValue$1(t.enableRotate,!0),this.enableZoom=defaultValue$1(t.enableZoom,!0),this.enablePan=defaultValue$1(t.enablePan,!0),this.enableTilt=defaultValue$1(t.enableTilt,!0),this.enableFixCenter=defaultValue$1(t.enableFixCenter,!1),this.enableTerrainCollision=defaultValue$1(t.enableTerrainCollision,!1),this.inertiaTranslate=defaultValue$1(t.inertiaTranslate,.9),this.inertiaZoom=defaultValue$1(t.inertiaZoom,.8),this.maximumMovementRatio=defaultValue$1(t.maximumMovementRatio,.1),this.bounceAnimationTime=defaultValue$1(t.bounceAnimationTime,3),this.minimumZoomDistance=defaultValue$1(t.minimumZoomDistance,1),this.maximumZoomDistance=defaultValue$1(t.maximumZoomDistance,Number.POSITIVE_INFINITY)}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._engine.map._map.controller.enabled=e}get enableRotate(){return this._enableRotate}set enableRotate(e){this._enableRotate=e,this._engine.map._map.controller.enableRotate=e}get enableZoom(){return this._enableZoom}set enableZoom(e){this._enableZoom=e,this._engine.map._map.controller.enableZoom=e}get enablePan(){return this._enablePan}set enablePan(e){this._enablePan=e,this._engine.map._map.controller.enablePan=e}get enableTilt(){return this._enableTilt}set enableTilt(e){this._enableTilt=e,this._engine.map._map.controller.enableTilt=e}get enableFixCenter(){return this._enableFixCenter}set enableFixCenter(e){this._enableFixCenter=e}get enableTerrainCollision(){return this._enableTerrainCollision}set enableTerrainCollision(e){this._enableTerrainCollision=e}get inertiaDragging(){return this._inertiaDragging}set inertiaDragging(e){this._inertiaDragging=e,this._engine.map._map.controller.inertiaDragging=e}get inertiaZoom(){return this._inertiaZoom}set inertiaZoom(e){this._inertiaZoom=e,this._engine.map._map.controller.inertiaZoom=e}get maximumMovementRatio(){return this._maximumMovementRatio}set maximumMovementRatio(e){this._maximumMovementRatio=e}get bounceAnimationTime(){return this._bounceAnimationTime}set bounceAnimationTime(e){this._bounceAnimationTime=e}get minimumZoomDistance(){return this._minimumZoomDistance}set minimumZoomDistance(e){this._minimumZoomDistance=e}get maximumZoomDistance(){return this._maximumZoomDistance}set maximumZoomDistance(e){this._maximumZoomDistance=e}}overrideShaders();let _globalId=0;class Engine{constructor(e,t={}){if(__publicField(this,"_container"),__publicField(this,"_event"),__publicField(this,"_map"),__publicField(this,"_rendering"),__publicField(this,"_selection"),__publicField(this,"_widgets"),__publicField(this,"_clock"),__publicField(this,"_controller"),__publicField(this,"isEngine",!0),this._id=++_globalId,"string"==typeof e||e instanceof String)this._container=document.getElementById(e);else{if(!(e instanceof HTMLElement))throw new Error("container is not a valid container");this._container=e}const i=window.getComputedStyle(this._container).position;"static"!==i&&i||(this._container.style.position="relative"),this._clock=new EngineClock(t.clock),this._event=new EngineEvent(this,t.event),this._map=new EngineMap(this,t.map),this._map.init();const n=this.map.getResolution();this._rendering=new EngineRendering(this,{resolution:n,...t.rendering}),this._rendering.init(),this._map.afterInit(),this._controller=new EngineController(this,t.controller),this._rendering.startRenderLoop(),this._selection=new EngineSelection(this,t.selection),this._widgets=new EngineWidgets(this,t.widgets),this.trackingRequest()}add(e){return this._rendering.add(e)}remove(e){this._rendering.remove(e)}requestRender(){this._rendering.requestRender()}addPrepareRenderListener(e){this._rendering.addPrepareRenderListener(e)}addBeforeRenderListener(e){this._rendering.addBeforeRenderListener(e)}removeBeforeRenderListener(e){this._rendering.removeBeforeRenderListener(e)}removePrepareRenderListener(e){this._rendering.removePrepareRenderListener(e)}addBeforePrepareRenderObject(e){this._rendering.addBeforePrepareRenderObject(e)}removeBeforePrepareRenderObject(e){this._rendering.removeBeforePrepareRenderObject(e)}addBeforeRenderObject(e){this._rendering.addBeforeRenderObject(e)}removeBeforeRenderObject(e){this._rendering.removeBeforeRenderObject(e)}lockCamera(){this.camera._isLocked=!0}unlockCamera(){this.camera._isLocked=!1}async renderVideo(e){await this._rendering.renderVideo(e)}get container(){return this._container}get map(){return this._map}get rendering(){return this._rendering}get widgets(){return this._widgets}get renderer(){return this._rendering.renderer}get scene(){return this._rendering.scene}get camera(){return this._rendering.camera}get event(){return this._event}get selection(){return this._selection}get clock(){return this._clock}get controller(){return this._controller}get id(){return this._id}dispose(){this._widgets.dispose(),this._event.dispose(),this._selection.dispose(),this._rendering.dispose(),this._map.dispose()}trackingRequest(){var e,t;null==(t=null==(e=this._map._map)?void 0:e.map)||t._printLog("mapvthree")}}class SkyAtmosphere extends three.Mesh{constructor(){super(),__publicField(this,"_fsQuad"),__publicField(this,"_hasPaintedScatterBuffer"),__publicField(this,"_scatteringMaterial"),__publicField(this,"_scatteringRenderTarget"),__publicField(this,"_transmittanceMaterial"),__publicField(this,"_transmittanceRenderTarget"),__publicField(this,"_viewMaterial"),__publicField(this,"_viewRenderTarget"),this.geometry=new three.SphereGeometry(1,32,32),this.frustumCulled=!1;const e=[256,64],t=[32,32],i=[400,400],n=this._transmittanceRenderTarget=new three.WebGLRenderTarget(e[0],e[1],{type:three.HalfFloatType,depthBuffer:!1});n.texture.name="SkyAtmosphere.transmittance",this._transmittanceMaterial=new three.ShaderMaterial({uniforms:three.UniformsUtils.clone(SkyAtmosphereTransmittanceShader.uniforms),vertexShader:SkyAtmosphereTransmittanceShader.vertexShader,fragmentShader:SkyAtmosphereTransmittanceShader.fragmentShader});const r=this._scatteringRenderTarget=new three.WebGLRenderTarget(t[0],t[1],{type:three.HalfFloatType,depthBuffer:!1});r.texture.name="SkyAtmosphere.scattering",this._scatteringMaterial=new three.ShaderMaterial({uniforms:three.UniformsUtils.clone(SkyAtmosphereScatteringShader.uniforms),vertexShader:SkyAtmosphereScatteringShader.vertexShader,fragmentShader:SkyAtmosphereScatteringShader.fragmentShader}),this._scatteringMaterial.uniforms.transmittanceTexture.value=n.texture,this._scatteringMaterial.uniforms.transmittanceResolution.value=[e[0],e[1]],this._fsQuad=new FullScreenQuad(null);const s=this._viewRenderTarget=new three.WebGLRenderTarget(i[0],i[1],{type:three.HalfFloatType,depthBuffer:!1});s.texture.name="SkyAtmosphere.view";const a=this._viewMaterial=new three.ShaderMaterial({uniforms:three.UniformsUtils.clone(SkyAtmosphereViewShader.uniforms),vertexShader:SkyAtmosphereViewShader.vertexShader,fragmentShader:SkyAtmosphereViewShader.fragmentShader});a.uniforms.transmittanceTexture.value=n.texture,a.uniforms.transmittanceResolution.value=[e[0],e[1]],a.uniforms.scatteringTexture.value=r.texture,a.uniforms.scatteringResolution.value=[t[0],t[1]];const o=this.material=new three.ShaderMaterial({uniforms:three.UniformsUtils.clone(SkyAtmosphereShader.uniforms),vertexShader:SkyAtmosphereShader.vertexShader,fragmentShader:SkyAtmosphereShader.fragmentShader,side:three.DoubleSide});o.uniforms.transmittanceTexture.value=n.texture,o.uniforms.transmittanceResolution.value=[e[0],e[1]],o.uniforms.scatteringTexture.value=r.texture,o.uniforms.scatteringResolution.value=[t[0],t[1]],o.uniforms.viewTexture.value=s.texture,o.uniforms.viewResolution.value=[i[0],i[1]],Object.defineProperties(this.material,{isEmissive:{get:function(){return this.uniforms.isEmissive.value},set:function(e){this.uniforms.isEmissive.value=e}},uTime:{get:function(){return this.uniforms.uTime.value},set:function(e){this.uniforms.uTime.value=e}},uStarVisible:{get:function(){return this.uniforms.uStarVisible.value},set:function(e){this.uniforms.uStarVisible.value=e}},uMoonMap:{get:function(){return this.uniforms.uMoonMap.value},set:function(e){this.uniforms.uMoonMap.value=e}}}),this._fsQuad=new FullScreenQuad(null),this.scale.multiplyScalar(1e4),this.altitude=0}onBeforeRender(e,t,i){}updateRenderTargets(e,t){const i=this._fsQuad;this._hasPaintedScatterBuffer||(i.material=this._transmittanceMaterial,e.setRenderTarget(this._transmittanceRenderTarget),e.clear(),i.render(e),i.material=this._scatteringMaterial,e.setRenderTarget(this._scatteringRenderTarget),e.clear(),i.render(e),this._hasPaintedScatterBuffer=!0),i.material=this._viewMaterial,e.setRenderTarget(this._viewRenderTarget),e.clear(),i.render(e),e.setRenderTarget(null)}dispose(){this.geometry.dispose(),this._transmittanceRenderTarget.dispose(),this._scatteringRenderTarget.dispose(),this._viewRenderTarget.dispose(),this._transmittanceMaterial.dispose(),this._scatteringMaterial.dispose(),this._viewMaterial.dispose(),this.material.dispose(),this._fsQuad.dispose()}get altitude(){return this.material.uniforms.altitude.value}set altitude(e){this._transmittanceMaterial.uniforms.altitude.value=e,this._scatteringMaterial.uniforms.altitude.value=e,this._viewMaterial.uniforms.altitude.value=e,this.material.uniforms.altitude.value=e}get viewHeight(){return this.material.uniforms.viewHeight.value}set viewHeight(e){this._transmittanceMaterial.uniforms.viewHeight.value=e,this._scatteringMaterial.uniforms.viewHeight.value=e,this._viewMaterial.uniforms.viewHeight.value=e,this.material.uniforms.viewHeight.value=e}get mixGrayFactor(){return this._viewMaterial.uniforms.mixGrayFactor.value}set mixGrayFactor(e){this._viewMaterial.uniforms.mixGrayFactor.value=e}}const _vector3$3=new three.Vector3,_up=new three.Vector3(0,0,1);class SkyAtmospherePass extends Pass$1{constructor(){super(),this.uniforms=three.UniformsUtils.clone(SkyAtmospherePostprocessingShader.uniforms),this.material=new three.ShaderMaterial({defines:{MVT_USE_NORMAL_TEXTURE:!1},uniforms:this.uniforms,vertexShader:CopyShader.vertexShader,fragmentShader:SkyAtmospherePostprocessingShader.fragmentShader,depthTest:!1,depthWrite:!1,name:"SkyAtmospherePass"}),this.needsSwap=!0,this.fsQuad=new FullScreenQuad(null),this.needsDepthTexture=!0,this.needsNormalTextureWhenMRT=!0}_consoleIfBigDiff(e,t,i){const n=e.pitch,r=e.roll,s=e.heading;this[t]&&(Math.abs(n-this[t].pitch),Math.abs(r-this[t].roll),Math.abs(s-this[t].heading)),this[t]={pitch:n,roll:r,heading:s}}render(e,t,i){const n=this.sky;if(!n)return;const r=this.rendering,s=r.camera,a=n.skyAtmosphere,o=this.uniforms;o.altitude.value=a.altitude,o.tDiffuse.value=i.texture,o.tDepth.value=r.main.sceneRendering.depthTexture,o.tAtmosphere.value=a.material.uniforms.viewTexture.value,o.isGlobe.value=a.material.uniforms.isGlobe.value,o.projectionInverseMatrix.value.copy(s.projectionMatrixInverse),o.viewInverseMatrix.value.copy(s.matrixWorld),o.cameraNear.value=s.near,o.cameraFar.value=s.far,o.cameraPosition.value.copy(s.position),o.viewHeight.value=a.material.uniforms.viewHeight.value,o.transmittanceTexture.value=a.material.uniforms.transmittanceTexture.value,o.transmittanceResolution.value=a.material.uniforms.transmittanceResolution.value,o.scatteringTexture.value=a.material.uniforms.scatteringTexture.value,o.scatteringResolution.value=a.material.uniforms.scatteringResolution.value,o.viewTexture.value=a.material.uniforms.viewTexture.value,o.viewResolution.value=a.material.uniforms.viewResolution.value,o.mvt_viewMatrix.value.copy(s.matrixWorldInverse),o.resolution=r.uniforms.resolution,o.sunDirection.value.copy(n.localSunDirection);const l=r.main.sceneRendering.normalTexture;o.tNormal.value=l;const c=!!l;c!==this.material.defines.MVT_USE_NORMAL_TEXTURE&&(this.material.defines.MVT_USE_NORMAL_TEXTURE=c,this.material.needsUpdate=!0);let h=0,u=1;if("earth"===r._engine.map.mapType){let e=r._engine.map._map._ellipsoidCamera;if(e.positionCartographic.z,!this._sphereCamera){const e=new Ellipsoid(6371e3,6371e3,6371e3);this._sphereCamera=new EllipsoidCamera({_ellipsoid:e,mapProjection:new GeographicProjection(e),camera:s})}const t=this._sphereCamera;t.position.copy(e.position),t.direction.copy(e.direction),t.up.copy(e.up),t.right.copy(e.right),a._transformChanged=!0,e=t,o.viewInverseMatrix.value.copy(e.getLocalTransform());const i=o.viewInverseMatrix.value.elements;_vector3$3.set(i[8],i[9],i[10]);const n=three.MathUtils.clamp(_vector3$3.dot(_up),.1,1),l=1e6*o.viewHeight.value/n,c=three.MathUtils.mapLinear(Math.sqrt(10*o.viewHeight.value),0,1,20,2),d=Math.max(l+100,l*c);h=r.renderState.getDepthByDistance(l),u=r.renderState.getDepthByDistance(d)}o.fogDepthRange.value.set(h,u);const d=e.autoClear,p=e.getRenderTarget();e.autoClear=!1,this.fsQuad.material=this.material,e.setRenderTarget(this.renderToScreen?null:t),e.clear(!0,!1,!1),this.fsQuad.render(e),e.autoClear=d,e.setRenderTarget(p)}getCurrentUsedTextures(){const e=[];return this.sky&&this.sky._precomputedTexturesGenerator&&(e.push(this.sky._precomputedTexturesGenerator.textures.transmittanceTexture),e.push(this.sky._precomputedTexturesGenerator.textures.irradianceTexture)),e}dispose(){this.material.dispose(),this.fsQuad.dispose()}}const commonFragShader='#define GLSLIFY 1\n// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n// 1 unit correspondents to SCENE_SCALE meter.\n\n#define SCENE_SCALE (1.)\n#define INV_SCENE_SCALE (1.)\n\n// #define MOUNTAIN_HEIGHT (5000.)\n// #define MOUNTAIN_HW_RATIO (0.00016)\n\n// #define SUN_DIR normalize(vec3(-.1,.4,.15))\n// #define SUN_COLOR (vec3(1.,.9,.85)*1.4)\n\n#define FLAG_POSITION (vec3(3900.5,720.,-2516.)*INV_SCENE_SCALE)\n#define HUMANOID_SCALE (2.)\n\n// #define CAMERA_RO (vec3(3980.,730.,-2650.)*INV_SCENE_SCALE)\n// #define CAMERA_FL 2.\n\n#define HEIGHT_BASED_FOG_B 0.02\n#define HEIGHT_BASED_FOG_C 0.05\n\n// mat3 getCamera( in float time, in vec4 mouse, inout vec3 ro, inout vec3 ta ) {\n//     ro = CAMERA_RO;\n//     vec3 cw;\n//     if (mouse.z > 0.) {\n//         vec2 m = (mouse.xy - .5) * 2.3;\n//         float my = -sin(m.y);\n//         cw = normalize(vec3(-sin(-m.x), my+.15, cos(-m.x)));\n//     } else {\n//     \tro.x += -cos(time*.13)*5.*INV_SCENE_SCALE;\n//     \tro.z += (-cos(time*.1)*100.+20.)*INV_SCENE_SCALE;\n//     \tcw = normalize(vec3(-.1,.18,1.));\n//     }   \n//     ta = ro + cw*(200.*INV_SCENE_SCALE);\n// \tvec3 cp = vec3(0.0,1.0, 0.0);\n// \tvec3 cu = normalize( cross(cw,cp) );\n// \tvec3 cv = normalize( cross(cu,cw) );\n//     return mat3( cu, cv, cw );\n// }\n\n// void getRay( in float time, in vec2 fragCoord, in vec2 resolution, in vec4 mouse, inout vec3 ro, inout vec3 rd) {\n// \tvec3 ta;\n// \tmat3 cam = getCamera( time, mouse, ro, ta );\n//     vec2 p = (-resolution.xy + 2.0*(fragCoord))/resolution.y;\n//     rd = cam * normalize(vec3(p,CAMERA_FL));     \n// }\n\n//\n// To reduce noise I use temporal reprojection (both for clouds (Buffer D) and the terrain \n// (Buffer C) seperatly. The temporal repojection code is based on code from the shader\n// "Rain Forest" (again by Íñigo Quílez):\n//\n// https://www.shadertoy.com/view/4ttSWf\n// \n// vec4 saveCamera( in float time, in vec2 fragCoord, in vec4 mouse ) {   \n//     vec3 ro, ta;\n//     mat3 cam = getCamera( time, mouse, ro, ta );\n//     vec4 fragColor;\n    \n//     if( abs(fragCoord.x-4.5)<0.5 ) fragColor = vec4( cam[2], -dot(cam[2],ro) );\n//     if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( cam[1], -dot(cam[1],ro) );\n//     if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( cam[0], -dot(cam[0],ro) );\n    \n//     return fragColor;\n// }\n\n// vec2 reprojectPos( in vec3 pos, in vec2 resolution, in sampler2D storage ) {\n//     mat4 oldCam = mat4( texelFetch(storage,ivec2(2,0),0),\n//                         texelFetch(storage,ivec2(3,0),0),\n//                         texelFetch(storage,ivec2(4,0),0),\n//                         0.0, 0.0, 0.0, 1.0 );\n\n//     vec4 wpos = vec4(pos,1.0);\n//     vec3 cpos = (wpos*oldCam).xyz; \n//     vec2 npos = CAMERA_FL * cpos.xy / cpos.z;\n//     return 0.5 + 0.5*npos*vec2(resolution.y/resolution.x,1.0);\n// }\n\n//\n// Fast skycolor function by Íñigo Quílez\n// https://www.shadertoy.com/view/MdX3Rr\n//\n// vec3 getSkyColor(vec3 rd) {\n//     float sundot = clamp(dot(rd,SUN_DIR),0.0,1.0);\n// \tvec3 col = vec3(0.2,0.5,0.85)*1.1 - max(rd.y,0.01)*max(rd.y,0.01)*0.5;\n//     col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow(1.0-max(rd.y,0.0), 6.0) );\n\n//     col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n//     col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n//     col += 0.20*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    \n//     col += clamp((0.1-rd.y)*10., 0., 1.) * vec3(.0,.1,.2);\n//     col += 0.2*vec3(1.0,0.8,0.6)*pow( sundot, 8.0 );\n//     return col;\n// }\n\n// bool letterBox(vec2 fragCoord, const vec2 resolution, const float aspect) { \n//     if( fragCoord.x < 0. || fragCoord.x > resolution.x ||\n//         abs(2.*fragCoord.y-resolution.y) > resolution.x * (1./aspect) ) {\n//         return true;\n//     } else {\n//         return false;\n//     }\n// }\n\n//\n// Noise functions\n//\n// Hash without Sine by DaveHoskins \n//\n// https://www.shadertoy.com/view/4djSRW\n//\nfloat hash12( vec2 p ) {\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash13(vec3 p3) {\n    p3  = fract(p3 * 1031.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat valueHash(vec3 p3) {\n    p3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//\n// Noise functions used for cloud shapes\n//\nfloat valueNoise( in vec3 x, float tile ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( valueHash(mod(p+vec3(0,0,0),tile)), \n                        valueHash(mod(p+vec3(1,0,0),tile)),f.x),\n                   mix( valueHash(mod(p+vec3(0,1,0),tile)), \n                        valueHash(mod(p+vec3(1,1,0),tile)),f.x),f.y),\n               mix(mix( valueHash(mod(p+vec3(0,0,1),tile)), \n                        valueHash(mod(p+vec3(1,0,1),tile)),f.x),\n                   mix( valueHash(mod(p+vec3(0,1,1),tile)), \n                        valueHash(mod(p+vec3(1,1,1),tile)),f.x),f.y),f.z);\n}\n\nfloat voronoi( vec3 x, float tile ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float res = 100.;\n    for(int k=-1; k<=1; k++){\n        for(int j=-1; j<=1; j++) {\n            for(int i=-1; i<=1; i++) {\n                vec3 b = vec3(i, j, k);\n                vec3 c = p + b;\n\n                if( tile > 0. ) {\n                    c = mod( c, vec3(tile) );\n                }\n\n                vec3 r = vec3(b) - f + hash13( c );\n                float d = dot(r, r);\n\n                if(d < res) {\n                    res = d;\n                }\n            }\n        }\n    }\n\n    return 1.-res;\n}\n\nfloat tilableVoronoi( vec3 p, const int octaves, float tile ) {\n    float f = 1.;\n    float a = 1.;\n    float c = 0.;\n    float w = 0.;\n\n    if( tile > 0. ) f = tile;\n\n    for (int i = 0; i < 100; i++) {\n        if (i >= octaves) break;\n        c += a*voronoi( p * f, f );\n        f *= 2.0;\n        w += a;\n        a *= 0.5;\n    }\n\n    return c / w;\n}\n\nfloat tilableFbm( vec3 p, const int octaves, float tile ) {\n    float f = 1.;\n    float a = 1.;\n    float c = 0.;\n    float w = 0.;\n\n    if( tile > 0. ) f = tile;\n\n    for (int i = 0; i < 100; i++) {\n        if (i >= octaves) break;\n        c += a*valueNoise( p * f, f );\n        f *= 2.0;\n        w += a;\n        a *= 0.5;\n    }\n\n    return c / w;\n}\n\n',mainVertShader="#define GLSLIFY 1\nvarying vec3 vWorldPosition;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    vWorldPosition = normalize(vec3(position.x, position.y, position.z));\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    // gl_Position.z = gl_Position.w;\n}\n",mainFragShader='#define GLSLIFY 1\n// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n// I started this shader by trying to implement the clouds of Horizon Zero Dawn, as\n// described in "The real-time volumetric cloudscapes of Horizon Zero Dawn" by \n// Andrew Schneider and Nathan Vos.[1] To model the shape of the clouds, two look-up\n// textures are created with different frequencies of (Perlin -) Worley noise:\n//\n// Buffer A: The main look-up texture for the cloud shapes. \n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\n//           \n// Because it is not possible (yet) to create buffers with fixed size, or 3D buffers, the\n// look-up texture in Buffer A is 2D, and a slice of the volume that is described in the \n// article. Therefore, and because I didn\'t have any slots left (in Buffer C) to use a \n// cloud type/cloud coverage texture, the modelling of the cloud shapes in this shader is \n// in the end mostly based on trial and error, and is probably far from the code used in \n// Horizon Zero Dawn.\n//\n// Buffer D: Rendering of the clouds.\n//\n// I render the clouds using the improved integration method of volumetric media, as described \n// in "Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite" by \n// Sébastien Hillaire.[2]\n//\n// You can find the (excellent) example shaders of Sébastien Hillaire (SebH) here:\n//\n// https://www.shadertoy.com/view/XlBSRz\n// https://www.shadertoy.com/view/MdlyDs\n//\n// #define MVT_CLOUD_MARCH_STEPS 8\n// #define MVT_CLOUD_SELF_SHADOW_STEPS 3\n\n#define EARTH_RADIUS    (637100.) // (6371000.)\n#define CLOUDS_BOTTOM   (1350.)\n#define CLOUDS_TOP      (2350.)\n\n#define CLOUDS_LAYER_BOTTOM   (-150.)\n#define CLOUDS_LAYER_TOP      (-70.)\n\n#define CLOUDS_LAYER_COVERAGE (.41)\n\n#define CLOUDS_DETAIL_STRENGTH (.225)\n#define CLOUDS_BASE_EDGE_SOFTNESS (.1)\n#define CLOUDS_BOTTOM_SOFTNESS (.25)\n#define CLOUDS_SHADOW_MARGE_STEP_SIZE (10.)\n#define CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE (4.)\n#define CLOUDS_SHADOW_MARGE_STEP_MULTIPLY (1.3)\n#define CLOUDS_FORWARD_SCATTERING_G (.8)\n#define CLOUDS_BACKWARD_SCATTERING_G (-.2)\n#define CLOUDS_SCATTERING_LERP (.5)\n\n#define CLOUDS_AMBIENT_COLOR_TOP (vec3(149., 167., 200.)*(1.5/255.))\n// #define ambientColorBottom (vec3(39., 67., 87.)*(1.5/255.))\n// #define ambientColorBottom (vec3(20., 20., 20.)*(1.5/255.))\n#define CLOUDS_MIN_TRANSMITTANCE .1\n\n// #define shapeScale 5.51\n#define CLOUDS_DETAIL_SCALE 50.\n\n#ifdef MVT_USE_VOULEMTRIC\nuniform sampler2D tShape; // cloud shape\nuniform sampler2D tPrevious; // previous frame\nuniform sampler2D tDetail; // cloud detail\n#else\nuniform sampler2D tWeather; // cloud shape\nuniform sampler2D tNoise; // cloud detail\n#endif\nuniform sampler2D tDepth; // depth buffer\nuniform sampler2D tDiffuse;\nuniform sampler2D tBlueNoise;\nuniform vec2 resolution;\nuniform float iTime;\nuniform vec3 cameraDirection;\nuniform mat4 mvt_viewMatrixInverse;\nuniform mat4 mvt_projectionMatrixInverse;\nuniform vec3 mvt_cameraPosition;\nuniform mat4 uCameraMatrix;\nuniform mat4 uLastCameraMatrix;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform float coverage;\nuniform float density;\nuniform float speed;\nuniform bool cameraChanged;\nuniform vec3 ambientColorBottom;\nuniform float previousRatio;\n// .x baseScale .y detailScale\nuniform vec4 shapeScale;\n//\n// Cloud shape modelling and rendering \n//\n\nfloat HenyeyGreenstein( float sundotrd, float g) {\n\tfloat gg = g * g;\n\treturn (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);\n}\n\n// float interectCloudSphere( vec3 rd, float r ) {\n//     float b = EARTH_RADIUS * rd.y;\n//     float d = b * b + r * r + 2. * EARTH_RADIUS * r;\n//     return -b + sqrt( d );\n// }\n\nfloat interectCloudSphere(vec3 ro, vec3 rd, float rad) {\n    rad += EARTH_RADIUS;\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad*rad;\n    if (c > 0.0 && b > 0.0) return -1.0;\n    float discr = b*b - c;\n    if (discr < 0.0) return -1.0;\n    // Special case: inside sphere, use far discriminant\n    if (discr > b*b) return (-b + sqrt(discr));\n    return -b - sqrt(discr);\n}\n\nfloat linearstep( const float s, const float e, float v ) {\n    return clamp( (v-s)*(1./(e-s)), 0., 1. );\n}\n\nfloat linearstep0( const float e, float v ) {\n    return min( v*(1./e), 1. );\n}\n\nfloat remap(float v, float s, float e) {\n\treturn (v - s) / (e - s);\n}\n\nfloat remap2(float v, float l0, float h0, float ln, float hn) {\n    return ln + (v - l0) * (hn - ln) / (h0 - l0);\n}\n#ifdef MVT_USE_VOULEMTRIC\nfloat cloudMapBase(vec3 p, float norY) {\n\tvec3 uv = p * (0.00005 * shapeScale.x);\n    vec3 cloud = texture2D(tShape, uv.xz * 2.5 + iTime * 0.002 * speed).rgb;\n   \n    float n = norY*norY;\n    n *= cloud.b ;\n        n+= pow(1.-norY, 16.); \n\treturn remap( cloud.r - n, cloud.g, 1.);\n}\n\nfloat cloudMapDetail(vec3 p) { \n    // 3d lookup in 2d texture :(\n    p = abs(p) * (0.0016 * shapeScale.x * shapeScale.y);\n    p += iTime * 0.02 * speed;\n    float yi = mod(p.y,32.);\n    ivec2 offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;\n    float a = texture2D(tDetail, (mod(p.xz,32.)+vec2(offset.xy)+1.)/resolution.xy).r;\n    \n    yi = mod(p.y+1.,32.);\n    offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;\n    float b = texture2D(tDetail, (mod(p.xz,32.)+vec2(offset.xy)+1.)/resolution.xy).r;\n    \n    return mix(a,b,fract(p.y));\n}\n\nfloat cloudGradient( float norY ) {\n    return linearstep( 0., .05, norY ) - linearstep( .8, 1.2, norY);\n}\n\nfloat cloudMap(vec3 pos, vec3 rd, float norY) {\n    vec3 ps = pos;\n    \n    float m = cloudMapBase(ps, norY);\n\tm *= cloudGradient( norY );\n\n\tfloat dstrength = smoothstep(1., 0.5, m);\n    \n    // erode with detail\n    if(dstrength > 0.) {\n\t\tm -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;\n    }\n\n\tm = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(coverage-1.) );\n    m *= linearstep0(CLOUDS_BOTTOM_SOFTNESS, norY);\n\n    return clamp(m * density * (1.+max((ps.x-100000.)*0.005,0.)), 0., 1.);\n}\n\nfloat volumetricShadow(in vec3 from, in float sundotrd ) {\n    float dd = CLOUDS_SHADOW_MARGE_STEP_SIZE;\n    vec3 rd = sunDirection;\n    float d = dd * .5;\n    float shadow = 1.0;\n\n    for(int s=0; s<MVT_CLOUD_SELF_SHADOW_STEPS; s++) {\n        vec3 pos = from + rd * d;\n        float norY = (length(pos) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM));\n\n        if(norY > 1.) return shadow;\n\n        float muE = cloudMap( pos, rd, norY );\n        shadow *= exp(-muE * dd);\n\n        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;\n        d += dd;\n    }\n    return shadow;\n}\n\nvec4 renderClouds( vec3 ro, vec3 rd, inout float dist ) {\n    if( rd.y < 0. ) {\n        return vec4(0,0,0,1);\n    }\n\n    // ro.x += -cos(iTime * 0.13) * 0.5;\n    // ro.z += (-cos(iTime * 0.1) * 100. + 20.) * 0.1;\n    // ro += rand();\n    // ro.xz *= SCENE_SCALE;\n    // 位置\n    // ro.x += iTime * 0.;\n    ro.y += EARTH_RADIUS;\n    // ro.y = sqrt(EARTH_RADIUS*EARTH_RADIUS-dot(ro.xz,ro.xz));\n\n    float start = interectCloudSphere(ro, rd, CLOUDS_BOTTOM );\n    float end  = interectCloudSphere(ro,  rd, CLOUDS_TOP );\n    \n    if (start > dist) {\n        return vec4(0,0,0,1);\n    }\n    \n    end = min(end, dist);\n    \n    float sundotrd = dot( rd, -sunDirection);\n\n    // raymarch\n    float d = start;\n    float dD = (end-start) / float(MVT_CLOUD_MARCH_STEPS);\n\n    float h = hash13(rd + fract(iTime) );\n    d -= dD * h;\n\n    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),\n        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );\n\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n\n    dist = EARTH_RADIUS;\n\n    for(int s=0; s<MVT_CLOUD_MARCH_STEPS; s++) {\n        vec3 p = ro + d * rd;\n\n        float norY = clamp( (length(p) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM)), 0., 1.);\n\n        float alpha = cloudMap( p, rd, norY );\n\n        if( alpha > 0. ) {\n            dist = min( dist, d);\n            vec3 ambientLight = mix( ambientColorBottom, CLOUDS_AMBIENT_COLOR_TOP, norY );\n\n            vec3 S = (ambientLight + sunColor * (scattering * volumetricShadow(p, sundotrd))) * alpha;\n            float dTrans = exp(-alpha * dD);\n            vec3 Sint = (S - S * dTrans) * (1. / alpha);\n            scatteredLight += transmittance * Sint; \n            transmittance *= dTrans;\n        }\n\n        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;\n\n        d += dD;\n    }\n\n    return vec4(scatteredLight, transmittance);\n}\n//\n//\n// !Because I wanted a second cloud layer (below the horizon), I copy-pasted \n// almost all of the code above:\n//\n\nfloat cloudMapLayer(vec3 pos, vec3 rd, float norY) {\n    vec3 ps = pos;\n\n    float m = cloudMapBase(ps, norY);\n\t// m *= cloudGradient( norY );\n\tfloat dstrength = smoothstep(1., 0.5, m);\n    \n    // erode with detail\n    if (dstrength > 0.) {\n\t\tm -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;\n    }\n\n\tm = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(CLOUDS_LAYER_COVERAGE-1.) );\n\n    return clamp(m * density, 0., 1.);\n}\n\nfloat volumetricShadowLayer(in vec3 from, in float sundotrd ) {\n    float dd = CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE;\n    vec3 rd = sunDirection;\n    float d = dd * .5;\n    float shadow = 1.0;\n\n    for(int s=0; s<MVT_CLOUD_SELF_SHADOW_STEPS; s++) {\n        vec3 pos = from + rd * d;\n        float norY = clamp( (pos.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);\n\n        if(norY > 1.) return shadow;\n\n        float muE = cloudMapLayer( pos, rd, norY );\n        shadow *= exp(-muE * dd);\n\n        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;\n        d += dd;\n    }\n    return shadow;\n}\n\nvec4 renderCloudLayer( vec3 ro, vec3 rd, inout float dist ) {\n    if( rd.y > 0. ) {\n        return vec4(0,0,0,10);\n    }\n\n    ro.xz *= SCENE_SCALE;\n    ro.y += EARTH_RADIUS;\n    // ro.y = 0.;\n\n    float start = CLOUDS_LAYER_TOP/rd.y;\n    float end  = CLOUDS_LAYER_BOTTOM/rd.y;\n    \n    if (start > dist) {\n        return vec4(0,0,0,10);\n    }\n    \n    end = min(end, dist);\n    \n    float sundotrd = dot( rd, -sunDirection);\n\n    // raymarch\n    float d = start;\n    float dD = (end-start) / float(MVT_CLOUD_MARCH_STEPS);\n\n    float h = hash13(rd + fract(iTime) );\n    d -= dD * h;\n\n    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),\n        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );\n\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n\n    dist = EARTH_RADIUS;\n\n    for(int s=0; s<MVT_CLOUD_MARCH_STEPS; s++) {\n        vec3 p = ro + d * rd;\n\n        float norY = clamp( (p.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);\n\n        float alpha = cloudMapLayer( p, rd, norY );\n\n        if( alpha > 0. ) {\n            dist = min( dist, d);\n            vec3 ambientLight = mix( ambientColorBottom, CLOUDS_AMBIENT_COLOR_TOP, norY );\n\n            vec3 S = .7 * (ambientLight +  sunColor * (scattering * volumetricShadowLayer(p, sundotrd))) * alpha;\n            float dTrans = exp(-alpha * dD);\n            vec3 Sint = (S - S * dTrans) * (1. / alpha);\n            scatteredLight += transmittance * Sint; \n            transmittance *= dTrans;\n        }\n\n        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;\n\n        d += dD;\n    }\n\n    return vec4(scatteredLight, transmittance);\n}\n\nvec2 reprojectPos( in vec3 pos, in vec2 resolution, in sampler2D storage ) {\n    vec4 wpos = vec4(pos.xyz,1.0);\n    vec3 cpos = (wpos*uLastCameraMatrix).xzy; \n    vec2 npos = 2. * cpos.xy / cpos.z;\n    return 0.5 + 0.5*npos*vec2(resolution.y/resolution.x,1.0);\n}\n#else\n/**\n* simple cloud\n*/\nvec4 renderClouds( vec3 ro, vec3 rd, inout float dist ) {\n    if( rd.y < 0. ) {\n        return vec4(0,0,0,1);\n    }\n    ro.y += EARTH_RADIUS;\n\n    vec3 p = ro + rd * 60000.;\n    vec4 col = vec4(1.0);\n\n    // vec2 cloudUV = p.xz * 0.1;\n    float r = sqrt(2.0 * (1.0 - rd.y));\n    float theta = atan(rd.x, rd.z);\n\n    vec2 cloudUV = vec2(r * cos(theta) * 0.5 + 0.5, r * sin(theta) * 0.5 + 0.5) * 10000.0;\n    float uvOffset = iTime / 1000.0 * speed;\n    vec4 weatherColor = texture2D(tWeather, cloudUV * 0.00003 + uvOffset);\n    float wmc = max(weatherColor.x, clamp(coverage * 1.0 - 0.5, 0.0, 1.0) * weatherColor.y * 2.0);\n    // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);\n    // SNsample = R(snr, (sng ×0.625+snb ×0.25+sna ×0.125)−1, 1, 0, 1)\n    vec4 noiseColor = texture2D(tNoise, (cloudUV + uvOffset) * 1.0);\n    float sn_sample = remap2(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);\n    float sn = clamp(remap2(sn_sample, 1.0 - coverage * 1.0 * wmc, 1.0, 0.0, 1.0), 0.0, 1.0);\n \n    float thickness = clamp(sn * 1.0 + 0.1, 0.0, 1.0);\n    float cloudAlpha = clamp(thickness, 0.0, 1.0); // remap2(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);\n    // vec3 cloudColor = vec3(remap2(clamp(cloudAlpha, 0.0, 1.0), 0.0, 1.0, 1.0, 0.6));\n    vec3 cloudColor = vec3(cloudAlpha);\n    // 太阳散射，根据厚度发生变化\n    // vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;\n    // if (mixGrayFactor > 0.0) {\n    //     vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);\n    //     sunLightColor = mix(sunLightColor, gray, mixGrayFactor);\n    // }\n    // cloudColor = sunLightColor;\n    // cloudColor = sunLightColor * (remap(thickness, 0.0, 1.0, 1.5, 0.5));\n    \n    // // 天空大气颜色\n    // vec3 sunDir = getSunDir();\n    // vec3 rayDir = normalize(vWorldPosition.xzy);\n\n    // cloudColor *= clamp(remap(dot(rayDir, sunDir), -1.0, 1.0, 0.75, 2.0), 0.75, 2.0);\n\n    // vec3 atmosphereColor = getValFromSkyLUT(rayDir, sunDir);\n    // atmosphereColor *= 100.0;\n    // atmosphereColor = jodieReinhardTonemap(atmosphereColor);\n    // atmosphereColor = pow(atmosphereColor, vec3(1.0/2.2));\n    // atmosphereColor = toLinear(vec4(atmosphereColor, 1.0)).xyz;\n\n    // float atmosphereColorFactor = remap(clamp(thickness, 0.5, 1.0), 0.5, 1.0, 0.0, 1.0);\n    // atmosphereColorFactor = 0.5 - abs(0.5 - atmosphereColorFactor);\n    // cloudColor = mix(cloudColor, atmosphereColor, atmosphereColorFactor);\n\n    // // 和天空大气混合\n    // cloudColor = mix(cloudColor, atmosphereColor, 1.0 - clamp((vWorldPosition.z + 0.02) * 10.0, 0.0, 1.0));\n\n    // cloudColor = atmosphereColor; // lum;\n    // vec3 cloudColor = texture2D(skyMap, cloudUV * 2.0).xyz * 10.0;\n    return vec4(cloudColor, 1.0 - cloudAlpha);\n    // return vec4(cloudUV, 0.0, 1.0);\n    // return col;\n}\n#endif\nfloat getDepthValue(sampler2D depthTexture, vec2 uv) {\n    return texture2D(depthTexture, uv).r;\n}\n\nvec3 ReinhardToneMapping( vec3 color ) {\n\treturn clamp( color / ( vec3( 1.0 ) + color ), 0.0, 1.0 );\n\n}\n\nvoid main() {\n    // if (gl_FragCoord.y < 1.5) {\n    //     gl_FragColor = saveCamera(iTime, gl_FragCoord, iMouse/resolution.xyxy);\n    //     if( abs(gl_FragCoord.x-1.5)<0.5 ) gl_FragColor = vec4(iMouse);\n    //     if( abs(gl_FragCoord.x-0.5)<0.5 ) gl_FragColor = mouseChanged() ? vec4(0) : vec4(resolution.xy,0,0);\n    // } else {\n    //     if( letterBox(gl_FragCoord, resolution.xy, 2.25) ) {\n    //     \tgl_FragColor = vec4( 0., 0., 0., 1. );\n    //    \t\treturn;\n    //     } else {\n    float depthValue = texelFetch(tDepth, ivec2(gl_FragCoord), 0).r;\n    // vec2 depthValueUV = gl_FragCoord.xy / resolution;\n    // float depthValue = getDepthValue(tDepth, depthValueUV);\n    if (depthValue < 0.99) {\n        gl_FragColor = vec4(0,0,0,1);\n        return;\n    }\n    float dist = 60000.0; // texelFetch(tDepth, ivec2(gl_FragCoord),0).w * SCENE_SCALE;\n    // dist = 30000.0 * SCENE_SCALE;\n    vec4 col = vec4(0,0,0,1);\n    vec3 camRight   = vec3( uCameraMatrix[0][0],  uCameraMatrix[0][1],  uCameraMatrix[0][2]);\n    vec3 camUp      = vec3( uCameraMatrix[1][0],  uCameraMatrix[1][1],  uCameraMatrix[1][2]);\n\tvec3 camForward = vec3(-uCameraMatrix[2][0], -uCameraMatrix[2][1], -uCameraMatrix[2][2]);\n\n\t// calculate unique seed for rng() function\n\t// seed = uvec2(uFrameCounter, uFrameCounter + 1.0) * uvec2(gl_FragCoord);\n\t// initialize rand() variables\n\t// randNumber = 0.0; // the final randomly-generated number (range: 0.0 to 1.0)\n\tfloat blueNoise = texelFetch(tBlueNoise, ivec2(mod(floor(gl_FragCoord.xy), 128.0)), 0).r * 0.5;\n    // vec2 blueNoiseUV = mod(gl_FragCoord.xy, vec2(128.0)) / 128.0;\n    // float blueNoise = getDepthValue(tBlueNoise, blueNoiseUV) * 0.5;\n\n\t// vec2 pixelOffset = vec2( tentFilter(rand()), tentFilter(rand()) ) * 0.5;\n\t// // we must map pixelPos into the range -1.0 to +1.0\n\n    float camFOVWidth = 35.0 / 180.0 * 3.1415926;\n    float camHeightScale = tan(camFOVWidth / 2.0);\n    float camWidthScale = camHeightScale * resolution.x / resolution.y;\n    vec2 uv = (gl_FragCoord.xy + vec2(0.5) + blueNoise) / resolution;\n\tvec2 pixelPos = uv * 2.0 - 1.0;\n\n\tvec3 rayDir = normalize( pixelPos.x * camRight * camWidthScale + pixelPos.y * camUp * camHeightScale + camForward );\n\n\t// depth of field\n\t// vec3 focalPoint = uFocusDistance * rayDir;\n\t// float randomAngle = rng() * TWO_PI; // pick random point on aperture\n\t// float randomRadius = rng() * uApertureSize;\n\t// vec3  randomAperturePos = ( cos(randomAngle) * camRight + sin(randomAngle) * camUp ) * sqrt(randomRadius);\n\t// // point on aperture to focal point\n\t// vec3 finalRayDir = normalize(focalPoint - randomAperturePos);\n\n\t// vec3 ro = vec3(0., 0., 0.); // cameraPosition.xzy; // CAMERA_RO; // cameraPosition.xzy / 10.;\n    vec3 ro = mvt_cameraPosition.xzy;\n    // ro += blueNoise;\n\tvec3 rd = rayDir.xzy;\n    if( rd.y > 0. ) {\n        // clouds\n        col = renderClouds(ro, rd, dist);\n        // TODO: 调整云的高光区域，防止过曝\n       //  col.rgb = ReinhardToneMapping(col.rgb);\n        // float fogAmount = 1.-(.1 + exp(-dist*0.000001));\n        float fogAmount = 1.0 - clamp(rd.y * 20.0, 0.0, 1.0);\n        // vec3 skyColor = getSkyColor(rd);\n        vec3 skyColor = clamp(texture2D(tDiffuse, uv).rgb, 0.0, 1.0);\n        col.rgb = mix(col.rgb, skyColor*(1.-col.a), fogAmount);\n    } else {\n        // cloud layer below horizon\n        // col = renderCloudLayer(ro, rd, dist);\n        // // height based fog, see https://iquilezles.org/articles/fog\n        // float fogAmount = HEIGHT_BASED_FOG_C * \n        //     (1.-exp( -dist*rd.y*(INV_SCENE_SCALE*HEIGHT_BASED_FOG_B)))/rd.y;\n        // vec3 skyColor = texture(tDiffuse, uv).rgb;\n        // col.rgb = mix(col.rgb, skyColor*(1.-col.a), clamp(fogAmount,0.,1.));\n    }\n    // vec4 previousColor = texelFetch(tPrevious, ivec2(gl_FragCoord.xy), 0);\n    // gl_FragColor = col * 0.1 + previousColor * 0.9;\t\n    #ifdef MVT_USE_VOULEMTRIC\n    if( col.w > 1. ) {\n         gl_FragColor = vec4(0,0,0,1);\n    } else {\n        // float ratio = 0.3;\n        // if (!cameraChanged) {\n        //     // vec2 spos = reprojectPos(ro+rd*dist, resolution.xy, tPrevious);\n        //     // 简化叠加\n        //     // col.r = ocol.a;\n        //     // col.x += 0.5;\n        //     ratio = 0.2;\n        // }\n        // else {\n\n        // }\n        vec2 spos = uv;\n        vec4 ocol = texture2D( tPrevious, spos, 0.0 ).xyzw;\n        col = mix(ocol, col, previousRatio);\n    }\n    #endif\n    gl_FragColor = col;\n}',shapeFragShader="#define GLSLIFY 1\n// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n// Buffer A: The main look-up texture for the cloud shapes. \n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\n// \nvarying vec2 vUv;\nvoid main() { \n\n    vec3 coord = fract(vec3(vUv + vec2(.2,0.62), .5));\n    \n    vec4 col = vec4(1);\n    \n    float mfbm = 0.9;\n    float mvor = 0.7;\n    \n    col.r = mix(1., tilableFbm( coord, 7, 4. ), mfbm) * \n            mix(1., tilableVoronoi( coord, 8, 9. ), mvor);\n    col.g = 0.625 * tilableVoronoi( coord + 0., 3, 15. ) +\n            0.250 * tilableVoronoi(  coord + 0., 3, 19. ) +\n            0.125 * tilableVoronoi( coord + 0., 3, 23. ) \n            -1.;\n    col.b = 1. - tilableVoronoi( coord + 0.5, 6, 9. );\n    \n    gl_FragColor = col;\n}",detailFragShader="#define GLSLIFY 1\n// Himalayas. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MdGfzh\n//\n// This is my first attempt to render volumetric clouds in a fragment shader.\n//\n// Buffer A: The main look-up texture for the cloud shapes. \n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\n// \n\nvoid main() { \n    \n        // pack 32x32x32 3d texture in 2d texture (with padding)\n    float z = floor(gl_FragCoord.x/34.) + 8.*floor(gl_FragCoord.y/34.);\n    vec2 uv = mod(gl_FragCoord.xy, 34.) - 1.;\n    vec3 coord = vec3(uv, z) / 32.;\n\n    float r = tilableVoronoi( coord, 16,  3. );\n    float g = tilableVoronoi( coord,  4,  8. );\n    float b = tilableVoronoi( coord,  4, 16. );\n\n    float c = max(0., 1.-(r + g * .5 + b * .25) / 1.75);\n\n    gl_FragColor = vec4(c,c,c,c);\n\n}",VolumetricCloudsShapeShader={uniforms:{},vertexShader:mainVertShader,fragmentShader:commonFragShader+"\n"+shapeFragShader},VolumetricCloudsDetailShader={uniforms:{},vertexShader:mainVertShader,fragmentShader:commonFragShader+"\n"+detailFragShader},VolumetricCloudsShader={uniforms:{tShape:{value:null},tPrevious:{value:null},tDepth:{value:null},tDetail:{value:null},tDiffuse:{value:null},tBlueNoise:{value:null},tWeather:{value:null},tNoise:{value:null},resolution:{value:new three.Vector2(1,1)},iTime:{value:0},mvt_projectionMatrixInverse:{value:new three.Matrix4},mvt_viewMatrixInverse:{value:new three.Matrix4},uCameraMatrix:{value:new three.Matrix4},uLastCameraMatrix:{value:new three.Matrix4},mvt_cameraPosition:{value:new three.Vector3},sunColor:{value:new three.Vector3(1,1,1)},sunDirection:{value:new three.Vector3(0,1,0)},coverage:{value:.52},density:{value:.03},speed:{value:1},cameraChanged:{value:!1},ambientColorBottom:{value:new three.Vector3(.2,.35,.5)},shapeScale:{value:new three.Vector4(5.51,50,1,1)},previousRatio:{value:.5}},vertexShader:mainVertShader,fragmentShader:commonFragShader+"\n"+mainFragShader},compostionFragShader="\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tClold;\n    varying vec2 vUv;\n    void main() {\n        vec4 color = texture2D(tDiffuse, vUv);\n        vec4 cloud = texture2D(tClold, vUv);\n        // gl_FragColor.rgb = mix(color.rgb, cloud.rgb, 1.0 - clamp(cloud.a, 0.0, 1.0));\n        gl_FragColor.rgb = cloud.rgb + color.rgb * cloud.a;\n        gl_FragColor.a = 1.0;\n        // gl_FragColor.rgb += cloud.rgb;\n        // gl_FragColor = cloud;\n        // gl_FragColor = vec4(cloud.a, 0.0, 0.0, 1.0);\n        // gl_FragColor = vec4(cloud.rgb, 1.0);\n    }\n";class VolumetricCloudsPass extends Pass$1{constructor(e={}){super(),__publicField(this,"_coverage",.56),__publicField(this,"_density",.015),__publicField(this,"_speed",1),__publicField(this,"_shapeBaseScale",.55),__publicField(this,"_shapeDetailScale",20),__publicField(this,"_sunColor",new three.Vector3(1,1,1)),__publicField(this,"_sunDirection",new three.Vector3(0,1,0)),__publicField(this,"_ambientColorBottom",new three.Vector3(.2,.35,.5)),__publicField(this,"_useVolumetric",!0),this._fsQuad=new FullScreenQuad(null),this._shapeRenderTarget=new three.WebGLRenderTarget(1280,720,{format:"RGBA",depthBuffer:!1,stencilBuffer:!1}),this._shapeRenderTarget.texture.generateMipmaps=!1,this._shapeRenderTarget.texture.minFilter=three.LinearFilter,this._shapeRenderTarget.texture.magFilter=three.LinearFilter,this._shapeRenderTarget.texture.wrapS=three.RepeatWrapping,this._shapeRenderTarget.texture.wrapT=three.RepeatWrapping,this._shapeMaterial=new three.ShaderMaterial({uniforms:three.UniformsUtils.clone(VolumetricCloudsShapeShader.uniforms),vertexShader:VolumetricCloudsShapeShader.vertexShader,fragmentShader:VolumetricCloudsShapeShader.fragmentShader,depthTest:!1,depthWrite:!1}),this._detailRenderTarget=new three.WebGLRenderTarget(1024,512,{format:"RGBA",depthBuffer:!1,stencilBuffer:!1}),this._detailRenderTarget.texture.generateMipmaps=!1,this._detailRenderTarget.texture.wrapS=three.RepeatWrapping,this._detailRenderTarget.texture.wrapT=three.RepeatWrapping,this._detailRenderTarget.texture.minFilter=three.LinearFilter,this._detailRenderTarget.texture.magFilter=three.LinearFilter,this._detailMaterial=new three.ShaderMaterial({uniforms:three.UniformsUtils.clone(VolumetricCloudsDetailShader.uniforms),vertexShader:VolumetricCloudsDetailShader.vertexShader,fragmentShader:VolumetricCloudsDetailShader.fragmentShader,depthTest:!1,depthWrite:!1});const t={MVT_CLOUD_MARCH_STEPS:8,MVT_CLOUD_SELF_SHADOW_STEPS:3};this._useVolumetric&&(t.MVT_USE_VOULEMTRIC=!0);const i=this._mainMaterial=new three.ShaderMaterial({uniforms:three.UniformsUtils.clone(VolumetricCloudsShader.uniforms),vertexShader:VolumetricCloudsShader.vertexShader,fragmentShader:VolumetricCloudsShader.fragmentShader,defines:t,depthTest:!1,depthWrite:!1,name:"VolumetricCloudsShader"});i.uniforms.tShape.value=this._shapeRenderTarget.texture,i.uniforms.tDetail.value=this._detailRenderTarget.texture,i.uniforms.tBlueNoise.value=e.tBlueNoise,i.uniforms.tWeather.value=e.tWeather,i.uniforms.tNoise.value=e.tNoise,this._previousRenderTarget=new three.WebGLRenderTarget(1,1,{format:"RGBA",depthBuffer:!1,stencilBuffer:!1}),this._copyMaterial=new three.ShaderMaterial({uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:CopyShader.vertexShader,fragmentShader:CopyShader.fragmentShader,name:"VolumetricCloudsCopyShader",depthTest:!1,depthWrite:!1}),i.uniforms.tPrevious.value=this._previousRenderTarget.texture,this._compostionMaterial=new three.ShaderMaterial({uniforms:{tDiffuse:{value:null},tClold:{value:null}},vertexShader:CopyShader.vertexShader,fragmentShader:compostionFragShader,name:"VolumetricCloudsCompostionShader",depthTest:!1,depthWrite:!1}),this.needsDepthTexture=!0}render(e,t,i,n,r){if(!this.sky)return;const s=this.rendering,a=s.camera,o=s.resolution,l=s.pixelRatio,c=e.autoClear,h=this._mainMaterial,u=this._copyMaterial,d=this._fsQuad;if(e.autoClear=!1,!this._hasRenderShapeTexture||s.renderState.isRendererRecreated){d.material=this._shapeMaterial,e.setRenderTarget(this._shapeRenderTarget),e.clear(!0,!1,!1),d.render(e);const t=this._detailMaterial;d.material=t,e.setRenderTarget(this._detailRenderTarget),e.clear(!0,!1,!1),d.render(e),this._hasRenderShapeTexture=!0}if(h.uniforms.tDiffuse.value=i.texture,h.uniforms.tDepth.value=this.rendering.main.sceneRendering.depthTexture,h.uniforms.mvt_projectionMatrixInverse.value.copy(a.projectionMatrixInverse),h.uniforms.mvt_viewMatrixInverse.value.copy(a.matrixWorld),h.uniforms.cameraChanged.value=s.renderState.viewChanged,h.uniforms.speed.value=this._speed,h.uniforms.ambientColorBottom.value.copy(this._ambientColorBottom),h.uniforms.sunColor.value.copy(this._sunColor),h.uniforms.sunDirection.value.copy(this._sunDirection),h.uniforms.coverage.value=this._coverage,h.uniforms.density.value=this._density,h.uniforms.shapeScale.value.set(this._shapeBaseScale,this._shapeDetailScale,1,1),s._engine.map.isGlobe){let e=s._engine.map._map._ellipsoidCamera;h.uniforms.uCameraMatrix.value.copy(e.getLocalTransform());const t=e.positionCartographic.z;h.uniforms.mvt_cameraPosition.value.set(0,0,t)}else h.uniforms.uCameraMatrix.value.copy(a.matrixWorld),h.uniforms.mvt_cameraPosition.value.set(0,0,0);h.uniforms.coverage.value=this._coverage,h.uniforms.density.value=this._density,h.uniforms.iTime.value+=n;let p=!1;this._previousRenderTarget.width===o.x*l&&this._previousRenderTarget.height===o.y*l||(this._previousRenderTarget.setSize(o.x*l,o.y*l),h.uniforms.resolution.value.set(o.x*l,o.y*l),p=!0);const m=s.renderState.viewChanged;p?(h.previousRatio=0,this._stableFrames=0):m?(h.uniforms.previousRatio.value=.5,this._stableFrames=0):(h.uniforms.previousRatio.value=.1,this._stableFrames++),this._stableFrames<30?(s.requestRender(),this.isStable=!1):this.isStable=!0;const f=s.sharedFullScreenRenderTargets.getAvailableRenderTarget();e.setRenderTarget(f),d.material=h,e.clear(!0,!1,!1),d.render(e),e.setRenderTarget(this._previousRenderTarget),u.uniforms.tDiffuse.value=f.texture,d.material=u,e.clear(!0,!1,!1),d.render(e);const g=this._compostionMaterial;g.uniforms.tDiffuse.value=i.texture,g.uniforms.tClold.value=f.texture,d.material=g,e.setRenderTarget(this.renderToScreen?null:t),e.clear(!0,!1,!1),d.render(e),h.uniforms.uLastCameraMatrix.value.copy(h.uniforms.uCameraMatrix.value),e.autoClear=c}getCurrentUsedTextures(){return[this._shapeRenderTarget.texture,this._detailRenderTarget.texture]}_resetStableState(){this._stableFrames=0}get coverage(){return this._coverage}set coverage(e){this._coverage=e,this._mainMaterial.uniforms.coverage.value=e,this._resetStableState()}get density(){return this._density}set density(e){this._density=e,this._mainMaterial.uniforms.density.value=e,this._resetStableState()}get speed(){return this._speed}set speed(e){this._speed=e,this._mainMaterial.uniforms.speed.value=e,this._resetStableState()}get sunColor(){return this._sunColor}set sunColor(e){this._sunColor.copy(e),this._mainMaterial.uniforms.sunColor.value.copy(e),this._resetStableState()}get sunDirection(){return this._sunDirection}set sunDirection(e){this._sunDirection.copy(e),this._mainMaterial.uniforms.sunDirection.value.copy(e),this._resetStableState()}get ambientColorBottom(){return this._ambientColorBottom}set ambientColorBottom(e){this._ambientColorBottom.copy(e),this._mainMaterial.uniforms.ambientColorBottom.value.copy(e),this._resetStableState()}get shapeBaseScale(){return this._shapeBaseScale}set shapeBaseScale(e){this._shapeBaseScale=e,this._mainMaterial.uniforms.shapeScale.value.x=e,this._resetStableState()}get shapeDetailScale(){return this._shapeDetailScale}set shapeDetailScale(e){this._shapeDetailScale=e,this._mainMaterial.uniforms.shapeScale.value.y=e,this._resetStableState()}get useVolumetric(){return this._useVolumetric}set useVolumetric(e){this._useVolumetric=e,e?this._mainMaterial.defines.MVT_USE_VOULEMTRIC=!0:delete this._mainMaterial.defines.MVT_USE_VOULEMTRIC,this._mainMaterial.needsUpdate=!0,this._resetStableState()}get marchSteps(){return this._mainMaterial.defines.MVT_CLOUD_MARCH_STEPS}set marchSteps(e){this._mainMaterial.defines.MVT_CLOUD_MARCH_STEPS=parseInt(e,10),this._mainMaterial.needsUpdate=!0}get selfShadowSteps(){return this._mainMaterial.defines.MVT_CLOUD_SELF_SHADOW_STEPS}set selfShadowSteps(e){this._mainMaterial.defines.MVT_CLOUD_SELF_SHADOW_STEPS=parseInt(e,10),this._mainMaterial.needsUpdate=!0}}const ENV_TYPE_CUBE_UV=2,_vector3$2=new three.Vector3,_color=new three.Color,_matrix4$3=new three.Matrix4;class DynamicSky extends EmptySky{constructor(e={}){super(e),__publicField(this,"isDynamicSky",!0),__publicField(this,"_rtFlipCount",0),__publicField(this,"_skyNeedsCapture",!0),__publicField(this,"_skyNeedsUpdate",!0),__publicField(this,"_staticEnvMapNeedsUpdate",!0),__publicField(this,"_realtimeCapture",!0),__publicField(this,"_envMapType",ENV_TYPE_CUBE_UV),__publicField(this,"_PMREMGenerator",null),__publicField(this,"_cloud",null),__publicField(this,"_envRenderTarget1",null),__publicField(this,"_envRenderTarget2",null),__publicField(this,"_skyAtmosphere",null),__publicField(this,"_lastCameraZ",-1/0),__publicField(this,"_skyLightIntensity",.2),__publicField(this,"_sunLightIntensity",2.2),__publicField(this,"name","DynamicSky"),__publicField(this,"dynamicCloud",!1),__publicField(this,"_envCaptureLocationKey",""),__publicField(this,"_presetWeatherProperties",{clear:{sunLightIntensity:2.5,skyLightIntensity:.1,cloudsCoverage:0,mixGrayFactor:0},partlyCloudy:{sunLightIntensity:2.2,skyLightIntensity:.2,cloudsCoverage:.55,mixGrayFactor:.2},cloudy:{sunLightIntensity:.5,skyLightIntensity:.5,cloudsCoverage:.6,mixGrayFactor:.5},overcast:{sunLightIntensity:0,skyLightIntensity:.5,cloudsCoverage:.8,mixGrayFactor:.75},foggy:{sunLightIntensity:0,skyLightIntensity:.5,cloudsCoverage:0,mixGrayFactor:1},rainy:{sunLightIntensity:0,skyLightIntensity:.5,cloudsCoverage:0,mixGrayFactor:1},snowy:{sunLightIntensity:0,skyLightIntensity:.5,cloudsCoverage:0,mixGrayFactor:1},stormy:{sunLightIntensity:0,skyLightIntensity:.5,cloudsCoverage:.8,mixGrayFactor:1},thunderstorm:{sunLightIntensity:0,skyLightIntensity:.3,cloudsCoverage:.3,mixGrayFactor:.5}}),__publicField(this,"_setupClouds",(()=>{const e=this._engine,t=new three.TextureLoader,i=t.load(getAssetUrl("assets/textures/cloud/weather_1.png"),(e=>{i.wrapS=i.wrapT=three.RepeatWrapping})),n=t.load(getAssetUrl("assets/textures/cloud/shape_1.png"),(e=>{n.wrapS=n.wrapT=three.RepeatWrapping})),r=t.load(getAssetUrl("assets/textures/cloud/BlueNoise_R_128.png"),(e=>{r.wrapS=r.wrapT=three.RepeatWrapping})),s=this._cloudsPass=new VolumetricCloudsPass({tBlueNoise:r,tWeather:i,tNoise:n});s.renderOrder=2001,s.sky=this,e.rendering.main.postprocessings.add(s)})),__publicField(this,"updateRealtimeEnvironment",(()=>{const e=this._engine;if(this._skyAtmosphere.material.uStarVisible=!1,!this._cubeRenderTarget){const e=this._cubeRenderTarget=new three.WebGLCubeRenderTarget(256);e.texture.type=three.HalfFloatType,e.texture.minFilter=three.LinearMipmapLinearFilter,e.texture.magFilter=three.LinearFilter,e.texture.generateMipmaps=!0,this._cubeCamera=new three.CubeCamera(1,1e3,e)}e.rendering.objectsScene.visible=!1,e.rendering.environmentScene.visible=!0;const t=e.scene;let i=t.background;t.background={};const n=e.rendering.environmentScene;e.map.isGlobe&&(e.map.projection.localFrameToFixedFrame(e.rendering.camera.position,_matrix4$3),_matrix4$3.decompose(_vector3$2,n.quaternion,_vector3$2),n.updateMatrixWorld()),this._cubeCamera.update(e.renderer,t),this._PMREMGenerator||(this._PMREMGenerator=new three.PMREMGenerator(e.renderer)),this._PMREMGenerator._renderer!==e.renderer?(this._PMREMGenerator.dispose(),this._PMREMGenerator=new three.PMREMGenerator(e.renderer),this._envRT&&this._envRT.dispose(),this._envRT=this._PMREMGenerator.fromCubemap(this._cubeRenderTarget.texture)):this._envRT=this._PMREMGenerator.fromCubemap(this._cubeRenderTarget.texture,this._envRT),e.rendering.scene.environment=this._envRT.texture,t.background=i,e.rendering.objectsScene.visible=!0,e.rendering.environmentScene.visible=!1,this._skyAtmosphere.material.uStarVisible=!0})),__publicField(this,"disposeEnvRenderTarget",(e=>{this._envRenderTarget1&&(this._envRenderTarget1.dispose(),this._envRenderTarget1=null),this._envRenderTarget2&&(this._envRenderTarget2.dispose(),this._envRenderTarget2=null)})),this._affectWorld=!0,this._upDirection=new three.Vector3(0,0,1)}afterAddToEngine(e){super.afterAddToEngine(e),this._engine=e,this.initEnv()}initEnv(){const e=this._engine,t=this._skyAtmosphere=new SkyAtmosphere;t.collisionDisabled=!0,t.__isEnvironment=!0,t.renderOrder=-100,e.add(t);const i=this._atmospherePass=new SkyAtmospherePass;i.renderOrder=2e3,i.sky=this,e.rendering.main.opaquePostprocessings.add(i),this._cloudAmbientBottomColorGradient=new GradientColorLerp([[0,new three.Color("#010105")],[5.5/24,new three.Color("#010105")],[5.8/24,new three.Color("#aa0000")],[6.1/24,new three.Color("#aa9944")],[.3125,new three.Color("#aaaaaa")],[.5,new three.Color("#bbccdd")]]),this._cloudSunIntensityGradient=new GradientColorLerp([[0,.01],[5.5/24,.05],[.3125,.1],[.5,.4]]),this._setupClouds()}onBeforeScenePrepareRender(){super.onBeforeScenePrepareRender();const e=this._engine,t=e.map.isGlobe,i=this._skyAtmosphere,n=this._cloud;i.material.uTime=e.rendering.uniforms.elapsedTime.value,i.material.uniforms.isGlobe.value=t,e.rendering.renderState.isRendererRecreated&&(this.disposeEnvRenderTarget(),i._hasPaintedScatterBuffer=!1,this._skyNeedsUpdate=!0,this._skyNeedsCapture=!0,this._hasCaptureSky=!1,n&&n.updateRenderCacheData());let r=e.map.getViewHeight();const s=Math.abs(r-(this._lastViewHeight||-1/0));if(this._lastViewHeight=r,t){s>1&&(this._skyNeedsUpdate=!0),e.map.getCameraLocation(_vector3$2);const t=`${Math.round(_vector3$2.x/10)}-${Math.round(_vector3$2.y/10)}`;t!==this._envCaptureLocationKey&&(this._envCaptureLocationKey=t,this._skyNeedsCapture=!0,this._hasCaptureSky=!1)}else this._skyNeedsUpdate=!1;(this._skyNeedsCapture||this._skyNeedsUpdate)&&(i.viewHeight=t?Math.max(r/1e6,2e-4):2e-4,i.updateRenderTargets(e.rendering.renderer,e.rendering.camera),n&&(n.material.uniforms.skyAltitude.value=i.altitude)),this.dynamicCloud&&(n.material.uniforms.time.value=e.rendering.uniforms.elapsedTime.value),this._hasCaptureSky||(this._skyNeedsCapture=!0),r>1e4&&(this._skyNeedsCapture=!1),(this._skyNeedsCapture||this.dynamicCloud)&&(i.position.set(0,0,0),i.updateMatrixWorld(),n&&(n.position.set(0,0,0),n.updateMatrixWorld()),this._affectWorld&&(e.rendering.stats.beginTimeStatsItem("Sky.CaptureEnvironment"),this.updateRealtimeEnvironment(),e.rendering.stats.endTimeStatsItem("Sky.CaptureEnvironment")),this._hasCaptureSky=!0),this._affectWorld||(e.rendering.scene.environment=null),i.position.copy(e.rendering.camera.position),i.position.z-=0,n&&n.position.copy(e.rendering.camera.position),this._skyNeedsCapture=!1}updateLight(){if(super.updateLight(),this._lensflare){const e=this._sunDirection.z,t=this._sunDirection.x;let i=10*this._engine.map.getCameraDistance();if(e>.01&&this.sunLight.intensity>.1&&i<1e6){this._lensflare.visible=!0;const[n,r]=this._engine.map.getProjectionCenter();this._lensflare.position.set(n+t*i,r,e*i)}else this._lensflare.visible=!1}}onTimeChanged(e){this._skyAtmosphere.altitude=(e/86400-.25)*Math.PI*2,this._skyNeedsCapture=!0,this._updateClouds()}_updateClouds(){const e=this._cloudsPass;if(e){const t=this._timeRatio>.5?1-this._timeRatio:this._timeRatio,i=this._cloudSunIntensityGradient.lerp(t),n=this.sunLight.color;e.sunColor=_vector3$2.set(n.r,n.g,n.b).multiplyScalar(i*(1-this.mixGrayFactor)),e.sunDirection=_vector3$2.set(-this.localSunDirection.x,-this.localSunDirection.y,-this.localSunDirection.z),this._cloudAmbientBottomColorGradient.lerp(t,_color),_vector3$2.set(_color.r,_color.g,_color.b).multiplyScalar(1-this.mixGrayFactor),e.ambientColorBottom=_vector3$2}}getTextures(){return this._envMapType===ENV_TYPE_CUBE_UV?[this._envRenderTarget1.texture,this._envRenderTarget2.texture]:[]}beforeRemoveFromEngine(e){this.disposeEnvRenderTarget(this._realtimeCapture),e.remove(this._skyAtmosphere),e.remove(this._cloud),e.rendering.main.postprocessings.remove(this._atmospherePass),e.rendering.main.postprocessings.remove(this._cloudsPass),this._skyNeedsUpdate=!0,this._skyNeedsCapture=!0,this._timeChanged=!0,super.beforeRemoveFromEngine(e)}dispose(){super.dispose()}set useVolumetricClouds(e){this._cloudsPass.useVolumetric=e}get useVolumetricClouds(){return this._cloudsPass.useVolumetric}set affectWorld(e){this._skyNeedsCapture=!0,this._affectWorld=e}get affectWorld(){return this._affectWorld}get mixGrayFactor(){return this._skyAtmosphere.mixGrayFactor}set mixGrayFactor(e){this._skyAtmosphere.mixGrayFactor=e,this._skyNeedsCapture=!0,this._updateClouds()}get realtimeCapture(){return this._realtimeCapture}set realtimeCapture(e){e!==this._realtimeCapture&&(console.warn("has not been supported"),this._skyNeedsCapture=!0,this._realtimeCapture=e)}get skyAtmosphere(){return this._skyAtmosphere}get clipUnderground(){return!1}set clipUnderground(e){console.warn("has not been supported")}get enableAtmospherePass(){return this._atmospherePass.enabled||!1}set enableAtmospherePass(e){this._atmospherePass&&(this._atmospherePass.enabled=e)}get enableCloudsPass(){return this._cloudsPass&&this._cloudsPass.enabled||!1}set enableCloudsPass(e){this._cloudsPass&&(this._cloudsPass.enabled=e)}get cloudsCoverage(){return this._cloudsPass&&this._cloudsPass.coverage||0}set cloudsCoverage(e){this._cloudsPass&&(this._cloudsPass.coverage=e)}get cloudDensity(){return this._cloudsPass&&this._cloudsPass.density||0}set cloudDensity(e){this._cloudsPass&&(this._cloudsPass.density=e)}get cloudsSpeed(){return this._cloudsPass&&this._cloudsPass.speed||1}set cloudsSpeed(e){this._cloudsPass&&(this._cloudsPass.speed=e)}get cloudShapeBaseScale(){return this._cloudsPass&&this._cloudsPass.shapeBaseScale||1}set cloudShapeBaseScale(e){this._cloudsPass&&(this._cloudsPass.shapeBaseScale=e)}get cloudShapeDetailScale(){return this._cloudsPass&&this._cloudsPass.shapeDetailScale||1}set cloudShapeDetailScale(e){this._cloudsPass&&(this._cloudsPass.shapeDetailScale=e)}get cloudMarchSteps(){return this._cloudsPass.marchSteps}set cloudMarchSteps(e){this._cloudsPass.marchSteps=e}get cloudSelfShadowSteps(){return this._cloudsPass.selfShadowSteps}set cloudSelfShadowSteps(e){this._cloudsPass.selfShadowSteps=e}get upDirection(){return this._upDirection}get cloudsBaseHeight(){return 0}set cloudsBaseHeight(e){console.warn("cloudsBaseHeight has not been supported")}}class RGBELoader extends three.DataTextureLoader{constructor(e){super(e),this.type=three.HalfFloatType}parse(e){const t=function(e,t){switch(e){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(t||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(t||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(t||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(t||""))}},i=function(e,t,i){t=t||1024;let n=e.pos,r=-1,s=0,a="",o=String.fromCharCode.apply(null,new Uint16Array(e.subarray(n,n+128)));for(;0>(r=o.indexOf("\n"))&&s<t&&n<e.byteLength;)a+=o,s+=o.length,n+=128,o+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(n,n+128)));return-1<r&&(!1!==i&&(e.pos+=s+r+1),a+o.slice(0,r))},n=function(e,t,i,n){const r=e[t+3],s=Math.pow(2,r-128)/255;i[n+0]=e[t+0]*s,i[n+1]=e[t+1]*s,i[n+2]=e[t+2]*s,i[n+3]=1},r=function(e,t,i,n){const r=e[t+3],s=Math.pow(2,r-128)/255;i[n+0]=three.DataUtils.toHalfFloat(Math.min(e[t+0]*s,65504)),i[n+1]=three.DataUtils.toHalfFloat(Math.min(e[t+1]*s,65504)),i[n+2]=three.DataUtils.toHalfFloat(Math.min(e[t+2]*s,65504)),i[n+3]=three.DataUtils.toHalfFloat(1)},s=new Uint8Array(e);s.pos=0;const a=function(e){const n=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,r=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*FORMAT=(\S+)\s*$/,a=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,o={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;for((e.pos>=e.byteLength||!(l=i(e)))&&t(1,"no header found"),(c=l.match(/^#\?(\S+)/))||t(3,"bad initial token"),o.valid|=1,o.programtype=c[1],o.string+=l+"\n";l=i(e),!1!==l;)if(o.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(n))&&(o.gamma=parseFloat(c[1])),(c=l.match(r))&&(o.exposure=parseFloat(c[1])),(c=l.match(s))&&(o.valid|=2,o.format=c[1]),(c=l.match(a))&&(o.valid|=4,o.height=parseInt(c[1],10),o.width=parseInt(c[2],10)),2&o.valid&&4&o.valid)break}else o.comments+=l+"\n";return 2&o.valid||t(3,"missing format specifier"),4&o.valid||t(3,"missing image size specifier"),o}(s),o=a.width,l=a.height,c=function(e,i,n){const r=i;if(r<8||r>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);r!==(e[2]<<8|e[3])&&t(3,"wrong scanline width");const s=new Uint8Array(4*i*n);s.length||t(4,"unable to allocate buffer space");let a=0,o=0;const l=4*r,c=new Uint8Array(4),h=new Uint8Array(l);let u=n;for(;u>0&&o<e.byteLength;){o+4>e.byteLength&&t(1),c[0]=e[o++],c[1]=e[o++],c[2]=e[o++],c[3]=e[o++],2==c[0]&&2==c[1]&&(c[2]<<8|c[3])==r||t(3,"bad rgbe scanline format");let i,n=0;for(;n<l&&o<e.byteLength;){i=e[o++];const r=i>128;if(r&&(i-=128),(0===i||n+i>l)&&t(3,"bad scanline data"),r){const t=e[o++];for(let e=0;e<i;e++)h[n++]=t}else h.set(e.subarray(o,o+i),n),n+=i,o+=i}const d=r;for(let e=0;e<d;e++){let t=0;s[a]=h[e+t],t+=r,s[a+1]=h[e+t],t+=r,s[a+2]=h[e+t],t+=r,s[a+3]=h[e+t],a+=4}u--}return s}(s.subarray(s.pos),o,l);let h,u,d;switch(this.type){case three.FloatType:d=c.length/4;const e=new Float32Array(4*d);for(let i=0;i<d;i++)n(c,4*i,e,4*i);h=e,u=three.FloatType;break;case three.HalfFloatType:d=c.length/4;const t=new Uint16Array(4*d);for(let i=0;i<d;i++)r(c,4*i,t,4*i);h=t,u=three.HalfFloatType;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:o,height:l,data:h,header:a.string,gamma:a.gamma,exposure:a.exposure,type:u}}setDataType(e){return this.type=e,this}load(e,t,i,n){return super.load(e,(function(e,i){switch(e.type){case three.FloatType:case three.HalfFloatType:e.colorSpace=three.LinearSRGBColorSpace,e.minFilter=three.LinearFilter,e.magFilter=three.LinearFilter,e.generateMipmaps=!1,e.flipY=!0}t&&t(e,i)}),i,n)}}class HDRCubeTextureLoader extends three.Loader{constructor(e){super(e),this.hdrLoader=new RGBELoader,this.type=three.HalfFloatType}load(e,t,i,n){const r=new three.CubeTexture;switch(r.type=this.type,r.type){case three.FloatType:case three.HalfFloatType:r.colorSpace=three.LinearSRGBColorSpace,r.minFilter=three.LinearFilter,r.magFilter=three.LinearFilter,r.generateMipmaps=!1}const s=this;let a=0;function o(t,i,n,o){new three.FileLoader(s.manager).setPath(s.path).setResponseType("arraybuffer").setWithCredentials(s.withCredentials).load(e[t],(function(e){a++;const n=s.hdrLoader.parse(e);if(n){if(void 0!==n.data){const e=new three.DataTexture(n.data,n.width,n.height);e.type=r.type,e.colorSpace=r.colorSpace,e.format=r.format,e.minFilter=r.minFilter,e.magFilter=r.magFilter,e.generateMipmaps=r.generateMipmaps,r.images[t]=e}6===a&&(r.needsUpdate=!0,i&&i(r))}}),n,o)}for(let l=0;l<e.length;l++)o(l,t,i,n);return r}setDataType(e){return this.type=e,this.hdrLoader.setDataType(e),this}}const vertexShader$i="#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main()\n{\n    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);\n    vUv = uv;\n    gl_Position = projectionMatrix * viewPos;\n    gl_Position.z = gl_Position.w;\n}\n",fragmentShader$g="#define GLSLIFY 1\n#include <common>\nvarying vec2 vUv;\nuniform sampler2D map;\nuniform float opacity;\nvoid main() {\n\n    vec4 color = texture2D(map, vUv);\n    color.a *= opacity;\n    gl_FragColor = color;\n\n    #include <colorspace_fragment>\n}\n",uniforms$j={map:{value:null},opacity:{value:1},isEmissive:{value:!1}};class StaticSkyMaterial extends three.ShaderMaterial{constructor(e){super(),this.defines={},this.uniforms=three.UniformsUtils.clone(uniforms$j),this.side=three.DoubleSide,this.vertexShader=vertexShader$i,this.fragmentShader=fragmentShader$g,this.depthWrite=!1,this.depthTest=!0,this.transparent=!0,this.envMap=null,this.envMapRotation=new three.Euler(0,0,0),defineMaterialNormalProperties(this,["isEmissive"]),Object.defineProperties(this,{map:{get:function(){return this.uniforms.map.value},set:function(e){this.uniforms.map.value=e,this.needsUpdate=!0}},opacity:{get:function(){return this.uniforms.opacity.value},set:function(e){this.uniforms.opacity.value=e}}})}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const _vector3$1=new three.Vector3,_vector32=new three.Vector3,_matrix4$2=new three.Matrix4;class CustomStaticSky extends EmptySky{constructor(e={}){super(e),__publicField(this,"isCustomStaticSky",!0),__publicField(this,"name","CustomStaticSky"),__publicField(this,"_textureIsCube",!1),__publicField(this,"_textureIsHDR",!1),__publicField(this,"_textureURL",null),__publicField(this,"_textureNames",null),__publicField(this,"_affectWorld",!0),__publicField(this,"_isVerticalTexture",null),__publicField(this,"_mesh",null),__publicField(this,"_material",null),__publicField(this,"_sphereGeometry",null),__publicField(this,"_envTexture",null),__publicField(this,"_engine",null),__publicField(this,"_PMREMGenerator",null),__publicField(this,"_fadeHeightStart",5e3),__publicField(this,"_fadeHeightRange",2e3),__publicField(this,"_envCaptureLocationKey",""),e.texture;const t=this._sphereGeometry=new three.SphereGeometry(1,32,32);this.isVerticalTexture=e.isVerticalTexture||!1;const i=this._mesh=new three.Mesh(t,this._material);i.frustumCulled=!1,i.collisionDisabled=!0,this.add(i)}afterAddToEngine(e){super.afterAddToEngine(e),this._engine=e,this._PMREMGenerator=new three.PMREMGenerator(e.renderer),this._loadSkyTexture()}onBeforeScenePrepareRender(e,t,i){super.onBeforeScenePrepareRender(e,t,i);const n=this._mesh,r=this._material,s=e.map.isGlobe;if(s){const t=e.map.getViewHeight();t<this._fadeHeightStart?r.opacity=1:t>this._fadeHeightStart+this._fadeHeightRange?r.opacity=0:r.opacity=1-(t-this._fadeHeightStart)/this._fadeHeightRange}else r.opacity=1;if(n.position.set(0,0,0),n.rotation.set(0,0,0),n.quaternion.set(0,0,0,1),n.scale.set(1,1,1),this._onLocalTransform(n),n.updateMatrixWorld(!0),s){e.map.unprojectCoordinate(i.position,_vector3$1),_vector3$1.z=.8*_vector3$1.z,e.map.projectCoordinate(_vector3$1,_vector32);const t=e.map.projection.localFrameToFixedFrame(_vector32,_matrix4$2);n.applyMatrix4(t)}else{const t=e.map.projection.localFrameToFixedFrame(i.position,_matrix4$2);n.applyMatrix4(t)}if(s&&e.scene.environment===this._envTexture&&(e.map.getCameraLocation(_vector3$1),_vector3$1.z<this._fadeHeightStart)){const t=`${Math.round(_vector3$1.x/10)}-${Math.round(_vector3$1.y/10)}`;t!==this._envCaptureLocationKey&&(this._envCaptureLocationKey=t,this._renderEnvTexture(),this._envTexture=this._envRT.texture,e.scene.environment=this._envTexture)}}_onLocalTransform(e){e.rotateX(Math.PI/2),e.scale.setScalar(1e4)}_renderEnvTexture(){if(!this._cubeRenderTarget){const e=this._cubeRenderTarget=new three.WebGLCubeRenderTarget(256);e.texture.type=three.HalfFloatType,e.texture.minFilter=three.LinearFilter,e.texture.magFilter=three.LinearFilter,e.texture.generateMipmaps=!1,this._cubeCamera=new three.CubeCamera(1,1e3,e)}const e=this._mesh,t=e.position.clone();e.position.set(0,0,0),this._cubeCamera.update(this._engine.renderer,e),e.position.copy(t),this._envRT=this._PMREMGenerator.fromCubemap(this._cubeRenderTarget.texture,this._envRT)}_loadSkyTexture(){if(!this._engine||!this._textureURL)return;let e=null;e=this._textureIsHDR?this._textureIsCube?new HDRCubeTextureLoader:new RGBELoader:this._textureIsCube?new three.CubeTextureLoader:new three.TextureLoader;const t=this._engine.rendering.scene;let i=null;this._textureIsCube?(e.setPath(this._textureURL),i=this._textureNames?this._textureNames:this._textureIsHDR?["nz.HDR","pz.HDR","px.HDR","nx.HDR","py.HDR","ny.HDR"]:["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]):i=this._textureURL,e.load(i,(e=>{this._textureIsCube?(this._mesh.visible=!1,e.colorSpace=three.SRGBColorSpace,t.background=e,this._envTexture=this._PMREMGenerator.fromCubemap(e).texture,this._affectWorld&&(t.environment=this._envTexture)):(t.background=null,this._mesh.visible=!0,e.colorSpace=three.SRGBColorSpace,this._material.map=e,this._material.needsUpdate=!0,this._isVerticalTexture?t.environment=null:(this._renderEnvTexture(),this._envTexture=this._envRT.texture,this._affectWorld&&(t.environment=this._envTexture))),this._engine.requestRender()}))}get isVerticalTexture(){return this._verticalTexture}set isVerticalTexture(e){e!==this._isVerticalTexture&&(this._material&&this._material.dispose(),this._material=new StaticSkyMaterial,this._isVerticalTexture=e,this._mesh&&(this._mesh.material=this._material))}set textureIsCube(e){this._textureIsCube=e}get textureIsCube(){return this._textureIsCube}get textureURL(){return this._textureURL}set textureURL(e){this._textureURL=e,this._loadSkyTexture()}get affectWorld(){return this._affectWorld}set affectWorld(e){const t=this._engine.rendering.scene;e?(this._affectWorld=!0,t.environment=this._envTexture):(this._affectWorld=!1,t.environment===this._envTexture&&(t.environment=null))}}class StaticSky extends CustomStaticSky{constructor(){super(...arguments),__publicField(this,"isStaticSky",!0),__publicField(this,"name","StaticSky"),__publicField(this,"weather","clear"),__publicField(this,"_phase","default"),__publicField(this,"_lastPhase",null),__publicField(this,"_lastWeather",null),__publicField(this,"_nightStartTime",64800),__publicField(this,"_nightEndTime",21600),__publicField(this,"_afternoonTime",55800),__publicField(this,"_duskTime",61200),__publicField(this,"_engine",null)}_onLocalTransform(e){super._onLocalTransform(e),e.rotateY(Math.PI)}onTimeChanged(e){e>=this._nightStartTime||e<=this._nightEndTime?this._phase="night":e>=this._duskTime?this._phase="dusk":e>=this._afternoonTime?this._phase="afternoon":this._phase="default",this.loadSkyTexture()}onWeatherChanged(e){this._weather=e,this.loadSkyTexture()}loadSkyTexture(){if(!this._engine||this._phase===this._lastPhase&&this.weather===this._lastWeather)return;let e=urlJoin(getBaseUrl(),"assets/textures/sky",this.weather,this._phase,"/"+this._phase+".jpg");this.textureURL=e,this._lastPhase=this._phase,this._lastWeather=this._weather}}const http$9="http:"===window.location.protocol?"http:":"https:",styleMap={[STADIA_MAP_STYLE_STAMEN_WATERCOLOR]:`${http$9}//tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{reverseY}.jpg`,[STADIA_MAP_STYLE_STAMEN_TONER]:`${http$9}//tiles.stadiamaps.com/tiles/stamen_toner/{z}/{x}/{reverseY}@2x.png`,[STADIA_MAP_STYLE_ALIDE_SMOOTH]:`${http$9}//tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{reverseY}@2x.png`,[STADIA_MAP_STYLE_ALIDE_SMOOTH_DARK]:`${http$9}//tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{reverseY}@2x.png`,[STADIA_MAP_STYLE_OUTDOORS]:`${http$9}//tiles.stadiamaps.com/tiles/outdoors/{z}/{x}/{reverseY}@2x.png`};class StadiaImageryTileProvider extends ImageryTileProvider{constructor(e={}){super({...e,projection:PROJECTION_WEB_MERCATOR}),__publicField(this,"name","StadiaImageryTileProvider"),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_WEB_MERCATOR,PROJECTION_GEO]),__publicField(this,"_defaultStartLevel",1),__publicField(this,"_defaultMaxLevel",18),__publicField(this,"_maxParallelRequestNum",24),__publicField(this,"_useWebMeractorProjectionAndGrid",!0),this._style=e.style||STADIA_MAP_STYLE_STAMEN_WATERCOLOR,this._replaceStr={x:"{x}",y:"{y}",z:"{z}",reverseY:"{reverseY}"}}get style(){return this._style}set style(e){this._style!==e&&(this._style=e,this._needsClearCache=!0)}getTileURL(e,t,i,n){return styleMap[this._style].replaceAll(this._replaceStr.x,t).replaceAll(this._replaceStr.y,i).replaceAll(this._replaceStr.reverseY,n.reverseY).replaceAll(this._replaceStr.z,e)}}const http$8="http:"===window.location.protocol?"http:":"https:",osmUrls=[`${http$8}//tile.osm.org`,`${http$8}//a.tile.osm.org`,`${http$8}//b.tile.osm.org`,`${http$8}//c.tile.osm.org`];class OSMImageryTileProvider extends ImageryTileProvider{constructor(e){super({...e,projection:PROJECTION_WEB_MERCATOR}),__publicField(this,"name","OSMImageryTileProvider"),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_WEB_MERCATOR,PROJECTION_GEO]),__publicField(this,"_defaultStartLevel",1),__publicField(this,"_defaultMaxLevel",18),__publicField(this,"_maxParallelRequestNum",24),__publicField(this,"_useWebMeractorProjectionAndGrid",!0)}getTileURL(e,t,i,n){const r=Math.abs(t+i)%osmUrls.length;return`${osmUrls[r]}/${e}/${t}/${n.reverseY}.png`}}class TiandituImageryTileProvider extends ImageryTileProvider{constructor(e={}){super({...e}),__publicField(this,"name","TiandituImageryTileProvider"),__publicField(this,"_tk",""),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_GEO,PROJECTION_WEB_MERCATOR]),__publicField(this,"_defaultMaxLevel",18),this._tk=e.tk||TiandituConfig.tk}initProjectionAndGrid(){this._sourceProjection=this._targetProjection,this._sourceProjection.name===PROJECTION_WEB_MERCATOR?this._grid=new WebMercatorGrid(this._engine,this._sourceProjection,this._targetProjection):this._sourceProjection.name===PROJECTION_GEO&&(this._grid=new GeoGrid(this._engine,this._sourceProjection,this._targetProjection))}getTileURL(e,t,i,n){const r=this._sourceProjection.name===PROJECTION_GEO?"vec_c":"vec_w";return`https://t2.tianditu.gov.cn/DataServer?tk=${this._tk}&T=${r}&x=${t}&y=${n.reverseY}&l=${e}`}}class XYZImageryTileProvider extends ImageryTileProvider{constructor(e={}){if(super(e),__publicField(this,"name","XYZImageryTileProvider"),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_WEB_MERCATOR,PROJECTION_GEO]),__publicField(this,"_maxParallelRequestNum",24),__publicField(this,"_url",null),!e.url)throw new Error("XYZImageryTileProvider: url is required");this._replaceStr={x:"{x}",z:"{z}",y:"{reverseY}",reverseY:"{y}"},void 0!==this._maxLevel&&this._maxLevel!==1/0||(this._maxLevel=18),this._url=e.url,this._defaultXYZProjectionName=e.projection||PROJECTION_WEB_MERCATOR}initProjectionAndGrid(){this._defaultXYZProjectionName===PROJECTION_WEB_MERCATOR?(this._sourceProjection=getProjection(PROJECTION_WEB_MERCATOR),this._grid=new WebMercatorGrid(this._engine,this._sourceProjection,this._targetProjection)):this._defaultXYZProjectionName===PROJECTION_GEO&&(this._sourceProjection=getProjection(PROJECTION_GEO),this._grid=new GeoGrid(this._engine,this._sourceProjection,this._targetProjection))}getTileURL(e,t,i,n){return this._url.replaceAll(this._replaceStr.x,t).replaceAll(this._replaceStr.y,i).replaceAll(this._replaceStr.reverseY,n.reverseY).replaceAll(this._replaceStr.z,e)}}class Baidu09ImageryTileProvider extends ImageryTileProvider{constructor(e={}){super({...e}),__publicField(this,"name","Baidu09ImageryTileProvider"),__publicField(this,"isBaiduProvider",!0),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_WEB_MERCATOR,PROJECTION_GEO]),__publicField(this,"_defaultStartLevel",3),__publicField(this,"_defaultMaxLevel",19),__publicField(this,"_maxParallelRequestNum",24),__publicField(this,"_type",null);const t=e.ak||BaiduMapConfig.ak;this._ak=t,this._type=e.type}initProjectionAndGrid(){this._sourceProjection=getProjection(PROJECTION_BD_MERCATOR),this._grid=new BaiduImageryGrid(this._engine,this._sourceProjection,this._targetProjection)}getTileURL(e,t,i,n){if(e<3)return!1;const[r,s,a]=n.grid.getRasterTileCoord(e,t,i);return"satellite"===this._type?`https://apimaponline${Math.abs(t+i)%4}.bdimg.com/starpic/?qt=satepc&ak=${this._ak}&u=x=${s};y=${a};z=${r};v=009;type=sate&fm=46&app=webearth2&udt=20250724&v=009&from=mapvthree`:`https://apimaponline${Math.abs(t+i)%4}.bdimg.com/tile/?qt=vtile&v=three&ak=${this._ak}&x=${s}&y=${a}&z=${r}&styles=pl&scaler=2&udt=20211014&from=mapvthree`}}class WMSImageryTileProvider extends ImageryTileProvider{constructor(e={}){if(super(e),__publicField(this,"name","WMSImageryTileProvider"),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_WEB_MERCATOR,PROJECTION_GEO]),__publicField(this,"_maxParallelRequestNum",24),__publicField(this,"_defaultMaxLevel",18),__publicField(this,"_url",null),__publicField(this,"_serverType",null),__publicField(this,"_hidpi",!1),__publicField(this,"_devicePixelRatio",1),!e.url)throw new Error("WMSImageryTileProvider: url is required");this._replaceStr={x:"{x}",y:"{y}",z:"{z}",b:"{b}",reverseY:"{reverseY}"},this._url=e.url,this._baseUrl=e.url.split("?")[0],this._params=e.params||{},this._serverType=e.serverType,this._hidpi=e.hidpi||!1,this._setWmsParams()}_setWmsParams(){const e=this.getUrlParams(this._url);this._params=Object.assign({SERVICE:"WMS",VERSION:"1.3.0",REQUEST:"GetMap",FORMAT:"image/png",TRANSPARENT:!0,LAYERS:"",WIDTH:256,HEIGHT:256,STYLES:"",BBOX:"{b}"},this._getUppercaseKeys(e),this._getUppercaseKeys(this._params)),this._params.TRANSPARENT=void 0===this._params.TRANSPARENT||("true"===this._params.TRANSPARENT||!0===this._params.TRANSPARENT),this._params.WIDTH=parseInt(this._params.WIDTH||this._params.width||"256",10),this._params.HEIGHT=parseInt(this._params.HEIGHT||this._params.height||"256",10);this._compareVersions(this._params.VERSION,"1.3")>=0?this._params.CRS=this._params.CRS||this._params.crs||PROJECTION_WEB_MERCATOR:this._params.SRS=this._params.SRS||this._params.srs||PROJECTION_WEB_MERCATOR}getHiDPIParams(){if(this._engine&&this._engine.rendering&&(this._devicePixelRatio=this._engine.rendering.pixelRatio),this._hidpi&&!(this._devicePixelRatio<=1))switch(this._serverType){case"geoserver":const e=90*this._devicePixelRatio+.5|0;"FORMAT_OPTIONS"in this._params?this._params.FORMAT_OPTIONS+=";dpi:"+e:this._params.FORMAT_OPTIONS="dpi:"+e;break;case"mapserver":this._params.MAP_RESOLUTION=90*this._devicePixelRatio;break;case"carmentaserver":case"qgis":this._params.DPI=90*this._devicePixelRatio;break;default:throw new Error("Unknown `serverType` configured")}}_getUppercaseKeys(e){const t={};for(const i in e)t[i.toUpperCase()]=e[i];return t}initProjectionAndGrid(){this.getHiDPIParams();const e=this._params,t=e.CRS||e.SRS||PROJECTION_WEB_MERCATOR,i=this._normalizeProjectionName(t);i===PROJECTION_WEB_MERCATOR?(this._sourceProjection=getProjection(PROJECTION_WEB_MERCATOR),this._grid=new WebMercatorGrid(this._engine,this._sourceProjection,this._targetProjection)):i===PROJECTION_GEO&&(this._sourceProjection=getProjection(PROJECTION_GEO),this._grid=new GeoGrid(this._engine,this._sourceProjection,this._targetProjection))}_normalizeProjectionName(e){if(!e)return PROJECTION_WEB_MERCATOR;const t=e.toUpperCase().trim();return{"EPSG:900913":PROJECTION_WEB_MERCATOR,"EPSG:3857":PROJECTION_WEB_MERCATOR,"EPSG:4326":PROJECTION_GEO,"CRS:84":PROJECTION_GEO,"OGC:CRS84":PROJECTION_GEO}[t]||t}_compareVersions(e,t){const i=e.split(".").map(Number),n=t.split(".").map(Number);for(let r=0;r<Math.max(i.length,n.length);r++){const e=i[r]||0,t=n[r]||0;if(e<t)return-1;if(e>t)return 1}return 0}_formatBbox(e,t,i){const{min:n,max:r}=e;let s=Math.max(n.x,t?-180:-20037508.342789244),a=Math.max(n.y,t?-90:-20037508.342789244),o=Math.min(r.x,t?180:20037508.342789244),l=Math.min(r.y,t?90:20037508.342789244),c=[s,a,o,l];return this._compareVersions(i,"1.3")>=0&&t&&(c=[a,s,l,o]),c.join(",")}appendParams(e,t){const i=[];Object.keys(t).forEach((e=>{if(null!==t[e]&&void 0!==t[e]){let n=t[e];Object.values(this._replaceStr).some((e=>"string"==typeof n&&n.indexOf(e)>=0))||(n=encodeURIComponent(n)),i.push(e+"="+n)}}));const n=i.join("&");return e=e.replace(/[?&]$/,""),(e+=e.includes("?")?"&":"?")+n}getUrlParams(e){const t=e.split("?").pop().split("#").shift().split("&");let i={};return t.forEach((e=>{if(e){const[t,n]=e.split("=");t&&void 0!==n&&(i[t]=decodeURIComponent(n))}})),i}getTileURL(e,t,i,n){let r=this.appendParams(this._baseUrl,this._params);const{min:s,max:a}=this._sourceProjection.isGeo?n.geoBoundingBox:n.projectedBoundingBox,o=this._formatBbox({min:s,max:a},this._sourceProjection.isGeo,this._params.VERSION);return r=r.replaceAll(this._replaceStr.b,o),r}setParams(e){this._params={...this._params,...e},this._needsClearCache=!0}getParams(){return{...this._params}}}class WMTSImageryTileProvider extends ImageryTileProvider{constructor(e={}){if(super(e),__publicField(this,"name","WMTSImageryTileProvider"),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_WEB_MERCATOR,PROJECTION_GEO]),__publicField(this,"_maxParallelRequestNum",24),__publicField(this,"_defaultMaxLevel",18),__publicField(this,"_url",null),__publicField(this,"_requestEncoding","KVP"),__publicField(this,"_matrixIds",null),!e.url)throw new Error("WMTSImageryTileProvider: url is required");this._replaceStr={x:"{x}",y:"{y}",z:"{z}",reverseY:"{reverseY}"},this._url=e.url,this._baseUrl=e.url.split("?")[0],this._params=e.params||{},this._matrixIds=e.matrixIds||null,this._requestEncoding=e.requestEncoding||"KVP",this._setWmtsParams()}_setWmtsParams(){const e=this.getUrlParams(this._url),t={LAYER:"",STYLE:"",TILEMATRIXSET:"EPSG:3857",TILEMATRIX:"{z}",TILEROW:"{y}",TILECOL:"{x}"};"KVP"===this._requestEncoding&&Object.assign(t,{SERVICE:"WMTS",REQUEST:"GetTile",VERSION:"1.0.0",FORMAT:"image/png"}),this._params=Object.assign(t,this._getUppercaseKeys(e),this._getUppercaseKeys(this._params))}_getUppercaseKeys(e){const t={};for(const i in e)t[i.toUpperCase()]=e[i];return t}initProjectionAndGrid(){const e=this._params.TILEMATRIXSET||"EPSG:3857",t=this._normalizeProjectionName(e);t===PROJECTION_WEB_MERCATOR?(this._sourceProjection=getProjection(PROJECTION_WEB_MERCATOR),this._grid=new WebMercatorGrid(this._engine,this._sourceProjection,this._targetProjection)):t===PROJECTION_GEO&&(this._sourceProjection=getProjection(PROJECTION_GEO),this._grid=new GeoGrid(this._engine,this._sourceProjection,this._targetProjection))}_normalizeProjectionName(e){if(!e)return PROJECTION_WEB_MERCATOR;const t=e.toUpperCase().trim();return{"EPSG:900913":PROJECTION_WEB_MERCATOR,"EPSG:3857":PROJECTION_WEB_MERCATOR,"EPSG:4326":PROJECTION_GEO,"CRS:84":PROJECTION_GEO,"OGC:CRS84":PROJECTION_GEO,GOOGLEMAPSCOMPATIBLE:PROJECTION_WEB_MERCATOR,WGS84:PROJECTION_GEO,WGS84QUAD:PROJECTION_GEO,DEFAULT028MM:PROJECTION_WEB_MERCATOR}[t]||t}appendParams(e,t){const i=[];Object.keys(t).forEach((e=>{if(null!==t[e]&&void 0!==t[e]){let n=t[e];Object.values(this._replaceStr).some((e=>"string"==typeof n&&n.indexOf(e)>=0))||(n=encodeURIComponent(n)),i.push(e+"="+n)}}));const n=i.join("&");return e=e.replace(/[?&]$/,""),(e+=e.includes("?")?"&":"?")+n}getUrlParams(e){const t=e.split("?").pop().split("#").shift().split("&");let i={};return t.forEach((e=>{if(e){const[t,n]=e.split("=");t&&void 0!==n&&(i[t]=decodeURIComponent(n))}})),i}getTileURL(e,t,i,n){const r=this._getTileMatrixValue(e),s={...this._params};this._matrixIds&&Array.isArray(this._matrixIds)&&void 0!==this._matrixIds[e]&&(s.TILEMATRIX=r);let a="";return"REST"===this._requestEncoding?(a=this._url,a=a.replace(/(\{layer\})/gi,s.LAYER).replace(/(\{style\})/gi,s.STYLE).replace(/(\{tilematrixset\})/gi,s.TILEMATRIXSET).replace(/(\{tilematrix\})/gi,s.TILEMATRIX).replace(/(\{tilerow\})/gi,s.TILEROW).replace(/(\{tilecol\})/gi,s.TILECOL)):a=this.appendParams(this._baseUrl,s),a=a.replaceAll(this._replaceStr.x,t).replaceAll(this._replaceStr.y,n.reverseY).replaceAll(this._replaceStr.z,r),a}_getTileMatrixValue(e){return this._matrixIds&&Array.isArray(this._matrixIds)&&void 0!==this._matrixIds[e]?this._matrixIds[e]:e}setParams(e){this._params={...this._params,...e},this._needsClearCache=!0}getParams(){return{...this._params}}}const IndexDatatype={UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,UNSIGNED_INT:5125,getSizeInBytes:function(e){switch(e){case IndexDatatype.UNSIGNED_BYTE:return Uint8Array.BYTES_PER_ELEMENT;case IndexDatatype.UNSIGNED_SHORT:return Uint16Array.BYTES_PER_ELEMENT;case IndexDatatype.UNSIGNED_INT:return Uint32Array.BYTES_PER_ELEMENT}throw new DeveloperError("indexDatatype is required and must be a valid IndexDatatype constant.")},fromSizeInBytes:function(e){switch(e){case 2:return IndexDatatype.UNSIGNED_SHORT;case 4:return IndexDatatype.UNSIGNED_INT;case 1:return IndexDatatype.UNSIGNED_BYTE;default:throw new DeveloperError("Size in bytes cannot be mapped to an IndexDatatype")}},validate:function(e){return defined$2(e)&&(e===IndexDatatype.UNSIGNED_BYTE||e===IndexDatatype.UNSIGNED_SHORT||e===IndexDatatype.UNSIGNED_INT)},createTypedArray:function(e,t){if(!defined$2(e))throw new DeveloperError("numberOfVertices is required.");return e>=CesiumMath.SIXTY_FOUR_KILOBYTES?new Uint32Array(t):new Uint16Array(t)},createTypedArrayFromArrayBuffer:function(e,t,i,n){if(!defined$2(e))throw new DeveloperError("numberOfVertices is required.");if(!defined$2(t))throw new DeveloperError("sourceArray is required.");if(!defined$2(i))throw new DeveloperError("byteOffset is required.");return e>=CesiumMath.SIXTY_FOUR_KILOBYTES?new Uint32Array(t,i,n):new Uint16Array(t,i,n)},fromTypedArray:function(e){if(e instanceof Uint8Array)return IndexDatatype.UNSIGNED_BYTE;if(e instanceof Uint16Array)return IndexDatatype.UNSIGNED_SHORT;if(e instanceof Uint32Array)return IndexDatatype.UNSIGNED_INT;throw new DeveloperError("array must be a Uint8Array, Uint16Array, or Uint32Array.")}},IndexDatatype$1=Object.freeze(IndexDatatype),arrayScratch=[],QuantizedMeshExtensionIds={OCT_VERTEX_NORMALS:1,WATER_MASK:2,METADATA:4};function sortIndicesIfNecessary(e,t,i){arrayScratch.length=e.length;let n=!1;for(let r=0,s=e.length;r<s;++r)arrayScratch[r]=e[r],n=n||r>0&&t(e[r-1],e[r])>0;return n?(arrayScratch.sort(t),IndexDatatype$1.createTypedArray(i,arrayScratch)):e}function zigZagDecode(e){return e>>1^-(1&e)}function zigZagDeltaDecode(e,t,i){const n=e.length;let r=0,s=0,a=0;for(let o=0;o<n;++o)r+=zigZagDecode(e[o]),s+=zigZagDecode(t[o]),e[o]=r,t[o]=s,defined$2(i)&&(a+=zigZagDecode(i[o]),i[o]=a)}class QuantizedMeshTerrainData{constructor(e){if(!defined$2(e)||!defined$2(e.quantizedVertices))throw new DeveloperError("options.quantizedVertices is required.");if(!defined$2(e.indices))throw new DeveloperError("options.indices is required.");if(!defined$2(e.minimumHeight))throw new DeveloperError("options.minimumHeight is required.");if(!defined$2(e.maximumHeight))throw new DeveloperError("options.maximumHeight is required.");if(!defined$2(e.maximumHeight))throw new DeveloperError("options.maximumHeight is required.");if(!defined$2(e.westIndices))throw new DeveloperError("options.westIndices is required.");if(!defined$2(e.southIndices))throw new DeveloperError("options.southIndices is required.");if(!defined$2(e.eastIndices))throw new DeveloperError("options.eastIndices is required.");if(!defined$2(e.northIndices))throw new DeveloperError("options.northIndices is required.");this._quantizedVertices=e.quantizedVertices,this._encodedNormals=e.encodedNormals,this._indices=e.indices,this._minimumHeight=e.minimumHeight,this._maximumHeight=e.maximumHeight,this._boundingSphere=e.boundingSphere,this._horizonOcclusionPoint=e.horizonOcclusionPoint;const t=this._quantizedVertices.length/3,i=this._uValues=this._quantizedVertices.subarray(0,t),n=this._vValues=this._quantizedVertices.subarray(t,2*t);function r(e,t){return n[e]-n[t]}function s(e,t){return i[e]-i[t]}this._heightValues=this._quantizedVertices.subarray(2*t,3*t),this._westIndices=sortIndicesIfNecessary(e.westIndices,r,t),this._southIndices=sortIndicesIfNecessary(e.southIndices,s,t),this._eastIndices=sortIndicesIfNecessary(e.eastIndices,r,t),this._northIndices=sortIndicesIfNecessary(e.northIndices,s,t),this._childTileMask=defaultValue$1(e.childTileMask,15),this._mesh=void 0}static createQuantizedMeshTerrainData(e,t){let i=0;const n=3*Float64Array.BYTES_PER_ELEMENT,r=4*Float64Array.BYTES_PER_ELEMENT,s=3*Uint16Array.BYTES_PER_ELEMENT;let a=Uint16Array.BYTES_PER_ELEMENT,o=3*a;const l=new DataView(t);i+=n;const c=l.getFloat32(i,!0);i+=Float32Array.BYTES_PER_ELEMENT;const h=l.getFloat32(i,!0);i+=Float32Array.BYTES_PER_ELEMENT;const u={center:new three.Vector3(l.getFloat64(i,!0),l.getFloat64(i+8,!0),l.getFloat64(i+16,!0)),radius:l.getFloat64(i+n,!0)};i+=r;const d=new three.Vector3(l.getFloat64(i,!0),l.getFloat64(i+8,!0),l.getFloat64(i+16,!0));i+=n;const p=l.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const m=new Uint16Array(t,i,3*p);i+=p*s,p>65536&&(a=Uint32Array.BYTES_PER_ELEMENT,o=3*a);zigZagDeltaDecode(m.subarray(0,p),m.subarray(p,2*p),m.subarray(2*p,3*p)),i%a!==0&&(i+=a-i%a);const f=l.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const g=IndexDatatype$1.createTypedArrayFromArrayBuffer(p,t,i,3*f);i+=f*o;let _=0;const A=g.length;for(let w=0;w<A;++w){const e=g[w];g[w]=_-e,0===e&&++_}const v=l.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const y=IndexDatatype$1.createTypedArrayFromArrayBuffer(p,t,i,v);i+=v*a;const x=l.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const b=IndexDatatype$1.createTypedArrayFromArrayBuffer(p,t,i,x);i+=x*a;const S=l.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const C=IndexDatatype$1.createTypedArrayFromArrayBuffer(p,t,i,S);i+=S*a;const T=l.getUint32(i,!0);i+=Uint32Array.BYTES_PER_ELEMENT;const E=IndexDatatype$1.createTypedArrayFromArrayBuffer(p,t,i,T);let M;for(i+=T*a;i<l.byteLength;){const n=l.getUint8(i,!0);i+=Uint8Array.BYTES_PER_ELEMENT;const r=!0,s=l.getUint32(i,r);i+=Uint32Array.BYTES_PER_ELEMENT,n===QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS&&e.hasVertexNormals&&(M=new Uint8Array(t,i,2*p)),i+=s}return new QuantizedMeshTerrainData({minimumHeight:c,maximumHeight:h,boundingSphere:u,horizonOcclusionPoint:d,quantizedVertices:m,encodedNormals:M,indices:g,westIndices:y,southIndices:b,eastIndices:C,northIndices:E})}}class TerrainMesh{constructor(e,t,i,n,r,s,a,o,l,c,h,u,d,p,m,f){this.center=e,this.vertices=t,this.stride=defaultValue$1(c,6),this.indices=i,this.indexCountWithoutSkirts=n,this.vertexCountWithoutSkirts=r,this.minimumHeight=s,this.maximumHeight=a,this.boundingSphere3D=o,this.occludeePointInScaledSpace=l,this.orientedBoundingBox=h,this.encoding=u,this.westIndicesSouthToNorth=d,this.southIndicesEastToWest=p,this.eastIndicesNorthToSouth=m,this.northIndicesWestToEast=f}}class AsyncCesiumTerrainDataLoader{constructor(e,t,i){this.provider=e,this._workerTaskScheduler=new WorkerTaskScheduler(t,i),this._workerTaskScheduler.getResponseMessageId=this.getResponseMessageId,this._workerTaskScheduler.isMessageCompleted=this.isMessageCompleted}isMessageCompleted(e,t){return"terrainMeshCreated"===e.type||"terrainDataUpsampled"===e.type}getResponseMessageId(e,t){return e.tileKey}_vectorToArray(e){return[e.x,e.y,e.z]}_boxToArray(e){return[e.min.x,e.min.y,e.min.z,e.max.x,e.max.y,e.max.z]}async upsample(e,t,i){const n=this.provider,r=n._engine.map.map._ellipsoid,s=n.hasVertexNormals,a=t.x,o=t.y,l=i.x,c=i.y;if(!defined$2(e)||!defined$2(e._mesh))return;const h=e._mesh,u=2*a!==l,d=2*o!==c,p=Rectangle.fromBox(i.geoBoundingBox),m="upsampleTerrainData",f={type:m,tileKey:i.key,isEastChild:u,isNorthChild:d,childRectangle:p,ellipsoid:r,vertices:h.vertices,indices:h.indices,vertexCountWithoutSkirts:h.vertexCountWithoutSkirts,indexCountWithoutSkirts:h.indexCountWithoutSkirts,minimumHeight:h.minimumHeight,maximumHeight:h.maximumHeight,hasVertexNormals:s};if(n.getFetchOptions){const e=n.getFetchOptions(i);f.fetchOptions=e}if(n.getWorkerOptions){const e=n.getWorkerOptions(i);f.workerOptions=e}let g=await this._workerTaskScheduler.postMessage(f,[],m+"-"+i.key);g=g.content;const _=new Uint16Array(g.vertices),A=IndexDatatype$1.createTypedArray(_.length/3,g.indices);return new QuantizedMeshTerrainData({quantizedVertices:_,indices:A,minimumHeight:g.minimumHeight,maximumHeight:g.maximumHeight,westIndices:g.westIndices,southIndices:g.southIndices,eastIndices:g.eastIndices,northIndices:g.northIndices,encodedNormals:g.encodedNormals,childTileMask:0})}async requestTile(e){const t=this.provider;let i,n=t.getTileURL(e.z,e.x,e.y,e);try{const r=t.getFetchOptions(e);i=await reFetch(n,{responseType:"arraybuffer",...r}).then((e=>e.arrayBuffer()))}catch(r){return void console.warn("no tile")}if(!i)return Promise.reject("Mesh buffer dosen't exist");return QuantizedMeshTerrainData.createQuantizedMeshTerrainData(t,i)}async createMesh(e,t,i){const n=this.provider,r=n._engine.map.map._ellipsoid,s=Rectangle.fromBox(t.geoBoundingBox),a="createTerrainMesh";let o=t.targetCenter;const l={type:a,tileKey:t.key,tileCenter:o,minimumHeight:e._minimumHeight,maximumHeight:e._maximumHeight,quantizedVertices:e._quantizedVertices,indices:e._indices,westIndices:e._westIndices,southIndices:e._southIndices,eastIndices:e._eastIndices,northIndices:e._northIndices,rectangle:s,level:t.z,ellipsoid:r,sourceProjectionName:n.sourceProjection.name,targetProjectionName:n.targetProjection.name,octEncodedNormals:e._encodedNormals};if(n.getFetchOptions){const e=n.getFetchOptions(t);l.fetchOptions=e}if(n.getWorkerOptions){const e=n.getWorkerOptions(t);l.workerOptions=e}const c=await this._workerTaskScheduler.postMessage(l,[],a+"-"+t.key);if(!defined$2(c.content))return;const h=c.content,u=e._quantizedVertices.length/3,d=u+e._westIndices.length+e._southIndices.length+e._eastIndices.length+e._northIndices.length,p=IndexDatatype$1.createTypedArray(d,h.indices),m=new Float32Array(h.vertices),f=h.center,g=h.minimumHeight,_=h.maximumHeight;return e._mesh=new TerrainMesh(f,m,p,h.indexCountWithoutSkirts,u,g,_,void 0,void 0,void 0,void 0,void 0,h.westIndicesSouthToNorth,h.southIndicesEastToWest,h.eastIndicesNorthToSouth,h.northIndicesWestToEast),e._quantizedVertices=void 0,e._encodedNormals=void 0,e._indices=void 0,e._uValues=void 0,e._vValues=void 0,e._heightValues=void 0,e._westIndices=void 0,e._southIndices=void 0,e._eastIndices=void 0,e._northIndices=void 0,e._mesh}postMessageToAll(e,t){this._workerTaskScheduler.postMessageToAll(e,t)}}function WorkerWrapper$1(){return new Worker(getAssetUrl('assets/workers/CesiumTerrainParser.worker-ba35b937.js'),{type:"module"})}new three.Vector3,new three.Vector3;const upsampleTileKey=new three.Vector3;class CesiumTerrainTileProvider extends PlaneTerrainTileProvider{constructor(e={}){super(e),__publicField(this,"name","CesiumTerrainTileProvider"),__publicField(this,"_supportedTargetProjectionNames",[PROJECTION_ECEF,PROJECTION_WEB_MERCATOR,PROJECTION_GEO]),__publicField(this,"_url","https://assets.ion.cesium.com/ap-northeast-1/asset_depot/1/CesiumWorldTerrain/v1.2"),__publicField(this,"_defaultMaxLevel",16),__publicField(this,"_shouldCheckTileAvailable",!0),__publicField(this,"_canUpsample",!0),__publicField(this,"_isDefaultCesium",!0),this._accessToken=e.accessToken||CesiumConfig.accessToken,this._requestVertexNormals=e.requestVertexNormals||!0,e.url&&(this._url=e.url,this._isDefaultCesium=!1)}initProjectionAndGrid(){const e=this._sourceProjection.name;e===PROJECTION_WEB_MERCATOR?this._grid=new WebMercatorGrid(this._engine,this._sourceProjection,this._targetProjection):e===PROJECTION_GEO&&(this._grid=new GeoGrid(this._engine,this._sourceProjection,this._targetProjection));const t=this._targetProjection.name;let i=null;i=getProjection(e===PROJECTION_WEB_MERCATOR&&t===PROJECTION_WEB_MERCATOR?PROJECTION_WEB_MERCATOR:PROJECTION_GEO),this.rasterProjection=i,this._grid.rasterProjection=i}async _asyncInit(){await this._refreshAccessToken();let e=null;const t={};this._isDefaultCesium&&(e={Accept:"application/json",Authorization:"Bearer "+this._sessionToken},t.headers=e);const i=await reFetch(`${this._url}/layer.json`,t).then((e=>e.json()));let n=!1,r=!0;i.extensions&&-1!==i.extensions.indexOf("octvertexnormals")?n=!0:i.extensions&&-1!==i.extensions.indexOf("vertexnormals")&&(n=!0,r=!1),this.hasVertexNormals=n&&this._requestVertexNormals,this.littleEndianExtensionSize=r,this._layerConfig=i,this._urlTemplate=this._url+"/"+i.tiles[0],this._version=i.version;const s=this._availableTiles=i.available;this._maxLevel=s.length-1;const a=i.projection||PROJECTION_GEO;this._sourceProjection=getProjection(a),this._dataLoader=new AsyncCesiumTerrainDataLoader(this,WorkerWrapper$1,2)}async _refreshAccessToken(){if(!this._isDefaultCesium)return;const e=await reFetch(`https://api.cesium.com/v1/assets/1/endpoint?access_token=${this._accessToken}`,{headers:{Accept:"application/json",Authorization:"Bearer "+this._accessToken}}).then((e=>e.json()));this._sessionToken=e.accessToken,this._lastRefreshTokenTime=Date.now()}async _checkAndRefreshAccessToken(){this._isDefaultCesium&&Date.now()-this._lastRefreshTokenTime>36e5&&await this._refreshAccessToken()}getTileURL(e,t,i,n){return this._urlTemplate.replace("{version}",this._version).replace("{z}",this._sourceProjection.name===PROJECTION_GEO?e-1:e).replace("{x}",t).replace("{y}",i)}getFetchOptions(){return this._isDefaultCesium?{headers:{Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01",Authorization:"Bearer "+this._sessionToken}}:{}}isTileAvailable(e,t,i){this._sourceProjection.name===PROJECTION_GEO&&(e-=1);const n=this._availableTiles;if(!n||0===n.length)return;if(e>=n.length)return!1;const r=n[e];for(let s=0,a=r.length;s<a;++s){const e=r[s];if(t>=e.startX&&t<=e.endX&&i>=e.startY&&i<=e.endY)return!0}return!1}async doRequestTileData(e){let t,i;if(this._targetProjection.name,await this._checkAndRefreshAccessToken(),e.needUpSample){const i=e.parentKey.split("-").map((e=>+e));upsampleTileKey.set(i[1],i[2],i[0]);const n=this._quadtree.getTile(upsampleTileKey.z,upsampleTileKey.x,upsampleTileKey.y);t=await this._dataLoader.upsample(n.terrainData,upsampleTileKey,e)}else t=await this._dataLoader.requestTile(e),e.quantizedMesh=t;if(e.terrainData=t,t&&(i=await this._dataLoader.createMesh(t,e,{})),!i)return super.doRequestTileData(e);const n=new three.BufferGeometry;let r;return this.hasVertexNormals?(r=new three.InterleavedBuffer(i.vertices,9),n.setAttribute("normal",new three.InterleavedBufferAttribute(r,3,6))):r=new three.InterleavedBuffer(i.vertices,6),n.setAttribute("position",new three.InterleavedBufferAttribute(r,3,0)),n.setAttribute("uv",new three.InterleavedBufferAttribute(r,2,4)),n.setIndex(new three.BufferAttribute(i.indices,1)),n._heights=[i.minimumHeight,i.maximumHeight],n}}const _centerIn=new three.Vector3,_lastPosition=new three.Vector3,_currentPosition=new three.Vector3,_lineNormal=new three.Vector3,_offset=new three.Vector3,_segmentLines3D=(e,t,i,n,r,s,a,o,l,c,h,u,d,p,m,f)=>{const g=d.targetCenter,_=d.targetProjection,{sourceProjectionName:A,targetProjectionName:v}=d;let y=0;_centerIn.fromArray(g),_lastPosition.fromArray(a),_currentPosition.fromArray(o);let x=u.value;r.push(x,x),s.push(x,1,x,0);const b=_.getProjectedSurfaceNormal(_lastPosition,_lineNormal),S=_offset.copy(_currentPosition).sub(_lastPosition),C=_lineNormal.crossVectors(b,S).normalize();A!==v&&(_lastPosition.sub(_centerIn),_currentPosition.sub(_centerIn)),i.push(C.x,C.y,C.z,-C.x,-C.y,-C.z),e.push(_lastPosition.x,_lastPosition.y,_lastPosition.z,_lastPosition.x,_lastPosition.y,_lastPosition.z),t.push(l,l),y+=2,h||(n.push(c+0-2,c+1-2,c+2-2),n.push(c+2-2,c+1-2,c+3-2)),n.push(c,c+1,c+2),i.push(C.x,C.y,C.z,-C.x,-C.y,-C.z),e.push(_currentPosition.x,_currentPosition.y,_currentPosition.z,_currentPosition.x,_currentPosition.y,_currentPosition.z),t.push(l,l);return x+=(m&&f?getDistance(m,f):getDistance(a,o))/p,r.push(x,x),s.push(x,1,x,0),u.value=x,y+=2,n.push(c+2,c+1,c+3),4};function lineToMesh(e,t,i,n,r=1,s){let a=e;if(!Array.isArray(e[0])){a=[];for(let t=0;t<e.length;t+=3)a.push([e[t],e[t+1],e[t+2]])}let o=0,l=null,c=null,h=null;const u=[],d=[],p=[],m=[],f=[],g=[];let _;const A={value:0},v=s||a;let y=!0;for(let x=1,b=a.length-1;x<=b;x++){l=h||a[x-1],c=a[x];const e=h?s?s[a.indexOf(h)]:h:v[x-1],n=v[x],_=v[x+1];if(_&&isPointEqual(n,_)){h=l;continue}let b=0;b=_segmentLines3D(u,m,d,p,f,g,l,c,t,o,y,A,i,r,e,n),-1!==b&&(o+=b,h=null),y=!1}for(let x=0;x<g.length;x++)x%2==0&&(g[x]=A.value-g[x]);return n&&(_=new Array(f.length).fill(A.value)),{vertices:u,indices:p,normals:d,widths:m,lengths:f,totalLengths:_,uvs:g}}function fillFlatArray(e,t,i){i||(i=t.length);const n=i*e,r=new Array(n);for(let s=0,a=n-i+1;s<a;s+=i)for(let e=0;e<i;e++)r[s+e]=t[e];return r}const arrFeatureStyles=[[2,"rgba(79,210,125,1)",2,2,0,[],0,0],[2,"rgba(79,210,125,1)",3,2,0,[],0,0],[2,"rgba(79,210,125,1)",3,2,0,[],0,0],[2,"rgba(79,210,125,1)",5,2,0,[],0,0],[2,"rgba(79,210,125,1)",6,2,0,[],0,0],[2,"rgba(255,208,69,1)",2,2,0,[],0,0],[2,"rgba(255,208,69,1)",3,2,0,[],0,0],[2,"rgba(255,208,69,1)",3,2,0,[],0,0],[2,"rgba(255,208,69,1)",5,2,0,[],0,0],[2,"rgba(255,208,69,1)",6,2,0,[],0,0],[2,"rgba(232,14,14,1)",2,2,0,[],0,0],[2,"rgba(232,14,14,1)",3,2,0,[],0,0],[2,"rgba(232,14,14,1)",3,2,0,[],0,0],[2,"rgba(232,14,14,1)",5,2,0,[],0,0],[2,"rgba(232,14,14,1)",6,2,0,[],0,0],[2,"rgba(181,0,0,1)",2,2,0,[],0,0],[2,"rgba(181,0,0,1)",3,2,0,[],0,0],[2,"rgba(181,0,0,1)",3,2,0,[],0,0],[2,"rgba(181,0,0,1)",5,2,0,[],0,0],[2,"rgba(181,0,0,1)",6,2,0,[],0,0],[2,"rgba(255,255,255,1)",4,0,0,[],0,0],[2,"rgba(255,255,255,1)",5.5,0,0,[],0,0],[2,"rgba(255,255,255,1)",7,0,0,[],0,0],[2,"rgba(255,255,255,1)",8.5,0,0,[],0,0],[2,"rgba(255,255,255,1)",10,0,0,[],0,0]];arrFeatureStyles[404]=[2,"rgba(204,204,204,1)",2,2,0,[],0,0],arrFeatureStyles[405]=[2,"rgba(204,204,204,1)",3,2,0,[],0,0],arrFeatureStyles[406]=[2,"rgba(204,204,204,1)",4,2,0,[],0,0],arrFeatureStyles[407]=[2,"rgba(204,204,204,1)",5,2,0,[],0,0],arrFeatureStyles[408]=[2,"rgba(204,204,204,1)",6,2,0,[],0,0];const trafficDataLoader={requestTile:async(e,t)=>{const i=e.getTileURL(t.z,t.x,t.y,t),n={type:"requestTile",tileKey:t.key,sourceProjectionName:e.sourceProjection.name,targetProjectionName:e.targetProjection.name,projectedBoundingBox:_boxToArray(t.projectedBoundingBox),geoBoundingBox:_boxToArray(t.geoBoundingBox),projectedCenter:_vectorToArray(t.projectedCenter),targetCenter:_vectorToArray(t.targetCenter),id:t.id,x:t.x,y:t.y,z:t.z,reverseY:t.reverseY,url:i,timeStart:performance.now(),sourceCoordType:e.sourceCoordType||void 0,targetCoordType:e.targetCoordType||void 0};if(e.getWorkerOptions){const i=e.getWorkerOptions(t);n.workerOptions=i}return await handleRequestTile(n)}};async function handleRequestTile(e){const{tileKey:t,workerOptions:i,url:n,sourceProjectionName:r,targetProjectionName:s}=e;e.sourceProjection=getProjection(r),e.targetProjection=getProjection(s);const a=s===PROJECTION_WEB_MERCATOR&&r===PROJECTION_WEB_MERCATOR;e.isNormalized=a;for(const h in i)if(Object.hasOwnProperty.call(i,h)){const e=i[h];trafficDataLoader[h]=e}let o=await jsonp(n,{},{jsonp:"fn"}),l=null;try{l=mergePrimitives(parseData(o,e))}catch(c){console.warn(c)}return{type:"responseTile",tileKey:t,content:{data:l},isNormalized:a}}function parseData(e,t){t.targetProjectionName;const i=[];let n=[],r=10;0===e.error?(n=e.content&&e.content.tf,e.precision&&"number"==typeof e.precision&&(r*=e.precision)):0===e.status&&(n=e.result.trafficData);for(let s=0;s<n.length;s++){let e=n[s][1],a=0,o=0,l=arrFeatureStyles[Math.max(0,n[s][3])];if(!l)continue;let c=[];c=trafficDataLoader.colors&&trafficDataLoader.colors[Math.floor(n[s][3]/5)]?colorToArr4(trafficDataLoader.colors[Math.floor(n[s][3]/5)]):colorToArr4(l[1]);let h=trafficDataLoader.lineWidth||l[2],u=[];for(let t=0,i=e.length;t<i/2;t++)a+=e[2*t]/r,o+=e[2*t+1]/r,u.push([a/256-.5,.5-o/256,0]);projectVertices(u,t,!1,!1);const d=lineToMesh(u,h,t);d.colors=fillFlatArray(d.vertices.length/3,[c[0],c[1],c[2],1]),d.layerIndices=fillFlatArray(d.vertices.length/3,[1]),i.push(d)}return i}function mergePrimitives(e){const t=[],i=[];let n=null,r=null,s=null,a=null,o=null,l=null,c=null,h=0,u=0;for(let d=0;d<e.length;d++)if(n=e[d],r=n.vertices,s=n.normals,a=n.indices,o=n.colors,l=n.widths,c=n.layerIndices,a&&a.length){for(let e=0,i=r.length-2;e<i;e+=3)t.push(r[e],r[e+1],r[e+2]),t.push(s[e],s[e+1],s[e+2]),h=e/3*4,t.push(o[h],o[h+1],o[h+2],o[h+3]),t.push(l[e/3]),t.push(c[e/3]);for(let e=0,t=a.length;e<t;e++)i.push(a[e]+u);u+=r.length/3}return{attributes:new Float32Array(t),indices:new Uint32Array(i)}}function _boxToArray(e){return[e.min.x,e.min.y,e.min.z,e.max.x,e.max.y,e.max.z]}function _vectorToArray(e){return[e.x,e.y,e.z]}class BaiduTrafficTileProvider extends VectorTileProvider{constructor(e={}){super(e),__publicField(this,"name","BaiduTrafficTileProvider"),__publicField(this,"isBaiduProvider",!0),__publicField(this,"_supportAllProjections",!0),__publicField(this,"_defaultStartLevel",2),__publicField(this,"_defaultMaxLevel",16),this._options=e,this._url=e.url,this.params=e.params,this._isOffline=e.isOffline,this._autoRefresh=defaultValue$1(e.autoRefresh,!0),this._refreshInterval=defaultValue$1(e.refreshInterval,6e4),this._refreshTimer=null,this._isOffline?(this._sourceProjectionName=defaultValue$1(e.projection,PROJECTION_WEB_MERCATOR),this._isWebMercator=!(this._sourceProjectionName!==PROJECTION_WEB_MERCATOR)):(this._sourceProjectionName=PROJECTION_BD_MERCATOR,this._isWebMercator=!1),this._isWebMercator?(this._defaultMinLevel=2,this._defaultMaxLevel=16):(this._defaultMinLevel=3,this._defaultMaxLevel=19)}async _asyncInit(){this.refreshInterval=this._refreshInterval}initProjectionAndGrid(){this._sourceProjection=getProjection(this._sourceProjectionName),this._sourceProjectionName===PROJECTION_BD_MERCATOR?this._grid=new BaiduImageryGrid(this._engine,this._sourceProjection,this._targetProjection):this._grid=new WebMercatorGrid(this._engine,this._sourceProjection,this._targetProjection)}getTileURL(e,t,i,n){return this._isOffline?this._getOfflineTileURL(e,t,i,n):this._getOnlineTileURL(e,t,i,n)}_getOnlineTileURL(e,t,i,n){const[r,s,a]=n.grid.getRasterTileCoord(e,t,i);let o=`https://traffic.map.baidu.com/traffic/?qt=vtraffic&z=${r}&x=${s}&y=${a}&udt=20250717`;if(this.params){o+=`&${Object.entries(this.params).map((([e,t])=>`${encodeURIComponent(e)}=${encodeURIComponent(t)}`)).join("&")}`}return o}_getOfflineTileURL(e,t,i,n){let r=e,s=t,a=n.reverseY;this._isWebMercator||([r,s,a]=n.grid.getRasterTileCoord(e,t,i));let o=`http://10.27.57.8:8837/traffic/v1/traffic/?qt=traffic&z=${r}&x=${s}&y=${a}&udt=20190618&ApiAuthorization=USER_AK`;if(this._url?o=`${this._url}/traffic/?qt=traffic&z=${r}&x=${s}&y=${a}&udt=20190618&ApiAuthorization=USER_AK`:window.BMAPGL_URL&&window.TRAFFIC_URL&&(o=`${window.TRAFFIC_URL}/traffic/?qt=traffic&z=${r}&x=${s}&y=${a}&udt=20190618&ApiAuthorization=USER_AK`),o+="&yanpanIds=&geoproIds=",this.params){o+=`&${Object.entries(this.params).map((([e,t])=>`${encodeURIComponent(e)}=${encodeURIComponent(t)}`)).join("&")}`}return o}getWorkerOptions(){return{colors:this._options.colors,lineWidth:this._options.lineWidth}}async doRequestVectorTileData(e){let t=await trafficDataLoader.requestTile(this,e);const i=t.isNormalized,{data:n}=t.content,{attributes:r,indices:s}=n,a=new three.Group,o=new three.Group,l=new three.BufferGeometry,c=new three.InterleavedBuffer(r,12);l.setAttribute("position",new three.InterleavedBufferAttribute(c,3,0)),l.setAttribute("normal",new three.InterleavedBufferAttribute(c,3,3)),l.setAttribute("aColor",new three.InterleavedBufferAttribute(c,4,6)),l.setAttribute("aWidth",new three.InterleavedBufferAttribute(c,1,10)),l.setAttribute("layerIndex",new three.InterleavedBufferAttribute(c,1,11)),l.setIndex(new three.BufferAttribute(s,1));const h=new FatLineMaterial({transparent:!0,lineWidth:4,vertexColors:!0,keepSize:!0,vertexZIndexLegacy:!0,enableDepthRange:!0});h.setCommonUniforms(this._engine.rendering.uniforms);const u=new three.Mesh(l,h);return o.add(u),i?(e.projectedBoundingBox.getSize(a.scale),a.scale.z=1,o.scale.copy(a.scale),a.position.copy(e.targetCenter),o.position.copy(e.targetCenter)):(a.position.copy(e.targetCenter),o.position.copy(e.targetCenter)),[a,o]}_startAutoRefresh(){this._refreshTimer&&this._stopAutoRefresh(),this._refreshTimer=setInterval((()=>{this._needsClearCache=!0,this._engine.requestRender&&this._engine.requestRender()}),this._refreshInterval)}_stopAutoRefresh(){this._refreshTimer&&(clearInterval(this._refreshTimer),this._refreshTimer=null)}get autoRefresh(){return this._autoRefresh}set autoRefresh(e){this._autoRefresh!==e&&(this._autoRefresh=e,e?this._startAutoRefresh():this._stopAutoRefresh())}get refreshInterval(){return this._refreshInterval}set refreshInterval(e){e<6e4&&(e=6e4),this._refreshInterval=e,this._autoRefresh&&this._startAutoRefresh()}dispose(){this._stopAutoRefresh()}onTileDispose(e){}}function WorkerWrapper(){return new Worker(getAssetUrl('assets/workers/MVTParser.worker-bb80e3b4.js'),{type:"module"})}const mapboxBaseUrl="https://api.mapbox.com";function getMapboxPath(e){const t="mapbox://";return 0!==e.indexOf(t)?"":e.slice(9)}function getMapvThreeMvtPath(e,t){const i="mapvthree://";return 0!==e.indexOf(i)?"":e.replace(i,t)}function normalizeStyleUrl(e,t){const i=getMapboxPath(e);if(!i)return decodeURI(e);const n="styles/";if(0!==i.indexOf(n))throw new Error(`unexpected style url: ${e}`);const r=i.slice(7);return`${mapboxBaseUrl}/styles/v1/${r}?&access_token=${t}`}function normalizeSpriteUrl(e,t,i){const n=getMapboxPath(e);if(!n)return decodeURI(new URL(e,i).href);const r="sprites/";if(0!==n.indexOf(r))throw new Error(`unexpected sprites url: ${e}`);const s=n.slice(8);return`${mapboxBaseUrl}/styles/v1/${s}/sprite?access_token=${t}`}function normalizeSourceUrl(e,t,i="access_token",n){const r=new URL(e,n),s=getMapboxPath(e);if(!s)return t?(r.searchParams.set(i,t),decodeURI(r.href)):decodeURI(r.href);if("mapbox.satellite"===s){return`https://api.mapbox.com/v4/${s}/{z}/{x}/{y}${window.devicePixelRatio>=1.5?"@2x":""}.webp?access_token=${t}`}return`https://api.mapbox.com/v4/${s}/{z}/{x}/{y}.vector.pbf?access_token=${t}`}function assert(e){if(!e)throw new Error("The expression evaluated to a falsy value")}class Sprite{constructor(e,t){__publicField(this,"_spriteUrl"),__publicField(this,"_accessToken"),__publicField(this,"_channels",4),this._spriteUrl=e,this._accessToken=t}loadSpriteData(){return Promise.all([this._loadSpriteJson(),this._loadSpriteImage()]).then((([e,t])=>(this._generateIconUv(e,t),{data:e,image:t})))}_getSpriteUrlObj(){const e=new URL(normalizeSpriteUrl(this._spriteUrl,this._accessToken)),t=window.devicePixelRatio>=1.5?"@2x":"";return e.sizeFactor=t,e}_loadSpriteJson(){const{origin:e,pathname:t,search:i,sizeFactor:n}=this._getSpriteUrlObj();return reFetch(e+t+n+".json"+i).then((e=>e.json()))}_loadSpriteImage(){const{origin:e,pathname:t,search:i,sizeFactor:n}=this._getSpriteUrlObj(),r=e+t+n+".png"+i;return new Promise(((e,t)=>{const i=new Image;i.src=r,i.crossOrigin="Anonymous",i.onload=function(){e(i)},i.onerror=function(e){t(e)}}))}_generateIconUv(e,t){for(const i in e){const n=e[i],r=n.x/t.width,s=n.y/t.height,a=(n.x+n.width)/t.width,o=(n.y+n.height)/t.height,l=new Float32Array([r,o,r,s,a,s,a,o]);n.uvs=l}return e}_generateSpriteData(e,t){const i={};for(const n in e){const{width:r,height:s,x:a,y:o,sdf:l,pixelRatio:c,stretchX:h,stretchY:u,content:d}=e[n],p={width:r,height:s,data:new Uint8Array(r*s*this._channels)};this._copyImage(t,p,{x:a,y:o},{width:r,height:s}),i[n]={width:r,height:s,data:p.data,sdf:l,pixelRatio:c,stretchX:h,stretchY:u,content:d}}return i}_copyImage(e,t,i,n){if(0===n.width||0===n.height)return t;if(n.width>e.width||n.height>e.height||i.x>e.width-n.width||i.y>e.height-n.height)throw new RangeError("out of range source coordinates for image copy");if(n.width>t.width||n.height>t.height||0>t.width-n.width||0>t.height-n.height)throw new RangeError("out of range destination coordinates for image copy");const r=e.data,s=t.data;assert(r!==s);for(let a=0;a<n.height;a++){const o=((i.y+a)*e.width+i.x)*this._channels,l=((0+a)*t.width+0)*this._channels;for(let e=0;e<n.width*this._channels;e++)s[l+e]=r[o+e]}return t}_getImageData(e){const t=document.createElement("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0);return i.getImageData(0,0,t.width,t.height)}}const vertexShader$h="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#endif\n\n#include <normal_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\n#if defined(MVT_USE_EXTENT_CLIP) && !defined(MVT_USE_UV_CLIP)\n    attribute vec2 extentVertex;\n    varying vec2 vExtentVertex;\n#endif\n\n#ifdef MVT_USE_VERTEX_ZINDEX_LEGACY\n    attribute float layerIndex;\n    varying float vLayerIndex;\n#endif\n\n#ifdef IS_PATTERN\n    attribute vec4 patternImage;\n    varying vec4 vPatternImage;\n#endif\n\nvarying vec2 vUv;\n\nvoid main() {\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = color;\n    #endif\n\n    #ifdef IS_PATTERN\n        vPatternImage = patternImage;\n    #endif\n\n    #include <begin_vertex>\n    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n\n    #ifdef MVT_USE_VERTEX_ZINDEX_LEGACY\n        vLayerIndex = layerIndex;\n    #endif\n\n    vUv = uv;\n\n    #if defined(MVT_USE_EXTENT_CLIP) && !defined(MVT_USE_UV_CLIP)\n        vExtentVertex = extentVertex;\n    #endif\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <normal_vertex>\n\n    #include <fog_vertex>\n    #include <shadowmap_vertex>\n    #include <logdepthbuf_vertex>\n\n}\n\n",fragmentShader$f="#define GLSLIFY 1\n#include <common>\n#include <fog_pars_fragment>\n\n#ifdef MVT_USE_VERTEX_COLOR\nvarying vec4 vColor;\n#else\nuniform vec3 color;\n#endif\nuniform float opacity;\nvarying vec2 vUv;\n\n#ifdef IS_PATTERN\nuniform sampler2D patternMap;\nvarying vec4 vPatternImage;\n#endif\n\n#if defined(MVT_USE_EXTENT_CLIP) && !defined(MVT_USE_UV_CLIP)\nvarying vec2 vExtentVertex;\n#endif\n\n#include <mvt_depth_range_pars_fragment>\n\n#include <packing>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n\n    #ifdef MVT_USE_EXTENT_CLIP\n        #ifdef MVT_USE_UV_CLIP\n            if (vUv.x < 0.0 || vUv.x > 1.0 || vUv.y < 0.0 || vUv.y > 1.0) {\n                discard;\n            }\n        #else\n            if (vExtentVertex.x < 0.0 || vExtentVertex.x > 1.0 || vExtentVertex.y < 0.0 || vExtentVertex.y > 1.0) {\n                discard;\n            }\n        #endif\n    #endif\n\n    vec4 diffuseColor = vec4(0.0);\n    #ifdef MVT_USE_VERTEX_COLOR\n    diffuseColor = vColor;\n    #else\n    diffuseColor = vec4(color, 1.0);\n    #endif\n\n    diffuseColor.a *= opacity;\n    if (diffuseColor.a <= 0.) {\n        discard;\n    }\n\n    #if ( NUM_DIR_LIGHTS > 0 )\n        // 根据方向光的方向与法向，来计算颜色衰减程度，值范围为-1~1，给重映射到0~1的范围\n    float normalLightIntensity = dot(vNormal, directionalLights[0].direction) * getShadowMask();\n    gl_FragColor = vec4(diffuseColor.rgb * (normalLightIntensity / 2.0 + 0.5), diffuseColor.a);\n    #else \n    gl_FragColor = diffuseColor;\n    #endif\n\n    #ifdef OPAQUE\n    gl_FragColor.a = 1.0;\n    #endif\n\n    #ifdef IS_PATTERN\n    vec2 patternUv = vec2(vPatternImage.x + mod(vUv.x, vPatternImage.z), vPatternImage.y + mod(vUv.y, vPatternImage.w));\n    gl_FragColor = texture2D(patternMap, patternUv);\n    #endif\n\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n    #include <mvt_depth_range_fragment>\n}\n\n",uniforms$i=three.UniformsUtils.merge([three.UniformsLib.fog,three.UniformsLib.lights,{opacity:{value:1},uColor:{value:[0,1,1]},vertexColors:{value:!1},vertexZIndexLegacy:{value:!1},isEmissive:{value:!1},depthRange:{value:new three.Vector2(0,1)},patternMap:{value:null}}]);class MVTMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="MVTMaterial",this.type="MVTMaterial",this.isMVTMaterial=!0,this.lights=!0,this.fog=!0,this.fragmentShader=fragmentShader$f,this.vertexShader=vertexShader$h,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$i)),defineMaterialNormalProperties(this,["opacity","isEmissive","depthRange","patternMap"]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexZIndexLegacy","MVT_USE_VERTEX_ZINDEX_LEGACY"],["enableDepthRange","MVT_USE_DEPTH_RANGE"],["enableExtentClip","MVT_USE_EXTENT_CLIP"],["useUVClip","MVT_USE_UV_CLIP"],["isPattern","IS_PATTERN"]]),this.useUVClip=!0,this.setValues(e)}}const getPixelSize$1=(e,t,i)=>.2*Math.tan(t/2)*e/i;class MapboxVectorTileProvider extends VectorTileProvider{constructor(e={}){super(e),__publicField(this,"name","MapboxVectorTileProvider"),__publicField(this,"_shouldRenderPlaceholder",!0),__publicField(this,"_placeholderColor",new three.Color(.8663865327835083,.8170174360275269,.7507214546203613)),__publicField(this,"_defaultStartLevel",0),__publicField(this,"_defaultMaxLevel",18),__publicField(this,"_lodScaleFactor",.4),__publicField(this,"_defaultMaterials",{}),__publicField(this,"_symbols",{}),__publicField(this,"_materialManager",null),__publicField(this,"_useWebMeractorProjectionAndGrid",!0),__publicField(this,"_supportAllProjections",!0),this._style=e.style||"mapbox://styles/mapbox/streets-v11",this._accessToken=e.accessToken||MapboxConfig.accessToken,this._defaultStyle=e.defaultStyle,this._dispalyOptions=e.displayOptions||{},this._options=e}async _asyncInit(){this._dataLoader||(this._dataLoader=new AsyncDataTileLoader(this,WorkerWrapper,2)),await this._loadStyle()}async _loadStyle(){try{if("string"==typeof this._style&&this._style.endsWith(".json")){const e=this._style.lastIndexOf("/",this._style.lastIndexOf(".json"));this._stylePath=this._style.slice(0,e+1)}const[e,t]=await this._getStyleJSON();if(8!==e.version)throw new Error("mapbox style version 8 required");let i,n=e.layers.length;for(let o=0;o<n;o++){const t=e.layers[o];if(i&&t.source!==i){console.warn("only support one source, the first source will be used,you can use mapbox studio to merge multiple sources into oneor add multiple mvt layer to the map");break}i=t.source}const r=e.sources[i];if("vector"!==r.type)throw new Error("only support vector source");const s=await this._getTileJson(r);let a=e.sprite;if(a&&a.startsWith("mapvthree://")&&(a=getMapvThreeMvtPath(a,this._stylePath)),this._sourceUrl=s.tiles[0],this._sourceUrl.startsWith("mapvthree://")&&(this._sourceUrl=getMapvThreeMvtPath(this._sourceUrl,this._stylePath)),this._styleJSON=e,this._defaultStyleJSON=t,a){const e=new Sprite(a,this._accessToken),t=await e.loadSpriteData();this._spriteData=t.data,this._spriteImage=t.image,this.spriteTexture=new three.Texture(this._spriteImage),this.spriteTexture.generateMipmaps=!1,this.spriteTexture.colorSpace=three.SRGBColorSpace,this.spriteTexture.needsUpdate=!0,this._ready=!0}else this._ready=!0;this._ready&&this._dataLoader.postMessageToAll({type:"changeStyle",styleJSON:this._styleJSON,defaultStyleJSON:this._defaultStyleJSON,spriteData:this._spriteData})}catch(e){console.warn(e)}}_getTileJson(e){const t=e.url;let i;if(t&&!e.tiles){const e=normalizeSourceUrl(t,this._accessToken);if(t.startsWith("mapbox://"))i=Promise.resolve({tiles:[e]});else if(t.startsWith("mapvthree://")){i=reFetch(getMapvThreeMvtPath(e,this._stylePath)).then((e=>e.json())).then((e=>Promise.resolve(e)))}else i=reFetch(e).then((e=>e.json())).then((e=>Promise.resolve(e)))}else i=Promise.resolve(e);return i}_getStyleJSON(){const e=[];if("object"==typeof this._style)e.push(Promise.resolve(this._style));else{const t=reFetch(normalizeStyleUrl(this._style,this._accessToken)).then((e=>e.json()));e.push(t)}if(this._defaultStyle)if("object"==typeof this._defaultStyle)e.push(Promise.resolve(this._defaultStyle));else{const t=reFetch(this._defaultStyle).then((e=>e.json()));e.push(t)}else{const t=reFetch(getAssetUrl("assets/map/mapbox/v8.json")).then((e=>e.json()));e.push(t)}return Promise.all(e)}getTileURL(e,t,i,n){return this._sourceUrl.replace("{z}",e).replace("{x}",t).replace("{y}",n.reverseY)}getWorkerOptions(){return{displayOptions:this._options.displayOptions}}async doRequestVectorTileData(e){const t=(await this._dataLoader.requestTile(e)).content,i=new three.Object3D,n=new three.Vector3,r=["background","fill_opaque","fill_pattern","fill_water","fill_wood","fill_translucent","fill_extrusion_opaque","fill_extrusion_translucent","line_opaque","line_translucent","line_dashed","symbol"],s=new three.Object3D;for(const a of r)if(this._hasBufferData(t[a])){let r;switch(a){case"background":r=this._getBackgroundMesh(t[a],a);break;case"fill_opaque":case"fill_water":case"fill_wood":r=this._getFillOpaqueMesh(t[a],a);break;case"fill_pattern":r=this._getFillPatternMesh(t[a],a);break;case"fill_translucent":r=this._getFillTranslucentMesh(t[a],a);break;case"line_opaque":r=this._getLineOpaqueMesh(t[a],a);break;case"line_translucent":r=this._getLineTranslucentMesh(t[a],a);break;case"line_dashed":r=this._getLineDashedMesh(t[a],a,n,e);break;case"fill_extrusion_opaque":r=this._getExtrusionOpaqueMesh(t[a],a);break;case"fill_extrusion_translucent":r=this._getExtrusionTranslucentMesh(t[a],a);break;case"symbol":this._setupSymbolData(t[a],i);continue;default:throw new Error(`Unknown mesh type: ${a}`)}r.material.enableDepthRange?s.add(r):i.add(r)}return this.targetProjection.name===this.sourceProjection.name&&(e.targetBoundingBox.getSize(i.scale),i.scale.z=1,s.scale.copy(i.scale)),i.position.copy(e.targetCenter),s.position.copy(e.targetCenter),[i,s]}cancelTiles(e){this._dataLoader&&this._dataLoader.cancelTiles&&this._dataLoader.cancelTiles(e)}_hasBufferData(e){const t=e&&e.vertices&&e.vertices.length>0,i=e&&e.symbols&&e.symbols.length>0;return t||i}_getBackgroundMesh(e,t){const{colors:i,vertices:n,uvs:r,indices:s,normals:a,layerIndices:o}=e,l=new three.BufferGeometry;l.setAttribute("position",new three.BufferAttribute(n,3)),l.setAttribute("uv",new three.BufferAttribute(r,2)),l.setAttribute("color",new three.BufferAttribute(i,4)),l.setAttribute("normal",new three.BufferAttribute(a,3)),l.setAttribute("layerIndex",new three.BufferAttribute(o,1)),l.setIndex(new three.BufferAttribute(s,1));const c=this._getMaterial(t),h=new three.Mesh(l,c);return h.name="MVTBackground",h.renderOrder=-102,h.raycast=()=>{},h}_getFillOpaqueMesh(e,t){const{colors:i,vertices:n,uvs:r,indices:s,normals:a,layerIndices:o}=e,l=new three.BufferGeometry;l.setAttribute("position",new three.BufferAttribute(n,3)),l.setAttribute("uv",new three.BufferAttribute(r,2)),l.setAttribute("color",new three.BufferAttribute(i,4)),l.setAttribute("normal",new three.BufferAttribute(a,3)),l.setAttribute("layerIndex",new three.BufferAttribute(o,1)),l.setIndex(new three.BufferAttribute(s,1));const c=this._getMaterial(t),h=new three.Mesh(l,c);return h.name="MVTFillOpaque",h.renderOrder=-101,h.raycast=()=>{},h}_getFillPatternMesh(e,t){const{colors:i,vertices:n,uvs:r,indices:s,normals:a,layerIndices:o,icons:l}=e,c=new three.BufferGeometry;c.setAttribute("position",new three.BufferAttribute(n,3)),c.setAttribute("uv",new three.BufferAttribute(r,2)),c.setAttribute("color",new three.BufferAttribute(i,4)),c.setAttribute("normal",new three.BufferAttribute(a,3)),c.setAttribute("layerIndex",new three.BufferAttribute(o,1)),c.setAttribute("patternImage",new three.BufferAttribute(l,4)),c.setIndex(new three.BufferAttribute(s,1));const h=this._getMaterial(t),u=new three.Mesh(c,h);return u.name="MVTFillPattern",u.renderOrder=-101,u.raycast=()=>{},u}_getFillTranslucentMesh(e,t){const{colors:i,vertices:n,uvs:r,indices:s,normals:a,layerIndices:o}=e,l=new three.BufferGeometry;l.setAttribute("position",new three.BufferAttribute(n,3)),l.setAttribute("uv",new three.BufferAttribute(r,2)),l.setAttribute("color",new three.BufferAttribute(i,4)),l.setAttribute("normal",new three.BufferAttribute(a,3)),l.setAttribute("layerIndex",new three.BufferAttribute(o,1)),l.setIndex(new three.BufferAttribute(s,1));const c=this._getMaterial(t),h=new three.Mesh(l,c);return h.name="MVTFillTranslucent",h.renderOrder=-101,h.raycast=()=>{},h}_getLineOpaqueMesh(e,t){const{colors:i,vertices:n,normals:r,indices:s,widths:a,layerIndices:o,extentVertices:l}=e,c=new three.BufferGeometry;c.setAttribute("position",new three.BufferAttribute(n,3)),c.setAttribute("aColor",new three.BufferAttribute(i,4)),c.setAttribute("normal",new three.BufferAttribute(r,3)),c.setAttribute("aWidth",new three.BufferAttribute(a,1)),c.setAttribute("layerIndex",new three.BufferAttribute(o,1)),c.setAttribute("extentVertex",new three.BufferAttribute(l,2)),c.setIndex(new three.BufferAttribute(s,1));const h=this._getMaterial(t),u=new three.Mesh(c,h);return u.name="MVTLineOpaque",u.renderOrder=-100,u.raycast=()=>{},u}_getLineTranslucentMesh(e,t){const{colors:i,vertices:n,normals:r,indices:s,widths:a,layerIndices:o,extentVertices:l}=e,c=new three.BufferGeometry;c.setAttribute("position",new three.BufferAttribute(n,3)),c.setAttribute("aColor",new three.BufferAttribute(i,4)),c.setAttribute("normal",new three.BufferAttribute(r,3)),c.setAttribute("aWidth",new three.BufferAttribute(a,1)),c.setAttribute("layerIndex",new three.BufferAttribute(o,1)),c.setAttribute("extentVertex",new three.BufferAttribute(l,2)),c.setIndex(new three.BufferAttribute(s,1));const h=this._getMaterial(t),u=new three.Mesh(c,h);return u.name="MVTLineTranslucent",u.renderOrder=-100,u.raycast=()=>{},u}_getLineDashedMesh(e,t,i,n){const{colors:r,vertices:s,normals:a,indices:o,widths:l,layerIndices:c,extentVertices:h,lengths:u,dashArrays:d,dashRatios:p}=e,m=new three.BufferGeometry;m.setAttribute("position",new three.BufferAttribute(s,3)),m.setAttribute("aColor",new three.BufferAttribute(r,4)),m.setAttribute("normal",new three.BufferAttribute(a,3)),m.setAttribute("aWidth",new three.BufferAttribute(l,1)),m.setAttribute("layerIndex",new three.BufferAttribute(c,1)),m.setAttribute("extentVertex",new three.BufferAttribute(h,2)),m.setAttribute("lengths",new three.BufferAttribute(u,1)),m.setAttribute("aDashArray",new three.BufferAttribute(d,1)),m.setAttribute("aDashRatio",new three.BufferAttribute(p,1)),m.setIndex(new three.BufferAttribute(o,1));const f=this._getMaterial(t),g=new three.Mesh(m,f);return g.name="MVTLineDashed",g.renderOrder=-100,g.onBeforeRender=()=>{const e=n.targetCenter,t=this._engine.camera,i=this._engine.rendering.renderState,r=t.position,s=e.clone();s.x-=i.cameraOffset.x,s.y-=i.cameraOffset.y,s.z-=i.cameraOffset.z;const a=r.distanceTo(s),o=getPixelSize$1(a,t.fov*Math.PI/180,this._engine.container.clientHeight);f.zoomUnits=8*o,f.useLength=!0},g.raycast=()=>{},g}_getExtrusionOpaqueMesh(e,t){const{colors:i,vertices:n,uvs:r,indices:s,indices_side:a,normals:o,layerIndices:l,extentVertices:c}=e,h=new three.BufferGeometry;h.setAttribute("position",new three.BufferAttribute(n,3)),h.setAttribute("uv",new three.BufferAttribute(r,2)),h.setAttribute("color",new three.BufferAttribute(i,4)),h.setAttribute("normal",new three.BufferAttribute(o,3)),h.setAttribute("layerIndex",new three.BufferAttribute(l,1)),h.setAttribute("extentVertex",new three.BufferAttribute(c,2)),h.setIndex(new three.BufferAttribute(new Uint32Array([...s,...a]),1)),h.clearGroups(),h.addGroup(0,s.length,1),h.addGroup(s.length,a.length,0);const u=this._getMaterial(t),d=new three.Mesh(h,u);return d.name="MVTExtrusionOpaque",d.renderOrder=-99,d.raycast=()=>{},d}_getExtrusionTranslucentMesh(e,t){const{colors:i,vertices:n,uvs:r,indices:s,indices_side:a,normals:o,layerIndices:l,extentVertices:c}=e,h=new three.BufferGeometry;h.setAttribute("position",new three.BufferAttribute(n,3)),h.setAttribute("uv",new three.BufferAttribute(r,2)),h.setAttribute("color",new three.BufferAttribute(i,4)),h.setAttribute("normal",new three.BufferAttribute(o,3)),h.setAttribute("layerIndex",new three.BufferAttribute(l,1)),h.setAttribute("extentVertex",new three.BufferAttribute(c,2)),h.setIndex(new three.BufferAttribute(new Uint32Array([...s,...a]),1)),h.clearGroups(),h.addGroup(0,s.length,1),h.addGroup(s.length,a.length,0);const u=this._getMaterial(t),d=new three.Mesh(h,u);return d.name="MVTExtrusionTranslucent",d.renderOrder=-99,d.raycast=()=>{},d}_getMaterial(e){const t=this._engine.rendering.features.antialias.samples>0;if(this.materialManager)return this.materialManager.getMaterialByKey(e);if(this._defaultMaterials[e])return this._defaultMaterials[e];let i;switch(e){case"background":i=new MVTMaterial({name:e,vertexColors:!0,enableDepthRange:!0,depthRange:new three.Vector2(0,1),vertexZIndexLegacy:!0});break;case"fill_extrusion_opaque":i=new MVTMaterial({name:e,vertexColors:!0,vertexZIndexLegacy:!0,depthRange:new three.Vector2(0,1),useUVClip:!1,enableExtentClip:!0});break;case"fill_extrusion_translucent":i=new MVTMaterial({name:e,vertexColors:!0,vertexZIndexLegacy:!0,transparent:!0,depthRange:new three.Vector2(0,1),useUVClip:!1,enableExtentClip:!0});break;case"fill_opaque":case"fill_water":case"fill_wood":i=new MVTMaterial({name:e,vertexColors:!0,vertexZIndexLegacy:!0,enableDepthRange:!0,depthRange:new three.Vector2(0,1),enableExtentClip:!0});break;case"fill_pattern":i=new MVTMaterial({name:e,vertexColors:!0,vertexZIndexLegacy:!0,enableDepthRange:!0,transparent:!0,depthRange:new three.Vector2(0,1),enableExtentClip:!0,patternMap:this.spriteTexture,isPattern:!0});break;case"fill_translucent":i=new MVTMaterial({name:e,transparent:!0,vertexZIndexLegacy:!0,vertexColors:!0,enableDepthRange:!0,depthRange:new three.Vector2(0,1),enableExtentClip:!0});break;case"line_opaque":i=new FatLineMaterial({name:e,keepSize:!0,vertexColors:!0,enableDepthRange:!0,vertexZIndexLegacy:!0,depthRange:new three.Vector2(0,1),antialias:!t,antialiasFactor:.6,lineWidth:1,enableExtentClip:!0});break;case"line_dashed":i=new FatLineMaterial({name:e,dashed:!0,keepSize:!0,vertexColors:!0,dashArray:5,enableDepthRange:!0,vertexZIndexLegacy:!0,depthRange:new three.Vector2(0,1),enableExtentClip:!0,transparent:!0,antialias:!t,antialiasFactor:.6,lineWidth:1,vertexDashArray:!0,vertexDashRatio:!0});break;case"line_translucent":i=new FatLineMaterial({name:e,keepSize:!0,transparent:!0,vertexZIndexLegacy:!0,antialias:!t,antialiasFactor:.6,lineWidth:1,vertexColors:!0,enableDepthRange:!0,depthRange:new three.Vector2(0,1),enableExtentClip:!0});break;default:throw new Error("unknown material type: "+e)}return this._defaultMaterials[e]=i,i.setCommonUniforms(this._engine.rendering.uniforms),i}_calculateTolerance(e,t,i){const n=e.tile.z;let r=0;return 5===n&&"中华人民共和国"===i.text&&(r=-3),6===n&&"广州"===i.text&&(r=-4),7===n?(r=4,"三沙"!==i.text&&"三亚"!==i.text&&"儋州"!==i.text||(r=-1)):n>7&&(r=12),"香港"!==i.text&&"澳门"!==i.text&&"台北"!==i.text||(r=-3),r}_setupSymbolData(e,t){t.symbols=e.symbols}_addTilePOI(e,t){const i=[0,0];t.rendering.label.spriteTexture=this.spriteTexture;const n=t.map.projectionName,r=e.tile.z<10;if(e.object&&e.object.symbols){const s=[];for(let o=0;o<e.object.symbols.length;o++){const a=e.object.symbols[o];if(!this._symbols[a.id]){this._symbols[a.id]=a;const o=a.textStyle||{},{width:l,height:c,opacity:h}=a.iconStyle||{},u=o.fontSize||0,d=o.fontWeight||"400",p=o.textOffset||i,m=o.hOffset||0,f=o.vOffset||0;s.push({crs:n,id:a.id,text:a.text,type:a.type,rank:a.rank,position:a.position,rotateZ:a.rotateZ,iconUvs:a.iconUvs,bucket:e.dataTile.key,textWeight:d,textSize:u,textFillStyle:o.fillRgba,textStrokeStyle:o.haloRgba,textStrokeWidth:o.haloSize,textOffset:[p[0]*u+m,p[1]*u+f],textAnchor:o.textAnchor,maxWidth:o.maxWidth,iconSize:[l,c],iconOpacity:h,tolerance:this._calculateTolerance(e,t,a),checkVisible:r})}}const a=e.dataTile.key;t.rendering.label.addLabels(s,a)}}_removeTilePOI(e,t){if(e.object&&e.object.symbols){const i=[];for(let t=0;t<e.object.symbols.length;t++){const n=e.object.symbols[t];this._symbols[n.id]&&(delete this._symbols[n.id],i.push(n))}const n=e.dataTile.key;t.rendering.label.removeLabels(i,n)}}onSurfaceTileAdded(e,t){this._addTilePOI(e,t)}onSurfaceTileRemoved(e,t){this._removeTilePOI(e,t)}addAllSymbols(){Object.keys(this._symbols).forEach((e=>{const t=this._symbols[e];t.isHidden&&(t.isHidden=!1,this._engine.rendering.label.addLabel(t))}))}removeAllSymbols(){Object.keys(this._symbols).forEach((e=>{const t=this._symbols[e];t.isHidden||(t.isHidden=!0,this._engine.rendering.label.removeLabel(t))}))}onTileDispose(e){}get materialManager(){return this._materialManager&&!this._materialManager._inited&&(this._materialManager.engine=this._engine,this._materialManager.init()),this._materialManager}set materialManager(e){e!==this._materialManager&&(this._needsClearCache=!0,this._materialManager=e)}}function estimateBytesUsed$1(e){let t=0;for(const n in e.attributes){const i=e.getAttribute(n);t+=i.count*i.itemSize*i.array.BYTES_PER_ELEMENT}const i=e.getIndex();return t+=i?i.count*i.itemSize*i.array.BYTES_PER_ELEMENT:0,t}function toTrianglesDrawMode(e,t){if(t===three.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===three.TriangleFanDrawMode||t===three.TriangleStripDrawMode){let i=e.getIndex();if(null===i){const t=[],n=e.getAttribute("position");if(void 0===n)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<n.count;e++)t.push(e);e.setIndex(t),i=e.getIndex()}const n=i.count-2,r=[];if(t===three.TriangleFanDrawMode)for(let e=1;e<=n;e++)r.push(i.getX(0)),r.push(i.getX(e)),r.push(i.getX(e+1));else for(let e=0;e<n;e++)e%2==0?(r.push(i.getX(e)),r.push(i.getX(e+1)),r.push(i.getX(e+2))):(r.push(i.getX(e+2)),r.push(i.getX(e+1)),r.push(i.getX(e)));r.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=e.clone();return s.setIndex(r),s.clearGroups(),s}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}const REVISION_GEQ_165=parseInt(three.REVISION,10)>=165,REVISION_GEQ_166=parseInt(three.REVISION,10)>=166,_box$2=new three.Box2,_currentScissor=new three.Vector4,_pos$1=new three.Vector2,TextureReadUtility=new class{constructor(){this._renderer=new three.WebGLRenderer,this._target=new three.WebGLRenderTarget(1,1),this._texTarget=new three.WebGLRenderTarget,this._quad=new FullScreenQuad(new three.ShaderMaterial({blending:three.CustomBlending,blendDst:three.ZeroFactor,blendSrc:three.OneFactor,uniforms:{map:{value:null},pixel:{value:new three.Vector2}},vertexShader:"\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform ivec2 pixel;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texelFetch( map, pixel, 0 );\n\n\t\t\t\t}\n\t\t\t"}))}increaseSizeTo(e){this._target.setSize(Math.max(this._target.width,e),1)}readDataAsync(e){const{_renderer:t,_target:i}=this;return REVISION_GEQ_165?t.readRenderTargetPixelsAsync(i,0,0,e.length/4,1,e):Promise.resolve().then((()=>this.readData(e)))}readData(e){const{_renderer:t,_target:i}=this;t.readRenderTargetPixels(i,0,0,e.length/4,1,e)}renderPixelToTarget(e,t,i){const{_quad:n,_renderer:r,_target:s,_texTarget:a}=this;if(REVISION_GEQ_166)_box$2.min.copy(t),_box$2.max.copy(t),_box$2.max.x+=1,_box$2.max.y+=1,r.initRenderTarget(s),r.copyTextureToTexture(e,s.texture,_box$2,i,0);else{const o=r.autoClear,l=r.getRenderTarget(),c=r.getScissorTest();r.getScissor(_currentScissor),a.setSize(e.image.width,e.image.height),r.setRenderTarget(a),_pos$1.set(0,0),REVISION_GEQ_165?r.copyTextureToTexture(e,a.texture,null,_pos$1):r.copyTextureToTexture(_pos$1,e,a.texture),n.material.uniforms.map.value=a.texture,n.material.uniforms.pixel.value.copy(t),r.setRenderTarget(s),r.setScissorTest(!0),r.setScissor(i.x,i.y,1,1),r.autoClear=!1,n.render(r),r.setScissorTest(c),r.setScissor(_currentScissor),r.setRenderTarget(l),r.autoClear=o,a.dispose()}}},_uv0=new three.Vector2,_uv1=new three.Vector2,_uv2=new three.Vector2;function getTextureCoordAttribute(e,t){return 0===t?e.getAttribute("uv"):e.getAttribute(`uv${t}`)}function getTriangleVertexIndices(e,t,i=new Array(3)){let n=3*t,r=3*t+1,s=3*t+2;return e.index&&(n=e.index.getX(n),r=e.index.getX(r),s=e.index.getX(s)),i[0]=n,i[1]=r,i[2]=s,i}function getTexCoord(e,t,i,n,r){const[s,a,o]=n,l=getTextureCoordAttribute(e,t);_uv0.fromBufferAttribute(l,s),_uv1.fromBufferAttribute(l,a),_uv2.fromBufferAttribute(l,o),r.set(0,0,0).addScaledVector(_uv0,i.x).addScaledVector(_uv1,i.y).addScaledVector(_uv2,i.z)}function getTexelIndices(e,t,i,n){const r=e.x-Math.floor(e.x),s=e.y-Math.floor(e.y),a=Math.floor(r*t%t),o=Math.floor(s*i%i);return n.set(a,o),n}const _uv=new three.Vector2,_pixel=new three.Vector2,_dstPixel=new three.Vector2;function getMaxBarycoordIndex(e){return e.x>e.y&&e.x>e.z?0:e.y>e.z?1:2}class MeshFeatures{constructor(e,t,i){this.geometry=e,this.textures=t,this.data=i,this._asyncRead=!1,this.featureIds=i.featureIds.map((e=>{const{texture:t,...i}=e,n={label:null,propertyTable:null,nullFeatureId:null,...i};return t&&(n.texture={texCoord:0,channels:[0],...t}),n}))}getTextures(){return this.textures}getFeatureInfo(){return this.featureIds}getFeaturesAsync(...e){this._asyncRead=!0;const t=this.getFeatures(...e);return this._asyncRead=!1,t}getFeatures(e,t){const{geometry:i,textures:n,featureIds:r}=this,s=new Array(r.length).fill(null),a=r.length;TextureReadUtility.increaseSizeTo(a);const o=getTriangleVertexIndices(i,e),l=o[getMaxBarycoordIndex(t)];for(let u=0,d=r.length;u<d;u++){const e=r[u],a="nullFeatureId"in e?e.nullFeatureId:null;if("texture"in e){const r=n[e.texture.index];getTexCoord(i,e.texture.texCoord,t,o,_uv),getTexelIndices(_uv,r.image.width,r.image.height,_pixel),_dstPixel.set(u,0),TextureReadUtility.renderPixelToTarget(n[e.texture.index],_pixel,_dstPixel)}else if("attribute"in e){const t=i.getAttribute(`_feature_id_${e.attribute}`).getX(l);t!==a&&(s[u]=t)}else{const e=l;e!==a&&(s[u]=e)}}const c=new Uint8Array(4*a);return this._asyncRead?TextureReadUtility.readDataAsync(c).then((()=>(h(),s))):(TextureReadUtility.readData(c),h(),s);function h(){const e=new Uint32Array(1);for(let t=0,i=r.length;t<i;t++){const i=r[t],n="nullFeatureId"in i?i.nullFeatureId:null;if("texture"in i){const{channels:r}=i.texture,a=r.map((e=>c[4*t+e]));new Uint8Array(e.buffer).set(a);const o=e[0];o!==n&&(s[t]=o)}}}}dispose(){this.textures.forEach((e=>{e&&(e.dispose(),e.image instanceof ImageBitmap&&e.image.close())}))}}const EXT_NAME$1="EXT_mesh_features";function forEachPrimitiveExtension(e,t,i){e.traverse((e=>{if(t.associations.has(e)){const{meshes:n,primitives:r}=t.associations.get(e);if(defined$2(n)&&defined$2(r)){const s=t.json.meshes[n].primitives[r];s&&s.extensions&&s.extensions[EXT_NAME$1]&&i(e,s.extensions[EXT_NAME$1])}}}))}class GLTFMeshFeaturesExtension{constructor(e){this.parser=e,this.name=EXT_NAME$1}async afterRoot({scene:e,parser:t}){var i;const n=t.json.extensionsUsed;if(!n||!n.includes(EXT_NAME$1))return;const r=(null==(i=t.json.textures)?void 0:i.length)||0,s=new Array(r).fill(null);forEachPrimitiveExtension(e,t,((e,{featureIds:i})=>{i.forEach((e=>{if(e.texture&&null===s[e.texture.index]){const i=e.texture.index;s[i]=t.loadTexture(i)}}))}));const a=await Promise.all(s);forEachPrimitiveExtension(e,t,((e,t)=>{e.userData.meshFeatures=new MeshFeatures(e.geometry,a,t)}))}}class StructuralMetadata{constructor(e){e=defaultValue$1(e,defaultValue$1.EMPTY_OBJECT),this._schema=e.schema;const t=e.propertyTables;this._propertyTableCount=defined$2(t)?t.length:0,this._propertyTables=t,this._propertyTextures=e.propertyTextures,this._propertyAttributes=e.propertyAttributes,this._statistics=e.statistics,this._extras=e.extras,this._extensions=e.extensions}get schema(){return this._schema}get statistics(){return this._statistics}get extras(){return this._extras}get extensions(){return this._extensions}get propertyTableCount(){return this._propertyTableCount}get propertyTables(){return this._propertyTables}get propertyTextures(){return this._propertyTextures}get propertyAttributes(){return this._propertyAttributes}get propertyTablesByteLength(){if(!defined$2(this._propertyTables))return 0;let e=0;const t=this._propertyTables.length;for(let i=0;i<t;i++)e+=this._propertyTables[i].byteLength;return e}getPropertyTable(e){return this._propertyTables[e]}getPropertyTexture(e){return this._propertyTextures[e]}getPropertyAttribute(e){return this._propertyAttributes[e]}dispose(){}}function supportsBigInt$1(){return"undefined"!=typeof BigInt}const MetadataComponentType={INT8:"INT8",UINT8:"UINT8",INT16:"INT16",UINT16:"UINT16",INT32:"INT32",UINT32:"UINT32",INT64:"INT64",UINT64:"UINT64",FLOAT32:"FLOAT32",FLOAT64:"FLOAT64",getMinimum:function(e){switch(e){case MetadataComponentType.INT8:return-128;case MetadataComponentType.UINT8:return 0;case MetadataComponentType.INT16:return-32768;case MetadataComponentType.UINT16:return 0;case MetadataComponentType.INT32:return-2147483648;case MetadataComponentType.UINT32:return 0;case MetadataComponentType.INT64:return supportsBigInt$1()?BigInt("-9223372036854775808"):-Math.pow(2,63);case MetadataComponentType.UINT64:return supportsBigInt$1()?BigInt(0):0;case MetadataComponentType.FLOAT32:return-34028234663852886e22;case MetadataComponentType.FLOAT64:return-Number.MAX_VALUE}},getMaximum:function(e){switch(e){case MetadataComponentType.INT8:return 127;case MetadataComponentType.UINT8:return 255;case MetadataComponentType.INT16:return 32767;case MetadataComponentType.UINT16:return 65535;case MetadataComponentType.INT32:return 2147483647;case MetadataComponentType.UINT32:return 4294967295;case MetadataComponentType.INT64:return supportsBigInt$1()?BigInt("9223372036854775807"):Math.pow(2,63)-1;case MetadataComponentType.UINT64:return supportsBigInt$1()?BigInt("18446744073709551615"):Math.pow(2,64)-1;case MetadataComponentType.FLOAT32:return 34028234663852886e22;case MetadataComponentType.FLOAT64:return Number.MAX_VALUE}},isIntegerType:function(e){switch(e){case MetadataComponentType.INT8:case MetadataComponentType.UINT8:case MetadataComponentType.INT16:case MetadataComponentType.UINT16:case MetadataComponentType.INT32:case MetadataComponentType.UINT32:case MetadataComponentType.INT64:case MetadataComponentType.UINT64:return!0;default:return!1}},isUnsignedIntegerType:function(e){switch(e){case MetadataComponentType.UINT8:case MetadataComponentType.UINT16:case MetadataComponentType.UINT32:case MetadataComponentType.UINT64:return!0;default:return!1}},isVectorCompatible:function(e){switch(e){case MetadataComponentType.INT8:case MetadataComponentType.UINT8:case MetadataComponentType.INT16:case MetadataComponentType.UINT16:case MetadataComponentType.INT32:case MetadataComponentType.UINT32:case MetadataComponentType.FLOAT32:case MetadataComponentType.FLOAT64:return!0;default:return!1}},normalize:function(e,t){return Math.max(Number(e)/Number(MetadataComponentType.getMaximum(t)),-1)},unnormalize:function(e,t){const i=MetadataComponentType.getMaximum(t),n=MetadataComponentType.isUnsignedIntegerType(t)?0:-i;return e=CesiumMath.sign(e)*Math.round(Math.abs(e)*Number(i)),t!==MetadataComponentType.INT64&&t!==MetadataComponentType.UINT64||!supportsBigInt$1()||(e=BigInt(e)),e>i?i:e<n?n:e},applyValueTransform:function(e,t,i){return i*e+t},unapplyValueTransform:function(e,t,i){return 0===i?0:(e-t)/i},getSizeInBytes:function(e){switch(e){case MetadataComponentType.INT8:case MetadataComponentType.UINT8:return 1;case MetadataComponentType.INT16:case MetadataComponentType.UINT16:return 2;case MetadataComponentType.INT32:case MetadataComponentType.UINT32:return 4;case MetadataComponentType.INT64:case MetadataComponentType.UINT64:return 8;case MetadataComponentType.FLOAT32:return 4;case MetadataComponentType.FLOAT64:return 8}}},MetadataComponentType$1=Object.freeze(MetadataComponentType);class MetadataEnumValue{constructor(e){const t=(e=defaultValue$1(e,{})).value,i=e.name;this._value=t,this._name=i,this._description=e.description,this._extras=clone$2(e.extras,!0),this._extensions=clone$2(e.extensions,!0)}static fromJson(e){return new MetadataEnumValue({value:e.value,name:e.name,description:e.description,extras:e.extras,extensions:e.extensions})}get value(){return this._value}get name(){return this._name}get description(){return this._description}get extras(){return this._extras}get extensions(){return this._extensions}}class MetadataEnum{constructor(e){const t=(e=defaultValue$1(e,{})).id,i=e.values,n={},r={},s=i.length;for(let o=0;o<s;++o){const e=i[o];n[e.value]=e.name,r[e.name]=e.value}const a=defaultValue$1(e.valueType,MetadataComponentType$1.UINT16);this._values=i,this._namesByValue=n,this._valuesByName=r,this._valueType=a,this._id=t,this._name=e.name,this._description=e.description,this._extras=clone$2(e.extras,!0),this._extensions=clone$2(e.extensions,!0)}static fromJson(e){const t=(e=defaultValue$1(e,{})).id,i=e.enum,n=i.values.map((function(e){return MetadataEnumValue.fromJson(e)}));return new MetadataEnum({id:t,values:n,valueType:MetadataComponentType$1[i.valueType],name:i.name,description:i.description,extras:i.extras,extensions:i.extensions})}get values(){return this._values}get namesByValue(){return this._namesByValue}get valuesByName(){return this._valuesByName}get valueType(){return this._valueType}get id(){return this._id}get name(){return this._name}get extras(){return this._extras}get extensions(){return this._extensions}}const MetadataType={SCALAR:"SCALAR",VEC2:"VEC2",VEC3:"VEC3",VEC4:"VEC4",MAT2:"MAT2",MAT3:"MAT3",MAT4:"MAT4",BOOLEAN:"BOOLEAN",STRING:"STRING",ENUM:"ENUM"};function unpackVectorArray(e,t,i){const n=t.length;defined$2(i)?i.length=n/2:i=new Array(n/2);for(let r=0;r<n;r+=2){const n=r/2;defined$2(i[n])||(i[n]=new e),i[n]=i[n].fromArray(t,r)}return i}MetadataType.isVectorType=function(e){switch(e){case MetadataType.VEC2:case MetadataType.VEC3:case MetadataType.VEC4:return!0;default:return!1}},MetadataType.isMatrixType=function(e){switch(e){case MetadataType.MAT2:case MetadataType.MAT3:case MetadataType.MAT4:return!0;default:return!1}},MetadataType.getComponentCount=function(e){switch(e){case MetadataType.SCALAR:case MetadataType.STRING:case MetadataType.ENUM:case MetadataType.BOOLEAN:return 1;case MetadataType.VEC2:return 2;case MetadataType.VEC3:return 3;case MetadataType.VEC4:case MetadataType.MAT2:return 4;case MetadataType.MAT3:return 9;case MetadataType.MAT4:return 16;default:throw new Error(`Invalid metadata type ${e}`)}},MetadataType.getMathType=function(e){switch(e){case MetadataType.VEC2:return three.Vector2;case MetadataType.VEC3:return three.Vector3;case MetadataType.VEC4:return three.Vector4;case MetadataType.MAT2:return void console.warn("not support mat2");case MetadataType.MAT3:return three.Matrix3;case MetadataType.MAT4:return three.Matrix4;default:return}};class MetadataClassProperty{constructor(e){const t=(e=defaultValue$1(e,{})).id,i=e.type,n=e.componentType,r=e.enumType,s=defined$2(n)&&MetadataComponentType$1.isIntegerType(n)&&defaultValue$1(e.normalized,!1);this._id=t,this._name=e.name,this._description=e.description,this._semantic=e.semantic,this._isLegacyExtension=e.isLegacyExtension,this._type=i,this._componentType=n,this._enumType=r,this._valueType=defined$2(r)?r.valueType:n,this._isArray=defaultValue$1(e.isArray,!1),this._isVariableLengthArray=defaultValue$1(e.isVariableLengthArray,!1),this._arrayLength=e.arrayLength,this._min=clone$2(e.min,!0),this._max=clone$2(e.max,!0),this._normalized=s;let a=clone$2(e.offset,!0),o=clone$2(e.scale,!0);const l=defined$2(a)||defined$2(o),c=!0;defined$2(a)||(a=this.expandConstant(0,c)),defined$2(o)||(o=this.expandConstant(1,c)),this._offset=a,this._scale=o,this._hasValueTransform=l,this._noData=clone$2(e.noData,!0),this._default=clone$2(e.default,!0),this._required=defaultValue$1(e.required,!0),this._extras=clone$2(e.extras,!0),this._extensions=clone$2(e.extensions,!0)}static fromJson(e){const t=(e=defaultValue$1(e,{})).id,i=e.property,n=isLegacy(i),r=parseType(i,e.enums);let s;return s=!!defined$2(n)&&(n?!defined$2(i.optional)||!i.optional:defaultValue$1(i.required,!1)),new MetadataClassProperty({id:t,type:r.type,componentType:r.componentType,enumType:r.enumType,isArray:r.isArray,isVariableLengthArray:r.isVariableLengthArray,arrayLength:r.arrayLength,normalized:i.normalized,min:i.min,max:i.max,offset:i.offset,scale:i.scale,noData:i.noData,default:i.default,required:s,name:i.name,description:i.description,semantic:i.semantic,extras:i.extras,extensions:i.extensions,isLegacyExtension:n})}normalize(e){return this._normalized?normalizeInPlace(e,this._valueType,MetadataComponentType$1.normalize):e}unnormalize(e){return this._normalized?normalizeInPlace(e,this._valueType,MetadataComponentType$1.unnormalize):e}applyValueTransform(e){return!this._hasValueTransform||this._isVariableLengthArray?e:MetadataClassProperty.valueTransformInPlace(e,this._offset,this._scale,MetadataComponentType$1.applyValueTransform)}unapplyValueTransform(e){return!this._hasValueTransform||this._isVariableLengthArray?e:MetadataClassProperty.valueTransformInPlace(e,this._offset,this._scale,MetadataComponentType$1.unapplyValueTransform)}expandConstant(e,t){t=defaultValue$1(t,!1);const i=this._isArray,n=this._arrayLength,r=MetadataType.getComponentCount(this._type),s=i&&r>1;if(!i&&1===r)return e;if(!i)return new Array(r).fill(e);if(!s)return new Array(n).fill(e);if(!t)return new Array(this._arrayLength*r).fill(e);const a=new Array(r).fill(e);return new Array(this._arrayLength).fill(a)}handleNoData(e){const t=this._noData;return defined$2(t)&&arrayEquals(e,t)?void 0:e}unpackVectorAndMatrixTypes(e,t){t=defaultValue$1(t,!1);const i=MetadataType.getMathType(this._type),n=this._isArray,r=MetadataType.getComponentCount(this._type),s=n&&r>1;return defined$2(i)?t&&s?e.map((function(e){return(new i).fromArray(e)})):n?unpackVectorArray(i,e):(new i).fromArray(e):e}packVectorAndMatrixTypes(e){if(defined$2(e)||!defined$2(this._default))return this._required&&!defined$2(e)?"required property must have a value":this._isArray?validateArray(this,e):validateSingleValue(this,e)}valueTransformInPlace(e,t,i,n){if(!Array.isArray(e))return n(e,t,i);for(let r=0;r<e.length;r++)e[r]=MetadataClassProperty.valueTransformInPlace(e[r],t[r],i[r],n);return e}get id(){return this._id}get name(){return this._name}get description(){return this._description}get type(){return this._type}get enumType(){return this._enumType}get componentType(){return this._componentType}get valueType(){return this._valueType}get isArray(){return this._isArray}get isVariableLengthArray(){return this._isVariableLengthArray}get arrayLength(){return this._arrayLength}get normalized(){return this._normalized}get max(){return this._max}get min(){return this._min}get noData(){return this._noData}get default(){return this._default}get required(){return this._required}get semantic(){return this._semantic}get hasValueTransform(){return this._hasValueTransform}get offset(){return this._offset}get scale(){return this._scale}get extras(){return this._extras}get extensions(){return this._extensions}}function normalizeInPlace(e,t,i){if(!Array.isArray(e))return i(e,t);for(let n=0;n<e.length;n++)e[n]=normalizeInPlace(e[n],t,i);return e}function isLegacy(e){if("ARRAY"===e.type)return!0;const t=e.type;return t!==MetadataType.SCALAR&&!MetadataType.isMatrixType(t)&&!MetadataType.isVectorType(t)&&(!!defined$2(MetadataComponentType$1[t])||!(defined$2(e.noData)||defined$2(e.scale)||defined$2(e.offset)||defined$2(e.required)||defined$2(e.count)||defined$2(e.array))&&(!defined$2(e.optional)&&void 0))}function parseType(e,t){const i=e.type,n=e.componentType,r="ARRAY"===i;let s,a,o,l;if(r?(s=!0,a=e.componentCount,o=!defined$2(a)):e.array?(s=!0,a=e.count,o=!defined$2(e.count)):(s=!1,a=void 0,o=!1),defined$2(e.enumType)&&(l=t[e.enumType]),i===MetadataType.ENUM)return{type:i,componentType:void 0,enumType:l,valueType:l.valueType,isArray:s,isVariableLengthArray:o,arrayLength:a};if(r&&n===MetadataType.ENUM)return{type:n,componentType:void 0,enumType:l,valueType:l.valueType,isArray:s,isVariableLengthArray:o,arrayLength:a};if(i===MetadataType.SCALAR||MetadataType.isMatrixType(i)||MetadataType.isVectorType(i))return{type:i,componentType:n,enumType:void 0,valueType:n,isArray:s,isVariableLengthArray:o,arrayLength:a};if(i===MetadataType.BOOLEAN||i===MetadataType.STRING)return{type:i,componentType:void 0,enumType:void 0,valueType:void 0,isArray:s,isVariableLengthArray:o,arrayLength:a};if(r&&(n===MetadataType.BOOLEAN||n===MetadataType.STRING))return{type:n,componentType:void 0,enumType:void 0,valueType:void 0,isArray:s,isVariableLengthArray:o,arrayLength:a};if(defined$2(n)&&defined$2(MetadataComponentType$1[n]))return{type:MetadataType.SCALAR,componentType:n,enumType:void 0,valueType:n,isArray:s,isVariableLengthArray:o,arrayLength:a};if(defined$2(MetadataComponentType$1[i]))return{type:MetadataType.SCALAR,componentType:i,enumType:void 0,valueType:i,isArray:s,isVariableLengthArray:o,arrayLength:a};throw new Error(`unknown metadata type {type: ${i}, componentType: ${n})`)}function arrayEquals(e,t){if(!Array.isArray(e))return e===t;if(!Array.isArray(t))return!1;if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(!arrayEquals(e[i],t[i]))return!1;return!0}function validateArray(e,t){if(!Array.isArray(t))return`value ${t} must be an array`;const i=t.length;if(!e._isVariableLengthArray&&i!==e._arrayLength)return"Array length does not match property.arrayLength";for(let n=0;n<i;n++){const i=validateSingleValue(e,t[n]);if(defined$2(i))return i}}function validateSingleValue(e,t){const i=e._type,n=e._componentType,r=e._enumType,s=e._normalized;return MetadataType.isVectorType(i)?validateVector(t,i,n):MetadataType.isMatrixType(i)?validateMatrix(t,i,n):i===MetadataType.STRING?validateString(t):i===MetadataType.BOOLEAN?validateBoolean(t):i===MetadataType.ENUM?validateEnum(t,r):validateScalar(t,n,s)}function validateVector(e,t,i){return MetadataComponentType$1.isVectorCompatible(i)?t!==MetadataType.VEC2||e instanceof three.Vector2?t!==MetadataType.VEC3||e instanceof three.Vector3?t!==MetadataType.VEC4||e instanceof three.Vector4?void 0:`vector value ${e} must be a Vector4`:`vector value ${e} must be a Vector3`:`vector value ${e} must be a Vector2`:`componentType ${i} is incompatible with vector type ${t}`}function validateMatrix(e,t,i){return MetadataComponentType$1.isVectorCompatible(i)?(t===MetadataType.MAT2&&console.warn("not support mat2"),t!==MetadataType.MAT3||e instanceof three.Matrix3?t!==MetadataType.MAT4||e instanceof three.Matrix4?void 0:`matrix value ${e} must be a Matrix4`:`matrix value ${e} must be a Matrix3`):`componentType ${i} is incompatible with matrix type ${t}`}function validateString(e){if("string"!=typeof e)return getTypeErrorMessage(e,MetadataType.STRING)}function validateBoolean(e){if("boolean"!=typeof e)return getTypeErrorMessage(e,MetadataType.BOOLEAN)}function validateEnum(e,t){const i=typeof e;if(defined$2(t))return"string"===i&&defined$2(t.valuesByName[e])?void 0:`value ${e} is not a valid enum name for ${t.id}`}function validateScalar(e,t,i){const n=typeof e;switch(t){case MetadataComponentType$1.INT8:case MetadataComponentType$1.UINT8:case MetadataComponentType$1.INT16:case MetadataComponentType$1.UINT16:case MetadataComponentType$1.INT32:case MetadataComponentType$1.UINT32:case MetadataComponentType$1.FLOAT32:case MetadataComponentType$1.FLOAT64:return"number"!==n?getTypeErrorMessage(e,t):isFinite(e)?checkInRange(e,t,i):getNonFiniteErrorMessage(e,t);case MetadataComponentType$1.INT64:case MetadataComponentType$1.UINT64:return"number"!==n&&"bigint"!==n?getTypeErrorMessage(e,t):"number"!==n||isFinite(e)?checkInRange(e,t,i):getNonFiniteErrorMessage(e,t)}}function getTypeErrorMessage(e,t){return`value ${e} does not match type ${t}`}function getOutOfRangeErrorMessage(e,t,i){let n=`value ${e} is out of range for type ${t}`;return i&&(n+=" (normalized)"),n}function checkInRange(e,t,i){if(i){return e<(MetadataComponentType$1.isUnsignedIntegerType(t)?0:-1)||e>1?getOutOfRangeErrorMessage(e,t,i):void 0}if(e<MetadataComponentType$1.getMinimum(t)||e>MetadataComponentType$1.getMaximum(t))return getOutOfRangeErrorMessage(e,t,i)}function getNonFiniteErrorMessage(e,t){return`value ${e} of type ${t} must be finite`}const _MetadataClass=class{constructor(e){const t=(e=defaultValue$1(e,{})).id,i=defaultValue$1(e.properties,{}),n={};for(const r in i)if(i.hasOwnProperty(r)){const e=i[r];defined$2(e.semantic)&&(n[e.semantic]=e)}this._id=t,this._name=e.name,this._description=e.description,this._properties=i,this._propertiesBySemantic=n,this._extras=clone$2(e.extras,!0),this._extensions=clone$2(e.extensions,!0)}static fromJson(e){const t=(e=defaultValue$1(e,{})).id,i=e.class,n={};for(const r in i.properties)if(i.properties.hasOwnProperty(r)){const t=MetadataClassProperty.fromJson({id:r,property:i.properties[r],enums:e.enums});n[r]=t}return new _MetadataClass({id:t,name:i.name,description:i.description,properties:n,extras:i.extras,extensions:i.extensions})}get properties(){return this._properties}get propertiesBySemantic(){return this._propertiesBySemantic}get id(){return this._id}get name(){return this._name}get description(){return this._description}get extras(){return this._extras}get extensions(){return this._extensions}};let MetadataClass=_MetadataClass;__publicField(MetadataClass,"BATCH_TABLE_CLASS_NAME","_batchTable");class MetadataSchema{constructor(e){e=defaultValue$1(e,{});const t=defaultValue$1(e.classes,{}),i=defaultValue$1(e.enums,{});this._classes=t,this._enums=i,this._id=e.id,this._name=e.name,this._description=e.description,this._version=e.version,this._extras=clone$2(e.extras,!0),this._extensions=clone$2(e.extensions,!0)}static fromJson(e){const t={};if(defined$2(e.enums))for(const n in e.enums)e.enums.hasOwnProperty(n)&&(t[n]=MetadataEnum.fromJson({id:n,enum:e.enums[n]}));const i={};if(defined$2(e.classes))for(const n in e.classes)e.classes.hasOwnProperty(n)&&(i[n]=MetadataClass.fromJson({id:n,class:e.classes[n],enums:t}));return new MetadataSchema({id:e.id,name:e.name,description:e.description,version:e.version,classes:i,enums:t,extras:e.extras,extensions:e.extensions})}get classes(){return this._classes}get enums(){return this._enums}get id(){return this._id}get name(){return this._name}get description(){return this._description}get version(){return this._version}get extras(){return this._extras}get extensions(){return this._extensions}}class MetadataEntity{static hasProperty(e,t,i){if(defined$2(t[e]))return!0;const n=i.properties;if(!defined$2(n))return!1;const r=n[e];return!(!defined$2(r)||!defined$2(r.default))}static hasPropertyBySemantic(e,t,i){const n=i.propertiesBySemantic;if(!defined$2(n))return!1;return defined$2(n[e])}static getPropertyIds(e,t,i){(i=defined$2(i)?i:[]).length=0;for(const r in e)e.hasOwnProperty(r)&&defined$2(e[r])&&i.push(r);const n=t.properties;if(defined$2(n))for(const r in n)n.hasOwnProperty(r)&&!defined$2(e[r])&&defined$2(n[r].default)&&i.push(r);return i}static getProperty(e,t,i){const n=i.properties[e];let r=t[e];Array.isArray(r)&&(r=r.slice());const s=!0;return r=n.handleNoData(r),!defined$2(r)&&defined$2(n.default)?(r=clone$2(n.default,!0),n.unpackVectorAndMatrixTypes(r,s)):defined$2(r)?(r=n.normalize(r),r=n.unpackVectorAndMatrixTypes(r,s),r):void 0}static setProperty(e,t,i,n){const r=n.properties[e];t=r.packVectorAndMatrixTypes(t);const s=r.transform(t);return!!defined$2(s)&&(Array.isArray(s)?i[e]=s.slice():i[e]=s,!0)}static getPropertyBySemantic(e,t,i){const n=i.propertiesBySemantic;if(!defined$2(n))return;const r=n[e];return defined$2(r)?MetadataEntity.getProperty(r.id,t,i):void 0}static setPropertyBySemantic(e,t,i,n){const r=n.propertiesBySemantic;if(!defined$2(r))return!1;const s=r[e];return!!defined$2(s)&&MetadataEntity.setProperty(s.id,t,i,n)}}const RequestState={UNISSUED:0,ISSUED:1,ACTIVE:2,RECEIVED:3,CANCELLED:4,FAILED:5},RequestState$1=Object.freeze(RequestState);class Request{constructor(e={}){const t=defaultValue$1(e.throttleByServer,!1),i=defaultValue$1(e.throttle,!1);this.url=e.url,this.requestFunction=e.requestFunction,this.cancelFunction=e.cancelFunction,this.priorityFunction=e.priorityFunction,this.priority=defaultValue$1(e.priority,0),this.throttle=i,this.throttleByServer=t,this.serverKey=e.serverKey,this.state=RequestState$1.UNISSUED,this.deferred=void 0,this.cancelled=!1}cancel(){this.cancelled=!0}clone(e){return defined$2(e)?(e.url=this.url,e.requestFunction=this.requestFunction,e.cancelFunction=this.cancelFunction,e.priorityFunction=this.priorityFunction,e.priority=this.priority,e.throttle=this.throttle,e.throttleByServer=this.throttleByServer,e.type=this.type,e.serverKey=this.serverKey,e.state=RequestState$1.UNISSUED,e.deferred=void 0,e.cancelled=!1,e):new Request(this)}}function getStringFromTypedArray(e,t,i){if(!defined$2(e))throw new Error("uint8Array is required.");if(t<0)throw new Error("byteOffset cannot be negative.");if(i<0)throw new Error("byteLength cannot be negative.");if(t+i>e.byteLength)throw new Error("sub-region exceeds array bounds.");return t=defaultValue$1(t,0),i=defaultValue$1(i,e.byteLength-t),e=e.subarray(t,t+i),getStringFromTypedArray.decode(e)}function inRange(e,t,i){return t<=e&&e<=i}function utf8Handler(e){let t=0,i=0,n=0,r=128,s=191;const a=[],o=e.length;for(let l=0;l<o;++l){const o=e[l];if(0===n){if(inRange(o,0,127)){a.push(o);continue}if(inRange(o,194,223)){n=1,t=31&o;continue}if(inRange(o,224,239)){224===o&&(r=160),237===o&&(s=159),n=2,t=15&o;continue}if(inRange(o,240,244)){240===o&&(r=144),244===o&&(s=143),n=3,t=7&o;continue}throw new Error("String decoding failed.")}inRange(o,r,s)?(r=128,s=191,t=t<<6|63&o,++i,i===n&&(a.push(t),t=n=i=0)):(t=n=i=0,r=128,s=191,--l)}return a}function getMagic(e,t){return getStringFromTypedArray(e,t=defaultValue$1(t,0),Math.min(4,e.length))}function getJsonFromTypedArray$2(e,t,i){return JSON.parse(getStringFromTypedArray(e,t,i))}getStringFromTypedArray.decodeWithTextDecoder=function(e){return new TextDecoder("utf-8").decode(e)},getStringFromTypedArray.decodeWithFromCharCode=function(e){let t="";const i=utf8Handler(e),n=i.length;for(let r=0;r<n;++r){let e=i[r];e<=65535?t+=String.fromCharCode(e):(e-=65536,t+=String.fromCharCode(55296+(e>>10),56320+(1023&e)))}return t},"undefined"!=typeof TextDecoder?getStringFromTypedArray.decode=getStringFromTypedArray.decodeWithTextDecoder:getStringFromTypedArray.decode=getStringFromTypedArray.decodeWithFromCharCode;class MetadataTableProperty{constructor(e){const t=(e=defaultValue$1(e,defaultValue$1.EMPTY_OBJECT)).count,i=e.property,n=e.classProperty,r=e.bufferViews,s=n.type,a=n.isArray,o=n.isVariableLengthArray;let l=n.valueType;const c=n.enumType,h=s===MetadataType.STRING,u=s===MetadataType.BOOLEAN;let d,p=0;if(o){let e=defaultValue$1(i.arrayOffsetType,i.offsetType);e=defaultValue$1(MetadataComponentType$1[e],MetadataComponentType$1.UINT32);d=new BufferView(r[defaultValue$1(i.arrayOffsets,i.arrayOffsetBufferView)],e,t+1),p+=d.typedArray.byteLength}const m=MetadataType.getComponentCount(s);let f;f=o?d.get(t)-d.get(0):a?t*n.arrayLength:t;const g=m*f;let _,A;if(h){let e=defaultValue$1(i.stringOffsetType,i.offsetType);e=defaultValue$1(MetadataComponentType$1[e],MetadataComponentType$1.UINT32);_=new BufferView(r[defaultValue$1(i.stringOffsets,i.stringOffsetBufferView)],e,g+1),p+=_.typedArray.byteLength}(h||u)&&(l=MetadataComponentType$1.UINT8),A=h?_.get(g)-_.get(0):u?Math.ceil(g/8):g;const v=new BufferView(r[defaultValue$1(i.values,i.bufferView)],l,A);p+=v.typedArray.byteLength;let y=i.offset,x=i.scale;const b=n.hasValueTransform||defined$2(y)||defined$2(x);let S,C;y=defaultValue$1(y,n.offset),x=defaultValue$1(x,n.scale),y=flatten(y),x=flatten(x);const T=this;h?S=function(e){return getString(e,T._values,T._stringOffsets)}:u?(S=function(e){return getBoolean(e,T._values)},C=function(e,t){setBoolean(e,T._values,t)}):defined$2(c)?(S=function(e){const t=T._values.get(e);return c.namesByValue[t]},C=function(e,t){const i=c.valuesByName[t];T._values.set(e,i)}):(S=function(e){return T._values.get(e)},C=function(e,t){T._values.set(e,t)}),this._arrayOffsets=d,this._stringOffsets=_,this._values=v,this._classProperty=n,this._count=t,this._vectorComponentCount=m,this._min=i.min,this._max=i.max,this._offset=y,this._scale=x,this._hasValueTransform=b,this._getValue=S,this._setValue=C,this._unpackedValues=void 0,this._extras=i.extras,this._extensions=i.extensions,this._byteLength=p}get(e){let t=get(this,e);return t=this._classProperty.handleNoData(t),defined$2(t)?(t=this._classProperty.normalize(t),t=applyValueTransform(this,t),this._classProperty.unpackVectorAndMatrixTypes(t)):(t=this._classProperty.default,this._classProperty.unpackVectorAndMatrixTypes(t))}set(e,t){const i=this._classProperty;t=unapplyValueTransform(this,t=i.packVectorAndMatrixTypes(t)),set(this,e,t=i.unnormalize(t))}getTypedArray(){if(defined$2(this._values))return this._values.typedArray}get hasValueTransform(){return this._hasValueTransform}get offset(){return this._offset}get scale(){return this._scale}get extensions(){return this._extensions}get byteLength(){return this._byteLength}}function BufferView(e,t,i){const n=this;let r,s,a;t===MetadataComponentType$1.INT64?supportsBigInt()?supportsBigInt64Array()?(r=new BigInt64Array(e.buffer,e.byteOffset,i),a=function(e,t){n.typedArray[e]=BigInt(t)}):(r=new Uint8Array(e.buffer,e.byteOffset,8*i),s=function(e){return getInt64BigIntFallback(e,n)}):(warnOnce("INT64 type is not fully supported on this platform. Values greater than 2^53 - 1 or less than -(2^53 - 1) may lose precision when read."),r=new Uint8Array(e.buffer,e.byteOffset,8*i),s=function(e){return getInt64NumberFallback(e,n)}):t===MetadataComponentType$1.UINT64?supportsBigInt()?supportsBigUint64Array()?(r=new BigUint64Array(e.buffer,e.byteOffset,i),a=function(e,t){n.typedArray[e]=BigInt(t)}):(r=new Uint8Array(e.buffer,e.byteOffset,8*i),s=function(e){return getUint64BigIntFallback(e,n)}):(warnOnce("UINT64 type is not fully supported on this platform. Values greater than 2^53 - 1 may lose precision when read."),r=new Uint8Array(e.buffer,e.byteOffset,8*i),s=function(e){return getUint64NumberFallback(e,n)}):(r=getTypedArrayByDatatype(t,e.buffer,e.byteOffset,i),a=function(e,t){n.typedArray[e]=t}),defined$2(s)||(s=function(e){return n.typedArray[e]}),this.typedArray=r,this.dataView=new DataView(r.buffer,r.byteOffset),this.get=s,this.set=a,this._componentType=t}function flatten(e){if(!Array.isArray(e))return e;const t=[];for(let i=0;i<e.length;i++){const n=e[i];Array.isArray(n)?t.push.apply(t,n):t.push(n)}return t}function get(e,t){requiresUnpackForGet(e)&&unpackProperty(e);const i=e._classProperty,n=i.isArray,r=i.type,s=MetadataType.getComponentCount(r);if(defined$2(e._unpackedValues)){const i=e._unpackedValues[t];return n?clone$2(i,!0):i}return n||1!==s?getArrayValues(e,i,t):e._getValue(t)}function getArrayValues(e,t,i){let n,r;if(t.isVariableLengthArray){n=e._arrayOffsets.get(i),r=e._arrayOffsets.get(i+1)-n;const s=MetadataType.getComponentCount(t.type);n*=s,r*=s}else{const s=defaultValue$1(t.arrayLength,1)*e._vectorComponentCount;n=i*s,r=s}const s=new Array(r);for(let a=0;a<r;a++)s[a]=e._getValue(n+a);return s}function set(e,t,i){requiresUnpackForSet(e,t,i)&&unpackProperty(e);const n=e._classProperty,r=n.isArray,s=n.type,a=MetadataType.getComponentCount(s);if(defined$2(e._unpackedValues))return n.isArray&&(i=clone$2(i,!0)),void(e._unpackedValues[t]=i);if(!r&&1===a)return void e._setValue(t,i);let o,l;if(n.isVariableLengthArray)o=e._arrayOffsets.get(t),l=e._arrayOffsets.get(t+1)-o;else{const i=defaultValue$1(n.arrayLength,1)*e._vectorComponentCount;o=t*i,l=i}for(let c=0;c<l;++c)e._setValue(o+c,i[c])}function getString(e,t,i){const n=i.get(e),r=i.get(e+1)-n;return getStringFromTypedArray(t.typedArray,n,r)}function getBoolean(e,t){const i=e>>3,n=e%8;return 1==(t.typedArray[i]>>n&1)}function setBoolean(e,t,i){const n=e>>3,r=e%8;i?t.typedArray[n]|=1<<r:t.typedArray[n]&=~(1<<r)}function getInt64NumberFallback(e,t){const i=t.dataView,n=8*e;let r=0;const s=(128&i.getUint8(n+7))>0;let a=!0;for(let o=0;o<8;++o){let e=i.getUint8(n+o);s&&(a?0!==e&&(e=255&~(e-1),a=!1):e=255&~e),r+=e*Math.pow(256,o)}return s&&(r=-r),r}function getInt64BigIntFallback(e,t){const i=t.dataView,n=8*e;let r=BigInt(0);const s=(128&i.getUint8(n+7))>0;let a=!0;for(let o=0;o<8;++o){let e=i.getUint8(n+o);s&&(a?0!==e&&(e=255&~(e-1),a=!1):e=255&~e),r+=BigInt(e)*(BigInt(1)<<BigInt(8*o))}return s&&(r=-r),r}function getUint64NumberFallback(e,t){const i=t.dataView,n=8*e;return i.getUint32(n,!0)+4294967296*i.getUint32(n+4,!0)}function getUint64BigIntFallback(e,t){const i=t.dataView,n=8*e,r=BigInt(i.getUint32(n,!0)),s=BigInt(i.getUint32(n+4,!0));return r+BigInt(4294967296)*s}function getTypedArrayByDatatype(e,t,i,n){switch(e){case MetadataComponentType$1.INT8:return new Int8Array(t,i,n);case MetadataComponentType$1.UINT8:return new Uint8Array(t,i,n);case MetadataComponentType$1.INT16:return new Int16Array(t,i,n);case MetadataComponentType$1.UINT16:return new Uint16Array(t,i,n);case MetadataComponentType$1.INT32:return new Int32Array(t,i,n);case MetadataComponentType$1.UINT32:return new Uint32Array(t,i,n);case MetadataComponentType$1.FLOAT32:return new Float32Array(t,i,n);case MetadataComponentType$1.FLOAT64:return new Float64Array(t,i,n);default:throw new Error(`Unsupported component type: ${e}`)}}function requiresUnpackForGet(e){if(defined$2(e._unpackedValues))return!1;const t=e._classProperty,i=t.type,n=t.valueType;return i===MetadataType.STRING||(n===MetadataComponentType$1.INT64&&!supportsBigInt64Array()||n===MetadataComponentType$1.UINT64&&!supportsBigUint64Array())}function requiresUnpackForSet(e,t,i){if(requiresUnpackForGet(e))return!0;const n=e._arrayOffsets;if(defined$2(n)){if(n.get(t+1)-n.get(t)!==i.length)return!0}return!1}function unpackProperty(e){e._unpackedValues=unpackValues(e),e._arrayOffsets=void 0,e._stringOffsets=void 0,e._values=void 0}function unpackValues(e){const t=e._count,i=new Array(t),n=e._classProperty,r=n.isArray,s=n.type,a=MetadataType.getComponentCount(s);if(!r&&1===a){for(let n=0;n<t;++n)i[n]=e._getValue(n);return i}for(let o=0;o<t;o++)i[o]=getArrayValues(e,n,o);return i}function applyValueTransform(e,t){const i=e._classProperty.isVariableLengthArray;return!e._hasValueTransform||i?t:MetadataClassProperty.valueTransformInPlace(t,e._offset,e._scale,MetadataComponentType$1.applyValueTransform)}function unapplyValueTransform(e,t){const i=e._classProperty.isVariableLengthArray;return!e._hasValueTransform||i?t:MetadataClassProperty.valueTransformInPlace(t,e._offset,e._scale,MetadataComponentType$1.unapplyValueTransform)}function supportsBigInt(){return"undefined"!=typeof BigInt}function supportsBigInt64Array(){return"undefined"!=typeof BigInt64Array}function supportsBigUint64Array(){return"undefined"!=typeof BigUint64Array}class MetadataTable{constructor(e={}){e=defaultValue$1(e,defaultValue$1.EMPTY_OBJECT);const{count:t,properties:i,class:n,bufferViews:r}=e;if(this._count=t,this._class=n,this._properties={},this._byteLength=0,defined$2(i))for(const s in i)if(i.hasOwnProperty(s)){const e=new MetadataTableProperty({count:t,property:i[s],classProperty:n.properties[s],bufferViews:r});this._properties[s]=e,this._byteLength+=e.byteLength}}get count(){return this._count}get class(){return this._class}get byteLength(){return this._byteLength}hasProperty(e){return MetadataEntity.hasProperty(e,this._properties,this._class)}hasPropertyBySemantic(e){return MetadataEntity.hasPropertyBySemantic(e,this._properties,this._class)}getPropertyIds(e=[]){return MetadataEntity.getPropertyIds(this._properties,this._class,e)}getProperty(e,t){const i=this._properties[t];let n;return n=defined$2(i)?i.get(e):getDefault$1(this._class,t),n}setProperty(e,t,i){const n=this._properties[t];return!!defined$2(n)&&(n.set(e,i),!0)}getPropertyBySemantic(e,t){let i;const n=this._class.propertiesBySemantic;if(defined$2(n)&&(i=n[t]),defined$2(i))return this.getProperty(e,i.id)}setPropertyBySemantic(e,t,i){let n;const r=this._class.propertiesBySemantic;return defined$2(r)&&(n=r[t]),!!defined$2(n)&&this.setProperty(e,n.id,i)}getPropertyTypedArray(e){const t=this._properties[e];if(defined$2(t))return t.getTypedArray()}getPropertyTypedArrayBySemantic(e){let t;const i=this._class.propertiesBySemantic;if(defined$2(i)&&(t=i[e]),defined$2(t))return this.getPropertyTypedArray(t.id)}}function getDefault$1(e,t){const i=e.properties;if(!defined$2(i))return;const n=i[t];if(defined$2(n)&&defined$2(n.default)){let e=n.default;return n.isArray&&(e=clone$2(e,!0)),e=n.normalize(e),n.unpackVectorAndMatrixTypes(e)}}const emptyClass={};class JsonMetadataTable{constructor(e){this._count=e.count,this._properties=clone$2(e.properties,!0)}hasProperty(e){return MetadataEntity.hasProperty(e,this._properties,emptyClass)}getPropertyIds(e=[]){return MetadataEntity.getPropertyIds(this._properties,emptyClass,e)}getProperty(e,t){const i=this._properties[t];if(defined$2(i))return clone$2(i[e],!0)}setProperty(e,t,i){let n=this._properties[t];defined$2(n)||(n=new Array(this._count),this._properties[t]=n),n[e]=clone$2(i,!0)}}const scratchResults=[];class PropertyTable{constructor(e=defaultValue$1.EMPTY_OBJECT){this._name=e.name,this._id=e.id,this._count=e.count,this._extras=e.extras,this._extensions=e.extensions,this._metadataTable=e.metadataTable,this._jsonMetadataTable=e.jsonMetadataTable,this._batchTableHierarchy=e.batchTableHierarchy}get name(){return this._name}get id(){return this._id}get count(){return this._count}get class(){return this._metadataTable?this._metadataTable.class:void 0}get extras(){return this._extras}get extensions(){return this._extensions}get byteLength(){let e=0;return this._metadataTable&&(e+=this._metadataTable.byteLength),this._batchTableHierarchy&&(e+=this._batchTableHierarchy.byteLength),e}hasProperty(e,t){return!(!this._metadataTable||!this._metadataTable.hasProperty(t))||(!(!this._batchTableHierarchy||!this._batchTableHierarchy.hasProperty(e,t))||!(!this._jsonMetadataTable||!this._jsonMetadataTable.hasProperty(t)))}hasPropertyBySemantic(e,t){return!!this._metadataTable&&this._metadataTable.hasPropertyBySemantic(t)}propertyExists(e){return!(!this._metadataTable||!this._metadataTable.hasProperty(e))||(!(!this._batchTableHierarchy||!this._batchTableHierarchy.propertyExists(e))||!(!this._jsonMetadataTable||!this._jsonMetadataTable.hasProperty(e)))}propertyExistsBySemantic(e){return!!this._metadataTable&&this._metadataTable.hasPropertyBySemantic(e)}getPropertyIds(e,t=[]){return t.length=0,this._metadataTable&&t.push(...this._metadataTable.getPropertyIds(scratchResults)),this._batchTableHierarchy&&t.push(...this._batchTableHierarchy.getPropertyIds(e,scratchResults)),this._jsonMetadataTable&&t.push(...this._jsonMetadataTable.getPropertyIds(scratchResults)),t}getProperty(e,t){let i;return this._metadataTable&&(i=this._metadataTable.getProperty(e,t),i)||this._batchTableHierarchy&&(i=this._batchTableHierarchy.getProperty(e,t),i)||this._jsonMetadataTable&&(i=this._jsonMetadataTable.getProperty(e,t),i)?i:void 0}setProperty(e,t,i){this._metadataTable&&this._metadataTable.setProperty(e,t,i)||this._batchTableHierarchy&&this._batchTableHierarchy.setProperty(e,t,i)||(this._jsonMetadataTable||(this._jsonMetadataTable=new JsonMetadataTable({count:this._count,properties:{}})),this._jsonMetadataTable.setProperty(e,t,i))}getPropertyBySemantic(e,t){return this._metadataTable?this._metadataTable.getPropertyBySemantic(e,t):void 0}setPropertyBySemantic(e,t,i){return!!this._metadataTable&&this._metadataTable.setPropertyBySemantic(e,t,i)}getPropertyTypedArray(e){return this._metadataTable?this._metadataTable.getPropertyTypedArray(e):void 0}getPropertyTypedArrayBySemantic(e){return this._metadataTable?this._metadataTable.getPropertyTypedArrayBySemantic(e):void 0}isClass(e,t){return!!this._batchTableHierarchy&&this._batchTableHierarchy.isClass(e,t)}isExactClass(e,t){return this.getExactClassName(e)===t}getExactClassName(e){return this._batchTableHierarchy?this._batchTableHierarchy.getClassName(e):void 0}}class PropertyTextureProperty{constructor(e){const t=(e=defaultValue$1(e,defaultValue$1.EMPTY_OBJECT)).property,i=e.classProperty,n=e.textures,r=defined$2(t.channels)?t.channels:[0],s=t;this._textureInfo=s,this._channels=reformatChannels(r),this._texture=n[s.index],this._min=t.min,this._max=t.max;let a=t.offset,o=t.scale;const l=i.hasValueTransform||defined$2(a)||defined$2(o);a=defaultValue$1(a,i.offset),o=defaultValue$1(o,i.scale),a=i.unpackVectorAndMatrixTypes(a),o=i.unpackVectorAndMatrixTypes(o),this._offset=a,this._scale=o,this._hasValueTransform=l,this._classProperty=i,this._extras=t.extras,this._extensions=t.extensions}get texture(){return this._texture}get channels(){return this._channels}get offset(){return this._offset}get scale(){return this._scale}get extra(){return this._extras}get extensions(){return this._extensions}get classProperty(){return this._classProperty}get textureInfo(){return this._textureInfo}}function reformatChannels(e){return e.map((function(e){return"rgba".charAt(e)})).join("")}class PropertyTexture{constructor(e){const t=(e=defaultValue$1(e,defaultValue$1.EMPTY_OBJECT)).propertyTexture,i=e.class,n=e.textures,r=t.extensions,s=t.extras,a={};if(defined$2(t.properties))for(const o in t.properties)t.properties.hasOwnProperty(o)&&(a[o]=new PropertyTextureProperty({property:t.properties[o],classProperty:i.properties[o],textures:n}));this._name=e.name,this._id=e.id,this._class=i,this._properties=a,this._extras=s,this._extensions=r}get name(){return this._name}get id(){return this._id}get class(){return this._class}get properties(){return this._properties}get extras(){return this._extras}get extensions(){return this._extensions}getProperty(e){return this._properties[e]}}class PropertyAttributeProperty{constructor(e){const t=(e=defaultValue$1(e,defaultValue$1.EMPTY_OBJECT)).property,i=e.classProperty;this._attribute=t.attribute,this._classProperty=i,this._min=t.min,this._max=t.max;let n=t.offset,r=t.scale;const s=i.hasValueTransform||defined$2(n)||defined$2(r);n=defaultValue$1(n,i.offset),r=defaultValue$1(r,i.scale),n=i.unpackVectorAndMatrixTypes(n),r=i.unpackVectorAndMatrixTypes(r),this._offset=n,this._scale=r,this._hasValueTransform=s,this._extras=t.extras,this._extensions=t.extensions}get attribute(){return this._attribute}get hasValueTransform(){return this._hasValueTransform}get offset(){return this._offset}get scale(){return this._scale}get classProperty(){return this._classProperty}get extras(){return this._extras}get extensions(){return this._extensions}}class PropertyAttribute{constructor(e){const t=(e=defaultValue$1(e,defaultValue$1.EMPTY_OBJECT)).propertyAttribute,i=e.class,n={};if(defined$2(t.properties))for(const r in t.properties)t.properties.hasOwnProperty(r)&&(n[r]=new PropertyAttributeProperty({property:t.properties[r],classProperty:i.properties[r]}));this._name=e.name,this._id=e.id,this._class=i,this._properties=n,this._extras=t.extras,this._extensions=t.extensions}get name(){return this._name}get id(){return this._id}get class(){return this._class}get properties(){return this._properties}get extras(){return this._extras}get extensions(){return this._extensions}getProperty(e){return this._properties[e]}}function parseStructuralMetadata(e){const t=(e=defaultValue$1(e,defaultValue$1.EMPTY_OBJECT)).extension,i=e.schema,n=[];if(defined$2(t.propertyTables))for(let a=0;a<t.propertyTables.length;a++){const r=t.propertyTables[a],s=i.classes[r.class],o=new MetadataTable({count:r.count,properties:r.properties,class:s,bufferViews:e.bufferViews});n.push(new PropertyTable({id:a,name:r.name,count:r.count,metadataTable:o,extras:r.extras,extensions:r.extensions}))}const r=[];if(defined$2(t.propertyTextures))for(let a=0;a<t.propertyTextures.length;a++){const n=t.propertyTextures[a];r.push(new PropertyTexture({id:a,name:n.name,propertyTexture:n,class:i.classes[n.class],textures:e.textures}))}const s=[];if(defined$2(t.propertyAttributes))for(let a=0;a<t.propertyAttributes.length;a++){const e=t.propertyAttributes[a];s.push(new PropertyAttribute({id:a,name:e.name,class:i.classes[e.class],propertyAttribute:e}))}return new StructuralMetadata({schema:i,propertyTables:n,propertyTextures:r,propertyAttributes:s,statistics:t.statistics,extras:t.extras,extensions:t.extensions})}function createChildStructuralMetadata(e,t){let i=[],n=[];if(t){if(t.propertyTextures){const n=e.propertyTextures;i=t.propertyTextures.map((e=>n[e]))}if(t.propertyAttributes){const i=e.propertyAttributes;n=t.propertyAttributes.map((e=>i[e]))}}return new StructuralMetadata({schema:e.schema,propertyTables:e.propertyTables,propertyTextures:i,propertyAttributes:n,extras:e.extras,extensions:e.extensions})}const EXT_NAME="EXT_structural_metadata";function getRelevantTextures(e,t=[]){var i;const n=(null==(i=e.json.textures)?void 0:i.length)||0,r=new Array(n).fill(null);return t.forEach((({properties:t})=>{for(const i in t)if(t.hasOwnProperty(i)){const{index:n}=t[i];null===r[n]&&(r[n]=e.loadTexture(n))}})),Promise.all(r)}function getRelevantBuffers(e,t=[]){var i;const n=(null==(i=e.json.bufferViews)?void 0:i.length)||0,r=new Array(n).fill(null);return t.forEach((({properties:t})=>{for(const i in t)if(t.hasOwnProperty(i)){const{values:n,arrayOffsets:s,stringOffsets:a}=t[i];null===r[n]&&(r[n]=e.loadBufferView(n)),null===r[s]&&(r[s]=e.loadBufferView(s)),null===r[a]&&(r[a]=e.loadBufferView(a))}})),Promise.all(r)}class GLTFStructuralMetadataExtension{constructor(e){this.parser=e,this.name=EXT_NAME}async afterRoot({scene:e,parser:t}){const i=t.json.extensionsUsed;if(!i||!i.includes(EXT_NAME))return;let n=null,r=t.json.extensions[EXT_NAME];if(r.schemaUri){const{manager:e,path:i,requestHeader:s,crossOrigin:a}=t.options,o=new URL(r.schemaUri,i).toString(),l=new three.FileLoader(e);l.setCrossOrigin(a),l.setResponseType("json"),l.setRequestHeader(s),n=l.loadAsync(o).then((e=>{r={...r,schema:e}}))}const[s,a]=await Promise.all([getRelevantTextures(t,r.propertyTextures),getRelevantBuffers(t,r.propertyTables),n]),o=a.map((e=>{if(e)return new Uint8Array(e)})),l=MetadataSchema.fromJson(r.schema),c=parseStructuralMetadata({extension:r,schema:l,bufferViews:o,textures:s});e.userData.structuralMetadata=c,e.traverse((e=>{if(t.associations.has(e)){const{meshes:i,primitives:n}=t.associations.get(e);if(defined$2(i)&&defined$2(n)){const r=t.json.meshes[i].primitives[n];if(r&&r.extensions&&r.extensions[EXT_NAME]){const t=r.extensions[EXT_NAME];e.userData.structuralMetadata=createChildStructuralMetadata(c,t)}else e.userData.structuralMetadata=c}}}))}}class GLTFCesiumRTCExtension{constructor(){this.name="CESIUM_RTC"}afterRoot(e){if(e.parser.json.extensions&&e.parser.json.extensions.CESIUM_RTC){const{center:t}=e.parser.json.extensions.CESIUM_RTC;t&&(e.scene.position.x+=t[0],e.scene.position.y+=t[1],e.scene.position.z+=t[2])}}}class GLTFLoader$1 extends three.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.forceUnlit=!1,this.pluginCallbacks=[],this.register((function(e){return new GLTFMaterialsClearcoatExtension$1(e)})),this.register((function(e){return new GLTFTextureBasisUExtension$1(e)})),this.register((function(e){return new GLTFTextureWebPExtension$1(e)})),this.register((function(e){return new GLTFTextureAVIFExtension$1(e)})),this.register((function(e){return new GLTFMaterialsSheenExtension$1(e)})),this.register((function(e){return new GLTFMaterialsTransmissionExtension$1(e)})),this.register((function(e){return new GLTFMaterialsVolumeExtension$1(e)})),this.register((function(e){return new GLTFMaterialsIorExtension$1(e)})),this.register((function(e){return new GLTFMaterialsEmissiveStrengthExtension$1(e)})),this.register((function(e){return new GLTFMaterialsSpecularExtension$1(e)})),this.register((function(e){return new GLTFMaterialsIridescenceExtension$1(e)})),this.register((function(e){return new GLTFMaterialsAnisotropyExtension$1(e)})),this.register((function(e){return new GLTFLightsExtension$1(e)})),this.register((function(e){return new GLTFMeshoptCompression$1(e)})),this.register((function(e){return new GLTFMeshGpuInstancing$1(e)})),this.register((function(e){return new GLTFMeshFeaturesExtension(e)})),this.register((function(e){return new GLTFStructuralMetadataExtension(e)})),this.register((function(e){return new GLTFCesiumRTCExtension(e)}))}load(t,i,n,r){const s=this;let a;a=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:three.LoaderUtils.extractUrlBase(t),this.manager.itemStart(t);const o=function(e){r?r(e):console.error(e),s.manager.itemError(t),s.manager.itemEnd(t)},l=new three.FileLoader(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(t,(function(n){try{s.parse(n,a,(function(e){i(e),s.manager.itemEnd(t)}),o)}catch(e){o(e)}}),n,o)}setForceUnlit(e){return this.forceUnlit=e,this}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,n){let r;const s={},a={},o=new TextDecoder;if("string"==typeof e)r=JSON.parse(e);else if(e instanceof ArrayBuffer){const t=o.decode(new Uint8Array(e,0,4));if(t===BINARY_EXTENSION_HEADER_MAGIC$1||t===BINARY_EXTENSION_ENCRYPT_FLAG){try{s[EXTENSIONS$1.KHR_BINARY_GLTF]=new GLTFBinaryExtension$1(e)}catch(c){return void(n&&n(c))}r=JSON.parse(s[EXTENSIONS$1.KHR_BINARY_GLTF].content)}else r=JSON.parse(o.decode(e))}else r=e;if(void 0===r.asset||r.asset.version[0]<2)return void(n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const l=new GLTFParser$1(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder,forceUnlit:this.forceUnlit});l.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const e=this.pluginCallbacks[h](l);a[e.name]=e,s[e.name]=!0}if(r.extensionsUsed)for(let h=0;h<r.extensionsUsed.length;++h){const e=r.extensionsUsed[h],t=r.extensionsRequired||[];switch(e){case EXTENSIONS$1.KHR_MATERIALS_UNLIT:s[e]=new GLTFMaterialsUnlitExtension$1;break;case EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION:s[e]=new GLTFDracoMeshCompressionExtension$1(r,this.dracoLoader);break;case EXTENSIONS$1.KHR_TEXTURE_TRANSFORM:s[e]=new GLTFTextureTransformExtension$1;break;case EXTENSIONS$1.KHR_MESH_QUANTIZATION:s[e]=new GLTFMeshQuantizationExtension$1;break;case EXTENSIONS$1.KHR_TEXTURE_BASISU:s[e]=new GLTFTextureBasisUExtension$1(l);break;default:t.indexOf(e)>=0&&void 0===a[e]&&console.warn('THREE.GLTFLoader: Unknown extension "'+e+'".')}}if(r.textures)for(let h=0,u=r.textures.length;h<u;h++){const e=r.textures[h];e.extensions&&e.extensions.KHR_texture_basisu&&"number"==typeof e.extensions.KHR_texture_basisu.source&&(e.source=e.source||e.extensions.KHR_texture_basisu.source);"image/ktx2"===r.images[e.source].mimeType&&(s.KHR_texture_basisu=new GLTFTextureBasisUExtension$1(l),r.textures[h].extensions={KHR_texture_basisu:e})}this.forceUnlit&&(s.KHR_materials_unlit=new GLTFMaterialsUnlitExtension$1),l.setExtensions(s),l.setPlugins(a),l.parse(i,n)}parseAsync(e,t){const i=this;return new Promise((function(n,r){i.parse(e,t,n,r)}))}}function GLTFRegistry$1(){let e={};return{get:function(t){return e[t]},add:function(t,i){e[t]=i},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const EXTENSIONS$1={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class GLTFLightsExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let i=0,n=t.length;i<n;i++){const n=t[i];n.extensions&&n.extensions[this.name]&&void 0!==n.extensions[this.name].light&&e._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(e){const t=this.parser,i="light:"+e;let n=t.cache.get(i);if(n)return n;const r=t.json,s=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let a;const o=new three.Color(16777215);void 0!==s.color&&o.fromArray(s.color);const l=void 0!==s.range?s.range:0;switch(s.type){case"directional":a=new three.DirectionalLight(o),a.target.position.set(0,0,-1),a.add(a.target);break;case"point":a=new three.PointLight(o),a.distance=l;break;case"spot":a=new three.SpotLight(o),a.distance=l,s.spot=s.spot||{},s.spot.innerConeAngle=void 0!==s.spot.innerConeAngle?s.spot.innerConeAngle:0,s.spot.outerConeAngle=void 0!==s.spot.outerConeAngle?s.spot.outerConeAngle:Math.PI/4,a.angle=s.spot.outerConeAngle,a.penumbra=1-s.spot.innerConeAngle/s.spot.outerConeAngle,a.target.position.set(0,0,-1),a.add(a.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+s.type)}return a.position.set(0,0,0),a.decay=2,assignExtrasToUserData$1(a,s),void 0!==s.intensity&&(a.intensity=s.intensity),a.name=t.createUniqueName(s.name||"light_"+e),n=Promise.resolve(a),t.cache.add(i,n),n}getDependency(e,t){if("light"===e)return this._loadLight(t)}createNodeAttachment(e){const t=this,i=this.parser,n=i.json.nodes[e],r=(n.extensions&&n.extensions[this.name]||{}).light;return void 0===r?null:this._loadLight(r).then((function(e){return i._getNodeRef(t.cache,r,e)}))}}class GLTFMaterialsUnlitExtension$1{constructor(){this.name=EXTENSIONS$1.KHR_MATERIALS_UNLIT}getMaterialType(){return three.MeshBasicMaterial}extendParams(e,t,i){const n=[];e.color=new three.Color(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const t=r.baseColorFactor;e.color.fromArray(t),e.opacity=t[3]}void 0!==r.baseColorTexture&&n.push(i.assignTexture(e,"map",r.baseColorTexture,three.SRGBColorSpace))}return Promise.all(n)}}class GLTFMaterialsEmissiveStrengthExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name].emissiveStrength;return void 0!==n&&(t.emissiveIntensity=n),Promise.resolve()}}class GLTFMaterialsClearcoatExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];if(void 0!==s.clearcoatFactor&&(t.clearcoat=s.clearcoatFactor),void 0!==s.clearcoatTexture&&r.push(i.assignTexture(t,"clearcoatMap",s.clearcoatTexture)),void 0!==s.clearcoatRoughnessFactor&&(t.clearcoatRoughness=s.clearcoatRoughnessFactor),void 0!==s.clearcoatRoughnessTexture&&r.push(i.assignTexture(t,"clearcoatRoughnessMap",s.clearcoatRoughnessTexture)),void 0!==s.clearcoatNormalTexture&&(r.push(i.assignTexture(t,"clearcoatNormalMap",s.clearcoatNormalTexture)),void 0!==s.clearcoatNormalTexture.scale)){const e=s.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new three.Vector2(e,e)}return Promise.all(r)}}class GLTFMaterialsIridescenceExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];return void 0!==s.iridescenceFactor&&(t.iridescence=s.iridescenceFactor),void 0!==s.iridescenceTexture&&r.push(i.assignTexture(t,"iridescenceMap",s.iridescenceTexture)),void 0!==s.iridescenceIor&&(t.iridescenceIOR=s.iridescenceIor),void 0===t.iridescenceThicknessRange&&(t.iridescenceThicknessRange=[100,400]),void 0!==s.iridescenceThicknessMinimum&&(t.iridescenceThicknessRange[0]=s.iridescenceThicknessMinimum),void 0!==s.iridescenceThicknessMaximum&&(t.iridescenceThicknessRange[1]=s.iridescenceThicknessMaximum),void 0!==s.iridescenceThicknessTexture&&r.push(i.assignTexture(t,"iridescenceThicknessMap",s.iridescenceThicknessTexture)),Promise.all(r)}}class GLTFMaterialsSheenExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new three.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const s=n.extensions[this.name];return void 0!==s.sheenColorFactor&&t.sheenColor.fromArray(s.sheenColorFactor),void 0!==s.sheenRoughnessFactor&&(t.sheenRoughness=s.sheenRoughnessFactor),void 0!==s.sheenColorTexture&&r.push(i.assignTexture(t,"sheenColorMap",s.sheenColorTexture,three.SRGBColorSpace)),void 0!==s.sheenRoughnessTexture&&r.push(i.assignTexture(t,"sheenRoughnessMap",s.sheenRoughnessTexture)),Promise.all(r)}}class GLTFMaterialsTransmissionExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];return void 0!==s.transmissionFactor&&(t.transmission=s.transmissionFactor),void 0!==s.transmissionTexture&&r.push(i.assignTexture(t,"transmissionMap",s.transmissionTexture)),Promise.all(r)}}class GLTFMaterialsVolumeExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];t.thickness=void 0!==s.thicknessFactor?s.thicknessFactor:0,void 0!==s.thicknessTexture&&r.push(i.assignTexture(t,"thicknessMap",s.thicknessTexture)),t.attenuationDistance=s.attenuationDistance||1/0;const a=s.attenuationColor||[1,1,1];return t.attenuationColor=new three.Color(a[0],a[1],a[2]),Promise.all(r)}}class GLTFMaterialsIorExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name];return t.ior=void 0!==n.ior?n.ior:1.5,Promise.resolve()}}class GLTFMaterialsSpecularExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];t.specularIntensity=void 0!==s.specularFactor?s.specularFactor:1,void 0!==s.specularTexture&&r.push(i.assignTexture(t,"specularIntensityMap",s.specularTexture));const a=s.specularColorFactor||[1,1,1];return t.specularColor=new three.Color(a[0],a[1],a[2]),void 0!==s.specularColorTexture&&r.push(i.assignTexture(t,"specularColorMap",s.specularColorTexture,three.SRGBColorSpace)),Promise.all(r)}}class GLTFMaterialsAnisotropyExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];return void 0!==s.anisotropyStrength&&(t.anisotropy=s.anisotropyStrength),void 0!==s.anisotropyRotation&&(t.anisotropyRotation=s.anisotropyRotation),void 0!==s.anisotropyTexture&&r.push(i.assignTexture(t,"anisotropyMap",s.anisotropyTexture)),Promise.all(r)}}class GLTFTextureBasisUExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,i=t.json,n=i.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const r=n.extensions[this.name],s=t.options.ktx2Loader;if(!s){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,s)}}class GLTFTextureWebPExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,n=i.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const s=r.extensions[t],a=n.images[s.source];let o=i.textureLoader;if(a.uri){const e=i.options.manager.getHandler(a.uri);null!==e&&(o=e)}return this.detectSupport().then((function(r){if(r)return i.loadTextureImage(e,s.source,o);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(1===t.height)}}))),this.isSupported}}class GLTFTextureAVIFExtension$1{constructor(e){this.parser=e,this.name=EXTENSIONS$1.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,n=i.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const s=r.extensions[t],a=n.images[s.source];let o=i.textureLoader;if(a.uri){const e=i.options.manager.getHandler(a.uri);null!==e&&(o=e)}return this.detectSupport().then((function(r){if(r)return i.loadTextureImage(e,s.source,o);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return i.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(1===t.height)}}))),this.isSupported}}class GLTFMeshoptCompression$1{constructor(e){this.name=EXTENSIONS$1.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,i=t.bufferViews[e];if(i.extensions&&i.extensions[this.name]){const e=i.extensions[this.name],n=this.parser.getDependency("buffer",e.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return n.then((function(t){const i=e.byteOffset||0,n=e.byteLength||0,s=e.count,a=e.byteStride,o=new Uint8Array(t,i,n);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(s,a,o,e.mode,e.filter).then((function(e){return e.buffer})):r.ready.then((function(){const t=new ArrayBuffer(s*a);return r.decodeGltfBuffer(new Uint8Array(t),s,a,o,e.mode,e.filter),t}))}))}return null}}class GLTFMeshGpuInstancing$1{constructor(e){this.name=EXTENSIONS$1.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,i=t.nodes[e];if(!i.extensions||!i.extensions[this.name]||void 0===i.mesh)return null;const n=t.meshes[i.mesh];for(const o of n.primitives)if(o.mode!==WEBGL_CONSTANTS$1.TRIANGLES&&o.mode!==WEBGL_CONSTANTS$1.TRIANGLE_STRIP&&o.mode!==WEBGL_CONSTANTS$1.TRIANGLE_FAN&&void 0!==o.mode)return null;const r=i.extensions[this.name].attributes,s=[],a={};for(const o in r)s.push(this.parser.getDependency("accessor",r[o]).then((e=>(a[o]=e,a[o]))));return s.length<1?null:(s.push(this.parser.createNodeMesh(e)),Promise.all(s).then((e=>{const t=e.pop(),i=t.isGroup?t.children:[t],n=e[0].count,r=[];for(const s of i){const e=new three.Matrix4,t=new three.Vector3,i=new three.Quaternion,o=new three.Vector3(1,1,1),l=new three.InstancedMesh(s.geometry,s.material,n);for(let r=0;r<n;r++)a.TRANSLATION&&t.fromBufferAttribute(a.TRANSLATION,r),a.ROTATION&&i.fromBufferAttribute(a.ROTATION,r),a.SCALE&&o.fromBufferAttribute(a.SCALE,r),l.setMatrixAt(r,e.compose(t,i,o));for(const n in a)"TRANSLATION"!==n&&"ROTATION"!==n&&"SCALE"!==n&&s.geometry.setAttribute(n,a[n]);three.Object3D.prototype.copy.call(l,s),this.parser.assignFinalMaterial(l),r.push(l)}return t.isGroup?(t.clear(),t.add(...r),t):r[0]})))}}const BINARY_EXTENSION_ENCRYPT_FLAG="embf",BINARY_EXTENSION_HEADER_MAGIC$1="glTF",BINARY_EXTENSION_HEADER_LENGTH$1=12,BINARY_EXTENSION_CHUNK_TYPES$1={JSON:1313821514,BIN:5130562};class GLTFBinaryExtension$1{constructor(e){this.name=EXTENSIONS$1.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new TextDecoder;let i=0;if(t.decode(new Uint8Array(e.slice(0,4)))===BINARY_EXTENSION_ENCRYPT_FLAG){if(1===new Uint8Array(e,4,1)[0]){i=6+new Uint8Array(e,5,1)[0]}}const n=new DataView(e,i,BINARY_EXTENSION_HEADER_LENGTH$1);if(this.header={magic:t.decode(new Uint8Array(e.slice(i,i+4))),version:n.getUint32(4,!0),length:n.getUint32(8,!0)},this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC$1)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-BINARY_EXTENSION_HEADER_LENGTH$1+i,s=new DataView(e,BINARY_EXTENSION_HEADER_LENGTH$1);let a=i;for(;a<r;){const i=s.getUint32(a,!0);a+=4;const n=s.getUint32(a,!0);if(a+=4,n===BINARY_EXTENSION_CHUNK_TYPES$1.JSON){const n=new Uint8Array(e,BINARY_EXTENSION_HEADER_LENGTH$1+a,i);this.content=t.decode(n)}else if(n===BINARY_EXTENSION_CHUNK_TYPES$1.BIN){const t=BINARY_EXTENSION_HEADER_LENGTH$1+a;this.body=e.slice(t,t+i)}a+=i}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension$1{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const i=this.json,n=this.dracoLoader,r=e.extensions[this.name].bufferView,s=e.extensions[this.name].attributes,a={},o={},l={};for(const c in s){const e=ATTRIBUTES$1[c]||c.toLowerCase();a[e]=s[c]}for(const c in e.attributes){const t=ATTRIBUTES$1[c]||c.toLowerCase();if(void 0!==s[c]){const n=i.accessors[e.attributes[c]],r=WEBGL_COMPONENT_TYPES$1[n.componentType];l[t]=r.name,o[t]=!0===n.normalized}}return t.getDependency("bufferView",r).then((function(e){return new Promise((function(t){n.decodeDracoFile(e,(function(e){for(const t in e.attributes){const i=e.attributes[t],n=o[t];void 0!==n&&(i.normalized=n)}t(e)}),a,l)}))}))}}class GLTFTextureTransformExtension$1{constructor(){this.name=EXTENSIONS$1.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&t.texCoord!==e.channel||void 0!==t.offset||void 0!==t.rotation||void 0!==t.scale?(e=e.clone(),void 0!==t.texCoord&&(e.channel=t.texCoord),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0,e):e}}class GLTFMeshQuantizationExtension$1{constructor(){this.name=EXTENSIONS$1.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant$1 extends three.Interpolant{constructor(e,t,i,n){super(e,t,i,n)}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=e*n*3+n;for(let s=0;s!==n;s++)t[s]=i[r+s];return t}interpolate_(e,t,i,n){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=2*a,l=3*a,c=n-t,h=(i-t)/c,u=h*h,d=u*h,p=e*l,m=p-l,f=-2*d+3*u,g=d-u,_=1-f,A=g-u+h;for(let v=0;v!==a;v++){const e=s[m+v+a],t=s[m+v+o]*c,i=s[p+v+a],n=s[p+v]*c;r[v]=_*e+A*t+f*i+g*n}return r}}const _q=new three.Quaternion;class GLTFCubicSplineQuaternionInterpolant$1 extends GLTFCubicSplineInterpolant$1{interpolate_(e,t,i,n){const r=super.interpolate_(e,t,i,n);return _q.fromArray(r).normalize().toArray(r),r}}const WEBGL_CONSTANTS$1={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},WEBGL_COMPONENT_TYPES$1={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS$1={9728:three.NearestFilter,9729:three.LinearFilter,9984:three.NearestMipmapNearestFilter,9985:three.LinearMipmapNearestFilter,9986:three.NearestMipmapLinearFilter,9987:three.LinearMipmapLinearFilter},WEBGL_WRAPPINGS$1={33071:three.ClampToEdgeWrapping,33648:three.MirroredRepeatWrapping,10497:three.RepeatWrapping},WEBGL_TYPE_SIZES$1={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES$1={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES$1={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION$1={CUBICSPLINE:void 0,LINEAR:three.InterpolateLinear,STEP:three.InterpolateDiscrete},ALPHA_MODES$1={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function createDefaultMaterial$1(e){return void 0===e.DefaultMaterial&&(e.DefaultMaterial=new three.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:three.FrontSide})),e.DefaultMaterial}function addUnknownExtensionsToUserData$1(e,t,i){for(const n in i.extensions)void 0===e[n]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[n]=i.extensions[n])}function assignExtrasToUserData$1(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function addMorphTargets$1(e,t,i){let n=!1,r=!1,s=!1;for(let c=0,h=t.length;c<h;c++){const e=t[c];if(void 0!==e.POSITION&&(n=!0),void 0!==e.NORMAL&&(r=!0),void 0!==e.COLOR_0&&(s=!0),n&&r&&s)break}if(!n&&!r&&!s)return Promise.resolve(e);const a=[],o=[],l=[];for(let c=0,h=t.length;c<h;c++){const h=t[c];if(n){const t=void 0!==h.POSITION?i.getDependency("accessor",h.POSITION):e.attributes.position;a.push(t)}if(r){const t=void 0!==h.NORMAL?i.getDependency("accessor",h.NORMAL):e.attributes.normal;o.push(t)}if(s){const t=void 0!==h.COLOR_0?i.getDependency("accessor",h.COLOR_0):e.attributes.color;l.push(t)}}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l)]).then((function(t){const i=t[0],a=t[1],o=t[2];return n&&(e.morphAttributes.position=i),r&&(e.morphAttributes.normal=a),s&&(e.morphAttributes.color=o),e.morphTargetsRelative=!0,e}))}function updateMorphTargets$1(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let i=0,n=t.weights.length;i<n;i++)e.morphTargetInfluences[i]=t.weights[i];if(t.extras&&Array.isArray(t.extras.targetNames)){const i=t.extras.targetNames;if(e.morphTargetInfluences.length===i.length){e.morphTargetDictionary={};for(let t=0,n=i.length;t<n;t++)e.morphTargetDictionary[i[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function createPrimitiveKey$1(e){let t;const i=e.extensions&&e.extensions[EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION];if(t=i?"draco:"+i.bufferView+":"+i.indices+":"+createAttributesKey$1(i.attributes):e.indices+":"+createAttributesKey$1(e.attributes)+":"+e.mode,void 0!==e.targets)for(let n=0,r=e.targets.length;n<r;n++)t+=":"+createAttributesKey$1(e.targets[n]);return t}function createAttributesKey$1(e){let t="";const i=Object.keys(e).sort();for(let n=0,r=i.length;n<r;n++)t+=i[n]+":"+e[i[n]]+";";return t}function getNormalizedComponentScale$1(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function getImageURIMimeType$1(e){return e.search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/)?"image/jpeg":e.search(/\.webp($|\?)/i)>0||0===e.search(/^data\:image\/webp/)?"image/webp":"image/png"}const _identityMatrix$1=new three.Matrix4;class GLTFParser$1{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new GLTFRegistry$1,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let i=!1,n=!1,r=-1;"undefined"!=typeof navigator&&(i=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),n=navigator.userAgent.indexOf("Firefox")>-1,r=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),"undefined"==typeof createImageBitmap||i||n&&r<98?this.textureLoader=new three.TextureLoader(this.options.manager):this.textureLoader=new three.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new three.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const i=this,n=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll((function(e){return e._markDefs&&e._markDefs()})),Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])})).then((function(t){const s={scene:t[0][n.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:n.asset,parser:i,userData:{}};addUnknownExtensionsToUserData$1(r,s,n),assignExtrasToUserData$1(s,n),Promise.all(i._invokeAll((function(e){return e.afterRoot&&e.afterRoot(s)}))).then((function(){e(s)}))})).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const i=t[n].joints;for(let t=0,n=i.length;t<n;t++)e[i[t]].isBone=!0}for(let n=0,r=e.length;n<r;n++){const t=e[n];void 0!==t.mesh&&(this._addNodeRef(this.meshCache,t.mesh),void 0!==t.skin&&(i[t.mesh].isSkinnedMesh=!0)),void 0!==t.camera&&this._addNodeRef(this.cameraCache,t.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;const n=i.clone(),r=(e,t)=>{const i=this.associations.get(e);null!=i&&this.associations.set(t,i);for(const[n,s]of e.children.entries())r(s,t.children[n])};return r(i,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const n=e(t[i]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const i=[];for(let n=0;n<t.length;n++){const r=e(t[n]);r&&i.push(r)}return i}getDependency(e,t){const i=e+":"+t;let n=this.cache.get(i);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne((function(e){return e.loadNode&&e.loadNode(t)}));break;case"mesh":n=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":n=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne((function(e){return e.loadAnimation&&e.loadAnimation(t)}));break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne((function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)})),!n)throw new Error("Unknown type: "+e)}this.cache.add(i,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const i=this,n=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(n.map((function(t,n){return i.getDependency(e,n)}))),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],i=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[EXTENSIONS$1.KHR_BINARY_GLTF].body);const n=this.options;return new Promise((function(e,r){i.load(three.LoaderUtils.resolveURL(t.uri,n.path),e,void 0,(function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){const i=t.byteLength||0,n=t.byteOffset||0;return e.slice(n,n+i)}))}loadAccessor(e){const t=this,i=this.json,n=this.json.accessors[e];if(void 0===n.bufferView&&void 0===n.sparse){const e=WEBGL_TYPE_SIZES$1[n.type],t=WEBGL_COMPONENT_TYPES$1[n.componentType],i=!0===n.normalized,r=new t(n.count*e);return Promise.resolve(new three.BufferAttribute(r,e,i))}const r=[];return void 0!==n.bufferView?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),void 0!==n.sparse&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then((function(e){const r=e[0],s=WEBGL_TYPE_SIZES$1[n.type],a=WEBGL_COMPONENT_TYPES$1[n.componentType],o=a.BYTES_PER_ELEMENT,l=o*s,c=n.byteOffset||0,h=void 0!==n.bufferView?i.bufferViews[n.bufferView].byteStride:void 0,u=!0===n.normalized;let d,p;if(h&&h!==l){const e=Math.floor(c/h),i="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+e+":"+n.count;let l=t.cache.get(i);l||(d=new a(r,e*h,n.count*h/o),l=new three.InterleavedBuffer(d,h/o),t.cache.add(i,l)),p=new three.InterleavedBufferAttribute(l,s,c%h/o,u)}else d=null===r?new a(n.count*s):new a(r,c,n.count*s),p=new three.BufferAttribute(d,s,u);if(void 0!==n.sparse){const t=WEBGL_TYPE_SIZES$1.SCALAR,i=WEBGL_COMPONENT_TYPES$1[n.sparse.indices.componentType],o=n.sparse.indices.byteOffset||0,l=n.sparse.values.byteOffset||0,c=new i(e[1],o,n.sparse.count*t),h=new a(e[2],l,n.sparse.count*s);null!==r&&(p=new three.BufferAttribute(p.array.slice(),p.itemSize,p.normalized));for(let e=0,n=c.length;e<n;e++){const t=c[e];if(p.setX(t,h[e*s]),s>=2&&p.setY(t,h[e*s+1]),s>=3&&p.setZ(t,h[e*s+2]),s>=4&&p.setW(t,h[e*s+3]),s>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return p}))}loadTexture(e){const t=this.json,i=this.options,n=t.textures[e].source,r=t.images[n],s=this.extensions;let a=this.textureLoader;if("image/ktx2"===r.mimeType&&s[EXTENSIONS$1.KHR_TEXTURE_BASISU])return s[EXTENSIONS$1.KHR_TEXTURE_BASISU].loadTexture(e);if(r.uri){const e=i.manager.getHandler(r.uri);null!==e&&(a=e)}return this.loadTextureImage(e,n,a)}loadTextureImage(e,t,i){const n=this,r=this.json,s=r.textures[e],a=r.images[t],o=(a.uri||a.bufferView)+":"+s.sampler;if(this.textureCache[o])return this.textureCache[o];const l=this.loadImageSource(t,i).then((function(t){t.flipY=!1,t.name=s.name||a.name||"",""===t.name&&"string"==typeof a.uri&&!1===a.uri.startsWith("data:image/")&&(t.name=a.uri);const i=(r.samplers||{})[s.sampler]||{};return t.magFilter=WEBGL_FILTERS$1[i.magFilter]||three.LinearFilter,t.minFilter=WEBGL_FILTERS$1[i.minFilter]||three.LinearMipmapLinearFilter,t.wrapS=WEBGL_WRAPPINGS$1[i.wrapS]||three.RepeatWrapping,t.wrapT=WEBGL_WRAPPINGS$1[i.wrapT]||three.RepeatWrapping,n.associations.set(t,{textures:e}),t})).catch((function(){return null}));return this.textureCache[o]=l,l}loadImageSource(e,t){const i=this,n=this.json,r=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then((e=>e.clone()));const s=n.images[e],a=self.URL||self.webkitURL;let o=s.uri||"",l=!1;if(void 0!==s.bufferView)o=i.getDependency("bufferView",s.bufferView).then((function(e){l=!0;const t=new Blob([e],{type:s.mimeType});return o=a.createObjectURL(t),o}));else if(void 0===s.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(o).then((function(e){return new Promise((function(i,n){let s=i;!0===t.isImageBitmapLoader&&(s=function(e){const t=new three.Texture(e);t.needsUpdate=!0,i(t)}),t.load(three.LoaderUtils.resolveURL(e,r.path),s,void 0,n)}))})).then((function(e){return!0===l&&a.revokeObjectURL(o),e.userData.mimeType=s.mimeType||getImageURIMimeType$1(s.uri),e})).catch((function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",o),e}));return this.sourceCache[e]=c,c}assignTexture(e,t,i,n){const r=this;return this.getDependency("texture",i.index).then((function(s){if(!s)return null;if(void 0!==i.texCoord&&i.texCoord>0&&((s=s.clone()).channel=i.texCoord),r.extensions[EXTENSIONS$1.KHR_TEXTURE_TRANSFORM]){const e=void 0!==i.extensions?i.extensions[EXTENSIONS$1.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=r.associations.get(s);s=r.extensions[EXTENSIONS$1.KHR_TEXTURE_TRANSFORM].extendTexture(s,e),r.associations.set(s,t)}}return void 0!==n&&(s.colorSpace=n),e[t]=s,s}))}assignFinalMaterial(e){const t=e.geometry;let i=e.material;const n=void 0===t.attributes.tangent,r=void 0!==t.attributes.color,s=void 0===t.attributes.normal;if(e.isPoints){const e="PointsMaterial:"+i.uuid;let t=this.cache.get(e);t||(t=new three.PointsMaterial,three.Material.prototype.copy.call(t,i),t.color.copy(i.color),t.map=i.map,t.sizeAttenuation=!1,this.cache.add(e,t)),i=t}else if(e.isLine){const e="LineBasicMaterial:"+i.uuid;let t=this.cache.get(e);t||(t=new three.LineBasicMaterial,three.Material.prototype.copy.call(t,i),t.color.copy(i.color),t.map=i.map,this.cache.add(e,t)),i=t}if(n||r||s){let e="ClonedMaterial:"+i.uuid+":";n&&(e+="derivative-tangents:"),r&&(e+="vertex-colors:"),s&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=i.clone(),r&&(t.vertexColors=!0),s&&(t.flatShading=!0),n&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(i))),i=t}e.material=i}getMaterialType(){return three.MeshStandardMaterial}loadMaterial(e){const t=this,i=this.json,n=this.extensions,r=i.materials[e];let s;const a={},o=[];if((r.extensions||{})[EXTENSIONS$1.KHR_MATERIALS_UNLIT]||t.options.forceUnlit){const e=n[EXTENSIONS$1.KHR_MATERIALS_UNLIT];s=e.getMaterialType(),o.push(e.extendParams(a,r,t))}else{const i=r.pbrMetallicRoughness||{};if(a.color=new three.Color(1,1,1),a.opacity=1,Array.isArray(i.baseColorFactor)){const e=i.baseColorFactor;a.color.fromArray(e),a.opacity=e[3]}void 0!==i.baseColorTexture&&o.push(t.assignTexture(a,"map",i.baseColorTexture,three.SRGBColorSpace)),a.metalness=void 0!==i.metallicFactor?i.metallicFactor:1,a.roughness=void 0!==i.roughnessFactor?i.roughnessFactor:1,void 0!==i.metallicRoughnessTexture&&(o.push(t.assignTexture(a,"metalnessMap",i.metallicRoughnessTexture)),o.push(t.assignTexture(a,"roughnessMap",i.metallicRoughnessTexture))),s=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),o.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,a)}))))}!0===r.doubleSided&&(a.side=three.DoubleSide);const l=r.alphaMode||ALPHA_MODES$1.OPAQUE;if(l===ALPHA_MODES$1.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,l===ALPHA_MODES$1.MASK&&(a.alphaTest=void 0!==r.alphaCutoff?r.alphaCutoff:.5)),void 0!==r.normalTexture&&s!==three.MeshBasicMaterial&&(o.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new three.Vector2(1,1),void 0!==r.normalTexture.scale)){const e=r.normalTexture.scale;a.normalScale.set(e,e)}return void 0!==r.occlusionTexture&&s!==three.MeshBasicMaterial&&(o.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),void 0!==r.occlusionTexture.strength&&(a.aoMapIntensity=r.occlusionTexture.strength)),void 0!==r.emissiveFactor&&s!==three.MeshBasicMaterial&&(a.emissive=(new three.Color).fromArray(r.emissiveFactor)),void 0!==r.emissiveTexture&&s!==three.MeshBasicMaterial&&o.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,three.SRGBColorSpace)),Promise.all(o).then((function(){const i=new s(a);return r.name&&(i.name=r.name),assignExtrasToUserData$1(i,r),t.associations.set(i,{materials:e}),r.extensions&&addUnknownExtensionsToUserData$1(n,i,r),i}))}createUniqueName(e){const t=three.PropertyBinding.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,i=this.extensions,n=this.primitiveCache;function r(e){return i[EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(i){return addPrimitiveAttributes$1(i,e,t)}))}const s=[];for(let a=0,o=e.length;a<o;a++){const i=e[a],o=createPrimitiveKey$1(i),l=n[o];if(l)s.push(l.promise);else{let e;e=i.extensions&&i.extensions[EXTENSIONS$1.KHR_DRACO_MESH_COMPRESSION]?r(i):addPrimitiveAttributes$1(new three.BufferGeometry,i,t),n[o]={primitive:i,promise:e},s.push(e)}}return Promise.all(s)}loadMesh(e){const t=this,i=this.json,n=this.extensions,r=i.meshes[e],s=r.primitives,a=[];for(let o=0,l=s.length;o<l;o++){const e=void 0===s[o].material?createDefaultMaterial$1(this.cache):this.getDependency("material",s[o].material);a.push(e)}return a.push(t.loadGeometries(s)),Promise.all(a).then((function(i){const a=i.slice(0,i.length-1),o=i[i.length-1],l=[];for(let h=0,u=o.length;h<u;h++){const i=o[h],c=s[h];let u;const d=a[h];if(c.mode===WEBGL_CONSTANTS$1.TRIANGLES||c.mode===WEBGL_CONSTANTS$1.TRIANGLE_STRIP||c.mode===WEBGL_CONSTANTS$1.TRIANGLE_FAN||void 0===c.mode)u=!0===r.isSkinnedMesh?new three.SkinnedMesh(i,d):new three.Mesh(i,d),!0===u.isSkinnedMesh&&u.normalizeSkinWeights(),c.mode===WEBGL_CONSTANTS$1.TRIANGLE_STRIP?u.geometry=toTrianglesDrawMode(u.geometry,three.TriangleStripDrawMode):c.mode===WEBGL_CONSTANTS$1.TRIANGLE_FAN&&(u.geometry=toTrianglesDrawMode(u.geometry,three.TriangleFanDrawMode));else if(c.mode===WEBGL_CONSTANTS$1.LINES)u=new three.LineSegments(i,d);else if(c.mode===WEBGL_CONSTANTS$1.LINE_STRIP)u=new three.Line(i,d);else if(c.mode===WEBGL_CONSTANTS$1.LINE_LOOP)u=new three.LineLoop(i,d);else{if(c.mode!==WEBGL_CONSTANTS$1.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+c.mode);u=new three.Points(i,d)}Object.keys(u.geometry.morphAttributes).length>0&&updateMorphTargets$1(u,r),u.name=t.createUniqueName(r.name||"mesh_"+e),assignExtrasToUserData$1(u,r),c.extensions&&addUnknownExtensionsToUserData$1(n,u,c),t.assignFinalMaterial(u),l.push(u)}for(let n=0,r=l.length;n<r;n++)t.associations.set(l[n],{meshes:e,primitives:n});if(1===l.length)return r.extensions&&addUnknownExtensionsToUserData$1(n,l[0],r),l[0];const c=new three.Group;r.extensions&&addUnknownExtensionsToUserData$1(n,c,r),t.associations.set(c,{meshes:e});for(let e=0,t=l.length;e<t;e++)c.add(l[e]);return c}))}loadCamera(e){let t;const i=this.json.cameras[e],n=i[i.type];if(n)return"perspective"===i.type?t=new three.PerspectiveCamera(three.MathUtils.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):"orthographic"===i.type&&(t=new three.OrthographicCamera(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),i.name&&(t.name=this.createUniqueName(i.name)),assignExtrasToUserData$1(t,i),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],i=[];for(let n=0,r=t.joints.length;n<r;n++)i.push(this._loadNodeShallow(t.joints[n]));return void 0!==t.inverseBindMatrices?i.push(this.getDependency("accessor",t.inverseBindMatrices)):i.push(null),Promise.all(i).then((function(e){const i=e.pop(),n=e,r=[],s=[];for(let a=0,o=n.length;a<o;a++){const e=n[a];if(e){r.push(e);const t=new three.Matrix4;null!==i&&t.fromArray(i.array,16*a),s.push(t)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[a])}return new three.Skeleton(r,s)}))}loadAnimation(e){const t=this.json.animations[e],i=t.name?t.name:"animation_"+e,n=[],r=[],s=[],a=[],o=[];for(let l=0,c=t.channels.length;l<c;l++){const e=t.channels[l],i=t.samplers[e.sampler],c=e.target,h=c.node,u=void 0!==t.parameters?t.parameters[i.input]:i.input,d=void 0!==t.parameters?t.parameters[i.output]:i.output;void 0!==c.node&&(n.push(this.getDependency("node",h)),r.push(this.getDependency("accessor",u)),s.push(this.getDependency("accessor",d)),a.push(i),o.push(c))}return Promise.all([Promise.all(n),Promise.all(r),Promise.all(s),Promise.all(a),Promise.all(o)]).then((function(e){const t=e[0],n=e[1],r=e[2],s=e[3],a=e[4],o=[];for(let i=0,l=t.length;i<l;i++){const e=t[i],l=n[i],c=r[i],h=s[i],u=a[i];if(void 0===e)continue;let d;switch(e.updateMatrix(),PATH_PROPERTIES$1[u.path]){case PATH_PROPERTIES$1.weights:d=three.NumberKeyframeTrack;break;case PATH_PROPERTIES$1.rotation:d=three.QuaternionKeyframeTrack;break;case PATH_PROPERTIES$1.position:case PATH_PROPERTIES$1.scale:default:d=three.VectorKeyframeTrack}const p=e.name?e.name:e.uuid,m=void 0!==h.interpolation?INTERPOLATION$1[h.interpolation]:three.InterpolateLinear,f=[];PATH_PROPERTIES$1[u.path]===PATH_PROPERTIES$1.weights?e.traverse((function(e){e.morphTargetInfluences&&f.push(e.name?e.name:e.uuid)})):f.push(p);let g=c.array;if(c.normalized){const e=getNormalizedComponentScale$1(g.constructor),t=new Float32Array(g.length);for(let i=0,n=g.length;i<n;i++)t[i]=g[i]*e;g=t}for(let t=0,i=f.length;t<i;t++){const e=new d(f[t]+"."+PATH_PROPERTIES$1[u.path],l.array,g,m);"CUBICSPLINE"===h.interpolation&&(e.createInterpolant=function(e){return new(this instanceof three.QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant$1:GLTFCubicSplineInterpolant$1)(this.times,this.values,this.getValueSize()/3,e)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),o.push(e)}}return new three.AnimationClip(i,void 0,o)}))}createNodeMesh(e){const t=this.json,i=this,n=t.nodes[e];return void 0===n.mesh?null:i.getDependency("mesh",n.mesh).then((function(e){const t=i._getNodeRef(i.meshCache,n.mesh,e);return void 0!==n.weights&&t.traverse((function(e){if(e.isMesh)for(let t=0,i=n.weights.length;t<i;t++)e.morphTargetInfluences[t]=n.weights[t]})),t}))}loadNode(e){const t=this,i=this.json.nodes[e],n=t._loadNodeShallow(e),r=[],s=i.children||[];for(let o=0,l=s.length;o<l;o++)r.push(t.getDependency("node",s[o]));const a=void 0===i.skin?Promise.resolve(null):t.getDependency("skin",i.skin);return Promise.all([n,Promise.all(r),a]).then((function(e){const t=e[0],i=e[1],n=e[2];null!==n&&t.traverse((function(e){e.isSkinnedMesh&&e.bind(n,_identityMatrix$1)}));for(let r=0,s=i.length;r<s;r++)t.add(i[r]);return t}))}_loadNodeShallow(e){const t=this.json,i=this.extensions,n=this;if(void 0!==this.nodeCache[e])return this.nodeCache[e];const r=t.nodes[e],s=r.name?n.createUniqueName(r.name):"",a=[],o=n._invokeOne((function(t){return t.createNodeMesh&&t.createNodeMesh(e)}));return o&&a.push(o),void 0!==r.camera&&a.push(n.getDependency("camera",r.camera).then((function(e){return n._getNodeRef(n.cameraCache,r.camera,e)}))),n._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){a.push(e)})),this.nodeCache[e]=Promise.all(a).then((function(t){let a;if(a=!0===r.isBone?new three.Bone:t.length>1?new three.Group:1===t.length?t[0]:new three.Object3D,a!==t[0])for(let e=0,i=t.length;e<i;e++)a.add(t[e]);if(r.name&&(a.userData.name=r.name,a.name=s),assignExtrasToUserData$1(a,r),r.extensions&&addUnknownExtensionsToUserData$1(i,a,r),void 0!==r.matrix){const e=new three.Matrix4;e.fromArray(r.matrix),a.applyMatrix4(e)}else void 0!==r.translation&&a.position.fromArray(r.translation),void 0!==r.rotation&&a.quaternion.fromArray(r.rotation),void 0!==r.scale&&a.scale.fromArray(r.scale);return n.associations.has(a)||n.associations.set(a,{}),n.associations.get(a).nodes=e,a})),this.nodeCache[e]}loadScene(e){const t=this.extensions,i=this.json.scenes[e],n=this,r=new three.Group;i.name&&(r.name=n.createUniqueName(i.name)),assignExtrasToUserData$1(r,i),i.extensions&&addUnknownExtensionsToUserData$1(t,r,i);const s=i.nodes||[],a=[];for(let o=0,l=s.length;o<l;o++)a.push(n.getDependency("node",s[o]));return Promise.all(a).then((function(e){for(let t=0,i=e.length;t<i;t++)r.add(e[t]);return n.associations=(e=>{const t=new Map;for(const[i,r]of n.associations)(i instanceof three.Material||i instanceof three.Texture)&&t.set(i,r);return e.traverse((e=>{const i=n.associations.get(e);null!=i&&t.set(e,i)})),t})(r),r}))}}function computeBounds$1(e,t,i){const n=t.attributes,r=new three.Box3;if(void 0===n.POSITION)return;{const e=i.json.accessors[n.POSITION],t=e.min,s=e.max;if(void 0===t||void 0===s)return void warnOnce("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(r.set(new three.Vector3(t[0],t[1],t[2]),new three.Vector3(s[0],s[1],s[2])),e.normalized){const t=getNormalizedComponentScale$1(WEBGL_COMPONENT_TYPES$1[e.componentType]);r.min.multiplyScalar(t),r.max.multiplyScalar(t)}}const s=t.targets;if(void 0!==s){const e=new three.Vector3,t=new three.Vector3;for(let n=0,r=s.length;n<r;n++){const r=s[n];if(void 0!==r.POSITION){const n=i.json.accessors[r.POSITION],s=n.min,a=n.max;if(void 0!==s&&void 0!==a){if(t.setX(Math.max(Math.abs(s[0]),Math.abs(a[0]))),t.setY(Math.max(Math.abs(s[1]),Math.abs(a[1]))),t.setZ(Math.max(Math.abs(s[2]),Math.abs(a[2]))),n.normalized){const e=getNormalizedComponentScale$1(WEBGL_COMPONENT_TYPES$1[n.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}r.expandByVector(e)}e.boundingBox=r;const a=new three.Sphere;r.getCenter(a.center),a.radius=r.min.distanceTo(r.max)/2,e.boundingSphere=a}function addPrimitiveAttributes$1(e,t,i){const n=t.attributes,r=[];function s(t,n){return i.getDependency("accessor",t).then((function(t){e.setAttribute(n,t)}))}for(const a in n){const t=ATTRIBUTES$1[a]||a.toLowerCase();t in e.attributes||r.push(s(n[a],t))}if(void 0!==t.indices&&!e.index){const n=i.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));r.push(n)}return assignExtrasToUserData$1(e,t),computeBounds$1(e,t,i),Promise.all(r).then((function(){return void 0!==t.targets?addMorphTargets$1(e,t.targets,i):e}))}var MeshoptDecoder=function(){var e=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),t=new Uint8Array([32,0,65,2,1,106,34,33,3,128,11,4,13,64,6,253,10,7,15,116,127,5,8,12,40,16,19,54,20,9,27,255,113,17,42,67,24,23,146,148,18,14,22,45,70,69,56,114,101,21,25,63,75,136,108,28,118,29,73,115]);if("object"!=typeof WebAssembly)return{supported:!1};var i,n=WebAssembly.validate(e)?s("b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q:6dkr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq:p9sqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk:N8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhlaicefhodnaeTmbadTmbalc;WFbGglcjdalcjd6EhwcbhDinawaeaD9RaDawfae6Egqcsfglc9WGgkci2hxakcethmalcl4cifcd4hPabaDad2fhsakc;ab6hzcbhHincbhOaohAdndninaraA9RaP6meavcj;cbfaOak2fhCaAaPfhocbhidnazmbarao9Rc;Gb6mbcbhlinaCalfhidndndndndnaAalco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklbaoczfhokdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklzaoczfhokdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaiaopbbbpklaaoczfhokdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaiaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WaoclfaYpQbfaXc:q:yjjbfRbbfhoxdkaiaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WaocwfaYpQbfaXc:q:yjjbfRbbfhoxekaiaopbbbpkl8Waoczfhokalc;abfhialcjefak0meaihlarao9Rc;Fb0mbkkdnaiak9pmbaici4hlinarao9RcK6miaCaifhXdndndndndnaAaico4fRbbalcoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpkbbxikaXaopbblaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkbbaoclfaYpQbfaKc:q:yjjbfRbbfhoxdkaXaopbbwaopbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkbbaocwfaYpQbfaKc:q:yjjbfRbbfhoxekaXaopbbbpkbbaoczfhokalcdfhlaiczfgiak6mbkkaoTmeaohAaOcefgOclSmdxbkkc9:hoxlkdnakTmbavcjdfaHfhiavaHfpbdbhYcbhXinaiavcj;cbfaXfglpblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLalakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEalamfpblbg3cep9Ta3aQp9op9Hp9rg3alaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfglaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaladfglaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaladfglaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaladfglaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaladfhiaXczfgXak6mbkkaHclfgHad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfgDae6mbkkcbc99arao9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk::seHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgwce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhDaicefgqarfhidnaeTmbcmcsawceSEhkcbhxcbhmcbhPcbhwcbhlindnaiaD9nmbc9:hoxikdndnaqRbbgoc;Ve0mbavc;abfalaocu7gscl4fcsGcitfgzydlhrazydbhzdnaocsGgHak9pmbavawasfcsGcdtfydbaxaHEhoaHThsdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkaxasfhxcdhHavawcdtfaoBdbawasfhwcehsalhOxdkdndnaHcsSmbaHc987aHamffcefhoxekaicefhoai8SbbgHcFeGhsdndnaHcu9mmbaohixekaicvfhiascFbGhscrhHdninao8SbbgOcFbGaHtasVhsaOcu9kmeaocefhoaHcrfgHc8J9hmbxdkkaocefhikasce4cbasceG9R7amfhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhHavawcdtfaoBdbcehsawcefhwalhOaohmxekdnaocpe0mbaxcefgHavawaDaocsGfRbbgocl49RcsGcdtfydbaocz6gzEhravawao9RcsGcdtfydbaHazfgAaocsGgHEhoaHThCdndnadcd9hmbabaPcetfgHax87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHaxBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfaxBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgOaxBdlaOarBdbavawazfgwcsGcdtfaoBdbalcefcsGhOawaCfhwaxhzaAaCfhxxekaxcbaiRbbgOEgzaoc;:eSgHfhraOcsGhCaOcl4hAdndnaOcs0mbarcefhoxekarhoavawaA9RcsGcdtfydbhrkdndnaCmbaocefhxxekaohxavawaO9RcsGcdtfydbhokdndnaHTmbaicefhHxekaicdfhHai8SbegscFeGhzdnascu9kmbaicofhXazcFbGhzcrhidninaH8SbbgscFbGaitazVhzascu9kmeaHcefhHaicrfgic8J9hmbkaXhHxekaHcefhHkazce4cbazceG9R7amfgmhzkdndnaAcsSmbaHhsxekaHcefhsaH8SbbgicFeGhrdnaicu9kmbaHcvfhXarcFbGhrcrhidninas8SbbgHcFbGaitarVhraHcu9kmeascefhsaicrfgic8J9hmbkaXhsxekascefhskarce4cbarceG9R7amfgmhrkdndnaCcsSmbashixekascefhias8SbbgocFeGhHdnaocu9kmbascvfhXaHcFbGhHcrhodninai8SbbgscFbGaotaHVhHascu9kmeaicefhiaocrfgoc8J9hmbkaXhixekaicefhikaHce4cbaHceG9R7amfgmhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfazBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgXazBdlaXarBdbavawaOcz6aAcsSVfgwcsGcdtfaoBdbawaCTaCcsSVfhwalcefcsGhOkaqcefhqavc;abfaOcitfgOarBdlaOaoBdbavc;abfalasfcsGcitfgraoBdlarazBdbawcsGhwalaHfcsGhlaPcifgPae6mbkkcbc99aiaDSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:wPliuo97eue978Jjjjjbca9Rhiaec98Ghldndnadcl9hmbdnalTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalaeSmeaipxbbbbbbbbbbbbbbbbgqpklbaiabalcdtfgdaeciGglcdtgv;8qbbdnalTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDaqp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkadaiav;8qbbskdnalTmbcbhvabhdinadczfgxaxpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmbediwDqkzHOAKY8AEgwczp:Reczp:Sep;6egraDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eawczp:Sep;6egwp;Gearp;Gep;Kep;Legopxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegrpxb;:FSb;:FSb;:FSb;:FSararp;Meaoaop;Meawaqawamp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFFbbFFbbFFbbFFbbp9oaoawp;Meaqp;Keczp:Rep9qgoarawp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogrpmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oaoarpmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgval6mbkkalaeSmbaiaeciGgvcitgdfcbcaad9R;8kbaiabalcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmbediwDqkzHOAKY8AEgwczp:Reczp:Sep;6egraDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eawczp:Sep;6egwp;Gearp;Gep;Kep;Legopxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegrpxb;:FSb;:FSb;:FSb;:FSararp;Meaoaop;Meawaqawamp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFFbbFFbbFFbbFFbbp9oaoawp;Meaqp;Keczp:Rep9qgoarawp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogrpmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oaoarpmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaDakp;Mearp;Keamp9oaqakp;Mearp;Keczp:Rep9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalaeSmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaDakp;Mearp;Keamp9oaqakp;Mearp;Keczp:Rep9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbheabhdinadadpbbbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepkbbadczfhdaeclfgeav6mbkkdnavalSmbaialciGgecdtgdVcbc;abad9R;8kbaiabavcdtfgvad;8qbbdnaeTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepklbkavaiad;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz:Dbb"):s("b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q:Odkr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq;w8Wqdbk;esezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9Uc;WFbGgocjdaocjd6EhDaicefhocbhqdnindndndnaeaq9nmbaDaeaq9RaqaDfae6Egkcsfglcl4cifcd4hxalc9WGgmTmecbhPawcjdfhsaohzinaraz9Rax6mvarazaxfgo9RcK6mvczhlcbhHinalgic9WfgOawcj;cbffhldndndndndnazaOco4fRbbaHcoG4ciGPlbedibkal9cb83ibalcwf9cb83ibxikalaoRblaoRbbgOco4gAaAciSgAE86bbawcj;cbfaifglcGfaoclfaAfgARbbaOcl4ciGgCaCciSgCE86bbalcVfaAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc7faAaCfgARbbaOciGgOaOciSgOE86bbalctfaAaOfgARbbaoRbegOco4gCaCciSgCE86bbalc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc93faAaCfgARbbaOciGgOaOciSgOE86bbalc94faAaOfgARbbaoRbdgOco4gCaCciSgCE86bbalc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbalc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbalc97faAaCfgARbbaOciGgOaOciSgOE86bbalc98faAaOfgORbbaoRbigoco4gAaAciSgAE86bbalc99faOaAfgORbbaocl4ciGgAaAciSgAE86bbalc9:faOaAfgORbbaocd4ciGgAaAciSgAE86bbalcufaOaAfglRbbaociGgoaociSgoE86bbalaofhoxdkalaoRbwaoRbbgOcl4gAaAcsSgAE86bbawcj;cbfaifglcGfaocwfaAfgARbbaOcsGgOaOcsSgOE86bbalcVfaAaOfgORbbaoRbegAcl4gCaCcsSgCE86bbalc7faOaCfgORbbaAcsGgAaAcsSgAE86bbalctfaOaAfgORbbaoRbdgAcl4gCaCcsSgCE86bbalc91faOaCfgORbbaAcsGgAaAcsSgAE86bbalc4faOaAfgORbbaoRbigAcl4gCaCcsSgCE86bbalc93faOaCfgORbbaAcsGgAaAcsSgAE86bbalc94faOaAfgORbbaoRblgAcl4gCaCcsSgCE86bbalc95faOaCfgORbbaAcsGgAaAcsSgAE86bbalc96faOaAfgORbbaoRbvgAcl4gCaCcsSgCE86bbalc97faOaCfgORbbaAcsGgAaAcsSgAE86bbalc98faOaAfgORbbaoRbogAcl4gCaCcsSgCE86bbalc99faOaCfgORbbaAcsGgAaAcsSgAE86bbalc9:faOaAfgORbbaoRbrgocl4gAaAcsSgAE86bbalcufaOaAfglRbbaocsGgoaocsSgoE86bbalaofhoxekalao8Pbb83bbalcwfaocwf8Pbb83bbaoczfhokdnaiam9pmbaHcdfhHaiczfhlarao9RcL0mekkaiam6mvaoTmvdnakTmbawaPfRbbhHawcj;cbfhlashiakhOinaialRbbgzce4cbazceG9R7aHfgH86bbaiadfhialcefhlaOcufgOmbkkascefhsaohzaPcefgPad9hmbxikkcbc99arao9Radcaadca0ESEhoxlkaoaxad2fhCdnakmbadhlinaoTmlarao9Rax6mlaoaxfhoalcufglmbkaChoxekcbhmawcjdfhAinarao9Rax6miawamfRbbhHawcj;cbfhlaAhiakhOinaialRbbgzce4cbazceG9R7aHfgH86bbaiadfhialcefhlaOcufgOmbkaAcefhAaoaxfhoamcefgmad9hmbkaChokabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqaombkc9:hoxekc9:hokavcj;ebf8Kjjjjbaok;cseHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgwce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhDaicefgqarfhidnaeTmbcmcsawceSEhkcbhxcbhmcbhPcbhwcbhlindnaiaD9nmbc9:hoxikdndnaqRbbgoc;Ve0mbavc;abfalaocu7gscl4fcsGcitfgzydlhrazydbhzdnaocsGgHak9pmbavawasfcsGcdtfydbaxaHEhoaHThsdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkaxasfhxcdhHavawcdtfaoBdbawasfhwcehsalhOxdkdndnaHcsSmbaHc987aHamffcefhoxekaicefhoai8SbbgHcFeGhsdndnaHcu9mmbaohixekaicvfhiascFbGhscrhHdninao8SbbgOcFbGaHtasVhsaOcu9kmeaocefhoaHcrfgHc8J9hmbxdkkaocefhikasce4cbasceG9R7amfhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhHavawcdtfaoBdbcehsawcefhwalhOaohmxekdnaocpe0mbaxcefgHavawaDaocsGfRbbgocl49RcsGcdtfydbaocz6gzEhravawao9RcsGcdtfydbaHazfgAaocsGgHEhoaHThCdndnadcd9hmbabaPcetfgHax87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHaxBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfaxBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgOaxBdlaOarBdbavawazfgwcsGcdtfaoBdbalcefcsGhOawaCfhwaxhzaAaCfhxxekaxcbaiRbbgOEgzaoc;:eSgHfhraOcsGhCaOcl4hAdndnaOcs0mbarcefhoxekarhoavawaA9RcsGcdtfydbhrkdndnaCmbaocefhxxekaohxavawaO9RcsGcdtfydbhokdndnaHTmbaicefhHxekaicdfhHai8SbegscFeGhzdnascu9kmbaicofhXazcFbGhzcrhidninaH8SbbgscFbGaitazVhzascu9kmeaHcefhHaicrfgic8J9hmbkaXhHxekaHcefhHkazce4cbazceG9R7amfgmhzkdndnaAcsSmbaHhsxekaHcefhsaH8SbbgicFeGhrdnaicu9kmbaHcvfhXarcFbGhrcrhidninas8SbbgHcFbGaitarVhraHcu9kmeascefhsaicrfgic8J9hmbkaXhsxekascefhskarce4cbarceG9R7amfgmhrkdndnaCcsSmbashixekascefhias8SbbgocFeGhHdnaocu9kmbascvfhXaHcFbGhHcrhodninai8SbbgscFbGaotaHVhHascu9kmeaicefhiaocrfgoc8J9hmbkaXhixekaicefhikaHce4cbaHceG9R7amfgmhokdndnadcd9hmbabaPcetfgHaz87ebaHclfao87ebaHcdfar87ebxekabaPcdtfgHazBdbaHcwfaoBdbaHclfarBdbkcdhsavawcdtfazBdbavawcefgwcsGcdtfarBdbcihHavc;abfalcitfgXazBdlaXarBdbavawaOcz6aAcsSVfgwcsGcdtfaoBdbawaCTaCcsSVfhwalcefcsGhOkaqcefhqavc;abfaOcitfgOarBdlaOaoBdbavc;abfalasfcsGcitfgraoBdlarazBdbawcsGhwalaHfcsGhlaPcifgPae6mbkkcbc99aiaDSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;oiliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabaiavcefciGfcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:OhDxekcjjjj94hDkabaiavciGfgkcd7cetfaD87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:OhDxekcjjjj94hDkabaiavcufciGfcetfaD87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohvxekcjjjj94hvkabakcetfav87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2gdTmbinababydbgecwtcw91:Yaece91cjjj98Gcjjj;8if::NUdbabclfhbadcufgdmbkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaeczfheaiczfhiadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklzNbb"),r=WebAssembly.instantiate(n,{}).then((function(e){(i=e.instance).exports.__wasm_call_ctors()}));function s(e){for(var i=new Uint8Array(e.length),n=0;n<e.length;++n){var r=e.charCodeAt(n);i[n]=r>96?r-97:r>64?r-39:r+4}var s=0;for(n=0;n<e.length;++n)i[s++]=i[n]<60?t[i[n]]:64*(i[n]-60)+i[++n];return i.buffer.slice(0,s)}function a(e,t,i,n,r,s,a){var o=e.exports.sbrk,l=n+3&-4,c=o(l*r),h=o(s.length),u=new Uint8Array(e.exports.memory.buffer);u.set(s,h);var d=t(c,n,r,h,s.length);if(0==d&&a&&a(c,l,r),i.set(u.subarray(c,c+n*r)),o(c-o(0)),0!=d)throw new Error("Malformed buffer data: "+d)}var o={NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},l={ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"},c=[],h=0;function u(e){var t={object:new Worker(e),pending:0,requests:{}};return t.object.onmessage=function(e){var i=e.data;t.pending-=i.count,t.requests[i.id][i.action](i.value),delete t.requests[i.id]},t}function d(e){var t=e.data;if(!t.id)return self.close();self.ready.then((function(e){try{var i=new Uint8Array(t.count*t.size);a(e,e.exports[t.mode],i,t.count,t.size,t.source,e.exports[t.filter]),self.postMessage({id:t.id,count:t.count,action:"resolve",value:i},[i.buffer])}catch(n){self.postMessage({id:t.id,count:t.count,action:"reject",value:n})}}))}return{ready:r,supported:!0,useWorkers:function(e){!function(e){for(var t="self.ready = WebAssembly.instantiate(new Uint8Array(["+new Uint8Array(n)+"]), {}).then(function(result) { result.instance.exports.__wasm_call_ctors(); return result.instance; });self.onmessage = "+d.name+";"+a.toString()+d.toString(),i=new Blob([t],{type:"text/javascript"}),r=URL.createObjectURL(i),s=c.length;s<e;++s)c[s]=u(r);for(s=e;s<c.length;++s)c[s].object.postMessage({});c.length=e,URL.revokeObjectURL(r)}(e)},decodeVertexBuffer:function(e,t,n,r,s){a(i,i.exports.meshopt_decodeVertexBuffer,e,t,n,r,i.exports[o[s]])},decodeIndexBuffer:function(e,t,n,r){a(i,i.exports.meshopt_decodeIndexBuffer,e,t,n,r)},decodeIndexSequence:function(e,t,n,r){a(i,i.exports.meshopt_decodeIndexSequence,e,t,n,r)},decodeGltfBuffer:function(e,t,n,r,s,c){a(i,i.exports[l[s]],e,t,n,r,i.exports[o[c]])},decodeGltfBufferAsync:function(e,t,n,s,u){return c.length>0?function(e,t,i,n,r){for(var s=c[0],a=1;a<c.length;++a)c[a].pending<s.pending&&(s=c[a]);return new Promise((function(a,o){var l=new Uint8Array(i),c=++h;s.pending+=e,s.requests[c]={resolve:a,reject:o},s.object.postMessage({id:c,count:e,size:t,source:l,mode:n,filter:r},[l.buffer])}))}(e,t,n,l[s],o[u]):r.then((function(){var r=new Uint8Array(e*t);return a(i,i.exports[l[s]],r,e,t,n,i.exports[o[u]]),r}))}}}();const _taskCache$1=new WeakMap;class DRACOLoader extends three.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,i,n){const r=new three.FileLoader(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,(e=>{this.parse(e,t,n)}),i,n)}parse(e,t,i=()=>{}){this.decodeDracoFile(e,t,null,null,three.SRGBColorSpace,i).catch(i)}decodeDracoFile(e,t,i,n,r=three.LinearSRGBColorSpace,s=()=>{}){const a={attributeIDs:i||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!i,vertexColorSpace:r};return this.decodeGeometry(e,a).then(t).catch(s)}decodeGeometry(e,t){const i=JSON.stringify(t);if(_taskCache$1.has(e)){const t=_taskCache$1.get(e);if(t.key===i)return t.promise;if(0===e.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const r=this.workerNextTaskID++,s=e.byteLength,a=this._getWorker(r,s).then((i=>(n=i,new Promise(((i,s)=>{n._callbacks[r]={resolve:i,reject:s},n.postMessage({type:"decode",id:r,taskConfig:t,buffer:e},[e])}))))).then((e=>this._createGeometry(e.geometry)));return a.catch((()=>!0)).then((()=>{n&&r&&this._releaseTask(n,r)})),_taskCache$1.set(e,{key:i,promise:a}),a}_createGeometry(e){const t=new three.BufferGeometry;e.index&&t.setIndex(new three.BufferAttribute(e.index.array,1));for(let i=0;i<e.attributes.length;i++){const n=e.attributes[i],r=n.name,s=n.array,a=n.itemSize,o=new three.BufferAttribute(s,a);"color"===r&&(this._assignVertexColorSpace(o,n.vertexColorSpace),o.normalized=s instanceof Float32Array==!1),t.setAttribute(r,o)}return t}_assignVertexColorSpace(e,t){if(t!==three.SRGBColorSpace)return;const i=new three.Color;for(let n=0,r=e.count;n<r;n++)i.fromBufferAttribute(e,n),three.ColorManagement.colorSpaceToWorking(i,three.SRGBColorSpace),e.setXYZ(n,i.r,i.g,i.b)}_loadLibrary(e,t){const i=new three.FileLoader(this.manager);return i.setPath(this.decoderPath),i.setResponseType(t),i.setWithCredentials(this.withCredentials),new Promise(((t,n)=>{i.load(e,t,void 0,n)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then((t=>{const i=t[0];e||(this.decoderConfig.wasmBinary=t[1]);const n=DRACOWorker.toString(),r=["/* draco decoder */",i,"","/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([r]))})),this.decoderPending}_getWorker(e,t){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const e=new Worker(this.workerSourceURL);e._callbacks={},e._taskCosts={},e._taskLoad=0,e.postMessage({type:"init",decoderConfig:this.decoderConfig}),e.onmessage=function(t){const i=t.data;switch(i.type){case"decode":e._callbacks[i.id].resolve(i);break;case"error":e._callbacks[i.id].reject(i);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+i.type+'"')}},this.workerPool.push(e)}else this.workerPool.sort((function(e,t){return e._taskLoad>t._taskLoad?-1:1}));const i=this.workerPool[this.workerPool.length-1];return i._taskCosts[e]=t,i._taskLoad+=t,i}))}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map((e=>e._taskLoad)))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,""!==this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}}function DRACOWorker(){let e,t;function i(e,t,i,n,r,s){const a=s.num_components(),o=i.num_points()*a,l=o*r.BYTES_PER_ELEMENT,c=function(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}(e,r),h=e._malloc(l);t.GetAttributeDataArrayForAllPoints(i,s,c,l,h);const u=new r(e.HEAPF32.buffer,h,o).slice();return e._free(h),{name:n,array:u,itemSize:a}}onmessage=function(n){const r=n.data;switch(r.type){case"init":e=r.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":const n=r.buffer,s=r.taskConfig;t.then((e=>{const t=e.draco,a=new t.Decoder;try{const e=function(e,t,n,r){const s=r.attributeIDs,a=r.attributeTypes;let o,l;const c=t.GetEncodedGeometryType(n);if(c===e.TRIANGULAR_MESH)o=new e.Mesh,l=t.DecodeArrayToMesh(n,n.byteLength,o);else{if(c!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");o=new e.PointCloud,l=t.DecodeArrayToPointCloud(n,n.byteLength,o)}if(!l.ok()||0===o.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+l.error_msg());const h={index:null,attributes:[]};for(const u in s){const n=self[a[u]];let l,c;if(r.useUniqueIDs)c=s[u],l=t.GetAttributeByUniqueId(o,c);else{if(c=t.GetAttributeId(o,e[s[u]]),-1===c)continue;l=t.GetAttribute(o,c)}const d=i(e,t,o,u,n,l);"color"===u&&(d.vertexColorSpace=r.vertexColorSpace),h.attributes.push(d)}c===e.TRIANGULAR_MESH&&(h.index=function(e,t,i){const n=i.num_faces(),r=3*n,s=4*r,a=e._malloc(s);t.GetTrianglesUInt32Array(i,s,a);const o=new Uint32Array(e.HEAPF32.buffer,a,r).slice();return e._free(a),{array:o,itemSize:1}}(e,t,o));return e.destroy(o),h}(t,a,new Int8Array(n),s),o=e.attributes.map((e=>e.array.buffer));e.index&&o.push(e.index.array.buffer),self.postMessage({type:"decode",id:r.id,geometry:e},o)}catch(o){console.error(o),self.postMessage({type:"error",id:r.id,error:o.message})}finally{t.destroy(a)}}))}}}class WorkerPool{constructor(e=4){this.pool=e,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0,this.workerCreator=null}_initWorker(e){if(!this.workers[e]){const t=this.workerCreator();t.addEventListener("message",this._onMessage.bind(this,e)),this.workers[e]=t}}_getIdleWorker(){for(let e=0;e<this.pool;e++)if(!(this.workerStatus&1<<e))return e;return-1}_onMessage(e,t){const i=this.workersResolve[e];if(i&&i(t),this.queue.length){const{resolve:t,msg:i,transfer:n}=this.queue.shift();this.workersResolve[e]=t,this.workers[e].postMessage(i,n)}else this.workerStatus^=1<<e}setWorkerCreator(e){this.workerCreator=e}setWorkerLimit(e){this.pool=e}postMessage(e,t){return new Promise((i=>{const n=this._getIdleWorker();-1!==n?(this._initWorker(n),this.workerStatus|=1<<n,this.workersResolve[n]=i,this.workers[n].postMessage(e,t)):this.queue.push({resolve:i,msg:e,transfer:t})}))}dispose(){this.workers.forEach((e=>e.terminate())),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}const t=0,n=2,g$1=1,u=2,T=0,C$1=1,R=10,it=0,ct=9,yt=15,xt=16,wt=22,Ft=37,Ct=43,te=76,ae=83,ge$1=97,ue=100,we=103,Ae=109,Ge=131,Je=132,Qe=133,Ze=134,en=137,nn=138,rn=141,on=142,hn=145,Un=146,_n=148,xn=152,mn=157,Dn=158,In=165,Sn=166,pi=1000066e3;class Ii{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=0,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:0,descriptorBlockSize:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],this.keyValue={},this.globalData=null}}class Si{constructor(e,t,i,n){this._dataView=void 0,this._littleEndian=void 0,this._offset=void 0,this._dataView=new DataView(e.buffer,e.byteOffset+t,i),this._littleEndian=n,this._offset=0}_nextUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}_nextUint16(){const e=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,e}_nextUint32(){const e=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint64(){const e=this._dataView.getUint32(this._offset,this._littleEndian)+2**32*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,e}_nextInt32(){const e=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint8Array(e){const t=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._offset,e);return this._offset+=e,t}_skip(e){return this._offset+=e,this}_scan(e,t){void 0===t&&(t=0);const i=this._offset;let n=0;for(;this._dataView.getUint8(this._offset)!==t&&n<e;)n++,this._offset++;return n<e&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+i,n)}}const Oi=[171,75,84,88,32,50,48,187,13,10,26,10];function Ti(e){return(new TextDecoder).decode(e)}function Pi(e){const t=new Uint8Array(e.buffer,e.byteOffset,Oi.length);if(t[0]!==Oi[0]||t[1]!==Oi[1]||t[2]!==Oi[2]||t[3]!==Oi[3]||t[4]!==Oi[4]||t[5]!==Oi[5]||t[6]!==Oi[6]||t[7]!==Oi[7]||t[8]!==Oi[8]||t[9]!==Oi[9]||t[10]!==Oi[10]||t[11]!==Oi[11])throw new Error("Missing KTX 2.0 identifier.");const i=new Ii,n=17*Uint32Array.BYTES_PER_ELEMENT,r=new Si(e,Oi.length,n,!0);i.vkFormat=r._nextUint32(),i.typeSize=r._nextUint32(),i.pixelWidth=r._nextUint32(),i.pixelHeight=r._nextUint32(),i.pixelDepth=r._nextUint32(),i.layerCount=r._nextUint32(),i.faceCount=r._nextUint32();const s=r._nextUint32();i.supercompressionScheme=r._nextUint32();const a=r._nextUint32(),o=r._nextUint32(),l=r._nextUint32(),c=r._nextUint32(),h=r._nextUint64(),u=r._nextUint64(),d=new Si(e,Oi.length+n,3*s*8,!0);for(let D=0;D<s;D++)i.levels.push({levelData:new Uint8Array(e.buffer,e.byteOffset+d._nextUint64(),d._nextUint64()),uncompressedByteLength:d._nextUint64()});const p=new Si(e,a,o,!0),m={vendorId:p._skip(4)._nextUint16(),descriptorType:p._nextUint16(),versionNumber:p._nextUint16(),descriptorBlockSize:p._nextUint16(),colorModel:p._nextUint8(),colorPrimaries:p._nextUint8(),transferFunction:p._nextUint8(),flags:p._nextUint8(),texelBlockDimension:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],bytesPlane:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],samples:[]},f=(m.descriptorBlockSize/4-6)/4;for(let D=0;D<f;D++){const e={bitOffset:p._nextUint16(),bitLength:p._nextUint8(),channelType:p._nextUint8(),samplePosition:[p._nextUint8(),p._nextUint8(),p._nextUint8(),p._nextUint8()],sampleLower:-1/0,sampleUpper:1/0};64&e.channelType?(e.sampleLower=p._nextInt32(),e.sampleUpper=p._nextInt32()):(e.sampleLower=p._nextUint32(),e.sampleUpper=p._nextUint32()),m.samples[D]=e}i.dataFormatDescriptor.length=0,i.dataFormatDescriptor.push(m);const g=new Si(e,l,c,!0);for(;g._offset<c;){const e=g._nextUint32(),t=g._scan(e),n=Ti(t);if(i.keyValue[n]=g._nextUint8Array(e-t.byteLength-1),n.match(/^ktx/i)){const e=Ti(i.keyValue[n]);i.keyValue[n]=e.substring(0,e.lastIndexOf("\0"))}g._skip(e%4?4-e%4:0)}if(u<=0)return i;const _=new Si(e,h,u,!0),A=_._nextUint16(),v=_._nextUint16(),y=_._nextUint32(),x=_._nextUint32(),b=_._nextUint32(),S=_._nextUint32(),C=[];for(let D=0;D<s;D++)C.push({imageFlags:_._nextUint32(),rgbSliceByteOffset:_._nextUint32(),rgbSliceByteLength:_._nextUint32(),alphaSliceByteOffset:_._nextUint32(),alphaSliceByteLength:_._nextUint32()});const T=h+_._offset,E=T+y,M=E+x,w=M+b,I=new Uint8Array(e.buffer,e.byteOffset+T,y),P=new Uint8Array(e.buffer,e.byteOffset+E,x),R=new Uint8Array(e.buffer,e.byteOffset+M,b),B=new Uint8Array(e.buffer,e.byteOffset+w,S);return i.globalData={endpointCount:A,selectorCount:v,imageDescs:C,endpointsData:I,selectorsData:P,tablesData:R,extendedData:B},i}let A,I,B;const g={env:{emscripten_notify_memory_growth:function(e){B=new Uint8Array(I.exports.memory.buffer)}}};class Q{init(){return A||(A="undefined"!=typeof fetch?fetch("data:application/wasm;base64,"+C).then((e=>e.arrayBuffer())).then((e=>WebAssembly.instantiate(e,g))).then(this._init):WebAssembly.instantiate(Buffer.from(C,"base64"),g).then(this._init),A)}_init(e){I=e.instance,g.env.emscripten_notify_memory_growth(0)}decode(e,t=0){if(!I)throw new Error("ZSTDDecoder: Await .init() before decoding.");const i=e.byteLength,n=I.exports.malloc(i);B.set(e,n),t=t||Number(I.exports.ZSTD_findDecompressedSize(n,i));const r=I.exports.malloc(t),s=I.exports.ZSTD_decompress(r,t,n,i),a=B.slice(r,r+s);return I.exports.free(n),I.exports.free(r),a}}const C="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",DisplayP3ColorSpace="display-p3",LinearDisplayP3ColorSpace="display-p3-linear",_taskCache=new WeakMap;let _activeLoaders=0,_zstd;class KTX2Loader extends three.Loader{constructor(e){super(e),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new WorkerPool,this.workerSourceURL="",this.workerConfig=null,"undefined"!=typeof MSC_TRANSCODER&&console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(e){return this.transcoderPath=e,this}setWorkerLimit(e){return this.workerPool.setWorkerLimit(e),this}async detectSupportAsync(e){return this.workerConfig={astcSupported:await e.hasFeatureAsync("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:await e.hasFeatureAsync("texture-compression-etc1"),etc2Supported:await e.hasFeatureAsync("texture-compression-etc2"),dxtSupported:await e.hasFeatureAsync("texture-compression-bc"),bptcSupported:await e.hasFeatureAsync("texture-compression-bptc"),pvrtcSupported:await e.hasFeatureAsync("texture-compression-pvrtc")},this}detectSupport(e){return!0===e.isWebGPURenderer?this.workerConfig={astcSupported:e.hasFeature("texture-compression-astc"),astcHDRSupported:!1,etc1Supported:e.hasFeature("texture-compression-etc1"),etc2Supported:e.hasFeature("texture-compression-etc2"),dxtSupported:e.hasFeature("texture-compression-bc"),bptcSupported:e.hasFeature("texture-compression-bptc"),pvrtcSupported:e.hasFeature("texture-compression-pvrtc")}:this.workerConfig={astcSupported:e.extensions.has("WEBGL_compressed_texture_astc"),astcHDRSupported:e.extensions.has("WEBGL_compressed_texture_astc")&&e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),etc1Supported:e.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:e.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:e.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:e.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:e.extensions.has("WEBGL_compressed_texture_pvrtc")||e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},this}init(){if(!this.transcoderPending){const e=new three.FileLoader(this.manager);e.setPath(this.transcoderPath),e.setWithCredentials(this.withCredentials);const t=e.loadAsync("basis_transcoder.js"),i=new three.FileLoader(this.manager);i.setPath(this.transcoderPath),i.setResponseType("arraybuffer"),i.setWithCredentials(this.withCredentials);const n=i.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([t,n]).then((([e,t])=>{const i=KTX2Loader.BasisWorker.toString(),n=["/* constants */","let _EngineFormat = "+JSON.stringify(KTX2Loader.EngineFormat),"let _EngineType = "+JSON.stringify(KTX2Loader.EngineType),"let _TranscoderFormat = "+JSON.stringify(KTX2Loader.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(KTX2Loader.BasisFormat),"/* basis_transcoder.js */",e,"/* worker */",i.substring(i.indexOf("{")+1,i.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([n])),this.transcoderBinary=t,this.workerPool.setWorkerCreator((()=>{const e=new Worker(this.workerSourceURL),t=this.transcoderBinary.slice(0);return e.postMessage({type:"init",config:this.workerConfig,transcoderBinary:t},[t]),e}))})),_activeLoaders>0&&console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),_activeLoaders++}return this.transcoderPending}load(e,t,i,n){if(null===this.workerConfig)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");const r=new three.FileLoader(this.manager);r.setPath(this.path),r.setCrossOrigin(this.crossOrigin),r.setWithCredentials(this.withCredentials),r.setResponseType("arraybuffer"),r.load(e,(e=>{this.parse(e,t,n)}),i,n)}parse(e,t,i){if(null===this.workerConfig)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");if(_taskCache.has(e)){return _taskCache.get(e).promise.then(t).catch(i)}this._createTexture(e).then((e=>t?t(e):null)).catch(i)}_createTextureFrom(e,t){const{type:i,error:n,data:{faces:r,width:s,height:a,format:o,type:l,dfdFlags:c}}=e;if("error"===i)return Promise.reject(n);let h;if(6===t.faceCount)h=new three.CompressedCubeTexture(r,o,l);else{const e=r[0].mipmaps;h=t.layerCount>1?new three.CompressedArrayTexture(e,s,a,t.layerCount,o,l):new three.CompressedTexture(e,s,a,o,l)}return h.minFilter=1===r[0].mipmaps.length?three.LinearFilter:three.LinearMipmapLinearFilter,h.magFilter=three.LinearFilter,h.generateMipmaps=!1,h.needsUpdate=!0,h.colorSpace=parseColorSpace(t),h.premultiplyAlpha=!!(c&g$1),h}async _createTexture(e,t={}){const i=Pi(new Uint8Array(e)),n=i.vkFormat===pi&&167===i.dataFormatDescriptor[0].colorModel;if(!(i.vkFormat===it||n&&!this.workerConfig.astcHDRSupported))return createRawTexture(i);const r=t,s=this.init().then((()=>this.workerPool.postMessage({type:"transcode",buffer:e,taskConfig:r},[e]))).then((e=>this._createTextureFrom(e.data,i)));return _taskCache.set(e,{promise:s}),s}dispose(){this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),_activeLoaders--}}KTX2Loader.BasisFormat={ETC1S:0,UASTC:1,UASTC_HDR:2},KTX2Loader.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16,BC6H:22,RGB_HALF:24,RGBA_HALF:25},KTX2Loader.EngineFormat={RGBAFormat:three.RGBAFormat,RGBA_ASTC_4x4_Format:three.RGBA_ASTC_4x4_Format,RGB_BPTC_UNSIGNED_Format:three.RGB_BPTC_UNSIGNED_Format,RGBA_BPTC_Format:three.RGBA_BPTC_Format,RGBA_ETC2_EAC_Format:three.RGBA_ETC2_EAC_Format,RGBA_PVRTC_4BPPV1_Format:three.RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT5_Format:three.RGBA_S3TC_DXT5_Format,RGB_ETC1_Format:three.RGB_ETC1_Format,RGB_ETC2_Format:three.RGB_ETC2_Format,RGB_PVRTC_4BPPV1_Format:three.RGB_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format:three.RGBA_S3TC_DXT1_Format},KTX2Loader.EngineType={UnsignedByteType:three.UnsignedByteType,HalfFloatType:three.HalfFloatType,FloatType:three.FloatType},KTX2Loader.BasisWorker=function(){let e,t,i;const n=_EngineFormat,r=_EngineType,s=_TranscoderFormat,a=_BasisFormat;self.addEventListener("message",(function(n){const s=n.data;switch(s.type){case"init":e=s.config,o=s.transcoderBinary,t=new Promise((e=>{i={wasmBinary:o,onRuntimeInitialized:e},BASIS(i)})).then((()=>{i.initializeBasis(),void 0===i.KTX2File&&console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")}));break;case"transcode":t.then((()=>{try{const{faces:t,buffers:n,width:o,height:u,hasAlpha:d,format:p,type:m,dfdFlags:f}=function(t){const n=new i.KTX2File(new Uint8Array(t));function s(){n.close(),n.delete()}if(!n.isValid())throw s(),new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");let o;if(n.isUASTC())o=a.UASTC;else if(n.isETC1S())o=a.ETC1S;else{if(!n.isHDR())throw new Error("THREE.KTX2Loader: Unknown Basis encoding");o=a.UASTC_HDR}const u=n.getWidth(),d=n.getHeight(),p=n.getLayers()||1,m=n.getLevels(),f=n.getFaces(),g=n.getHasAlpha(),_=n.getDFDFlags(),{transcoderFormat:A,engineFormat:v,engineType:y}=function(t,i,n,r){const s=l[t];for(let a=0;a<s.length;a++){const o=s[a];if(o.if&&!e[o.if])continue;if(!o.basisFormat.includes(t))continue;if(r&&o.transcoderFormat.length<2)continue;if(o.needsPowerOfTwo&&(!c(i)||!c(n)))continue;return{transcoderFormat:o.transcoderFormat[r?1:0],engineFormat:o.engineFormat[r?1:0],engineType:o.engineType[0]}}throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.")}(o,u,d,g);if(!u||!d||!m)throw s(),new Error("THREE.KTX2Loader:\tInvalid texture");if(!n.startTranscoding())throw s(),new Error("THREE.KTX2Loader: .startTranscoding failed");const x=[],b=[];for(let e=0;e<f;e++){const t=[];for(let i=0;i<m;i++){const a=[];let o,l;for(let t=0;t<p;t++){const c=n.getImageLevelInfo(i,t,e);0!==e||0!==i||0!==t||c.origWidth%4==0&&c.origHeight%4==0||console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."),m>1?(o=c.origWidth,l=c.origHeight):(o=c.width,l=c.height);let h=new Uint8Array(n.getImageTranscodedSizeInBytes(i,t,0,A));const u=n.transcodeImage(h,i,t,e,A,0,-1,-1);if(y===r.HalfFloatType&&(h=new Uint16Array(h.buffer,h.byteOffset,h.byteLength/Uint16Array.BYTES_PER_ELEMENT)),!u)throw s(),new Error("THREE.KTX2Loader: .transcodeImage failed.");a.push(h)}const c=h(a);t.push({data:c,width:o,height:l}),b.push(c.buffer)}x.push({mipmaps:t,width:u,height:d,format:v,type:y})}return s(),{faces:x,buffers:b,width:u,height:d,hasAlpha:g,dfdFlags:_,format:v,type:y}}(s.buffer);self.postMessage({type:"transcode",id:s.id,data:{faces:t,width:o,height:u,hasAlpha:d,format:p,type:m,dfdFlags:f}},n)}catch(t){console.error(t),self.postMessage({type:"error",id:s.id,error:t.message})}}))}var o}));const o=[{if:"astcSupported",basisFormat:[a.UASTC],transcoderFormat:[s.ASTC_4x4,s.ASTC_4x4],engineFormat:[n.RGBA_ASTC_4x4_Format,n.RGBA_ASTC_4x4_Format],engineType:[r.UnsignedByteType],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[a.ETC1S,a.UASTC],transcoderFormat:[s.BC7_M5,s.BC7_M5],engineFormat:[n.RGBA_BPTC_Format,n.RGBA_BPTC_Format],engineType:[r.UnsignedByteType],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[a.ETC1S,a.UASTC],transcoderFormat:[s.BC1,s.BC3],engineFormat:[n.RGBA_S3TC_DXT1_Format,n.RGBA_S3TC_DXT5_Format],engineType:[r.UnsignedByteType],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[a.ETC1S,a.UASTC],transcoderFormat:[s.ETC1,s.ETC2],engineFormat:[n.RGB_ETC2_Format,n.RGBA_ETC2_EAC_Format],engineType:[r.UnsignedByteType],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[a.ETC1S,a.UASTC],transcoderFormat:[s.ETC1],engineFormat:[n.RGB_ETC1_Format],engineType:[r.UnsignedByteType],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[a.ETC1S,a.UASTC],transcoderFormat:[s.PVRTC1_4_RGB,s.PVRTC1_4_RGBA],engineFormat:[n.RGB_PVRTC_4BPPV1_Format,n.RGBA_PVRTC_4BPPV1_Format],engineType:[r.UnsignedByteType],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0},{if:"bptcSupported",basisFormat:[a.UASTC_HDR],transcoderFormat:[s.BC6H],engineFormat:[n.RGB_BPTC_UNSIGNED_Format],engineType:[r.HalfFloatType],priorityHDR:1,needsPowerOfTwo:!1},{basisFormat:[a.ETC1S,a.UASTC],transcoderFormat:[s.RGBA32,s.RGBA32],engineFormat:[n.RGBAFormat,n.RGBAFormat],engineType:[r.UnsignedByteType,r.UnsignedByteType],priorityETC1S:100,priorityUASTC:100,needsPowerOfTwo:!1},{basisFormat:[a.UASTC_HDR],transcoderFormat:[s.RGBA_HALF],engineFormat:[n.RGBAFormat],engineType:[r.HalfFloatType],priorityHDR:100,needsPowerOfTwo:!1}],l={[a.ETC1S]:o.filter((e=>e.basisFormat.includes(a.ETC1S))).sort(((e,t)=>e.priorityUASTC-t.priorityUASTC)),[a.UASTC]:o.filter((e=>e.basisFormat.includes(a.UASTC))).sort(((e,t)=>e.priorityUASTC-t.priorityUASTC)),[a.UASTC_HDR]:o.filter((e=>e.basisFormat.includes(a.UASTC_HDR))).sort(((e,t)=>e.priorityHDR-t.priorityHDR))};function c(e){return e<=2||!(e&e-1)&&0!==e}function h(e){if(1===e.length)return e[0];let t=0;for(let r=0;r<e.length;r++){t+=e[r].byteLength}const i=new Uint8Array(t);let n=0;for(let r=0;r<e.length;r++){const t=e[r];i.set(t,n),n+=t.byteLength}return i}};const UNCOMPRESSED_FORMATS=new Set([three.RGBAFormat,three.RGFormat,three.RedFormat]),FORMAT_MAP={[Ae]:three.RGBAFormat,[ge$1]:three.RGBAFormat,[Ft]:three.RGBAFormat,[Ct]:three.RGBAFormat,[we]:three.RGFormat,[ae]:three.RGFormat,[xt]:three.RGFormat,[wt]:three.RGFormat,[ue]:three.RedFormat,[te]:three.RedFormat,[yt]:three.RedFormat,[ct]:three.RedFormat,[_n]:three.RGB_ETC2_Format,[xn]:three.RGBA_ETC2_EAC_Format,[pi]:three.RGBA_ASTC_4x4_Format,[Dn]:three.RGBA_ASTC_4x4_Format,[mn]:three.RGBA_ASTC_4x4_Format,[Sn]:three.RGBA_ASTC_6x6_Format,[In]:three.RGBA_ASTC_6x6_Format,[Qe]:three.RGBA_S3TC_DXT1_Format,[Ze]:three.RGBA_S3TC_DXT1_Format,[Ge]:three.RGB_S3TC_DXT1_Format,[Je]:three.RGB_S3TC_DXT1_Format,[nn]:three.RGBA_S3TC_DXT3_Format,[en]:three.RGBA_S3TC_DXT3_Format,[on]:three.RGBA_S3TC_DXT5_Format,[rn]:three.RGBA_S3TC_DXT5_Format,[Un]:three.RGBA_BPTC_Format,[hn]:three.RGBA_BPTC_Format},TYPE_MAP={[Ae]:three.FloatType,[ge$1]:three.HalfFloatType,[Ft]:three.UnsignedByteType,[Ct]:three.UnsignedByteType,[we]:three.FloatType,[ae]:three.HalfFloatType,[xt]:three.UnsignedByteType,[wt]:three.UnsignedByteType,[ue]:three.FloatType,[te]:three.HalfFloatType,[yt]:three.UnsignedByteType,[ct]:three.UnsignedByteType,[_n]:three.UnsignedByteType,[xn]:three.UnsignedByteType,[pi]:three.HalfFloatType,[Sn]:three.UnsignedByteType,[In]:three.UnsignedByteType};async function createRawTexture(e){const{vkFormat:i}=e;if(void 0===FORMAT_MAP[i])throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");let r;e.supercompressionScheme===n&&(_zstd||(_zstd=new Promise((async e=>{const t=new Q;await t.init(),e(t)}))),r=await _zstd);const s=[];for(let o=0;o<e.levels.length;o++){const a=Math.max(1,e.pixelWidth>>o),l=Math.max(1,e.pixelHeight>>o),c=e.pixelDepth?Math.max(1,e.pixelDepth>>o):0,h=e.levels[o];let u,d;if(e.supercompressionScheme===t)u=h.levelData;else{if(e.supercompressionScheme!==n)throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");u=r.decode(h.levelData,h.uncompressedByteLength)}d=TYPE_MAP[i]===three.FloatType?new Float32Array(u.buffer,u.byteOffset,u.byteLength/Float32Array.BYTES_PER_ELEMENT):TYPE_MAP[i]===three.HalfFloatType?new Uint16Array(u.buffer,u.byteOffset,u.byteLength/Uint16Array.BYTES_PER_ELEMENT):u,s.push({data:d,width:a,height:l,depth:c})}let a;if(UNCOMPRESSED_FORMATS.has(FORMAT_MAP[i]))a=0===e.pixelDepth?new three.DataTexture(s[0].data,e.pixelWidth,e.pixelHeight):new three.Data3DTexture(s[0].data,e.pixelWidth,e.pixelHeight,e.pixelDepth);else{if(e.pixelDepth>0)throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");a=new three.CompressedTexture(s,e.pixelWidth,e.pixelHeight),a.minFilter=1===s.length?three.LinearFilter:three.LinearMipmapLinearFilter,a.magFilter=three.LinearFilter}return a.mipmaps=s,a.type=TYPE_MAP[i],a.format=FORMAT_MAP[i],a.colorSpace=parseColorSpace(e),a.needsUpdate=!0,Promise.resolve(a)}function parseColorSpace(e){const t=e.dataFormatDescriptor[0];return t.colorPrimaries===C$1?t.transferFunction===u?three.SRGBColorSpace:three.LinearSRGBColorSpace:t.colorPrimaries===R?t.transferFunction===u?DisplayP3ColorSpace:LinearDisplayP3ColorSpace:(t.colorPrimaries===T||console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${t.colorPrimaries}"`),three.NoColorSpace)}const ktx2Loader=new KTX2Loader,renderer=new three.WebGLRenderer;ktx2Loader.detectSupport(renderer),ktx2Loader.setWorkerLimit=4,ktx2Loader.setTranscoderPath(getAssetUrl("assets/libs/basis/"));const dracoLoader=new DRACOLoader;function createEnhancedLoader(){const e=new GLTFLoader$1;return e.setMeshoptDecoder(MeshoptDecoder),e.setDRACOLoader(dracoLoader),e.setKTX2Loader(ktx2Loader),e}dracoLoader.setDecoderPath(getAssetUrl("assets/libs/draco/gltf/")),dracoLoader.setDecoderConfig({type:"js"});let gltfLoader=createEnhancedLoader();function clone$1(e){const t=new Map,i=new Map,n=e.clone();return parallelTraverse(e,n,(function(e,n){t.set(n,e),i.set(e,n)})),n.traverse((function(e){if(!e.isSkinnedMesh)return;const n=e,r=t.get(e),s=r.skeleton.bones;n.skeleton=r.skeleton.clone(),n.bindMatrix.copy(r.bindMatrix),n.skeleton.bones=s.map((function(e){return i.get(e)})),n.bind(n.skeleton,n.bindMatrix)})),n}function parallelTraverse(e,t,i){i(e,t);for(let n=0;n<e.children.length;n++)parallelTraverse(e.children[n],t.children[n],i)}const _modelMeshSingleton=new PromisedSingleton;_modelMeshSingleton.generate=async e=>new Promise(((t,i)=>{gltfLoader.load(e,(e=>{t(e)}),null,i)}));const _pointScratch=new three.Vector3,_scaleScratch=new three.Vector3,_rotationScratch=new three.Euler;new three.Matrix4;class SimpleModel extends three.Object3D{constructor(e){super(e),__publicField(this,"_autoYUpToZUp",!0),this._parameters=e,this._name=e.name||"",this._object=e.object||e.url,void 0!==e.autoYUpToZUp&&(this._autoYUpToZUp=e.autoYUpToZUp)}afterAddToEngine(e){this._engine=e,this.setTransform({point:this._parameters.point||[0,0,0],scale:this._parameters.scale||[1,1,1],rotation:this._parameters.rotation||[0,0,0]}),this._initModel()}beforeRemoveFromEngine(){this.dispose()}async _initModel(){if(!this._object)return void console.error("object of SimpleModel is required");let e=null;if("string"==typeof this._object){const t=await _modelMeshSingleton.get(this._object);e=t.animations&&t.animations.length>0?clone$1(t.scene):t.scene.clone(),this._updateData(t,e),this.dispatchEvent({type:"loaded",value:this}),this._autoYUpToZUp&&e.rotateX(Math.PI/2)}else this._object.isObject3D&&(e=this._object);this.add(e)}dispose(){}setTransform(e={}){if(e.point){e.point instanceof three.Vector3?_pointScratch.copy(e.point):e.point instanceof Array&&_pointScratch.set(e.point[0],e.point[1],e.point[2]||0);const t=this._engine.map.projectCoordinate(_pointScratch);this.position.copy(t)}if(e.rotation){if(e.rotation instanceof three.Euler?_rotationScratch.copy(e.rotation):e.rotation instanceof three.Vector3?_rotationScratch.setFromVector3(e.rotation,"XYZ"):e.rotation instanceof Array&&_rotationScratch.set(e.rotation[0],e.rotation[1],e.rotation[2],"XYZ"),this._engine.map.isGlobe){const e={heading:_rotationScratch.z,pitch:_rotationScratch.y,roll:_rotationScratch.x},t=Transforms.headingPitchRollToFixedFrame(this.position,e);_rotationScratch.setFromRotationMatrix(t)}this.rotation.set(_rotationScratch.x,_rotationScratch.y,_rotationScratch.z,_rotationScratch.order)}e.scale&&(e.scale instanceof three.Vector3?_scaleScratch.copy(e.scale):"number"==typeof e.scale?_scaleScratch.set(e.scale,e.scale,e.scale):e.scale instanceof Array&&_scaleScratch.set(e.scale[0],e.scale[1],e.scale[2]),this.scale.set(_scaleScratch.x,_scaleScratch.y,_scaleScratch.z))}set point(e){e&&this.setTransform({point:e})}get autoYUpToZUp(){return this._autoYUpToZUp}_updateData(){}}class AnimationModel extends SimpleModel{constructor(e){super(e)}_updateData(e,t){let i=[];e.animations&&e.animations.length>0&&(this.animations=e.animations,this.mixer=new three.AnimationMixer(t),i=this.animations.map((e=>this.mixer.clipAction(e))),this._parameters.autoPlay&&i[0].play(),this._engine.rendering.animation.addMixer(this.mixer)),this.animationActions=i}play(e){e=e||0,this.animationActions[e]&&this.animationActions[e].play()}stop(e){e=e||0,this.animationActions[e]&&this.animationActions[e].stop()}playAll(){this.animationActions.forEach((e=>e.play()))}stopAll(){this.animationActions.forEach((e=>e.stop()))}setSpeed(e,t){void 0!==t?this.animationActions[t]&&(this.animationActions[t].timeScale=e):this.animationActions.forEach((t=>t.timeScale=e))}setLoop(e,t){const i=!0===e?three.LoopRepeat:three.LoopOnce;void 0!==t?this.animationActions[t]&&(this.animationActions[t].loop=i):this.animationActions.forEach((e=>e.loop=i))}dispose(){this.mixer&&(this._engine.rendering.animation.removeMixer(this.mixer),this.mixer.stopAllAction(),this.mixer.uncacheAction(),this.animationActions.forEach((e=>{this.mixer.uncacheClip(e)}))),this.mixer=null,this.animations=null,this.animationActions=null,super.dispose()}}const LodModelCache=new LRUCache$1({max:100,onRemove(e){e.destroyModel()}});class LODModel extends three.Object3D{constructor(e){super(e),__publicField(this,"_hysteresis",.1),__publicField(this,"_levels",[]),__publicField(this,"_currentLevel"),__publicField(this,"_currentModel"),__publicField(this,"_loader",gltfLoader),__publicField(this,"_generateModelMesh",(async e=>new Promise(((t,i)=>{this._loader.load(e,(e=>{t(e.scene)}),null,i)})))),__publicField(this,"update",(async()=>{if(!this.visible)return;const e=this._engine.camera,t=this.levels,i=this.position,n=t.length;if(n>0){const r=e.position.distanceTo(i),s=t[n-1].hysteresis||this.hysteresis;if(r>t[n-1].distance*(1+s))return this._modelMeshSingleton.keys.forEach((async e=>{(await this._modelMeshSingleton.get(e)).visible=!1})),!LodModelCache.cache[this.uuid]&&this.isInit&&LodModelCache.set(this.uuid,this),this._currentLevel=void 0,void(this._currentModel=void 0);let a,o;LodModelCache.remove(this.uuid);for(let e=0;e<n;e++){const i=t[e];let n=i.distance;if(i.init){if(!0===(await this._modelMeshSingleton.get(i.file)).visible){n+=n*(i.hysteresis||this.hysteresis)}}if(void 0===a&&r<=n)a=e;else if(i.init){(await this._modelMeshSingleton.get(i.file)).visible=!1}}if(a>=0){let e=t[a],i=await this._modelMeshSingleton.get(e.file);e.init?i.visible=!0:(this.add(i),e.init=!0,this.handleLoaded(i)),o=i}this._currentLevel=a,this._currentModel=o}})),e.hysteresis&&(this.hysteresis=e.hysteresis),e.levels&&(this.levels=e.levels)}afterAddToEngine(e){this._engine=e,this._modelMeshSingleton=new PromisedSingleton,this._modelMeshSingleton.generate=this._generateModelMesh,this._engine.rendering.addPrepareRenderListener(this.update)}beforeRemoveFromEngine(e){this.dispose()}addLevel(e,t=0,i=0){t=Math.abs(t);const n=this.levels;let r;for(r=0;r<n.length&&!(t<n[r].distance);r++);return n.splice(r,0,{distance:t,hysteresis:i,file:e,init:!1}),this}removeLevel(e){for(let t=0;t<this.levels.length;t++){if(e===this.levels[t].file){this.levels.splice(t,1);break}}return this}getCurrentLevel(){return this._currentLevel}getCurrentModel(){return this._currentModel}async getModel(e){let t=this.levels[e];if(t)return await this._modelMeshSingleton.get(t.file)}handleLoaded(e){this.dispatchEvent({type:"loaded",value:e}),this.levels.every((e=>e.init))&&this.dispatchEvent({type:"complete",value:this})}dispose(){this._loaded&&(this._engine.rendering.removePrepareRenderListener(this.update),this.destroyModel())}get isInit(){return this.levels.findIndex((e=>e.init))>=0}destroyModel(){this._modelMeshSingleton.keys.forEach((async e=>{let t=await this._modelMeshSingleton.get(e);this.remove(t),t.traverse((e=>{if(e.isMesh){e.geometry.dispose(),e.material.dispose();const t=e.material.map;t&&(t.image instanceof ImageBitmap&&t.image.close(),t.dispose())}}))}));for(let e=0;e<this.levels.length;e++){this.levels[e].init=!1}this._modelMeshSingleton.clear()}get transform(){return{translate:this.position,rotation:this.rotation,scale:this.scale}}set transform(e){e.translate&&(e.translate instanceof three.Vector3?this.position.copy(e.translate):this.position.set(...e.translate)),e.rotation&&(e.rotation instanceof three.Vector3?this.rotation.copy(e.rotation):this.rotation.set(...e.rotation)),e.scale&&(e.scale instanceof three.Vector3?this.scale.copy(e.scale):"number"==typeof e.scale?this.scale.setScalar(e.scale):this.scale.set(...e.scale))}get levels(){return this._levels}set levels(e){this._levels=e.map((e=>(e.init=!1,e)))}get hysteresis(){return this._hysteresis}set hysteresis(e){this._hysteresis=e}}const Cesium3DTileContentState={UNLOADED:0,LOADING:1,PROCESSING:2,READY:3,EXPIRED:4,FAILED:5},Cesium3DTileContentState$1=Object.freeze(Cesium3DTileContentState);function swap$2(e,t,i){const n=e[t];e[t]=e[i],e[i]=n}class Heap{constructor(e){this._comparator=e.comparator,this._array=[],this._length=0,this._maximumLength=void 0}reserve(e){e=defaultValue$1(e,this._length),this._array.length=e}heapify(e){e=defaultValue$1(e,0);const t=this._length,i=this._comparator,n=this._array;let r=-1,s=!0;for(;s;){const a=2*(e+1),o=a-1;r=o<t&&i(n[o],n[e])<0?o:e,a<t&&i(n[a],n[r])<0&&(r=a),r!==e?(swap$2(n,r,e),e=r):s=!1}}resort(){const e=this._length;for(let t=Math.ceil(e/2);t>=0;--t)this.heapify(t)}insert(e){const t=this._array,i=this._comparator,n=this._maximumLength;let r,s=this._length++;for(s<t.length?t[s]=e:t.push(e);0!==s;){const e=Math.floor((s-1)/2);if(!(i(t[s],t[e])<0))break;swap$2(t,s,e),s=e}return defined$2(n)&&this._length>n&&(r=t[n],this._length=n),r}pop(e){if(e=defaultValue$1(e,0),0===this._length)return;const t=this._array,i=t[e];return swap$2(t,e,--this._length),this.heapify(e),t[this._length]=void 0,i}get length(){return this._length}get internalArray(){return this._array}get maximumLength(){return this._maximumLength}set maximumLength(e){const t=this._length;if(e<t){const i=this._array;for(let n=e;n<t;++n)i[n]=void 0;this._length=e,i.length=e}this._maximumLength=e}get comparator(){return this._comparator}}const dataUriRegex$1=/^data:/i;function isDataUri(e){return dataUriRegex$1.test(e)}const blobUriRegex=/^blob:/i;function isBlobUri(e){return blobUriRegex.test(e)}function sortRequests(e,t){return e.priority-t.priority}const statistics={numberOfAttemptedRequests:0,numberOfActiveRequests:0,numberOfCancelledRequests:0,numberOfCancelledActiveRequests:0,numberOfFailedRequests:0,numberOfActiveRequestsEver:0,lastNumberOfActiveRequests:0};let priorityHeapLength=20;const requestHeap=new Heap({comparator:sortRequests});requestHeap.maximumLength=priorityHeapLength,requestHeap.reserve(priorityHeapLength);const pageUri="undefined"!=typeof document?new Uri(document.location.href):new Uri,activeRequests=[];let numberOfActiveRequestsByServer={};const _RequestScheduler=class{static get statistics(){return statistics}static get priorityHeapLength(){return priorityHeapLength}static set priorityHeapLength(e){if(e<priorityHeapLength)for(;requestHeap.length>e;){cancelRequest(requestHeap.pop())}priorityHeapLength=e,requestHeap.maximumLength=e,requestHeap.reserve(e)}static update(){let e,t,i=0;const n=activeRequests.length;for(e=0;e<n;e++)t=activeRequests[e],t.cancelled&&cancelRequest(t),t.state===RequestState$1.ACTIVE?i>0&&(activeRequests[e-i]=t):++i;activeRequests.length-=i;const r=requestHeap.internalArray,s=requestHeap.length;for(e=0;e<s;++e)updatePriority(r[e]);requestHeap.resort();const a=Math.max(_RequestScheduler.maximumRequests-activeRequests.length,0);let o=0;for(;o<a&&requestHeap.length>0;)t=requestHeap.pop(),t.cancelled?cancelRequest(t):!t.throttleByServer||_RequestScheduler.serverHasOpenSlots(t.serverKey)?(startRequest(t),++o):cancelRequest(t)}static request(e){if(isDataUri(e.url)||isBlobUri(e.url))return e.state=RequestState$1.RECEIVED,e.requestFunction();if(++statistics.numberOfAttemptedRequests,defined$2(e.serverKey)||(e.serverKey=_RequestScheduler.getServerKey(e.url)),!e.throttle)return startRequest(e);if(activeRequests.length>=_RequestScheduler.maximumRequests)return;updatePriority(e);const t=requestHeap.insert(e);if(defined$2(t)){if(t===e)return;cancelRequest(t)}return issueRequest(e)}};let RequestScheduler=_RequestScheduler;function cancelRequest(e){const t=e.state===RequestState$1.ACTIVE;if(e.state=RequestState$1.CANCELLED,++statistics.numberOfCancelledRequests,defined$2(e.deferred)){const t=e.deferred;e.deferred=void 0,t.reject()}t&&(--statistics.numberOfActiveRequests,--numberOfActiveRequestsByServer[e.serverKey],++statistics.numberOfCancelledActiveRequests),defined$2(e.cancelFunction)&&e.cancelFunction()}function updatePriority(e){defined$2(e.priorityFunction)&&(e.priority=e.priorityFunction())}function issueRequest(e){return e.state===RequestState$1.UNISSUED&&(e.state=RequestState$1.ISSUED,e.deferred=defer()),e.deferred.promise}function getRequestReceivedFunction(e){return function(t){if(e.state===RequestState$1.CANCELLED)return;const i=e.deferred;--statistics.numberOfActiveRequests,--numberOfActiveRequestsByServer[e.serverKey],e.state=RequestState$1.RECEIVED,e.deferred=void 0,i.resolve(t)}}function getRequestFailedFunction(e){return function(t){e.state!==RequestState$1.CANCELLED&&(++statistics.numberOfFailedRequests,--statistics.numberOfActiveRequests,--numberOfActiveRequestsByServer[e.serverKey],e.state=RequestState$1.FAILED,e.deferred.reject(t))}}function startRequest(e){const t=issueRequest(e);return e.state=RequestState$1.ACTIVE,activeRequests.push(e),++statistics.numberOfActiveRequests,++statistics.numberOfActiveRequestsEver,++numberOfActiveRequestsByServer[e.serverKey],e.requestFunction().then(getRequestReceivedFunction(e)).catch(getRequestFailedFunction(e)),t}__publicField(RequestScheduler,"maximumRequests",50),__publicField(RequestScheduler,"maximumRequestsPerServer",18),__publicField(RequestScheduler,"requestsByServer",{}),__publicField(RequestScheduler,"throttleRequests",!0),__publicField(RequestScheduler,"debugShowStatistics",!1),__publicField(RequestScheduler,"getServerKey",(function(e){let t=new Uri(e);""===t.scheme()&&(t=t.absoluteTo(pageUri),t.normalize());let i=t.authority();/:/.test(i)||(i=`${i}:${"https"===t.scheme()?"443":"80"}`);return defined$2(numberOfActiveRequestsByServer[i])||(numberOfActiveRequestsByServer[i]=0),i})),__publicField(RequestScheduler,"serverHasOpenSlots",(function(e,t){t=defaultValue$1(t,1);const i=defaultValue$1(_RequestScheduler.requestsByServer[e],_RequestScheduler.maximumRequestsPerServer);return numberOfActiveRequestsByServer[e]+t<=i})),__publicField(RequestScheduler,"heapHasOpenSlots",(function(e){return requestHeap.length+e<=priorityHeapLength}));class DoublyLinkedListNode{constructor(e,t,i){this.item=e,this.previous=t,this.next=i}}function remove(e,t){defined$2(t.previous)&&defined$2(t.next)?(t.previous.next=t.next,t.next.previous=t.previous):defined$2(t.previous)?(t.previous.next=void 0,e.tail=t.previous):defined$2(t.next)?(t.next.previous=void 0,e.head=t.next):(e.head=void 0,e.tail=void 0),t.next=void 0,t.previous=void 0}class DoublyLinkedList{constructor(){this.head=void 0,this.tail=void 0,this._length=0}add(e){const t=new DoublyLinkedListNode(e,this.tail,void 0);return defined$2(this.tail)?(this.tail.next=t,this.tail=t):(this.head=t,this.tail=t),++this._length,t}remove(e){defined$2(e)&&(remove(this,e),--this._length)}splice(e,t){if(e===t)return;remove(this,t);const i=e.next;e.next=t,this.tail===e?this.tail=t:i.previous=t,t.next=i,t.previous=e}get length(){return this._length}}class Cesium3DTilesetCache{constructor(){this._list=new DoublyLinkedList,this._sentinel=this._list.add(),this.trimTiles=!1}reset(){this._list.splice(this._list.tail,this._sentinel)}touch(e){const t=e.cacheNode;defined$2(t)&&this._list.splice(this._sentinel,t)}add(e){defined$2(e.cachedNode)||(e.cacheNode=this._list.add(e))}unloadTile(e,t,i){const n=t.cacheNode;defined$2(n)&&(this._list.remove(n),t.cacheNode=void 0,i(e,t))}unloadTiles(e,t){const i=this._trimTiles;this._trimTiles=!1;const n=this._list,r=this._sentinel;let s=n.head;for(;s!==r&&(e.totalMemoryUsageInBytes>e.cacheBytes||i);){const i=s.item;s=s.next,this.unloadTile(e,i,t)}}trim(){this._trimTiles=!0}}class Cesium3DTilesetStatistics{constructor(){this.selected=0,this.visited=0,this.numberOfAttemptedRequests=0,this.numberOfPendingRequests=0,this.numberOfTilesProcessing=0,this.numberOfTilesWithContentReady=0,this.numberOfTilesTotal=0,this.numberOfLoadedTilesTotal=0,this.numberOfTilesCulledWithChildrenUnion=0,this.totalByteLength=0}clear(){this.selected=0,this.visited=0,this.numberOfAttemptedRequests=0,this.numberOfTilesCulledWithChildrenUnion=0}incrementSelectionCounts(){updatePointAndFeatureCounts(this,this.content,!1,!1)}incrementLoadCounts(e){updatePointAndFeatureCounts(this,e,!1,!0)}decrementLoadCounts(e){updatePointAndFeatureCounts(this,e,!0,!0)}}function updatePointAndFeatureCounts(e,t,i,n){const r=t.innerContents;t.pointsLength,t.trianglesLength,t.featuresLength;const s=t.byteSize;if(n&&(e.totalByteLength+=i?-s:s),defined$2(r)){const t=r.length;for(let s=0;s<t;++s)updatePointAndFeatureCounts(e,r[s],i,n)}}function objectToQuery(e){if(!defined$2(e))throw new Error("obj is required.");let t="";for(const i in e)if(e.hasOwnProperty(i)){const n=e[i],r=`${encodeURIComponent(i)}=`;if(Array.isArray(n))for(let e=0,i=n.length;e<i;++e)t+=`${r+encodeURIComponent(n[e])}&`;else t+=`${r+encodeURIComponent(n)}&`}return t=t.slice(0,-1),t}function checkAndResetRequest(e){if(e.state===RequestState$1.ISSUED||e.state===RequestState$1.ACTIVE)throw new Error("The Resource is already being fetched.");e.state=RequestState$1.UNISSUED,e.deferred=void 0}function stringifyQuery(e){const t=Object.keys(e);return 0===t.length?"":1!==t.length||defined$2(e[t[0]])?`?${objectToQuery(e)}`:`?${t[0]}`}function queryToObject(e){const t={};if(""===e)return t;const i=e.replace(/\+/g,"%20").split(/[&;]/);for(let n=0,r=i.length;n<r;++n){const e=i[n].split("="),r=decodeURIComponent(e[0]);let s=e[1];s=defined$2(s)?decodeURIComponent(s):"";const a=t[r];"string"==typeof a?t[r]=[a,s]:Array.isArray(a)?a.push(s):t[r]=s}return t}function combine(e,t,i){i=defaultValue$1(i,!1);const n={},r=defined$2(e),s=defined$2(t);let a,o,l;if(r)for(a in e)e.hasOwnProperty(a)&&(o=e[a],s&&i&&"object"==typeof o&&t.hasOwnProperty(a)?(l=t[a],n[a]="object"==typeof l?combine(o,l,i):o):n[a]=o);if(s)for(a in t)t.hasOwnProperty(a)&&!n.hasOwnProperty(a)&&(l=t[a],n[a]=l);return n}function clone(e,t){if(null===e||"object"!=typeof e)return e;t=defaultValue$1(t,!1);const i=new e.constructor;for(const n in e)if(e.hasOwnProperty(n)){let r=e[n];t&&(r=clone(r,t)),i[n]=r}return i}function combineQueryParameters(e,t,i){if(!i)return combine(e,t);const n=clone(e,!0);for(const r in t)if(t.hasOwnProperty(r)){let e=n[r];const i=t[r];defined$2(e)?(Array.isArray(e)||(e=n[r]=[e]),n[r]=e.concat(i)):n[r]=Array.isArray(i)?i.slice():i}return n}function parseQueryString(e){return 0===e.length?{}:-1===e.indexOf("=")?{[e]:void 0}:queryToObject(e)}class Resource{constructor(e){"string"==typeof(e=defaultValue$1(e,{}))&&(e={url:e}),this._url=void 0,this._templateValues=defaultValue$1(e.templateValues,{}),this._queryParameters=defaultValue$1(e.queryParameters,{}),this.headers=defaultValue$1(e.headers,{}),this.request=defaultValue$1(e.request,new Request),this.proxy=e.proxy,this.retryCallback=e.retryCallback,this.retryAttempts=defaultValue$1(e.retryAttempts,0),this._retryCount=0;defaultValue$1(e.parseUrl,!0)?this.parseUrl(e.url,!0,!0):this._url=e.url}parseUrl(e,t,i,n){let r=new Uri(e);const s=parseQueryString(r.query());this._queryParameters=t?combineQueryParameters(s,this.queryParameters,i):s,r.search(""),r.fragment(""),defined$2(n)&&""===r.scheme()&&(r=r.absoluteTo(getAbsoluteUri(n))),this._url=r.toString()}clone(e){return defined$2(e)?(e._url=this._url,e._queryParameters=clone(this._queryParameters),e._templateValues=clone(this._templateValues),e.headers=clone(this.headers),e.proxy=this.proxy,e.retryCallback=this.retryCallback,e.retryAttempts=this.retryAttempts,e._retryCount=0,e.request=this.request.clone(),e):new Resource({url:this._url,queryParameters:this.queryParameters,templateValues:this.templateValues,headers:this.headers,proxy:this.proxy,retryCallback:this.retryCallback,retryAttempts:this.retryAttempts,request:this.request.clone(),parseUrl:!1,credits:defined$2(this.credits)?this.credits.slice():void 0})}setQueryParameters(e,t){this._queryParameters=t?combineQueryParameters(this._queryParameters,e,!1):combineQueryParameters(e,this._queryParameters,!1)}getDerivedResource(e){const t=this.clone();if(t._retryCount=0,defined$2(e.url)){const i=defaultValue$1(e.preserveQueryParameters,!1);t.parseUrl(e.url,!0,i,this._url)}return defined$2(e.queryParameters)&&(t._queryParameters=combine(e.queryParameters,t.queryParameters)),defined$2(e.templateValues)&&(t._templateValues=combine(e.templateValues,t.templateValues)),defined$2(e.headers)&&(t.headers=combine(e.headers,t.headers)),defined$2(e.proxy)&&(t.proxy=e.proxy),defined$2(e.request)&&(t.request=e.request),defined$2(e.retryCallback)&&(t.retryCallback=e.retryCallback),defined$2(e.retryAttempts)&&(t.retryAttempts=e.retryAttempts),t}fetchJson(){const e=this.fetch({responseType:"text",headers:{Accept:"application/json,*/*;q=0.01"}});if(defined$2(e))return e.then((function(e){if(defined$2(e))return JSON.parse(e)}))}fetchArrayBuffer(){return this.fetch({responseType:"arraybuffer"})}fetch(e){return(e=defaultValue$1(e,{})).method="GET",this._makeRequest(e)}retryOnError(e){const t=this.retryCallback;if("function"!=typeof t||this._retryCount>=this.retryAttempts)return Promise.resolve(!1);const i=this;return Promise.resolve(t(this,e)).then((function(e){return++i._retryCount,e}))}_makeRequest(e){const t=this;checkAndResetRequest(t.request);const i=t.request,n=t.url;i.url=n,i.requestFunction=function(){const r=e.responseType,s=combine(e.headers,t.headers),a=e.overrideMimeType,o=e.method,l=e.data,c=defer(),h=Resource._Implementations.loadWithXhr(n,r,o,l,s,c,a);return defined$2(h)&&defined$2(h.abort)&&(i.cancelFunction=function(){h.abort()}),c.promise};const r=RequestScheduler.request(i);if(defined$2(r))return r.then((function(e){return i.cancelFunction=void 0,e})).catch((function(n){return i.cancelFunction=void 0,i.state!==RequestState$1.FAILED?Promise.reject(n):t.retryOnError(n).then((function(r){return r?(i.state=RequestState$1.UNISSUED,i.deferred=void 0,t.fetch(e)):Promise.reject(n)}))}))}getUrlComponent(e,t){if(this.isDataUri)return this._url;let i=this._url;e&&(i=`${i}${stringifyQuery(this.queryParameters||{})}`),i=i.replace(/%7B/g,"{").replace(/%7D/g,"}");const n=this._templateValues;return Object.keys(n).length>0&&(i=i.replace(/{(.*?)}/g,(function(e,t){const i=n[t];return defined$2(i)?encodeURIComponent(i):e}))),t&&defined$2(this.proxy)&&(i=this.proxy.getURL(i)),i}getBaseUri(e){return getBaseUri(this.getUrlComponent(e),e)}static createIfNeeded(e){return e instanceof Resource?e.getDerivedResource({request:e.request}):"string"!=typeof e?e:new Resource({url:e})}static fetchArrayBuffer(e){return new Resource(e).fetchArrayBuffer()}get url(){return this.getUrlComponent(!0,!0)}set url(e){this.parseUrl(e,!1,!1)}get queryParameters(){return this._queryParameters}get extension(){return getExtensionFromUri(this._url)}}const dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;function decodeDataUriText(e,t){const i=decodeURIComponent(t);return e?atob(i):i}function decodeDataUriArrayBuffer(e,t){const i=decodeDataUriText(e,t),n=new ArrayBuffer(i.length),r=new Uint8Array(n);for(let s=0;s<i.length;s++)r[s]=i.charCodeAt(s);return n}function decodeDataUri(e,t){t=defaultValue$1(t,"");const i=e[1],n=!!e[2],r=e[3];let s,a;switch(t){case"":case"text":return decodeDataUriText(n,r);case"arraybuffer":return decodeDataUriArrayBuffer(n,r);case"blob":return s=decodeDataUriArrayBuffer(n,r),new Blob([s],{type:i});case"document":return a=new DOMParser,a.parseFromString(decodeDataUriText(n,r),i);case"json":return JSON.parse(decodeDataUriText(n,r));default:throw new Error(`Unhandled responseType: ${t}`)}}const noXMLHttpRequest="undefined"==typeof XMLHttpRequest;function loadWithHttpRequest(e,t,i,n,r,s,a){fetch(e,{method:i,headers:r}).then((async e=>{if(!e.ok)return e.headers.forEach(((e,t)=>{})),void s.reject();switch(t){case"text":s.resolve(e.text());break;case"json":s.resolve(e.json());break;default:s.resolve(new Uint8Array(await e.arrayBuffer()).buffer)}})).catch((()=>{}))}Resource._Implementations={},Resource._Implementations.loadWithXhr=function(t,i,n,r,s,a,o){const l=dataUriRegex.exec(t);if(null!==l)return void a.resolve(decodeDataUri(l,i));if(noXMLHttpRequest)return void loadWithHttpRequest(t,i,n,r,s,a);const c=new XMLHttpRequest;if(c.open(n,t,!0),defined$2(o)&&defined$2(c.overrideMimeType)&&c.overrideMimeType(o),defined$2(s))for(const e in s)s.hasOwnProperty(e)&&c.setRequestHeader(e,s[e]);defined$2(i)&&(c.responseType=i);let h=!1;return"string"==typeof t&&(h=0===t.indexOf("file://")||"undefined"!=typeof window&&"file://"===window.location.origin),c.onload=function(){if((c.status<200||c.status>=300)&&(!h||0!==c.status))return void a.reject();const t=c.response,r=c.responseType;if("HEAD"===n||"OPTIONS"===n){const e=c.getAllResponseHeaders().trim().split(/[\r\n]+/),t={};return e.forEach((function(e){const i=e.split(": "),n=i.shift();t[n]=i.join(": ")})),void a.resolve(t)}if(204===c.status)a.resolve(void 0);else if(!defined$2(t)||defined$2(i)&&r!==i)if("json"===i&&"string"==typeof t)try{a.resolve(JSON.parse(t))}catch(e){a.reject(e)}else(""===r||"document"===r)&&defined$2(c.responseXML)&&c.responseXML.hasChildNodes()?a.resolve(c.responseXML):""!==r&&"text"!==r||!defined$2(c.responseText)?a.reject(new Error("Invalid XMLHttpRequest response type.")):a.resolve(c.responseText);else a.resolve(t)},c.onerror=function(e){},c.send(r),c};const Cesium3DTileOptimizations={},scratchAxis=new three.Vector3,Cesium3DTileOptimizationHint={NOT_COMPUTED:-1,USE_OPTIMIZATION:1,SKIP_OPTIMIZATION:0};function getObb(e){const t=e.boundingVolume;let i;return t.obb?i=t.obb:t.regionObb&&(i=t.regionObb),i}Cesium3DTileOptimizations.checkChildrenWithinParent=function(e){const t=e.children,i=t.length,n=getObb(e);if(n){e._optimChildrenWithinParent=Cesium3DTileOptimizationHint.USE_OPTIMIZATION;for(let r=0;r<i;++r){const i=getObb(t[r]);if(!i){e._optimChildrenWithinParent=Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;break}const s=scratchAxis.subVectors(i.center,n.center),a=s.length();s.divideScalar(a);const o=n.halfAxes,l=Math.abs(o[0]*s.x)+Math.abs(o[1]*s.y)+Math.abs(o[2]*s.z)+Math.abs(o[3]*s.x)+Math.abs(o[4]*s.y)+Math.abs(o[5]*s.z)+Math.abs(o[6]*s.x)+Math.abs(o[7]*s.y)+Math.abs(o[8]*s.z),c=i.halfAxes;if(l<=Math.abs(c[0]*s.x)+Math.abs(c[1]*s.y)+Math.abs(c[2]*s.z)+Math.abs(c[3]*s.x)+Math.abs(c[4]*s.y)+Math.abs(c[5]*s.z)+Math.abs(c[6]*s.x)+Math.abs(c[7]*s.y)+Math.abs(c[8]*s.z)+a){e._optimChildrenWithinParent=Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;break}}}return e._optimChildrenWithinParent===Cesium3DTileOptimizationHint.USE_OPTIMIZATION};const _mat3=new three.Matrix3;function findIntersectionPoint(e,t,i,n){const r=_mat3.set(e.normal.x,e.normal.y,e.normal.z,t.normal.x,t.normal.y,t.normal.z,i.normal.x,i.normal.y,i.normal.z);return n.set(-e.constant,-t.constant,-i.constant),n.applyMatrix3(r.invert()),n}class ExtendedFrustum extends three.Frustum{constructor(){super(),this.points=Array(8).fill().map((()=>new three.Vector3))}setFromProjectionMatrix(e,t){super.setFromProjectionMatrix(e,t),this.calculateFrustumPoints()}calculateFrustumPoints(){const{planes:e,points:t}=this;[[e[0],e[3],e[4]],[e[1],e[3],e[4]],[e[0],e[2],e[4]],[e[1],e[2],e[4]],[e[0],e[3],e[5]],[e[1],e[3],e[5]],[e[0],e[2],e[5]],[e[1],e[2],e[5]]].forEach(((e,i)=>{findIntersectionPoint(e[0],e[1],e[2],t[i])}))}}function Empty3DTileContent(e,t){this._tileset=e,this._tile=t,this.featurePropertiesDirty=!1}Object.defineProperties(Empty3DTileContent.prototype,{featuresLength:{get:function(){return 0}},pointsLength:{get:function(){return 0}},trianglesLength:{get:function(){return 0}},geometryByteLength:{get:function(){return 0}},texturesByteLength:{get:function(){return 0}},batchTableByteLength:{get:function(){return 0}},innerContents:{get:function(){}},ready:{get:function(){return!0}},tileset:{get:function(){return this._tileset}},tile:{get:function(){return this._tile}},url:{get:function(){}},metadata:{get:function(){},set:function(e){throw new Error("Empty3DTileContent cannot have content metadata")}},batchTable:{get:function(){}},group:{get:function(){},set:function(e){throw new Error("Empty3DTileContent cannot have group metadata")}}}),Empty3DTileContent.prototype.hasProperty=function(e,t){return!1},Empty3DTileContent.prototype.getFeature=function(e){},Empty3DTileContent.prototype.applyDebugSettings=function(e,t){},Empty3DTileContent.prototype.applyStyle=function(e){},Empty3DTileContent.prototype.update=function(e,t){},Empty3DTileContent.prototype.pick=function(e,t,i){},Empty3DTileContent.prototype.isDestroyed=function(){return!1},Empty3DTileContent.prototype.destroy=function(){return destroyObject(this)};const Cesium3DTileContentType={BATCHED_3D_MODEL:"b3dm",INSTANCED_3D_MODEL:"i3dm",COMPOSITE:"cmpt",POINT_CLOUD:"pnts",VECTOR:"vctr",GEOMETRY:"geom",GLTF:"gltf",GLTF_BINARY:"glb",IMPLICIT_SUBTREE:"subt",IMPLICIT_SUBTREE_JSON:"subtreeJson",EXTERNAL_TILESET:"externalTileset",MULTIPLE_CONTENT:"multipleContent",GEOJSON:"geoJson",VOXEL_BINARY:"voxl",VOXEL_JSON:"voxelJson",isBinaryFormat:function(e){switch(e){case Cesium3DTileContentType.BATCHED_3D_MODEL:case Cesium3DTileContentType.INSTANCED_3D_MODEL:case Cesium3DTileContentType.COMPOSITE:case Cesium3DTileContentType.POINT_CLOUD:case Cesium3DTileContentType.VECTOR:case Cesium3DTileContentType.GEOMETRY:case Cesium3DTileContentType.IMPLICIT_SUBTREE:case Cesium3DTileContentType.VOXEL_BINARY:case Cesium3DTileContentType.GLTF_BINARY:return!0;default:return!1}}},Cesium3DTileContentType$1=Object.freeze(Cesium3DTileContentType);class Tileset3DTileContent{constructor(e,t,i){this.isTileset3DTileContent=!0,this._tileset=e,this._tile=t,this._resource=i,this.featurePropertiesDirty=null,this._metadata=void 0,this._group=void 0,this._ready=!1}static fromJson(e,t,i,n){const r=new Tileset3DTileContent(e,t,i);return r._tileset.loadTileset(r._resource,n,r._tile),r._ready=!0,r}hasProperty(e,t){return!1}getFeature(e){}applyDebugSettings(){}applyStyle(e){}update(e,t){}isDestroyed(){return!1}destroy(){return destroyObject(this)}get featuresLength(){return 0}get pointsLength(){return 0}get trianglesLength(){return 0}get geometryByteLength(){return 0}get texturesByteLength(){return 0}get batchTableByteLength(){return 0}get innerContents(){}get ready(){return this._ready}get tileset(){return this._tileset}get tile(){return this._tile}get url(){return this._resource.getUrlComponent(!0)}get batchTable(){}get metadata(){return this._metadata}set metadata(e){this._metadata=e}get group(){return this._group}set group(e){this._group=e}}const utf8decoder=new TextDecoder;function arrayToString(e){return utf8decoder.decode(e)}function parseBinArray(e,t,i,n,r,s){let a,o;switch(n){case"SCALAR":a=1;break;case"VEC2":a=2;break;case"VEC3":a=3;break;case"VEC4":a=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${s}".`)}const l=i*a;switch(r){case"BYTE":o=new Int8Array(e,t,l);break;case"UNSIGNED_BYTE":o=new Uint8Array(e,t,l);break;case"SHORT":o=new Int16Array(e,t,l);break;case"UNSIGNED_SHORT":o=new Uint16Array(e,t,l);break;case"INT":o=new Int32Array(e,t,l);break;case"UNSIGNED_INT":o=new Uint32Array(e,t,l);break;case"FLOAT":o=new Float32Array(e,t,l);break;case"DOUBLE":o=new Float64Array(e,t,l);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${s}".`)}return o}class FeatureTable{constructor(e,t,i,n){this.buffer=e,this.binOffset=t+i,this.binLength=n;let r=null;if(0!==i){const n=new Uint8Array(e,t,i);r=JSON.parse(arrayToString(n))}else r={};this.header=r}getKeys(){return Object.keys(this.header)}getData(e,t,i=null,n=null){const r=this.header;if(!(e in r))return null;const s=r[e];if(!(s instanceof Object))return s;if(Array.isArray(s))return s;const{buffer:a,binOffset:o,binLength:l}=this,c=s.byteOffset||0,h=s.type||n,u=s.componentType||i;if("type"in s&&n&&s.type!==n)throw new Error("FeatureTable: Specified type does not match expected type.");const d=o+c,p=parseBinArray(a,d,t,h,u,e);if(d+p.byteLength>o+l)throw new Error("FeatureTable: Feature data read outside binary body length.");return p}getBuffer(e,t){const{buffer:i,binOffset:n}=this;return i.slice(n+e,n+e+t)}}class BatchTableHierarchyExtension{constructor(e){var t;this.batchTable=e;const i=e.header.extensions["3DTILES_batch_table_hierarchy"];this.classes=i.classes;for(const r of this.classes){const e=r.instances;for(const t in e)e.hasOwnProperty(t)&&(r.instances[t]=this._parseProperty(e[t],r.length,t))}if(this.instancesLength=i.instancesLength,this.classIds=this._parseProperty(i.classIds,this.instancesLength,"classIds"),i.parentCounts?this.parentCounts=this._parseProperty(i.parentCounts,this.instancesLength,"parentCounts"):this.parentCounts=new Array(this.instancesLength).fill(1),i.parentIds){const e=this.parentCounts.reduce(((e,t)=>e+t),0);this.parentIds=this._parseProperty(i.parentIds,e,"parentIds")}else this.parentIds=null;this.instancesIds=[];const n={};for(const r of this.classIds)n[r]=null!=(t=n[r])?t:0,this.instancesIds.push(n[r]),n[r]++}_parseProperty(e,t,i){if(Array.isArray(e))return e;const{buffer:n,binOffset:r}=this.batchTable;return parseBinArray(n,r+e.byteOffset,t,"SCALAR",e.componentType||"UNSIGNED_SHORT",i)}getDataFromId(e,t={}){const i=this.parentCounts[e];if(this.parentIds&&i>0){let n=0;for(let t=0;t<e;t++)n+=this.parentCounts[t];for(let r=0;r<i;r++){const i=this.parentIds[n+r];i!==e&&this.getDataFromId(i,t)}}const n=this.classIds[e],r=this.classes[n].instances,s=this.classes[n].name,a=this.instancesIds[e];for(const o in r)r.hasOwnProperty(o)&&(t[s]=t[s]||{},t[s][o]=r[o][a]);return t}}class BatchTable extends FeatureTable{constructor(e,t,i,n,r){super(e,i,n,r),this.batchSize=t,this.extensions={};const s=this.header.extensions;s&&s["3DTILES_batch_table_hierarchy"]&&(this.extensions["3DTILES_batch_table_hierarchy"]=new BatchTableHierarchyExtension(this))}getData(e,t=null,i=null){return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId instead."),super.getData(e,this.batchSize,t,i)}getDataFromId(e,t={}){if(e<0||e>=this.batchSize)throw new Error(`BatchTable: id value "${e}" out of bounds for "${this.batchSize}" features number.`);for(const i of this.getKeys())"extensions"!==i&&(t[i]=super.getData(i,this.batchSize)[e]);for(const i in this.extensions)if(this.extensions.hasOwnProperty(i)){const n=this.extensions[i];n.getDataFromId instanceof Function&&(t[i]=t[i]||{},n.getDataFromId(e,t[i]))}return t}}class LoaderBase{constructor(){this.fetchOptions={},this.workingPath=""}load(e){return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'),this.loadAsync(e)}loadAsync(e){return fetch(e,this.fetchOptions).then((t=>{if(!t.ok)throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`);return t.arrayBuffer()})).then((t=>(""===this.workingPath&&(this.workingPath=this.workingPathForURL(e)),this.parse(t))))}resolveExternalURL(e){return/^[^\\/]/.test(e)?this.workingPath+"/"+e:e}workingPathForURL(e){const t=e.split(/[\\/]/g);t.pop();return t.join("/")+"/"}parse(e){throw new Error("LoaderBase: Parse not implemented.")}}class B3DMLoaderBase extends LoaderBase{parse(e){const t=new DataView(e),i=t.getUint32(4,!0);console.assert(1===i);const n=t.getUint32(8,!0);console.assert(n===e.byteLength);const r=t.getUint32(12,!0),s=t.getUint32(16,!0),a=t.getUint32(20,!0),o=t.getUint32(24,!0),l=e.slice(28,28+r+s),c=new FeatureTable(l,0,r,s),h=28+r+s,u=e.slice(h,h+a+o),d=new BatchTable(u,c.getData("BATCH_LENGTH"),0,a,o),p=h+a+o;return{version:i,featureTable:c,batchTable:d,glbBytes:new Uint8Array(e,p,n-p)}}}class GLTFLoader extends three.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(e){return new GLTFMaterialsClearcoatExtension(e)})),this.register((function(e){return new GLTFMaterialsDispersionExtension(e)})),this.register((function(e){return new GLTFTextureBasisUExtension(e)})),this.register((function(e){return new GLTFTextureWebPExtension(e)})),this.register((function(e){return new GLTFTextureAVIFExtension(e)})),this.register((function(e){return new GLTFMaterialsSheenExtension(e)})),this.register((function(e){return new GLTFMaterialsTransmissionExtension(e)})),this.register((function(e){return new GLTFMaterialsVolumeExtension(e)})),this.register((function(e){return new GLTFMaterialsIorExtension(e)})),this.register((function(e){return new GLTFMaterialsEmissiveStrengthExtension(e)})),this.register((function(e){return new GLTFMaterialsSpecularExtension(e)})),this.register((function(e){return new GLTFMaterialsIridescenceExtension(e)})),this.register((function(e){return new GLTFMaterialsAnisotropyExtension(e)})),this.register((function(e){return new GLTFMaterialsBumpExtension(e)})),this.register((function(e){return new GLTFLightsExtension(e)})),this.register((function(e){return new GLTFMeshoptCompression(e)})),this.register((function(e){return new GLTFMeshGpuInstancing(e)}))}load(t,i,n,r){const s=this;let a;if(""!==this.resourcePath)a=this.resourcePath;else if(""!==this.path){const e=three.LoaderUtils.extractUrlBase(t);a=three.LoaderUtils.resolveURL(e,this.path)}else a=three.LoaderUtils.extractUrlBase(t);this.manager.itemStart(t);const o=function(e){r?r(e):console.error(e),s.manager.itemError(t),s.manager.itemEnd(t)},l=new three.FileLoader(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(t,(function(n){try{s.parse(n,a,(function(e){i(e),s.manager.itemEnd(t)}),o)}catch(e){o(e)}}),n,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,n){let r;const s={},a={},o=new TextDecoder;if("string"==typeof e)r=JSON.parse(e);else if(e instanceof ArrayBuffer){if(o.decode(new Uint8Array(e,0,4))===BINARY_EXTENSION_HEADER_MAGIC){try{s[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFBinaryExtension(e)}catch(c){return void(n&&n(c))}r=JSON.parse(s[EXTENSIONS.KHR_BINARY_GLTF].content)}else r=JSON.parse(o.decode(e))}else r=e;if(void 0===r.asset||r.asset.version[0]<2)return void(n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const l=new GLTFParser(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const e=this.pluginCallbacks[h](l);e.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[e.name]=e,s[e.name]=!0}if(r.extensionsUsed)for(let h=0;h<r.extensionsUsed.length;++h){const e=r.extensionsUsed[h],t=r.extensionsRequired||[];switch(e){case EXTENSIONS.KHR_MATERIALS_UNLIT:s[e]=new GLTFMaterialsUnlitExtension;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:s[e]=new GLTFDracoMeshCompressionExtension(r,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:s[e]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:s[e]=new GLTFMeshQuantizationExtension;break;default:t.indexOf(e)>=0&&void 0===a[e]&&console.warn('THREE.GLTFLoader: Unknown extension "'+e+'".')}}l.setExtensions(s),l.setPlugins(a),l.parse(i,n)}parseAsync(e,t){const i=this;return new Promise((function(n,r){i.parse(e,t,n,r)}))}}function GLTFRegistry(){let e={};return{get:function(t){return e[t]},add:function(t,i){e[t]=i},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class GLTFLightsExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let i=0,n=t.length;i<n;i++){const n=t[i];n.extensions&&n.extensions[this.name]&&void 0!==n.extensions[this.name].light&&e._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(e){const t=this.parser,i="light:"+e;let n=t.cache.get(i);if(n)return n;const r=t.json,s=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let a;const o=new three.Color(16777215);void 0!==s.color&&o.setRGB(s.color[0],s.color[1],s.color[2],three.LinearSRGBColorSpace);const l=void 0!==s.range?s.range:0;switch(s.type){case"directional":a=new three.DirectionalLight(o),a.target.position.set(0,0,-1),a.add(a.target);break;case"point":a=new three.PointLight(o),a.distance=l;break;case"spot":a=new three.SpotLight(o),a.distance=l,s.spot=s.spot||{},s.spot.innerConeAngle=void 0!==s.spot.innerConeAngle?s.spot.innerConeAngle:0,s.spot.outerConeAngle=void 0!==s.spot.outerConeAngle?s.spot.outerConeAngle:Math.PI/4,a.angle=s.spot.outerConeAngle,a.penumbra=1-s.spot.innerConeAngle/s.spot.outerConeAngle,a.target.position.set(0,0,-1),a.add(a.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+s.type)}return a.position.set(0,0,0),assignExtrasToUserData(a,s),void 0!==s.intensity&&(a.intensity=s.intensity),a.name=t.createUniqueName(s.name||"light_"+e),n=Promise.resolve(a),t.cache.add(i,n),n}getDependency(e,t){if("light"===e)return this._loadLight(t)}createNodeAttachment(e){const t=this,i=this.parser,n=i.json.nodes[e],r=(n.extensions&&n.extensions[this.name]||{}).light;return void 0===r?null:this._loadLight(r).then((function(e){return i._getNodeRef(t.cache,r,e)}))}}class GLTFMaterialsUnlitExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return three.MeshBasicMaterial}extendParams(e,t,i){const n=[];e.color=new three.Color(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const t=r.baseColorFactor;e.color.setRGB(t[0],t[1],t[2],three.LinearSRGBColorSpace),e.opacity=t[3]}void 0!==r.baseColorTexture&&n.push(i.assignTexture(e,"map",r.baseColorTexture,three.SRGBColorSpace))}return Promise.all(n)}}class GLTFMaterialsEmissiveStrengthExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name].emissiveStrength;return void 0!==n&&(t.emissiveIntensity=n),Promise.resolve()}}class GLTFMaterialsClearcoatExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];if(void 0!==s.clearcoatFactor&&(t.clearcoat=s.clearcoatFactor),void 0!==s.clearcoatTexture&&r.push(i.assignTexture(t,"clearcoatMap",s.clearcoatTexture)),void 0!==s.clearcoatRoughnessFactor&&(t.clearcoatRoughness=s.clearcoatRoughnessFactor),void 0!==s.clearcoatRoughnessTexture&&r.push(i.assignTexture(t,"clearcoatRoughnessMap",s.clearcoatRoughnessTexture)),void 0!==s.clearcoatNormalTexture&&(r.push(i.assignTexture(t,"clearcoatNormalMap",s.clearcoatNormalTexture)),void 0!==s.clearcoatNormalTexture.scale)){const e=s.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new three.Vector2(e,e)}return Promise.all(r)}}class GLTFMaterialsDispersionExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_DISPERSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name];return t.dispersion=void 0!==n.dispersion?n.dispersion:0,Promise.resolve()}}class GLTFMaterialsIridescenceExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];return void 0!==s.iridescenceFactor&&(t.iridescence=s.iridescenceFactor),void 0!==s.iridescenceTexture&&r.push(i.assignTexture(t,"iridescenceMap",s.iridescenceTexture)),void 0!==s.iridescenceIor&&(t.iridescenceIOR=s.iridescenceIor),void 0===t.iridescenceThicknessRange&&(t.iridescenceThicknessRange=[100,400]),void 0!==s.iridescenceThicknessMinimum&&(t.iridescenceThicknessRange[0]=s.iridescenceThicknessMinimum),void 0!==s.iridescenceThicknessMaximum&&(t.iridescenceThicknessRange[1]=s.iridescenceThicknessMaximum),void 0!==s.iridescenceThicknessTexture&&r.push(i.assignTexture(t,"iridescenceThicknessMap",s.iridescenceThicknessTexture)),Promise.all(r)}}class GLTFMaterialsSheenExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new three.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const s=n.extensions[this.name];if(void 0!==s.sheenColorFactor){const e=s.sheenColorFactor;t.sheenColor.setRGB(e[0],e[1],e[2],three.LinearSRGBColorSpace)}return void 0!==s.sheenRoughnessFactor&&(t.sheenRoughness=s.sheenRoughnessFactor),void 0!==s.sheenColorTexture&&r.push(i.assignTexture(t,"sheenColorMap",s.sheenColorTexture,three.SRGBColorSpace)),void 0!==s.sheenRoughnessTexture&&r.push(i.assignTexture(t,"sheenRoughnessMap",s.sheenRoughnessTexture)),Promise.all(r)}}class GLTFMaterialsTransmissionExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];return void 0!==s.transmissionFactor&&(t.transmission=s.transmissionFactor),void 0!==s.transmissionTexture&&r.push(i.assignTexture(t,"transmissionMap",s.transmissionTexture)),Promise.all(r)}}class GLTFMaterialsVolumeExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];t.thickness=void 0!==s.thicknessFactor?s.thicknessFactor:0,void 0!==s.thicknessTexture&&r.push(i.assignTexture(t,"thicknessMap",s.thicknessTexture)),t.attenuationDistance=s.attenuationDistance||1/0;const a=s.attenuationColor||[1,1,1];return t.attenuationColor=(new three.Color).setRGB(a[0],a[1],a[2],three.LinearSRGBColorSpace),Promise.all(r)}}class GLTFMaterialsIorExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const n=i.extensions[this.name];return t.ior=void 0!==n.ior?n.ior:1.5,Promise.resolve()}}class GLTFMaterialsSpecularExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];t.specularIntensity=void 0!==s.specularFactor?s.specularFactor:1,void 0!==s.specularTexture&&r.push(i.assignTexture(t,"specularIntensityMap",s.specularTexture));const a=s.specularColorFactor||[1,1,1];return t.specularColor=(new three.Color).setRGB(a[0],a[1],a[2],three.LinearSRGBColorSpace),void 0!==s.specularColorTexture&&r.push(i.assignTexture(t,"specularColorMap",s.specularColorTexture,three.SRGBColorSpace)),Promise.all(r)}}class GLTFMaterialsBumpExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.EXT_MATERIALS_BUMP}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];return t.bumpScale=void 0!==s.bumpFactor?s.bumpFactor:1,void 0!==s.bumpTexture&&r.push(i.assignTexture(t,"bumpMap",s.bumpTexture)),Promise.all(r)}}class GLTFMaterialsAnisotropyExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?three.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const i=this.parser,n=i.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],s=n.extensions[this.name];return void 0!==s.anisotropyStrength&&(t.anisotropy=s.anisotropyStrength),void 0!==s.anisotropyRotation&&(t.anisotropyRotation=s.anisotropyRotation),void 0!==s.anisotropyTexture&&r.push(i.assignTexture(t,"anisotropyMap",s.anisotropyTexture)),Promise.all(r)}}class GLTFTextureBasisUExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,i=t.json,n=i.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const r=n.extensions[this.name],s=t.options.ktx2Loader;if(!s){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,s)}}class GLTFTextureWebPExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.EXT_TEXTURE_WEBP}loadTexture(e){const t=this.name,i=this.parser,n=i.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const s=r.extensions[t],a=n.images[s.source];let o=i.textureLoader;if(a.uri){const e=i.options.manager.getHandler(a.uri);null!==e&&(o=e)}return i.loadTextureImage(e,s.source,o)}}class GLTFTextureAVIFExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.EXT_TEXTURE_AVIF}loadTexture(e){const t=this.name,i=this.parser,n=i.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const s=r.extensions[t],a=n.images[s.source];let o=i.textureLoader;if(a.uri){const e=i.options.manager.getHandler(a.uri);null!==e&&(o=e)}return i.loadTextureImage(e,s.source,o)}}class GLTFMeshoptCompression{constructor(e){this.name=EXTENSIONS.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,i=t.bufferViews[e];if(i.extensions&&i.extensions[this.name]){const e=i.extensions[this.name],n=this.parser.getDependency("buffer",e.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return n.then((function(t){const i=e.byteOffset||0,n=e.byteLength||0,s=e.count,a=e.byteStride,o=new Uint8Array(t,i,n);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(s,a,o,e.mode,e.filter).then((function(e){return e.buffer})):r.ready.then((function(){const t=new ArrayBuffer(s*a);return r.decodeGltfBuffer(new Uint8Array(t),s,a,o,e.mode,e.filter),t}))}))}return null}}class GLTFMeshGpuInstancing{constructor(e){this.name=EXTENSIONS.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,i=t.nodes[e];if(!i.extensions||!i.extensions[this.name]||void 0===i.mesh)return null;const n=t.meshes[i.mesh];for(const o of n.primitives)if(o.mode!==WEBGL_CONSTANTS.TRIANGLES&&o.mode!==WEBGL_CONSTANTS.TRIANGLE_STRIP&&o.mode!==WEBGL_CONSTANTS.TRIANGLE_FAN&&void 0!==o.mode)return null;const r=i.extensions[this.name].attributes,s=[],a={};for(const o in r)s.push(this.parser.getDependency("accessor",r[o]).then((e=>(a[o]=e,a[o]))));return s.length<1?null:(s.push(this.parser.createNodeMesh(e)),Promise.all(s).then((e=>{const t=e.pop(),i=t.isGroup?t.children:[t],n=e[0].count,r=[];for(const s of i){const e=new three.Matrix4,t=new three.Vector3,i=new three.Quaternion,o=new three.Vector3(1,1,1),l=new three.InstancedMesh(s.geometry,s.material,n);for(let r=0;r<n;r++)a.TRANSLATION&&t.fromBufferAttribute(a.TRANSLATION,r),a.ROTATION&&i.fromBufferAttribute(a.ROTATION,r),a.SCALE&&o.fromBufferAttribute(a.SCALE,r),l.setMatrixAt(r,e.compose(t,i,o));for(const n in a)if("_COLOR_0"===n){const e=a[n];l.instanceColor=new three.InstancedBufferAttribute(e.array,e.itemSize,e.normalized)}else"TRANSLATION"!==n&&"ROTATION"!==n&&"SCALE"!==n&&s.geometry.setAttribute(n,a[n]);three.Object3D.prototype.copy.call(l,s),this.parser.assignFinalMaterial(l),r.push(l)}return t.isGroup?(t.clear(),t.add(...r),t):r[0]})))}}const BINARY_EXTENSION_HEADER_MAGIC="glTF",BINARY_EXTENSION_HEADER_LENGTH=12,BINARY_EXTENSION_CHUNK_TYPES={JSON:1313821514,BIN:5130562};class GLTFBinaryExtension{constructor(e){this.name=EXTENSIONS.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,BINARY_EXTENSION_HEADER_LENGTH),i=new TextDecoder;if(this.header={magic:i.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-BINARY_EXTENSION_HEADER_LENGTH,r=new DataView(e,BINARY_EXTENSION_HEADER_LENGTH);let s=0;for(;s<n;){const t=r.getUint32(s,!0);s+=4;const n=r.getUint32(s,!0);if(s+=4,n===BINARY_EXTENSION_CHUNK_TYPES.JSON){const n=new Uint8Array(e,BINARY_EXTENSION_HEADER_LENGTH+s,t);this.content=i.decode(n)}else if(n===BINARY_EXTENSION_CHUNK_TYPES.BIN){const i=BINARY_EXTENSION_HEADER_LENGTH+s;this.body=e.slice(i,i+t)}s+=t}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const i=this.json,n=this.dracoLoader,r=e.extensions[this.name].bufferView,s=e.extensions[this.name].attributes,a={},o={},l={};for(const c in s){const e=ATTRIBUTES[c]||c.toLowerCase();a[e]=s[c]}for(const c in e.attributes){const t=ATTRIBUTES[c]||c.toLowerCase();if(void 0!==s[c]){const n=i.accessors[e.attributes[c]],r=WEBGL_COMPONENT_TYPES[n.componentType];l[t]=r.name,o[t]=!0===n.normalized}}return t.getDependency("bufferView",r).then((function(e){return new Promise((function(t,i){n.decodeDracoFile(e,(function(e){for(const t in e.attributes){const i=e.attributes[t],n=o[t];void 0!==n&&(i.normalized=n)}t(e)}),a,l,three.LinearSRGBColorSpace,i)}))}))}}class GLTFTextureTransformExtension{constructor(){this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&t.texCoord!==e.channel||void 0!==t.offset||void 0!==t.rotation||void 0!==t.scale?(e=e.clone(),void 0!==t.texCoord&&(e.channel=t.texCoord),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0,e):e}}class GLTFMeshQuantizationExtension{constructor(){this.name=EXTENSIONS.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends three.Interpolant{constructor(e,t,i,n){super(e,t,i,n)}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=e*n*3+n;for(let s=0;s!==n;s++)t[s]=i[r+s];return t}interpolate_(e,t,i,n){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=2*a,l=3*a,c=n-t,h=(i-t)/c,u=h*h,d=u*h,p=e*l,m=p-l,f=-2*d+3*u,g=d-u,_=1-f,A=g-u+h;for(let v=0;v!==a;v++){const e=s[m+v+a],t=s[m+v+o]*c,i=s[p+v+a],n=s[p+v]*c;r[v]=_*e+A*t+f*i+g*n}return r}}const _quaternion=new three.Quaternion;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(e,t,i,n){const r=super.interpolate_(e,t,i,n);return _quaternion.fromArray(r).normalize().toArray(r),r}}const WEBGL_CONSTANTS={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:three.NearestFilter,9729:three.LinearFilter,9984:three.NearestMipmapNearestFilter,9985:three.LinearMipmapNearestFilter,9986:three.NearestMipmapLinearFilter,9987:three.LinearMipmapLinearFilter},WEBGL_WRAPPINGS={33071:three.ClampToEdgeWrapping,33648:three.MirroredRepeatWrapping,10497:three.RepeatWrapping},WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION={CUBICSPLINE:void 0,LINEAR:three.InterpolateLinear,STEP:three.InterpolateDiscrete},ALPHA_MODES={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function createDefaultMaterial(e){return void 0===e.DefaultMaterial&&(e.DefaultMaterial=new three.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:three.FrontSide})),e.DefaultMaterial}function addUnknownExtensionsToUserData(e,t,i){for(const n in i.extensions)void 0===e[n]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[n]=i.extensions[n])}function assignExtrasToUserData(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function addMorphTargets(e,t,i){let n=!1,r=!1,s=!1;for(let c=0,h=t.length;c<h;c++){const e=t[c];if(void 0!==e.POSITION&&(n=!0),void 0!==e.NORMAL&&(r=!0),void 0!==e.COLOR_0&&(s=!0),n&&r&&s)break}if(!n&&!r&&!s)return Promise.resolve(e);const a=[],o=[],l=[];for(let c=0,h=t.length;c<h;c++){const h=t[c];if(n){const t=void 0!==h.POSITION?i.getDependency("accessor",h.POSITION):e.attributes.position;a.push(t)}if(r){const t=void 0!==h.NORMAL?i.getDependency("accessor",h.NORMAL):e.attributes.normal;o.push(t)}if(s){const t=void 0!==h.COLOR_0?i.getDependency("accessor",h.COLOR_0):e.attributes.color;l.push(t)}}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l)]).then((function(t){const i=t[0],a=t[1],o=t[2];return n&&(e.morphAttributes.position=i),r&&(e.morphAttributes.normal=a),s&&(e.morphAttributes.color=o),e.morphTargetsRelative=!0,e}))}function updateMorphTargets(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let i=0,n=t.weights.length;i<n;i++)e.morphTargetInfluences[i]=t.weights[i];if(t.extras&&Array.isArray(t.extras.targetNames)){const i=t.extras.targetNames;if(e.morphTargetInfluences.length===i.length){e.morphTargetDictionary={};for(let t=0,n=i.length;t<n;t++)e.morphTargetDictionary[i[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function createPrimitiveKey(e){let t;const i=e.extensions&&e.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];if(t=i?"draco:"+i.bufferView+":"+i.indices+":"+createAttributesKey(i.attributes):e.indices+":"+createAttributesKey(e.attributes)+":"+e.mode,void 0!==e.targets)for(let n=0,r=e.targets.length;n<r;n++)t+=":"+createAttributesKey(e.targets[n]);return t}function createAttributesKey(e){let t="";const i=Object.keys(e).sort();for(let n=0,r=i.length;n<r;n++)t+=i[n]+":"+e[i[n]]+";";return t}function getNormalizedComponentScale(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function getImageURIMimeType(e){return e.search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/)?"image/jpeg":e.search(/\.webp($|\?)/i)>0||0===e.search(/^data\:image\/webp/)?"image/webp":e.search(/\.ktx2($|\?)/i)>0||0===e.search(/^data\:image\/ktx2/)?"image/ktx2":"image/png"}const _identityMatrix=new three.Matrix4;class GLTFParser{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new GLTFRegistry,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let i=!1,n=-1,r=!1,s=-1;if("undefined"!=typeof navigator){const e=navigator.userAgent;i=!0===/^((?!chrome|android).)*safari/i.test(e);const t=e.match(/Version\/(\d+)/);n=i&&t?parseInt(t[1],10):-1,r=e.indexOf("Firefox")>-1,s=r?e.match(/Firefox\/([0-9]+)\./)[1]:-1}"undefined"==typeof createImageBitmap||i&&n<17||r&&s<98?this.textureLoader=new three.TextureLoader(this.options.manager):this.textureLoader=new three.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new three.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const i=this,n=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll((function(e){return e._markDefs&&e._markDefs()})),Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])})).then((function(t){const s={scene:t[0][n.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:n.asset,parser:i,userData:{}};return addUnknownExtensionsToUserData(r,s,n),assignExtrasToUserData(s,n),Promise.all(i._invokeAll((function(e){return e.afterRoot&&e.afterRoot(s)}))).then((function(){for(const e of s.scenes)e.updateMatrixWorld();e(s)}))})).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const i=t[n].joints;for(let t=0,n=i.length;t<n;t++)e[i[t]].isBone=!0}for(let n=0,r=e.length;n<r;n++){const t=e[n];void 0!==t.mesh&&(this._addNodeRef(this.meshCache,t.mesh),void 0!==t.skin&&(i[t.mesh].isSkinnedMesh=!0)),void 0!==t.camera&&this._addNodeRef(this.cameraCache,t.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;const n=i.clone(),r=(e,t)=>{const i=this.associations.get(e);null!=i&&this.associations.set(t,i);for(const[n,s]of e.children.entries())r(s,t.children[n])};return r(i,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const n=e(t[i]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const i=[];for(let n=0;n<t.length;n++){const r=e(t[n]);r&&i.push(r)}return i}getDependency(e,t){const i=e+":"+t;let n=this.cache.get(i);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne((function(e){return e.loadNode&&e.loadNode(t)}));break;case"mesh":n=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":n=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne((function(e){return e.loadAnimation&&e.loadAnimation(t)}));break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne((function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)})),!n)throw new Error("Unknown type: "+e)}this.cache.add(i,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const i=this,n=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(n.map((function(t,n){return i.getDependency(e,n)}))),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],i=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);const n=this.options;return new Promise((function(e,r){i.load(three.LoaderUtils.resolveURL(t.uri,n.path),e,void 0,(function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){const i=t.byteLength||0,n=t.byteOffset||0;return e.slice(n,n+i)}))}loadAccessor(e){const t=this,i=this.json,n=this.json.accessors[e];if(void 0===n.bufferView&&void 0===n.sparse){const e=WEBGL_TYPE_SIZES[n.type],t=WEBGL_COMPONENT_TYPES[n.componentType],i=!0===n.normalized,r=new t(n.count*e);return Promise.resolve(new three.BufferAttribute(r,e,i))}const r=[];return void 0!==n.bufferView?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),void 0!==n.sparse&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then((function(e){const r=e[0],s=WEBGL_TYPE_SIZES[n.type],a=WEBGL_COMPONENT_TYPES[n.componentType],o=a.BYTES_PER_ELEMENT,l=o*s,c=n.byteOffset||0,h=void 0!==n.bufferView?i.bufferViews[n.bufferView].byteStride:void 0,u=!0===n.normalized;let d,p;if(h&&h!==l){const e=Math.floor(c/h),i="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+e+":"+n.count;let l=t.cache.get(i);l||(d=new a(r,e*h,n.count*h/o),l=new three.InterleavedBuffer(d,h/o),t.cache.add(i,l)),p=new three.InterleavedBufferAttribute(l,s,c%h/o,u)}else d=null===r?new a(n.count*s):new a(r,c,n.count*s),p=new three.BufferAttribute(d,s,u);if(void 0!==n.sparse){const t=WEBGL_TYPE_SIZES.SCALAR,i=WEBGL_COMPONENT_TYPES[n.sparse.indices.componentType],o=n.sparse.indices.byteOffset||0,l=n.sparse.values.byteOffset||0,c=new i(e[1],o,n.sparse.count*t),h=new a(e[2],l,n.sparse.count*s);null!==r&&(p=new three.BufferAttribute(p.array.slice(),p.itemSize,p.normalized)),p.normalized=!1;for(let e=0,n=c.length;e<n;e++){const t=c[e];if(p.setX(t,h[e*s]),s>=2&&p.setY(t,h[e*s+1]),s>=3&&p.setZ(t,h[e*s+2]),s>=4&&p.setW(t,h[e*s+3]),s>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}p.normalized=u}return p}))}loadTexture(e){const t=this.json,i=this.options,n=t.textures[e].source,r=t.images[n];let s=this.textureLoader;if(r.uri){const e=i.manager.getHandler(r.uri);null!==e&&(s=e)}return this.loadTextureImage(e,n,s)}loadTextureImage(e,t,i){const n=this,r=this.json,s=r.textures[e],a=r.images[t],o=(a.uri||a.bufferView)+":"+s.sampler;if(this.textureCache[o])return this.textureCache[o];const l=this.loadImageSource(t,i).then((function(t){t.flipY=!1,t.name=s.name||a.name||"",""===t.name&&"string"==typeof a.uri&&!1===a.uri.startsWith("data:image/")&&(t.name=a.uri);const i=(r.samplers||{})[s.sampler]||{};return t.magFilter=WEBGL_FILTERS[i.magFilter]||three.LinearFilter,t.minFilter=WEBGL_FILTERS[i.minFilter]||three.LinearMipmapLinearFilter,t.wrapS=WEBGL_WRAPPINGS[i.wrapS]||three.RepeatWrapping,t.wrapT=WEBGL_WRAPPINGS[i.wrapT]||three.RepeatWrapping,t.generateMipmaps=!t.isCompressedTexture&&t.minFilter!==three.NearestFilter&&t.minFilter!==three.LinearFilter,n.associations.set(t,{textures:e}),t})).catch((function(){return null}));return this.textureCache[o]=l,l}loadImageSource(e,t){const i=this,n=this.json,r=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then((e=>e.clone()));const s=n.images[e],a=self.URL||self.webkitURL;let o=s.uri||"",l=!1;if(void 0!==s.bufferView)o=i.getDependency("bufferView",s.bufferView).then((function(e){l=!0;const t=new Blob([e],{type:s.mimeType});return o=a.createObjectURL(t),o}));else if(void 0===s.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const c=Promise.resolve(o).then((function(e){return new Promise((function(i,n){let s=i;!0===t.isImageBitmapLoader&&(s=function(e){const t=new three.Texture(e);t.needsUpdate=!0,i(t)}),t.load(three.LoaderUtils.resolveURL(e,r.path),s,void 0,n)}))})).then((function(e){return!0===l&&a.revokeObjectURL(o),assignExtrasToUserData(e,s),e.userData.mimeType=s.mimeType||getImageURIMimeType(s.uri),e})).catch((function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",o),e}));return this.sourceCache[e]=c,c}assignTexture(e,t,i,n){const r=this;return this.getDependency("texture",i.index).then((function(s){if(!s)return null;if(void 0!==i.texCoord&&i.texCoord>0&&((s=s.clone()).channel=i.texCoord),r.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){const e=void 0!==i.extensions?i.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=r.associations.get(s);s=r.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(s,e),r.associations.set(s,t)}}return void 0!==n&&(s.colorSpace=n),e[t]=s,s}))}assignFinalMaterial(e){const t=e.geometry;let i=e.material;const n=void 0===t.attributes.tangent,r=void 0!==t.attributes.color,s=void 0===t.attributes.normal;if(e.isPoints){const e="PointsMaterial:"+i.uuid;let t=this.cache.get(e);t||(t=new three.PointsMaterial,three.Material.prototype.copy.call(t,i),t.color.copy(i.color),t.map=i.map,t.sizeAttenuation=!1,this.cache.add(e,t)),i=t}else if(e.isLine){const e="LineBasicMaterial:"+i.uuid;let t=this.cache.get(e);t||(t=new three.LineBasicMaterial,three.Material.prototype.copy.call(t,i),t.color.copy(i.color),t.map=i.map,this.cache.add(e,t)),i=t}if(n||r||s){let e="ClonedMaterial:"+i.uuid+":";n&&(e+="derivative-tangents:"),r&&(e+="vertex-colors:"),s&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=i.clone(),r&&(t.vertexColors=!0),s&&(t.flatShading=!0),n&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(i))),i=t}e.material=i}getMaterialType(){return three.MeshStandardMaterial}loadMaterial(e){const t=this,i=this.json,n=this.extensions,r=i.materials[e];let s;const a={},o=[];if((r.extensions||{})[EXTENSIONS.KHR_MATERIALS_UNLIT]){const e=n[EXTENSIONS.KHR_MATERIALS_UNLIT];s=e.getMaterialType(),o.push(e.extendParams(a,r,t))}else{const i=r.pbrMetallicRoughness||{};if(a.color=new three.Color(1,1,1),a.opacity=1,Array.isArray(i.baseColorFactor)){const e=i.baseColorFactor;a.color.setRGB(e[0],e[1],e[2],three.LinearSRGBColorSpace),a.opacity=e[3]}void 0!==i.baseColorTexture&&o.push(t.assignTexture(a,"map",i.baseColorTexture,three.SRGBColorSpace)),a.metalness=void 0!==i.metallicFactor?i.metallicFactor:1,a.roughness=void 0!==i.roughnessFactor?i.roughnessFactor:1,void 0!==i.metallicRoughnessTexture&&(o.push(t.assignTexture(a,"metalnessMap",i.metallicRoughnessTexture)),o.push(t.assignTexture(a,"roughnessMap",i.metallicRoughnessTexture))),s=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),o.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,a)}))))}!0===r.doubleSided&&(a.side=three.DoubleSide);const l=r.alphaMode||ALPHA_MODES.OPAQUE;if(l===ALPHA_MODES.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,l===ALPHA_MODES.MASK&&(a.alphaTest=void 0!==r.alphaCutoff?r.alphaCutoff:.5)),void 0!==r.normalTexture&&s!==three.MeshBasicMaterial&&(o.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new three.Vector2(1,1),void 0!==r.normalTexture.scale)){const e=r.normalTexture.scale;a.normalScale.set(e,e)}if(void 0!==r.occlusionTexture&&s!==three.MeshBasicMaterial&&(o.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),void 0!==r.occlusionTexture.strength&&(a.aoMapIntensity=r.occlusionTexture.strength)),void 0!==r.emissiveFactor&&s!==three.MeshBasicMaterial){const e=r.emissiveFactor;a.emissive=(new three.Color).setRGB(e[0],e[1],e[2],three.LinearSRGBColorSpace)}return void 0!==r.emissiveTexture&&s!==three.MeshBasicMaterial&&o.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,three.SRGBColorSpace)),Promise.all(o).then((function(){const i=new s(a);return r.name&&(i.name=r.name),assignExtrasToUserData(i,r),t.associations.set(i,{materials:e}),r.extensions&&addUnknownExtensionsToUserData(n,i,r),i}))}createUniqueName(e){const t=three.PropertyBinding.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,i=this.extensions,n=this.primitiveCache;function r(e){return i[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(i){return addPrimitiveAttributes(i,e,t)}))}const s=[];for(let a=0,o=e.length;a<o;a++){const i=e[a],o=createPrimitiveKey(i),l=n[o];if(l)s.push(l.promise);else{let e;e=i.extensions&&i.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?r(i):addPrimitiveAttributes(new three.BufferGeometry,i,t),n[o]={primitive:i,promise:e},s.push(e)}}return Promise.all(s)}loadMesh(e){const t=this,i=this.json,n=this.extensions,r=i.meshes[e],s=r.primitives,a=[];for(let o=0,l=s.length;o<l;o++){const e=void 0===s[o].material?createDefaultMaterial(this.cache):this.getDependency("material",s[o].material);a.push(e)}return a.push(t.loadGeometries(s)),Promise.all(a).then((function(i){const a=i.slice(0,i.length-1),o=i[i.length-1],l=[];for(let h=0,u=o.length;h<u;h++){const i=o[h],c=s[h];let u;const d=a[h];if(c.mode===WEBGL_CONSTANTS.TRIANGLES||c.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP||c.mode===WEBGL_CONSTANTS.TRIANGLE_FAN||void 0===c.mode)u=!0===r.isSkinnedMesh?new three.SkinnedMesh(i,d):new three.Mesh(i,d),!0===u.isSkinnedMesh&&u.normalizeSkinWeights(),c.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP?u.geometry=toTrianglesDrawMode(u.geometry,three.TriangleStripDrawMode):c.mode===WEBGL_CONSTANTS.TRIANGLE_FAN&&(u.geometry=toTrianglesDrawMode(u.geometry,three.TriangleFanDrawMode));else if(c.mode===WEBGL_CONSTANTS.LINES)u=new three.LineSegments(i,d);else if(c.mode===WEBGL_CONSTANTS.LINE_STRIP)u=new three.Line(i,d);else if(c.mode===WEBGL_CONSTANTS.LINE_LOOP)u=new three.LineLoop(i,d);else{if(c.mode!==WEBGL_CONSTANTS.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+c.mode);u=new three.Points(i,d)}Object.keys(u.geometry.morphAttributes).length>0&&updateMorphTargets(u,r),u.name=t.createUniqueName(r.name||"mesh_"+e),assignExtrasToUserData(u,r),c.extensions&&addUnknownExtensionsToUserData(n,u,c),t.assignFinalMaterial(u),l.push(u)}for(let n=0,r=l.length;n<r;n++)t.associations.set(l[n],{meshes:e,primitives:n});if(1===l.length)return r.extensions&&addUnknownExtensionsToUserData(n,l[0],r),l[0];const c=new three.Group;r.extensions&&addUnknownExtensionsToUserData(n,c,r),t.associations.set(c,{meshes:e});for(let e=0,t=l.length;e<t;e++)c.add(l[e]);return c}))}loadCamera(e){let t;const i=this.json.cameras[e],n=i[i.type];if(n)return"perspective"===i.type?t=new three.PerspectiveCamera(three.MathUtils.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):"orthographic"===i.type&&(t=new three.OrthographicCamera(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),i.name&&(t.name=this.createUniqueName(i.name)),assignExtrasToUserData(t,i),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],i=[];for(let n=0,r=t.joints.length;n<r;n++)i.push(this._loadNodeShallow(t.joints[n]));return void 0!==t.inverseBindMatrices?i.push(this.getDependency("accessor",t.inverseBindMatrices)):i.push(null),Promise.all(i).then((function(e){const i=e.pop(),n=e,r=[],s=[];for(let a=0,o=n.length;a<o;a++){const e=n[a];if(e){r.push(e);const t=new three.Matrix4;null!==i&&t.fromArray(i.array,16*a),s.push(t)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[a])}return new three.Skeleton(r,s)}))}loadAnimation(e){const t=this.json,i=this,n=t.animations[e],r=n.name?n.name:"animation_"+e,s=[],a=[],o=[],l=[],c=[];for(let h=0,u=n.channels.length;h<u;h++){const e=n.channels[h],t=n.samplers[e.sampler],i=e.target,r=i.node,u=void 0!==n.parameters?n.parameters[t.input]:t.input,d=void 0!==n.parameters?n.parameters[t.output]:t.output;void 0!==i.node&&(s.push(this.getDependency("node",r)),a.push(this.getDependency("accessor",u)),o.push(this.getDependency("accessor",d)),l.push(t),c.push(i))}return Promise.all([Promise.all(s),Promise.all(a),Promise.all(o),Promise.all(l),Promise.all(c)]).then((function(e){const t=e[0],n=e[1],s=e[2],a=e[3],o=e[4],l=[];for(let r=0,c=t.length;r<c;r++){const e=t[r],c=n[r],h=s[r],u=a[r],d=o[r];if(void 0===e)continue;e.updateMatrix&&e.updateMatrix();const p=i._createAnimationTracks(e,c,h,u,d);if(p)for(let t=0;t<p.length;t++)l.push(p[t])}return new three.AnimationClip(r,void 0,l)}))}createNodeMesh(e){const t=this.json,i=this,n=t.nodes[e];return void 0===n.mesh?null:i.getDependency("mesh",n.mesh).then((function(e){const t=i._getNodeRef(i.meshCache,n.mesh,e);return void 0!==n.weights&&t.traverse((function(e){if(e.isMesh)for(let t=0,i=n.weights.length;t<i;t++)e.morphTargetInfluences[t]=n.weights[t]})),t}))}loadNode(e){const t=this,i=this.json.nodes[e],n=t._loadNodeShallow(e),r=[],s=i.children||[];for(let o=0,l=s.length;o<l;o++)r.push(t.getDependency("node",s[o]));const a=void 0===i.skin?Promise.resolve(null):t.getDependency("skin",i.skin);return Promise.all([n,Promise.all(r),a]).then((function(e){const t=e[0],i=e[1],n=e[2];null!==n&&t.traverse((function(e){e.isSkinnedMesh&&e.bind(n,_identityMatrix)}));for(let r=0,s=i.length;r<s;r++)t.add(i[r]);return t}))}_loadNodeShallow(e){const t=this.json,i=this.extensions,n=this;if(void 0!==this.nodeCache[e])return this.nodeCache[e];const r=t.nodes[e],s=r.name?n.createUniqueName(r.name):"",a=[],o=n._invokeOne((function(t){return t.createNodeMesh&&t.createNodeMesh(e)}));return o&&a.push(o),void 0!==r.camera&&a.push(n.getDependency("camera",r.camera).then((function(e){return n._getNodeRef(n.cameraCache,r.camera,e)}))),n._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){a.push(e)})),this.nodeCache[e]=Promise.all(a).then((function(t){let a;if(a=!0===r.isBone?new three.Bone:t.length>1?new three.Group:1===t.length?t[0]:new three.Object3D,a!==t[0])for(let e=0,i=t.length;e<i;e++)a.add(t[e]);if(r.name&&(a.userData.name=r.name,a.name=s),assignExtrasToUserData(a,r),r.extensions&&addUnknownExtensionsToUserData(i,a,r),void 0!==r.matrix){const e=new three.Matrix4;e.fromArray(r.matrix),a.applyMatrix4(e)}else void 0!==r.translation&&a.position.fromArray(r.translation),void 0!==r.rotation&&a.quaternion.fromArray(r.rotation),void 0!==r.scale&&a.scale.fromArray(r.scale);if(n.associations.has(a)){if(void 0!==r.mesh&&n.meshCache.refs[r.mesh]>1){const e=n.associations.get(a);n.associations.set(a,{...e})}}else n.associations.set(a,{});return n.associations.get(a).nodes=e,a})),this.nodeCache[e]}loadScene(e){const t=this.extensions,i=this.json.scenes[e],n=this,r=new three.Group;i.name&&(r.name=n.createUniqueName(i.name)),assignExtrasToUserData(r,i),i.extensions&&addUnknownExtensionsToUserData(t,r,i);const s=i.nodes||[],a=[];for(let o=0,l=s.length;o<l;o++)a.push(n.getDependency("node",s[o]));return Promise.all(a).then((function(e){for(let t=0,i=e.length;t<i;t++)r.add(e[t]);return n.associations=(e=>{const t=new Map;for(const[i,r]of n.associations)(i instanceof three.Material||i instanceof three.Texture)&&t.set(i,r);return e.traverse((e=>{const i=n.associations.get(e);null!=i&&t.set(e,i)})),t})(r),r}))}_createAnimationTracks(e,t,i,n,r){const s=[],a=e.name?e.name:e.uuid,o=[];let l;switch(PATH_PROPERTIES[r.path]===PATH_PROPERTIES.weights?e.traverse((function(e){e.morphTargetInfluences&&o.push(e.name?e.name:e.uuid)})):o.push(a),PATH_PROPERTIES[r.path]){case PATH_PROPERTIES.weights:l=three.NumberKeyframeTrack;break;case PATH_PROPERTIES.rotation:l=three.QuaternionKeyframeTrack;break;case PATH_PROPERTIES.translation:case PATH_PROPERTIES.scale:l=three.VectorKeyframeTrack;break;default:if(1===i.itemSize)l=three.NumberKeyframeTrack;else l=three.VectorKeyframeTrack}const c=void 0!==n.interpolation?INTERPOLATION[n.interpolation]:three.InterpolateLinear,h=this._getArrayFromAccessor(i);for(let u=0,d=o.length;u<d;u++){const e=new l(o[u]+"."+PATH_PROPERTIES[r.path],t.array,h,c);"CUBICSPLINE"===n.interpolation&&this._createCubicSplineTrackInterpolant(e),s.push(e)}return s}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const e=getNormalizedComponentScale(t.constructor),i=new Float32Array(t.length);for(let n=0,r=t.length;n<r;n++)i[n]=t[n]*e;t=i}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(e){return new(this instanceof three.QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant)(this.times,this.values,this.getValueSize()/3,e)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function computeBounds(e,t,i){const n=t.attributes,r=new three.Box3;if(void 0===n.POSITION)return;{const e=i.json.accessors[n.POSITION],t=e.min,s=e.max;if(void 0===t||void 0===s)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(r.set(new three.Vector3(t[0],t[1],t[2]),new three.Vector3(s[0],s[1],s[2])),e.normalized){const t=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[e.componentType]);r.min.multiplyScalar(t),r.max.multiplyScalar(t)}}const s=t.targets;if(void 0!==s){const e=new three.Vector3,t=new three.Vector3;for(let n=0,r=s.length;n<r;n++){const r=s[n];if(void 0!==r.POSITION){const n=i.json.accessors[r.POSITION],s=n.min,a=n.max;if(void 0!==s&&void 0!==a){if(t.setX(Math.max(Math.abs(s[0]),Math.abs(a[0]))),t.setY(Math.max(Math.abs(s[1]),Math.abs(a[1]))),t.setZ(Math.max(Math.abs(s[2]),Math.abs(a[2]))),n.normalized){const e=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[n.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}r.expandByVector(e)}e.boundingBox=r;const a=new three.Sphere;r.getCenter(a.center),a.radius=r.min.distanceTo(r.max)/2,e.boundingSphere=a}function addPrimitiveAttributes(e,t,i){const n=t.attributes,r=[];function s(t,n){return i.getDependency("accessor",t).then((function(t){e.setAttribute(n,t)}))}for(const a in n){const t=ATTRIBUTES[a]||a.toLowerCase();t in e.attributes||r.push(s(n[a],t))}if(void 0!==t.indices&&!e.index){const n=i.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));r.push(n)}return three.ColorManagement.workingColorSpace!==three.LinearSRGBColorSpace&&"COLOR_0"in n&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${three.ColorManagement.workingColorSpace}" not supported.`),assignExtrasToUserData(e,t),computeBounds(e,t,i),Promise.all(r).then((function(){return void 0!==t.targets?addMorphTargets(e,t.targets,i):e}))}class B3DMLoader extends B3DMLoaderBase{constructor(e=three.DefaultLoadingManager){super(),this.manager=e,this.adjustmentTransform=new three.Matrix4}parse(e){const t=super.parse(e),i=t.glbBytes.slice().buffer;return new Promise(((e,n)=>{const r=this.manager,s=this.fetchOptions,a=r.getHandler("path.gltf")||new GLTFLoader(r);"include"===s.credentials&&"cors"===s.mode&&a.setCrossOrigin("use-credentials"),"credentials"in s&&a.setWithCredentials("include"===s.credentials),s.headers&&a.setRequestHeader(s.headers);let o=this.workingPath;!/[\\/]$/.test(o)&&o.length&&(o+="/");const l=this.adjustmentTransform;a.parse(i,o,(i=>{const{batchTable:n,featureTable:r}=t,{scene:s}=i,a=r.getData("RTC_CENTER");a&&(s.position.x+=a[0],s.position.y+=a[1],s.position.z+=a[2]),i.scene.updateMatrix(),i.scene.matrix.multiply(l),i.scene.matrix.decompose(i.scene.position,i.scene.quaternion,i.scene.scale),i.batchTable=n,i.featureTable=r,s.batchTable=n,s.featureTable=r,e(i)}),n)}))}}class I3DMLoaderBase extends LoaderBase{parse(e){const t=new DataView(e),i=t.getUint32(4,!0);console.assert(1===i);const n=t.getUint32(8,!0);console.assert(n===e.byteLength);const r=t.getUint32(12,!0),s=t.getUint32(16,!0),a=t.getUint32(20,!0),o=t.getUint32(24,!0),l=t.getUint32(28,!0),c=e.slice(32,32+r+s),h=new FeatureTable(c,0,r,s),u=32+r+s,d=e.slice(u,u+a+o),p=new BatchTable(d,h.getData("INSTANCES_LENGTH"),0,a,o),m=u+a+o,f=new Uint8Array(e,m,n-m);let g=null,_=null;if(l)g=f,_=Promise.resolve();else{const e=this.resolveExternalURL(arrayToString(f));_=fetch(e,this.fetchOptions).then((t=>{if(!t.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${e}" with status ${t.status} : ${t.statusText}`);return t.arrayBuffer()})).then((e=>{g=new Uint8Array(e)}))}return _.then((()=>({version:i,featureTable:h,batchTable:p,glbBytes:g})))}}const tempFwd=new three.Vector3,tempUp=new three.Vector3,tempRight=new three.Vector3,tempPos=new three.Vector3,tempQuat=new three.Quaternion,tempSca=new three.Vector3,tempMat=new three.Matrix4;class I3DMLoader extends I3DMLoaderBase{constructor(e=three.DefaultLoadingManager){super(),this.manager=e,this.adjustmentTransform=new three.Matrix4}resolveExternalURL(e){return this.manager.resolveURL(super.resolveExternalURL(e))}parse(e){return super.parse(e).then((e=>{const{featureTable:t,batchTable:i}=e,n=e.glbBytes.slice().buffer;return new Promise(((e,r)=>{const s=this.fetchOptions,a=this.manager,o=a.getHandler("path.gltf")||new GLTFLoader(a);"include"===s.credentials&&"cors"===s.mode&&o.setCrossOrigin("use-credentials"),"credentials"in s&&o.setWithCredentials("include"===s.credentials),s.headers&&o.setRequestHeader(s.headers);let l=this.workingPath;/[\\/]$/.test(l)||(l+="/");const c=this.adjustmentTransform;o.parse(n,l,(n=>{const r=t.getData("INSTANCES_LENGTH"),s=t.getData("POSITION",r,"FLOAT","VEC3"),a=t.getData("NORMAL_UP",r,"FLOAT","VEC3"),o=t.getData("NORMAL_RIGHT",r,"FLOAT","VEC3"),l=t.getData("SCALE_NON_UNIFORM",r,"FLOAT","VEC3"),h=t.getData("SCALE",r,"FLOAT","SCALAR");["RTC_CENTER","QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","EAST_NORTH_UP","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach((e=>{e in t.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${e}" detected.`)}));const u=new Map,d=[];n.scene.traverse((e=>{if(e.isMesh){const{geometry:t,material:i}=e,n=new three.InstancedMesh(t,i,r);n.position.copy(e.position),n.rotation.copy(e.rotation),n.scale.copy(e.scale),d.push(n),u.set(e,n)}}));const p=new three.Vector3;for(let e=0;e<r;e++)p.x+=s[3*e+0]/r,p.y+=s[3*e+1]/r,p.z+=s[3*e+2]/r;u.forEach(((e,t)=>{const i=t.parent;i&&(i.remove(t),i.add(e),e.updateMatrixWorld(),e.position.copy(p).applyMatrix4(e.matrixWorld))}));for(let e=0;e<r;e++){tempPos.set(s[3*e+0]-p.x,s[3*e+1]-p.y,s[3*e+2]-p.z),a?(tempUp.set(a[3*e+0],a[3*e+1],a[3*e+2]),tempRight.set(o[3*e+0],o[3*e+1],o[3*e+2]),tempFwd.crossVectors(tempRight,tempUp).normalize(),tempMat.makeBasis(tempRight,tempUp,tempFwd),tempQuat.setFromRotationMatrix(tempMat)):tempQuat.set(0,0,0,1),h?tempSca.setScalar(h[e]):l?tempSca.set(l[3*e+0],l[3*e+1],l[3*e+2]):tempSca.set(1,1,1),tempMat.compose(tempPos,tempQuat,tempSca).multiply(c);for(let t=0,i=d.length;t<i;t++){d[t].setMatrixAt(e,tempMat)}}n.batchTable=i,n.featureTable=t,n.scene.batchTable=i,n.scene.featureTable=t,e(n)}),r)}))}))}}class PNTSLoaderBase extends LoaderBase{parse(e){const t=new DataView(e),i=t.getUint32(4,!0);console.assert(1===i);const n=t.getUint32(8,!0);console.assert(n===e.byteLength);const r=t.getUint32(12,!0),s=t.getUint32(16,!0),a=t.getUint32(20,!0),o=t.getUint32(24,!0),l=e.slice(28,28+r+s),c=new FeatureTable(l,0,r,s),h=28+r+s,u=e.slice(h,h+a+o),d=new BatchTable(u,c.getData("BATCH_LENGTH")||c.getData("POINTS_LENGTH"),0,a,o);return Promise.resolve({version:i,featureTable:c,batchTable:d})}}const DRACO_ATTRIBUTE_MAP={RGB:"color",POSITION:"position"};class PNTSLoader extends PNTSLoaderBase{constructor(e=three.DefaultLoadingManager){super(),this.manager=e}parse(e){return super.parse(e).then((async e=>{const{featureTable:t,batchTable:i}=e,n=new three.PointsMaterial,r=t.header.extensions,s=new three.Vector3;let a;if(r&&r["3DTILES_draco_point_compression"]){const{byteOffset:e,byteLength:i,properties:s}=r["3DTILES_draco_point_compression"],o=this.manager.getHandler("draco.drc");if(null==o)throw new Error("PNTSLoader: dracoLoader not available.");const l={};for(const t in s)if(t in DRACO_ATTRIBUTE_MAP&&t in s){l[DRACO_ATTRIBUTE_MAP[t]]=s[t]}const c={attributeIDs:l,attributeTypes:{position:"Float32Array",color:"Uint8Array"},useUniqueIDs:!0},h=t.getBuffer(e,i);a=await o.decodeGeometry(h,c),a.attributes.color&&(n.vertexColors=!0)}else{const e=t.getData("POINTS_LENGTH"),i=t.getData("POSITION",e,"FLOAT","VEC3"),r=t.getData("RGB",e,"UNSIGNED_BYTE","VEC3"),o=t.getData("RGBA",e,"UNSIGNED_BYTE","VEC4"),l=t.getData("RGB565",e,"UNSIGNED_SHORT","SCALAR"),c=t.getData("CONSTANT_RGBA",e,"UNSIGNED_BYTE","VEC4"),h=t.getData("POSITION_QUANTIZED",e,"UNSIGNED_SHORT","VEC3"),u=t.getData("QUANTIZED_VOLUME_SCALE",e,"FLOAT","VEC3"),d=t.getData("QUANTIZED_VOLUME_OFFSET",e,"FLOAT","VEC3");if(a=new three.BufferGeometry,h){const t=new Float32Array(3*e);for(let i=0;i<e;i++)for(let e=0;e<3;e++){const n=3*i+e;t[n]=h[n]/65535*u[e]}s.x=d[0],s.y=d[1],s.z=d[2],a.setAttribute("position",new three.BufferAttribute(t,3,!1))}else a.setAttribute("position",new three.BufferAttribute(i,3,!1));if(null!==o)a.setAttribute("color",new three.BufferAttribute(o,4,!0)),n.vertexColors=!0,n.transparent=!0,n.depthWrite=!1;else if(null!==r)a.setAttribute("color",new three.BufferAttribute(r,3,!0)),n.vertexColors=!0;else if(null!==l){const t=new Uint8Array(3*e);for(let i=0;i<e;i++){const e=rgb565torgb(l[i]);for(let n=0;n<3;n++){t[3*i+n]=e[n]}}a.setAttribute("color",new three.BufferAttribute(t,3,!0)),n.vertexColors=!0}else if(null!==c){const e=new three.Color(c[0],c[1],c[2]);n.color=e;const t=c[3]/255;t<1&&(n.opacity=t,n.transparent=!0,n.depthWrite=!1)}}["BATCH_LENGTH","NORMAL","NORMAL_OCT16P"].forEach((e=>{e in t.header&&console.warn(`PNTSLoader: Unsupported FeatureTable feature "${e}" detected.`)}));const o=new three.Points(a,n);o.position.copy(s),e.scene=o,e.scene.featureTable=t,e.scene.batchTable=i;const l=t.getData("RTC_CENTER");return l&&(e.scene.position.x+=l[0],e.scene.position.y+=l[1],e.scene.position.z+=l[2]),e}))}}function readMagicBytes(e){let t;if(t=e instanceof DataView?e:new DataView(e),"{"===String.fromCharCode(t.getUint8(0)))return null;let i="";for(let n=0;n<4;n++)i+=String.fromCharCode(t.getUint8(n));return i}class CMPTLoaderBase extends LoaderBase{parse(e){const t=new DataView(e),i=readMagicBytes(t);console.assert("cmpt"===i,'CMPTLoader: The magic bytes equal "cmpt".');const n=t.getUint32(4,!0);console.assert(1===n,'CMPTLoader: The version listed in the header is "1".');const r=t.getUint32(8,!0);console.assert(r===e.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const s=t.getUint32(12,!0),a=[];let o=16;for(let l=0;l<s;l++){const t=new DataView(e,o,12),i=readMagicBytes(t),n=t.getUint32(4,!0),r=t.getUint32(8,!0),s=new Uint8Array(e,o,r);a.push({type:i,buffer:s,version:n}),o+=r}return{version:n,tiles:a}}}class CMPTLoader extends CMPTLoaderBase{constructor(e=three.DefaultLoadingManager){super(),this.manager=e,this.adjustmentTransform=new three.Matrix4}parse(e){const t=super.parse(e),i=this.manager,n=this.adjustmentTransform,r=[];for(const s in t.tiles)if(t.tiles.hasOwnProperty(s)){const{type:e,buffer:a}=t.tiles[s];switch(e){case"b3dm":{const e=a.slice(),t=new B3DMLoader(i);t.workingPath=this.workingPath,t.fetchOptions=this.fetchOptions,t.adjustmentTransform.copy(n);const s=t.parse(e.buffer);r.push(s);break}case"pnts":{const e=a.slice(),t=new PNTSLoader(i);t.workingPath=this.workingPath,t.fetchOptions=this.fetchOptions;const n=t.parse(e.buffer);r.push(n);break}case"i3dm":{const e=a.slice(),t=new I3DMLoader(i);t.workingPath=this.workingPath,t.fetchOptions=this.fetchOptions,t.adjustmentTransform.copy(n);const s=t.parse(e.buffer);r.push(s);break}}}return Promise.all(r).then((e=>{const t=new three.Group;return e.forEach((e=>{t.add(e.scene)})),{tiles:e,scene:t}}))}}class GLTFExtensionLoader extends LoaderBase{constructor(e=three.DefaultLoadingManager){super(),this.manager=e}parse(e){return new Promise(((t,i)=>{const n=this.manager,r=this.fetchOptions;let s=n.getHandler("path.gltf")||n.getHandler("path.glb");s||(s=new GLTFLoader(n)),"include"===r.credentials&&"cors"===r.mode&&s.setCrossOrigin("use-credentials"),"credentials"in r&&s.setWithCredentials("include"===r.credentials),r.headers&&s.setRequestHeader(r.headers);let a=s.resourcePath||s.path||this.workingPath;!/[\\/]$/.test(a)&&a.length&&(a+="/"),s.parse(e,a,(e=>{t(e)}),i)}))}}const ImplicitSubdivisionScheme={QUADTREE:"QUADTREE",OCTREE:"OCTREE",getBranchingFactor:function(e){switch(e){case ImplicitSubdivisionScheme.OCTREE:return 8;case ImplicitSubdivisionScheme.QUADTREE:return 4;default:throw new Error("subdivisionScheme is not a valid value.")}}};class ImplicitAvailabilityBitstream{constructor(e){const t=e.lengthBits;let i=e.availableCount;const n=e.constant,r=e.bitstream;if(defined$2(n))i=t;else{const n=Math.ceil(t/8);if(r.length!==n)throw new Error(`Availability bitstream must be exactly ${n} bytes long to store ${t} bits.\n                    Actual bitstream was ${r.length} bytes long.`);const s=defaultValue$1(e.computeAvailableCountEnabled,!1);!defined$2(i)&&s&&(i=count1Bits(r,t))}this._lengthBits=t,this._availableCount=i,this._constant=n,this._bitstream=r}getBit(e){if(defined$2(this._constant))return this._constant;const t=e>>3,i=e%8;return 1==(this._bitstream[t]>>i&1)}get lengthBits(){return this._lengthBits}get availableCount(){return this._availableCount}}function count1Bits(e,t){let i=0;for(let n=0;n<t;n++){const t=n%8;i+=e[n>>3]>>t&1}return i}class ImplicitSubtreeMetadata{constructor(e){const t=(e=defaultValue$1(e,{})).subtreeMetadata,i=e.class,n=defined$2(t)?t.properties:{};this._class=i,this._properties=n,this._extras=t.extras,this._extensions=t.extensions}get class(){return this._class}get extras(){return this._extras}get extensions(){return this._extensions}hasProperty(e){return MetadataEntity.hasProperty(e,this._properties,this._class)}hasPropertyBySemantic(e){return MetadataEntity.hasPropertyBySemantic(e,this._properties,this._class)}getPropertyIds(e){return MetadataEntity.getPropertyIds(this._properties,this._class,e)}getProperty(e){return MetadataEntity.getProperty(e,this._properties,this._class)}setProperty(e,t){return MetadataEntity.setProperty(e,t,this._properties,this._class)}getPropertyBySemantic(e){return MetadataEntity.getPropertyBySemantic(e,this._properties,this._class)}setPropertyBySemantic(e,t){return MetadataEntity.setPropertyBySemantic(e,t,this._properties,this._class)}}function getExternalResourceCacheKey(e){return getAbsoluteUri(e.url)}class ResourceCacheKey{static getSchemaCacheKey(e){const{schema:t,resource:i}=e;return defined$2(t)?`embedded-schema:${JSON.stringify(t)}`:`external-schema:${getExternalResourceCacheKey(i)}`}}class ResourceLoader{unload(){}process(){return!1}isDestroyed(){return!1}destroy(){return this.unload(),destroyObject(this)}}const ResourceLoaderState={UNLOADED:0,LOADING:1,LOADED:2,PROCESSING:3,READY:4,FAILED:5},ResourceLoaderState$1=Object.freeze(ResourceLoaderState);class MetadataSchemaLoader extends ResourceLoader{constructor(e){super(e);const t=(e=defaultValue$1(e,{})).schema,i=e.resource,n=e.cacheKey;this._schema=defined$2(t)?MetadataSchema.fromJson(t):void 0,this._resource=i,this._cacheKey=n,this._state=ResourceLoaderState$1.UNLOADED,this._promise=void 0}load(){return defined$2(this._promise)?this._promise:defined$2(this._schema)?(this._promise=Promise.resolve(this),this._promise):(this._promise=loadExternalSchema(this),this._promise)}unload(){this._schema=void 0}get cacheKey(){return this._cacheKey}get schema(){return this._schema}}async function loadExternalSchema(e){const t=e._resource;e._state=ResourceLoaderState$1.LOADING;try{const i=await t.fetchJson();if(e.isDestroyed())return;return e._schema=MetadataSchema.fromJson(i),e._state=ResourceLoaderState$1.READY,e}catch(i){if(e.isDestroyed())return;e._state=ResourceLoaderState$1.FAILED;const n=`Failed to load schema: ${t.url}`;throw e.getError(n,i)}}class BufferLoader extends ResourceLoader{constructor(e){super();const t=(e=defaultValue$1(e,{})).typedArray,i=e.resource,n=e.cacheKey;this._typedArray=t,this._resource=i,this._cacheKey=n,this._state=ResourceLoaderState$1.UNLOADED,this._promise=void 0}get cacheKey(){return this._cacheKey}get typedArray(){return this._typedArray}async load(){return defined$2(this._promise)?this._promise:defined$2(this._typedArray)?(this._promise=Promise.resolve(this),this._promise):(this._promise=this.loadExternalBuffer(),this._promise)}unload(){this._typedArray=void 0}async loadExternalBuffer(){const e=this._resource;this._state=ResourceLoaderState$1.LOADING;try{const t=await BufferLoader._fetchArrayBuffer(e);if(this.isDestroyed())return;return this._typedArray=new Uint8Array(t),this._state=ResourceLoaderState$1.READY,this}catch(t){if(this.isDestroyed())return;this._state=ResourceLoaderState$1.FAILED;const i=`Failed to load external buffer: ${e.url}`;throw this.getError(i,t)}}static _fetchArrayBuffer(e){return e.fetchArrayBuffer()}}function CacheEntry(e){this.referenceCount=1,this.resourceLoader=e,this._statisticsPromise=void 0}const _ResourceCache=class{static get(e){const t=_ResourceCache.cacheEntries[e];if(defined$2(t))return++t.referenceCount,t.resourceLoader}static add(e){const t=e.cacheKey;return _ResourceCache.cacheEntries[t]=new CacheEntry(e),e}static unload(e){const t=e.cacheKey,i=_ResourceCache.cacheEntries[t];--i.referenceCount,0===i.referenceCount&&(e.destroy(),delete _ResourceCache.cacheEntries[t])}static getSchemaLoader(e){e=defaultValue$1(e,{});const{schema:t,resource:i}=e,n=ResourceCacheKey.getSchemaCacheKey({schema:t,resource:i});let r=_ResourceCache.get(n);return defined$2(r)?r:(r=new MetadataSchemaLoader({schema:t,resource:i,cacheKey:n}),_ResourceCache.add(r))}static getExternalBufferLoader(e){e=defaultValue$1(e,{});const{resource:t}=e,i=ResourceCacheKey.getExternalBufferCacheKey({resource:t});let n=_ResourceCache.get(i);return defined$2(n)?n:(n=new BufferLoader({resource:t,cacheKey:i}),_ResourceCache.add(n))}};let ResourceCache=_ResourceCache;__publicField(ResourceCache,"cacheEntries",{});class ImplicitMetadataView{constructor(e){const t=(e=defaultValue$1(e,{})).metadataTable,i=e.class,n=e.entityId,r=e.propertyTableJson;this._class=i,this._metadataTable=t,this._entityId=n,this._extensions=r.extensions,this._extras=r.extras}get class(){return this._class}get extras(){return this._extras}get extensions(){return this._extensions}hasProperty(e){return this._metadataTable.hasProperty(e)}hasPropertyBySemantic(e){return this._metadataTable.hasPropertyBySemantic(e)}getPropertyIds(e){return this._metadataTable.getPropertyIds(e)}getProperty(e){return this._metadataTable.getProperty(this._entityId,e)}setProperty(e,t){return this._metadataTable.setProperty(this._entityId,e,t)}getPropertyBySemantic(e){return this._metadataTable.getPropertyBySemantic(this._entityId,e)}setPropertyBySemantic(e,t){return this._metadataTable.setPropertyBySemantic(this._entityId,e,t)}}class ImplicitSubtree{constructor(e,t,i){this._resource=e,this._subtreeJson=void 0,this._bufferLoader=void 0,this._tileAvailability=void 0,this._contentAvailabilityBitstreams=[],this._childSubtreeAvailability=void 0,this._implicitCoordinates=i,this._subtreeLevels=t.subtreeLevels,this._subdivisionScheme=t.subdivisionScheme,this._branchingFactor=t.branchingFactor,this._metadata=void 0,this._tileMetadataTable=void 0,this._tilePropertyTableJson=void 0,this._contentMetadataTables=[],this._contentPropertyTableJsons=[],this._tileJumpBuffer=void 0,this._contentJumpBuffers=[],this._ready=!1}get ready(){return this._ready}get metadata(){return this._metadata}get tileMetadataTable(){return this._tileMetadataTable}get tilePropertyTableJson(){return this._tilePropertyTableJson}get contentMetadataTables(){return this._contentMetadataTables}get contentPropertyTableJsons(){return this._contentPropertyTableJsons}get implicitCoordinates(){return this._implicitCoordinates}tileIsAvailableAtIndex(e){return this._tileAvailability.getBit(e)}tileIsAvailableAtCoordinates(e){const t=this.getTileIndex(e);return this.tileIsAvailableAtIndex(t)}contentIsAvailableAtIndex(e,t){return t=defaultValue$1(t,0),this._contentAvailabilityBitstreams[t].getBit(e)}contentIsAvailableAtCoordinates(e,t){const i=this.getTileIndex(e);return this.contentIsAvailableAtIndex(i,t)}childSubtreeIsAvailableAtIndex(e){return this._childSubtreeAvailability.getBit(e)}childSubtreeIsAvailableAtCoordinates(e){const t=this.getChildSubtreeIndex(e);return this.childSubtreeIsAvailableAtIndex(t)}getLevelOffset(e){const t=this._branchingFactor;return(Math.pow(t,e)-1)/(t-1)}getParentMortonIndex(e){let t=2;return this._subdivisionScheme===ImplicitSubdivisionScheme.OCTREE&&(t=3),e>>t}getTileIndex(e){const t=e.level-this._implicitCoordinates.level;if(t<0||this._subtreeLevels<=t)throw new Error("level is out of bounds for this subtree");return e.getSubtreeCoordinates().getOffsetCoordinates(e).tileIndex}getChildSubtreeIndex(e){if(e.level-this._implicitCoordinates.level!==this._implicitCoordinates.subtreeLevels)throw new Error("level is out of bounds for this subtree");return e.getParentSubtreeCoordinates().getOffsetCoordinates(e).mortonIndex}getTileMetadataView(e){const t=getTileEntityId(this,e);if(!defined$2(t))return;const i=this._tileMetadataTable;return new ImplicitMetadataView({class:i.class,metadataTable:i,entityId:t,propertyTableJson:this._tilePropertyTableJson})}getContentMetadataView(e,t){const i=getContentEntityId(this,e,t);if(!defined$2(i))return;const n=this._contentMetadataTables[t],r=this._contentPropertyTableJsons[t];return new ImplicitMetadataView({class:n.class,metadataTable:n,entityId:i,contentIndex:t,propertyTableJson:r})}isDestroyed(){return!1}destroy(){return defined$2(this._bufferLoader)&&ResourceCache.unload(this._bufferLoader),destroyObject(this)}static async fromSubtreeJson(e,t,i,n,r){const s=new ImplicitSubtree(e,n,r);let a;a=defined$2(t)?{json:t,binary:void 0}:parseSubtreeChunks(i);const o=a.json;let l;if(s._subtreeJson=o,hasExtension(o,"3DTILES_metadata"))l=o.extensions["3DTILES_metadata"];else if(defined$2(o.tileMetadata)){const e=o.tileMetadata;l=o.propertyTables[e]}const c=[];if(defined$2(o.contentMetadata)){const e=o.contentMetadata.length;for(let t=0;t<e;t++){const e=o.contentMetadata[t];c.push(o.propertyTables[e])}}let h;const u=n.metadataSchema,d=o.subtreeMetadata;if(defined$2(d)){const e=d.class,t=u.classes[e];h=new ImplicitSubtreeMetadata({subtreeMetadata:d,class:t})}s._metadata=h,s._tilePropertyTableJson=l,s._contentPropertyTableJsons=c;const p={constant:0};o.contentAvailabilityHeaders=[],hasExtension(o,"3DTILES_multiple_contents")?o.contentAvailabilityHeaders=o.extensions["3DTILES_multiple_contents"].contentAvailability:Array.isArray(o.contentAvailability)?o.contentAvailabilityHeaders=o.contentAvailability:o.contentAvailabilityHeaders.push(defaultValue$1(o.contentAvailability,p));const m=preprocessBuffers(o.buffers),f=preprocessBufferViews(o.bufferViews,m);markActiveBufferViews(o,f),defined$2(l)&&markActiveMetadataBufferViews(l,f);for(let g=0;g<c.length;g++){markActiveMetadataBufferViews(c[g],f)}return parseAvailability(s,o,n,parseActiveBufferViews(f,await requestActiveBuffers(s,m,a.binary))),defined$2(l)&&(parseTileMetadataTable(s,n),makeTileJumpBuffer(s)),parseContentMetadataTables(s,n),makeContentJumpBuffers(s),s._ready=!0,s}}function parseSubtreeChunks(e){const t=!0,i=new DataView(e.buffer,e.byteOffset);let n=8;const r=i.getUint32(n,t);n+=8;const s=i.getUint32(n,t);n+=8;const a=getJsonFromTypedArray$2(e,n,r);n+=r;return{json:a,binary:e.subarray(n,n+s)}}function preprocessBuffers(e){e=defined$2(e)?e:[];for(let t=0;t<e.length;t++){const i=e[t];i.isExternal=defined$2(i.uri),i.isActive=!1}return e}function preprocessBufferViews(e,t){e=defined$2(e)?e:[];for(let i=0;i<e.length;i++){const n=e[i],r=t[n.buffer];n.bufferHeader=r,n.isActive=!1}return e}function markActiveBufferViews(e,t){let i;const n=e.tileAvailability;defined$2(n.bitstream)?i=t[n.bitstream]:defined$2(n.bufferView)&&(i=t[n.bufferView]),defined$2(i)&&(i.isActive=!0,i.bufferHeader.isActive=!0);const r=e.contentAvailabilityHeaders;for(let a=0;a<r.length;a++)i=void 0,defined$2(r[a].bitstream)?i=t[r[a].bitstream]:defined$2(r[a].bufferView)&&(i=t[r[a].bufferView]),defined$2(i)&&(i.isActive=!0,i.bufferHeader.isActive=!0);i=void 0;const s=e.childSubtreeAvailability;defined$2(s.bitstream)?i=t[s.bitstream]:defined$2(s.bufferView)&&(i=t[s.bufferView]),defined$2(i)&&(i.isActive=!0,i.bufferHeader.isActive=!0)}function markActiveMetadataBufferViews(e,t){const i=e.properties;let n;for(const r in i)if(i.hasOwnProperty(r)){const e=i[r];n=t[defaultValue$1(e.values,e.bufferView)],n.isActive=!0,n.bufferHeader.isActive=!0;const s=defaultValue$1(e.stringOffsets,e.stringOffsetBufferView);defined$2(s)&&(n=t[s],n.isActive=!0,n.bufferHeader.isActive=!0);const a=defaultValue$1(e.arrayOffsets,e.arrayOffsetBufferView);defined$2(a)&&(n=t[a],n.isActive=!0,n.bufferHeader.isActive=!0)}}function requestActiveBuffers(e,t,i){const n=[];for(let r=0;r<t.length;r++){const s=t[r];if(s.isActive)if(s.isExternal){const t=requestExternalBuffer(e,s);n.push(t)}else n.push(Promise.resolve(i));else n.push(Promise.resolve(void 0))}return Promise.all(n).then((function(e){const t={};for(let i=0;i<e.length;i++){const n=e[i];defined$2(n)&&(t[i]=n)}return t}))}async function requestExternalBuffer(e,t){const i=e._resource.getDerivedResource({url:t.uri}),n=ResourceCache.getExternalBufferLoader({resource:i});e._bufferLoader=n;try{await n.load()}catch(r){if(n.isDestroyed())return;throw r}return n.typedArray}function parseActiveBufferViews(e,t){const i={};for(let n=0;n<e.length;n++){const r=e[n];if(!r.isActive)continue;const s=r.byteOffset,a=s+r.byteLength,o=t[r.buffer].subarray(s,a);i[n]=o}return i}function parseAvailability(e,t,i,n){const r=i.branchingFactor,s=i.subtreeLevels,a=(Math.pow(r,s)-1)/(r-1),o=Math.pow(r,s),l=hasExtension(t,"3DTILES_metadata"),c=defined$2(e._tilePropertyTableJson);let h=l||c;e._tileAvailability=parseAvailabilityBitstream(t.tileAvailability,n,a,h);const u=e._contentPropertyTableJsons.length>0;h=h||u;for(let d=0;d<t.contentAvailabilityHeaders.length;d++){const i=parseAvailabilityBitstream(t.contentAvailabilityHeaders[d],n,a,h);e._contentAvailabilityBitstreams.push(i)}e._childSubtreeAvailability=parseAvailabilityBitstream(t.childSubtreeAvailability,n,o)}function parseAvailabilityBitstream(e,t,i,n){if(defined$2(e.constant))return new ImplicitAvailabilityBitstream({constant:Boolean(e.constant),lengthBits:i,availableCount:e.availableCount});let r;return defined$2(e.bitstream)?r=t[e.bitstream]:defined$2(e.bufferView)&&(r=t[e.bufferView]),new ImplicitAvailabilityBitstream({bitstream:r,lengthBits:i,availableCount:e.availableCount,computeAvailableCountEnabled:n})}function parseTileMetadataTable(e,t,i){const n=e._tilePropertyTableJson;e._tileAvailability.availableCount;const r=t.metadataSchema,s=n.class;r.classes[s]}function parseContentMetadataTables(e,t,i){const n=e._contentPropertyTableJsons,r=e._contentAvailabilityBitstreams,s=t.metadataSchema;e._contentMetadataTables;for(let a=0;a<n.length;a++){const e=n[a];r[a].availableCount;const t=e.class;s.classes[t]}}function makeJumpBuffer(e){let t=0;const i=e.lengthBits,n=e.availableCount;let r;r=n<256?new Uint8Array(i):n<65536?new Uint16Array(i):new Uint32Array(i);for(let s=0;s<e.lengthBits;s++)e.getBit(s)&&(r[s]=t,t++);return r}function makeTileJumpBuffer(e){const t=makeJumpBuffer(e._tileAvailability);e._tileJumpBuffer=t}function makeContentJumpBuffers(e){const t=e._contentJumpBuffers,i=e._contentAvailabilityBitstreams;for(let n=0;n<i.length;n++){const e=makeJumpBuffer(i[n]);t.push(e)}}function getTileEntityId(e,t){if(!defined$2(e._tileMetadataTable))return;const i=e.getTileIndex(t);return e._tileAvailability.getBit(i)?e._tileJumpBuffer[i]:void 0}function getContentEntityId(e,t,i){const n=e._contentMetadataTables;if(!defined$2(n))return;if(!defined$2(n[i]))return;const r=e._contentAvailabilityBitstreams[i],s=e.getTileIndex(t);if(r.getBit(s)){return e._contentJumpBuffers[i][s]}}const MetadataSemantic={ID:"ID",NAME:"NAME",DESCRIPTION:"DESCRIPTION",TILESET_TILE_COUNT:"TILESET_TILE_COUNT",TILE_BOUNDING_BOX:"TILE_BOUNDING_BOX",TILE_BOUNDING_REGION:"TILE_BOUNDING_REGION",TILE_BOUNDING_SPHERE:"TILE_BOUNDING_SPHERE",TILE_MINIMUM_HEIGHT:"TILE_MINIMUM_HEIGHT",TILE_MAXIMUM_HEIGHT:"TILE_MAXIMUM_HEIGHT",TILE_HORIZON_OCCLUSION_POINT:"TILE_HORIZON_OCCLUSION_POINT",TILE_GEOMETRIC_ERROR:"TILE_GEOMETRIC_ERROR",CONTENT_BOUNDING_BOX:"CONTENT_BOUNDING_BOX",CONTENT_BOUNDING_REGION:"CONTENT_BOUNDING_REGION",CONTENT_BOUNDING_SPHERE:"CONTENT_BOUNDING_SPHERE",CONTENT_MINIMUM_HEIGHT:"CONTENT_MINIMUM_HEIGHT",CONTENT_MAXIMUM_HEIGHT:"CONTENT_MAXIMUM_HEIGHT",CONTENT_HORIZON_OCCLUSION_POINT:"CONTENT_HORIZON_OCCLUSION_POINT"},MetadataSemantic$1=Object.freeze(MetadataSemantic);class Implicit3DTileContent{constructor(e,t,i){const n=t.implicitTileset,r=t.implicitCoordinates;this._implicitTileset=n,this._implicitCoordinates=r,this._implicitSubtree=void 0,this._tileset=e,this._tile=t,this._resource=i,this._metadata=void 0,this.featurePropertiesDirty=!1,this._group=void 0;const s=r.getTemplateValues(),a=n.subtreeUriTemplate.getDerivedResource({templateValues:s});this._url=a.getUrlComponent(!0),this._ready=!1}hasProperty(e,t){return!1}getFeature(e){}applyDebugSettings(e,t){}update(e,t){}pick(e,t,i){}isDestroyed(){return!1}destroy(){return this._implicitSubtree=this._implicitSubtree&&this._implicitSubtree.destroy(),destroyObject(this)}get featuresLength(){return 0}get pointsLength(){return 0}get trianglesLength(){return 0}get geometryByteLength(){return 0}get texturesByteLength(){return 0}get batchTableByteLength(){return 0}get innerContents(){}get ready(){return this._ready}get tileset(){return this._tileset}get tile(){return this._tile}get url(){return this._url}get metadata(){}get batchTable(){}get group(){return this._group}set group(e){this._group=e}static async fromSubtreeJson(e,t,i,n,r,s){let a;s=defaultValue$1(s,0),defined$2(r)&&(a=new Uint8Array(r,s));const o=t.implicitTileset,l=t.implicitCoordinates,c=await ImplicitSubtree.fromSubtreeJson(i,n,a,o,l),h=new Implicit3DTileContent(e,t,i);return h._implicitSubtree=c,expandSubtree(h,c),h._ready=!0,h}}function expandSubtree(e,t){const i=e._tile,n=transcodeSubtreeTiles(e,t,i,e._implicitCoordinates.childIndex),r=e._tileset.statistics;i.children.push(n.rootTile),r.numberOfTilesTotal++;const s=listChildSubtrees(e,t,n.bottomRow);for(let a=0;a<s.length;a++){const t=s[a],i=t.tile,n=makePlaceholderChildSubtree(e,i,t.childIndex);i.children.push(n),r.numberOfTilesTotal++}}function listChildSubtrees(e,t,i){const n=[],r=e._implicitTileset.branchingFactor;for(let s=0;s<i.length;s++){const e=i[s];if(defined$2(e))for(let i=0;i<r;i++){const a=s*r+i;t.childSubtreeIsAvailableAtIndex(a)&&n.push({tile:e,childIndex:i})}}return n}function transcodeSubtreeTiles(e,t,i,n){const r=deriveChildTile(e,t,i,n,0,!0),s=e._tileset.statistics;let a=[r],o=[];const l=e._implicitTileset;for(let c=1;c<l.subtreeLevels;c++){const i=t.getLevelOffset(c),n=l.branchingFactor*a.length;for(let r=0;r<n;r++){const n=i+r;if(!t.tileIsAvailableAtIndex(n)){o.push(void 0);continue}const c=a[t.getParentMortonIndex(r)],h=deriveChildTile(e,t,c,r%l.branchingFactor,n);c.children.push(h),s.numberOfTilesTotal++,o.push(h)}a=o,o=[]}return{rootTile:r,bottomRow:a}}function getGeometricError(e,t,i){const n=MetadataSemantic$1.TILE_GEOMETRIC_ERROR;return defined$2(e)&&e.hasPropertyBySemantic(n)?e.getPropertyBySemantic(n):t.geometricError/Math.pow(2,i.level)}function deriveChildTile(e,t,i,n,r,s){const a=e._implicitTileset;let o,l;o=defaultValue$1(s,!1)?i.implicitCoordinates:i.implicitCoordinates.getChildCoordinates(n),defined$2(t.tilePropertyTableJson)&&(l=t.getTileMetadataView(o));const c=t.contentPropertyTableJsons.length;let h=!1;for(let A=0;A<c;A++)if(t.contentIsAvailableAtCoordinates(o,A)){h=!0;break}const u=getTileBoundingVolume(a,o,n,s,i,undefined),d=[];for(let A=0;A<a.contentCount;A++){if(!t.contentIsAvailableAtIndex(r,A))continue;const e={uri:a.contentUriTemplates[A].getDerivedResource({templateValues:o.getTemplateValues()}).url},i=getContentBoundingVolume(u,undefined);defined$2(i)&&(e.boundingVolume=i),d.push(combine$1(e,a.contentHeaders[A]))}const p={boundingVolume:u,geometricError:getGeometricError(l,a,o),refine:a.refine,contents:d},m=!0,f=clone$2(a.tileHeader,m);delete f.boundingVolume,delete f.transform,delete f.metadata;const g=combine$1(p,f,m),_=makeTile$1(e,a.baseResource,g,i);return _.implicitCoordinates=o,_.implicitSubtree=t,_.metadata=l,_.hasImplicitContentMetadata=h,_}function canUpdateHeights(e,t){return defined$2(e)&&defined$2(t)&&(defined$2(t.minimumHeight)||defined$2(t.maximumHeight))&&(hasExtension(e,"3DTILES_bounding_volume_S2")||defined$2(e.region))}function updateHeights(e,t){defined$2(t)&&(hasExtension(e,"3DTILES_bounding_volume_S2")?updateS2CellHeights(e.extensions["3DTILES_bounding_volume_S2"],t.minimumHeight,t.maximumHeight):defined$2(e.region)&&updateRegionHeights(e.region,t.minimumHeight,t.maximumHeight))}function updateRegionHeights(e,t,i){defined$2(t)&&(e[4]=t),defined$2(i)&&(e[5]=i)}function updateS2CellHeights(e,t,i){defined$2(t)&&(e.minimumHeight=t),defined$2(i)&&(e.maximumHeight=i)}function getTileBoundingVolume(e,t,i,n,r,s){let a;return a=!defined$2(s)||!defined$2(s.boundingVolume)||!canUpdateHeights(s.boundingVolume,s)&&canUpdateHeights(e.boundingVolume,s)?deriveBoundingVolume(e,t,i,defaultValue$1(n,!1),r):s.boundingVolume,updateHeights(a,s),a}function getContentBoundingVolume(e,t){let i;return defined$2(t)&&(i=t.boundingVolume),canUpdateHeights(i,t)?updateHeights(i,t):canUpdateHeights(e,t)&&(i=clone$2(e,!0),updateHeights(i,t)),i}function deriveBoundingVolume(e,t,i,n,r){const s=e.boundingVolume;if(hasExtension(s,"3DTILES_bounding_volume_S2"))return deriveBoundingVolumeS2(n,r,i,t.level,t.x,t.y,t.z);if(defined$2(s.region)){return{region:deriveBoundingRegion(s.region,t.level,t.x,t.y,t.z)}}return{box:deriveBoundingBox(s.box,t.level,t.x,t.y,t.z)}}function deriveBoundingVolumeS2(e,t,i,n,r,s,a){}const scratchScaleFactors=new three.Vector3,scratchRootCenter=new three.Vector3,scratchCenter$1=new three.Vector3,scratchHalfAxes=new three.Matrix3;function deriveBoundingBox(e,t,i,n,r){if(0===t)return e;const s=scratchRootCenter.fromArray(e,0),a=scratchHalfAxes.fromArray(e,3),o=Math.pow(2,-t),l=(2*i+1)*o-1,c=(2*n+1)*o-1;let h=0;const u=scratchScaleFactors.set(o,o,1);defined$2(r)&&(h=(2*r+1)*o-1,u.z=o);let d=scratchCenter$1.set(l,c,h);d=scratchCenter$1.applyMatrix3(a),d=scratchCenter$1.addVectors(d,s);let p=(new three.Matrix3).copy(a);StaticMatrix3.multiplyByScale(p,u,p);const m=new Array(12);return d.toArray(m),p.toArray(m,3),m}const scratchRectangle=new Rectangle;function deriveBoundingRegion(e,t,i,n,r){if(0===t)return e.slice();const s=Rectangle.unpack(e,0,scratchRectangle),a=e[4],o=e[5],l=Math.pow(2,-t),c=l*s.width,h=CesiumMath.negativePiToPi(s.west+i*c),u=CesiumMath.negativePiToPi(h+c),d=l*s.height,p=CesiumMath.negativePiToPi(s.south+n*d),m=CesiumMath.negativePiToPi(p+d);let f=a,g=o;if(defined$2(r)){const e=l*(o-a);f+=r*e,g=f+e}return[h,p,u,m,f,g]}function makePlaceholderChildSubtree(e,t,i){const n=e._implicitTileset,r=t.implicitCoordinates.getChildCoordinates(i),s=deriveBoundingVolume(n,r,i,!1,t),a=getGeometricError(void 0,n,r),o=n.subtreeUriTemplate.getDerivedResource({templateValues:r.getTemplateValues()}).url,l={boundingVolume:s,geometricError:a,refine:n.refine,contents:[{uri:o}]},c=makeTile$1(e,n.baseResource,l,t);return c.implicitTileset=n,c.implicitCoordinates=r,c}function makeTile$1(e,t,i,n){return new(0,e._tile.constructor)(e._tileset,t,i,n)}const INITIAL_FRUSTUM_CULLED=Symbol("INITIAL_FRUSTUM_CULLED");function updateFrustumCulled(e,t){e.traverse((e=>{e.frustumCulled=e[INITIAL_FRUSTUM_CULLED]&&t}))}class Mesh3DTileContent{constructor(e){__publicField(this,"byteSize",0),this.scene=e.scene,this.asset=defaultValue$1(e.asset,{}),this.parser=e.parser,this.animations=defaultValue$1(e.animations,[]),this.batchTable=defaultValue$1(e.batchTable,{}),this.featureTable=defaultValue$1(e.featureTable,{}),this.userData=defaultValue$1(e.userData,{}),this.metadata=defaultValue$1(e.metadata,{}),this.group=defaultValue$1(e.group,{}),this.tile=e.tile,this.type=defaultValue$1(e.type,"gltf")}static fromJson(e){return e=defaultValue$1(e,{}),new Mesh3DTileContent(e)}traverse(e){const t=this.scene;t&&t.traverse(e)}dispose(){const e=this.scene,t=this.tile.tileset.materialManager;let i=[];if(t){const e=t._materrialMap.values();i=Array.from(e)}if(e){const t=[],n=[],r=[];this.traverse((e=>{e.geometry&&n.push(e.geometry),e.material&&t.push(e.material),e.userData.meshFeatures&&e.userData.meshFeatures.dispose(),e.userData.structuralMetadata&&e.userData.structuralMetadata.dispose()}));for(let e=0,i=n.length;e<i;e++)n[e].dispose();for(let e=0,s=t.length;e<s;e++){const n=t[e];if(!i.includes(n)){for(const e in n)if(n.hasOwnProperty(e)){const t=n[e];t&&t.isTexture&&r.push(t)}t[e].dispose()}}for(let e=0,i=r.length;e<i;e++){const t=r[e];t.image instanceof ImageBitmap&&t.image.close(),t.dispose()}e.removeFromParent()}}update(e){const t=e.tileset,i=this.scene,n=t.gltfUpMatrix;t.optimizeRaycast,i.updateMatrix(),"gltf"!==this.type&&"glb"!==this.type||i.matrix.multiply(n),i.matrix.premultiply(e.computedTransform),i.matrix.decompose(i.position,i.quaternion,i.scale),i.traverse((t=>{t[INITIAL_FRUSTUM_CULLED]=t.frustumCulled,t.isMesh&&(t.content=this,t.tile=e)})),updateFrustumCulled(i,!1)}}const Cesium3DTileContentFactory={externalTileset:function(e,t,i,n){return Tileset3DTileContent.fromJson(e,t,i,n)},b3dm:async function(e,t,i,n){const r=e._manager,s=i.url.split(/[\\/]/g);s.pop();const a=s.join("/"),o=new B3DMLoader(r),l=e.gltfUpMatrix;o.adjustmentTransform.copy(l),o.workingPath=a;const c=o.parse(n),h=await c;return h.type="b3dm",h.tile=t,Mesh3DTileContent.fromJson(h)},pnts:async function(e,t,i,n){const r=e._manager,s=i.url.split(/[\\/]/g);s.pop();const a=s.join("/"),o=new PNTSLoader(r);o.workingPath=a;const l=o.parse(n),c=await l;return c.type="pnts",c.tile=t,Mesh3DTileContent.fromJson(c)},i3dm:async function(e,t,i,n){const r=e._manager,s=i.url.split(/[\\/]/g);s.pop();const a=s.join("/"),o=new I3DMLoader(r),l=e.gltfUpMatrix;o.adjustmentTransform.copy(l),o.workingPath=a;const c=o.parse(n),h=await c;return h.type="i3dm",h.tile=t,Mesh3DTileContent.fromJson(h)},cmpt:async function(e,t,i,n){const r=e._manager,s=i.url.split(/[\\/]/g);s.pop();const a=s.join("/"),o=new CMPTLoader(r),l=e.gltfUpMatrix;o.adjustmentTransform.copy(l),o.workingPath=a;const c=o.parse(n),h=await c;return h.type="cmpt",h.tile=t,Mesh3DTileContent.fromJson(h)},gltf:async function(e,t,i,n){const r=e._manager,s=i.url.split(/[\\/]/g);s.pop();const a=s.join("/"),o=new GLTFExtensionLoader(r);o.workingPath=a;const l=o.parse(n),c=await l;return c.type="gltf",c.tile=t,Mesh3DTileContent.fromJson(c)},glb:async function(e,t,i,n){const r=e._manager,s=i.url.split(/[\\/]/g);s.pop();const a=s.join("/"),o=new GLTFExtensionLoader(r);o.workingPath=a;const l=o.parse(n),c=await l;return c.type="glb",c.tile=t,Mesh3DTileContent.fromJson(c)},subt:function(e,t,i,n,r){return Implicit3DTileContent.fromSubtreeJson(e,t,i,void 0,n,r)},subtreeJson:function(e,t,i,n){return Implicit3DTileContent.fromSubtreeJson(e,t,i,n)}},_worldMin=new three.Vector3,_worldMax=new three.Vector3,_norm$1=new three.Vector3,_ray=new three.Ray;class OBB{constructor(e=new three.Box3,t=new three.Matrix4){this.box=e.clone(),this.absoluteBox=e.clone(),this.transform=t.clone(),this.inverseTransform=new three.Matrix4,this.points=new Array(8).fill().map((()=>new three.Vector3)),this.planes=new Array(6).fill().map((()=>new three.Plane))}clampPoint(e,t){return t.copy(e).applyMatrix4(this.inverseTransform).clamp(this.box.min,this.box.max).applyMatrix4(this.transform)}distanceToPoint(e){return this.clampPoint(e,_norm$1).distanceTo(e)}containsPoint(e){return _norm$1.copy(e).applyMatrix4(this.inverseTransform),this.box.containsPoint(_norm$1)}intersectsRay(e){return _ray.copy(e).applyMatrix4(this.inverseTransform),_ray.intersectsBox(this.box)}intersectRay(e,t){return _ray.copy(e).applyMatrix4(this.inverseTransform),_ray.intersectBox(this.box,t)?(t.applyMatrix4(this.transform),t):null}update(){const{points:e,inverseTransform:t,transform:i,box:n}=this;t.copy(i).invert();const{min:r,max:s}=n;let a=0;for(let o=-1;o<=1;o+=2)for(let t=-1;t<=1;t+=2)for(let n=-1;n<=1;n+=2)e[a].set(o<0?r.x:s.x,t<0?r.y:s.y,n<0?r.z:s.z).applyMatrix4(i),a++;this.updatePlanes()}updatePlanes(){_worldMin.copy(this.box.min).applyMatrix4(this.transform),_worldMax.copy(this.box.max).applyMatrix4(this.transform),_norm$1.set(0,0,1).transformDirection(this.transform),this.planes[0].setFromNormalAndCoplanarPoint(_norm$1,_worldMin),this.planes[1].setFromNormalAndCoplanarPoint(_norm$1,_worldMax).negate(),_norm$1.set(0,1,0).transformDirection(this.transform),this.planes[2].setFromNormalAndCoplanarPoint(_norm$1,_worldMin),this.planes[3].setFromNormalAndCoplanarPoint(_norm$1,_worldMax).negate(),_norm$1.set(1,0,0).transformDirection(this.transform),this.planes[4].setFromNormalAndCoplanarPoint(_norm$1,_worldMin),this.planes[5].setFromNormalAndCoplanarPoint(_norm$1,_worldMax).negate()}intersectsFrustum(e){const{points:t}=this,{planes:i}=e;for(let n=0;n<6;n++){const e=i[n];let r=-1/0;for(let i=0;i<8;i++){const n=t[i],s=e.distanceToPoint(n);r=r<s?s:r}if(r<0)return!1}for(let n=0;n<6;n++){const t=this.planes[n];let i=-1/0;for(let n=0;n<8;n++){const r=e.points[n],s=t.distanceToPoint(r);i=i<s?s:i}if(i<0)return!1}return!0}}const PI=Math.PI,HALF_PI=PI/2,_orthoX=new three.Vector3,_orthoY=new three.Vector3,_orthoZ=new three.Vector3,_invMatrix=new three.Matrix4,_tempCartographic=new three.Vector3,_position=new three.Vector3;new three.Matrix4;let _poolIndex=0;const _pointsPool=[];function getVector(e=!1){return e?(_pointsPool[_poolIndex]||(_pointsPool[_poolIndex]=new three.Vector3),_poolIndex++,_pointsPool[_poolIndex-1]):new three.Vector3}function resetPool(){_poolIndex=0}class EllipsoidRegion extends Ellipsoid{constructor(e,t,i,n=-HALF_PI,r=HALF_PI,s=0,a=2*PI,o=0,l=0){super(e,t,i),this.latStart=n,this.latEnd=r,this.lonStart=s,this.lonEnd=a,this.heightStart=o,this.heightEnd=l}_getPoints(e=!1){const{latStart:t,latEnd:i,lonStart:n,lonEnd:r,heightStart:s,heightEnd:a}=this,o=three.MathUtils.mapLinear(.5,0,1,t,i),l=three.MathUtils.mapLinear(.5,0,1,n,r),c=Math.floor(n/HALF_PI)*HALF_PI,h=[[-PI/2,0],[PI/2,0],[0,c],[0,c+PI/2],[0,c+PI],[0,c+3*PI/2],[t,r],[i,r],[t,n],[i,n],[0,n],[0,r],[o,l],[t,l],[i,l],[o,n],[o,r]],u=[],d=h.length;for(let p=0;p<=1;p++){const o=three.MathUtils.mapLinear(p,0,1,s,a);for(let s=0,a=d;s<a;s++){const[a,l]=h[s];if(a>=t&&a<=i&&l>=n&&l<=r){const t=getVector(e);u.push(t),this.cartographicToCartesian(_position.set(l,a,o),t)}}}return u}getBoundingBox(e,t){resetPool();const{latStart:i,latEnd:n,lonStart:r,lonEnd:s}=this;if(n-i<PI/2){const e=three.MathUtils.mapLinear(.5,0,1,i,n),a=three.MathUtils.mapLinear(.5,0,1,r,s);this.cartographicToCartesian(_tempCartographic.set(a,e,0),_position);const o=Transforms.eastNorthUpToFixedFrame(_position);t.copy(o)}else _orthoX.set(1,0,0),_orthoY.set(0,1,0),_orthoZ.set(0,0,1),t.makeBasis(_orthoX,_orthoY,_orthoZ);const a=this._getPoints(!0);e.makeEmpty(),e.setFromPoints(a),_invMatrix.copy(t).invert();for(let o=0,l=a.length;o<l;o++)a[o].applyMatrix4(_invMatrix);e.makeEmpty(),e.setFromPoints(a)}getBoundingSphere(e,t){resetPool();const i=this._getPoints(!0);e.makeEmpty(),e.setFromPoints(i,t)}}const _vecX=new three.Vector3,_vecY=new three.Vector3,_vecZ=new three.Vector3,_sphereVec=new three.Vector3,_obbVec=new three.Vector3;new three.Matrix3;const _obbHalfAxes=new three.Matrix3,_obbCartographic=new three.Vector3,scratchOffset=new three.Vector3,scratchScale=new three.Vector3,WGS84_RADIUS=6378137,WGS84_FLATTENING=1/298.257223563,WGS84_HEIGHT=-(WGS84_FLATTENING*WGS84_RADIUS-WGS84_RADIUS);class TileBoundingVolume{constructor(){this.sphere=null,this.obb=null,this.region=null,this.regionObb=null}intersectsRay(e){const t=this.sphere,i=this.obb||this.regionObb;return!(t&&!e.intersectsSphere(t))&&!(i&&!i.intersectsRay(e))}intersectRay(e,t=null){const i=this.sphere,n=this.obb||this.regionObb;let r=-1/0,s=-1/0;i&&e.intersectSphere(i,_sphereVec)&&(r=i.containsPoint(e.origin)?0:e.origin.distanceToSquared(_sphereVec)),n&&n.intersectRay(e,_obbVec)&&(s=n.containsPoint(e.origin)?0:e.origin.distanceToSquared(_obbVec));const a=Math.max(r,s);return a===-1/0?null:(e.at(Math.sqrt(a),t),t)}distanceToPoint(e){const t=this.sphere,i=this.obb||this.regionObb;let n=-1/0,r=-1/0;return t&&(n=Math.max(t.distanceToPoint(e),0)),i&&(r=i.distanceToPoint(e)),n>r?n:r}intersectsFrustum(e,t){const i=this.obb||this.regionObb,n=this.sphere;return!(n&&!e.intersectsSphere(n))&&(!(i&&!i.intersectsFrustum(e))&&Boolean(n||i))}getOBB(e,t){const i=this.obb||this.regionObb;i?(e.copy(i.box),t.copy(i.transform)):(this.getAABB(e),t.identity())}getAABB(e){if(this.sphere)this.sphere.getBoundingBox(e);else{const t=this.obb||this.regionObb;e.copy(t.box).applyMatrix4(t.transform)}}getSphere(e){if(this.sphere)e.copy(this.sphere);else if(this.region)this.region.getBoundingSphere(e);else{const t=this.obb||this.regionObb;t.box.getBoundingSphere(e),e.applyMatrix4(t.transform)}}setObbData(e,t){const i=new OBB;_vecX.set(e[3],e[4],e[5]),_vecY.set(e[6],e[7],e[8]),_vecZ.set(e[9],e[10],e[11]);const n=_vecX.length(),r=_vecY.length(),s=_vecZ.length();_vecX.normalize(),_vecY.normalize(),_vecZ.normalize(),0===n&&_vecX.crossVectors(_vecY,_vecZ),0===r&&_vecY.crossVectors(_vecX,_vecZ),0===s&&_vecZ.crossVectors(_vecX,_vecY),i.transform.set(_vecX.x,_vecY.x,_vecZ.x,e[0],_vecX.y,_vecY.y,_vecZ.y,e[1],_vecX.z,_vecY.z,_vecZ.z,e[2],0,0,0,1).premultiply(t);const a=(new three.Vector3).setFromMatrixColumn(i.transform,3);i.center=a,_obbHalfAxes.fromArray(e,3);const o=(new three.Matrix3).setFromMatrix4(t);i.halfAxes=o.multiply(_obbHalfAxes),i.box.min.set(-n,-r,-s),i.box.max.set(n,r,s),i.update(),i.absoluteBox.copy(i.box).applyMatrix4(i.transform),this.obb=i}setSphereData(e,t,i,n,r){const s=new three.Sphere;s.center.set(e,t,i),s.radius=n,s.applyMatrix4(r),this.sphere=s}setRegionData(e,t,i,n,r,s){const a=new EllipsoidRegion(WGS84_RADIUS,WGS84_RADIUS,WGS84_HEIGHT,t,n,e,i,r,s),o=new OBB;a.getBoundingBox(o.box,o.transform),o.update();const l=three.MathUtils.mapLinear(.5,0,1,t,n),c=three.MathUtils.mapLinear(.5,0,1,e,i),{min:h,max:u}=o.box,d=(new three.Matrix3).setFromMatrix4(o.transform);let p=scratchOffset;p.x=(h.x+u.x)/2,p.y=(h.y+u.y)/2,p.z=(h.z+u.z)/2;const m=scratchScale;m.x=(u.x-h.x)/2,m.y=(u.y-h.y)/2,m.z=(u.z-h.z)/2;const f=a.cartographicToCartesian(_obbCartographic.set(c,l,0));p.applyMatrix3(d),o.center=f.add(p),StaticMatrix3.multiplyByScale(d,m,d),o.halfAxes=d,o.absoluteBox.copy(o.box).applyMatrix4(o.transform),this.region=a,this.regionObb=o}}function getJsonFromTypedArray$1(e,t,i){return JSON.parse(getStringFromTypedArray(e,t,i))}function getJsonContent$1(e){let t;try{t=getJsonFromTypedArray$1(e)}catch(i){throw new Error("Invalid tile content.")}return t}function preprocess3DTileContent$1(e){const t=new Uint8Array(e);let i=getMagic(t);if("glTF"===i&&(i="glb"),Cesium3DTileContentType$1.isBinaryFormat(i))return{contentType:i,binaryPayload:t};const n=getJsonContent$1(t);if(defined$2(n.root))return{contentType:Cesium3DTileContentType$1.EXTERNAL_TILESET,jsonPayload:n};if(defined$2(n.root))return{contentType:Cesium3DTileContentType$1.EXTERNAL_TILESET,jsonPayload:n};if(defined$2(n.asset))return{contentType:Cesium3DTileContentType$1.GLTF,jsonPayload:n};if(defined$2(n.tileAvailability))return{contentType:Cesium3DTileContentType$1.IMPLICIT_SUBTREE_JSON,jsonPayload:n};if(defined$2(n.type))return{contentType:Cesium3DTileContentType$1.GEOJSON,jsonPayload:n};if(defined$2(n.voxelTable))return{contentType:Cesium3DTileContentType$1.VOXEL_JSON,jsonPayload:n};throw new Error("Invalid tile content.")}class TileMetadata{constructor(e){const t=(e=defaultValue$1(e,{})).tile,i=e.class;this._class=i,this._properties=t.properties,this._extensions=t.extensions,this._extras=t.extras}get class(){return this._class}get extras(){return this._extras}get extensions(){return this._extensions}hasProperty(e){return MetadataEntity.hasProperty(e,this._properties,this._class)}hasPropertyBySemantic(e){return MetadataEntity.hasPropertyBySemantic(e,this._properties,this._class)}getPropertyIds(e){return MetadataEntity.getPropertyIds(this._properties,this._class,e)}getProperty(e){return MetadataEntity.getProperty(e,this._properties,this._class)}setProperty(e,t){return MetadataEntity.setProperty(e,t,this._properties,this._class)}getPropertyBySemantic(e){return MetadataEntity.getPropertyBySemantic(e,this._properties,this._class)}setPropertyBySemantic(e,t){return MetadataEntity.setPropertyBySemantic(e,t,this._properties,this._class)}}class ContentMetadata{constructor(e){const t=(e=defaultValue$1(e,{})).content,i=e.class;this._class=i,this._properties=t.properties,this._extensions=t.extensions,this._extras=t.extras}get class(){return this._class}get extras(){return this._extras}get extensions(){return this._extensions}hasProperty(e){return MetadataEntity.hasProperty(e,this._properties,this._class)}hasPropertyBySemantic(e){return MetadataEntity.hasPropertyBySemantic(e,this._properties,this._class)}getPropertyIds(e){return MetadataEntity.getPropertyIds(this._properties,this._class,e)}getProperty(e){return MetadataEntity.getProperty(e,this._properties,this._class)}setProperty(e,t){return MetadataEntity.setProperty(e,t,this._properties,this._class)}getPropertyBySemantic(e){return MetadataEntity.getPropertyBySemantic(e,this._properties,this._class)}setPropertyBySemantic(e,t){return MetadataEntity.setPropertyBySemantic(e,t,this._properties,this._class)}}function findTileMetadata(e,t){const i=hasExtension(t,"3DTILES_metadata")?t.extensions["3DTILES_metadata"]:t.metadata;if(!defined$2(i))return;if(!defined$2(e.schema))return void warnOnce("Could not find a metadata schema for tile metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json.");const n=defaultValue$1(e.schema.classes,{});if(defined$2(i.class)){const e=n[i.class];return new TileMetadata({tile:i,class:e})}}function findGroupMetadata(e,t){const i=e.metadataExtension;if(!defined$2(i))return;const n=i.groups,r=hasExtension(t,"3DTILES_metadata")?t.extensions["3DTILES_metadata"].group:t.group;if("number"==typeof r)return n[r];const s=i.groupIds.findIndex((function(e){return e===r}));return s>=0?n[s]:void 0}function findContentMetadata(e,t){const i=hasExtension(t,"3DTILES_metadata")?t.extensions["3DTILES_metadata"]:t.metadata;if(!defined$2(i))return;if(!defined$2(e.schema))return void warnOnce("Could not find a metadata schema for content metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json.");const n=defaultValue$1(e.schema.classes,{});if(defined$2(i.class)){const e=n[i.class];return new ContentMetadata({content:i,class:e})}}class Cesium3DContentGroup{constructor(e){e=defaultValue$1(e,{}),this._metadata=e.metadata}get metadata(){return this._metadata}}function contain(e,t){const i=e.image&&e.image.width?e.image.width/e.image.height:1;return i>t?(e.repeat.x=1,e.repeat.y=i/t,e.offset.x=0,e.offset.y=(1-e.repeat.y)/2):(e.repeat.x=t/i,e.repeat.y=1,e.offset.x=(1-e.repeat.x)/2,e.offset.y=0),e}function cover(e,t){const i=e.image&&e.image.width?e.image.width/e.image.height:1;return i>t?(e.repeat.x=t/i,e.repeat.y=1,e.offset.x=(1-e.repeat.x)/2,e.offset.y=0):(e.repeat.x=1,e.repeat.y=i/t,e.offset.x=0,e.offset.y=(1-e.repeat.y)/2),e}function fill(e){return e.repeat.x=1,e.repeat.y=1,e.offset.x=0,e.offset.y=0,e}function getByteLength(e,t,i,n){const r=getTextureTypeByteLength(n);switch(i){case three.AlphaFormat:return e*t;case three.RedFormat:case three.RedIntegerFormat:return e*t/r.components*r.byteLength;case three.RGFormat:case three.RGIntegerFormat:return e*t*2/r.components*r.byteLength;case three.RGBAFormat:case three.RGBAIntegerFormat:return e*t*4/r.components*r.byteLength;case three.RGB_S3TC_DXT1_Format:case three.RGBA_S3TC_DXT1_Format:return Math.floor((e+3)/4)*Math.floor((t+3)/4)*8;case three.RGBA_S3TC_DXT3_Format:case three.RGBA_S3TC_DXT5_Format:return Math.floor((e+3)/4)*Math.floor((t+3)/4)*16;case three.RGB_PVRTC_2BPPV1_Format:case three.RGBA_PVRTC_2BPPV1_Format:return Math.max(e,16)*Math.max(t,8)/4;case three.RGB_PVRTC_4BPPV1_Format:case three.RGBA_PVRTC_4BPPV1_Format:return Math.max(e,8)*Math.max(t,8)/2;case three.RGB_ETC1_Format:case three.RGB_ETC2_Format:return Math.floor((e+3)/4)*Math.floor((t+3)/4)*8;case three.RGBA_ETC2_EAC_Format:case three.RGBA_ASTC_4x4_Format:return Math.floor((e+3)/4)*Math.floor((t+3)/4)*16;case three.RGBA_ASTC_5x4_Format:return Math.floor((e+4)/5)*Math.floor((t+3)/4)*16;case three.RGBA_ASTC_5x5_Format:return Math.floor((e+4)/5)*Math.floor((t+4)/5)*16;case three.RGBA_ASTC_6x5_Format:return Math.floor((e+5)/6)*Math.floor((t+4)/5)*16;case three.RGBA_ASTC_6x6_Format:return Math.floor((e+5)/6)*Math.floor((t+5)/6)*16;case three.RGBA_ASTC_8x5_Format:return Math.floor((e+7)/8)*Math.floor((t+4)/5)*16;case three.RGBA_ASTC_8x6_Format:return Math.floor((e+7)/8)*Math.floor((t+5)/6)*16;case three.RGBA_ASTC_8x8_Format:return Math.floor((e+7)/8)*Math.floor((t+7)/8)*16;case three.RGBA_ASTC_10x5_Format:return Math.floor((e+9)/10)*Math.floor((t+4)/5)*16;case three.RGBA_ASTC_10x6_Format:return Math.floor((e+9)/10)*Math.floor((t+5)/6)*16;case three.RGBA_ASTC_10x8_Format:return Math.floor((e+9)/10)*Math.floor((t+7)/8)*16;case three.RGBA_ASTC_10x10_Format:return Math.floor((e+9)/10)*Math.floor((t+9)/10)*16;case three.RGBA_ASTC_12x10_Format:return Math.floor((e+11)/12)*Math.floor((t+9)/10)*16;case three.RGBA_ASTC_12x12_Format:return Math.floor((e+11)/12)*Math.floor((t+11)/12)*16;case three.RGBA_BPTC_Format:case three.RGB_BPTC_SIGNED_Format:case three.RGB_BPTC_UNSIGNED_Format:return Math.ceil(e/4)*Math.ceil(t/4)*16;case three.RED_RGTC1_Format:case three.SIGNED_RED_RGTC1_Format:return Math.ceil(e/4)*Math.ceil(t/4)*8;case three.RED_GREEN_RGTC2_Format:case three.SIGNED_RED_GREEN_RGTC2_Format:return Math.ceil(e/4)*Math.ceil(t/4)*16}throw new Error(`Unable to determine texture byte length for ${i} format.`)}function getTextureTypeByteLength(e){switch(e){case three.UnsignedByteType:case three.ByteType:return{byteLength:1,components:1};case three.UnsignedShortType:case three.ShortType:case three.HalfFloatType:return{byteLength:2,components:1};case three.UnsignedShort4444Type:case three.UnsignedShort5551Type:return{byteLength:2,components:4};case three.UnsignedIntType:case three.IntType:case three.FloatType:return{byteLength:4,components:1}}throw new Error(`Unknown texture type ${e}.`)}const TextureUtils={contain:contain,cover:cover,fill:fill,getByteLength:getByteLength};function estimateBytesUsed(e){if(!TextureUtils)return 0;const t=new Set;let i=0;return e.traverse((e=>{if(e.geometry&&!t.has(e.geometry)&&(i+=estimateBytesUsed$1(e.geometry),t.add(e.geometry)),e.material){const n=e.material;for(const e in n)if(n.hasOwnProperty(e)){const r=n[e];if(r&&r.isTexture&&!t.has(r)){const{format:e,type:n,image:s}=r,{width:a,height:o}=s,l=TextureUtils.getByteLength(a,o,e,n);i+=r.generateMipmaps?4*l/3:l,t.add(r)}}}})),i}function canScheduleAllRequests(e){const t={};for(let i=0;i<e.length;i++){const n=e[i];defined$2(t[n])?t[n]++:t[n]=1}for(let i in t)if(t.hasOwnProperty(i)&&!RequestScheduler.serverHasOpenSlots(i,t[i]))return!1;return RequestScheduler.heapHasOpenSlots(e.length)}function cancelPendingRequests(e,t){e._cancelCount++,e._tile._contentState=t;const i=e.tileset.statistics;i.numberOfPendingRequests-=e._requestsInFlight,i.numberOfAttemptedRequests+=e._requestsInFlight,e._requestsInFlight=0;const n=e._innerContentHeaders.length;e._arrayFetchPromises=new Array(n)}function requestInnerContent(e,t,i,n){const r=e._innerContentResources[t].clone(),s=e.tile,a=e._serverKeys[t],o=new Request({throttle:!0,throttleByServer:!0,priorityFunction:function(){return s._priority},serverKey:a});r.request=o,e._requests[t]=o;const l=r.fetchArrayBuffer();if(defined$2(l))return l.then((function(t){if(!(i<e._cancelCount)){if(!r.request.cancelled&&r.request.state!==RequestState$1.CANCELLED)return updatePendingRequests(e,-1),t;cancelPendingRequests(e,n)}})).catch((function(s){i<e._cancelCount||(r.request.cancelled||r.request.state===RequestState$1.CANCELLED?cancelPendingRequests(e,n):(updatePendingRequests(e,-1),handleInnerContentFailed(e,t,s)))}))}function updatePendingRequests(e,t){e._requestsInFlight+=t,e.tileset.statistics.numberOfPendingRequests+=t}async function createInnerContents(e){const t=e._cancelCount,i=await Promise.all(e._arrayFetchPromises);if(t<e._cancelCount)return;const n=i.map(((t,i)=>createInnerContent(e,t,i))),r=await Promise.all(n);return e._contentCreated=!0,e._contents=r.filter(defined$2),r}function handleInnerContentFailed(e,t,i){e._tileset,e._innerContentResources[t].url,defined$2(i.message)?i.message:i.toString()}async function createInnerContent(e,t,i){if(defined$2(t))try{const n=preprocess3DTileContent$1(t);if(n.contentType===Cesium3DTileContentType$1.EXTERNAL_TILESET)throw new Error("External tilesets are disabllowed inside multiple contents");const r=e._tileset,s=e._innerContentResources[i],a=e._tile;let o;const l=Cesium3DTileContentFactory[n.contentType];o=defined$2(n.binaryPayload)?await l(r,a,a._contentResource,n.binaryPayload.buffer,0):await Promise.resolve(l(r,a,s,n.binaryPayload.buffer));const c=e._innerContentHeaders[i];if(a.hasImplicitContentMetadata){const e=a.implicitSubtree,t=a.implicitCoordinates;o.metadata=e.getContentMetadataView(t,i)}else a.hasImplicitContent||(o.metadata=findContentMetadata(r,c));const h=findGroupMetadata(r,c);if(defined$2(h)&&(o.group=new Cesium3DContentGroup({metadata:h})),!a.hasTilesetContent&&!a.hasImplicitContent){defined$2(o.scene)&&(o.byteSize=estimateBytesUsed(o.scene))}return o}catch(n){handleInnerContentFailed(e,i,n)}}class Multiple3DTileContents{constructor(e,t,i,n){__publicField(this,"isMultiple3DTileContents",!0),this._tileset=e,this._tile=t,this._tilesetResource=i;const r=defined$2(n.contents)?n.contents:n.content;this._innerContentHeaders=r,this._requestsInFlight=0,this._cancelCount=0;const s=this._innerContentHeaders.length;this._arrayFetchPromises=new Array(s),this._requests=new Array(s),this._ready=!1,this._innerContentResources=new Array(s),this._serverKeys=new Array(s);for(let a=0;a<s;a++){const e=i.getDerivedResource({url:r[a].uri}),t=RequestScheduler.getServerKey(e.getUrlComponent());this._innerContentResources[a]=e,this._serverKeys[a]=t}}updatePendingRequests(e){}requestInnerContents(){if(!canScheduleAllRequests(this._serverKeys))return void(this.tileset.statistics.numberOfAttemptedRequests+=this._serverKeys.length);const e=this._innerContentHeaders;updatePendingRequests(this,e.length);const t=this._cancelCount;for(let i=0;i<e.length;i++)this._arrayFetchPromises[i]=requestInnerContent(this,i,t,this._tileset._contentState);return createInnerContents(this)}cancelRequests(){for(let e=0;e<this._requests.length;e++){const t=this._requests[e];defined$2(t)&&t.cancel()}}traverse(e){const t=this._contents;if(t&&t.length>0)for(let i=0;i<t.length;i++){const n=t[i].scene;n&&n.traverse(e)}}dispose(){const e=this._contents;if(e&&e.length>0)for(let t=0;t<e.length;t++){e[t].dispose()}}update(e){const t=this._contents;t&&t.length>0&&t.forEach((t=>{t.update(e)}))}get tileset(){return this._tileset}get tile(){return this._tile}}const scratchSphere=new three.Sphere,scratchToTileCenter=new three.Vector3,scratchDirectionWC=new three.Vector3,scratchCartesian=new three.Vector3;function isolateDigits(e,t,i){const n=e*Math.pow(10,t);return parseInt(n,10)*Math.pow(10,i)}function hasExtension$1(e,t){return defined$2(e)&&defined$2(e.extensions)&&defined$2(e.extensions[t])}function requestMultipleContents(e){let t=e._content;const i=e._tileset;if(!defined$2(t)){const n=hasExtension$1(e.content,"3DTILES_multiple_contents")?e._header.extensions["3DTILES_multiple_contents"]:e._header;t=new Multiple3DTileContents(i,e,e._contentResource.clone(),n),e._content=t}const n=t.requestInnerContents();if(defined$2(n))return e._contentState=Cesium3DTileContentState$1.LOADING,n.then((i=>{if(!e.isDestroyed()&&defined$2(i))return e._contentState=Cesium3DTileContentState$1.PROCESSING,t})).catch((t=>{if(!e.isDestroyed())return e._contentState=Cesium3DTileContentState$1.FAILED,t}))}function createPriorityFunction(e){return function(){return e._priority}}function requestSingleContent(e){const t=e._contentResource.clone(),i=new Request({throttle:!0,throttleByServer:!0,priorityFunction:createPriorityFunction(e),serverKey:e._serverKey});e._request=i,t.request=i;const n=e._tileset,r=t.fetchArrayBuffer();if(defined$2(r))return processArrayBuffer(e,n,i,!1,r);++n.statistics.numberOfAttemptedRequests}function fogDensity(e,t){const i=e*t;return 1-Math.exp(-i*i)}function getJsonFromTypedArray(e,t,i){return JSON.parse(getStringFromTypedArray(e,t,i))}function getJsonContent(e){let t;try{t=getJsonFromTypedArray(e)}catch(i){throw new Error("Invalid tile content.")}return t}function priorityNormalizeAndClamp(e,t,i){return Math.max(CesiumMath.normalize(e,t,i)-CesiumMath.EPSILON7,0)}function isPriorityDeferred(e,t){const{tileset:i,boundingVolume:n}=e;n.getSphere(scratchSphere);const r=t._rendering.camera,s=scratchSphere.center,a=scratchSphere.radius,o=i._cameraInfo,l=scratchDirectionWC.copy(o.directionWC).multiplyScalar(e._centerZDepth),c=scratchCartesian.addVectors(o.position,l),h=scratchCartesian.subVectors(c,s);if(h.length()>scratchSphere.radius){const t=scratchCartesian.copy(h).normalize().multiplyScalar(a),i=scratchCartesian.addVectors(s,t);scratchCartesian.subVectors(i,o.position);const n=scratchCartesian.normalize();e._foveatedFactor=1-Math.abs(o.directionWC.dot(n))}else e._foveatedFactor=0;const u=1-Math.cos(.5*r.fov),d=i.foveatedConeSize*u;if(e._foveatedFactor<=d)return!1;const p=u-d,m=CesiumMath.clamp((e._foveatedFactor-d)/p,0,1),f=i.foveatedInterpolationCallback(i.foveatedMinimumScreenSpaceErrorRelaxation,i.screenSpaceError,m),g=0===e._screenSpaceError&&defined$2(e.parent)?.5*e.parent._screenSpaceError:e._screenSpaceError;return i.screenSpaceError-f<=4*g}function preprocess3DTileContent(e){const t=new Uint8Array(e);let i=getMagic(t);if("glTF"===i&&(i="glb"),Cesium3DTileContentType$1.isBinaryFormat(i))return{contentType:i,binaryPayload:t};const n=getJsonContent(t);if(defined$2(n.root))return{contentType:Cesium3DTileContentType$1.EXTERNAL_TILESET,jsonPayload:n};if(defined$2(n.root))return{contentType:Cesium3DTileContentType$1.EXTERNAL_TILESET,jsonPayload:n};if(defined$2(n.asset))return{contentType:Cesium3DTileContentType$1.GLTF,jsonPayload:n};if(defined$2(n.tileAvailability))return{contentType:Cesium3DTileContentType$1.IMPLICIT_SUBTREE_JSON,jsonPayload:n};if(defined$2(n.type))return{contentType:Cesium3DTileContentType$1.GEOJSON,jsonPayload:n};if(defined$2(n.voxelTable))return{contentType:Cesium3DTileContentType$1.VOXEL_JSON,jsonPayload:n};throw new Error("Invalid tile content.")}async function makeContent(e,t){const i=preprocess3DTileContent(t),n=e._tileset;let r;n._disableSkipLevelOfDetail=n._disableSkipLevelOfDetail||i.contentType===Cesium3DTileContentType$1.GEOMETRY||i.contentType===Cesium3DTileContentType$1.VECTOR,i.contentType!==Cesium3DTileContentType$1.IMPLICIT_SUBTREE&&i.contentType!==Cesium3DTileContentType$1.IMPLICIT_SUBTREE_JSON||(e.hasImplicitContent=!0),i.contentType===Cesium3DTileContentType$1.EXTERNAL_TILESET&&(e.hasTilesetContent=!0);const s=Cesium3DTileContentFactory[i.contentType];if(e.isDestroyed())return;r=defined$2(i.binaryPayload)?await s(n,e,e._contentResource,i.binaryPayload.buffer,0):await Promise.resolve(s(n,e,e._contentResource,i.jsonPayload));const a=e._contentHeader;if(e.hasImplicitContentMetadata){const t=e.implicitSubtree,i=e.implicitCoordinates;r.metadata=t.getContentMetadataView(i,0)}else e.hasImplicitContent||(r.metadata=findContentMetadata(n,a));const o=findGroupMetadata(n,a);if(defined$2(o)&&(r.group=new Cesium3DContentGroup({metadata:o})),!e.hasTilesetContent&&!e.hasImplicitContent){const e=r.scene;defined$2(e)&&(r.byteSize=estimateBytesUsed(e))}return r}async function processArrayBuffer(e,t,i,n,r){const s=e._contentState;let a;e._contentState=Cesium3DTileContentState$1.LOADING,++t.statistics.numberOfPendingRequests;try{a=await r}catch(o){if(--t.statistics.numberOfPendingRequests,e.isDestroyed())return;if(i.cancelled||i.state===RequestState$1.CANCELLED)return e._contentState=s,void++t.statistics.numberOfAttemptedRequests;e._contentState=Cesium3DTileContentState$1.FAILED}if(e.isDestroyed())--t.statistics.numberOfPendingRequests;else{if(i.cancelled||i.state===RequestState$1.CANCELLED)return e._contentState=s,--t.statistics.numberOfPendingRequests,void++t.statistics.numberOfAttemptedRequests;try{const i=await makeContent(e,a);if(--t.statistics.numberOfPendingRequests,e.isDestroyed())return;return e._content=i,e._contentState=Cesium3DTileContentState$1.PROCESSING,i}catch(o){if(--t.statistics.numberOfPendingRequests,e.isDestroyed())return;throw e._contentState=Cesium3DTileContentState$1.FAILED,o}}}function isPriorityProgressiveResolution(e,t){if(e.progressiveResolutionHeightFraction<=0||e.progressiveResolutionHeightFraction>.5)return!1;const i=e.screenSpaceError;let n=t._screenSpaceErrorProgressiveResolution>i;t._priorityProgressiveResolutionScreenSpaceErrorLeaf=!1;const r=t.parent,s=t._screenSpaceErrorProgressiveResolution<=i,a=defined$2(r)&&r._screenSpaceErrorProgressiveResolution>i;return s&&a&&(t._priorityProgressiveResolutionScreenSpaceErrorLeaf=!0,n=!0),n}class Cesium3DTile{constructor(e,t,i,n){this._tileset=e,this._header=i,this.hasTilesetContent=!1,this.hasImplicitContent=!1,this.hasImplicitContentMetadata=!1,this._updatedVisibilityFrame=0;const r=defined$2(i.contents),s=r&&i.contents.length>1||hasExtension$1(i,"3DTILES_multiple_contents"),a=r&&!s?i.contents[0]:i.content;this._contentHeader=a,this.transform=defined$2(i.transform)?(new three.Matrix4).fromArray(i.transform):new three.Matrix4;const o=defined$2(n)?n.computedTransform:e.modelMatrix,l=(new three.Matrix4).copy(o).multiply(this.transform);let c,h;this.computedTransform=l,this.metadata=findTileMetadata(e,i),this.geometricError=i.geometricError,this._geometricError=i.geometricError,defined$2(this._geometricError)||(this._geometricError=defined$2(n)?n._geometricError:e._geometricError),c=defined$2(i.refine)?"REPLACE"===i.refine.toUpperCase()?Cesium3DTileRefine.REPLACE:Cesium3DTileRefine.ADD:defined$2(n)?n.refine:Cesium3DTileRefine.REPLACE,this._parent=n;let u,d,p=!1;if(t=Resource.createIfNeeded(t),s)u=Cesium3DTileContentState$1.UNLOADED,d=t.clone();else if(defined$2(a)){let i=a.uri;defined$2(a.url)&&(console.warn('This tileset JSON uses the "content.url" property which has been deprecated. Use "content.uri" instead.'),i=a.url),""===i?(h=new Empty3DTileContent(e,this),p=!0,u=Cesium3DTileContentState$1.READY):(u=Cesium3DTileContentState$1.UNLOADED,d=t.getDerivedResource({url:i}),RequestScheduler.getServerKey(d.getUrlComponent()))}else h=new Empty3DTileContent(e,this),p=!0,u=Cesium3DTileContentState$1.READY;this._content=h,this._contentResource=d,this._contentState=u,this.hasEmptyContent=p,this.hasMultipleContents=s,this.refine=c,this.children=[],this.parent=n,this._screenSpaceError=0,this._depthToCamera=0,this._centerZDepth=0,this._depth=0,this._refines=!1,this.priorityDeferred=!1,this._visible=!1,this._inRequestVolume=!0,this.contentExpired=!1,this._isInRequestVolume=!0,this._priority=0,this._priorityHolder=this,this._foveatedFactor=0;const m=new TileBoundingVolume;"sphere"in i.boundingVolume&&m.setSphereData(...i.boundingVolume.sphere,this.computedTransform),"box"in i.boundingVolume&&m.setObbData(i.boundingVolume.box,this.computedTransform),"region"in i.boundingVolume&&m.setRegionData(...i.boundingVolume.region),this.boundingVolume=m}updatePriority(){const e=this.tileset,t=e.preferLeaves,i=e._minimumPriority,n=e._maximumPriority,r=Math.pow(10,8);Math.pow(10,9);let s=priorityNormalizeAndClamp(this._depth,i.depth,n.depth);s=t?1-s:s;const a=isolateDigits(priorityNormalizeAndClamp(this._priorityHolder._distanceToCamera,i.distance,n.distance),4,0),o=this._priorityProgressiveResolution?0:r;priorityNormalizeAndClamp(this._priorityHolder._foveatedFactor,i.foveatedFactor,n.foveatedFactor),this.priorityDeferred;const l=this.isVisible?0:Math.pow(10,10);this._priority=s+a+l+o}updateContent(e){const t=this.tileset;e.update(this),t.dispatchEvent({type:"loaded",tile:this})}process(e){this.contentReady||(this._selectedFrame=0,this.lastStyleTime=0,this._contentState=Cesium3DTileContentState$1.READY,this.hasTilesetContent||this.hasImplicitContent||(e._statistics.incrementLoadCounts(this.content),++e._statistics.numberOfTilesWithContentReady,++e._statistics.numberOfLoadedTilesTotal,e._cache.add(this)));try{const t=this._content;t.isTileset3DTileContent?t.update(e):this.updateContent(t)}catch(t){this._contentState=Cesium3DTileContentState$1.FAILED}}update(e){}cancelRequests(){this.hasMultipleContents?this._content.cancelRequests():this._request.cancel()}unloadContent(){if(!this.hasRenderableContent)return;const e=this._content;if(e){e.dispose();this.tileset.dispatchEvent({type:"dispose",tile:this}),this._content=null}this._contentState=Cesium3DTileContentState$1.UNLOADED}requestContent(){if(!this.hasEmptyContent)return this.hasMultipleContents?requestMultipleContents(this):requestSingleContent(this)}visibility(){const e=this.boundingVolume,t=this._tileset._cameraInfo.frustum;e.intersectsFrustum(t,!0)?this._visible=!0:this._visible=!1}computeVisibility(e,t){const i=this.tileset.getCamera().frustum;return this.intersectBoundingVolume(e,i)}intersectBoundingVolume(e,t){}updateVisibility(e){const{tileset:t}=this;this._updatedVisibilityFrame!==t._updatedVisibilityFrame&&(this.updateTransform(),this._distanceToCamera=this.distanceToTile(),this._centerZDepth=this.distanceToTileCenter(e),this._screenSpaceError=this.getScreenSpaceError(),this._screenSpaceErrorProgressiveResolution=this.getScreenSpaceError(!1,this.tileset.progressiveResolutionHeightFraction),this._priorityProgressiveResolution=isPriorityProgressiveResolution(t,this),this.priorityDeferred=isPriorityDeferred(this,e),this.visibility(),this._updatedVisibilityFrame=t._updatedVisibilityFrame)}updateTransform(){this.geometricError=this._geometricError}distanceToTile(){const e=this.boundingVolume,t=this.tileset._cameraInfo;return e.distanceToPoint(t.position)}distanceToTileCenter(e){this.boundingVolume;const t=this._tileset._cameraInfo,i=this.boundingVolumeCenter;return scratchToTileCenter.subVectors(i,t.position).dot(t.directionWC)}getScreenSpaceError(e,t){const i=this._tileset,n=defaultValue$1(t,1),r=defined$2(this.parent)?this.parent.geometricError:i._scaledGeometricError,s=e?r:this.geometricError;if(0===s)return 0;const a=i._cameraInfo;this.boundingVolume;const o=a.invScale;let l;if(a.isOrthographic){l=s/(a.pixelSize*o)}else{const e=Math.max(this._distanceToCamera,1e-7);if(l=s*n/(e*o*a.sseDenominator),i.dynamicScreenSpaceError){const t=i._dynamicScreenSpaceErrorComputedDensity,n=i.dynamicScreenSpaceErrorFactor;l-=fogDensity(e,t)*n}}return l}getDistance(){return 100}isDestroyed(){return!1}get contentReady(){return this._contentState===Cesium3DTileContentState$1.READY}get contentAvailable(){return this.contentReady&&this.hasRenderableContent}get hasRenderableContent(){return!this.hasEmptyContent&&!this.hasTilesetContent&&!this.hasImplicitContent}get isVisible(){return this._visible&&this._inRequestVolume}get tileset(){return this._tileset}get hasUnloadedRenderableContent(){return this.hasRenderableContent&&this.contentUnLoaded}get contentUnLoaded(){return this._contentState===Cesium3DTileContentState$1.UNLOADED}get content(){return this._content}get cached(){return this._content}get __visible(){const e=this._tileset;return this._selectedFrame===e._updatedVisibilityFrame}get boundingVolumeCenter(){const e=this.boundingVolume.obb||this.boundingVolume.regionObb;if(defined$2(e))return e.center;return this.boundingVolume.sphere.center}}class Cesium3DTilesetSkipTraversal{}const tempSphere=new three.Sphere;function isOnScreenLongEnough(e){const{tileset:t}=e;if(!t._cullRequestsWhileMoving)return!0;const i=t._cameraInfo,{positionWCDeltaMagnitude:n,positionWCDeltaMagnitudeLastFrame:r}=i,s=0!==n?n:r;e.boundingVolume.getSphere(tempSphere);const a=Math.max(2*tempSphere.radius,1);return t.cullRequestsWhileMovingMultiplier*s/a<1}class Cesium3DTilesetTraversal{static selectTile(e,t){e._wasSelectedLastFrame=!0;const{content:i,tileset:n}=e;e._selectedFrame=t.frameCount,n._selectedTiles.push(e)}static sortChildrenByDistanceToCamera(e,t){return 0===t._distanceToCamera&&0===e._distanceToCamera?t._centerZDepth-e._centerZDepth:t._distanceToCamera-e._distanceToCamera}static canTraverse(e){return 0!==e.children.length&&(!(!e.hasTilesetContent&&!e.hasImplicitContent)||e._screenSpaceError>e.tileset.screenSpaceError)}static visitTile(e,t){++e.tileset._statistics.visited,e._visitedFrame=t.frameCount}static touchTile(e,t){e._touchedFrame!==t.frameCount&&(e.tileset._cache.touch(e),e._touchedFrame=t.frameCount)}static loadTile(e,t){const{tileset:i}=e;e._requestedFrame!==t.frameCount&&e.hasUnloadedRenderableContent&&isOnScreenLongEnough(e)&&(e._requestedFrame=t.frameCount,i._requestedTiles.push(e))}static updateTile(e,t){updateTileVisibility(e,t),e._wasMinPriorityChild=!1,e._priorityHolder=e,updateMinimumMaximumPriority(e),e._shouldSelect=!1,e._finalResolution=!0}}function updateTileVisibility(e,t){if(e.updateVisibility(t),!e.isVisible)return;const i=e.children.length>0;if((e.hasTilesetContent||e.hasImplicitContent)&&i){const i=e.children[0];return updateTileVisibility(i,t),void(e._visible=i._visible)}if(meetsScreenSpaceErrorEarly(e))return void(e._visible=!1);const n=e.refine===Cesium3DTileRefine.REPLACE,r=e._optimChildrenWithinParent===Cesium3DTileOptimizationHint.USE_OPTIMIZATION;return n&&r&&i&&!anyChildrenVisible(e,t)?(++e.tileset._statistics.numberOfTilesCulledWithChildrenUnion,void(e._visible=!1)):void 0}function updateMinimumMaximumPriority(e){const t=e.tileset._minimumPriority,i=e.tileset._maximumPriority,n=e._priorityHolder;i.distance=Math.max(n._distanceToCamera,i.distance),t.distance=Math.min(n._distanceToCamera,t.distance),i.depth=Math.max(e._depth,i.depth),t.depth=Math.min(e._depth,t.depth),i.foveatedFactor=Math.max(n._foveatedFactor,i.foveatedFactor),t.foveatedFactor=Math.min(n._foveatedFactor,t.foveatedFactor)}function anyChildrenVisible(e,t){let i=!1;const n=e.children;for(let r=0;r<n.length;++r){const e=n[r];e.updateVisibility(t),i=i||e.isVisible}return i}function meetsScreenSpaceErrorEarly(e){const{parent:t,tileset:i}=e;return!(!defined$2(t)||t.hasTilesetContent||t.hasImplicitContent||t.refine!==Cesium3DTileRefine.ADD)&&e.getScreenSpaceError(!0)<=i.screenSpaceError}class ManagedArray{constructor(e=0){e=defaultValue$1(e,0),this._array=new Array(e),this._length=e}get length(){return this._length}set length(e){const t=this._array,i=this._length;if(e<i)for(let n=e;n<i;++n)t[n]=void 0;else e>t.length&&(t.length=e);this._length=e}get values(){return this._array}get(e){return this._array[e]}set(e,t){e>=this._length&&(this.length=e+1),this._array[e]=t}peek(){return this._array[this._length-1]}push(e){const t=this.length++;this._array[t]=e}pop(){if(0===this._length)return;const e=this._array[this._length-1];return--this.length,e}reserve(e){e>this._array.length&&(this._array.length=e)}resize(e){this.length=e}trim(e){e=defaultValue$1(e,this._length),this._array.length=e}}const traversal={stack:new ManagedArray,stackMaximumLength:0},emptyTraversal={stack:new ManagedArray,stackMaximumLength:0},loadedTraversal={stack:new ManagedArray,stackMaximumLength:0};class Cesium3DTilesetBaseTraversal{static selectTiles(e,t){e._requestedTiles.length=0,e._selectedTiles.length=0,e._selectedTilesToStyle.length=0,e._emptyTiles.length=0,e.hasMixedContent=!1;let i=e.root;if(Cesium3DTilesetTraversal.updateTile(i,t),!i.isVisible)return;if(i.getScreenSpaceError(!0)<e.screenSpaceError)return;executeTraversal(i,t),traversal.stack.trim(traversal.stackMaximumLength),emptyTraversal.stack.trim(emptyTraversal.stackMaximumLength);const n=e._requestedTiles;for(let r=0;r<n.length;++r)n[r].updatePriority()}static forEachLoadedTile(e,t){const i=e.root;if(!defined$2(i))return;const n=loadedTraversal.stack;for(n.push(i);n.length>0;){const e=n.pop();e.children.forEach((e=>{n.push(e)}));const i=e.content;if(e.hasRenderableContent&&i){t(i.scene,e)}}}}function executeTraversal(e,t){const{tileset:i}=e,{canTraverse:n,loadTile:r,visitTile:s,touchTile:a}=Cesium3DTilesetTraversal,o=traversal.stack;for(o.push(e);o.length>0;){traversal.stackMaximumLength=Math.max(traversal.stackMaximumLength,o.length);const e=o.pop(),l=e.parent,c=!defined$2(l)||l._refines;let h=!0;if(n(e)){const i=updateAndPushChildren(e,o,t);h=i.anyChildrenVisible,e._refines=i.refines&&c}else e._refines=!1;const u=!e._refines&&c;e.hasRenderableContent?e.refine===Cesium3DTileRefine.ADD?(selectDesiredTile(e,t,h),r(e,t)):e.refine===Cesium3DTileRefine.REPLACE&&(r(e,t),u&&selectDesiredTile(e,t,h)):(i._emptyTiles.push(e),r(e,t),u&&selectDesiredTile(e,t,h)),s(e,t),a(e,t)}}function selectDesiredTile(e,t,i){const n=e.refine===Cesium3DTileRefine.REPLACE,r=e._optimChildrenWithinParent===Cesium3DTileOptimizationHint.USE_OPTIMIZATION,s=e.children&&e.children.length>0,a=r&&s&&n;if(e.contentAvailable){if(a&&!i)return void++e.tileset._statistics.numberOfTilesCulledWithChildrenUnion;Cesium3DTilesetTraversal.selectTile(e,t)}}function updateAndPushChildren(e,t,i){const n=e.refine===Cesium3DTileRefine.REPLACE,{tileset:r,children:s}=e,{updateTile:a,loadTile:o,touchTile:l}=Cesium3DTilesetTraversal;for(let m=0;m<s.length;m++)a(s[m],i);s.sort(Cesium3DTilesetTraversal.sortChildrenByDistanceToCamera);const c=n&&e.hasRenderableContent;let h=!0,u=!1,d=-1,p=Number.MAX_VALUE;for(let m=0;m<s.length;++m){const e=s[m];if(e.isVisible?(t.push(e),e._foveatedFactor<p&&(d=m,p=e._foveatedFactor),u=!0):(c||r.loadSiblings)&&(e._foveatedFactor<p&&(d=m,p=e._foveatedFactor),o(e,i),l(e,i)),c){let t;t=!!e._isInRequestVolume&&(e.hasRenderableContent?e.contentAvailable:executeEmptyTraversal(e,i)),h=h&&!(e.isVisible&&!t)}}if(u||(h=!1),-1!==d&&n){const t=s[d];t._wasMinPriorityChild=!0;const i=(e._wasMinPriorityChild||e===r.root)&&p<=e._priorityHolder._foveatedFactor?e._priorityHolder:e;i._foveatedFactor=Math.min(t._foveatedFactor,i._foveatedFactor),i._distanceToCamera=Math.min(t._distanceToCamera,i._distanceToCamera);for(let e=0;e<s.length;++e)s[e]._priorityHolder=i}return{refines:h,anyChildrenVisible:u}}function executeEmptyTraversal(e,t){const{canTraverse:i,updateTile:n,loadTile:r,touchTile:s}=Cesium3DTilesetTraversal;let a=!0;const o=emptyTraversal.stack;for(o.push(e);o.length>0;){emptyTraversal.stackMaximumLength=Math.max(emptyTraversal.stackMaximumLength,o.length);const e=o.pop(),l=e.children,c=l.length,h=!e.hasRenderableContent&&i(e);if(h||e.contentAvailable||(a=!1),n(e,t),e.isVisible||(r(e,t),s(e,t)),h)for(let t=0;t<c;++t){const e=l[t];o.push(e)}}return e.hasEmptyContent||a}class ImplicitTileset{constructor(e,t,i){const n=hasExtension(t,"3DTILES_implicit_tiling")?t.extensions["3DTILES_implicit_tiling"]:t.implicitTiling;this.baseResource=e,this.geometricError=t.geometricError,this.metadataSchema=i;const r=t.boundingVolume;if(!(defined$2(r.box)||defined$2(r.region)||hasExtension(r,"3DTILES_bounding_volume_S2")||hasExtension(r,"3DTILES_bounding_volume_cylinder")))throw new Error("Only box, region, 3DTILES_bounding_volume_S2, and 3DTILES_bounding_volume_cylinder are supported for implicit tiling");this.boundingVolume=r,this.refine=t.refine,this.subtreeUriTemplate=new Resource({url:n.subtrees.uri}),this.contentUriTemplates=[],this.contentHeaders=[];const s=gatherContentHeader(t);for(let a=0;a<s.length;a++){const e=s[a];this.contentHeaders.push(clone$2(e,!0));const t=new Resource({url:e.uri});this.contentUriTemplates.push(t)}this.contentCount=this.contentHeaders.length,this.tileHeader=makeTileHeaderTemplate(t),this.subdivisionScheme=ImplicitSubdivisionScheme[n.subdivisionScheme],this.branchingFactor=ImplicitSubdivisionScheme.getBranchingFactor(this.subdivisionScheme),this.subtreeLevels=n.subtreeLevels,defined$2(n.availableLevels)?this.availableLevels=n.availableLevels:this.availableLevels=n.maximumLevel+1}}function gatherContentHeader(e){if(hasExtension(e,"3DTILES_multiple_contents")){const t=e.extensions["3DTILES_multiple_contents"];return defined$2(t.contents)?t.contents:t.content}return defined$2(e.contents)?e.contents:defined$2(e.content)?[e.content]:[]}function makeTileHeaderTemplate(e){const t=clone$2(e,!0);return defined$2(t.extensions)&&(delete t.extensions["3DTILES_implicit_tiling"],delete t.extensions["3DTILES_multiple_contents"],0===Object.keys(t.extensions).length&&delete t.extensions),delete t.implicitTiling,delete t.contents,delete t.content,t}const MortonOrder={};function insertOneSpacing(e){return e=1431655765&((e=858993459&((e=252645135&((e=16711935&(e^e<<8))^e<<4))^e<<2))^e<<1)}function insertTwoSpacing(e){return e=153391689&((e=51130563&((e=50393103&((e=50331903&(e^e<<16))^e<<8))^e<<4))^e<<2)}function removeOneSpacing(e){return e=65535&((e=16711935&((e=252645135&((e=858993459&((e&=1431655765)^e>>1))^e>>2))^e>>4))^e>>8)}function removeTwoSpacing(e){return e=1023&((e=4278190335&((e=50393103&((e=51130563&((e&=153391689)^e>>2))^e>>4))^e>>8))^e>>16)}MortonOrder.encode2D=function(e,t){return(insertOneSpacing(e)|insertOneSpacing(t)<<1)>>>0},MortonOrder.decode2D=function(e,t){return defined$2(t)||(t=new Array(2)),t[0]=removeOneSpacing(e),t[1]=removeOneSpacing(e>>1),t},MortonOrder.encode3D=function(e,t,i){return insertTwoSpacing(e)|insertTwoSpacing(t)<<1|insertTwoSpacing(i)<<2},MortonOrder.decode3D=function(e,t){return defined$2(t)||(t=new Array(3)),t[0]=removeTwoSpacing(e),t[1]=removeTwoSpacing(e>>1),t[2]=removeTwoSpacing(e>>2),t};const scratchCoordinatesArray=[0,0,0];class ImplicitTileCoordinates{constructor(e){this.subdivisionScheme=e.subdivisionScheme,this.subtreeLevels=e.subtreeLevels,this.level=e.level,this.x=e.x,this.y=e.y,this.z=void 0,e.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE&&(this.z=e.z)}getDescendantCoordinates(e){const t=this.level+e.level,i=(this.x<<e.level)+e.x,n=(this.y<<e.level)+e.y;if(this.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE){const r=(this.z<<e.level)+e.z;return new ImplicitTileCoordinates({subdivisionScheme:this.subdivisionScheme,subtreeLevels:this.subtreeLevels,level:t,x:i,y:n,z:r})}return new ImplicitTileCoordinates({subdivisionScheme:this.subdivisionScheme,subtreeLevels:this.subtreeLevels,level:t,x:i,y:n})}getAncestorCoordinates(e){const t=1<<e,i=this.level-e,n=Math.floor(this.x/t),r=Math.floor(this.y/t);if(this.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE){const e=Math.floor(this.z/t);return new ImplicitTileCoordinates({subdivisionScheme:this.subdivisionScheme,subtreeLevels:this.subtreeLevels,level:i,x:n,y:r,z:e})}return new ImplicitTileCoordinates({subdivisionScheme:this.subdivisionScheme,subtreeLevels:this.subtreeLevels,level:i,x:n,y:r})}getOffsetCoordinates(e){const t=e.level-this.level,i=1<<t,n=e.x%i,r=e.y%i;if(this.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE){const s=e.z%i;return new ImplicitTileCoordinates({subdivisionScheme:this.subdivisionScheme,subtreeLevels:this.subtreeLevels,level:t,x:n,y:r,z:s})}return new ImplicitTileCoordinates({subdivisionScheme:this.subdivisionScheme,subtreeLevels:this.subtreeLevels,level:t,x:n,y:r})}getChildCoordinates(e){const t=this.level+1,i=2*this.x+e%2,n=2*this.y+Math.floor(e/2)%2;if(this.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE){const r=2*this.z+Math.floor(e/4)%2;return new ImplicitTileCoordinates({subdivisionScheme:this.subdivisionScheme,subtreeLevels:this.subtreeLevels,level:t,x:i,y:n,z:r})}return new ImplicitTileCoordinates({subdivisionScheme:this.subdivisionScheme,subtreeLevels:this.subtreeLevels,level:t,x:i,y:n})}getSubtreeCoordinates(){return this.getAncestorCoordinates(this.level%this.subtreeLevels)}getParentSubtreeCoordinates(){return this.getAncestorCoordinates(this.level%this.subtreeLevels+this.subtreeLevels)}isAncestor(e){const t=e.level-this.level;if(t<=0)return!1;const i=e.x>>t,n=e.y>>t,r=this.x===i,s=this.y===n;if(this.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE){const i=e.z>>t,n=this.z===i;return r&&s&&n}return r&&s}isEqual(e){return this.subdivisionScheme===e.subdivisionScheme&&this.subtreeLevels===e.subtreeLevels&&this.level===e.level&&this.x===e.x&&this.y===e.y&&(this.subdivisionScheme!==ImplicitSubdivisionScheme.OCTREE||this.z===e.z)}isImplicitTilesetRoot(){return 0===this.level}isSubtreeRoot(){return this.level%this.subtreeLevels===0}isBottomOfSubtree(){return this.level%this.subtreeLevels===this.subtreeLevels-1}getTemplateValues(){const e={level:this.level,x:this.x,y:this.y};return this.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE&&(e.z=this.z),e}static fromMortonIndex(e,t,i,n){let r;return e===ImplicitSubdivisionScheme.OCTREE?(r=MortonOrder.decode3D(n,scratchCoordinatesArray),new ImplicitTileCoordinates({subdivisionScheme:e,subtreeLevels:t,level:i,x:r[0],y:r[1],z:r[2]})):(r=MortonOrder.decode2D(n,scratchCoordinatesArray),new ImplicitTileCoordinates({subdivisionScheme:e,subtreeLevels:t,level:i,x:r[0],y:r[1]}))}static fromTileIndex(e,t,i){let n,r,s;return e===ImplicitSubdivisionScheme.OCTREE?(n=Math.floor(Math.log2(7*i+1)/3),r=((1<<3*n)-1)/7,s=i-r):(n=Math.floor(Math.log2(3*i+1)/2),r=((1<<2*n)-1)/3,s=i-r),ImplicitTileCoordinates.fromMortonIndex(e,t,n,s)}get childIndex(){let e=0;return e|=1&this.x,e|=(1&this.y)<<1,this.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE&&(e|=(1&this.z)<<2),e}get mortonIndex(){return this.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE?MortonOrder.encode3D(this.x,this.y,this.z):MortonOrder.encode2D(this.x,this.y)}get tileIndex(){return(this.subdivisionScheme===ImplicitSubdivisionScheme.OCTREE?((1<<3*this.level)-1)/7:((1<<2*this.level)-1)/3)+this.mortonIndex}}const _norm=new three.Vector3,_norm2=new three.Vector3,_cartographic=new three.Vector3,_pos=new three.Vector3;function getRegionGeometry(e){const{latStart:t=-Math.PI/2,latEnd:i=Math.PI/2,lonStart:n=0,lonEnd:r=2*Math.PI,heightStart:s=0,heightEnd:a=0}=e,o=new three.BoxGeometry(1,1,1,32,32),{normal:l,position:c}=o.attributes,h=c.clone();for(let u=0;u<c.count;++u){_pos.fromBufferAttribute(c,u);const o=three.MathUtils.mapLinear(_pos.x,-.5,.5,t,i),l=three.MathUtils.mapLinear(_pos.y,-.5,.5,n,r);let h=s;_pos.z<0&&(h=a),e.cartographicToCartesian(_cartographic.set(l,o,h),_pos),c.setXYZ(u,..._pos)}o.computeVertexNormals();for(let u=0,d=h.count;u<d;u++){_pos.fromBufferAttribute(h,u);const s=three.MathUtils.mapLinear(_pos.x,-.5,.5,t,i),a=three.MathUtils.mapLinear(_pos.y,-.5,.5,n,r);_norm.fromBufferAttribute(l,u),e.geodeticSurfaceNormalCartographic(_cartographic.set(a,s,0),_norm2),Math.abs(_norm.dot(_norm2))>.1&&(_pos.z>0&&_norm2.multiplyScalar(-1),l.setXYZ(u,..._norm2))}return o}new three.Vector3,new three.Vector3;class EllipsoidRegionLineHelper extends three.LineSegments{constructor(e=new EllipsoidRegion,t=16776960){super(),this.ellipsoidRegion=e,this.material.color.set(t),this.update()}update(){const e=getRegionGeometry(this.ellipsoidRegion);this.geometry.dispose(),this.geometry=new three.EdgesGeometry(e,80)}dispose(){this.geometry.dispose(),this.material.dispose()}}const _vector$2=new three.Vector3,axes=["x","y","z"];class SphereHelper extends three.LineSegments{constructor(e,t=16776960,i=40){const n=new three.BufferGeometry,r=[];for(let s=0;s<3;s++){const e=axes[s],t=axes[(s+1)%3];_vector$2.set(0,0,0);for(let n=0;n<i;n++){let s;s=2*Math.PI*n/(i-1),_vector$2[e]=Math.sin(s),_vector$2[t]=Math.cos(s),r.push(_vector$2.x,_vector$2.y,_vector$2.z),s=2*Math.PI*(n+1)/(i-1),_vector$2[e]=Math.sin(s),_vector$2[t]=Math.cos(s),r.push(_vector$2.x,_vector$2.y,_vector$2.z)}}n.setAttribute("position",new three.BufferAttribute(new Float32Array(r),3)),n.computeBoundingSphere(),super(n,new three.LineBasicMaterial({color:t,toneMapped:!1})),this.sphere=e,this.type="SphereHelper"}updateMatrixWorld(e){const t=this.sphere;this.position.copy(t.center),this.scale.setScalar(t.radius),super.updateMatrixWorld(e)}}const ORIGINAL_MATERIAL=Symbol("ORIGINAL_MATERIAL"),emptyRaycast=()=>{},colors={};function getIndexedRandomColor(e){if(!colors[e]){const t=Math.random(),i=.5+.5*Math.random(),n=.375+.25*Math.random();colors[e]=(new three.Color).setHSL(t,i,n)}return colors[e]}const NONE=0;class DebugTilesPlugin{constructor(e){e={displayBoxBounds:!1,displaySphereBounds:!1,displayRegionBounds:!0,colorMode:NONE,maxDebugDepth:-1,maxDebugDistance:-1,maxDebugError:-1,customColorCallback:null,...e},this.name="DEBUG_TILES_PLUGIN",this.tiles=null,this.extremeDebugDepth=-1,this.extremeDebugError=-1,this.boxGroup=null,this.sphereGroup=null,this.regionGroup=null,this.displayBoxBounds=e.displayBoxBounds,this.displaySphereBounds=e.displaySphereBounds,this.displayRegionBounds=e.displayRegionBounds,this.colorMode=e.colorMode,this.maxDebugDepth=e.maxDebugDepth,this.maxDebugDistance=e.maxDebugDistance,this.maxDebugError=e.maxDebugError,this.customColorCallback=e.customColorCallback,this.getDebugColor=(e,t)=>{t.setRGB(e,e,e)}}init(e){this.tileset=e;const t=e.group;this.boxGroup=new three.Group,this.boxGroup.name="DebugTilesRenderer.boxGroup",t.add(this.boxGroup),this.boxGroup.updateMatrixWorld(),this.sphereGroup=new three.Group,this.sphereGroup.name="DebugTilesRenderer.sphereGroup",t.add(this.sphereGroup),this.sphereGroup.updateMatrixWorld(),this.regionGroup=new three.Group,this.regionGroup.name="DebugTilesRenderer.regionGroup",t.add(this.regionGroup),this.regionGroup.updateMatrixWorld(),this._onLoadTileSetCB=e=>{},this._onLoadTileCB=({scene:e,tile:t})=>{this._onLoadTile(t)},this._onDisposeTileCB=({tile:e})=>{this._onDisposeTile(e)},this._onUpdateAfterCB=()=>{this._onUpdateAfter()},this._onTileVisibilityChangeCB=({scene:e,tile:t,visible:i})=>{this._onTileVisibilityChange(t,i)},e.addEventListener("loaded",this._onLoadTileCB),e.addEventListener("dispose",this._onDisposeTileCB),e.addEventListener("update-after",this._onUpdateAfterCB),e.addEventListener("visibilitychange",this._onTileVisibilityChangeCB),e.traversalLoadedTile(((e,t)=>{this._onLoadTile(t)})),e._selectedTiles.forEach((e=>{this._onTileVisibilityChange(e,!0)}))}_onLoadTile(e){const t=e.content,i=e.boundingVolume,{obb:n,sphere:r,region:s,regionObb:a}=i,o=e.tileset._selectedTiles;if(n){const i=new three.Group;i.name="DebugTilesRenderer.boxHelperGroup",i.matrix.copy(n.transform),i.matrixAutoUpdate=!1;const r=new three.Box3Helper(n.box,getIndexedRandomColor(e._depth));r.raycast=emptyRaycast,i.add(r),t.boxHelperGroup=i,o.includes(e)&&this.displayBoxBounds&&(this.boxGroup.add(i),i.updateMatrixWorld())}if(r){const i=new SphereHelper(r,getIndexedRandomColor(e._depth));i.raycast=emptyRaycast,t.sphereHelper=i,o.includes(e)&&this.displaySphereBounds&&(this.boxGroup.add(i),i.updateMatrixWorld())}if(s){const i=new EllipsoidRegionLineHelper(s,getIndexedRandomColor(e._depth));i.raycast=emptyRaycast;const n=a.center;i.position.copy(n);const r=n.clone().multiplyScalar(-1);i.geometry.translate(...r),t.regionHelper=i,o.includes(e)&&this.displayRegionBounds&&(this.regionGroup.add(i),i.updateMatrixWorld(!0))}t.traverse((e=>{const t=e.material;t&&(e[ORIGINAL_MATERIAL]=t)}))}_onDisposeTile(e){const t=e.content;t.boxHelperGroup&&(t.boxHelperGroup.removeFromParent(),t.boxHelperGroup.children[0].geometry.dispose(),delete t.boxHelperGroup),t.sphereHelper&&(t.sphereHelper.removeFromParent(),t.sphereHelper.geometry.dispose(),delete t.sphereHelper),t.regionHelper&&(t.regionHelper.removeFromParent(),t.regionHelper.geometry.dispose(),delete t.regionHelper)}_initExtremes(e){}_onUpdateAfter(){this.tileset.root&&(this.boxGroup.visible=this.displayBoxBounds,this.sphereGroup.visible=this.displaySphereBounds,this.regionGroup.visible=this.displayRegionBounds)}_onTileVisibilityChange(e,t){const i=e.content,n=this.sphereGroup,r=this.boxGroup,s=this.regionGroup,a=i.boxHelperGroup,o=i.sphereHelper,l=i.regionHelper;t?(a&&(r.add(a),a.updateMatrixWorld(!0)),o&&(n.add(o),o.updateMatrixWorld(!0)),l&&(s.add(l),l.updateMatrixWorld(!0))):(a&&r.remove(a),o&&n.remove(o),l&&s.remove(l))}dispose(){const e=this.tileset;e.removeEventListener("loaded",this._onLoadTileCB),e.removeEventListener("dispose",this._onDisposeModelCB),e.removeEventListener("update-after",this._onUpdateAfterCB),e.removeEventListener("visibilitychange",this._onTileVisibilityChangeCB),e.traversalLoadedTile(((e,t)=>{this._onDisposeTile(t)})),this.boxGroup.removeFromParent(),this.sphereGroup.removeFromParent(),this.regionGroup.removeFromParent()}}const _mat=new three.Matrix4,_localRay=new three.Ray,_vec=new three.Vector3,_hitArray=[];function distanceSort(e,t){return e.distance-t.distance}function intersectTileScene(e,t,i){e.traverse((e=>{Object.getPrototypeOf(e).raycast.call(e,t,i)})),_hitArray.sort(distanceSort)}function intersectTilesSceneFirstHist(e,t){intersectTileScene(e,t,_hitArray);const i=_hitArray[0]||null;return _hitArray.length=0,i}function raycastTraverseFirstHit(e,t,i,n=null){const{group:r}=e,s=t.content;null===n&&(n=_localRay,_mat.copy(r.matrixWorld).invert(),n.copy(i.ray).applyMatrix4(_mat));const a=[],o=t.children;for(let u=0;u<o.length;u++){const t=o[u];if(t._touchedFrame!==e._updatedVisibilityFrame)continue;null!==t.boundingVolume.intersectRay(n,_vec)&&(_vec.applyMatrix4(r.matrixWorld),a.push({distance:_vec.distanceToSquared(i.ray.origin),tile:t}))}a.sort(distanceSort);let l=null,c=null;const h=!t.isVisible&&t._touchedFrame===e._updatedVisibilityFrame;if((t.__visible||h)&&t.hasRenderableContent&&s){const e=intersectTilesSceneFirstHist(s.scene,i);e&&(l=e,c=Math.pow(e.distance,2))}for(let u=0,d=a.length;u<d;u++){const t=a[u],r=t.distance,s=t.tile;if(r>c)break;const o=raycastTraverseFirstHit(e,s,i,n);if(o){const e=o.distance*o.distance;e<c&&(l=o,c=e)}}return l}function raycastTraverse(e,t,i,n,r=null){const{group:s}=e,{content:a,boundingVolume:o}=t;if(null===r&&(r=_localRay,_mat.copy(s.matrixWorld).invert(),r.copy(i.ray).applyMatrix4(_mat)),t._touchedFrame!==e._updatedVisibilityFrame||!o.intersectsRay(r))return;const l=!t.isVisible&&t._touchedFrame===e._updatedVisibilityFrame;if((t.__visible||l)&&t.hasRenderableContent&&a)if(a.isMultiple3DTileContents){a._contents.forEach((e=>{const t=e.scene;t&&intersectTileScene(t,i,n)}))}else{intersectTileScene(a.scene,i,n)}const c=t.children;for(let h=0;h<c.length;h++)raycastTraverse(e,c[h],i,n,r)}class ElementsManager{constructor(e){__publicField(this,"_tileMaxLevel",19),__publicField(this,"_subscribedMaxLodLevel",1),__publicField(this,"_elementHandlers",[]),__publicField(this,"_objectParent",null),__publicField(this,"subscribedDataTypeMap",{}),__publicField(this,"_active",!1),__publicField(this,"_configVersion",0),__publicField(this,"shouldIgnoreTile",(e=>e.__lodLevel>this._subscribedMaxLodLevel)),__publicField(this,"parseElements",(e=>{const t=e.cached.scene,i=t.batchTable&&t.batchTable.header;if(!i)return;if(!i.id||!i.dataType)return;const n=i.id,r=i.dataType,s={},a=new Map;let o=null,l=null,c=null;for(let h=0,u=r.length;h<u;h++){if(!this.subscribedDataTypeMap[r[h]])continue;o=r[h],l=this.subscribedDataTypeMap[o],c=n[h];const e={id:c,dataType:o,position:[],uv:[],normal:[],index:[]};s[h]=e;const t=a.get(l);t?t.push(e):a.set(l,[e])}for(const h of t.children)this.findElementInMesh(h,s,a);for(const h of a.keys()){const t=a.get(h);h.addTileElementObjects(e,t)}})),__publicField(this,"getInterleavedBufferValue2",((e,t)=>{const i=e.data.array,n=e.data.stride*t+e.offset;return[i[n],i[n+1]]})),__publicField(this,"getInterleavedBufferValue3",((e,t)=>{const i=e.data.array,n=e.data.stride*t+e.offset;return[i[n],i[n+1],i[n+2]]})),__publicField(this,"findElementInMesh",((e,t,i)=>{if(!e||!e.geometry)return;const n=e.geometry.getAttribute("_batchid");if(!n)return;const r=e.geometry.getAttribute("normal");if(!r)return;const s=e.geometry.getAttribute("position"),a=e.geometry.getAttribute("uv"),o=n.data.count,l={};let c=null;for(let u=0;u<o;u++){if(c=n.getX(u),!t[c])continue;let e=t[c],i=this.getInterleavedBufferValue3(s,u),o=this.getInterleavedBufferValue3(r,u),h=this.getInterleavedBufferValue2(a,u);e.position.push(i[0],i[1],i[2]),e.normal.push(o[0],o[1],o[2]),e.uv.push(h[0],h[1]),l[u]={batchId:c,index:e.position.length/3-1}}const h=e.geometry.index.array;for(let u=0,d=h.length-2;u<d;u+=3){let e=h[u];if(void 0===l[e])continue;let i=h[u+1],n=h[u+2],r=l[e],s=r.batchId,a=r.index,o=l[i]&&l[i].index,c=l[n]&&l[n].index;if(void 0===o||void 0===c){console.warn("one face includes more than one object");continue}t[s].index.push(a,o,c)}for(const u of Object.keys(t)){const e=t[u],i=new three.BufferGeometry;i.setAttribute("position",new three.BufferAttribute(new Float32Array(e.position),3)),i.setAttribute("normal",new three.BufferAttribute(new Float32Array(e.normal),3)),i.setAttribute("uv",new three.BufferAttribute(new Float32Array(e.uv),2)),i.setIndex(e.index),e.geometry=i}})),__publicField(this,"onTileLoad",((e,t)=>{this.parseTileInfo(e),this.shouldIgnoreTile(e)})),__publicField(this,"onTileDispose",((e,t)=>{if(!this.shouldIgnoreTile(e))for(const i of this._elementHandlers)i.disposeTileElementObjects(e)})),__publicField(this,"onTileShow",(e=>{this._active&&!this.shouldIgnoreTile(e)&&this.refreshTile(e)})),__publicField(this,"onTileHide",(e=>{if(this._active&&!this.shouldIgnoreTile(e))for(const t of this._elementHandlers)t.hideTileElementObjects(e)})),__publicField(this,"parseTileInfo",(e=>{const t=e._contentResource.url,i=t.substring(t.lastIndexOf("/")+1).split(".")[0],n=i.split("-");e.__id=i,e.__level=parseInt(n[0],10),e.__lodLevel=this._tileMaxLevel-e.__level})),__publicField(this,"refreshTile",(e=>{if(e.__elementsConfigVersion!==this._configVersion){for(const t of this._elementHandlers)t.disposeTileElementObjects(e);this.parseElements(e),e.__elementsConfigVersion=this._configVersion}for(const t of this._elementHandlers)t.showTileElementObjects(e)})),__publicField(this,"refreshTiles",(()=>{this.tilesRenderer.forEachLoadedModel(((e,t)=>{t.__visible&&!this.shouldIgnoreTile(t)&&this.refreshTile(t)})),this.engine.requestRender()})),this._objectParent=e}registerElement(e){e.parent=this._objectParent,e.engine=this.engine;for(const t of e.subscribedDataTypeIds)this.subscribedDataTypeMap[t]=e;return this._elementHandlers.push(e),this._configVersion++,this._active=!0,this.refreshTiles(),e}unregisterElement(e){for(let i of Object.keys(this.subscribedDataTypeMap))this.subscribedDataTypeMap[i]===e&&delete this.subscribedDataTypeMap[i];let t=this._elementHandlers.indexOf(e);t>-1&&(e.dispose(),this._elementHandlers.splice(t,1)),this._configVersion++,this._active=this._elementHandlers.length>0,this.refreshTiles()}tick(e){if(this._active)for(const t of this._elementHandlers)t.tick(e)}get subscribedMaxLodLevel(){return this._subscribedMaxLodLevel}set subscribedMaxLodLevel(e){this._subscribedMaxLodLevel=e}}class TilesetMetadata{constructor(e){const t=(e=defaultValue$1(e,{})).tileset,i=e.class,n=defined$2(t.properties)?t.properties:{};this._class=i,this._properties=n,this._extras=t.extras,this._extensions=t.extensions}hasProperty(e){return MetadataEntity.hasProperty(e,this._properties,this._class)}hasPropertyBySemantic(e){return MetadataEntity.hasPropertyBySemantic(e,this._properties,this._class)}getPropertyIds(e){return MetadataEntity.getPropertyIds(this._properties,this._class,e)}getProperty(e){return MetadataEntity.getProperty(e,this._properties,this._class)}setProperty(e,t){return MetadataEntity.setProperty(e,t,this._properties,this._class)}getPropertyBySemantic(e){return MetadataEntity.getPropertyBySemantic(e,this._properties,this._class)}setPropertyBySemantic(e,t){return MetadataEntity.setPropertyBySemantic(e,t,this._properties,this._class)}get class(){return this._class}get extra(){return this._extras}get extensions(){return this._extensions}}class GroupMetadata{constructor(e={}){e=defaultValue$1(e,{});const{id:t,group:i,class:n}=e;this._id=t,this._class=n,this._properties=defined$2(i.properties)?i.properties:{},this._extras=i.extras,this._extensions=i.extensions}get class(){return this._class}get id(){return this._id}get extras(){return this._extras}get extensions(){return this._extensions}hasProperty(e){return MetadataEntity.hasProperty(e,this._properties,this._class)}hasPropertyBySemantic(e){return MetadataEntity.hasPropertyBySemantic(e,this._properties,this._class)}getPropertyIds(e){return MetadataEntity.getPropertyIds(this._properties,this._class,e)}getProperty(e){return MetadataEntity.getProperty(e,this._properties,this._class)}setProperty(e,t){return MetadataEntity.setProperty(e,t,this._properties,this._class)}getPropertyBySemantic(e){return MetadataEntity.getPropertyBySemantic(e,this._properties,this._class)}setPropertyBySemantic(e,t){return MetadataEntity.setPropertyBySemantic(e,t,this._properties,this._class)}}class Cesium3DTilesetMetadata{constructor(e){const t=(e=defaultValue$1(e,{})).metadataJson,i=e.schema,n=defaultValue$1(t.metadata,t.tileset);let r;defined$2(n)&&(r=new TilesetMetadata({tileset:n,class:i.classes[n.class]}));let s=[];const a=[],o=t.groups;if(Array.isArray(o)){const e=o.length;for(let t=0;t<e;t++){const e=o[t];a.push(new GroupMetadata({group:e,class:i.classes[e.class]}))}}else if(defined$2(o)){s=Object.keys(o).sort();const e=s.length;for(let t=0;t<e;t++){const e=s[t];if(o.hasOwnProperty(e)){const t=o[e];a.push(new GroupMetadata({id:e,group:o[e],class:i.classes[t.class]}))}}}this._schema=i,this._groups=a,this._groupIds=s,this._tileset=r,this._statistics=t.statistics,this._extras=t.extras,this._extensions=t.extensions}get schema(){return this._schema}get groups(){return this._groups}get groupIds(){return this._groupIds}get tileset(){return this._tileset}get statistics(){return this._statistics}get extras(){return this._extras}get extensions(){return this._extensions}}const defaultAccessToken="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1ZjJlYTllMy1kYWRiLTQwYjctOGZhOS02NGJkOTJhYTA1ODUiLCJpZCI6MjU5LCJpYXQiOjE3Mjc3OTI2NzB9.XbfI79d1v3T5OpMl4CznrcBuctSfW1lycPWlt8bq_1A",Ion={};function retryCallback(e,t){const i=defaultValue$1(e._ionRoot,e),n=i._ionEndpointResource,r="undefined"!=typeof Image;return defined$2(t)&&(401===t.statusCode||r&&t.target instanceof Image)?(defined$2(i._pendingPromise)||(i._pendingPromise=n.fetchJson().then((function(e){return i._ionEndpoint=e,e})).finally((function(e){return i._pendingPromise=void 0,e}))),i._pendingPromise.then((function(t){return e._ionEndpoint=t,!0}))):Promise.resolve(!1)}Ion.defaultAccessToken=defaultAccessToken,Ion.defaultServer=new Resource({url:"https://api.cesium.com/"});const _IonResource=class extends Resource{constructor(e,t){let i;const n=e.externalType,r=defined$2(n);if(r){if("3DTILES"!==n&&"STK_TERRAIN_SERVER"!==n)throw new Error("Ion.createResource does not support external imagery assets; use IonImageryProvider instead.");i={url:e.options.url}}else i={url:e.url,retryAttempts:1,retryCallback:retryCallback};super(i),this._ionEndpoint=e,this._ionEndpointDomain=r?void 0:new Uri(e.url).authority(),this._ionEndpointResource=t,this._ionRoot=void 0,this._pendingPromise=void 0,this._credits=void 0,this._isExternal=r}static fromAssetId(e,t){const i=_IonResource._createEndpointResource(e,t);return i.fetchJson().then((function(e){return new _IonResource(e,i)}))}clone(e){const t=defaultValue$1(this._ionRoot,this);return defined$2(e)||(e=new _IonResource(t._ionEndpoint,t._ionEndpointResource)),(e=Resource.prototype.clone.call(this,e))._ionRoot=t,e._isExternal=this._isExternal,e}fetchImage(e){if(!this._isExternal){const t=e;e={preferBlob:!0},defined$2(t)&&(e.flipY=t.flipY,e.preferImageBitmap=t.preferImageBitmap)}return Resource.prototype.fetchImage.call(this,e)}_makeRequest(e){return this._isExternal||new Uri(this.url).authority()!==this._ionEndpointDomain||(defined$2(e.headers)||(e.headers={}),e.headers.Authorization=`Bearer ${this._ionEndpoint.accessToken}`,e.headers["X-Cesium-Client"]="CesiumJS","undefined"!=typeof CESIUM_VERSION&&(e.headers["X-Cesium-Client-Version"]=CESIUM_VERSION)),Resource.prototype._makeRequest.call(this,e)}};let IonResource=_IonResource;__publicField(IonResource,"_createEndpointResource",(function(e,t){t=defaultValue$1(t,{});let i=defaultValue$1(t.server,Ion.defaultServer);const n=defaultValue$1(t.accessToken,Ion.defaultAccessToken);i=Resource.createIfNeeded(i);const r={url:`v1/assets/${e}/endpoint`};return defined$2(n)&&(r.queryParameters={access_token:n}),i.getDerivedResource(r)}));const tempMatrix$1=new three.Matrix4,childMatrix=new three.Matrix4,scratchTranslation=new three.Vector3,scratchRotation$1=new three.Vector3;class InstancedModel extends three.Object3D{constructor(e,t){if(super(),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"isInstancedModel",!0),__publicField(this,"_meshes",[]),__publicField(this,"_idIndexMap",{}),__publicField(this,"_indexIdMap",{}),__publicField(this,"_matrixAttribute",null),__publicField(this,"_count",0),__publicField(this,"_rtc",null),__publicField(this,"updateRenderingMesh",(()=>{this._cleanOldMesh();const e=this._meshes,t=e.length;for(let i=0;i<t;++i){const t=e[i],n=new three.InstancedMesh(t.geometry,t.material);n.__eventProxyByParent=!0,n.castShadow=t.castShadow,n.receiveShadow=t.receiveShadow,n.parent=this,n.name=t.name,this.add(n),t.isInstancedMesh&&(n._isOriginalInstancedMesh=!0,n._rawInstanceMatrix=t.instanceMatrix,n._rawCount=t.count)}})),__publicField(this,"_cleanOldMesh",(()=>{const e=this.children;for(let t=e.length-1;t>=0;t--){const i=e[t];this.remove(i),i.dispose()}})),e)this._meshes=e;else{const e=this._defaultMesh=new three.Mesh(new three.BoxGeometry(1,1,1),new three.MeshBasicMaterial({color:16777215}));this._meshes=[e]}this.updateRenderingMesh(),this._matrixAttribute=new three.InstancedBufferAttribute(new Float32Array(16*t),16),this._initialized=!0}afterAddToEngine(e){this.engine=e}beforeRemoveFromEngine(e){this.dispose()}getEntityByIndex(e){const t=this._indexIdMap[e];if(void 0===t)return null;const i={id:t,index:e};return i.matrix=this._matrixAttribute.array.slice(16*e,16*(e+1)),i}has(e){return void 0!==this._idIndexMap[e]}clear(){this._idIndexMap={},this._indexIdMap={},this._rtc=null}setBufferData(e){if(this.clear(),!e)return;const t=e.id.length;0!==t&&(this.count=t,e.instanceMatrix?this._matrixAttribute.array.set(e.instanceMatrix,16*this._count):this.computeTempMatrix(e))}computeTempMatrix(e){const t=e.id,i=e.translation,n=e.scale,r=e.rotation,s=this._matrixAttribute.array;let a=new three.Matrix4,o=new three.Vector3,l=new three.Vector3,c=new three.Euler,h=new three.Quaternion,u=null,d=null,p=this._rtc;p||(i?(p=[i[0],i[1],i[2]],this._rtc=p,this.position.set(p[0],p[1],p[2])):p=[0,0,0]);for(let m=0;m<this._count;m++){let e=3*m;if(n?l.set(n[e],n[e+1],n[e+2]):l.set(1,1,1),i?o.set(i[e]-p[0],i[e+1]-p[1],i[e+2]-p[2]):o.set(0,0,0),scratchRotation$1.set(0,0,0),r&&scratchRotation$1.set(r[e],r[e+1],r[e+2]),this.engine&&this.engine.map.isGlobe){const t={heading:-scratchRotation$1.z,pitch:-scratchRotation$1.y,roll:scratchRotation$1.x},n=Transforms.headingPitchRollToFixedFrame(scratchTranslation.set(i[e],i[e+1],i[e+2]),t);c.setFromRotationMatrix(n,"ZYX")}else c.set(scratchRotation$1.x,scratchRotation$1.y,scratchRotation$1.z,"ZYX");h.setFromEuler(c),a.compose(o,h,l),e=16*m;const f=a.elements;for(let t=0;t<16;t++)s[e+t]=f[t];u=t[m],d=m,this._idIndexMap[u]=d,this._indexIdMap[d]=u}}update(){if(!this._initialized)return;const e=this.children;this._matrixAttribute.needsUpdate=!0;for(const t of e){if(t._isOriginalInstancedMesh){const e=t._rawCount*this._count,i=new Float32Array(16*e);for(let n=0;n<this._count;n++){tempMatrix$1.fromArray(this._matrixAttribute.array,16*n);for(let e=0;e<t._rawCount;e++)childMatrix.fromArray(t._rawInstanceMatrix.array,16*e),childMatrix.multiplyMatrices(tempMatrix$1,childMatrix),i.set(childMatrix.elements,16*(n*t._rawCount+e))}t.instanceMatrix=new three.InstancedBufferAttribute(i,16),t.count=e}else t.instanceMatrix=this._matrixAttribute,t.count=this._count;t.frustumCulled=!1,t.computeBoundingSphere(),t.instanceMatrix.needsUpdate=!0}}dispose(){this._cleanOldMesh(),this._defaultMesh&&(this._defaultMesh.geometry.dispose(),this._defaultMesh.material.dispose())}raycast(e,t){this.visible?this.traverse((e=>{e.isMesh&&e._originRaycast&&(e.raycast=e._originRaycast,delete e._originRaycast)})):this.traverse((e=>{e.isMesh&&!e._originRaycast&&(e._originRaycast=e.raycast,e.raycast=()=>{})}))}set needsUpdate(e){e&&this.update()}set count(e){e!==this._count&&(this._count=e,this._matrixAttribute=new three.InstancedBufferAttribute(new Float32Array(16*e),16))}get count(){return this._count}set meshes(e){e&&(Array.isArray(e)?this._meshes=e:e.isMesh?this._meshes=[e]:e.isGroup&&(this._meshes=e.children),this.updateRenderingMesh(),this.update())}get meshes(){return this._meshes}}const tempMatrix=new three.Matrix4,normalizeModel=e=>{const t=new three.Box3;t.setFromObject(e);const i=Math.max(t.max.x-t.min.x,t.max.y-t.min.y,t.max.z-t.min.z);e.scale.multiplyScalar(1/i)},rotateToZUp=e=>{e.rotation.x=Math.PI/2},applyTransformToGeometry=e=>{if(e.isInstancedMesh)for(let t=0;t<e.count;t++)tempMatrix.fromArray(e.instanceMatrix.array,16*t),tempMatrix.multiplyMatrices(e.matrixWorld,tempMatrix),e.instanceMatrix.array.set(tempMatrix.elements,16*t);else if(e.isSkinnedMesh)e.skeleton.pose(),e.geometry.applyMatrix4(e.bindMatrixInverse),e.geometry.applyMatrix4(e.matrixWorld);else if(e.isMesh)e.geometry.applyMatrix4(e.matrixWorld);else if(e.isBone)e.matrixWorld.decompose(e.position,e.quaternion,e.scale);else if(e.children.length>0)for(const t of e.children)applyTransformToGeometry(t);e.position.set(0,0,0),e.scale.set(1,1,1),e.quaternion.set(0,0,0,1)},collectMesh=(e,t)=>{if(e.isMesh||e.isBone)t.push(e);else if(e.children.length>0)for(const i of e.children)collectMesh(i,t)},parseScene=(e,t,i)=>{t&&normalizeModel(e),i&&rotateToZUp(e),e.updateMatrixWorld(),applyTransformToGeometry(e),e.updateMatrixWorld();const n=[];return collectMesh(e,n),n},parseLODModel=(e,t,i)=>{const n=[];for(const r of e){const e=r.name;if(!e.startsWith("lod"))continue;const s=parseInt(e.substring(3),10);if(isNaN(s))continue;const a=parseScene(r,t,i);n[s]=a}return n},model=Object.freeze(Object.defineProperty({__proto__:null,parseLODModel:parseLODModel,parseScene:parseScene},Symbol.toStringTag,{value:"Module"}));let _box$1=new three.Box3,_vector$1=new three.Vector3;class CustomInstancedBufferGeometry extends three.InstancedBufferGeometry{constructor(){super(...arguments),__publicField(this,"isCustomInstancedBufferGeometry",!0),__publicField(this,"instanceGeometry",null)}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new three.Box3);const e=this.attributes.instancedPosition;void 0!==e?this.boundingBox.setFromBufferAttribute(e):this.boundingBox.makeEmpty(),(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('CustomInstancedBufferGeometry.computeBoundingBox: Computed min/max have NaN values.The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new three.Sphere);let e=this.attributes.instancedPosition;if(e){let t=this.boundingSphere.center;_box$1.setFromBufferAttribute(e),_box$1.getCenter(t);let i=0;for(let n=0,r=e.count;n<r;n++)_vector$1.fromBufferAttribute(e,n),i=Math.max(i,t.distanceToSquared(_vector$1));this.boundingSphere.radius=Math.sqrt(i),1===e.count&&(this.boundingSphere.radius=1e5),isNaN(this.boundingSphere.radius)&&console.error('CustomInstancedBufferGeometry.computeBoundingSphere(): Computed radius is NaN.The "position" attribute is likely to have NaN values.',this)}}getInstanceGeometry(){return this.instanceGeometry||(this.instanceGeometry=new three.BufferGeometry,this.instanceGeometry.attributes=this.attributes,this.instanceGeometry.index=this.index),this.instanceGeometry}}class InstancedBillboardBufferGeometry extends CustomInstancedBufferGeometry{constructor(){super(),__publicField(this,"setModelData",(()=>{this.setAttribute("position",new three.Float32BufferAttribute([-.5,0,0,-.5,0,1,.5,0,1,.5,0,0],3)),this.setAttribute("uv",new three.Float32BufferAttribute([0,0,0,1,1,1,1,0],2)),this.setIndex([0,2,1,0,3,2])})),this.setModelData()}}const vertexShader$g="#define GLSLIFY 1\n#include <common>\n\nuniform vec2 imposterFrames;\nuniform vec3 positionOffset;\nuniform bool isFullSphere;\nuniform float imposterScale;\nuniform float offsetZ;\n\n#ifdef IS_GLOBE\n    attribute mat4 ecefMatrix;\n    varying mat4 vEcefMatrix;\n#endif\n\n// 传递给片元着色器的变量\nvarying vec2 vUv;\nvarying vec2 grid_classic;\nvarying vec4 quad_blend_weights;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vCenterWorldPosition;\nvarying vec3 vViewDir;\nvarying mat3 vTBN;\nvarying mat3 vRotationMatrix;\n\n// 八面体映射函数 - 全球模式\nvec2 VecToSphereOct(vec3 pivotToCamera) {\n    vec3 octant = sign(pivotToCamera);\n    float sum = dot(abs(pivotToCamera), vec3(1.0));\n    vec3 octahedron = pivotToCamera / sum;\n\n    if (octahedron.y < 0.0) {\n        vec3 absolute = abs(octahedron);\n        octahedron.xz = octant.xz * vec2(1.0 - absolute.z, 1.0 - absolute.x);\n    }\n    return octahedron.xz;\n}\n\n// 八面体映射函数 - 半球模式\nvec2 VecToHemiSphereOct(vec3 pivotToCamera) {\n    vec3 octant = sign(pivotToCamera);\n    float sum = dot(abs(pivotToCamera), vec3(1.0));\n    vec3 octahedron = pivotToCamera / sum;\n\n    return vec2(\n        octahedron.x + octahedron.y,\n        octahedron.y - octahedron.x\n    );\n}\n      \n\n// 根据模式选择合适的映射函数\nvec2 VectorToGrid(vec3 vec) {\n    if (isFullSphere) {\n        return VecToSphereOct(vec);\n    } else {\n        return VecToHemiSphereOct(vec);\n    }\n}\n\n// 从帧坐标转换回射线方向\nvec3 OctaSphereEnc(vec2 coord) {\n    coord = (coord - 0.5) * 2.0;\n    vec3 position = vec3(coord.x, 0.0, coord.y);\n    vec2 absolute = abs(position.xz);\n    position.y = 1.0 - absolute.x - absolute.y;\n\n    if (position.y < 0.0) {\n        position.xz = sign(position.xz) * vec2(1.0 - absolute.y, 1.0 - absolute.x);\n    }\n\n    return position;\n}\n\nvec3 OctaHemiSphereEnc(vec2 coord) {\n    vec3 position = vec3(coord.x - coord.y, -1.0 + coord.x + coord.y, 0);\n    vec2 absolute = abs(position.xy);\n    position.z = 1.0 - absolute.x - absolute.y;\n\n    return position;\n}\n\nvec3 GridToVector(vec2 coord) {\n    if (isFullSphere) {\n        return OctaSphereEnc(coord);\n    } else {\n        return OctaHemiSphereEnc(coord);\n    }\n}\n\nvec3 FrameXYToRay(vec2 frame, vec2 frameCountMinusOne) {\n    vec2 f = frame.xy / frameCountMinusOne;\n    vec3 vec = GridToVector(f);\n    vec = normalize(vec);\n    return vec;\n}\n\n// 计算三角形混合权重\nvec4 quadBlendWieghts(vec2 coords) {\n    vec4 res;\n    res.x = min(1.0 - coords.x, 1.0 - coords.y);\n    res.y = abs(coords.x - coords.y);\n    res.z = min(coords.x, coords.y);\n    res.w = step(0.0, coords.x - coords.y); // Three.js中使用step替代ceil\n    res.xyz /= (res.x + res.y + res.z);\n    return res;\n}\n\nfloat branchFreeTernary(bool comparison, float a, float b) {\n    float useA = float(comparison);\n    return a * useA + b * (1.0 - useA);\n}\n\nfloat fastApproximateAtan(float x) {\n    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);\n}\n\nfloat fastApproximateAtan(float x, float y) {\n    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.\n    // So range-reduce using abs and by flipping whether x or y is on top.\n    float t = abs(x); // t used as swap and atan result.\n    float opposite = abs(y);\n    float adjacent = max(t, opposite);\n    opposite = min(t, opposite);\n\n    t = fastApproximateAtan(opposite / adjacent);\n\n    // Undo range reduction\n    t = branchFreeTernary(abs(y) > abs(x), PI / 2.0 - t, t);\n    t = branchFreeTernary(x < 0.0, PI - t, t);\n    t = branchFreeTernary(y < 0.0, -t, t);\n    return t;\n}\n\nvec3 SpriteProjection(vec3 viewDir, float frames, vec2 size, vec2 coord) {\n    vec3 worldUp = vec3(0.0, 0.0, 1.0); // 假设Z轴是世界上方向\n    \n    vec3 z = normalize(viewDir);\n    \n    //  顶视图和z平行，效果不好\n    vec3 x = normalize(cross(worldUp, z));\n    vec3 y = normalize(cross(z, x));\n    if (abs(dot(worldUp, z)) > 0.99) {\n        x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n        y = normalize(cross(z, x));\n    }\n    \n    vec2 uv = ((coord * frames) - 0.5) * 2.0;\n    \n    vec3 newX = x * uv.x * size.x;\n    vec3 newY = y * uv.y * size.y;\n    \n    return newX + newY;\n}\n\nmat4 removeRotation(mat4 matrix) {\n    // 提取缩放部分\n    vec3 scale;\n    scale.x = length(matrix[0].xyz);\n    scale.y = length(matrix[1].xyz);\n    scale.z = length(matrix[2].xyz);\n\n    // 构建无旋转但保留缩放的矩阵\n    mat3 scaleMatrix = mat3(\n        vec3(scale.x, 0.0, 0.0),\n        vec3(0.0, scale.y, 0.0),\n        vec3(0.0, 0.0, scale.z)\n    );\n\n    // 构建新的 matrix，去掉旋转部分\n    mat4 newMatrix = mat4(\n        vec4(scaleMatrix[0], 0.0),\n        vec4(scaleMatrix[1], 0.0),\n        vec4(scaleMatrix[2], 0.0),\n        matrix[3] // 保持原来的平移部分\n    );\n\n    return newMatrix;\n}\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main () {\n    #include <mvt_selective_vertex>\n\n    vec3 scaleSize;\n    scaleSize.x = imposterScale * length(instanceMatrix[0].xyz);\n    scaleSize.y = imposterScale * length(instanceMatrix[1].xyz);\n    scaleSize.z = imposterScale * length(instanceMatrix[2].xyz);\n\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    #ifdef IS_GLOBE\n        up = vec3(ecefMatrix[2][0], ecefMatrix[2][1], ecefMatrix[2][2]);\n    #endif\n\n    // 创建一个z轴平移10个单位的平移矩阵\n    mat4 translationMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        up * scaleSize.z * (1.0 + offsetZ), 1.0\n    );\n\n    mat4 currentInstanceMatrix = removeRotation(instanceMatrix);\n\n    // 将平移矩阵与instanceMatrix相乘\n    mat4 translatedInstanceMatrix = currentInstanceMatrix * translationMatrix;\n\n    vec4 worldPosition = modelMatrix * translatedInstanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n    // 相机与 plane 的方向向量\n    vec3 toCamera = normalize(cameraPosition - worldPosition.xyz);\n\n    float angleZ = fastApproximateAtan(instanceMatrix[1][0], instanceMatrix[0][0]);\n    float c = cos(angleZ);\n    float s = sin(angleZ);\n    mat3 rotZ = mat3(\n        vec3(  c,  -s,  0.0),\n        vec3(  s,   c,  0.0),\n        vec3(0.0, 0.0,  1.0)\n    );\n    vRotationMatrix = rotZ;\n\n    #ifdef IS_GLOBE\n        mat4 ecefMatrixInverse = inverse(ecefMatrix);\n        toCamera = (ecefMatrixInverse * vec4(toCamera, 0.0)).xyz;\n\n        vEcefMatrix = ecefMatrix;\n    #endif\n\n    vec3 pivotToCameraRay = normalize(rotZ * toCamera);\n\n    // 计算八面体映射坐标\n    vec2 framesMinusOne = imposterFrames - vec2(1.0);\n    vec2 grid = VectorToGrid(pivotToCameraRay);\n    grid = clamp((grid + 1.0) * 0.5, vec2(0.0), vec2(1.0));\n    grid *= framesMinusOne;\n    vec2 gridFloor = floor(grid);\n\n    // 计算混合权重\n    quad_blend_weights = quadBlendWieghts(fract(grid));\n    grid_classic = gridFloor;\n\n    // 计算顶点的新位置\n    vec2 texcoord = uv * (1.0 / imposterFrames.x);\n    vec2 size = vec2(scaleSize.xy);\n    \n    // 从纹理图集帧计算方向向量\n    vec3 projectedQuadARray = FrameXYToRay(gridFloor, framesMinusOne);\n    vec3 projectedQuadBRray = FrameXYToRay(\n        gridFloor + mix(vec2(0.0, 1.0), vec2(1.0, 0.0), quad_blend_weights.w), \n        framesMinusOne\n    );\n    vec3 projectedQuadCRray = FrameXYToRay(gridFloor + vec2(1.0), framesMinusOne);\n    \n    // 混合方向向量\n    vec3 projectedQuadRay = \n        projectedQuadARray * quad_blend_weights.x +\n        projectedQuadBRray * quad_blend_weights.y +\n        projectedQuadCRray * quad_blend_weights.z;\n    \n    // 计算投影坐标\n    vec3 projected = SpriteProjection(\n        normalize(toCamera), \n        imposterFrames.x, \n        size, \n        texcoord.xy\n    );\n\n    vec3 N = normalize(projectedQuadRay);\n    vec3 T = normalize(cross(N, vec3(0.0, 1.0, 0.0)));\n    vec3 B = normalize(cross(T, N));\n    vTBN = transpose(mat3(T, B, N));\n\n    vec3 transformed = projected;\n\n    vec3 worldPositionVertex = (modelMatrix * translatedInstanceMatrix * vec4(position, 1.0)).xyz;\n    vec3 toCameraFromPosition = normalize(cameraPosition - worldPositionVertex.xyz);\n    vViewPosition = -toCameraFromPosition;\n\n    #ifdef IS_GLOBE\n        vWorldPosition = (modelMatrix * translatedInstanceMatrix * ecefMatrix * vec4(transformed, 1.0)).xyz;\n        vCenterWorldPosition = (currentInstanceMatrix * ecefMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * translatedInstanceMatrix * ecefMatrix * vec4(transformed, 1.0);\n    #else \n        vWorldPosition = (modelMatrix * translatedInstanceMatrix * vec4(transformed, 1.0)).xyz;\n        vCenterWorldPosition = (currentInstanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n\n        gl_Position = projectionMatrix * modelViewMatrix * translatedInstanceMatrix * vec4(transformed, 1.0);\n    #endif\n\n    vUv = uv;\n    #include <logdepthbuf_vertex>\n}",fragmentShader$e="#define GLSLIFY 1\n#include <common>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_selective_pars_fragment>\n\nuniform vec2 imposterFrames;\nuniform bool isTransparent;\nuniform float alphaClamp;\nuniform float depthScale;\nuniform float normalmapDepth;\nuniform vec3 color;\nuniform float metallic;\nuniform float roughness;\nuniform float specular;\nuniform mat3 normalMatrix;\nuniform float worldPositionScale;\n\n// 颜色变化控制参数\nuniform float colorVariationStrength; // 颜色变化强度 (0.0-1.0)\nuniform vec3 yellowTint;              // 偏黄色调 (默认: vec3(1.2, 1.1, 0.8))\nuniform vec3 greenTint;               // 偏绿色调 (默认: vec3(0.8, 1.3, 0.9))\nuniform vec3 darkTint;                // 偏暗色调 (默认: vec3(0.6, 0.7, 0.5))\nuniform float gradientFalloff;\n\n// 纹理\nuniform sampler2D imposterBaseTexture;\nuniform sampler2D imposterNormalDepthTexture;\nuniform sampler2D imposterORMTexture;\n\nvarying vec3 vCameraViewPosition;\n\nvarying vec2 vUv;\nvarying vec2 grid_classic;\nvarying vec4 quad_blend_weights;\nvarying vec3 vViewPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vCenterWorldPosition;\nvarying mat3 vTBN;\nvarying mat4 vEcefMatrix;\nvarying mat3 vRotationMatrix;\n\n// 随机数生成函数\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// 基于3D位置的随机数\nfloat random3D(vec3 pos) {\n    vec3 localPos = pos;\n\n    #ifdef IS_GLOBE\n        mat4 ecefMatrixInverse = inverse(vEcefMatrix);\n        localPos = (ecefMatrixInverse * vec4(worldPos, 1.0)).xyz;\n    #endif\n\n    return random(localPos.xy);\n}\n\n// 生成随机颜色变化\nvec3 generateColorVariation(vec3 worldPos) {\n    // 使用世界坐标作为随机种子，确保同一位置的树颜色一致\n    vec3 seed = floor(worldPos * 10.0) * 0.1;\n    \n    float rand1 = random3D(seed);\n    float rand2 = random3D(seed + vec3(1.0, 0.0, 0.0));\n    float rand3 = random3D(seed + vec3(0.0, 1.0, 0.0));\n    \n    vec3 colorTint = vec3(1.0); // 默认无变化\n    \n    if (rand1 < 0.5) {\n        // 大部分偏绿色\n        colorTint = mix(vec3(1.0), greenTint, colorVariationStrength);\n    } else if (rand1 < 0.75) {\n        // 偏黄色\n        colorTint = mix(vec3(1.0), yellowTint, colorVariationStrength);\n    } else {\n        // 偏暗色\n        colorTint = mix(vec3(1.0), darkTint, colorVariationStrength);\n    }\n    \n    vec3 microVariation = vec3(\n        0.9 + rand2 * 0.2,  // 0.9 - 1.1\n        0.9 + rand3 * 0.2,  // 0.9 - 1.1\n        0.9 + random3D(seed + vec3(0.0, 0.0, 1.0)) * 0.2  // 0.9 - 1.1\n    );\n\n    // vec3 baseColorVariation = colorTint * microVariation;\n    vec3 baseColorVariation = colorTint;\n    return baseColorVariation;\n}\n\n// 采样并混合纹理\nvec4 blendedColor(vec2 uv, vec2 grid_pos, vec4 grid_weights, sampler2D atlasTexture) {\n    vec4 res;\n    vec2 quad_size = vec2(1.0) / imposterFrames;\n    vec2 uv_quad_a = quad_size * grid_pos;\n    uv_quad_a += uv / imposterFrames;\n\n    vec2 uv_quad_b = uv_quad_a + quad_size * mix(\n        vec2(0.0, 1.0), \n        vec2(1.0, 0.0), \n        quad_blend_weights.w\n    );\n    vec2 uv_quad_c = uv_quad_a + quad_size;\n\n    vec4 quad_a = texture2D(atlasTexture, uv_quad_a);\n    vec4 quad_b = texture2D(atlasTexture, uv_quad_b);\n    vec4 quad_c = texture2D(atlasTexture, uv_quad_c);\n\n    res = quad_a * grid_weights.x + quad_b * grid_weights.y + quad_c * grid_weights.z;\n    return res;\n}\n\nvoid main() {\n    \n    vec3 toCamera = cameraPosition - vWorldPosition;\n    #ifdef IS_GLOBE\n        mat4 ecefMatrixInverse = inverse(vEcefMatrix);\n        toCamera = (ecefMatrixInverse * vec4(toCamera, 0.0)).xyz;\n    #endif\n    toCamera = vRotationMatrix * toCamera;\n    vec3 viewDir = normalize(vTBN * toCamera);\n    \n    // 视差映射偏移\n    vec2 base_uv = vUv;\n    float depth = blendedColor(base_uv, grid_classic, quad_blend_weights, imposterNormalDepthTexture).a;\n    base_uv -= vec2(viewDir.xy) / viewDir.z * ((depth) * depthScale * 2.0);\n    \n    // // 采样混合纹理\n    vec4 baseTex = blendedColor(base_uv, grid_classic, quad_blend_weights, imposterBaseTexture);\n\n    if (baseTex.a < 0.5) {\n        discard;\n    }\n    vec4 normalTex = blendedColor(base_uv, grid_classic, quad_blend_weights, imposterNormalDepthTexture);\n    vec4 ormTex = blendedColor(base_uv, grid_classic, quad_blend_weights, imposterORMTexture);\n\n    // 光照计算\n    vec3 viewLightDir = directionalLights[0].direction;\n    vec3 lightColor = directionalLights[0].color;\n    float lightIntensity = 1.0;\n\n    vec3 normalDir = normalTex.xyz;\n    #ifdef IS_GLOBE\n        normalDir = (ecefMatrixInverse * vec4(normalDir, 0.0)).xyz;\n    #endif\n    normalDir = normalMatrix * normalDir;\n\n    // 计算漫反射光照\n    float normalLightIntensity = max(dot(normalDir, normalize(viewLightDir)), 0.0);\n    vec3 diffuseLight = normalLightIntensity * lightColor * lightIntensity;\n\n    // 环境光 (简单实现)\n    vec3 ambientLight = 0.2 * lightColor;\n    float vRounghness = ormTex.g * roughness;\n\n    // 计算镜面反射 (简单Blinn-Phong模型)\n    vec3 viewDir1 = normalize(vViewPosition);\n    vec3 halfVector = normalize(viewLightDir + viewDir1);\n    #ifdef IS_GLOBE\n        halfVector = (ecefMatrixInverse * vec4(halfVector, 0.0)).xyz;\n    #endif\n    float specularIntensity = max(dot(normalTex.xyz, halfVector), 0.0);\n    vec3 specularLight = max(specularIntensity, 0.2) * lightColor * 0.3 * (1.0 - vRounghness);\n\n    // 基于金属度和粗糙度调整漫反射和镜面反射\n    vec3 baseColor = baseTex.rgb;\n    vec3 diffuseContrib = baseColor * (1.0 - metallic);\n    vec3 specularContrib = vec3(0.04) * specularLight;\n\n    // 组合所有光照贡献\n    vec3 finalColor = (ambientLight + diffuseLight) * diffuseContrib + specularContrib;\n\n    // 应用随机颜色变化\n    vec3 colorVariation = generateColorVariation(vCenterWorldPosition / worldPositionScale);\n    finalColor *= colorVariation;\n    \n    finalColor = clamp(finalColor, 0.0, 1.0);\n\n    // // 输出最终颜色\n    gl_FragColor = vec4(finalColor, baseTex.a);\n\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <mvt_selective_fragment>\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}",uniforms$h=three.UniformsUtils.merge([three.UniformsLib.lights,{imposterFrames:{value:new three.Vector2(16,16)},positionOffset:{value:new three.Vector3(0,0,0)},isFullSphere:{value:!1},isTransparent:{value:!1},alphaClamp:{value:.5},imposterScale:{value:3},depthScale:{value:.01},normalmapDepth:{value:1},color:{value:new three.Color(1,1,1)},imposterBaseTexture:{value:null},imposterNormalDepthTexture:{value:null},imposterORMTexture:{value:null},metallic:{value:0},roughness:{value:1},specular:{value:.5},colorVariationStrength:{value:1},yellowTint:{value:new three.Vector3(1.2,1.1,.8)},greenTint:{value:new three.Vector3(.8,1.2,.9)},darkTint:{value:new three.Vector3(.6,.7,.5)},gradientFalloff:{value:1},verticalGradientStrength:{value:2},worldPositionScale:{value:2e3},offsetZ:{value:0}}]);class OctahedralImpostorMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="OctahedralImpostorMaterial",this.vertexShader=vertexShader$g,this.fragmentShader=fragmentShader$e,this.side=three.DoubleSide,this.lights=!0,this.transparent=!1,defineMaterialNormalProperties(this,["imposterScale","imposterBaseTexture","imposterNormalDepthTexture","imposterORMTexture","offsetZ"]),defineMaterialBoolDefineProperties(this,[["isGlobe","IS_GLOBE"]]),Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$h)),this.setValues(e)}}let _box3=new three.Box3,_sphere$1=new three.Sphere,_instanceLocalMatrix=new three.Matrix4,_instanceWorldMatrix=new three.Matrix4,_instancePositionMatrix=new three.Matrix4;const _instanceMatrix=new three.Matrix4,_rtcMatrix=new three.Matrix4,_rotationMatrix=new three.Matrix4;let _tempMatrix=new three.Matrix4,_tempMesh=new three.Mesh,_instanceIntersects=[],_vector3=new three.Vector3,_vector4$1=new three.Vector4;const scratchRotation=new three.Vector3,rotationMatrixScratch$1=new three.Matrix4,positionScratch$3=new three.Vector3,_instanceEcefMatrix=new three.Matrix4;class GeoInstancedMesh extends GeoObject{constructor(e,t,i){super(),__publicField(this,"type","InstancedMesh"),__publicField(this,"isMesh",!0),__publicField(this,"isInstancedMesh",!0),__publicField(this,"frustumCulled",!1),__publicField(this,"instanceColor",null),__publicField(this,"count",0),__publicField(this,"instanceMatrix"),__publicField(this,"morphTexture",null),__publicField(this,"_enableInstanceColor",!1),__publicField(this,"instanceMorphMatrix",new three.Matrix4),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"boundingBox",null),__publicField(this,"boundingSphere",null),__publicField(this,"getInstanceLocalMatrix",((e,t,i,n)=>null)),__publicField(this,"getEcefTransformMatrix",((e,t,i)=>{const n=this.engine.map.isGlobe,r=new three.Matrix4;if(n){const t=Transforms.eastNorthUpToFixedFrame(positionScratch$3.fromArray(e)),i=rotationMatrixScratch$1.extractRotation(t);r.multiply(i)}return r})),__publicField(this,"addCustomAttributes",(()=>{})),this.parameters=Object.assign({},i),this.geometry=e,this.material=t,this.instanceMatrix=new three.InstancedBufferAttribute(new Float32Array(0),16)}set enableInstanceColor(e){e!==this._enableInstanceColor&&(this._enableInstanceColor=e,this.needsUpdate=!0)}get enableInstanceColor(){return this._enableInstanceColor}collisionTest(e){let t=this.material.keepSize?this.size:0;return{width:t,height:t}}_updateData(){const{visiblePropName:e="visible",vertexVisible:t=!1}=this.parameters,i=this.engine.map.isGlobe;let n=[];n=this._enableCollision&&this._collisionData?this._collisionData:this.dataSource.userData;const r=[],s=[],a=[],o=[];let l=1/0,c=1/0,h=1/0,u=-1/0,d=-1/0,p=-1/0;for(let f=0;f<n.length;f++){const e=n[f].position,[t,i,r=0]=e;t<l&&(l=t),t>u&&(u=t),i<c&&(c=i),i>d&&(d=i),r<h&&(h=r),r>p&&(p=r)}let m=[(l+u)/2,(c+d)/2,(h+p)/2||0];for(let f=0;f<n.length;f++){const l=n[f].position;n[f].index;const c=n[f][e];if(t&&!1===c)continue;const h=this.dataSource.getDataItem(f),u=this.getInstanceLocalMatrix(l,h,f,n[f]);_rtcMatrix.makeTranslation(l[0]-m[0],l[1]-m[1],(l[2]||0)-m[2]);const d=this.getEcefTransformMatrix(l,h,f);_instanceMatrix.identity(),this.constructor===GeoInstancedMesh&&(_rotationMatrix.extractRotation(d),_instanceMatrix.multiplyMatrices(_instanceMatrix,_rotationMatrix)),u&&_instanceMatrix.multiplyMatrices(_instanceMatrix,u),_instanceMatrix.multiplyMatrices(_rtcMatrix,_instanceMatrix);const p=_instanceMatrix.elements;if(r.push(p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7],p[8],p[9],p[10],p[11],p[12],p[13],p[14],p[15]),i){const e=d.elements;s.push(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}if(a.push(Math.random()),this._enableInstanceColor){let e=colorToArr4(n[f].color);o.push(e[0],e[1],e[2])}}i&&this.geometry.setAttribute("ecefMatrix",new three.InstancedBufferAttribute(new Float32Array(s),16)),this.geometry.setAttribute("instancedRandomFactor",new three.InstancedBufferAttribute(new Float32Array(a),1)),this.addCustomAttributes(this.geometry,this.dataSource),this.geometry.computeBoundingSphere(),this.geometry.instanceCount=r.length/16,this.instanceMatrix=new three.InstancedBufferAttribute(new Float32Array(r),16),this._enableInstanceColor&&(this.instanceColor=new three.InstancedBufferAttribute(new Float32Array(o),3)),this.originCenter=(new three.Vector3).fromArray(m),this.count=this.geometry.instanceCount,this.makeMeshPositionOffset(m),this.needsUpdate=!1}setBufferData(e){if(!e)return;const t=e.id.length;0!==t&&(this.count=t,this.geometry.instanceCount=t,e.instanceMatrix?this.instanceMatrix=new three.InstancedBufferAttribute(new Float32Array(e.instanceMatrix),16):this.computeTempMatrix(e))}computeTempMatrix(e){const t=this.engine.map.isGlobe;e.id;const i=e.translation,n=e.scale,r=e.rotation,s=[],a=[];let o=new three.Matrix4,l=new three.Vector3,c=new three.Vector3,h=new three.Euler,u=new three.Quaternion,d=1/0,p=1/0,m=1/0,f=-1/0,g=-1/0,_=-1/0;for(let v=0;v<this.count;v++){let e=3*v;const t=i[e],n=i[e+1],r=i[e+2];t<d&&(d=t),t>f&&(f=t),n<p&&(p=n),n>g&&(g=n),r<m&&(m=r),r>_&&(_=r)}let A=[(d+f)/2,(p+g)/2,(m+_)/2||0];for(let v=0;v<this.count;v++){let e=3*v;n?c.set(n[e],n[e+1],n[e+2]):c.set(1,1,1),i?l.set(i[e]-A[0],i[e+1]-A[1],i[e+2]-A[2]):l.set(0,0,0),scratchRotation.set(0,0,0),r&&scratchRotation.set(r[e],r[e+1],r[e+2]);const d=[i[e],i[e+1],i[e+2]];if(t){const e=this.getEcefTransformMatrix(d).elements;a.push(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}h.set(scratchRotation.x,scratchRotation.y,scratchRotation.z,"ZYX"),u.setFromEuler(h),o.compose(l,u,c),e=16*v;const p=o.elements;for(let t=0;t<16;t++)s[e+t]=p[t]}t&&this.geometry.setAttribute("ecefMatrix",new three.InstancedBufferAttribute(new Float32Array(a),16)),this.geometry.computeBoundingSphere(),this.instanceMatrix=new three.InstancedBufferAttribute(new Float32Array(s),16),this.makeMeshPositionOffset(A)}computeBoundingBox(){const e=this.geometry,t=this.count;null===this.boundingBox&&(this.boundingBox=new three.Box3),null===e.boundingBox&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<t;i++)this.getMatrixAt(i,_instanceLocalMatrix),_box3.copy(e.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const e=this.geometry,t=this.count;null===this.boundingSphere&&(this.boundingSphere=new three.Sphere),null===e.boundingSphere&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<t;i++)this.getMatrixAt(i,_instanceLocalMatrix),_sphere$1.copy(e.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere$1)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}computeInstanceMorphMatrix(e){const t=this.material;let i=t.height||0;e=e||t.zoomUnits;let n=1;if(t.keepSize&&(n=e||1),t.isUseSize3){const e=t.size3;_vector3.set(e[0]*n,e[1]*n,e[2]*n)}else if(t.isUseSize2){const e=t.size2;_vector3.set(e[0]*n,e[1]*n,n)}else{let e=t.size||1;_vector3.set(e*n,e*n,e*n)}this.instanceMorphMatrix.identity().scale(_vector3).premultiply(_tempMatrix.identity().makeTranslation(0,0,i*n))}getEntityByIndex(e){const t=this.dataSource;this._enableCollision&&this._collisionData&&(e=this._collisionData[e].index);const i={index:e,value:t.getDataItem(e),itemIndex:t.getDataItemIndex(e),pairs:{}},n=t.data;for(const r of Object.keys(n))i.pairs[r]=n[r][e];return i}getPixelSize(e){const{camera:t,rendering:i}=this.engine;return t.isOrthographicCamera?i.uniforms.zoomUnits.value:.2*t.projectionMatrix.elements[5]/i.resolution.y*t.position.distanceTo(e)}raycast(e,t){if(!this.visible)return;let i=this.geometry,n=this.material,r=this.matrixWorld;const s=this.engine.map.isGlobe;if(!n||!i)return;const a=this.instanceMatrix;if(!a)return;const o=a.array;s||this.computeInstanceMorphMatrix();const l=this.count;if(_tempMesh.geometry=this.geometry.getInstanceGeometry?this.geometry.getInstanceGeometry():this.geometry,_tempMesh.material=n,n.isInstancedBallonMaterial){const i=e.camera,s=n.resolution,a=e.mouse,c=n.size/s[0],h=n.size/s[1],u=2*(n.height+n.size/2)/s[1],d=a.x-c,p=a.x+c,m=a.y-h-u,f=a.y+h-u;_tempMatrix.multiplyMatrices(i.matrixWorldInverse,r),_tempMatrix.multiplyMatrices(i.projectionMatrix,_tempMatrix);for(let n=0;n<l;++n)if(_instancePositionMatrix.fromArray(o,16*n),_vector4$1.set(0,0,0,1).applyMatrix4(_instancePositionMatrix).applyMatrix4(_tempMatrix).divideScalar(_vector4$1.w),_vector4$1.x>=d&&_vector4$1.y>=m&&_vector4$1.x<=p&&_vector4$1.y<=f){_vector3.set(_instancePositionMatrix.elements[12],_instancePositionMatrix.elements[13],_instancePositionMatrix.elements[14]);const i=e.ray.origin.distanceTo(_vector3);i>=e.near&&i<=e.far&&(_instanceIntersects[0]={distance:i,point:_vector3.clone(),itemIndex:n,object:this},t.push(_instanceIntersects[0]),_instanceIntersects.length=0)}}else{let i=null;if(s){const e=this.geometry.getAttribute("ecefMatrix");e&&(i=e.array)}for(let n=0;n<l;++n){if(_instanceWorldMatrix.fromArray(o,16*n),s&&i){_instanceEcefMatrix.fromArray(i,16*n);const e=_instancePositionMatrix.makeTranslation(_instanceWorldMatrix.elements[12],_instanceWorldMatrix.elements[13],_instanceWorldMatrix.elements[14]),t=_instanceLocalMatrix.copy(_instanceWorldMatrix);t.elements[12]=0,t.elements[13]=0,t.elements[14]=0,_instanceWorldMatrix.multiplyMatrices(e,_instanceEcefMatrix),_instanceWorldMatrix.multiply(t)}if(_instanceWorldMatrix.multiplyMatrices(r,_instanceWorldMatrix),s){const e=_vector3.setFromMatrixPosition(_instanceWorldMatrix),t=this.getPixelSize(e);this.computeInstanceMorphMatrix(t)}_instanceWorldMatrix.multiply(this.instanceMorphMatrix),_tempMesh.matrixWorld=_instanceWorldMatrix,_tempMesh.raycast(e,_instanceIntersects),_instanceIntersects.length>0&&(_instanceIntersects[0].instanceId=n,_instanceIntersects[0].object=this,t.push(_instanceIntersects[0]),_instanceIntersects.length=0)}}}}const loader=new three.ImageBitmapLoader;loader.setOptions({imageOrientation:"flipY",premultiplyAlpha:"none"});const _OctahedralImpostor=class extends GeoInstancedMesh{constructor(e={}){super(e),__publicField(this,"onBeforeSceneRender",(()=>{this.dataSource?super.onBeforeSceneRender():this.onBeforeScenePrepareRenderHook()})),__publicField(this,"getInstanceLocalMatrix",((e,t,i,n)=>{const r=new three.Matrix4,s=this._createRotationMatrix(n.rotation),a=this._createScaleMatrix(n.scale);return r.multiplyMatrices(a,s),r})),this.parameters=e,this.offsetZ=e.offsetZ||0,this.modelDistance=e.modelDistance||0,this.imposterScale=e.imposterScale||3,this.hasLastResult=!1,this.lastCameraPosition=null,this._texturesInitialized=!1,this._geometryInitialized=!1,this.defineMaterialProxyProperties(["imposterScale"])}static _getBitmap(e){const t=this._bitmapPromises,i=t.get(e);if(i)return i;const n=new Promise(((t,i)=>{this.imageBitmapLoader.load(e,t,void 0,i)}));return t.set(e,n),n}static async initDefaultTextures(){this.defaultTextures.diffuse&&this.defaultTextures.normalDepth&&this.defaultTextures.orm||(this._defaultTexturesPromise||(this._defaultTexturesPromise=(async()=>{const e=getAssetUrl("assets/textures/imposter/tree2/base.webp"),t=getAssetUrl("assets/textures/imposter/tree2/norm_depth.webp"),i=getAssetUrl("assets/textures/imposter/tree2/orm.webp"),{diffuseTexture:n,normalDepthTexture:r,ormTexture:s}=await _OctahedralImpostor.createTextures(e,t,i);this.defaultTextures.diffuse=n,this.defaultTextures.normalDepth=r,this.defaultTextures.orm=s})()),await this._defaultTexturesPromise)}static async createTextures(e,t,i){var n,r,s;const a=_OctahedralImpostor;if(a[e]&&a[t]&&a[i])return{diffuseTexture:a[e],normalDepthTexture:a[t],ormTexture:a[i]};const[o,l,c]=await Promise.all([this._getBitmap(e),this._getBitmap(t),this._getBitmap(i)]);return{diffuseTexture:null!=(n=a[e])?n:(()=>{const t=new three.Texture(o);return t.flipY=!0,t.colorSpace=three.SRGBColorSpace,t.wrapS=t.wrapT=three.ClampToEdgeWrapping,t.minFilter=t.magFilter=three.LinearFilter,t.needsUpdate=!0,a[e]=t,t})(),normalDepthTexture:null!=(r=a[t])?r:(()=>{const e=new three.Texture(l);return e.flipY=!0,e.needsUpdate=!0,a[t]=e,e})(),ormTexture:null!=(s=a[i])?s:(()=>{const e=new three.Texture(c);return e.flipY=!0,e.needsUpdate=!0,a[i]=e,e})()}}async initialize(){var e;await this.initTextures(),this._initImposter(),this._initModelInstances(),this.material.isGlobe=(null==(e=this.engine.map)?void 0:e.isGlobe)||!1,this._geometryInitialized=!0}async initTextures(){if(!this._texturesInitialized){if(this.parameters.diffuse&&this.parameters.normalDepth&&this.parameters.orm){const{diffuseTexture:e,normalDepthTexture:t,ormTexture:i}=await _OctahedralImpostor.createTextures(this.parameters.diffuse,this.parameters.normalDepth,this.parameters.orm);this.diffuseTexture=e,this.normalDepthTexture=t,this.ormTexture=i}else await _OctahedralImpostor.initDefaultTextures(),this.diffuseTexture=_OctahedralImpostor.defaultTextures.diffuse,this.normalDepthTexture=_OctahedralImpostor.defaultTextures.normalDepth,this.ormTexture=_OctahedralImpostor.defaultTextures.orm;this._texturesInitialized=!0}}_initImposter(){const{diffuse:e,normalDepth:t,orm:i,...n}=this.parameters;this.geometry=new InstancedBillboardBufferGeometry(this.parameters),this.material=new OctahedralImpostorMaterial(n),this.material.imposterBaseTexture=this.diffuseTexture,this.material.imposterNormalDepthTexture=this.normalDepthTexture,this.material.imposterORMTexture=this.ormTexture}_initModelInstances(){const{modelGeometry:e,modelMaterial:t}=this.parameters;e&&t&&(this.modelInstanceMesh=new GeoInstancedMesh(e,t),this.modelDataSource=GeoJSONDataSource.fromGeoJSON([]),this.engine.add(this.modelInstanceMesh))}_updateData(){this.modelDistance<=0&&this._updateBufferData()}_updateBufferData(){const e=this.engine.camera,t=this.dataSource.data,i=this.modelDistance,n=i*i;this.lastCameraPosition||(this.lastCameraPosition=e.position.clone(),this.hasLastResult=!1);(e.position.distanceTo(this.lastCameraPosition)>.1*i||!this.hasLastResult)&&(this._partitionAndUpdateInstanceData(e,t,n),this.hasLastResult=!0,this.lastCameraPosition.copy(e.position))}_partitionAndUpdateInstanceData(e,t,i){const n=[],r=[],s=[],a=[],o=[],l=[],c=[],h=[],u=t.position.length;for(let d=0;d<u;d++){const u=t.position[d];this._calculateSquareDistance(u,e.position)>i?(n.push(...u),r.push(1,1,1),s.push(0,0,0),a.push("id_"+d)):(o.push(...u),l.push(1,1,1),c.push(0,0,0),h.push("id_"+d))}this.setBufferData({translation:n,scale:r,rotation:s,id:a}),this.modelInstanceMesh&&this.modelInstanceMesh.setBufferData({translation:o,scale:l,rotation:c,id:h})}_calculateSquareDistance(e,t){return(e[0]-t.x)**2+(e[1]-t.y)**2+(e[2]-t.z)**2}onBeforeScenePrepareRenderHook(){if(this.modelDistance<=0)return;const{modelGeometry:e,modelMaterial:t}=this.parameters;e&&t&&this._updateBufferData()}_createRotationMatrix(e){const t=new three.Matrix4;return"number"==typeof e?t.makeRotationZ(e):Array.isArray(e)?t.makeRotationFromEuler(new three.Euler(e[1],e[2],e[3])):e instanceof three.Vector3&&t.makeRotationFromEuler(new three.Euler(e.x,e.y,e.z)),t}_createScaleMatrix(e){const t=new three.Matrix4;return"number"==typeof e?t.makeScale(e,e,e):Array.isArray(e)?t.makeScale(e[0],e[1],e[2]):e instanceof three.Vector3&&t.makeScale(e.x,e.y,e.z),t}};let OctahedralImpostor=_OctahedralImpostor;__publicField(OctahedralImpostor,"imageBitmapLoader",loader),__publicField(OctahedralImpostor,"defaultTextures",{diffuse:null,normalDepth:null,orm:null}),__publicField(OctahedralImpostor,"_defaultTexturesPromise",null),__publicField(OctahedralImpostor,"_bitmapPromises",new Map);const ANCHOR=["bottom","left","top","right","center"];function decodeColor(e){return[e>>24&255,e>>16&255,e>>8&255,(255&e)/255]}function getMercatorScaleFactor(e){return 1/Math.cos(Math.PI*e/180)}let _tempPointScratch=[],_scaleFactorScratch=1;class TileInstancedElementManager{constructor(){__publicField(this,"_lastUpdateTime",0),__publicField(this,"_updateDelayTimerHander",null),__publicField(this,"_configVersion",0),__publicField(this,"_poiConfigVersion",0),__publicField(this,"_poiConfig",{poi:{enabled:!0},label:{enabled:!0}}),__publicField(this,"_config",{tree:{enabled:!1,isFoliage:!0,isBox:!1,scaleByZ:!1,instances:[{subtype:"shrub",diffuseTexture:getAssetUrl("assets/textures/imposter/tree3/base.webp"),normalDepthTexture:getAssetUrl("assets/textures/imposter/tree3/norm_depth.webp"),ormTexture:getAssetUrl("assets/textures/imposter/tree3/orm.webp"),imposterScale:1,uvOffset:-.2},{subtype:"arbor",diffuseTexture:getAssetUrl("assets/textures/imposter/tree2/base.webp"),normalDepthTexture:getAssetUrl("assets/textures/imposter/tree2/norm_depth.webp"),ormTexture:getAssetUrl("assets/textures/imposter/tree2/orm.webp"),imposterScale:5,uvOffset:0},{subtype:"0",imposterScale:5,uvOffset:0},{subtype:"1",imposterScale:5,uvOffset:0},{subtype:"2",imposterScale:5,uvOffset:0},{subtype:"3",imposterScale:5,uvOffset:0}]}}),__publicField(this,"_labelEnabled",!1),__publicField(this,"_poiEnabled",!1),__publicField(this,"_generateModelMesh",(async e=>new Promise(((t,i)=>{gltfLoader.load(e,(e=>{const i=parseScene(e.scene,!1,!0);t(i)}),null,i)})))),__publicField(this,"markNeedsUpdate",(()=>{this._updateDelayTimerHander||(this._updateDelayTimerHander=setTimeout((()=>{this.engine.requestRender(),this._updateDelayTimerHander=null}),100))})),__publicField(this,"remapBatchValueToNumber",(e=>e?isFinite(e)?e=Math.round(e%100):"string"==typeof e?(e=e.charCodeAt(3)||0)%100:0:0)),__publicField(this,"parseBatchTableAttribute",((e,t,i)=>{const n=e.cached.scene,r=[],s=n.batchTable&&n.batchTable.header;if(!s)return;const a=s[t];if(a){n.traverse((e=>{e.isMesh&&r.push(e)}));for(const e of r){if("type"in e.geometry.userData&&"subtype"in e.geometry.userData)continue;const t=e.geometry,n=t.getAttribute("_batchid");if(!n)continue;const r=n.data.count;let s=-1,o=0;const l=[];for(let e=0;e<r;e++)s=n.getX(e),o=this.remapBatchValueToNumber(a[s]),l.push(o);t.attributes[i]=new three.BufferAttribute(new Float32Array(l),1)}}})),__publicField(this,"parsePOIData",((e,t,i,n="default")=>{const r=t.content.batchTable.header.dataType,s=e.geometry,a=t.__id,o=s.attributes.position,l=s.attributes.angle,c=s.attributes.rank,h=s.attributes._batchid,u=o.count;if(0===u)return;const d=t.cached.scene.matrix,p=[],m=new three.Vector3,f=i.detail,g=defaultValue$1(f.direction,4),_=ANCHOR[g],A=f.styleid,v=this.style[A]||{},y=defaultValue$1(v.font_size,16),x=v.font_rgba?decodeColor(v.font_rgba):[0,0,0,1],b=v.halo_rgba?decodeColor(v.halo_rgba):[255,255,255,1],S=defaultValue$1(v.halo_size,0),C=defaultValue$1(v.fontWeight,"400"),T=v.icon,E=v.icon_hover;let M=f.name||"";M=M.replace(/\\n/g,"\\");for(let w=0;w<u;w++){m.set(o.getX(w),o.getY(w),o.getZ(w)),m.applyMatrix4(d);const e=r[h.getX(w)],t={id:`${a}-${m.x},${m.y},${m.z}-${w}`,position:[m.x,m.y,m.z],crs:this.engine.map.projectionName,dataType:e,forceProjected:!0,isCustom:!0};if(T&&(t.mapSrc=this.getIconUrl(T),t.hoverIcon=this.getIconUrl(E)),v.font_rgba&&(t.text=M,t.textFillStyle=x,t.textStrokeStyle=b,t.textStrokeWidth=S,t.textSize=y,t.textAnchor=_,t.textWeight=C),l){const e=l.getX(w);t.flat=!0,t.rotateZ=Math.PI/2-three.MathUtils.degToRad(e)}if(c){const e=c.getX(w);t.rank=e}p.push(t)}t[`__POIData_${n}`]=p})),__publicField(this,"parseLabelData",((e,t)=>{const i=e.geometry,n=t.__id,r=i.attributes.position,s=r.count;if(0===s)return;const a=i.attributes.rotation,o=t.cached.scene,l=o.matrix,c=o.batchTable.header.text,h=o.batchTable.header.rank,u=[],d=new three.Vector3;for(let p=0;p<s;p++)d.set(r.getX(p),r.getY(p),r.getZ(p)),d.applyMatrix4(l),u.push({id:n+"-"+p,type:"text_flat",position:[d.x,d.y,d.z],text:c[p],rotateZ:a.getZ(p),rank:h&&h[p]||0});t.__labelData=u})),__publicField(this,"onTileLoad",((e,t)=>{this.refreshTile(e)})),__publicField(this,"onTileDispose",((e,t)=>{this.resetTile(e)})),__publicField(this,"onTileShow",(e=>{if(e.__instanceInfo){const t=e.__instanceInfo;Object.keys(t).forEach((e=>{const i=t[e];i.model&&(i.model.visible=!0,this.markNeedsUpdate())}))}for(const[t,i]of Object.entries(this._poiConfig)){if(!i.enabled)continue;const n=e[`__POIData_${t}`],r=`__hasAddPOIData_${t}`;n&&!e[r]&&(this.addLabels(n),e.__visible?e[r]=!0:(this.removeLabels(n),e[r]=!1))}})),__publicField(this,"onTileHide",(e=>{if(e.__instanceInfo){const t=e.__instanceInfo;Object.keys(t).forEach((e=>{const i=t[e];i.model&&(i.model.visible=!1,this.markNeedsUpdate())}))}for(const t of Object.keys(this._poiConfig)){const i=e[`__POIData_${t}`],n=`__hasAddPOIData_${t}`;i&&e[n]&&(this.removeLabels(i),e[n]=!1)}})),__publicField(this,"resetTile",(e=>{if(e.__instanceConfigVersion=null,e.__instanceInfo&&(Object.keys(e.__instanceInfo).forEach((t=>{const i=e.__instanceInfo[t];i.model&&(this.group.remove(i.model),i.model.dispose())})),delete e.__instanceInfo),e.__labelData&&e.__hasAddLabelData){const t=e.__labelData;this.engine.rendering.label.removeLabels(t,e.__lodLevel),e.__hasAddLabelData=!1}for(const t of Object.keys(this._poiConfig)){const i=e[`__POIData_${t}`],n=`__hasAddPOIData_${t}`;i&&e[n]&&(this.removeLabels(i),e[n]=!1)}})),__publicField(this,"refreshTile",(e=>{var t;const i=e.cached.scene,n=[];if(e.__instanceConfigVersion!==this._configVersion){i.traverse((e=>{e.isMesh&&n.push(e)}));for(const i of n)if(i.isMesh&&"type"in i.geometry.userData&&"subtype"in i.geometry.userData){i.visible=!1;const{type:t,subtype:n}=i.geometry.userData,r=this.getInstanceCollectionConfig(t);if(!r)continue;const s=this.getInstanceConfig(t,n);if(!s)continue;e.__instanceInfo||(e.__instanceInfo={}),r.enabled&&this.createInstanceComponent(i,e,r,s)}else if(i.isMesh&&"type"in i.geometry.userData&&"detail"in i.geometry.userData){const{type:n,detail:r}=i.geometry.userData,s={type:n,detail:JSON.parse(r)};e.__instanceInfo||(e.__instanceInfo={}),(null==(t=this._poiConfig[n])?void 0:t.enabled)&&this.style&&this.parsePOIData(i,e,s,n)}else"_label"===i._rawMaterialName&&(i.visible=!1,this._labelEnabled&&!e.__instanceLabelParsed&&(this.parseLabelData(i,e),e.__instanceLabelParsed=!0));e.__instanceConfigVersion=this._configVersion}const r=e.__labelData;r&&(this._labelEnabled&&!e.__hasAddLabelData&&(this.engine.rendering.label.addLabels(r,e.__lodLevel),e.__hasAddLabelData=!0),!this._labelEnabled&&e.__hasAddLabelData&&(this.engine.rendering.label.removeLabels(r,e.__lodLevel),e.__hasAddLabelData=!1));for(const[s,a]of Object.entries(this._poiConfig)){const t=e[`__POIData_${s}`],i=`__hasAddPOIData_${s}`;e.__visible&&(t&&a.enabled&&!e[i]&&(this.addLabels(t),e.__visible?e[i]=!0:(this.engine.rendering.label.removeLabels(t),e[i]=!1)),t&&!a.enabled&&e[i]&&(this.engine.rendering.label.removeLabels(t),e[i]=!1))}})),__publicField(this,"refreshTiles",(()=>{this.tilesRenderer.forEachLoadedModel(((e,t)=>{t.__visible&&(this.resetTile(t),this.refreshTile(t))})),this.engine.requestRender()})),__publicField(this,"getLabelType",(e=>{let t=e.type;const i=e.flat;let n=!1,r=!1;if(e.text&&(n=!0),e.mapSrc){const{width:t,height:i}=e;e.icon=e.mapSrc,e.iconSize=[t||32,i||32],r=!0}return n&&r?t="icon_text":n?t=i?"text_flat":"text_fix":r&&(t=i?"icon_flat":"icon"),t})),this.group=new three.Group,this.group.isInstancedElementManager=!0,this._modelMeshSingleton=new PromisedSingleton,this._modelMeshSingleton.generate=this._generateModelMesh,this._hiddenDataTypes=new Set}getIconUrl(e){return this.tilesRenderer._rootPath+e+"@2x.png"}async createInstanceComponent(e,t,i,n){const r=e.geometry,s=t.__id,a=r.attributes.position,o=a.count;if(0===o)return;const l=i.type,c=l+"-"+n.subtype,h=n.itemScale||1,u=n.zOffset||0;let d;if("tree"===l)d=new OctahedralImpostor({diffuse:n.diffuseTexture,normalDepth:n.normalDepthTexture,orm:n.ormTexture,offsetZ:n.uvOffset,imposterScale:n.imposterScale});else{const e=await this._modelMeshSingleton.get(n.modelPath);d=new InstancedModel(e,o)}d.afterAddToEngine&&d.afterAddToEngine(this.engine),"tree"===l&&await d.initialize();const p=[],m=r.attributes.scale,f=r.attributes.rotation,g=new Array(3*o),_=new Float32Array(3*o),A=new Float32Array(3*o),v=t.cached.scene.matrix,y=new three.Vector3;for(let b=0;b<o;b++)y.set(a.getX(b),a.getY(b),a.getZ(b)),y.applyMatrix4(v),this.engine.isGlobe||(_tempPointScratch=this.engine.map.unprojectArrayCoordinate([y.x,y.y,y.z]),_scaleFactorScratch=getMercatorScaleFactor(_tempPointScratch[1])),g[3*b]=y.x,g[3*b+1]=y.y,g[3*b+2]=y.z+u,_[3*b]=m.getX(b)*h*_scaleFactorScratch,_[3*b+1]=m.getY(b)*h*_scaleFactorScratch,_[3*b+2]=m.getZ(b)*h,A[3*b]=f.getZ(b)/180*Math.PI,A[3*b+1]=-f.getY(b)/180*Math.PI,A[3*b+2]=f.getX(b)/180*Math.PI,p.push(s+"-"+b);const x={translation:g,scale:_,rotation:A,id:p};d.setBufferData(x),d.needsUpdate=!0,d.__originalMesh=e,t.__instanceInfo[c]={model:d,data:x},this.group.add(d),d.visible=t.__visible}getInstanceCollectionConfig(e){if(defined$2(this._config[e]))return{type:e,...this._config[e]};warnOnce("TileInstancedElementManager: no config for type "+e)}setInstanceCollectionConfig(e,t){return this._config[e]?this._config[e]={...this._config[e],...t}:this._config[e]=t,this._configVersion++,this.refreshTiles(),this}getInstanceConfig(e,t){if(this._config[e]){let i=this._config[e].instances;for(let e=0;e<i.length;e++){const n=i[e];if(String(n.subtype)===String(t))return n}warnOnce("TileInstancedElementManager: no config for type "+e+" subtype "+t)}else warnOnce("TileInstancedElementManager: no config for type "+e)}setInstanceConfig(e,t,i){if(this._config[e]){let n=this._config[e].instances,r=!0;for(let e=0;e<n.length;e++){const s=n[e];if(String(s.subtype)===String(t)){n[e]={...s,...i},r=!1;break}}r&&this._config[e].instances.push({...i,subtype:t}),this._configVersion++,this.refreshTiles()}return this}_getLabelInstance(e){if("icon"===e){if(this._icon)return this._icon;const e=this._icon=this.engine.rendering.add(new Label({type:"icon",vertexIcons:!0,isRenderInPostprocess:!1})),t=new DataSource;return t.defineAttributes({id:"id",icon:"icon",iconSize:"iconSize",boundingBox:"boundingBox",offset:"offset",checkVisible:"checkVisible",tolerance:"tolerance"}),e.dataSource=t,this.engine.rendering.collision.add(e,{margin:[0,0]},"tiles_poi"),e}if("text_fix"===e){if(this._text)return this._text;const e=this._text=this.engine.rendering.add(new Label({type:"text",isRenderInPostprocess:!1,flat:!1})),t=new DataSource;return t.defineAttributes({id:"id",text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textWeight:"textWeight",textAnchor:"textAnchor",boundingBox:"boundingBox",offset:"offset",checkVisible:"checkVisible",tolerance:"tolerance"}),e.dataSource=t,this.engine.rendering.collision.add(e,{margin:[0,0]},"tiles_poi"),e}if("icon_text"===e){if(this._hoverIcon)return this._hoverIcon;const e=this._icontext=this.engine.rendering.add(new Label({type:"icontext",vertexIcons:!0,enableFade:!0,useIconScale:!0,fadeDuration:100,isRenderInPostprocess:!0})),t=new DataSource;t.defineAttributes({id:"id",text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textWeight:"textWeight",textAnchor:"textAnchor",textDrawOnIcon:"textDrawOnIcon",icon:"icon",iconSize:"iconSize",direction:"direction",rotateZ:"rotateZ",boundingBox:"boundingBox",offset:"offset",checkVisible:"checkVisible",tolerance:"tolerance"}),e.dataSource=t;const i=this._hoverIcon=this.engine.rendering.add(new Label({type:"icon",vertexIcons:!0,isRenderInPostprocess:!1,useIconScale:!0})),n=new DataSource;n.defineAttributes({id:"id",text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textWeight:"textWeight",textAnchor:"textAnchor",textDrawOnIcon:"textDrawOnIcon",icon:"icon",hoverIcon:"hoverIcon",iconSize:"iconSize",direction:"direction",rotateZ:"rotateZ",boundingBox:"boundingBox",offset:"offset",checkVisible:"checkVisible",tolerance:"tolerance"}),i.dataSource=n,this.engine.rendering.collision.add(i,{margin:[0,0]},"tiles_poi");const r=t=>{e.dataSource.clear();const i=t.entity;if(i&&i.value){const t=i.value,n=JSON.parse(JSON.stringify(t.attributes)),r=i.pairs,s=n.hoverIcon,a={...n,forceProjected:!0,position:r.position,mapSrc:s,width:35};this.addLabel(a,e),e.dataSource.needsUpdate=!0}};return i.addEventListener("mouseenter",r),i.addEventListener("mousemove",r),i.addEventListener("mouseleave",(t=>{e.dataSource.clear(),e.dataSource.needsUpdate=!0})),i}if("text_flat"===e){if(this._textFlat)return this._textFlat;const e=this._textFlat=this.engine.rendering.add(new Label({type:"text",isRenderInPostprocess:!1,flat:!0})),t=new DataSource;return t.defineAttributes({id:"id",text:"text",textSize:"textSize",textFillStyle:"textFillStyle",textStrokeStyle:"textStrokeStyle",textStrokeWidth:"textStrokeWidth",textAnchor:"textAnchor",textWeight:"textWeight",rotateZ:"rotateZ",boundingBox:"boundingBox",checkVisible:"checkVisible",tolerance:"tolerance"}),e.dataSource=t,this.engine.rendering.collision.add(e,{margin:[20,20]},"tiles_label"),e}}addLabels(e){if(0!==e.length)for(let t=0;t<e.length;t++){const i=e[t],n=i.dataType;this._hiddenDataTypes.has(n)||this.addLabel(i)}}removeLabels(e){for(let t=0;t<e.length;t++){const i=e[t],n=this.getLabelType(i);this._getLabelInstance(n).dataSource.remove(i)}}addLabel(e,t){const i=this.getLabelType(e),n=t||this._getLabelInstance(i),{position:r,forceProjected:s,...a}=e,o=new DataItem(r,a,s);n.dataSource.add(o)}removeLabel(e,t){const i=this.getLabelType(e);(t||this._getLabelInstance(i)).dataSource.remove(e)}setPoiConfig(e){return this._poiConfig={...this._poiConfig,...e},this._poiConfigVersion++,this.refreshTiles(),this}getPoiConfig(){return{...this._poiConfig}}enablePoiType(e){return this._poiConfig[e]||(this._poiConfig[e]={}),this._poiConfig[e].enabled=!0,this._poiConfigVersion++,this.refreshTiles(),this}disablePoiType(e){return this._poiConfig[e]||(this._poiConfig[e]={}),this._poiConfig[e].enabled=!1,this._poiConfigVersion++,this.refreshTiles(),this}togglePoiType(e){this._poiConfig[e]||(this._poiConfig[e]={enabled:!1});const t=!this._poiConfig[e].enabled;return this._poiConfig[e].enabled=t,this._poiConfigVersion++,this.refreshTiles(),t}isPoiTypeEnabled(e){var t;return(null==(t=this._poiConfig[e])?void 0:t.enabled)||!1}getAvailablePoiTypes(){return Object.keys(this._poiConfig)}hideDataType(e){return this._hiddenDataTypes.add(e),this.refreshTiles(),this}showDataType(e){return this._hiddenDataTypes.delete(e),this.refreshTiles(),this}toggleDataType(e){return this._hiddenDataTypes.has(e)?(this._hiddenDataTypes.delete(e),this.refreshTiles(),!0):(this._hiddenDataTypes.add(e),this.refreshTiles(),!1)}isDataTypeVisible(e){return!this._hiddenDataTypes.has(e)}getHiddenDataTypes(){return Array.from(this._hiddenDataTypes)}set config(e){this._config=e,this._configVersion++,this.refreshTiles()}get config(){return this._config}set labelEnabled(e){this._labelEnabled=e,this._configVersion++,this.refreshTiles()}get labelEnabled(){return this._labelEnabled}set poiEnabled(e){this._poiEnabled=e,this._configVersion++,this.refreshTiles()}get poiEnabled(){return this._poiEnabled}set poiConfig(e){this.setPoiConfig(e)}get poiConfig(){return this.getPoiConfig()}}class EditableElementManager{constructor(){__publicField(this,"_configVersion",0),__publicField(this,"_deletedIds",new Set),__publicField(this,"_needsRefreshAll",!1),__publicField(this,"updateEditableAttribute",(e=>{const t=e.cached.scene;t.children;const i=t.batchTable&&t.batchTable.header;if(!i)return;const n=i.id;if(!n)return;const r=this._deletedIds;t.traverse((e=>{if(e.geometry){const t=e.geometry,s=t.getAttribute("_batchid");if(!s)return;const a=s.array.length;let o=-1,l=0;const c=[];for(let e=0;e<a;e++)o=s.getX(e),l=n[o]+"",r.has(l)||this.shouldBeHidden(i,o)?c.push(1):c.push(0);t.attributes._tileEditableValue=new three.BufferAttribute(new Float32Array(c),1)}}))})),__publicField(this,"shouldBeHidden",((e,t)=>!1)),__publicField(this,"onTileLoad",((e,t)=>{e.__editableConfigVersion=0})),__publicField(this,"onTileDispose",((e,t)=>{})),__publicField(this,"onTileShow",(e=>{this.refreshTile(e)})),__publicField(this,"onTileHide",(e=>{})),__publicField(this,"refreshTile",(e=>{e.__editableConfigVersion!==this._configVersion&&(this.updateEditableAttribute(e),e.__editableConfigVersion=this._configVersion)})),__publicField(this,"refreshTiles",(()=>{this._needsRefreshAll&&this.tilesRenderer.forEachLoadedModel(((e,t)=>{t.__visible&&this.refreshTile(t)}))}))}addDeletedId(e){e+="",this._deletedIds.add(e),this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}addDeletedIds(e){for(let t=0;t<e.length;t++){const i=e[t]+"";this._deletedIds.add(i)}this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}removeDeletedId(e){e+="",this._deletedIds.delete(e),this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}removeDeletedIds(e){for(let t=0;t<e.length;t++){const i=e[t]+"";this._deletedIds.delete(i)}this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}hasDeletedId(e){return this._deletedIds.has(e)}requestUpdate(){this._configVersion++,this._needsRefreshAll=!0,this.engine.requestRender()}}const scratchPositionWC=new three.Vector3;new three.Matrix4;const scratchHalfHeight=new three.Vector3,scratchCenter=new three.Vector3,X_AXIS=new three.Vector3(1,0,0),Y_AXIS=new three.Vector3(0,1,0),_infoPosition=new three.Vector3,_infoDelta=new three.Vector3,PLUGIN_REGISTERED=Symbol("PLUGIN_REGISTERED"),Axis={X:0,Y:1,Z:2,fromName:function(e){return Axis[e]}},scratchCartographic=new three.Vector3,scratchPositionNormal=new three.Vector3,scratchPosition=new three.Vector3,scratchDirection=new three.Vector3,_emptyFunction=()=>{};function updateDynamicScreenSpaceError(e,t,i){let n,r,s,a,o;const l=e._root,c=l.boundingVolume,h=e.getCamera(),u=e._cameraInfo,d=i.map.isGlobe;if(defined$2(l.boundingVolume.regionObb)){n=d?Cartesian3.normalize(h.position,scratchPositionNormal):Cartesian3.UNIT_Z,r=u.directionWC,s=u.positionCartographic.z;const e=l.boundingVolume.regionObb.box,{min:t,max:i}=e;a=t.z,o=i.z}else{const e=l.computedTransform.clone().invert(),t=i.map.map._ellipsoid||Ellipsoid.WGS84,p=c.obb,m=l.boundingVolumeCenter,f=StaticMatrix4.multiplyByPoint(e,m,scratchCenter);if(Cartesian3.magnitude(f)>t.minimumRadius&&d){const e=Cartographic.fromCartesian(f,t,scratchCartographic);n=Cartesian3.normalize(h.position,scratchPositionNormal),r=u.directionWC,s=u.positionCartographic.z,a=0,o=2*e.z}else{scratchPositionWC.copy(h.position);const t=StaticMatrix4.multiplyByPoint(e,scratchPositionWC,scratchPosition);n=Cartesian3.UNIT_Z,r=StaticMatrix4.multiplyByPointAsVector(e,u.directionWC,scratchDirection),r=Cartesian3.normalize(r,r),s=t.z;if(defined$2(p)){const e=StaticMatrix3.getColumn(p.halfAxes,2,scratchHalfHeight).length();a=f.z-e,o=f.z+e}else{const e=l.boundingVolume.sphere.radius;a=f.z-e,o=f.z+e}}}const p=a+(o-a)*e.dynamicScreenSpaceErrorHeightFalloff,m=o*e.dynamicScreenSpaceHeightScale,f=three.MathUtils.clamp((s-p)/(m-p),0,1);let g=1-Math.abs(Cartesian3.dot(r,n));g*=1-f,e._dynamicScreenSpaceErrorComputedDensity=e.dynamicScreenSpaceErrorDensity*g}async function processMetadataExtension(e,t){const i=hasExtension(t,"3DTILES_metadata")?t.extensions["3DTILES_metadata"]:t;let n;if(defined$2(i.schemaUri))e=e.getDerivedResource({url:i.schemaUri}),n=ResourceCache.getSchemaLoader({schema:i.schema});else{if(!defined$2(i.schema))return;n=ResourceCache.getSchemaLoader({schema:i.schema})}await n.load();const r=new Cesium3DTilesetMetadata({schema:n.schema,metadataJson:i});return ResourceCache.unload(n),r}const Cesium3DTileRefine={ADD:0,REPLACE:1},_Cesium3DTileset=class extends three.Object3D{constructor(e){super(),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"is3DTiles",!0),__publicField(this,"_needsRefreshAllLoadedTiles",!1),__publicField(this,"_freezeUpdate",!1),__publicField(this,"_forceUnlit",!1),__publicField(this,"handleBeforeRender",(e=>{if(this._needsRefreshAllLoadedTiles&&(this._needsRefreshAllLoadedTiles=!1,this.traversalLoadedTile(((e,t)=>{this._refreshTileInfo(t)}))),this._freezeUpdate||!this.visible)return;const t=e.rendering.renderState;this._elementsManager&&this._elementsManager.tick(t.time),this.prePassesUpdate(t),this.update(t),this.postPassesUpdate(t),this._editableElementManager.refreshTiles()})),__publicField(this,"_isInstancedElement",(e=>{let t=e;for(;t;){if(t.isInstancedElementManager)return!0;if(t.is3DTiles)return!1;t=t.parent}return!1})),__publicField(this,"parseBatchTableAttribute",((e,t)=>{const i=e.scene.children,n=e.batchTable&&e.batchTable.header;if(!n)return;const r=n[t];if(r&&r.length)for(const s of i){const e=s.geometry,i=e.getAttribute("_batchid");if(!i)continue;const n=i.data.count;let a=-1,o=0;const l=[];for(let t=0;t<n;t++)a=i.getX(t),o=r[a],l.push(o);e.attributes[t]=new three.BufferAttribute(new Float32Array(l),1)}})),__publicField(this,"_refreshTileInfo",(e=>{var t;const i=e.content;"2.0.0"===(null==(t=this._asset)?void 0:t.tilesetVersion)&&this.parseBatchTableAttribute(i,"typeId"),i.traverse((e=>{if(!e.isMesh||!e.material)return;void 0===e._rawMaterialName&&(e._rawMaterialName=e.material.name,e._originalMaterial=e.material);const t=e._rawMaterialName;if(this._materialManager){const i=this._materialManager.getMaterialByKey(t,e);i&&i.isMaterial?e.material=i:e.material=e._originalMaterial}else e.material=e._originalMaterial;e.receiveShadow=this._receiveShadow,e.castShadow=this._castShadow,i._raycastMethod!==this._raycastMethod&&(this._raycastMethod===_Cesium3DTileset.RAYCAST_NONE?e.raycast=_emptyFunction:e.raycast=this._overridenRaycast)})),i._raycastMethod=this._raycastMethod})),__publicField(this,"traversalLoadedTile",(e=>{this.getTraversal().forEachLoadedTile(this,e)})),e=defaultValue$1(e,{}),this.plugins=[],this.preferLeaves=defaultValue$1(e.preferLeaves,!1),this.dynamicScreenSpaceError=defaultValue$1(e.dynamicScreenSpaceError,!0),this._updatedVisibilityFrame=0,this.dynamicScreenSpaceErrorDensity=defaultValue$1(e.dynamicScreenSpaceErrorDensity,.00278),this.dynamicScreenSpaceErrorFactor=defaultValue$1(e.dynamicScreenSpaceErrorFactor,40),this.dynamicScreenSpaceErrorHeightFalloff=defaultValue$1(e.dynamicScreenSpaceErrorHeightFalloff,.25),this.foveatedScreenSpaceError=defaultValue$1(e.foveatedScreenSpaceError,!0),this._foveatedConeSize=defaultValue$1(e.foveatedConeSize,.05),this._foveatedMinimumScreenSpaceErrorRelaxation=defaultValue$1(e.foveatedMinimumScreenSpaceErrorRelaxation,0),this.foveatedInterpolationCallback=defaultValue$1(e.foveatedInterpolationCallback,three.MathUtils.lerp),this.loadSiblings=defaultValue$1(e.loadSiblings,!1),this.dynamicScreenSpaceHeightScale=e.dynamicScreenSpaceHeightScale||6,this._dynamicScreenSpaceErrorComputedDensity=0,this._cullWithChildrenBounds=defaultValue$1(e.cullWithChildrenBounds,!0),this._url=void 0,this._basePath=void 0,this._rootPath=void 0,this._root=void 0,this._cache=new Cesium3DTilesetCache,this._processingQueue=[],this._selectedTiles=[],this._selectedTilesToStyle=[],this._emptyTiles=[],this._requestedTiles=[],this._requestedTilesInFlight=[],this._maximumScreenSpaceError=defaultValue$1(e.maximumScreenSpaceError,64),this._screenSpaceError=this._maximumScreenSpaceError,this.cullRequestsWhileMoving=defaultValue$1(e.cullRequestsWhileMoving,!0),this._cullRequestsWhileMoving=!1,this.cullRequestsWhileMovingMultiplier=defaultValue$1(e.cullRequestsWhileMovingMultiplier,60),this.progressiveResolutionHeightFraction=three.MathUtils.clamp(defaultValue$1(e.progressiveResolutionHeightFraction,.5),0,.5),this._cacheBytes=defaultValue$1(e.cacheBytes,536870912),this._prevSelectedTiles=[];const t=defaultValue$1(e.maximumCacheOverflowBytes,536870912);this._maximumCacheOverflowBytes=t,this._statistics=new Cesium3DTilesetStatistics,this._statisticsLast=new Cesium3DTilesetStatistics,this._maximumPriority={foveatedFactor:-Number.MAX_VALUE,depth:-Number.MAX_VALUE,distance:-Number.MAX_VALUE,reverseScreenSpaceError:-Number.MAX_VALUE},this._minimumPriority={foveatedFactor:Number.MAX_VALUE,depth:Number.MAX_VALUE,distance:Number.MAX_VALUE,reverseScreenSpaceError:Number.MAX_VALUE},this._modelMatrix=defined$2(e.modelMatrix)?(new three.Matrix4).copy(e.modelMatrix):new three.Matrix4,this.optimizeRaycast=defaultValue$1(e.optimizeRaycast,!0),this._raycastMethod=_Cesium3DTileset.RAYCAST_DEFAULT;const i=this;this._overridenRaycast=function(e,t){i.optimizeRaycast||Object.getPrototypeOf(this).raycast.call(this,e,t)},this._camera=null,this._manager=new three.LoadingManager,Array.isArray(e.loaders)?this._loaders=e.loaders:(this._gltfLoader=createEnhancedLoader(),this._loaders=[[/\.gltf$/,this._gltfLoader]],e.forceUnlit&&(this.forceUnlit=!0)),this.updateCustomLoaders(),this.group=new three.Group,this.add(this.group);(this._elementsManager=new ElementsManager(this.group)).tilesRenderer=this;const n=this._instancedElementManager=new TileInstancedElementManager;n.tilesRenderer=this,this.add(n.group);(this._editableElementManager=new EditableElementManager).tilesRenderer=this,this._displayBoxBounds=defaultValue$1(e.displayBoxBounds,!1),this._displayRegionBounds=defaultValue$1(e.displayRegionBounds,!1),this.debug=defaultValue$1(e.debug,!1),this._initEventListener()}getBounds(){const e=new three.Box3,t=this.getBoundingBox(e);return t&&e.applyMatrix4(this.matrixWorld),t?e:null}isEntityVisible(e){return!e.id||!this._editableElementManager.hasDeletedId(e.id)}_initEventListener(){this.addEventListener("jsonloaded",this.handleLoadTileset),this.addEventListener("loaded",this.handleLoadTile),this.addEventListener("dispose",this.handleDisposeTile),this.addEventListener("visibilitychange",this.handleTileVisibleChanged)}handleLoadTileset(){this._engine&&this._engine.requestRender()}handleLoadTile(e){const t=e.tile;this._refreshTileInfo(t);const i=t.content.scene;this._elementsManager.onTileLoad(t,i),this._instancedElementManager.onTileLoad(t,i),this._editableElementManager.onTileLoad(t,i),this._engine.requestRender()}handleDisposeTile(e){const t=e.tile,i=t.content.scene;this._elementsManager.onTileDispose(t,i),this._instancedElementManager.onTileDispose(t,i),this._editableElementManager.onTileDispose(t,i)}handleTileVisibleChanged(e){const{tile:t,visible:i}=e;i?(this._instancedElementManager.onTileShow(t),this._elementsManager.onTileShow(t),this._editableElementManager.onTileShow(t)):(this._instancedElementManager.onTileHide(t),this._elementsManager.onTileHide(t),this._editableElementManager.onTileHide(t))}updateCustomLoaders(){for(const e of this._loaders)this._manager.addHandler(e[0],e[1])}afterAddToEngine(e){this._engine=e,e.addPrepareRenderListener(this.handleBeforeRender),this._elementsManager.engine=e,this._instancedElementManager.engine=e,this._editableElementManager.engine=e}setCamera(e){this._camera=e}hasCamera(){return defined$2(this._camera)}deleteCamera(){this._camera=void 0}getCamera(){return this.hasCamera()?this._camera:this._engine&&this._engine.camera}getEntityByIntersection(e){const t={};let i,n,r=e.object;if(!defined$2(r))return null;if(this._isInstancedElement(r))i=e.instanceId,n=r.__originalMesh||r.parent.__originalMesh;else{const{face:s,faceIndex:a}=e;i=s&&s.a,t._face=s,t._faceIndex=a,n=r}const s=n.content,a=n.tile;if(s&&(t._content=s),a){const e=a.tileset;t._tile=a,t._tileset=e}const o=n.geometry?n.geometry.getAttribute("_batchid"):void 0,l=s&&s.batchTable;if(void 0!==i&&o){const e=Math.round(o.getX(i));t._batchId=e;for(const i of Object.keys(l.header)){const n=l.header[i];t[i]=n[e]}}return t}updateInfo(){const e=this._engine,t=this.getCamera();this.dispatchEvent({type:"update-before"});const i=e.renderer.getPixelRatio(),n=this._cameraInfo||{positionWCDeltaMagnitude:0,positionCartographic:new three.Vector3,lastMovedTimestamp:Date.now(),positionWCDeltaMagnitudeLastFrame:0,timeSinceMoved:0,position:new three.Vector3,directionWC:new three.Vector3,oldPosition:null},r=e.rendering.resolution;0!==r.x&&0!==r.y||console.warn("TilesRenderer: resolution for camera error calculation is not set.");const s=t.projectionMatrix.elements;if(n.isOrthographic=1===s[15],n.isOrthographic){const e=2/s[0],t=2/s[5];n.pixelSize=Math.max(t/(r.height*i),e/(r.width*i))}else n.sseDenominator=2/s[5]/(r.y*i);n.invScale=1,n.position=_infoPosition.copy(t.position),n.pixelRatio=e.rendering.pixelRatio;const a=n.position;n.oldPosition||(n.oldPosition=a.clone()),n.frustum||(n.frustum=new ExtendedFrustum);const o=new three.Matrix4,l=new three.Matrix4,c=this.group;o.copy(c.matrixWorld),l.copy(o).invert(),o.premultiply(t.matrixWorldInverse),o.premultiply(t.projectionMatrix),n.frustum.setFromProjectionMatrix(o),a.set(0,0,0),a.applyMatrix4(t.matrixWorld),a.applyMatrix4(l),n.positionWCDeltaMagnitudeLastFrame=n.positionWCDeltaMagnitude;const h=_infoDelta.subVectors(a,n.oldPosition);n.positionWCDeltaMagnitude=h.length(),n.positionWCDeltaMagnitude>0?(n.timeSinceMoved=0,n.lastMovedTimestamp=Date.now()):n.timeSinceMoved=Math.max(Date.now()-n.lastMovedTimestamp,0)/1e3,n.oldPosition.copy(a),t.getWorldDirection(n.directionWC),n.positionCartographic.fromArray(e.map.unprojectArrayCoordinate(t.position.toArray())),this._cameraInfo=n}prePassesUpdate(e){if(this.updateInfo(),defined$2(this._root)){if(processTiles(this),this.dynamicScreenSpaceError){updateDynamicScreenSpaceError(this,e,this._engine)}this._cache.reset()}}forEachLoadedModel(e){this.traversalLoadedTile(e)}update(e){update(this,e)}trimLoadedTiles(){this._cache.trim()}postPassesUpdate(e){defined$2(this._root)&&(cancelOutOfViewRequests(this,e),this._cache.unloadTiles(this,unloadTile),this._styleApplied=!1,RequestScheduler.update())}beforeRemoveFromEngine(e){this._engine.removePrepareRenderListener(this.handleBeforeRender),this.dispose()}dispose(){this.resetQueue(),this.traversalLoadedTile(((e,t)=>{this._cache.unloadTile(this,t,unloadTile)}))}disposePlugins(){this.plugins.forEach((e=>{e.dispose&&e.dispose()}))}resetQueue(){this._prevSelectedTiles.length=0,this._processingQueue.length=0,this._requestedTiles.length=0}getTraversal(){return this.isSkippingLevelOfDetail?Cesium3DTilesetSkipTraversal:Cesium3DTilesetBaseTraversal}isDestroyed(){return!1}async setTilesetProperties(e,t,i){const n=await processMetadataExtension(t,e);this._metadataExtension=n,this._geometricError=e.geometricError,this._scaledGeometricError=e.geometricError;const r=e.asset;this._asset=r,this._extras=e.extras;const s=defined$2(e.asset.gltfUpAxis)?Axis.fromName(e.asset.gltfUpAxis):Axis.Y,a=defaultValue$1(i.modelUpAxis,s),o=defaultValue$1(i.modelForwardAxis,Axis.X);this._gltfUpMatrix=new three.Matrix4,this._properties=e.properties,this._extensionsUsed=e.extensionsUsed,this._extensions=e.extensions,this._modelUpAxis=a,this._modelForwardAxis=o,this._root=this.loadTileset(t,e),queueMicrotask((()=>{this.dispatchEvent({type:"rootloaded",tileset:e,url:t.url})}))}static async fromAssetId(e,t){const i=await IonResource.fromAssetId(e);return _Cesium3DTileset.fromUrl(i,t)}static fromUrl(e,t){t=defaultValue$1(t,{});const i=Resource.createIfNeeded(e);let n;"json"===i.extension?n=i.getBaseUri(!0):i.isDataUri&&(n="");const r=new _Cesium3DTileset(t);return r._resource=i,r._url=e,r._basePath=n,r._rootPath=n,_Cesium3DTileset.loadJson(i).then((async function(e){r.setTilesetProperties(e,i,t)})),r}static async fromUrlAsync(e,t){t=defaultValue$1(t,{});const i=Resource.createIfNeeded(e);let n;"json"===i.extension?n=i.getBaseUri(!0):i.isDataUri&&(n="");const r=await _Cesium3DTileset.loadJson(i),s=await processMetadataExtension(i,r),a=new _Cesium3DTileset(t);a._resource=i,a._url=e,a._basePath=n,a._rootPath=n,a._metadataExtension=s,a._geometricError=r.geometricError,a._scaledGeometricError=r.geometricError;const o=r.asset;a._asset=o,a._extras=r.extras;const l=defined$2(r.asset.gltfUpAxis)?Axis.fromName(r.asset.gltfUpAxis):Axis.Y,c=defaultValue$1(t.modelUpAxis,l),h=defaultValue$1(t.modelForwardAxis,Axis.X);return a._gltfUpMatrix=new three.Matrix4,a._properties=r.properties,a._extensionsUsed=r.extensionsUsed,a._extensions=r.extensions,a._modelUpAxis=c,a._modelForwardAxis=h,a._root=a.loadTileset(i,r),a}static async loadJson(e){return Resource.createIfNeeded(e).fetchJson()}getBoundingBox(e){if(!this.root)return!1;const t=this.root.boundingVolume;return!!t&&(t.getAABB(e),!0)}loadTileset(e,t,i){const n=t.asset;if(!defined$2(n))throw new Error("Tileset must have an asset property.");if("0.0"!==n.version&&"1.0"!==n.version&&"1.1"!==n.version)throw new Error("The tileset must be 3D Tiles version 0.0, 1.0, or 1.1");defined$2(t.extensionsRequired)&&_Cesium3DTileset.checkSupportedExtensions(t.extensionsRequired);const r=this._statistics,s=n.tilesetVersion;defined$2(s)&&(this._basePath+=`?v=${s}`,(e=e.clone()).setQueryParameters({v:s}));const a=makeTile(this,e,t.root,i);defined$2(i)&&(i.children.push(a),a._depth=i._depth+1);const o=[];for(o.push(a);o.length>0;){const t=o.pop();++r.numberOfTilesTotal,this._allTilesAdditive=this._allTilesAdditive&&t.refine===Cesium3DTileRefine.ADD;const i=t._header.children;if(defined$2(i))for(let n=0;n<i.length;++n){const r=i[n],s=makeTile(this,e,r,t);t.children.push(s),s._depth=t._depth+1,o.push(s)}this._cullWithChildrenBounds&&Cesium3DTileOptimizations.checkChildrenWithinParent(t)}return queueMicrotask((()=>{this.dispatchEvent({type:"jsonloaded",tileset:t,url:e.url})})),a}registerPlugin(e){if(!0===e[PLUGIN_REGISTERED])throw new Error("A plugin can only be registered to a single tile set");return this.plugins.push(e),e[PLUGIN_REGISTERED]=!0,e.init&&e.init(this),e}raycast(e,t){if(this._root&&this.raycastMethod!==_Cesium3DTileset.RAYCAST_NONE)if(e.firstHitOnly){const i=raycastTraverseFirstHit(this,this._root,e);i&&t.push(i)}else raycastTraverse(this,this._root,e,t)}get raycastMethod(){return this._raycastMethod}set raycastMethod(e){e!==this._raycastMethod&&(this._raycastMethod=parseInt(e,10),this._needsRefreshAllLoadedTiles=!0,this._engine&&this._engine.requestRender())}get root(){return this._root}get modelMatrix(){return this._modelMatrix}get screenSpaceError(){return this._screenSpaceError}get cacheBytes(){return this._cacheBytes}set cacheBytes(e){this._cacheBytes=e}get maximumCacheOverflowBytes(){return this._maximumCacheOverflowBytes}set maximumCacheOverflowBytes(e){this._maximumCacheOverflowBytes=e}get gltfUpMatrix(){switch(this._modelUpAxis){case Axis.X:this._gltfUpMatrix.makeRotationAxis(Y_AXIS,-Math.PI/2);break;case Axis.Y:this._gltfUpMatrix.makeRotationAxis(X_AXIS,Math.PI/2)}return this._gltfUpMatrix}get metadataExtension(){return this._metadataExtension}get schema(){if(defined$2(this._metadataExtension))return this._metadataExtension.schema}get metadata(){if(defined$2(this._metadataExtension))return this._metadataExtension.tileset}get foveatedConeSize(){return this._foveatedConeSize}set foveatedConeSize(e){this._foveatedConeSize=e}get totalMemoryUsageInBytes(){return this._statistics.totalByteLength}get statistics(){return this._statistics}get foveatedMinimumScreenSpaceErrorRelaxation(){return this._foveatedMinimumScreenSpaceErrorRelaxation}set foveatedMinimumScreenSpaceErrorRelaxation(e){this._foveatedMinimumScreenSpaceErrorRelaxation=e}get maximumScreenSpaceError(){return this._maximumScreenSpaceError}set maximumScreenSpaceError(e){this._maximumScreenSpaceError=e,this._screenSpaceError=e,this._engine&&this._engine.requestRender()}get debug(){return this._debug}set debug(e){this._debug!==e&&(this._debug=e,e?(this._debugTilesPlugin=new DebugTilesPlugin,this._debugTilesPlugin.displayBoxBounds=this._displayBoxBounds,this._debugTilesPlugin.displayRegionBounds=this._displayRegionBounds,this.registerPlugin(this._debugTilesPlugin)):this._debugTilesPlugin&&this._debugTilesPlugin.dispose())}get debugTilesPlugin(){return this._debugTilesPlugin}get displayBoxBounds(){return this._displayBoxBounds}set displayBoxBounds(e){this._displayBoxBounds=e,this._debugTilesPlugin&&(this._debugTilesPlugin.displayBoxBounds=e)}get displayRegionBounds(){return this._displayRegionBounds}set displayRegionBounds(e){this._displayRegionBounds=e,this._debugTilesPlugin&&(this._debugTilesPlugin.displayRegionBounds=e)}get displaySphereBounds(){return this._displaySphereBounds}set displaySphereBounds(e){this._displaySphereBounds=e,this._debugTilesPlugin&&(this._debugTilesPlugin.displaySphereBounds=e)}get freezeUpdate(){return this._freezeUpdate}set freezeUpdate(e){this._freezeUpdate=e}get materialManager(){return this._materialManager}set materialManager(e){e!==this._materialManager&&(e&&(e.engine=this._engine,e.tiles=this,e.init(),e.isIdentity3DTilesMaterialManager&&(e.type=this._identityType)),this._materialManager=e,this._needsRefreshAllLoadedTiles=!0,this._engine.requestRender())}get castShadow(){return this._castShadow}set castShadow(e){e!==this._castShadow&&(this._castShadow=e,this._needsRefreshAllLoadedTiles=!0,this._engine&&this._engine.requestRender())}get receiveShadow(){return this._receiveShadow}set receiveShadow(e){e!==this._receiveShadow&&(this._receiveShadow=e,this._needsRefreshAllLoadedTiles=!0,this._engine&&this._engine.requestRender())}get instancedElementManager(){return this._instancedElementManager}get editableElementManager(){return this._editableElementManager}get elementsManager(){return this._elementsManager}get forceUnlit(){return this._forceUnlit}set forceUnlit(e){e!==this._forceUnlit&&this._gltfLoader&&(this._forceUnlit=e,this._gltfLoader.setForceUnlit(e),this.dispose(),this.engine&&this.engine.requestRender())}};let Cesium3DTileset=_Cesium3DTileset;function makeTile(e,t,i,n){if(!(defined$2(i.implicitTiling)||hasExtension(i,"3DTILES_implicit_tiling")))return new Cesium3DTile(e,t,i,n);const r=e.schema,s=new ImplicitTileset(t,i,r),a=new ImplicitTileCoordinates({subdivisionScheme:s.subdivisionScheme,subtreeLevels:s.subtreeLevels,level:0,x:0,y:0,z:0}),o=s.subtreeUriTemplate.getDerivedResource({templateValues:a.getTemplateValues()}).url,l=clone$2(i,!0);l.contents=[{uri:o}],delete l.content,delete l.extensions;const c=new Cesium3DTile(e,t,l,n);return c.implicitTileset=s,c.implicitCoordinates=a,c}function cancelOutOfViewRequests(e,t){const i=e._requestedTilesInFlight;let n=0;for(let r=0;r<i.length;++r){const e=i[r],s=t.frameCount-e._touchedFrame>=1;e._contentState===Cesium3DTileContentState$1.LOADING?s?(e.cancelRequests(),++n):n>0&&(i[r-n]=e):++n}i.length-=n}function hasExtension(e,t){return defined$2(e)&&defined$2(e.extensions)&&defined$2(e.extensions[t])}function filterProcessingQueue(e){const t=e._processingQueue;let i=0;for(let n=0;n<t.length;n++){const e=t[n];e.isDestroyed()||e._contentState!==Cesium3DTileContentState$1.PROCESSING?++i:i&&(t[n-i]=e)}t.length-=i}function handleTileFailure(e,t,i){t.isDestroyed()||(i.isDestroyed()||i._contentResource.url,defined$2(e.message)?e.message:e.toString())}function resetMinimumMaximum(e){e._minimumPriority.depth=Number.MAX_VALUE,e._maximumPriority.depth=-Number.MAX_VALUE,e._minimumPriority.foveatedFactor=Number.MAX_VALUE,e._maximumPriority.foveatedFactor=-Number.MAX_VALUE,e._minimumPriority.distance=Number.MAX_VALUE,e._maximumPriority.distance=-Number.MAX_VALUE,e._minimumPriority.reverseScreenSpaceError=Number.MAX_VALUE,e._maximumPriority.reverseScreenSpaceError=-Number.MAX_VALUE}function update(e,t){if(!defined$2(e._root))return!1;e._statistics.clear(),e._updatedVisibilityFrame=t.frameCount,resetMinimumMaximum(e),e._cullRequestsWhileMoving=e.cullRequestsWhileMoving,e.getTraversal().selectTiles(e,t),requestTiles(e),updateTiles(e,t),e.dispatchEvent({type:"update-after"})}function sortTilesByPriority(e,t){return e._priority-t._priority}function requestTiles(e){const t=e._requestedTiles;t.sort(sortTilesByPriority);for(let i=0;i<t.length;++i)requestContent(e,t[i])}function addContent(e){const t=e.tileset,i=e._content;if(i.isMultiple3DTileContents){const e=i._contents,n=e.length;for(let i=0;i<n;++i){const n=e[i].scene;t.group.add(n)}}else{const e=i.scene;t.group.add(e)}}function removeContent(e){const t=e.tileset,i=e._content;if(i.isMultiple3DTileContents){const e=i._contents,n=e.length;for(let i=0;i<n;++i){const n=e[i].scene;t.group.remove(n)}}else{const e=i.scene;t.group.remove(e)}}function setTileVisible(e,t){const i=e.tileset;t?addContent(e):removeContent(e),i.dispatchEvent({type:"visibilitychange",tile:e,visible:t})}function updateTiles(e,t){e._styleApplied=!0;const i=e._prevSelectedTiles,n=e._selectedTiles,{statistics:r}=e;let s=0,a=0;for(s=0,a=i.length;s<a;s++){const e=i[s];n.includes(e)||setTileVisible(e,!1)}for(s=0,a=n.length;s<a;s++){const r=n[s];i.includes(r)||setTileVisible(r,!0),r.update(e,t)}r.selected=n.length,e._prevSelectedTiles=[...n];const o=e._emptyTiles;for(let l=0;l<o.length;++l){o[l].update(e,t)}}function requestContent(e,t){if(t.hasEmptyContent)return;const{statistics:i}=e,n=t.requestContent();defined$2(n)&&(n.then((n=>{!defined$2(n)||t.isDestroyed()||e.isDestroyed()||(e._processingQueue.push(t),++i.numberOfTilesProcessing,e._engine.requestRender())})).catch((i=>{handleTileFailure(i,e,t)})),e._requestedTilesInFlight.push(t))}function unloadTile(e,t){e._statistics.decrementLoadCounts(t.content),--e._statistics.numberOfTilesWithContentReady,t.unloadContent()}function processTiles(e){filterProcessingQueue(e);const t=e._processingQueue,{cacheBytes:i,maximumCacheOverflowBytes:n,statistics:r}=e;for(let a=0;a<t.length;++a){const i=t[a];try{i.process(e),i.contentReady&&--r.numberOfTilesProcessing}catch(s){--r.numberOfTilesProcessing,handleTileFailure()}}}__publicField(Cesium3DTileset,"RAYCAST_NONE",0),__publicField(Cesium3DTileset,"RAYCAST_DEFAULT",1),__publicField(Cesium3DTileset,"RAYCAST_BVH",2),__publicField(Cesium3DTileset,"supportedExtensions",{"3DTILES_metadata":!0,"3DTILES_implicit_tiling":!0,"3DTILES_content_gltf":!0,"3DTILES_multiple_contents":!0,"3DTILES_bounding_volume_S2":!0,"3DTILES_batch_table_hierarchy":!0,"3DTILES_draco_point_compression":!0,MAXAR_content_geojson:!0}),__publicField(Cesium3DTileset,"checkSupportedExtensions",(function(e){for(let t=0;t<e.length;t++)if(!_Cesium3DTileset.supportedExtensions[e[t]])throw new Error(`Unsupported 3D Tiles Extension: ${e[t]}`)}));class Default3DTiles extends Cesium3DTileset{constructor(e){const t=defaultValue$1(e.errorTarget,64);super({maximumScreenSpaceError:t,forceUnlit:defaultValue$1(e.forceUnlit,!1),cullWithChildrenBounds:defaultValue$1(e.cullWithChildrenBounds,!0),cullRequestsWhileMoving:defaultValue$1(e.cullRequestsWhileMoving,!0),cullRequestsWhileMovingMultiplier:defaultValue$1(e.cullRequestsWhileMovingMultiplier,60),dynamicScreenSpaceError:defaultValue$1(e.dynamicScreenSpaceError,!0),dynamicScreenSpaceErrorHeightFalloff:defaultValue$1(e.dynamicScreenSpaceErrorHeightFalloff,.25),dynamicScreenSpaceErrorDensity:defaultValue$1(e.dynamicScreenSpaceErrorDensity,.00278),foveatedScreenSpaceError:defaultValue$1(e.foveatedScreenSpaceError,!1),foveatedConeSize:defaultValue$1(e.foveatedConeSize,.3),foveatedMinimumScreenSpaceErrorRelaxation:defaultValue$1(e.foveatedMinimumScreenSpaceErrorRelaxation,.8),progressiveResolutionHeightFraction:defaultValue$1(e.progressiveResolutionHeightFraction,.5),cacheBytes:e.cacheBytes,maximumCacheOverflowBytes:e._maximumCacheOverflowBytes,loaders:e.loaders}),__publicField(this,"_showDebug",!1),__publicField(this,"transformFromEcefToPlane",((e,t,i=0)=>{let n=Transforms.eastNorthUpToFixedFrame(Transforms.lnglatToEcef(e,t,i));n.invert();const r=new three.Matrix4,s=this.engine.map.projectArrayCoordinate([e,t]);r.makeTranslation(s[0],s[1],0);const a=new three.Matrix4;a.multiplyMatrices(r,n),a.decompose(this.position,this.quaternion,this.scale)})),__publicField(this,"lockCameraViewport",(()=>{const e=this.getCamera(),t=this._lockedCamera=e.clone();this.setCamera(t),this._updateCameraHelper(t)})),__publicField(this,"releaseCameraViewport",(()=>{const e=this._engine;if(this._lockedCamera){const t=e.camera;this.setCamera(t),this._lockedCamera=null}this._destroyCameraHelper()})),this._errorTarget=t;const i=e.url,n=(e=defaultValue$1(e,{})).assetId;if(defined$2(n))IonResource.fromAssetId(n).then((t=>{let n;"json"===t.extension?n=t.getBaseUri(!0):t.isDataUri&&(n=""),this._resource=t,this._url=i,this._basePath=n,this._rootPath=n,Cesium3DTileset.loadJson(t).then((async i=>{this.setTilesetProperties(i,t,e)}))}));else{const t=Resource.createIfNeeded(i);let n;"json"===t.extension?n=t.getBaseUri(!0):t.isDataUri&&(n=""),this._resource=t,this._url=i,this._basePath=n,this._rootPath=n,Cesium3DTileset.loadJson(t).then((async i=>{this.setTilesetProperties(i,t,e)}))}}static async fromAssetId(e,t={}){const i=await IonResource.fromAssetId(e);t.url=i;return new Default3DTiles(t)}_updateCameraHelper(e){const t=this._engine;this._destroyCameraHelper();const i=this._cameraHelper=new three.CameraHelper(e);t.add(i)}_destroyCameraHelper(){const e=this._engine;this._cameraHelper&&(e.remove(this._cameraHelper),this._cameraHelper.dispose(),this._cameraHelper=null)}get showDebug(){return this._showDebug}set showDebug(e){this._showDebug!==e&&(this.debug=e,this.displayBoxBounds=e,this.displayRegionBounds=e,this.displaySphereBounds=e,this._showDebug=e)}get errorTarget(){return this.maximumScreenSpaceError}set errorTarget(e){this.maximumScreenSpaceError=e}get cullWithChildrenBounds(){return this._cullWithChildrenBounds}set cullWithChildrenBounds(e){this._cullWithChildrenBounds=e}get cullRequestsWhileMoving(){return this._cullRequestsWhileMoving}set cullRequestsWhileMoving(e){this._cullRequestsWhileMoving=e}get foveatedConeSize(){return this._foveatedConeSize}set foveatedConeSize(e){this._foveatedConeSize=e}get loadSiblings(){return this._loadSiblings}set loadSiblings(e){this._loadSiblings=e}}var wellknown={exports:{}};wellknown.exports=parse$1,wellknown.exports.parse=parse$1,wellknown.exports.stringify=stringify;var numberRegexp=/[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/,tuples=new RegExp("^"+numberRegexp.source+"(\\s"+numberRegexp.source+"){1,}");function parse$1(e){var t,i=e.split(";"),n=i.pop(),r=(i.shift()||"").split("=").pop(),s=0;function a(e){var t=n.substring(s).match(e);return t?(s+=t[0].length,t[0]):null}function o(){a(/^\s*/)}function l(){o();for(var e,t=0,i=[],n=[i],r=i;e=a(/^(\()/)||a(/^(\))/)||a(/^(,)/)||a(tuples);){if("("===e)n.push(r),r=[],n[n.length-1].push(r),t++;else if(")"===e){if(0===r.length)return null;if(!(r=n.pop()))return null;if(0===--t)break}else if(","===e)r=[],n[n.length-1].push(r);else{if(e.split(/\s/g).some(isNaN))return null;Array.prototype.push.apply(r,e.split(/\s/g).map(parseFloat))}o()}return 0!==t?null:i}function c(){for(var e,t,i=[];t=a(tuples)||a(/^(,)/);)","===t?(i.push(e),e=[]):t.split(/\s/g).some(isNaN)||(e||(e=[]),Array.prototype.push.apply(e,t.split(/\s/g).map(parseFloat))),o();return e?(i.push(e),i.length?i:null):null}function h(){return function(){if(!a(/^(point(\sz)?)/i))return null;if(o(),!a(/^(\()/))return null;var e=c();return e?(o(),a(/^(\))/)?{type:"Point",coordinates:e[0]}:null):null}()||function(){if(!a(/^(linestring(\sz)?)/i))return null;if(o(),!a(/^(\()/))return null;var e=c();return e&&a(/^(\))/)?{type:"LineString",coordinates:e}:null}()||function(){if(!a(/^(polygon(\sz)?)/i))return null;o();var e=l();return e?{type:"Polygon",coordinates:e}:null}()||function(){if(!a(/^(multipoint)/i))return null;o();var e=n.substring(n.indexOf("(")+1,n.length-1).replace(/\(/g,"").replace(/\)/g,"");n="MULTIPOINT ("+e+")";var t=l();return t?(o(),{type:"MultiPoint",coordinates:t}):null}()||function(){if(!a(/^(multilinestring)/i))return null;o();var e=l();return e?(o(),{type:"MultiLineString",coordinates:e}):null}()||function(){if(!a(/^(multipolygon)/i))return null;o();var e=l();return e?{type:"MultiPolygon",coordinates:e}:null}()||function(){var e,t=[];if(!a(/^(geometrycollection)/i))return null;if(o(),!a(/^(\()/))return null;for(;e=h();)t.push(e),o(),a(/^(,)/),o();return a(/^(\))/)?{type:"GeometryCollection",geometries:t}:null}()}return(t=h())&&r.match(/\d+/)&&(t.crs={type:"name",properties:{name:"urn:ogc:def:crs:EPSG::"+r}}),t}function stringify(e){function t(e){return e.join(" ")}function i(e){return e.map(t).join(", ")}function n(e){return e.map(i).map(r).join(", ")}function r(e){return"("+e+")"}switch("Feature"===e.type&&(e=e.geometry),e.type){case"Point":return"POINT ("+t(e.coordinates)+")";case"LineString":return"LINESTRING ("+i(e.coordinates)+")";case"Polygon":return"POLYGON ("+n(e.coordinates)+")";case"MultiPoint":return"MULTIPOINT ("+i(e.coordinates)+")";case"MultiPolygon":return"MULTIPOLYGON ("+(e.coordinates.map(n).map(r).join(", ")+")");case"MultiLineString":return"MULTILINESTRING ("+n(e.coordinates)+")";case"GeometryCollection":return"GEOMETRYCOLLECTION ("+e.geometries.map(stringify).join(", ")+")";default:throw new Error("stringify requires a valid GeoJSON Feature or geometry object as input")}}const _JSONDataSource=class extends DataSource{constructor(e={}){super(e),__publicField(this,"_coordinatesKey","coordinates"),__publicField(this,"_parseCoordinates"),__publicField(this,"_parseFeature"),this.type="JSONDataSource",e.coordinatesKey&&(this._coordinatesKey=e.coordinatesKey),e.parseCoordinates&&(this._parseCoordinates=e.parseCoordinates),e.parseFeature&&(this._parseFeature=e.parseFeature)}async _convertStreamingDataToObjectData(e){return await e.json()}_convertObjectDataToJSONData(e){return Array.isArray(e)?e:[e]}_parseObjectDataToDataItems(e){const t=this._convertObjectDataToJSONData(e),i=[];for(let n=0,r=t.length;n<r;n++){const e=t[n],r={};let s=null;if(this._parseFeature)i.push(this._parseFeature(e));else{for(const t of Object.keys(e))t!==this.coordinatesKey?r[t]=e[t]:this.parseCoordinates||(s=wellknown.exports(e[t]));this._parseCoordinates&&(s=this._parseCoordinates(e)),s=this._formatGeometry(s),i.push(new DataItem({geometry:s,properties:r}))}}return i}get coordinatesKey(){return this._coordinatesKey}set coordinatesKey(e){this._coordinatesKey=e}set parseCoordinates(e){this._parseCoordinates=e}get parseCoordinates(){return this._parseCoordinates}set parseFeature(e){this._parseFeature=e}get parseFeature(){return this._parseFeature}};let JSONDataSource=_JSONDataSource;__publicField(JSONDataSource,"fromURL",(async function(e,t){let i=new _JSONDataSource(t);return await i.load(e),i})),__publicField(JSONDataSource,"fromUrl",(async function(e,t){return console.warn("JSONDataSource.fromUrl is deprecated, please use JSONDataSource.fromURL instead."),await this.fromURL(e,t)})),__publicField(JSONDataSource,"fromJSON",(function(e,t){let i=new _JSONDataSource(t);return i.setData(e),i}));var global$1="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},lookup=[],revLookup=[],Arr="undefined"!=typeof Uint8Array?Uint8Array:Array,inited=!1;function init(){inited=!0;for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=0;t<64;++t)lookup[t]=e[t],revLookup[e.charCodeAt(t)]=t;revLookup["-".charCodeAt(0)]=62,revLookup["_".charCodeAt(0)]=63}function toByteArray(e){var t,i,n,r,s,a;inited||init();var o=e.length;if(o%4>0)throw new Error("Invalid string. Length must be a multiple of 4");s="="===e[o-2]?2:"="===e[o-1]?1:0,a=new Arr(3*o/4-s),n=s>0?o-4:o;var l=0;for(t=0,i=0;t<n;t+=4,i+=3)r=revLookup[e.charCodeAt(t)]<<18|revLookup[e.charCodeAt(t+1)]<<12|revLookup[e.charCodeAt(t+2)]<<6|revLookup[e.charCodeAt(t+3)],a[l++]=r>>16&255,a[l++]=r>>8&255,a[l++]=255&r;return 2===s?(r=revLookup[e.charCodeAt(t)]<<2|revLookup[e.charCodeAt(t+1)]>>4,a[l++]=255&r):1===s&&(r=revLookup[e.charCodeAt(t)]<<10|revLookup[e.charCodeAt(t+1)]<<4|revLookup[e.charCodeAt(t+2)]>>2,a[l++]=r>>8&255,a[l++]=255&r),a}function tripletToBase64(e){return lookup[e>>18&63]+lookup[e>>12&63]+lookup[e>>6&63]+lookup[63&e]}function encodeChunk(e,t,i){for(var n,r=[],s=t;s<i;s+=3)n=(e[s]<<16)+(e[s+1]<<8)+e[s+2],r.push(tripletToBase64(n));return r.join("")}function fromByteArray(e){var t;inited||init();for(var i=e.length,n=i%3,r="",s=[],a=16383,o=0,l=i-n;o<l;o+=a)s.push(encodeChunk(e,o,o+a>l?l:o+a));return 1===n?(t=e[i-1],r+=lookup[t>>2],r+=lookup[t<<4&63],r+="=="):2===n&&(t=(e[i-2]<<8)+e[i-1],r+=lookup[t>>10],r+=lookup[t>>4&63],r+=lookup[t<<2&63],r+="="),s.push(r),s.join("")}function read(e,t,i,n,r){var s,a,o=8*r-n-1,l=(1<<o)-1,c=l>>1,h=-7,u=i?r-1:0,d=i?-1:1,p=e[t+u];for(u+=d,s=p&(1<<-h)-1,p>>=-h,h+=o;h>0;s=256*s+e[t+u],u+=d,h-=8);for(a=s&(1<<-h)-1,s>>=-h,h+=n;h>0;a=256*a+e[t+u],u+=d,h-=8);if(0===s)s=1-c;else{if(s===l)return a?NaN:1/0*(p?-1:1);a+=Math.pow(2,n),s-=c}return(p?-1:1)*a*Math.pow(2,s-n)}function write(e,t,i,n,r,s){var a,o,l,c=8*s-r-1,h=(1<<c)-1,u=h>>1,d=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:s-1,m=n?1:-1,f=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,a=h):(a=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-a))<1&&(a--,l*=2),(t+=a+u>=1?d/l:d*Math.pow(2,1-u))*l>=2&&(a++,l/=2),a+u>=h?(o=0,a=h):a+u>=1?(o=(t*l-1)*Math.pow(2,r),a+=u):(o=t*Math.pow(2,u-1)*Math.pow(2,r),a=0));r>=8;e[i+p]=255&o,p+=m,o/=256,r-=8);for(a=a<<r|o,c+=r;c>0;e[i+p]=255&a,p+=m,a/=256,c-=8);e[i+p-m]|=128*f}var toString={}.toString,isArray=Array.isArray||function(e){return"[object Array]"==toString.call(e)},INSPECT_MAX_BYTES=50;function kMaxLength(){return Buffer$1.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function createBuffer(e,t){if(kMaxLength()<t)throw new RangeError("Invalid typed array length");return Buffer$1.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=Buffer$1.prototype:(null===e&&(e=new Buffer$1(t)),e.length=t),e}function Buffer$1(e,t,i){if(!(Buffer$1.TYPED_ARRAY_SUPPORT||this instanceof Buffer$1))return new Buffer$1(e,t,i);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return allocUnsafe(this,e)}return from(this,e,t,i)}function from(e,t,i,n){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?fromArrayBuffer(e,t,i,n):"string"==typeof t?fromString(e,t,i):fromObject(e,t)}function assertSize(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function alloc(e,t,i,n){return assertSize(t),t<=0?createBuffer(e,t):void 0!==i?"string"==typeof n?createBuffer(e,t).fill(i,n):createBuffer(e,t).fill(i):createBuffer(e,t)}function allocUnsafe(e,t){if(assertSize(t),e=createBuffer(e,t<0?0:0|checked(t)),!Buffer$1.TYPED_ARRAY_SUPPORT)for(var i=0;i<t;++i)e[i]=0;return e}function fromString(e,t,i){if("string"==typeof i&&""!==i||(i="utf8"),!Buffer$1.isEncoding(i))throw new TypeError('"encoding" must be a valid string encoding');var n=0|byteLength(t,i),r=(e=createBuffer(e,n)).write(t,i);return r!==n&&(e=e.slice(0,r)),e}function fromArrayLike(e,t){var i=t.length<0?0:0|checked(t.length);e=createBuffer(e,i);for(var n=0;n<i;n+=1)e[n]=255&t[n];return e}function fromArrayBuffer(e,t,i,n){if(t.byteLength,i<0||t.byteLength<i)throw new RangeError("'offset' is out of bounds");if(t.byteLength<i+(n||0))throw new RangeError("'length' is out of bounds");return t=void 0===i&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,i):new Uint8Array(t,i,n),Buffer$1.TYPED_ARRAY_SUPPORT?(e=t).__proto__=Buffer$1.prototype:e=fromArrayLike(e,t),e}function fromObject(e,t){if(internalIsBuffer(t)){var i=0|checked(t.length);return 0===(e=createBuffer(e,i)).length||t.copy(e,0,0,i),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||isnan(t.length)?createBuffer(e,0):fromArrayLike(e,t);if("Buffer"===t.type&&isArray(t.data))return fromArrayLike(e,t.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function checked(e){if(e>=kMaxLength())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+kMaxLength().toString(16)+" bytes");return 0|e}function internalIsBuffer(e){return!(null==e||!e._isBuffer)}function byteLength(e,t){if(internalIsBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var i=e.length;if(0===i)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return i;case"utf8":case"utf-8":case void 0:return utf8ToBytes(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*i;case"hex":return i>>>1;case"base64":return base64ToBytes(e).length;default:if(n)return utf8ToBytes(e).length;t=(""+t).toLowerCase(),n=!0}}function slowToString(e,t,i){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===i||i>this.length)&&(i=this.length),i<=0)return"";if((i>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return hexSlice(this,t,i);case"utf8":case"utf-8":return utf8Slice(this,t,i);case"ascii":return asciiSlice(this,t,i);case"latin1":case"binary":return latin1Slice(this,t,i);case"base64":return base64Slice(this,t,i);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return utf16leSlice(this,t,i);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function swap$1(e,t,i){var n=e[t];e[t]=e[i],e[i]=n}function bidirectionalIndexOf(e,t,i,n,r){if(0===e.length)return-1;if("string"==typeof i?(n=i,i=0):i>2147483647?i=2147483647:i<-2147483648&&(i=-2147483648),i=+i,isNaN(i)&&(i=r?0:e.length-1),i<0&&(i=e.length+i),i>=e.length){if(r)return-1;i=e.length-1}else if(i<0){if(!r)return-1;i=0}if("string"==typeof t&&(t=Buffer$1.from(t,n)),internalIsBuffer(t))return 0===t.length?-1:arrayIndexOf(e,t,i,n,r);if("number"==typeof t)return t&=255,Buffer$1.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?r?Uint8Array.prototype.indexOf.call(e,t,i):Uint8Array.prototype.lastIndexOf.call(e,t,i):arrayIndexOf(e,[t],i,n,r);throw new TypeError("val must be string, number or Buffer")}function arrayIndexOf(e,t,i,n,r){var s,a=1,o=e.length,l=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;a=2,o/=2,l/=2,i/=2}function c(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}if(r){var h=-1;for(s=i;s<o;s++)if(c(e,s)===c(t,-1===h?0:s-h)){if(-1===h&&(h=s),s-h+1===l)return h*a}else-1!==h&&(s-=s-h),h=-1}else for(i+l>o&&(i=o-l),s=i;s>=0;s--){for(var u=!0,d=0;d<l;d++)if(c(e,s+d)!==c(t,d)){u=!1;break}if(u)return s}return-1}function hexWrite(e,t,i,n){i=Number(i)||0;var r=e.length-i;n?(n=Number(n))>r&&(n=r):n=r;var s=t.length;if(s%2!=0)throw new TypeError("Invalid hex string");n>s/2&&(n=s/2);for(var a=0;a<n;++a){var o=parseInt(t.substr(2*a,2),16);if(isNaN(o))return a;e[i+a]=o}return a}function utf8Write(e,t,i,n){return blitBuffer(utf8ToBytes(t,e.length-i),e,i,n)}function asciiWrite(e,t,i,n){return blitBuffer(asciiToBytes(t),e,i,n)}function latin1Write(e,t,i,n){return asciiWrite(e,t,i,n)}function base64Write(e,t,i,n){return blitBuffer(base64ToBytes(t),e,i,n)}function ucs2Write(e,t,i,n){return blitBuffer(utf16leToBytes(t,e.length-i),e,i,n)}function base64Slice(e,t,i){return 0===t&&i===e.length?fromByteArray(e):fromByteArray(e.slice(t,i))}function utf8Slice(e,t,i){i=Math.min(e.length,i);for(var n=[],r=t;r<i;){var s,a,o,l,c=e[r],h=null,u=c>239?4:c>223?3:c>191?2:1;if(r+u<=i)switch(u){case 1:c<128&&(h=c);break;case 2:128==(192&(s=e[r+1]))&&(l=(31&c)<<6|63&s)>127&&(h=l);break;case 3:s=e[r+1],a=e[r+2],128==(192&s)&&128==(192&a)&&(l=(15&c)<<12|(63&s)<<6|63&a)>2047&&(l<55296||l>57343)&&(h=l);break;case 4:s=e[r+1],a=e[r+2],o=e[r+3],128==(192&s)&&128==(192&a)&&128==(192&o)&&(l=(15&c)<<18|(63&s)<<12|(63&a)<<6|63&o)>65535&&l<1114112&&(h=l)}null===h?(h=65533,u=1):h>65535&&(h-=65536,n.push(h>>>10&1023|55296),h=56320|1023&h),n.push(h),r+=u}return decodeCodePointsArray(n)}Buffer$1.TYPED_ARRAY_SUPPORT=void 0===global$1.TYPED_ARRAY_SUPPORT||global$1.TYPED_ARRAY_SUPPORT,kMaxLength(),Buffer$1.poolSize=8192,Buffer$1._augment=function(e){return e.__proto__=Buffer$1.prototype,e},Buffer$1.from=function(e,t,i){return from(null,e,t,i)},Buffer$1.TYPED_ARRAY_SUPPORT&&(Buffer$1.prototype.__proto__=Uint8Array.prototype,Buffer$1.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&Buffer$1[Symbol.species]),Buffer$1.alloc=function(e,t,i){return alloc(null,e,t,i)},Buffer$1.allocUnsafe=function(e){return allocUnsafe(null,e)},Buffer$1.allocUnsafeSlow=function(e){return allocUnsafe(null,e)},Buffer$1.isBuffer=isBuffer,Buffer$1.compare=function(e,t){if(!internalIsBuffer(e)||!internalIsBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var i=e.length,n=t.length,r=0,s=Math.min(i,n);r<s;++r)if(e[r]!==t[r]){i=e[r],n=t[r];break}return i<n?-1:n<i?1:0},Buffer$1.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Buffer$1.concat=function(e,t){if(!isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return Buffer$1.alloc(0);var i;if(void 0===t)for(t=0,i=0;i<e.length;++i)t+=e[i].length;var n=Buffer$1.allocUnsafe(t),r=0;for(i=0;i<e.length;++i){var s=e[i];if(!internalIsBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(n,r),r+=s.length}return n},Buffer$1.byteLength=byteLength,Buffer$1.prototype._isBuffer=!0,Buffer$1.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)swap$1(this,t,t+1);return this},Buffer$1.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)swap$1(this,t,t+3),swap$1(this,t+1,t+2);return this},Buffer$1.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)swap$1(this,t,t+7),swap$1(this,t+1,t+6),swap$1(this,t+2,t+5),swap$1(this,t+3,t+4);return this},Buffer$1.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?utf8Slice(this,0,e):slowToString.apply(this,arguments)},Buffer$1.prototype.equals=function(e){if(!internalIsBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===Buffer$1.compare(this,e)},Buffer$1.prototype.inspect=function(){var e="",t=INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length>t&&(e+=" ... ")),"<Buffer "+e+">"},Buffer$1.prototype.compare=function(e,t,i,n,r){if(!internalIsBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===i&&(i=e?e.length:0),void 0===n&&(n=0),void 0===r&&(r=this.length),t<0||i>e.length||n<0||r>this.length)throw new RangeError("out of range index");if(n>=r&&t>=i)return 0;if(n>=r)return-1;if(t>=i)return 1;if(this===e)return 0;for(var s=(r>>>=0)-(n>>>=0),a=(i>>>=0)-(t>>>=0),o=Math.min(s,a),l=this.slice(n,r),c=e.slice(t,i),h=0;h<o;++h)if(l[h]!==c[h]){s=l[h],a=c[h];break}return s<a?-1:a<s?1:0},Buffer$1.prototype.includes=function(e,t,i){return-1!==this.indexOf(e,t,i)},Buffer$1.prototype.indexOf=function(e,t,i){return bidirectionalIndexOf(this,e,t,i,!0)},Buffer$1.prototype.lastIndexOf=function(e,t,i){return bidirectionalIndexOf(this,e,t,i,!1)},Buffer$1.prototype.write=function(e,t,i,n){if(void 0===t)n="utf8",i=this.length,t=0;else if(void 0===i&&"string"==typeof t)n=t,i=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(i)?(i|=0,void 0===n&&(n="utf8")):(n=i,i=void 0)}var r=this.length-t;if((void 0===i||i>r)&&(i=r),e.length>0&&(i<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var s=!1;;)switch(n){case"hex":return hexWrite(this,e,t,i);case"utf8":case"utf-8":return utf8Write(this,e,t,i);case"ascii":return asciiWrite(this,e,t,i);case"latin1":case"binary":return latin1Write(this,e,t,i);case"base64":return base64Write(this,e,t,i);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ucs2Write(this,e,t,i);default:if(s)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),s=!0}},Buffer$1.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var MAX_ARGUMENTS_LENGTH=4096;function decodeCodePointsArray(e){var t=e.length;if(t<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,e);for(var i="",n=0;n<t;)i+=String.fromCharCode.apply(String,e.slice(n,n+=MAX_ARGUMENTS_LENGTH));return i}function asciiSlice(e,t,i){var n="";i=Math.min(e.length,i);for(var r=t;r<i;++r)n+=String.fromCharCode(127&e[r]);return n}function latin1Slice(e,t,i){var n="";i=Math.min(e.length,i);for(var r=t;r<i;++r)n+=String.fromCharCode(e[r]);return n}function hexSlice(e,t,i){var n=e.length;(!t||t<0)&&(t=0),(!i||i<0||i>n)&&(i=n);for(var r="",s=t;s<i;++s)r+=toHex(e[s]);return r}function utf16leSlice(e,t,i){for(var n=e.slice(t,i),r="",s=0;s<n.length;s+=2)r+=String.fromCharCode(n[s]+256*n[s+1]);return r}function checkOffset(e,t,i){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>i)throw new RangeError("Trying to access beyond buffer length")}function checkInt(e,t,i,n,r,s){if(!internalIsBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>r||t<s)throw new RangeError('"value" argument is out of bounds');if(i+n>e.length)throw new RangeError("Index out of range")}function objectWriteUInt16(e,t,i,n){t<0&&(t=65535+t+1);for(var r=0,s=Math.min(e.length-i,2);r<s;++r)e[i+r]=(t&255<<8*(n?r:1-r))>>>8*(n?r:1-r)}function objectWriteUInt32(e,t,i,n){t<0&&(t=4294967295+t+1);for(var r=0,s=Math.min(e.length-i,4);r<s;++r)e[i+r]=t>>>8*(n?r:3-r)&255}function checkIEEE754(e,t,i,n,r,s){if(i+n>e.length)throw new RangeError("Index out of range");if(i<0)throw new RangeError("Index out of range")}function writeFloat(e,t,i,n,r){return r||checkIEEE754(e,t,i,4),write(e,t,i,n,23,4),i+4}function writeDouble(e,t,i,n,r){return r||checkIEEE754(e,t,i,8),write(e,t,i,n,52,8),i+8}Buffer$1.prototype.slice=function(e,t){var i,n=this.length;if((e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e),Buffer$1.TYPED_ARRAY_SUPPORT)(i=this.subarray(e,t)).__proto__=Buffer$1.prototype;else{var r=t-e;i=new Buffer$1(r,void 0);for(var s=0;s<r;++s)i[s]=this[s+e]}return i},Buffer$1.prototype.readUIntLE=function(e,t,i){e|=0,t|=0,i||checkOffset(e,t,this.length);for(var n=this[e],r=1,s=0;++s<t&&(r*=256);)n+=this[e+s]*r;return n},Buffer$1.prototype.readUIntBE=function(e,t,i){e|=0,t|=0,i||checkOffset(e,t,this.length);for(var n=this[e+--t],r=1;t>0&&(r*=256);)n+=this[e+--t]*r;return n},Buffer$1.prototype.readUInt8=function(e,t){return t||checkOffset(e,1,this.length),this[e]},Buffer$1.prototype.readUInt16LE=function(e,t){return t||checkOffset(e,2,this.length),this[e]|this[e+1]<<8},Buffer$1.prototype.readUInt16BE=function(e,t){return t||checkOffset(e,2,this.length),this[e]<<8|this[e+1]},Buffer$1.prototype.readUInt32LE=function(e,t){return t||checkOffset(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},Buffer$1.prototype.readUInt32BE=function(e,t){return t||checkOffset(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},Buffer$1.prototype.readIntLE=function(e,t,i){e|=0,t|=0,i||checkOffset(e,t,this.length);for(var n=this[e],r=1,s=0;++s<t&&(r*=256);)n+=this[e+s]*r;return n>=(r*=128)&&(n-=Math.pow(2,8*t)),n},Buffer$1.prototype.readIntBE=function(e,t,i){e|=0,t|=0,i||checkOffset(e,t,this.length);for(var n=t,r=1,s=this[e+--n];n>0&&(r*=256);)s+=this[e+--n]*r;return s>=(r*=128)&&(s-=Math.pow(2,8*t)),s},Buffer$1.prototype.readInt8=function(e,t){return t||checkOffset(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},Buffer$1.prototype.readInt16LE=function(e,t){t||checkOffset(e,2,this.length);var i=this[e]|this[e+1]<<8;return 32768&i?4294901760|i:i},Buffer$1.prototype.readInt16BE=function(e,t){t||checkOffset(e,2,this.length);var i=this[e+1]|this[e]<<8;return 32768&i?4294901760|i:i},Buffer$1.prototype.readInt32LE=function(e,t){return t||checkOffset(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},Buffer$1.prototype.readInt32BE=function(e,t){return t||checkOffset(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},Buffer$1.prototype.readFloatLE=function(e,t){return t||checkOffset(e,4,this.length),read(this,e,!0,23,4)},Buffer$1.prototype.readFloatBE=function(e,t){return t||checkOffset(e,4,this.length),read(this,e,!1,23,4)},Buffer$1.prototype.readDoubleLE=function(e,t){return t||checkOffset(e,8,this.length),read(this,e,!0,52,8)},Buffer$1.prototype.readDoubleBE=function(e,t){return t||checkOffset(e,8,this.length),read(this,e,!1,52,8)},Buffer$1.prototype.writeUIntLE=function(e,t,i,n){(e=+e,t|=0,i|=0,n)||checkInt(this,e,t,i,Math.pow(2,8*i)-1,0);var r=1,s=0;for(this[t]=255&e;++s<i&&(r*=256);)this[t+s]=e/r&255;return t+i},Buffer$1.prototype.writeUIntBE=function(e,t,i,n){(e=+e,t|=0,i|=0,n)||checkInt(this,e,t,i,Math.pow(2,8*i)-1,0);var r=i-1,s=1;for(this[t+r]=255&e;--r>=0&&(s*=256);)this[t+r]=e/s&255;return t+i},Buffer$1.prototype.writeUInt8=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,1,255,0),Buffer$1.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},Buffer$1.prototype.writeUInt16LE=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,2,65535,0),Buffer$1.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):objectWriteUInt16(this,e,t,!0),t+2},Buffer$1.prototype.writeUInt16BE=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,2,65535,0),Buffer$1.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):objectWriteUInt16(this,e,t,!1),t+2},Buffer$1.prototype.writeUInt32LE=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,4,4294967295,0),Buffer$1.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):objectWriteUInt32(this,e,t,!0),t+4},Buffer$1.prototype.writeUInt32BE=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,4,4294967295,0),Buffer$1.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):objectWriteUInt32(this,e,t,!1),t+4},Buffer$1.prototype.writeIntLE=function(e,t,i,n){if(e=+e,t|=0,!n){var r=Math.pow(2,8*i-1);checkInt(this,e,t,i,r-1,-r)}var s=0,a=1,o=0;for(this[t]=255&e;++s<i&&(a*=256);)e<0&&0===o&&0!==this[t+s-1]&&(o=1),this[t+s]=(e/a|0)-o&255;return t+i},Buffer$1.prototype.writeIntBE=function(e,t,i,n){if(e=+e,t|=0,!n){var r=Math.pow(2,8*i-1);checkInt(this,e,t,i,r-1,-r)}var s=i-1,a=1,o=0;for(this[t+s]=255&e;--s>=0&&(a*=256);)e<0&&0===o&&0!==this[t+s+1]&&(o=1),this[t+s]=(e/a|0)-o&255;return t+i},Buffer$1.prototype.writeInt8=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,1,127,-128),Buffer$1.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},Buffer$1.prototype.writeInt16LE=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,2,32767,-32768),Buffer$1.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):objectWriteUInt16(this,e,t,!0),t+2},Buffer$1.prototype.writeInt16BE=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,2,32767,-32768),Buffer$1.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):objectWriteUInt16(this,e,t,!1),t+2},Buffer$1.prototype.writeInt32LE=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,4,2147483647,-2147483648),Buffer$1.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):objectWriteUInt32(this,e,t,!0),t+4},Buffer$1.prototype.writeInt32BE=function(e,t,i){return e=+e,t|=0,i||checkInt(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),Buffer$1.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):objectWriteUInt32(this,e,t,!1),t+4},Buffer$1.prototype.writeFloatLE=function(e,t,i){return writeFloat(this,e,t,!0,i)},Buffer$1.prototype.writeFloatBE=function(e,t,i){return writeFloat(this,e,t,!1,i)},Buffer$1.prototype.writeDoubleLE=function(e,t,i){return writeDouble(this,e,t,!0,i)},Buffer$1.prototype.writeDoubleBE=function(e,t,i){return writeDouble(this,e,t,!1,i)},Buffer$1.prototype.copy=function(e,t,i,n){if(i||(i=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<i&&(n=i),n===i)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(i<0||i>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-i&&(n=e.length-t+i);var r,s=n-i;if(this===e&&i<t&&t<n)for(r=s-1;r>=0;--r)e[r+t]=this[r+i];else if(s<1e3||!Buffer$1.TYPED_ARRAY_SUPPORT)for(r=0;r<s;++r)e[r+t]=this[r+i];else Uint8Array.prototype.set.call(e,this.subarray(i,i+s),t);return s},Buffer$1.prototype.fill=function(e,t,i,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,i=this.length):"string"==typeof i&&(n=i,i=this.length),1===e.length){var r=e.charCodeAt(0);r<256&&(e=r)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!Buffer$1.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<i)throw new RangeError("Out of range index");if(i<=t)return this;var s;if(t>>>=0,i=void 0===i?this.length:i>>>0,e||(e=0),"number"==typeof e)for(s=t;s<i;++s)this[s]=e;else{var a=internalIsBuffer(e)?e:utf8ToBytes(new Buffer$1(e,n).toString()),o=a.length;for(s=0;s<i-t;++s)this[s+t]=a[s%o]}return this};var INVALID_BASE64_RE=/[^+\/0-9A-Za-z-_]/g;function base64clean(e){if((e=stringtrim(e).replace(INVALID_BASE64_RE,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}function stringtrim(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}function toHex(e){return e<16?"0"+e.toString(16):e.toString(16)}function utf8ToBytes(e,t){var i;t=t||1/0;for(var n=e.length,r=null,s=[],a=0;a<n;++a){if((i=e.charCodeAt(a))>55295&&i<57344){if(!r){if(i>56319){(t-=3)>-1&&s.push(239,191,189);continue}if(a+1===n){(t-=3)>-1&&s.push(239,191,189);continue}r=i;continue}if(i<56320){(t-=3)>-1&&s.push(239,191,189),r=i;continue}i=65536+(r-55296<<10|i-56320)}else r&&(t-=3)>-1&&s.push(239,191,189);if(r=null,i<128){if((t-=1)<0)break;s.push(i)}else if(i<2048){if((t-=2)<0)break;s.push(i>>6|192,63&i|128)}else if(i<65536){if((t-=3)<0)break;s.push(i>>12|224,i>>6&63|128,63&i|128)}else{if(!(i<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;s.push(i>>18|240,i>>12&63|128,i>>6&63|128,63&i|128)}}return s}function asciiToBytes(e){for(var t=[],i=0;i<e.length;++i)t.push(255&e.charCodeAt(i));return t}function utf16leToBytes(e,t){for(var i,n,r,s=[],a=0;a<e.length&&!((t-=2)<0);++a)n=(i=e.charCodeAt(a))>>8,r=i%256,s.push(r),s.push(n);return s}function base64ToBytes(e){return toByteArray(base64clean(e))}function blitBuffer(e,t,i,n){for(var r=0;r<n&&!(r+i>=t.length||r>=e.length);++r)t[r+i]=e[r];return r}function isnan(e){return e!=e}function isBuffer(e){return null!=e&&(!!e._isBuffer||isFastBuffer(e)||isSlowBuffer(e))}function isFastBuffer(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}function isSlowBuffer(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&isFastBuffer(e.slice(0,0))}class CsvError extends Error{constructor(e,t,i,...n){Array.isArray(t)&&(t=t.join(" ").trim()),super(t),void 0!==Error.captureStackTrace&&Error.captureStackTrace(this,CsvError),this.code=e;for(const r of n)for(const e in r){const t=r[e];this[e]=isBuffer(t)?t.toString(i.encoding):null==t?t:JSON.parse(JSON.stringify(t))}}}const is_object=function(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)},normalize_columns_array=function(e){const t=[];for(let i=0,n=e.length;i<n;i++){const n=e[i];if(null==n||!1===n)t[i]={disabled:!0};else if("string"==typeof n)t[i]={name:n};else{if(!is_object(n))throw new CsvError("CSV_INVALID_COLUMN_DEFINITION",["Invalid column definition:","expect a string or a literal object,",`got ${JSON.stringify(n)} at position ${i}`]);if("string"!=typeof n.name)throw new CsvError("CSV_OPTION_COLUMNS_MISSING_NAME",["Option columns missing name:",`property "name" is required at position ${i}`,"when column is an object literal"]);t[i]=n}}return t};class ResizeableBuffer{constructor(e=100){this.size=e,this.length=0,this.buf=Buffer$1.allocUnsafe(e)}prepend(e){if(isBuffer(e)){const t=this.length+e.length;if(t>=this.size&&(this.resize(),t>=this.size))throw Error("INVALID_BUFFER_STATE");const i=this.buf;this.buf=Buffer$1.allocUnsafe(this.size),e.copy(this.buf,0),i.copy(this.buf,e.length),this.length+=e.length}else{const t=this.length++;t===this.size&&this.resize();const i=this.clone();this.buf[0]=e,i.copy(this.buf,1,0,t)}}append(e){const t=this.length++;t===this.size&&this.resize(),this.buf[t]=e}clone(){return Buffer$1.from(this.buf.slice(0,this.length))}resize(){const e=this.length;this.size=2*this.size;const t=Buffer$1.allocUnsafe(this.size);this.buf.copy(t,0,0,e),this.buf=t}toString(e){return e?this.buf.slice(0,this.length).toString(e):Uint8Array.prototype.slice.call(this.buf.slice(0,this.length))}toJSON(){return this.toString("utf8")}reset(){this.length=0}}const np=12,cr$1=13,nl$1=10,space=32,tab=9,init_state=function(e){return{bomSkipped:!1,bufBytesStart:0,castField:e.cast_function,commenting:!1,error:void 0,enabled:1===e.from_line,escaping:!1,escapeIsQuote:isBuffer(e.escape)&&isBuffer(e.quote)&&0===Buffer$1.compare(e.escape,e.quote),expectedRecordLength:Array.isArray(e.columns)?e.columns.length:void 0,field:new ResizeableBuffer(20),firstLineToHeaders:e.cast_first_line_to_header,needMoreDataSize:Math.max(null!==e.comment?e.comment.length:0,...e.delimiter.map((e=>e.length)),null!==e.quote?e.quote.length:0),previousBuf:void 0,quoting:!1,stop:!1,rawBuffer:new ResizeableBuffer(100),record:[],recordHasError:!1,record_length:0,recordDelimiterMaxLength:0===e.record_delimiter.length?0:Math.max(...e.record_delimiter.map((e=>e.length))),trimChars:[Buffer$1.from(" ",e.encoding)[0],Buffer$1.from("\t",e.encoding)[0]],wasQuoting:!1,wasRowDelimiter:!1,timchars:[Buffer$1.from(Buffer$1.from([cr$1],"utf8").toString(),e.encoding),Buffer$1.from(Buffer$1.from([nl$1],"utf8").toString(),e.encoding),Buffer$1.from(Buffer$1.from([np],"utf8").toString(),e.encoding),Buffer$1.from(Buffer$1.from([space],"utf8").toString(),e.encoding),Buffer$1.from(Buffer$1.from([tab],"utf8").toString(),e.encoding)]}},underscore=function(e){return e.replace(/([A-Z])/g,(function(e,t){return"_"+t.toLowerCase()}))},normalize_options=function(e){const t={};for(const n in e)t[underscore(n)]=e[n];if(void 0===t.encoding||!0===t.encoding)t.encoding="utf8";else if(null===t.encoding||!1===t.encoding)t.encoding=null;else if("string"!=typeof t.encoding&&null!==t.encoding)throw new CsvError("CSV_INVALID_OPTION_ENCODING",["Invalid option encoding:","encoding must be a string or null to return a buffer,",`got ${JSON.stringify(t.encoding)}`],t);if(void 0===t.bom||null===t.bom||!1===t.bom)t.bom=!1;else if(!0!==t.bom)throw new CsvError("CSV_INVALID_OPTION_BOM",["Invalid option bom:","bom must be true,",`got ${JSON.stringify(t.bom)}`],t);if(t.cast_function=null,void 0===t.cast||null===t.cast||!1===t.cast||""===t.cast)t.cast=void 0;else if("function"==typeof t.cast)t.cast_function=t.cast,t.cast=!0;else if(!0!==t.cast)throw new CsvError("CSV_INVALID_OPTION_CAST",["Invalid option cast:","cast must be true or a function,",`got ${JSON.stringify(t.cast)}`],t);if(void 0===t.cast_date||null===t.cast_date||!1===t.cast_date||""===t.cast_date)t.cast_date=!1;else if(!0===t.cast_date)t.cast_date=function(e){const t=Date.parse(e);return isNaN(t)?e:new Date(t)};else if("function"!=typeof t.cast_date)throw new CsvError("CSV_INVALID_OPTION_CAST_DATE",["Invalid option cast_date:","cast_date must be true or a function,",`got ${JSON.stringify(t.cast_date)}`],t);if(t.cast_first_line_to_header=null,!0===t.columns)t.cast_first_line_to_header=void 0;else if("function"==typeof t.columns)t.cast_first_line_to_header=t.columns,t.columns=!0;else if(Array.isArray(t.columns))t.columns=normalize_columns_array(t.columns);else{if(void 0!==t.columns&&null!==t.columns&&!1!==t.columns)throw new CsvError("CSV_INVALID_OPTION_COLUMNS",["Invalid option columns:","expect an array, a function or true,",`got ${JSON.stringify(t.columns)}`],t);t.columns=!1}if(void 0===t.group_columns_by_name||null===t.group_columns_by_name||!1===t.group_columns_by_name)t.group_columns_by_name=!1;else{if(!0!==t.group_columns_by_name)throw new CsvError("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",["Invalid option group_columns_by_name:","expect an boolean,",`got ${JSON.stringify(t.group_columns_by_name)}`],t);if(!1===t.columns)throw new CsvError("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",["Invalid option group_columns_by_name:","the `columns` mode must be activated."],t)}if(void 0===t.comment||null===t.comment||!1===t.comment||""===t.comment)t.comment=null;else if("string"==typeof t.comment&&(t.comment=Buffer$1.from(t.comment,t.encoding)),!isBuffer(t.comment))throw new CsvError("CSV_INVALID_OPTION_COMMENT",["Invalid option comment:","comment must be a buffer or a string,",`got ${JSON.stringify(t.comment)}`],t);if(void 0===t.comment_no_infix||null===t.comment_no_infix||!1===t.comment_no_infix)t.comment_no_infix=!1;else if(!0!==t.comment_no_infix)throw new CsvError("CSV_INVALID_OPTION_COMMENT",["Invalid option comment_no_infix:","value must be a boolean,",`got ${JSON.stringify(t.comment_no_infix)}`],t);const i=JSON.stringify(t.delimiter);if(Array.isArray(t.delimiter)||(t.delimiter=[t.delimiter]),0===t.delimiter.length)throw new CsvError("CSV_INVALID_OPTION_DELIMITER",["Invalid option delimiter:","delimiter must be a non empty string or buffer or array of string|buffer,",`got ${i}`],t);if(t.delimiter=t.delimiter.map((function(e){if(null==e||!1===e)return Buffer$1.from(",",t.encoding);if("string"==typeof e&&(e=Buffer$1.from(e,t.encoding)),!isBuffer(e)||0===e.length)throw new CsvError("CSV_INVALID_OPTION_DELIMITER",["Invalid option delimiter:","delimiter must be a non empty string or buffer or array of string|buffer,",`got ${i}`],t);return e})),void 0===t.escape||!0===t.escape?t.escape=Buffer$1.from('"',t.encoding):"string"==typeof t.escape?t.escape=Buffer$1.from(t.escape,t.encoding):null!==t.escape&&!1!==t.escape||(t.escape=null),null!==t.escape&&!isBuffer(t.escape))throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(t.escape)}`);if(void 0===t.from||null===t.from)t.from=1;else{if("string"==typeof t.from&&/\d+/.test(t.from)&&(t.from=parseInt(t.from)),!Number.isInteger(t.from))throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(t.from)}`);if(t.from<0)throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(e.from)}`)}if(void 0===t.from_line||null===t.from_line)t.from_line=1;else{if("string"==typeof t.from_line&&/\d+/.test(t.from_line)&&(t.from_line=parseInt(t.from_line)),!Number.isInteger(t.from_line))throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(e.from_line)}`);if(t.from_line<=0)throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(e.from_line)}`)}if(void 0===t.ignore_last_delimiters||null===t.ignore_last_delimiters)t.ignore_last_delimiters=!1;else if("number"==typeof t.ignore_last_delimiters)t.ignore_last_delimiters=Math.floor(t.ignore_last_delimiters),0===t.ignore_last_delimiters&&(t.ignore_last_delimiters=!1);else if("boolean"!=typeof t.ignore_last_delimiters)throw new CsvError("CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS",["Invalid option `ignore_last_delimiters`:","the value must be a boolean value or an integer,",`got ${JSON.stringify(t.ignore_last_delimiters)}`],t);if(!0===t.ignore_last_delimiters&&!1===t.columns)throw new CsvError("CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS",["The option `ignore_last_delimiters`","requires the activation of the `columns` option"],t);if(void 0===t.info||null===t.info||!1===t.info)t.info=!1;else if(!0!==t.info)throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(t.info)}`);if(void 0===t.max_record_size||null===t.max_record_size||!1===t.max_record_size)t.max_record_size=0;else if(Number.isInteger(t.max_record_size)&&t.max_record_size>=0);else{if("string"!=typeof t.max_record_size||!/\d+/.test(t.max_record_size))throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(t.max_record_size)}`);t.max_record_size=parseInt(t.max_record_size)}if(void 0===t.objname||null===t.objname||!1===t.objname)t.objname=void 0;else if(isBuffer(t.objname)){if(0===t.objname.length)throw new Error("Invalid Option: objname must be a non empty buffer");null===t.encoding||(t.objname=t.objname.toString(t.encoding))}else if("string"==typeof t.objname){if(0===t.objname.length)throw new Error("Invalid Option: objname must be a non empty string")}else if("number"!=typeof t.objname)throw new Error(`Invalid Option: objname must be a string or a buffer, got ${t.objname}`);if(void 0!==t.objname)if("number"==typeof t.objname){if(!1!==t.columns)throw Error("Invalid Option: objname index cannot be combined with columns or be defined as a field")}else if(!1===t.columns)throw Error("Invalid Option: objname field must be combined with columns or be defined as an index");if(void 0===t.on_record||null===t.on_record)t.on_record=void 0;else if("function"!=typeof t.on_record)throw new CsvError("CSV_INVALID_OPTION_ON_RECORD",["Invalid option `on_record`:","expect a function,",`got ${JSON.stringify(t.on_record)}`],t);if(void 0!==t.on_skip&&null!==t.on_skip&&"function"!=typeof t.on_skip)throw new Error(`Invalid Option: on_skip must be a function, got ${JSON.stringify(t.on_skip)}`);if(null===t.quote||!1===t.quote||""===t.quote)t.quote=null;else if(void 0===t.quote||!0===t.quote?t.quote=Buffer$1.from('"',t.encoding):"string"==typeof t.quote&&(t.quote=Buffer$1.from(t.quote,t.encoding)),!isBuffer(t.quote))throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(t.quote)}`);if(void 0===t.raw||null===t.raw||!1===t.raw)t.raw=!1;else if(!0!==t.raw)throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(t.raw)}`);if(void 0===t.record_delimiter)t.record_delimiter=[];else if("string"==typeof t.record_delimiter||isBuffer(t.record_delimiter)){if(0===t.record_delimiter.length)throw new CsvError("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a non empty string or buffer,",`got ${JSON.stringify(t.record_delimiter)}`],t);t.record_delimiter=[t.record_delimiter]}else if(!Array.isArray(t.record_delimiter))throw new CsvError("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a string, a buffer or array of string|buffer,",`got ${JSON.stringify(t.record_delimiter)}`],t);if(t.record_delimiter=t.record_delimiter.map((function(e,i){if("string"!=typeof e&&!isBuffer(e))throw new CsvError("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a string, a buffer or array of string|buffer",`at index ${i},`,`got ${JSON.stringify(e)}`],t);if(0===e.length)throw new CsvError("CSV_INVALID_OPTION_RECORD_DELIMITER",["Invalid option `record_delimiter`:","value must be a non empty string or buffer",`at index ${i},`,`got ${JSON.stringify(e)}`],t);return"string"==typeof e&&(e=Buffer$1.from(e,t.encoding)),e})),"boolean"==typeof t.relax_column_count);else{if(void 0!==t.relax_column_count&&null!==t.relax_column_count)throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(t.relax_column_count)}`);t.relax_column_count=!1}if("boolean"==typeof t.relax_column_count_less);else{if(void 0!==t.relax_column_count_less&&null!==t.relax_column_count_less)throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(t.relax_column_count_less)}`);t.relax_column_count_less=!1}if("boolean"==typeof t.relax_column_count_more);else{if(void 0!==t.relax_column_count_more&&null!==t.relax_column_count_more)throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(t.relax_column_count_more)}`);t.relax_column_count_more=!1}if("boolean"==typeof t.relax_quotes);else{if(void 0!==t.relax_quotes&&null!==t.relax_quotes)throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(t.relax_quotes)}`);t.relax_quotes=!1}if("boolean"==typeof t.skip_empty_lines);else{if(void 0!==t.skip_empty_lines&&null!==t.skip_empty_lines)throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(t.skip_empty_lines)}`);t.skip_empty_lines=!1}if("boolean"==typeof t.skip_records_with_empty_values);else{if(void 0!==t.skip_records_with_empty_values&&null!==t.skip_records_with_empty_values)throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(t.skip_records_with_empty_values)}`);t.skip_records_with_empty_values=!1}if("boolean"==typeof t.skip_records_with_error);else{if(void 0!==t.skip_records_with_error&&null!==t.skip_records_with_error)throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(t.skip_records_with_error)}`);t.skip_records_with_error=!1}if(void 0===t.rtrim||null===t.rtrim||!1===t.rtrim)t.rtrim=!1;else if(!0!==t.rtrim)throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(t.rtrim)}`);if(void 0===t.ltrim||null===t.ltrim||!1===t.ltrim)t.ltrim=!1;else if(!0!==t.ltrim)throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(t.ltrim)}`);if(void 0===t.trim||null===t.trim||!1===t.trim)t.trim=!1;else if(!0!==t.trim)throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(t.trim)}`);if(!0===t.trim&&!1!==e.ltrim?t.ltrim=!0:!0!==t.ltrim&&(t.ltrim=!1),!0===t.trim&&!1!==e.rtrim?t.rtrim=!0:!0!==t.rtrim&&(t.rtrim=!1),void 0===t.to||null===t.to)t.to=-1;else{if("string"==typeof t.to&&/\d+/.test(t.to)&&(t.to=parseInt(t.to)),!Number.isInteger(t.to))throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(e.to)}`);if(t.to<=0)throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(e.to)}`)}if(void 0===t.to_line||null===t.to_line)t.to_line=-1;else{if("string"==typeof t.to_line&&/\d+/.test(t.to_line)&&(t.to_line=parseInt(t.to_line)),!Number.isInteger(t.to_line))throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(e.to_line)}`);if(t.to_line<=0)throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(e.to_line)}`)}return t},isRecordEmpty=function(e){return e.every((e=>null==e||e.toString&&""===e.toString().trim()))},cr=13,nl=10,boms={utf8:Buffer$1.from([239,187,191]),utf16le:Buffer$1.from([255,254])},transform=function(e={}){const t=normalize_options(e);return{info:{bytes:0,comment_lines:0,empty_lines:0,invalid_field_length:0,lines:1,records:0},original_options:e,options:t,state:init_state(t),__needMoreData:function(e,t,i){if(i)return!1;const{encoding:n,escape:r,quote:s}=this.options,{quoting:a,needMoreDataSize:o,recordDelimiterMaxLength:l}=this.state;return t-e-1<Math.max(o,0===l?Buffer$1.from("\r\n",n).length:l,a?(null===r?0:r.length)+s.length:0,a?s.length+l:0)},parse:function(e,t,i,n){const{bom:r,comment_no_infix:s,encoding:a,from_line:o,ltrim:l,max_record_size:c,raw:h,relax_quotes:u,rtrim:d,skip_empty_lines:p,to:m,to_line:f}=this.options;let{comment:g,escape:_,quote:A,record_delimiter:v}=this.options;const{bomSkipped:y,previousBuf:x,rawBuffer:b,escapeIsQuote:S}=this.state;let C;if(void 0===x){if(void 0===e)return void n();C=e}else C=void 0!==x&&void 0===e?x:Buffer$1.concat([x,e]);if(!1===y)if(!1===r)this.state.bomSkipped=!0;else if(C.length<3){if(!1===t)return void(this.state.previousBuf=C)}else{for(const e in boms)if(0===boms[e].compare(C,0,boms[e].length)){const t=boms[e].length;this.state.bufBytesStart+=t,C=C.slice(t),this.options=normalize_options({...this.original_options,encoding:e}),({comment:g,escape:_,quote:A}=this.options);break}this.state.bomSkipped=!0}const T=C.length;let E;for(E=0;E<T&&!this.__needMoreData(E,T,t);E++){if(!0===this.state.wasRowDelimiter&&(this.info.lines++,this.state.wasRowDelimiter=!1),-1!==f&&this.info.lines>f)return this.state.stop=!0,void n();if(!1===this.state.quoting&&0===v.length){this.__autoDiscoverRecordDelimiter(C,E)&&(v=this.options.record_delimiter)}const e=C[E];if(!0===h&&b.append(e),e!==cr&&e!==nl||!1!==this.state.wasRowDelimiter||(this.state.wasRowDelimiter=!0),!0===this.state.escaping)this.state.escaping=!1;else{if(null!==_&&!0===this.state.quoting&&this.__isEscape(C,E,e)&&E+_.length<T){if(!S){this.state.escaping=!0,E+=_.length-1;continue}if(this.__isQuote(C,E+_.length)){this.state.escaping=!0,E+=_.length-1;continue}}if(!1===this.state.commenting&&this.__isQuote(C,E))if(!0===this.state.quoting){const t=C[E+A.length],i=d&&this.__isCharTrimable(C,E+A.length),n=null!==g&&this.__compareBytes(g,C,E+A.length,t),r=this.__isDelimiter(C,E+A.length,t),s=0===v.length?this.__autoDiscoverRecordDelimiter(C,E+A.length):this.__isRecordDelimiter(t,C,E+A.length);if(null!==_&&this.__isEscape(C,E,e)&&this.__isQuote(C,E+_.length))E+=_.length-1;else{if(!t||r||s||n||i){this.state.quoting=!1,this.state.wasQuoting=!0,E+=A.length-1;continue}if(!1===u){const e=this.__error(new CsvError("CSV_INVALID_CLOSING_QUOTE",["Invalid Closing Quote:",`got "${String.fromCharCode(t)}"`,`at line ${this.info.lines}`,"instead of delimiter, record delimiter, trimable character","(if activated) or comment"],this.options,this.__infoField()));if(void 0!==e)return e}else this.state.quoting=!1,this.state.wasQuoting=!0,this.state.field.prepend(A),E+=A.length-1}}else{if(0===this.state.field.length){this.state.quoting=!0,E+=A.length-1;continue}if(!1===u){const e=this.__infoField(),t=Object.keys(boms).map((e=>!!boms[e].equals(this.state.field.toString())&&e)).filter(Boolean)[0],i=this.__error(new CsvError("INVALID_OPENING_QUOTE",["Invalid Opening Quote:",`a quote is found on field ${JSON.stringify(e.column)} at line ${e.lines}, value is ${JSON.stringify(this.state.field.toString(a))}`,t?`(${t} bom)`:void 0],this.options,e,{field:this.state.field}));if(void 0!==i)return i}}if(!1===this.state.quoting){const t=this.__isRecordDelimiter(e,C,E);if(0!==t){if(this.state.commenting&&!1===this.state.wasQuoting&&0===this.state.record.length&&0===this.state.field.length)this.info.comment_lines++;else{if(!1===this.state.enabled&&this.info.lines+(!0===this.state.wasRowDelimiter?1:0)>=o){this.state.enabled=!0,this.__resetField(),this.__resetRecord(),E+=t-1;continue}if(!0===p&&!1===this.state.wasQuoting&&0===this.state.record.length&&0===this.state.field.length){this.info.empty_lines++,E+=t-1;continue}this.info.bytes=this.state.bufBytesStart+E;const e=this.__onField();if(void 0!==e)return e;this.info.bytes=this.state.bufBytesStart+E+t;const r=this.__onRecord(i);if(void 0!==r)return r;if(-1!==m&&this.info.records>=m)return this.state.stop=!0,void n()}this.state.commenting=!1,E+=t-1;continue}if(this.state.commenting)continue;if(null!==g&&(!1===s||0===this.state.record.length&&0===this.state.field.length)){if(0!==this.__compareBytes(g,C,E,e)){this.state.commenting=!0;continue}}const r=this.__isDelimiter(C,E,e);if(0!==r){this.info.bytes=this.state.bufBytesStart+E;const e=this.__onField();if(void 0!==e)return e;E+=r-1;continue}}}if(!1===this.state.commenting&&0!==c&&this.state.record_length+this.state.field.length>c)return this.__error(new CsvError("CSV_MAX_RECORD_SIZE",["Max Record Size:","record exceed the maximum number of tolerated bytes",`of ${c}`,`at line ${this.info.lines}`],this.options,this.__infoField()));const t=!1===l||!0===this.state.quoting||0!==this.state.field.length||!this.__isCharTrimable(C,E),r=!1===d||!1===this.state.wasQuoting;if(!0!==t||!0!==r){if(!0!==d||this.__isCharTrimable(C,E)){!1===t&&(E+=this.__isCharTrimable(C,E)-1);continue}return this.__error(new CsvError("CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE",["Invalid Closing Quote:","found non trimable byte after quote",`at line ${this.info.lines}`],this.options,this.__infoField()))}this.state.field.append(e)}if(!0===t)if(!0===this.state.quoting){const e=this.__error(new CsvError("CSV_QUOTE_NOT_CLOSED",["Quote Not Closed:",`the parsing is finished with an opening quote at line ${this.info.lines}`],this.options,this.__infoField()));if(void 0!==e)return e}else if(!0===this.state.wasQuoting||0!==this.state.record.length||0!==this.state.field.length){this.info.bytes=this.state.bufBytesStart+E;const e=this.__onField();if(void 0!==e)return e;const t=this.__onRecord(i);if(void 0!==t)return t}else!0===this.state.wasRowDelimiter?this.info.empty_lines++:!0===this.state.commenting&&this.info.comment_lines++;else this.state.bufBytesStart+=E,this.state.previousBuf=C.slice(E);!0===this.state.wasRowDelimiter&&(this.info.lines++,this.state.wasRowDelimiter=!1)},__onRecord:function(e){const{columns:t,group_columns_by_name:i,encoding:n,info:r,from:s,relax_column_count:a,relax_column_count_less:o,relax_column_count_more:l,raw:c,skip_records_with_empty_values:h}=this.options,{enabled:u,record:d}=this.state;if(!1===u)return this.__resetRecord();const p=d.length;if(!0===t)return!0===h&&isRecordEmpty(d)?void this.__resetRecord():this.__firstLineToColumns(d);if(!1===t&&0===this.info.records&&(this.state.expectedRecordLength=p),p!==this.state.expectedRecordLength){const e=!1===t?new CsvError("CSV_RECORD_INCONSISTENT_FIELDS_LENGTH",["Invalid Record Length:",`expect ${this.state.expectedRecordLength},`,`got ${p} on line ${this.info.lines}`],this.options,this.__infoField(),{record:d}):new CsvError("CSV_RECORD_INCONSISTENT_COLUMNS",["Invalid Record Length:",`columns length is ${t.length},`,`got ${p} on line ${this.info.lines}`],this.options,this.__infoField(),{record:d});if(!0===a||!0===o&&p<this.state.expectedRecordLength||!0===l&&p>this.state.expectedRecordLength)this.info.invalid_field_length++,this.state.error=e;else{const t=this.__error(e);if(t)return t}}if(!0===h&&isRecordEmpty(d))this.__resetRecord();else{if(!0===this.state.recordHasError)return this.__resetRecord(),void(this.state.recordHasError=!1);if(this.info.records++,1===s||this.info.records>=s){const{objname:s}=this.options;if(!1!==t){const a={};for(let e=0,n=d.length;e<n;e++)void 0===t[e]||t[e].disabled||(!0===i&&void 0!==a[t[e].name]?Array.isArray(a[t[e].name])?a[t[e].name]=a[t[e].name].concat(d[e]):a[t[e].name]=[a[t[e].name],d[e]]:a[t[e].name]=d[e]);if(!0===c||!0===r){const t=Object.assign({record:a},!0===c?{raw:this.state.rawBuffer.toString(n)}:{},!0===r?{info:this.__infoRecord()}:{}),i=this.__push(void 0===s?t:[a[s],t],e);if(i)return i}else{const t=this.__push(void 0===s?a:[a[s],a],e);if(t)return t}}else if(!0===c||!0===r){const t=Object.assign({record:d},!0===c?{raw:this.state.rawBuffer.toString(n)}:{},!0===r?{info:this.__infoRecord()}:{}),i=this.__push(void 0===s?t:[d[s],t],e);if(i)return i}else{const t=this.__push(void 0===s?d:[d[s],d],e);if(t)return t}}this.__resetRecord()}},__firstLineToColumns:function(e){const{firstLineToHeaders:t}=this.state;try{const i=void 0===t?e:t.call(null,e);if(!Array.isArray(i))return this.__error(new CsvError("CSV_INVALID_COLUMN_MAPPING",["Invalid Column Mapping:","expect an array from column function,",`got ${JSON.stringify(i)}`],this.options,this.__infoField(),{headers:i}));const n=normalize_columns_array(i);return this.state.expectedRecordLength=n.length,this.options.columns=n,void this.__resetRecord()}catch(i){return i}},__resetRecord:function(){!0===this.options.raw&&this.state.rawBuffer.reset(),this.state.error=void 0,this.state.record=[],this.state.record_length=0},__onField:function(){const{cast:e,encoding:t,rtrim:i,max_record_size:n}=this.options,{enabled:r,wasQuoting:s}=this.state;if(!1===r)return this.__resetField();let a=this.state.field.toString(t);if(!0===i&&!1===s&&(a=a.trimRight()),!0===e){const[e,t]=this.__cast(a);if(void 0!==e)return e;a=t}this.state.record.push(a),0!==n&&"string"==typeof a&&(this.state.record_length+=a.length),this.__resetField()},__resetField:function(){this.state.field.reset(),this.state.wasQuoting=!1},__push:function(e,t){const{on_record:i}=this.options;if(void 0!==i){const t=this.__infoRecord();try{e=i.call(null,e,t)}catch(n){return n}if(null==e)return}t(e)},__cast:function(e){const{columns:t,relax_column_count:i}=this.options;if(!0===Array.isArray(t)&&i&&this.options.columns.length<=this.state.record.length)return[void 0,void 0];if(null!==this.state.castField)try{const t=this.__infoField();return[void 0,this.state.castField.call(null,e,t)]}catch(n){return[n]}if(this.__isFloat(e))return[void 0,parseFloat(e)];if(!1!==this.options.cast_date){const t=this.__infoField();return[void 0,this.options.cast_date.call(null,e,t)]}return[void 0,e]},__isCharTrimable:function(e,t){return((e,t)=>{const{timchars:i}=this.state;e:for(let n=0;n<i.length;n++){const r=i[n];for(let i=0;i<r.length;i++)if(r[i]!==e[t+i])continue e;return r.length}return 0})(e,t)},__isFloat:function(e){return e-parseFloat(e)+1>=0},__compareBytes:function(e,t,i,n){if(e[0]!==n)return 0;const r=e.length;for(let s=1;s<r;s++)if(e[s]!==t[i+s])return 0;return r},__isDelimiter:function(e,t,i){const{delimiter:n,ignore_last_delimiters:r}=this.options;if(!0===r&&this.state.record.length===this.options.columns.length-1)return 0;if(!1!==r&&"number"==typeof r&&this.state.record.length===r-1)return 0;e:for(let s=0;s<n.length;s++){const r=n[s];if(r[0]===i){for(let i=1;i<r.length;i++)if(r[i]!==e[t+i])continue e;return r.length}}return 0},__isRecordDelimiter:function(e,t,i){const{record_delimiter:n}=this.options,r=n.length;e:for(let s=0;s<r;s++){const r=n[s],a=r.length;if(r[0]===e){for(let e=1;e<a;e++)if(r[e]!==t[i+e])continue e;return r.length}}return 0},__isEscape:function(e,t,i){const{escape:n}=this.options;if(null===n)return!1;const r=n.length;if(n[0]===i){for(let i=0;i<r;i++)if(n[i]!==e[t+i])return!1;return!0}return!1},__isQuote:function(e,t){const{quote:i}=this.options;if(null===i)return!1;const n=i.length;for(let r=0;r<n;r++)if(i[r]!==e[t+r])return!1;return!0},__autoDiscoverRecordDelimiter:function(e,t){const{encoding:i}=this.options,n=[Buffer$1.from("\r\n",i),Buffer$1.from("\n",i),Buffer$1.from("\r",i)];e:for(let r=0;r<n.length;r++){const i=n[r].length;for(let s=0;s<i;s++)if(n[r][s]!==e[t+s])continue e;return this.options.record_delimiter.push(n[r]),this.state.recordDelimiterMaxLength=n[r].length,n[r].length}return 0},__error:function(e){const{encoding:t,raw:i,skip_records_with_error:n}=this.options,r="string"==typeof e?new Error(e):e;return n?(this.state.recordHasError=!0,void(void 0!==this.options.on_skip&&this.options.on_skip(r,i?this.state.rawBuffer.toString(t):void 0))):r},__infoDataSet:function(){return{...this.info,columns:this.options.columns}},__infoRecord:function(){const{columns:e,raw:t,encoding:i}=this.options;return{...this.__infoDataSet(),error:this.state.error,header:!0===e,index:this.state.record.length,raw:t?this.state.rawBuffer.toString(i):void 0}},__infoField:function(){const{columns:e}=this.options,t=Array.isArray(e);return{...this.__infoRecord(),column:!0===t?e.length>this.state.record.length?e[this.state.record.length].name:null:this.state.record.length,quoting:this.state.wasQuoting}}}},parse=function(e,t={}){"string"==typeof e&&(e=Buffer$1.from(e));const i=t&&t.objname?{}:[],n=transform(t),r=e=>{void 0===n.options.objname?i.push(e):i[e[0]]=e[1]},s=()=>{},a=n.parse(e,!1,r,s);if(void 0!==a)throw a;const o=n.parse(void 0,!0,r,s);if(void 0!==o)throw o;return i},_CSVDataSource=class extends JSONDataSource{constructor(e){super(e),this.type="CSVDataSource"}async _convertStreamingDataToObjectData(e){return await e.text()}_convertObjectDataToJSONData(e){return parse(e,{columns:!0,skip_empty_lines:!0})}};let CSVDataSource=_CSVDataSource;__publicField(CSVDataSource,"fromURL",(async function(e,t){let i=new _CSVDataSource(t);return await i.load(e),i})),__publicField(CSVDataSource,"fromUrl",(async function(e,t){return console.warn("CSVDataSource.fromUrl is deprecated, please use CSVDataSource.fromURL instead."),await this.fromURL(e,t)})),__publicField(CSVDataSource,"fromCSVString",(function(e,t){let i=new _CSVDataSource(t);return i.setData(e),i})),new three.Euler(0,0,0,"ZXY"),new three.Vector3;const _changeEvent={type:"change"},_lockEvent={type:"lock"},_unlockEvent={type:"unlock"};class PointerLockControls extends three.EventDispatcher{constructor(e,t){super(),void 0===t&&(console.warn('THREE.PointerLockControls: The second parameter "domElement" is now mandatory.'),t=document.body),this.domElement=t,this.camera=e,this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1;const i=this;function n(e){!1!==i.isLocked&&(i.controller&&i.controller.handleMouseMove(i.camera,e),i.dispatchEvent(_changeEvent))}function r(){i.domElement.ownerDocument.pointerLockElement===i.domElement?(i.dispatchEvent(_lockEvent),i.isLocked=!0):(i.dispatchEvent(_unlockEvent),i.isLocked=!1)}function s(){console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}this.connect=function(){i.domElement.ownerDocument.addEventListener("mousemove",n),i.domElement.ownerDocument.addEventListener("pointerlockchange",r),i.domElement.ownerDocument.addEventListener("pointerlockerror",s)},this.disconnect=function(){i.domElement.ownerDocument.removeEventListener("mousemove",n),i.domElement.ownerDocument.removeEventListener("pointerlockchange",r),i.domElement.ownerDocument.removeEventListener("pointerlockerror",s)},this.dispose=function(){this.disconnect()},this.getObject=function(){return e},this.getDirection=function(){const t=new three.Vector3(0,0,-1);return function(i){return i.copy(t).applyQuaternion(e.quaternion)}}(),this.moveForward=function(e){this.controller&&this.controller.moveForward(this.camera,e)},this.moveRight=function(e){this.controller&&this.controller.moveRight(this.camera,e)},this.moveUp=function(e){this.controller&&this.controller.moveUp(this.camera,e)},this.lock=function(){this.domElement.requestPointerLock()},this.unlock=function(){i.domElement.ownerDocument.exitPointerLock()},this.connect()}}class Scene3DController{constructor(e,t=1){this.ellipsoidCamera=e,this.pointerSpeed=t}handleMouseMove(e,t){const i=t.movementX||t.mozMovementX||t.webkitMovementX||0,n=t.movementY||t.mozMovementY||t.webkitMovementY||0,r=.002*this.pointerSpeed;i>0&&this.ellipsoidCamera.lookRight(i*r),i<0&&this.ellipsoidCamera.lookLeft(-i*r),n>0&&this.ellipsoidCamera.lookDown(n*r),n<0&&this.ellipsoidCamera.lookUp(-n*r)}moveForward(e,t){this.ellipsoidCamera.moveForward(t)}moveRight(e,t){this.ellipsoidCamera.moveRight(t)}moveUp(e,t){this.ellipsoidCamera.moveUp(t)}}const _euler=new three.Euler(0,0,0,"ZXY"),_vector=new three.Vector3,_PI_2=Math.PI/2;class ColumbusController{constructor(e=1){this.pointerSpeed=e,this.minPolarAngle=0,this.maxPolarAngle=Math.PI}handleMouseMove(e,t){const i=t.movementX||t.mozMovementX||t.webkitMovementX||0,n=t.movementY||t.mozMovementY||t.webkitMovementY||0,r=.002*this.pointerSpeed;_euler.setFromQuaternion(e.quaternion),_euler.z-=i*r,_euler.x-=n*r,_euler.x=Math.max(_PI_2-this.maxPolarAngle,Math.min(_PI_2-this.minPolarAngle,_euler.x)),e.quaternion.setFromEuler(_euler)}moveForward(e,t){_vector.setFromMatrixColumn(e.matrix,0),_vector.crossVectors(e.up,_vector),e.position.addScaledVector(_vector,t)}moveRight(e,t){_vector.setFromMatrixColumn(e.matrix,0),e.position.addScaledVector(_vector,t)}moveUp(e,t){e.position.z+=t}}class PointerLockControl extends PointerLockControls{constructor(e){super(e.camera,e.map.container),__publicField(this,"_enableKeyboardEvent",!1),__publicField(this,"_moveForward",!1),__publicField(this,"_moveBackward",!1),__publicField(this,"_moveLeft",!1),__publicField(this,"_moveRight",!1),__publicField(this,"_moveTop",!1),__publicField(this,"_moveBottom",!1),__publicField(this,"_prevTime"),__publicField(this,"_velocity",new three.Vector3),__publicField(this,"_direction",new three.Vector3),__publicField(this,"handleKeyDownEvent",(e=>{switch(e.keyCode){case 87:this._moveForward=!0;break;case 83:this._moveBackward=!0;break;case 65:this._moveLeft=!0;break;case 68:this._moveRight=!0;break;case 81:this._moveTop=!0;break;case 69:this._moveBottom=!0;break;case 76:!this.isLocked&&this.lock()}})),__publicField(this,"animationMove",(()=>{if(!this._enableKeyboardEvent)return;const e=performance.now();requestAnimationFrame(this.animationMove);const t=(e-this._prevTime)/1e3;this._velocity.x-=10*this._velocity.x*t,this._velocity.z-=10*this._velocity.z*t,this._velocity.y-=10*this._velocity.y*t,this._direction.z=Number(this._moveForward)-Number(this._moveBackward),this._direction.x=Number(this._moveRight)-Number(this._moveLeft),this._direction.y=Number(this._moveTop)-Number(this._moveBottom),this._direction.normalize(),(this._moveForward||this._moveBackward)&&(this._velocity.z-=this._direction.z*this.forwardStepSize*t),(this._moveLeft||this._moveRight)&&(this._velocity.x-=this._direction.x*this.rightStepSize*t),(this._moveTop||this._moveBottom)&&(this._velocity.y-=this._direction.y*this.topStepSize*t),this.moveRight(-this._velocity.x),this.moveForward(-this._velocity.z),this.moveUp(-this._velocity.y),this._prevTime=e})),__publicField(this,"handleKeyUpEvent",(e=>{switch(e.keyCode){case 87:this._moveForward=!1;break;case 83:this._moveBackward=!1;break;case 65:this._moveLeft=!1;break;case 68:this._moveRight=!1;break;case 81:this._moveTop=!1;break;case 69:this._moveBottom=!1}})),this._engine=e,this.isGlobe=e.map.isGlobe,this._engine.camera.up.set(0,0,1),this.stepSize=10,this.controller=this.createController(),this.addEventListener("change",(t=>{e.requestRender()}))}createController(){if(this.isGlobe){const e=this._engine.map.map._ellipsoidCamera;return new Scene3DController(e)}return new ColumbusController}dispose(){super.dispose(),this.enableKeyboardEvent=!1}get forwardStepSize(){return this._forwardStepSize}set forwardStepSize(e){this._forwardStepSize=e}get rightStepSize(){return this._rightStepSize}set rightStepSize(e){this._rightStepSize=e}get topStepSize(){return this._topStepSize}set topStepSize(e){this._topStepSize=e}set stepSize(e){this.forwardStepSize=e,this.rightStepSize=e,this.topStepSize=e}set enableKeyboardEvent(e){e!==this._enableKeyboardEvent&&(this._enableKeyboardEvent=e,e?(this._prevTime=performance.now(),requestAnimationFrame(this.animationMove),window.addEventListener("keydown",this.handleKeyDownEvent),window.addEventListener("keyup",this.handleKeyUpEvent)):(window.removeEventListener("keydown",this.handleKeyDownEvent),window.removeEventListener("keyup",this.handleKeyUpEvent)))}}const VIEW_MODEL_MAP={FOLLOW:"follow",LOCK:"lock",UNLOCK:"unlock",KEYFRAME:"keyFrame",ACTIVEFRAME:"activeFrame"},Easing={linear:e=>e,"ease-in":e=>e*e,"ease-out":e=>e*(2-e),"ease-in-out":e=>e<.5?2*e*e:(4-2*e)*e-1},positionScratch$2=new three.Vector3,directionScratch=new three.Vector3,upScratch=new three.Vector3,rightScratch=new three.Vector3,scaledPositionScratch=new three.Vector3,objectEuler=new three.Euler;class TrackerAbstract extends three.Object3D{constructor(e={}){super(),__publicField(this,"_isRunning",!1),__publicField(this,"_isPause",!1),__publicField(this,"_pauseTime",0),__publicField(this,"_pauseTimestamp",0),__publicField(this,"_animationStartTime",0),__publicField(this,"_animationDuration",0),__publicField(this,"_animationTransform",{}),__publicField(this,"_animationCurrenState",null),__publicField(this,"_track",null),__publicField(this,"_frameInfo",null),__publicField(this,"onStart",null),__publicField(this,"onFinish",null),__publicField(this,"onUpdate",null),__publicField(this,"_runtime",{}),__publicField(this,"_withoutTrack",!1),__publicField(this,"_repeatCount",1),__publicField(this,"_completedCount",0),__publicField(this,"_debug",!1),__publicField(this,"_trackPoint",null),__publicField(this,"_trackLists",[]),__publicField(this,"_startPoint",null),__publicField(this,"_startLists",[]),__publicField(this,"_stratIndex",-1),__publicField(this,"_lockView",!1),__publicField(this,"_viewFollow",!0),__publicField(this,"_keepRunning",!1),__publicField(this,"_easingFn",Easing.linear),__publicField(this,"_currentEasingFn",Easing.linear),__publicField(this,"update",(()=>{if(!this._isRunning||this._isPause)return;const e=this._engine.rendering.renderState.time-this._pauseTime-this._animationStartTime;if(e<this._delay)return;const t=e-this._delay;let i=1;if(this._animationDuration>0){const e=t/this._animationDuration;if(this._repeatCount===1/0)i=e%1;else{if(t>=this._animationDuration*this._repeatCount)i=1;else{const e=Math.floor(t/this._animationDuration);this._completedCount=e,i=t%this._animationDuration/this._animationDuration}}}let n=i;if("reverse"===this._direction)n=1-i;else if("alternate"===this._direction){Math.floor(t/this._animationDuration)%2==1&&(n=1-i)}else if("alternate-reverse"===this._direction){Math.floor(t/this._animationDuration)%2==0&&(n=1-i)}const r=this._currentEasingFn(n),s=this.updatePositionByPercentage(r);if(this._animationCurrenState=s,this.updateObject(s),this._updateDebug(s.point),this.viewFollow&&this.updateCamera(s),this.onUpdate&&s&&this.onUpdate(s),this._repeatCount!==1/0){t>=this._animationDuration*this._repeatCount&&this.stop()}})),e.easing&&(this._easingFn=this._resolveEasing(e.easing),this._currentEasingFn=this._easingFn)}_resolveEasing(e){return"string"==typeof e&&e in Easing?Easing[e]:"function"==typeof e?e:(console.warn(`Unknown easing "${e}", fallback to linear`),Easing.linear)}onBeforeScenePrepareRender(e,t,i,n){this.update()}afterAddToEngine(e){if(this._engine=e,this._debug){this._trackPoint=e.add(new SimplePoint({color:"green",size:8}));const t=GeoJSONDataSource.fromGeoJSON([]);this._trackPoint.dataSource=t,this._startPoint=e.add(new SimplePoint({color:"red",size:20}));const i=GeoJSONDataSource.fromGeoJSON([]);this._startPoint.dataSource=i}}updatePositionByPercentage(e){throw new Error("updatePositionByPercentage method must be implemented by subclass")}start(e={}){const{duration:t=1e3,heading:i=0,pitch:n=60,range:r=100,easing:s,repeatCount:a,delay:o=0,direction:l="normal"}=e;if(!this._withoutTrack&&!this.track)return;if(this._isPause)return this._pauseTime+=(new Date).valueOf()-this._pauseTimestamp,void(this._isPause=!1);if(this._isRunning)return;if(this._debug&&(this._stratIndex+=1),this._isRunning=!0,this._animationDuration=t,this._animationTransform={heading:i,pitch:n,range:r},this._currentEasingFn=s?this._resolveEasing(s):this._easingFn,this._frameInfo&&this._frameInfo.length&&this._frameInfo.every((e=>e.time||0===e.time))){this._animationTransform={heading:0,pitch:0,range:r};let e=0;this._frameInfo.forEach((t=>{const{time:i}=t;e+=i})),this._animationDuration=e}const c=e.keepRunning?e.keepRunning:this._keepRunning;defined$2(a)?this._repeatCount=a===1/0?1/0:Math.max(1,a):this._repeatCount=c?1/0:1,this._completedCount=0,this._delay=Math.max(0,o),this._direction=l,this._animationStartTime=(new Date).getTime(),this.onStart&&this.onStart()}pause(){return this._isPause=!0,this._pauseTimestamp=(new Date).valueOf(),this._animationCurrenState}stop(){this._isRunning&&(this._isRunning=!1,this._isPause=!1,this._pauseTimestamp=0,this._pauseTime=0,this._animationCurrenState=null,this._arcInfo={},this.onFinish&&this.onFinish())}dirUpToHPR(e,t,i){i||(i=new three.Vector3(0,0,1));const n=this._engine,r=n.map;if(r.isGlobe){const i=r.map;positionScratch$2.fromArray(r.projectArrayCoordinate(t)),i._ellipsoid.scaleToGeodeticSurface(positionScratch$2,scaledPositionScratch),i._ellipsoid.geodeticSurfaceNormal(scaledPositionScratch,upScratch);const s={direction:e,up:upScratch},a={};directionUpToHeadingPitchRoll(n.map.map._ellipsoidCamera,positionScratch$2,s,a);let o=-(a.heading-2*Math.PI);return a.heading=three.MathUtils.radToDeg(o),a.pitch=three.MathUtils.radToDeg(a.pitch),a.roll=three.MathUtils.radToDeg(a.roll),a}directionScratch.copy(e),upScratch.copy(i),rightScratch.crossVectors(directionScratch,upScratch);const s=getHeading(directionScratch,upScratch),a=getPitch(directionScratch),o=getRoll(directionScratch,upScratch,rightScratch);let l=-(s-2*Math.PI);return{heading:three.MathUtils.radToDeg(l),pitch:three.MathUtils.radToDeg(a),roll:three.MathUtils.radToDeg(o)}}updateObject(e){if(!this.object)return;const t=this._engine.map,{point:i,hpr:n}=e,r=t.projectArrayCoordinate(i);this.object.position.fromArray(r);const s=t.isGlobe,{heading:a,pitch:o,roll:l}=n;if(s){const e={heading:2*Math.PI-three.MathUtils.degToRad(a)-Math.PI/2,pitch:three.MathUtils.degToRad(o),roll:three.MathUtils.degToRad(l)};positionScratch$2.fromArray(r);const t=Transforms.headingPitchRollToFixedFrame(positionScratch$2,e),i=objectEuler.setFromRotationMatrix(t);this.object.rotation.x=i.x,this.object.rotation.y=i.y,this.object.rotation.z=i.z}else{const e=three.MathUtils.degToRad(a)+Math.PI/2,t=three.MathUtils.degToRad(-o),i=three.MathUtils.degToRad(l),n=new three.Euler(i,t,e,"ZXY"),r=(new three.Quaternion).setFromEuler(n);this.object.quaternion.copy(r)}}updateCamera(e){var t,i;const n=this._engine.map,{point:r,hpr:s}=e,a=this._lockView&&null!=(t=null==s?void 0:s.heading)?t:n.getHeading(),o=this._lockView&&null!=(i=null==s?void 0:s.pitch)?i:n.getPitch();s.heading=a,s.pitch=o,"blank"===n.mapType?this._computeCameraMatrixBlank(r,s):this._computeCameraMatrix(r,s)}_updateDebug(e){if(this._debug){this._trackLists.push(e);const t=this._trackLists.map((e=>({type:"Feature",geometry:{type:"Point",coordinates:e}})));this._trackPoint.dataSource.setData(t);this._startLists[this._stratIndex]||this._startLists.push(e);const i=this._startLists.map((e=>({type:"Feature",geometry:{type:"Point",coordinates:e}})));this._startPoint.dataSource.setData(i)}}distanceToZoom(e){const t=this._engine.map,i=e/(this._engine._container.clientHeight/2)*Math.tan(t.fov/2*Math.PI/180);return t.getZoomByZoomUnits(i)}_computeCameraMatrixBlank(e,t){const i=this._animationTransform.range,n=this.distanceToZoom(i);let r=t.heading,s=t.pitch;if(this.lockView){const{heading:e,pitch:i}=this._animationTransform;r=t.heading+e,s=t.pitch+i}this._engine.map.lookAt(e,{heading:r,pitch:s,zoom:n})}_computeCameraMatrix(e,t){const i=this._engine,n=this._animationTransform;let r=t.heading,s=t.pitch;if(this.lockView){const{heading:e,pitch:i}=this._animationTransform;r=t.heading+e,s=t.pitch+i}const a=n.range;i.map.lookAt(e,{heading:r,pitch:s,range:a})}set viewMode(e){switch(this._viewMode=e,e){case VIEW_MODEL_MAP.FOLLOW:this.lockView=!1,this.viewFollow=!0;break;case VIEW_MODEL_MAP.LOCK:this.lockView=!0,this.viewFollow=!0;break;case VIEW_MODEL_MAP.UNLOCK:this.lockView=!1,this.viewFollow=!1;break;default:this.lockView=!0,this.viewFollow=!0}}get viewMode(){return this._viewMode}get currentState(){return this._animationCurrenState}get isRunning(){return this._isRunning}get isPaused(){return this._isPause}set lockView(e){this._lockView=e}get lockView(){return this._lockView}set viewFollow(e){this._viewFollow=e}get viewFollow(){return this._viewFollow}set object(e){this._object=e}get object(){return this._object}}class PathTracker extends TrackerAbstract{constructor(){super(...arguments),__publicField(this,"_sampledPath",[]),__publicField(this,"_arcInfo",{}),__publicField(this,"_interpolateDirectThreshold",10),__publicField(this,"_interpolateDirectThresholdPercent",.4)}updatePositionByPercentage(e){if(!this._sampledPath||0===this._sampledPath.length)return;return this._interpolatePath(e)}_interpolatePath(e){const t=this._sampledPath.length,{last:i,current:n,next:r,lastFrame:s,currentFrame:a,segmentPercent:o,isStart:l,isEnd:c}=this._getSegment(e,t),{isTransition:h,transPercent:u}=this._computeTransition(o,i,n,r,l,c),d=this._updatePositionAndDirection(i,n,o,h,u);if(this._viewMode===VIEW_MODEL_MAP.KEYFRAME||this._viewMode===VIEW_MODEL_MAP.ACTIVEFRAME){return this._handleFrame(s,a,i,n,r,d.point,u,o,e)}return d}_handleFrame(e,t,i,n,r,s,a,o,l){const c=this._engine.map;let h=c.projectArrayCoordinate(s);const u=a/2;let d,p,m,f={heading:0,pitch:0,roll:0};switch(this._viewMode){case VIEW_MODEL_MAP.KEYFRAME:if(!e||!t)break;if(e.aim){const{aim:t}=e,i=c.projectArrayCoordinate(t),[n,r,a]=i;d=new three.Vector3(n-h[0],r-h[1],a-h[2]).normalize(),f=this.dirUpToHPR(d,s)}else m=e.yaw+(t.yaw-e.yaw)*u,m=CesiumMath.zeroToTwoPi(m-Math.PI/2),p=e.pitch+(t.pitch-e.pitch)*u,f.heading=three.MathUtils.radToDeg(m),f.pitch=three.MathUtils.radToDeg(p);break;case VIEW_MODEL_MAP.ACTIVEFRAME:if("curve"===this._pointHandle){let e;e=this._frameInfo&&this._frameInfo.length&&this._frameInfo.every((e=>e.speed))?this.curvePath.getPointAt(l):this.curvePath.getPoint(l),s=this._engine.map.unprojectArrayCoordinate([e.x,e.y,e.z]),h=[e.x,e.y,e.z]}if(e&&t&&defined$2(e.yaw)&&defined$2(t.yaw))m=e.yaw+(t.yaw-e.yaw)*o,m=CesiumMath.zeroToTwoPi(m-Math.PI/2),p=e.pitch+(t.pitch-e.pitch)*o,f.heading=three.MathUtils.radToDeg(m),f.pitch=three.MathUtils.radToDeg(p);else{if(r){d=slerpVectors(new three.Vector3(...n.direction).normalize(),new three.Vector3(...r.direction).normalize(),o).normalize()}else d=new three.Vector3(...n.direction).normalize();f=this.dirUpToHPR(d,s)}}return{point:s,hpr:f,direction:d}}_getSegment(e,t){const i=this._sampledPath.findIndex((t=>t.percent>=e)),n=0===i,r=i===t-1;let s=this._sampledPath[i],a=this._sampledPath[i-1],o=this._sampledPath[i+1];n&&(a=s,s=o);return{last:a,current:s,next:o,isStart:n,isEnd:r,segmentPercent:(e-a.percent)/(s.percent-a.percent),lastFrame:this._frameInfo[i-1],currentFrame:this._frameInfo[i]}}_computeTransition(e,t,i,n,r,s){let a=0,o=!1,l=this._arcInfo.endRatio&&e<this._arcInfo.endRatio;if(n){const c=i.distance-t.distance,h=n.distance-i.distance,u=Math.min(c,h),d=this.interpolateDirectThreshold/u,p=d<.5?d:this._interpolateDirectThresholdPercent,m=p*u/c,f=p*u/h;if(r||(o=e<m),s||(o=e>1-m),o||l){o&&(this._arcInfo.line1=[t.position,i.position,m],this._arcInfo.line2=[i.position,n.position,f],this._arcInfo.endRatio=f);const r=(e-(1-m))/m,s=e/this._arcInfo.endRatio,l=o?r:s;a=o?l:1+l}}else if(l){a=1+e/this._arcInfo.endRatio}return{isTransition:o||l,transPercent:a}}_updatePositionAndDirection(e,t,i,n,r){const s=this._engine.map,a=intepolateArray3(e.position,t.position,i),o=s.unprojectArrayCoordinate(a),[l,c,h]=t.position,[u,d,p]=e.position;let m=new three.Vector3(l-u,c-d,h-p).normalize();if(n){const{line1:e,line2:t}=this._arcInfo,i=getRadiusCenter3D(e,t,r),n=i.point,a=i.direction,l=s.unprojectArrayCoordinate(n);n&&(o[0]=l[0],o[1]=l[1],s.isGlobe&&(o[2]=l[2])),m.fromArray(a)}return{point:o,hpr:this.dirUpToHPR(m,o)}}_findCurrentSegment(e){const t=this._sampledPath.findIndex((t=>t.percent>=e));if(-1===t)return null;const i=this._frameInfo?this._frameInfo[t-1]:null,n=this._frameInfo?this._frameInfo[t]:null;let r=this._sampledPath[t],s=this._sampledPath[t-1],a=this._sampledPath[t+1],o=0;return 0===t&&(s=r,r=a),o=(e-s.percent)/(r.percent-s.percent),{last:s,current:r,next:a,percent:o,lastFrame:i,currentFrame:n,index:t}}_calculateLocation(e,t,i){return{point:intepolateArray3(e.point,t.point,i),direction:new three.Vector3(t.position[0]-e.position[0],t.position[1]-e.position[1],t.position[2]-e.position[2]).normalize()}}_createSampledPath(e){const t=this._engine.map;if(!e)return;let i=0,n=[0],r=[],s=[],a=0,o=[0],l=new three.Vector3;for(let h=1;h<e.length;h++){const t=e[h],c=e[h-1],u=e[h+1],d=this._engine.map.projectArrayCoordinate(t),p=this._engine.map.projectArrayCoordinate(c),m=getDistance(p,d);if(n[h]=m+i,i+=m,this._frameInfo&&this._frameInfo.length&&this._frameInfo.every((e=>e.speed))){const e=m/this._frameInfo[h-1].speed*1e3;this._frameInfo[h-1].time=e,!u&&(this._frameInfo[h].time=0),o[h]=e+a,a+=e}else if(this._frameInfo&&this._frameInfo.length&&this._frameInfo.every((e=>e.time))){const e=this._frameInfo[h-1];o[h]=e.time+a,a+=e.time}if(1===h&&(r[0]=getDirection3(p,d,l).toArray(),s[0]=this._getRadians(c,t)),u){const e=this._engine.map.projectArrayCoordinate(u),i=intepolateArray3(getDirection3(p,d,l).toArray(),getDirection3(d,e,l).toArray(),.5);r[h]=i;const n=this._getRadians(c,t),a=this._getRadians(t,u);s[h]=intepolateScalar(n,a,.5)}else r[h]=getDirection3(p,d,l).toArray(),s[h]=this._getRadians(c,t)}const c=[];for(let h=0;h<e.length;h++){const l=e[h][2]?e[h]:[e[h][0],e[h][1],0],u={percent:(n[h]/i).toFixed(6),point:l,position:t.projectArrayCoordinate(l),distance:n[h],direction:r[h],pitch:s[h]};a&&o&&(u.percent=(o[h]/a).toFixed(6)),c.push(u)}return c.sort(((e,t)=>e.percent-t.percent)),this._sampledPath=c,c}_getRadians(e,t){const i=new three.Vector3(t[0]-e[0],t[1]-e[1],t[2]-e[2]).normalize();return Math.PI/2-Math.acos(three.MathUtils.clamp(i.z,-1,1))}_parseCoordinateArray(e){if(Array.isArray(e)&&e.length>=2&&Array.isArray(e[0])&&"number"==typeof e[0][0])return{track:e,frameInfo:[]}}_parseGeoJSON(e){var t,i;if("LineString"===(null==(t=e.geometry)?void 0:t.type)&&Array.isArray(e.geometry.coordinates))return{track:e.geometry.coordinates,frameInfo:(null==(i=e.properties)?void 0:i.frameInfo)||[]}}_parseFrameArray(e){if(Array.isArray(e)&&e.length>0&&"object"==typeof e[0]&&"x"in e[0]){return{track:e.map((({x:e,y:t,z:i})=>[e,t,i])),frameInfo:e.map((({pitch:e,yaw:t,aim:i,speed:n,time:r})=>({pitch:e,yaw:t,aim:i,speed:n,time:r})))}}}set track(e){if(!e)return this._track=null,void(this._frameInfo=null);const t=[this._parseCoordinateArray,this._parseGeoJSON,this._parseFrameArray];for(const i of t){const t=i.call(this,e);if(t)return this._track=t.track,this._frameInfo=t.frameInfo,void this._createSampledPath(this._track)}throw new Error("Unsupported track format")}get track(){return this._track}set interpolateDirectThreshold(e){this._interpolateDirectThreshold=e,this._createSampledPath(this.track)}get interpolateDirectThreshold(){return this._interpolateDirectThreshold}set pointHandle(e){if(this._pointHandle=e,"curve"===e){const e=this._track.map((e=>(new three.Vector3).fromArray(this._engine.map.projectArrayCoordinate(e))));this.curvePath=new three.CatmullRomCurve3(e)}}get pointHandle(){return this._pointHandle}}const _box=new three.Box3,_sphere=new three.Sphere,_center=new three.Vector3,hQuat=new three.Quaternion,pQuat=new three.Quaternion,_axisX=new three.Vector3(1,0,0),_axisZ=new three.Vector3(0,0,1);class RotateTracker extends TrackerAbstract{constructor(e={}){super(e),__publicField(this,"_keepRunning",!1),__publicField(this,"_withoutTrack",!0),this._trackedObject=null,this._runConfig=null,this.viewMode="lock"}start(e={}){const{duration:t=1e4,heading:i=0,pitch:n=0,range:r=0,easing:s,object:a=null,center:o=null,projectedCenter:l=null,radius:c=100,startAngle:h=0,endAngle:u=360,loopMode:d="repeat",keepRunning:p=!0,useWorldAxis:m=!1,height:f=0,...g}=e;a||o||l?(this._trackedObject=a instanceof three.Object3D?a:null,this._runConfig={center:o,projectedCenter:l,radius:c,startAngle:three.MathUtils.degToRad(h),endAngle:three.MathUtils.degToRad(u),loopMode:d,heading:three.MathUtils.degToRad(i),pitch:three.MathUtils.degToRad(n),useWorldAxis:m,height:f},super.start({heading:0,pitch:0,roll:0,duration:t,range:r,easing:s,keepRunning:p,loopMode:d,...g})):console.warn("RotateTracker 请传入 object、center 或 projectedCenter")}_computeLocalAxes(e){const t=this._engine.map.isGlobe,i=this._engine.map.map._ellipsoid;if(!this._runConfig.useWorldAxis&&t){const t=Transforms.eastNorthUpToFixedFrame(e,i);return{east:(new three.Vector3).setFromMatrixColumn(t,0).normalize(),up:(new three.Vector3).setFromMatrixColumn(t,2).normalize()}}return{east:_axisX,up:_axisZ}}_computeOrbitAxes(e,t,i,n){const r=pQuat.setFromAxisAngle(e,n),s=t.clone().applyQuaternion(r),a=hQuat.setFromAxisAngle(t,i),o=s.applyQuaternion(a).normalize();let l=(new three.Vector3).crossVectors(o,t);if(l.lengthSq()<1e-8){const n=(new three.Vector3).crossVectors(t,e).normalize();l.copy(e.clone().negate()).multiplyScalar(Math.cos(-i)).add(n.multiplyScalar(Math.sin(-i))).normalize()}else l.normalize();return{orbitNormal:o,startVector:l.negate()}}updatePositionByPercentage(e){const t=this._runConfig;if(!t)throw new Error("请先调用 start()");let i;if(this._trackedObject){this._trackedObject.updateMatrixWorld(!0);const e=_box.setFromObject(this._trackedObject).getBoundingSphere(_sphere);i=_center.copy(e.center)}else if(t.projectedCenter)i=_center.fromArray(t.projectedCenter);else{const e=this._engine.map.projectArrayCoordinate(t.center||[0,0,0]);i=_center.fromArray(e)}const{east:n,up:r}=this._computeLocalAxes(i),{orbitNormal:s,startVector:a}=this._computeOrbitAxes(n,r,t.heading,t.pitch),o=t.endAngle-t.startAngle,l=t.startAngle+e*o,c=(new three.Quaternion).setFromAxisAngle(s,l),h=a.clone().applyQuaternion(c).normalize().multiplyScalar(t.radius),u=s.clone().multiplyScalar(t.height||0),d=i.clone().add(h).add(u),p=this._engine.map.unprojectArrayCoordinate([d.x,d.y,d.z]),m=i.clone().sub(d).normalize(),f=this.dirUpToHPR(m,p);return f.pitch+=89,{point:p,hpr:f,direction:m}}}const rotationMatrix=new three.Matrix4,headingPitchRoll=new three.Euler,tmpV3A=new three.Vector3,tmpV3B=new three.Vector3,tmpQuat=new three.Quaternion,tmpScale=new three.Vector3;class ObjectTracker extends TrackerAbstract{constructor(){super(...arguments),__publicField(this,"_trackObject",null),__publicField(this,"_trackConfig",{}),__publicField(this,"_lastState",null),__publicField(this,"_keepRunning",!0)}track(e,t={}){var i,n,r,s,a;this._trackObject=e,this._trackConfig={lock:null==(i=t.lock)||i,extraDir:t.extraDir,height:t.height},this.lockView=!!this._trackConfig.lock,this.viewFollow=!0;const o=void 0!==t.radius?t.radius:void 0!==t.range?t.range:0;this.start({duration:null!=(n=t.duration)?n:0,easing:null!=(r=t.easing)?r:"linear",range:o,pitch:null!=(s=t.pitch)?s:0,heading:null!=(a=t.heading)?a:0})}stop(){super.stop(),this._trackObject=null,this._trackConfig={},this._lastState=null}updatePositionByPercentage(){if(!this._trackObject)return null;const e=this._computeTargetState(this._trackObject,this._trackConfig);return this.onTrackFrame(this._lastState,e),this._lastState=e,e}onTrackFrame(){}_computeTargetState(e,t){const{worldCenter:i,targetEuler:n}=this._sampleTargetWorldPose(e,t);let r=0,s=0;if(this._engine.map.isGlobe){rotationMatrix.makeRotationFromEuler(n);const e=Transforms.eastNorthUpToFixedFrame(i).invert().multiply(rotationMatrix);headingPitchRoll.setFromRotationMatrix(e),r=180*(headingPitchRoll.z-Math.PI/2)/Math.PI,s=three.MathUtils.radToDeg(headingPitchRoll.x-Math.PI/2)}else r=180*(n.z-Math.PI/2)/Math.PI,s=0;const a=[];"function"==typeof this._engine.map.unprojectArrayCoordinate?this._engine.map.unprojectArrayCoordinate([i.x,i.y,i.z||0],a):(a[0]=i.x,a[1]=i.y,a[2]=i.z||0);return{point:a,hpr:{heading:r,pitch:0,roll:s}}}_sampleTargetWorldPose(e,t){let i=tmpV3A.set(0,0,0),n=new three.Euler;if(e&&e.instance&&void 0!==e.instanceIndex){const t=e.instance.getEntityByIndex(e.instanceIndex);if(t&&t.matrix){const r=new three.Matrix4;r.elements=t.matrix,r.decompose(tmpV3A,tmpQuat,tmpScale),n.setFromQuaternion(tmpQuat),n.y=n.z;const[s,a,o]=e.instance.position.toArray();i=new three.Vector3(s+tmpV3A.x,a+tmpV3A.y,o+tmpV3A.z)}}else if(e instanceof three.Object3D){e.updateMatrixWorld(!0);const t=(new three.Box3).setFromObject(e).getBoundingSphere(new three.Sphere);i.copy(t.center),e.matrixWorld.decompose(tmpV3B,tmpQuat,tmpScale),n.setFromQuaternion(tmpQuat,"ZYX")}else e instanceof three.Vector3?i.copy(e):Array.isArray(e)&&i.set(e[0],e[1],e[2]||0);return t&&"number"==typeof t.extraDir&&(n.z-=t.extraDir*Math.PI/180),{worldCenter:i,targetEuler:n}}updateCamera(e){var t,i,n;if(super.updateCamera(e),!(null==(i=null==(t=this._engine)?void 0:t.map)?void 0:i.isGlobe)&&(null==(n=this._trackConfig)?void 0:n.height)){const e=this._engine.camera;e.position.z+=this._trackConfig.height,e.updateMatrixWorld()}}static computeTransformedBoundingBox(e,t){const i=[new three.Vector3(e.min.x,e.min.y,e.min.z),new three.Vector3(e.max.x,e.min.y,e.min.z),new three.Vector3(e.min.x,e.max.y,e.min.z),new three.Vector3(e.max.x,e.max.y,e.min.z),new three.Vector3(e.min.x,e.min.y,e.max.z),new three.Vector3(e.max.x,e.min.y,e.max.z),new three.Vector3(e.min.x,e.max.y,e.max.z),new three.Vector3(e.max.x,e.max.y,e.max.z)].map((e=>e.applyMatrix4(t)));return(new three.Box3).setFromPoints(i)}}new three.Raycaster,new three.Plane(new three.Vector3(0,0,1),0);const _tempVector3$3=new three.Vector3,_matrix4$1=new three.Matrix4;class DOMOverlay extends three.Object3D{constructor(e={}){super(e),__publicField(this,"_container"),__publicField(this,"_point"),__publicField(this,"_dom"),__publicField(this,"_div"),__publicField(this,"_visible"),__publicField(this,"_offset"),__publicField(this,"_stopPropagation",!1),__publicField(this,"_enableDragging",!1),__publicField(this,"handleMouseDown",(e=>{e.preventDefault();const t=this.engine.rendering.canvas.getBoundingClientRect();this._sub=(new three.Vector2).set(this._screenPos.x-e.x+t.left,this._screenPos.y-e.y+t.top),(this.stopPropagation||this.enableDragging)&&e.stopPropagation(),isSupportPointerEvent?(e.target.setPointerCapture(e.pointerId),document.addEventListener(EVENTS.MOVE,this.handleMouseMove),document.addEventListener(EVENTS.UP,this.handleMouseUp)):(document.addEventListener(EVENTS.MOVE,this.handleMouseMove),document.addEventListener(EVENTS.UP,this.handleMouseUp))})),__publicField(this,"handleMouseUp",(e=>{document.removeEventListener(EVENTS.MOVE,this.handleMouseMove),document.removeEventListener(EVENTS.UP,this.handleMouseUp),isSupportPointerEvent&&e.target.releasePointerCapture&&e.target.releasePointerCapture(e.pointerId)})),__publicField(this,"handleMouseMove",(e=>{e.preventDefault();const t=this.engine,i=t.rendering.canvas.getBoundingClientRect(),n=e.clientX+this._sub.x-i.left,r=e.clientY+this._sub.y-i.top;_tempVector3$3.copy(t.rendering.picking.pickSeaLevelWorldPosition({x:n,y:r}));const s=[_tempVector3$3.x,_tempVector3$3.y,_tempVector3$3.z],a=t.map.unprojectArrayCoordinate(s);this.point=[a[0],a[1],this.point[2]||0],this.dispatchEvent({type:"dragmove",target:this,point:a}),t.requestRender()})),__publicField(this,"handleWheel",(e=>{e.preventDefault(),e.stopPropagation();const t=new WheelEvent("wheel",{bubbles:!1,cancelable:!0,clientX:e.clientX,clientY:e.clientY,screenX:e.screenX,screenY:e.screenY,deltaX:e.deltaX,deltaY:e.deltaY,deltaZ:e.deltaZ,deltaMode:e.deltaMode});this.engine.map.projectionName===PROJECTION_ECEF?this.engine.rendering.renderer.domElement.dispatchEvent(t):this.engine.container.dispatchEvent(t)})),this.isDOMOverlay=!0,this.parameters=e}afterAddToEngine(e){this.engine=e;const t=e.container,i=t instanceof HTMLElement||t&&"object"==typeof t&&1===t.nodeType&&"string"==typeof t.nodeName;this._container=i?t:t.container||t._container;let n=!1;const r=e.map._mapType,s="-overlay-"+e.id,a=CSS_NAMESPACE+s,o=this._container.children;if(o&&(n=Array.from(o).some((e=>e.id===a))),n)this._div=Array.from(o).find((e=>e.id===a));else if(this._div=document.createElement("div"),this._div.id=a,addClass(this._div,`${CSS_NAMESPACE}-overlay-pane`),"bmapgl"===r){const e=null==t?void 0:t.container;e&&e instanceof HTMLElement&&t.container.appendChild(this._div)}else t instanceof HTMLElement?t.appendChild(this._div):"mapbox"===r&&t._container.appendChild(this._div);this.dom=this.initDom(),this.point=this.parameters.point||[],this.offset=this.parameters.offset||[0,0],this.className=this.parameters.className||"",this.enableDragging=this._enableDragging||!1,this.visible=this.parameters.visible||!0,this.afterInit()}beforeRemoveFromEngine(e){this.dispose()}initDom(){if(this.parameters.dom)return this.parameters.dom;console.warn("`DOMOverlay` must contain a property `dom`.")}afterInit(){}onBeforeScenePrepareRender(e,t,i){if(this.dom&&this.visible){this.camera=i,this.renderer=e.renderer;let t=new three.Vector2;e.renderer.getSize(t),_matrix4$1.multiplyMatrices(i.matrixWorldInverse,this.matrixWorld),_matrix4$1.multiplyMatrices(i.projectionMatrix,_matrix4$1);const n=new three.Vector4(0,0,0,1);n.applyMatrix4(_matrix4$1),n.divideScalar(n.w),n.z>1||n.z<-1?addClass(this.dom,`${CSS_NAMESPACE}-hidden`):removeClass(this.dom,`${CSS_NAMESPACE}-hidden`);const r=(1+n.x)*t.x/2,s=(1-n.y)*t.y/2,a=this.dom.clientWidth,o=this.dom.clientHeight;let l,c,h=r-a/2+this.offset[0],u=r+a/2+this.offset[0];if(this.isPopup?(l=s-o+this.offset[1],c=s+this.offset[1]):(l=s-o/2+this.offset[1],c=s+o/2+this.offset[1]),u<0||h>t.x||c<0||l>t.y)return void("hidden"!==this.dom.style.visibility&&(this.dom.style.visibility="hidden"));this.dom.style.position="absolute","hidden"===this.dom.style.visibility&&(this.dom.style.visibility="visible"),this.dom.style.left=h+"px",this.dom.style.top=l+"px";const d=new three.Vector3(this.matrixWorld.elements[12],this.matrixWorld.elements[13],this.matrixWorld.elements[14]).clone().project(i),p=(1+d.x)*t.x/2,m=(1-d.y)*t.y/2;this._screenPos=(new three.Vector2).set(p,m),this.dom.ondragstart=()=>!1,this.enableDragging?this.dom.style.touchAction="auto":this.dom.style.touchAction="none"}}onDispose(){}dispose(){this.onDispose(),this.enableDragging&&(this._dom.removeEventListener(EVENTS.DOWN,this.handleMouseDown),this._dom.removeEventListener(EVENTS.UP,this.handleMouseUp),document.removeEventListener(EVENTS.MOVE,this.handleMouseMove),document.removeEventListener(EVENTS.UP,this.handleMouseUp)),this._dom.removeEventListener("wheel",this.handleWheel),this._dom.remove(),this._dom=null,0===this._div.childElementCount&&this._div.remove()}get dom(){return this._dom}set dom(e){if(this._dom&&(this.enableDragging&&(this._dom.removeEventListener(EVENTS.DOWN,this.handleMouseDown),this._dom.removeEventListener(EVENTS.UP,this.handleMouseUp)),this._div.removeChild(this._dom)),"string"==typeof e){const t=document.createElement("div");addClass(t,`${CSS_NAMESPACE}-dom-overlay-custom`);const i=(new DOMParser).parseFromString(e,"text/html").body.children;for(let e=0;e<i.length;e++)t.appendChild(i.item(e));this._dom=t}else this._dom=e;this._div.appendChild(this._dom),this._dom.style.visibility="hidden",this._dom.setAttribute("draggable","false"),this._dom.ondragstart=()=>!1,this.enableDragging&&(this._dom.addEventListener(EVENTS.DOWN,this.handleMouseDown),this._dom.addEventListener(EVENTS.UP,this.handleMouseUp),this._dom.style.cursor="pointer"),this._dom.addEventListener("wheel",this.handleWheel)}get point(){return this._point}set point(e){Array.isArray(e)&&e.length>1?(this._point=e,this.engine&&this.position.set(...this.engine.map.projectArrayCoordinate(e))):(e.isVector2||e.isVector3)&&(this._point=[e.x,e.y,e.z||0],this.engine&&this.position.copy(this.engine.map.projectCoordinate(e)))}get visible(){return this._visible}set visible(e){e!==this._visible&&(this._visible=e)}get offset(){return this._offset}set offset(e){this._offset=e}get stopPropagation(){return this._stopPropagation}set stopPropagation(e){this._stopPropagation=e}get enableDragging(){return this._enableDragging}set enableDragging(e){this._enableDragging!==e&&(this._enableDragging=e,this.dom&&(e?(this.dom.addEventListener(EVENTS.DOWN,this.handleMouseDown),this.dom.addEventListener(EVENTS.UP,this.handleMouseUp),this.dom.style.cursor="pointer"):(this.dom.removeEventListener(EVENTS.DOWN,this.handleMouseDown),this.dom.removeEventListener(EVENTS.UP,this.handleMouseUp),this.dom.style.cursor="auto")))}get className(){return this._className}set className(e){e!==this._className&&(this.dom&&(this._className&&removeClass(this.dom,this._className),addClass(this.dom,e)),this._className=e)}}class Popup extends DOMOverlay{constructor(e){super(e),__publicField(this,"_titleDiv"),__publicField(this,"_contentDiv"),__publicField(this,"_title"),__publicField(this,"_content"),__publicField(this,"_closePopup"),__publicField(this,"click",(()=>{this.visible=!1,this.dispatchEvent({type:"close",target:this})})),this.isPopup=!0}initDom(){const e=document.createElement("div");addClass(e,`${CSS_NAMESPACE}-popup`);const t=document.createElement("div");addClass(t,"frame");const i=this._titleDiv=document.createElement("div");addClass(i,"title"),i.innerText=this.title;const n=this._closePopup=document.createElement("div");addClass(n,"close"),n.innerText="x",n.addEventListener("click",this.click);const r=this._contentDiv=document.createElement("div");addClass(r,"content"),r.innerText=this.content,t.appendChild(n),t.appendChild(i),t.appendChild(r);const s=document.createElement("div");return addClass(s,"triangle"),e.appendChild(t),e.appendChild(s),e}afterInit(){this.title=this.parameters.title||"title",this.content=this.parameters.content||"content"}onDispose(){this._closePopup.removeEventListener("click",this.click)}get title(){return this._title}set title(e){e&&(this._title=e,this._titleDiv&&(this._titleDiv.innerText=e))}get content(){return this._content}set content(e){this._content=e,this._contentDiv&&(this._contentDiv.innerText=e)}}class Marker extends DOMOverlay{constructor(e={}){super(e),__publicField(this,"_icon"),__publicField(this,"_width"),__publicField(this,"_height"),__publicField(this,"_title"),this.isMarker=!0,this._title=e.title||"",this._icon=e.icon||getAssetUrl("assets/images/marker_red.png"),this._width=e.width||25,this._height=e.height||25}initDom(){let e=document.createElement("img");return addClass(e,`${CSS_NAMESPACE}-marker`),e}afterInit(){this.icon=this._icon,this.width=this._width,this.height=this._height}get icon(){return this._icon}set icon(e){this.dom&&(this.dom.src=e),this._icon=e}get width(){return this._width}set width(e){this.dom&&(this.dom.width=e),this._width=e}get height(){return this._height}set height(e){this.dom&&(this.dom.height=e),this._height=e}set title(e){this.dom&&(this.dom.title=e),this._title=e}get title(){return this._title}}const API_SOURCE_BAIDU="baidu",API_SOURCE_TIANDITU="tdt";let apiSource=API_SOURCE_BAIDU;function setApiSource(e){apiSource=e}function getApiSource(){return apiSource}const http$7="https:"===location.protocol?"https":"http";let DataMgr={request:async function(e){-1===e.indexOf("v=")&&(e+="&v=three");const t="jsonp"+Math.ceil(1e5*Math.random());return e=e+"&callback="+t,e=DataMgr.getSeckeyAndSign(e),await jsonp(e,{},{autoCallback:!1,callbackName:t})},getSeckeyAndSign:function(e){let t=decodeURIComponent(e),i=(new Date).getTime(),n=window.___abvk?window.___abvk:DataMgr.getSeckeyCidItem("SECKEY_ABVK"),r=DataMgr.getSeckeyCidItem("BMAP_SECKEY");return e+="&seckey="+encodeURIComponent(n+","+r)+"&timeStamp="+i,t+="&seckey="+(n+","+r)+"&timeStamp="+i,e+=appendSign(t)},getSeckeyCidItem:function(e){return localStorage?localStorage.getItem(e)?localStorage.getItem(e):-1:sessionStorage?sessionStorage.getItem(e)?sessionStorage.getItem(e):-1:void 0}},SearchRequestMgr={request:async function(e,t,i,n){let r;if(i=i||"",r=t&&t.useEncodeURI?jsonToQuery(e,encodeURI):jsonToQuery(e,encodeURIComponent),!BaiduMapConfig.ak)throw new Error("BaiduMapConfig.ak is not set");let s=`${`${http$7}://api.map.baidu.com`}/${i}?${r}&ie=utf-8&oue=1&fromproduct=jsapi&ak=${BaiduMapConfig.ak}`;n||(s+="&res=api");let a=await DataMgr.request(s);return a.result&&0!==a.result.error&&console.error("BaiduRequest request failed:",a.result.error_msg),a}};function jsonToQuery(e,t){let i=[];t=t||function(e){return e};for(let n in e)Object.prototype.hasOwnProperty.call(e,n)&&i.push(n+"="+t(e[n]));return i.join("&")}const BMAP_ROUTE_TYPE_TRANSIT=1,BMAP_ROUTE_TYPE_WALKING=2,BMAP_ROUTE_TYPE_DRIVING=3,BMAP_ROUTE_TYPE_RIDING=6,QUERY_TYPE_CENTER="cen",QUERY_TYPE_POI_SEARCH="s",QUERY_TYPE_POI_SEARCH_CON="con",QUERY_TYPE_SEARCH_INBOUNDS="bd",QUERY_TYPE_SEARCH_NEARBY="nb",QUERY_TYPE_TRANSIT="bt",QUERY_TYPE_DRIVING="nav",QUERY_TYPE_WALKING="walk",QUERY_TYPE_GEOCODER="gc",QUERY_TYPE_REVERSE_GEOCODER="rgc",QUERY_TYPE_SEARCH_INBOUNDS_MULTIKEY="bda",QUERY_TYPE_SEARCH_MULTIKEY="sa",QUERY_TYPE_SEARCH_NEARBY_MULTIKEY="nba",QUERY_TYPE_EXT="ext",QUERY_TYPE_EXTS="exts",QUERY_TYPE_RIDING="ride",QUERY_TYPE_DIRECTION="drct",RETURN_TYPE_CURRENT_CITY=2,RETURN_TYPE_CENTER=4,RETURN_TYPE_CITY_LIST=7,RETURN_TYPE_POI_SEARCH=11,RETURN_TYPE_SEARCH_NEARBY=12,RETURN_TYPE_TRANSIT=14,RETURN_TYPE_DRIVING=20,RETURN_TYPE_SEARCH_INBOUNDS=21,RETURN_TYPE_SPECIAL_REGION=26,RETURN_TYPE_NODATA_REGION=28,RETURN_TYPE_WALKING=31,RETURN_TYPE_GEOCODER=35,RETURN_TYPE_REVERSE_GEOCODER=44,RETURN_TYPE_SEARCH_INBOUNDS_MULTIKEY=45,RETURN_TYPE_SEARCH_MULTIKEY=46,RETURN_TYPE_SEARCH_NEARBY_MULTIKEY=47,BMAP_POI_TYPE_NORMAL=0,BMAP_POI_TYPE_BUSSTOP=1,BMAP_POI_TYPE_SUBSTOP=3,DIRECTION_RETURN_TYPE_CLEAR=2,BMAP_TRANSIT_TYPE_IN_CITY=0,BMAP_TRANSIT_TYPE_CROSS_CITY=1,BMAP_VEHICLE_TYPE_BUS=3,BMAP_VEHICLE_TYPE_DRIVING=4,BMAP_VEHICLE_TYPE_TRAIN=1,BMAP_VEHICLE_TYPE_AIRPLANE=2,BMAP_VEHICLE_TYPE_WALKING=5,BMAP_VEHICLE_TYPE_COACH=6,BMAP_LINE_TYPE_BUS=0,BMAP_LINE_TYPE_SUBWAY=1,BMAP_LINE_TYPE_TRAIN=3,BMAP_LINE_TYPE_AIRPLANE=4,BMAP_LINE_TYPE_COACH=5,_tempVec3Scratch=new three.Vector3,_tempVec3Scratch1=new three.Vector3,_tempVec3Scratch2=new three.Vector3;class Geocoder_Bd{constructor(e={}){this.options=e,this._baiduMercatorProjection=getProjection(PROJECTION_BD_MERCATOR)}getPoint(e,t,i){i=i||"";if(!/^[ \s]*$/.test(e))return SearchRequestMgr.request({qt:QUERY_TYPE_GEOCODER,wd:e,cn:i}).then((e=>{if(e&&e.result&&e.result.type===RETURN_TYPE_GEOCODER){let i=e.result,n=e.content,r=null,s=null;if(i&&0===i.error&&n&&n.coord){let e=n.coord.x,t=n.coord.y,i=n.cn,a=n.sc,o=n.wd,l=n.prc,c=n.fuzzy_score,h=n.catalog;_tempVec3Scratch.set(e,t,0),r=this._baiduMercatorProjection.unprojectCoordinate(_tempVec3Scratch),s={city:i,citycode:a,address:o,precise:l,confidence:c,level:h}}return t&&t(r,s),r}}))}getLocation(e,t,i){let n=null,r=null,s=null;if(e instanceof three.Vector2?(n=e.x,r=e.y,s=0):Array.isArray(e)?(n=e[0],r=e[1],s=e[2]||0):e instanceof three.Vector3&&(n=e.x,r=e.y,s=e.z),(!n||!r)&&t)return void t(null);_tempVec3Scratch1.set(n,r,s),n=(e=this._baiduMercatorProjection.projectCoordinate(_tempVec3Scratch1)).x,r=e.y,s=e.z;let a=(i=i||{}).poiRadius||100,o=i.numPois||10;return SearchRequestMgr.request({qt:QUERY_TYPE_REVERSE_GEOCODER,x:n,y:r,dis_poi:a,poi_num:o,latest_admin:"1",language:"zh"}).then((e=>{let i=null;if(e&&e.result&&e.result.type===RETURN_TYPE_REVERSE_GEOCODER){let t,n=e.result,r=e.content,a={},o=[];if(0===n.error&&r){let e=r.address_detail,n=e.city;e&&(a.streetNumber=e.street_number,a.street=e.street,a.district=e.district,a.city=n,a.province=e.province),t=r.point,_tempVec3Scratch2.set(+t.x,+t.y,s);let l=this._baiduMercatorProjection.unprojectCoordinate(_tempVec3Scratch2),c=r.surround_poi;if(c&&c.length)for(let t=0,i=c.length;t<i;t++){let e={},i=c[t];e.title=i.name,e.uid=i.uid,_tempVec3Scratch2.set(+i.point.x,+i.point.y,s);let r=this._baiduMercatorProjection.unprojectCoordinate(_tempVec3Scratch2);e.point=r,e.city=n,e._poiType=i.poiType,e.type=BMAP_POI_TYPE_NORMAL,e.address=i.addr,e.postcode=i.zip||null,e.phoneNumber=i.tel||null;let a=e._poiType;0!==a.length&&(e.tags=a.split(",")),o.push(e)}i={point:l,address:r.address,addressComponents:a,surroundingPois:o,business:r.business,content:r}}}return t&&t(i),i}))}}const http$6="https:"===location.protocol?"https":"http";class ScriptLoader{constructor(){this.objName="tdt_loadResult",this.win=window,this.charset="utf-8",this.src=null,this.callback=null,this.oScript=null,this.running=!1}static async request(e){return new Promise(((t,i)=>{if(!e)return void i(new Error("天地图API URL不能为空"));const n=ScriptLoader.getObject();let r=TiandituConfig.tk||"您的密钥";-1===e.indexOf("tk=")&&(e+="&tk="+r),e=encodeURIComponent(e);let s=`${http$6}://api.tianditu.gov.cn/apiserver/ajaxproxy?proxyReqUrl=${e}`;n.loadScript(s,"utf-8",this,(e=>{t(e)}))}))}loadScript(e,t,i,n){if(!e)return;this.src=e,this.charset=t||"utf-8",this.callback=n?ScriptLoader.createCallback(i,n):null,this.oScript=document.createElement("script"),this.oScript.type="text/javascript",this.oScript.async=!0,this.oScript.charset=this.charset,this.oScript.src=this.src,this.running=!0;const r=this;this.oScript.onload=this.oScript.onreadystatechange=function(){this.readyState&&"loaded"!==this.readyState&&"complete"!==this.readyState||(this.onload=this.onreadystatechange=null,r.handleLoadComplete())},this.win.document.body.insertBefore(this.oScript,this.win.document.body.firstChild)}handleLoadComplete(){const e=this.win;let t="";e[this.objName]&&(t=e[this.objName],e[this.objName]=null),this.callback&&this.callback(t),this.cleanupScriptElement(),this.running=!1}cleanupScriptElement(){!document.all&&this.oScript&&this.oScript.parentNode===this.win.document.body&&(this.oScript.removeAttribute("src"),this.win.document.body.removeChild(this.oScript),this.oScript=null)}static getObject(e=window){e.scriptLoader_obj||(e.scriptLoader_obj=[]);for(let i=0;i<e.scriptLoader_obj.length;i++)if(!e.scriptLoader_obj[i].running){const t=e.scriptLoader_obj[i];return t.running=!0,t}const t=new ScriptLoader;return e.scriptLoader_obj.push(t),t}static getElementWindow(e){return e&&e.ownerDocument&&e.ownerDocument.parentWindow?e.ownerDocument.parentWindow:window}static processEventArguments(e){return e||(e=[]),e[0]||(e[0]=ScriptLoader.getElementWindow().event),e[0]&&!e[0].target&&e[0].srcElement&&(e[0].target=e[0].srcElement),e}static createCallback(e,t){return function(...i){t.apply(e,ScriptLoader.processEventArguments(i))}}}const http$5="https:"===location.protocol?"https":"http";class Geocoder_Tdt{constructor(e={}){this.options=e}getPoint(e,t,i){if(/^[ \s]*$/.test(e))return;let n=`${http$5}://api.tianditu.gov.cn/geocoder?ds={"keyWord":"${e}"}`;return ScriptLoader.request(n).then((e=>{if(e&&"0"===e.status&&"ok"===e.msg){let i=e.location,n=null,r=null;if(i){let e=+i.lon,t=+i.lat,s=i.keyWord,a=i.score,o=i.level;n=new three.Vector3(e,t,0),r={address:s,confidence:a,level:o}}return t&&t(n,r),n}}))}getLocation(e,t){let i=null,n=null;if(e instanceof three.Vector2?(i=e.x,n=e.y):Array.isArray(e)?(i=e[0],n=e[1],e[2]):e instanceof three.Vector3&&(i=e.x,n=e.y,e.z),(!i||!n)&&t)return void t(null);let r=`${http$5}://api.tianditu.gov.cn/geocoder?postStr={'lon':${i},'lat':${n},'ver':1}&type=geocode`;return ScriptLoader.request(r).then((e=>{let i=null;if(e&&"0"===e.status&&"ok"===e.msg){let t=e.result;if(t){let e=+t.location.lon,n=+t.location.lat;i={address:t.formatted_address,addressComponents:t.addressComponent,point:new three.Vector3(e,n,0)}}}return t&&t(i),i}))}}class Geocoder{constructor(e={}){this.options=e,this.apiSource=e.apiSource||getApiSource(),this._gc=this._createInstance(e)}_createInstance(e){return new({[API_SOURCE_BAIDU]:Geocoder_Bd,[API_SOURCE_TIANDITU]:Geocoder_Tdt}[this.apiSource]||Geocoder_Bd)(e)}getPoint(e,t,i){return this._gc.getPoint(e,t,i)}getLocation(e,t,i){return this._gc.getLocation(e,t,i)}}const GEO_TYPE_AREA=0,GEO_TYPE_LINE=1,GEO_TYPE_POINT=2,baiduMercatorProjection=getProjection(PROJECTION_BD_MERCATOR),SUtil={unique:function(e){let t=[],i={};for(let n=0,r=e.length;n<r;n++)i[e[n]]||(i[e[n]]=!0,t.push(e[n]));return t},parseGeo:function(e,t){if("string"!=typeof e||!e)return;let i,n,r,s=e.split("|");if(1===s.length)i=decode_geo_diff(e);else if(i=decode_geo_diff(s[2]),n=decode_geo_diff(s[0]),r=decode_geo_diff(s[1]),!t)return i;let a={type:i.geoType};if(t)switch(a.type){case GEO_TYPE_POINT:const e=new three.Vector2(i.geo[0][0],i.geo[0][1]),t=baiduMercatorProjection.unprojectCoordinate(e);a.point=t,a.points=[t];break;case GEO_TYPE_LINE:a.points=[];const s=i.geo[0];for(let i=0,n=s.length-1;i<n;i+=2){let e=new three.Vector2(s[i],s[i+1]);e=baiduMercatorProjection.unprojectCoordinate(e),a.points.push(e)}n=new three.Vector3(n.geo[0][0],n.geo[0][1],-100),r=new three.Vector3(r.geo[0][0],r.geo[0][1],100),n=baiduMercatorProjection.unprojectCoordinate(n),r=baiduMercatorProjection.unprojectCoordinate(r),a.bounds=new three.Box3(n,r)}return a},pathToPoints:function(e){let t=[];if("string"!=typeof e)return t;let i=e.split(";");for(let n=0;n<i.length;n++){let e=i[n].split(",");t.push([+e[0],+e[1]])}return t},pointsToString:function(e){let t="";if("object"!=typeof e)return e;if(Array.isArray(e)&&("number"==typeof e[0]||"string"==typeof e[0]))return e.join(",");for(let i=0;i<e.length;i++){let n=this.getY(e[i])+","+this.getX(e[i]);i!==e.length-1?t=t+n+"|":t+=n}return t},getX:function(e){return e.isVector2||e.isVector3?e.x:Array.isArray(e)?e[0]:"object"==typeof e&&e.lng&&e.lat?e.lng:e},getY:function(e){return e.isVector2||e.isVector3?e.y:Array.isArray(e)?e[1]:"object"==typeof e&&e.lng&&e.lat?e.lat:e}},_EXT_CHARS_=["=",".","-","*"],_MAX_DELTA_=1<<23;function decode_geo_diff(e){let t=_decode_type(e.charAt(0)),i=e.substr(1),n=0,r=i.length,s=[],a=[],o=[];for(;n<r;)if(i.charAt(n)===_EXT_CHARS_[0]){if(r-n<13)return 0;if(o=_decode_6byte_(i.substr(n,13),s),o<0)return 0;n+=13}else if(";"===i.charAt(n))a.push(s.slice(0)),s.length=0,++n;else{if(r-n<8)return 0;if(o=_decode_4byte_(i.substr(n,8),s),o<0)return 0;n+=8}for(let l=0,c=a.length;l<c;l++)for(let e=0,t=a[l].length;e<t;e++)a[l][e]/=100;return{geoType:t,geo:a}}function _decode_type(e){let t=-1;return e===_EXT_CHARS_[1]?t=GEO_TYPE_POINT:e===_EXT_CHARS_[2]?t=GEO_TYPE_LINE:e===_EXT_CHARS_[3]&&(t=GEO_TYPE_AREA),t}function _decode_6byte_(e,t){let i=0,n=0,r=0;for(let s=0;s<6;s++){if(r=_char2num_(e.substr(1+s,1)),r<0)return-1-s;if(i+=r<<6*s,r=_char2num_(e.substr(7+s,1)),r<0)return-7-s;n+=r<<6*s}return t.push(i),t.push(n),0}function _decode_4byte_(e,t){let i=t.length;if(i<2)return-1;let n=0,r=0,s=0;for(let a=0;a<4;a++){if(s=_char2num_(e.substr(a,1)),s<0)return-1-a;if(n+=s<<6*a,s=_char2num_(e.substr(4+a,1)),s<0)return-5-a;r+=s<<6*a}return n>_MAX_DELTA_&&(n=_MAX_DELTA_-n),r>_MAX_DELTA_&&(r=_MAX_DELTA_-r),t.push(t[i-2]+n),t.push(t[i-1]+r),0}function _char2num_(e){let t=e.charCodeAt(0);return e>="A"&&e<="Z"?t-"A".charCodeAt(0):e>="a"&&e<="z"?26+t-"a".charCodeAt(0):e>="0"&&e<="9"?52+t-"0".charCodeAt(0):"+"===e?62:"/"===e?63:-1}class LocalResult{constructor(e={}){this.keyword=e.keyword||"",this.pageIndex=e.pageIdx||0,this.currentNumPois=e.count||0,this.total=e.total||0,this.numPages=Math.ceil(e.total/e.pc),this.center=e.center,this.radius=e.radius,this.bounds=e.bounds,this.city=e.city,this.province=e.province,this.pois=e.pois&&e.pois.slice(0)||[]}}const _tempVec3$2=new three.Vector3;class LocalSearch_Bd{constructor(e={}){__publicField(this,"_isReqDataMap",((e,t)=>!(!e||void 0===t)&&((e!==QUERY_TYPE_POI_SEARCH||t===RETURN_TYPE_POI_SEARCH||t===RETURN_TYPE_CITY_LIST||t===RETURN_TYPE_CURRENT_CITY||t===RETURN_TYPE_SPECIAL_REGION||t===RETURN_TYPE_NODATA_REGION)&&((e!==QUERY_TYPE_SEARCH_NEARBY||t===RETURN_TYPE_SEARCH_NEARBY)&&((e!==QUERY_TYPE_SEARCH_INBOUNDS||t===RETURN_TYPE_SEARCH_INBOUNDS)&&((e!==QUERY_TYPE_SEARCH_INBOUNDS_MULTIKEY||t===RETURN_TYPE_SEARCH_INBOUNDS_MULTIKEY)&&((e!==QUERY_TYPE_SEARCH_MULTIKEY||t===RETURN_TYPE_SEARCH_MULTIKEY)&&(e!==QUERY_TYPE_SEARCH_NEARBY_MULTIKEY||t===RETURN_TYPE_SEARCH_NEARBY_MULTIKEY)))))))),__publicField(this,"_formatAddr",((e,t)=>(t=t||BMAP_POI_TYPE_NORMAL)===BMAP_POI_TYPE_BUSSTOP||t===BMAP_POI_TYPE_SUBSTOP?SUtil.unique(e.split(";")).join("; "):e)),this.options=e,this._baiduMercatorProjection=getProjection(PROJECTION_BD_MERCATOR)}async search(e,t){let i=1;if(this._engine){const e=this._baiduMercatorProjection.projectCoordinate(_tempVec3$2.fromArray(this._engine.map.getCenter())).toArray(),n=t.zoom||this._engine.map.getZoom();let r=await SearchRequestMgr.request({qt:QUERY_TYPE_CENTER,b:e[0]+","+e[1]+";"+e[0]+","+e[1],l:n});r&&r.result&&r.result.type===RETURN_TYPE_CENTER&&(i=r.content?r.content.uid:1)}const n=t.forceLocal?QUERY_TYPE_POI_SEARCH_CON:QUERY_TYPE_POI_SEARCH;let r=await SearchRequestMgr.request({qt:n,c:i,wd:e,rn:t.pageCapacity,pn:t.pageNum});const s=r.result;if(0!==s.error||!this._isReqDataMap(n,s.type))return;const a=r.content,o=r.current_city,l=s.page_num||0,c=s.count-(0===l&&s.spec_dispnum||0),h=s.total<760?s.total:760,u=[];for(let d=0===l&&s.spec_dispnum||0;d<s.count;d++)if(a&&a[d]){let e=a[d];if(null===e.addr)continue;let t=this._formatAddr(e.addr,e.poiType),i=[];if(e.cla&&e.cla.length>0){let t=e.cla.length;for(;t--;){let n=e.cla[t][1];n=n.replace("<b>","").replace("</b>",""),i.unshift(n)}}let n=[];e.std_tag&&e.std_tag.length>0&&(n=e.std_tag.split(";"));let r={title:e.name,uid:e.uid,adcode:e.admin_info?e.admin_info.area_id:"",point:SUtil.parseGeo(e.geo,!0).point,address:t,city:e.admin_info?e.admin_info.city_name:"",province:e.admin_info?e.admin_info.province_name:"",areaname:e.admin_info?e.admin_info.area_name:"",phoneNumber:e.tel,postcode:e.zip,type:e.poiType||BMAP_POI_TYPE_NORMAL,isAccurate:!(!e.acc_flag||1!==e.acc_flag),std_tag:n};i.length>0&&(r.tags=i),u.push(r)}return new LocalResult({keyword:e,count:c,total:h,pageIdx:l,pc:t.pageCapacity,city:o.name,ccode:o.code,province:o.up_province_name||"",pois:u})}}const http$4="https:"===location.protocol?"https":"http";class LocalSearch_Tdt{constructor(e={}){this.options=e}async search(e,t){var i,n,r;const s={keyWord:e,level:12,mapBound:"116.02524,39.83833,116.65592,39.99185",queryType:1,start:t.pageNum,count:t.pageCapacity};if(this._engine){const e=this._engine.map.getBounds(),i=t.zoom||this._engine.map.getZoom();s.mapBound=`${e.min.x},${e.min.y},${e.max.x},${e.max.y}`,s.level=Math.floor(i)}let a=`${http$4}://api.tianditu.gov.cn/v2/search?postStr=${JSON.stringify(s)}&type=query`,o=await ScriptLoader.request(a);if(o&&o.status&&1e3===o.status.infocode&&o.pois){const e=o.pois,s=+o.count,a=e.length||0,l=(null==(r=null==(n=null==(i=o.prompt)?void 0:i[0])?void 0:n.admins)?void 0:r[0])||{},c=[];for(let t=0;t<a;t++){const i=e[t],n=i.lonlat.split(","),r=new three.Vector3(+n[0],+n[1],0),s={title:i.name,uid:i.hotPointID,point:r,address:i.address,phoneNumber:i.phone,type:+i.poiType||101,source:+i.source||0,province:i.province||"",city:i.city||"",areaname:i.county||""};c.push(s)}return new LocalResult({keyword:o.keyWord,count:a,total:s,pageIdx:t.pageNum,pc:t.pageCapacity,city:l.adminName,ccode:l.adminCode,province:"",pois:c})}}}const _LocalSearch=class{constructor(e={}){__publicField(this,"result",null),__publicField(this,"_markers",[]),__publicField(this,"_popup",null),e.renderOptions=e.renderOptions||{},this.options=e,this.apiSource=e.apiSource||getApiSource(),this._local=this._createInstance(e),e.renderOptions.engine&&(this._engine=e.renderOptions.engine,this._local._engine=this._engine),this.setPageCapacity(e.pageCapacity),this.setPageNum(e.pageNum)}_createInstance(e){return new({[API_SOURCE_BAIDU]:LocalSearch_Bd,[API_SOURCE_TIANDITU]:LocalSearch_Tdt}[this.apiSource]||LocalSearch_Bd)(e)}async search(e,t={}){this.clearResult(),t.pageCapacity=t.pageCapacity||this.getPageCapacity(),t.pageNum=t.pageNum||this.getPageNum();const i=await this._local.search(e,t);return this.result=i,this._engine&&this.renderMap(i),i}gotoPage(e){this.result&&(this.setPageNum(e),this.search(this.result.keyword,{pageCapacity:this.getPageCapacity(),pageNum:this.getPageNum()}))}renderMap(e){const t=this._engine;this.clearMap(),this._popup=t.add(new Popup({point:e.pois[0].point,title:e.pois[0].title,content:e.pois[0].address,offset:[0,-16]}));for(let i=0;i<e.pois.length;i++){const n=e.pois[i];let r;r=i<10?t.add(new Marker({point:n.point,icon:getAssetUrl(`assets/images/markers/mkr_red_${i+1}.png`),width:21,height:33})):t.add(new Marker({point:n.point,width:23,height:25})),r.dom.addEventListener("click",(()=>{this.setPopupByIndex(i)})),this._markers.push(r)}if(this.options.renderOptions.autoViewport){const i=e.pois.map((e=>e.point));t.map.setViewport(i,{range:0})}}setPopupByIndex(e){const t=this.result.pois[e];this._popup.point=t.point,this._popup.title=t.title,this._popup.content=t.address,this._popup.visible=!0}clearMap(){if(this._engine){const e=this._engine;for(let t=0;t<this._markers.length;t++){const i=this._markers[t];e.remove(i)}this._markers=[],this._popup&&(e.remove(this._popup),this._popup=null)}}setPageCapacity(e){"number"!=typeof e||isNaN(e)?this.options.pageCapacity=_LocalSearch.DEFAULT_PAGE_CAPACITY:this.options.pageCapacity=e<1||e>_LocalSearch.MAX_PAGE_CAPACITY?_LocalSearch.DEFAULT_PAGE_CAPACITY:e}getPageCapacity(){return this.options.pageCapacity}setPageNum(e){"number"!=typeof e||isNaN(e)?this.options.pageNum=_LocalSearch.DEFAULT_PAGE_NUM:this.options.pageNum=e<0?_LocalSearch.DEFAULT_PAGE_NUM:e}getPageNum(){return this.options.pageNum}getResult(){return this.result}clearResult(){this.result=null}};let LocalSearch=_LocalSearch;__publicField(LocalSearch,"DEFAULT_PAGE_CAPACITY",10),__publicField(LocalSearch,"MIN_PAGE_CAPACITY",1),__publicField(LocalSearch,"MAX_PAGE_CAPACITY",100),__publicField(LocalSearch,"DEFAULT_RADIUS",2e3),__publicField(LocalSearch,"MAX_RADIUS",1e5),__publicField(LocalSearch,"DEFAULT_PAGE_NUM",0);const _tempVec3$1=new three.Vector3;class AutoComplete_Bd extends three.EventDispatcher{constructor(e={}){super(),this.options={debounceTime:100,minKeywordLength:1,maxResults:10,showSuggestion:!0,containerClassName:"autocomplete-suggestion-container",customStyles:{},...e},this._isInitialized=!1,this._exIndex=-1,this._json=null,this._typeIds=[],this._cityId=0,this._results=null,this._word="",this._currentRequest=null,this.oldValue="",this.keyValue="",this.pickValue="",this.mousedownView=!1,this.stopCircleTemporary=!1,this.defaultIptValue="",this.circleTimer=null,this.requestTimer=0,this._baiduMercatorProjection=getProjection(PROJECTION_BD_MERCATOR),this.TYPES_COLLECTION={ALL:"0",CITY:"1"}}initialize(){this._isInitialized||(this._exIndex=-1,this._json=null,this._typeIds=[],this._cityId=0,this._results=this._createEmptyResult(),this._getTypesId(),this._getCityId(),this._initTangramStyle(),this._isInitialized=!0)}_initTangramStyle(){const e=this._getInputElement();e&&(e.setAttribute("autocomplete","off"),this._startPolling(e))}setPickValue(e){this.pickValue=e}_startPolling(e){this.circleTimer=setInterval((()=>{if(this.stopCircleTemporary)return;if(!e||!e.parentNode)return void this.dispose();const t=e.value;t===this.oldValue&&""!==t&&t!==this.keyValue&&t!==this.pickValue?0===this.requestTimer&&(this.requestTimer=setTimeout((()=>{this._dispatchNeedData(t)}),this.options.debounceTime)):(clearTimeout(this.requestTimer),this.requestTimer=0,""===t&&""!==this.oldValue&&(this.pickValue=""),this.oldValue=t,t!==this.pickValue&&(this.defaultIptValue=t),this.keyValue!==e.value&&(this.keyValue=""))}),10)}_dispatchNeedData(e){this.dispatchEvent({type:"needData",keyword:e,target:this}),this._sendAutocompleteRequest(e)}_getInputElement(){return"string"==typeof this.options.input?document.getElementById(this.options.input):this.options.input}search(e){this._sendAutocompleteRequest(e)}_sendAutocompleteRequest(e){if(!e.trim())return;this._cancelCurrentRequest(),this._word=e,this._exIndex=-1,this._results=this._createEmptyResult();const t=this._shouldLimitCity(),i={qt:"placesug",query:e,region:t?this._cityId:1,city_limit:t,output:"json"};this._currentRequest=SearchRequestMgr.request(i).then((e=>{this._handleAutocompleteResponse(e)})).catch((e=>{this._handleRequestError(e)}))}_handleAutocompleteResponse(e){try{if(!this._validateResponse(e))return;e.result&&e.result.query&&(this._word=e.result.query);this._formatResponseData(e);this._results=this._createAutocompleteResult(this._json),this.dispatchEvent({type:"searchComplete",results:this._results,keyword:this._word,rawData:e,target:this})}catch(t){this._handleRequestError(t)}}_cancelCurrentRequest(){this._currentRequest=null}getResults(){return this._results}dispose(){this.circleTimer&&(clearInterval(this.circleTimer),this.circleTimer=null),this.requestTimer&&(clearTimeout(this.requestTimer),this.requestTimer=0),this._cancelCurrentRequest(),this._isInitialized=!1}_validateResponse(e){return!(!e||!e.result||0!==e.status||void 0!==e.result.error&&0!==e.result.error)}_formatResponseData(e){var t,i,n,r;const s=(null==(t=e.content)?void 0:t.poi_list)||(null==(i=e.result)?void 0:i.poi_list)||[],a=Math.min(s.length,this.options.maxResults),o={keyword:(null==(n=e.result)?void 0:n.query)||this._word,count:a,status:0===(null==(r=e.result)?void 0:r.error)?"SUCCESS":"SERVICE_UNAVAILABLE",items:[]},l=[];for(let c=0;c<a;c++){const e=this._formatSingleItem(s[c]);o.items.push(e.value),l.push(e)}return this._json=o,{data:l,word:o.keyword}}_formatSingleItem(e){return{value:{province:e.province||e.prov||"",city:e.city||e.cityname||"",district:e.district||e.area||"",street:e.name||e.street||"",streetNumber:e.street_number||"",business:e.business||"",address:e.address||e.addr||"",tag:e.tag||e.catalog||"",location:e.location?new three.Vector3(e.location.lng||e.location.x,e.location.lat||e.location.y,0):e.point?new three.Vector3(e.point.x,e.point.y,0):null}}}_handleRequestError(e){console.error("AutoComplete request failed:",e),this.dispatchEvent({type:"error",message:e.message||"Request failed",target:this})}setTypes(e){this.options.types=e,this._getTypesId()}_shouldLimitCity(){const e=this._typeIds.split(",");return e.length>=1&&1===Number(e[0])}_getTypesId(){const e=this.options.types,t=[];"string"==typeof e?t.push(this.TYPES_COLLECTION[e.toUpperCase()]||"0"):Array.isArray(e)&&e.forEach((e=>{t.push(this.TYPES_COLLECTION[e.toUpperCase()]||"0")})),this._typeIds=t.length>0?t.join(","):"0"}async _getCityId(){const e=this.options.location;let t=1;if(e){const i=18,n=this._baiduMercatorProjection.projectCoordinate(_tempVec3$1.fromArray(e)).toArray(),r=await SearchRequestMgr.request({qt:QUERY_TYPE_CENTER,b:n[0]+","+n[1]+";"+n[0]+","+n[1],l:i});r&&r.result&&r.result.type===RETURN_TYPE_CENTER&&(t=r.content?r.content.uid:1)}this._cityId=t}_createEmptyResult(){return{keyword:this._word||"",total:0,pois:[]}}_createAutocompleteResult(e){if(!e)return this._createEmptyResult();const t=e.items.map((e=>e.value||e));return{keyword:e.keyword,total:e.count,pois:t}}}class AutoComplete extends three.EventDispatcher{constructor(e={}){super(),this.options={input:null,types:[],location:null,maxResults:10,debounceTime:100,apiSource:getApiSource(),...e},this.apiSource=this.options.apiSource||getApiSource(),this._ac=this._createInstance(this.options),this._isInitialized=!1,this.initialize()}_createInstance(e){const t={[API_SOURCE_BAIDU]:AutoComplete_Bd}[this.apiSource]||AutoComplete_Bd;return this.apiSource===API_SOURCE_BAIDU&&AutoComplete_Bd.create?AutoComplete_Bd.create(e):new t(e)}_bindEvents(){this._ac.addEventListener("searchComplete",(e=>{this.dispatchEvent({type:"searchComplete",results:e.results,keyword:e.keyword,target:this})})),this._ac.addEventListener("error",(e=>{this.dispatchEvent({type:"error",message:e.message,target:this})})),this._ac.addEventListener("needData",(e=>{this.dispatchEvent({type:"needData",keyword:e.keyword,target:this})}))}initialize(){return this._isInitialized||(this._ac.initialize(),this._bindEvents(),this._isInitialized=!0),this}setPickValue(e){this._ac.setPickValue(e)}search(e){return this._ac.search&&this._ac.search(e),this}setTypes(e){return this._ac.setTypes&&this._ac.setTypes(e),this}getResults(){return this._ac.getResults?this._ac.getResults():null}dispose(){this._ac&&(this._ac.dispose(),this._ac=null),this._isInitialized=!1}getInstance(){return this._ac}}const Taiwanboundary=[[[119.590757,23.808251],[119.268804,23.41408],[119.422881,23.163397],[119.758632,23.201668],[119.726437,23.588002],[119.70804,23.763808],[119.645949,23.797671]],[[121.642055,25.312114],[121.752439,25.169879],[121.945611,25.186621],[121.991604,25.052618],[122.055995,24.985561],[121.872022,24.834547],[121.88122,24.624496],[121.899617,24.498294],[121.798432,24.270807],[121.697247,24.135805],[121.642055,23.958396],[121.504076,23.288798],[121.439685,23.178281],[121.310904,22.991042],[121.255712,22.812068],[121.053342,22.624316],[120.933759,22.290847],[121.016547,21.990891],[120.86017,21.887901],[120.648601,21.947988],[120.584211,22.376429],[120.289854,22.51325],[120.11508,22.939931],[120.013895,23.118734],[119.9771,23.543483],[120.372642,24.11892],[120.694595,24.641313],[121.126931,25.119638],[121.559268,25.337197],[121.623658,25.345557]],[[120.38414,22.372151],[120.423234,22.355038],[120.372642,22.307967],[120.347346,22.329365],[120.351945,22.355038],[120.356544,22.363595]],[[121.506375,22.696888],[121.552369,22.660607],[121.517874,22.611506],[121.469581,22.64353],[121.464981,22.690486],[121.492577,22.701155]],[[121.589163,22.100236],[121.600661,22.050934],[121.623658,22.012338],[121.637456,21.939406],[121.596062,21.93726],[121.550069,22.014483],[121.499476,22.044502],[121.501776,22.102379],[121.54087,22.102379]],[[122.08819,25.668005],[122.110037,25.488627],[121.911116,25.435387],[122.027249,25.658625],[122.057144,25.669047]],[[123.686455,25.955273],[123.730149,25.909524],[123.58527,25.699264],[123.454189,25.743012],[123.557674,25.817972],[123.594468,25.84711]],[[124.589072,25.924082],[124.60172,25.894964],[124.564926,25.902244],[124.567226,25.929282],[124.571825,25.930321]],[[115.973388,21.36321],[116.152762,21.298566],[116.152762,21.164878],[116.148163,21.039704],[116.056176,21.000836],[115.863004,21.035386],[115.835409,21.143304],[115.830809,21.26839],[115.844607,21.358902],[115.922796,21.36321]],[[118.474702,24.527161],[118.4862,24.509276],[118.491949,24.487706],[118.498848,24.46771],[118.501148,24.448764],[118.501148,24.435079],[118.492524,24.422972],[118.481026,24.411916],[118.467228,24.406125],[118.443082,24.39928],[118.41721,24.386643],[118.378116,24.379797],[118.314301,24.369264],[118.28728,24.371898],[118.247035,24.378217],[118.230363,24.377164],[118.202192,24.376111],[118.182645,24.375584],[118.167122,24.375584],[118.159073,24.378744],[118.156199,24.389802],[118.160223,24.397174],[118.167697,24.407178],[118.17862,24.424024],[118.194718,24.434026],[118.210241,24.444027],[118.232088,24.457185],[118.254509,24.472972],[118.275206,24.488232],[118.289579,24.497702],[118.316025,24.506646],[118.35052,24.521375],[118.368918,24.529791],[118.386165,24.537154],[118.405137,24.540836],[118.425834,24.543465],[118.449981,24.541888],[118.460904,24.53768]]];class Boundary_Bd{constructor(e={}){this.options=e}_isBohai(e){return e.lng>=117.546263&&e.lng<=118.711042&&e.lat>=38.697981&&e.lat<=38.91302}_isMacao(e){return e.lng>=113.576516&&e.lng<=113.638822&&e.lat>=22.146067&&e.lat<=22.156645}_dealHainan(e,t,i,n){e.lng>109&&e.lng<113&&e.lat>15&&e.lat<19&&(e.lng-t.lng>1&&e.lat-t.lat<-1&&(n.hainanLine=!0,n.hainanIndexA=i/2),e.lng-t.lng<-1&&e.lat-t.lat>1&&(n.hainanLine=!0,n.hainanIndexB=i/2))}_processCoordinateRecord(e,t){const i=e.length-1,n=[],r={hainanLine:!1,hainanIndexA:0,hainanIndexB:0};for(let s=0;s<i;s+=2){const a=e[s],o=e[s+1],l=MercatorProjection.convertMC2LL({lng:a,lat:o});let c=null;if(s<i-3){const t=e[s+2],i=e[s+3];c=MercatorProjection.convertMC2LL({lng:t,lat:i})}if(t.indexOf("全国")>-1||t.indexOf("中国")>-1||t.indexOf("中华人民共和国")>-1){if(this._isBohai(l)||this._isMacao(l))return[];c&&this._dealHainan(l,c,s,r)}t.indexOf("海南")>-1&&c&&this._dealHainan(l,c,s,r),n.push([Number(l.lng),Number(l.lat)])}return r.hainanLine?this._splitHainanBoundary(n,r):n.length>0?[n]:[]}_splitHainanBoundary(e,t){let{hainanIndexA:i,hainanIndexB:n}=t;if(i>n){const e=i;i=n,n=e}const r=e,s=e.splice(i+1),a=s.splice(n-i);return r.push(...a),[r,s]}get(e,t){const i={boundaries:[]};if(!["中国","全国","中华人民共和国"].includes(e)){if("台湾省"===e||"台湾"===e){for(let e=0;e<6;e++)i.boundaries[e]=Taiwanboundary[e];return i.boundaries[6]=Taiwanboundary[9],void(t&&t(i))}return"钓鱼岛"===e?(i.boundaries[0]=Taiwanboundary[6],void(t&&t(i))):"赤尾屿"===e?(i.boundaries[0]=Taiwanboundary[7],void(t&&t(i))):void SearchRequestMgr.request({qt:QUERY_TYPE_POI_SEARCH,wd:e}).then((n=>{if(!(n&&n.content&&n.content.uid||e))return void(t&&t(i));const r=n.content&&n.content.uid?n.content.uid:"";SearchRequestMgr.request({qt:QUERY_TYPE_EXT,num:1e3,l:10,uid:r,adname:e}).then((n=>{this._processBoundariesResponse(n,e,i),t&&t(i)}))}))}t&&t(i)}_processBoundariesResponse(e,t,i){if(!e||!e.content||!e.content.geo)return;const n=SUtil.parseGeo(e.content.geo,!1);if(n.geo&&0!==n.geo.length){for(const e of n.geo){if(!e||0===e.length)continue;const n=this._processCoordinateRecord(e,t);i.boundaries.push(...n)}if(("中国"===t||"全国"===t||"中华人民共和国"===t)&&i.boundaries.length>0){const e=i.boundaries.length;for(let t=0;t<Taiwanboundary.length-1;t++)i.boundaries[e+t]=Taiwanboundary[t]}}}toString(){return"Boundary_Bd"}}const http$3="https:"===location.protocol?"https":"http";class Boundary_Tdt{constructor(e={}){this.options=e}_parseWktBoundary(e){const t=wellknown.exports(e),i=[];return t?("Polygon"===t.type?t.coordinates.forEach((e=>{i.push(e.map((e=>[Number(e[0]),Number(e[1])])))})):"MultiPolygon"===t.type&&t.coordinates.forEach((e=>{e.forEach((e=>{i.push(e.map((e=>[Number(e[0]),Number(e[1])])))}))})),i):i}get(e,t){const i=`${http$3}://api.tianditu.gov.cn/v2/administrative?keyword=${encodeURIComponent(e)}&childLevel=0&extensions=true`;ScriptLoader.request(i).then((e=>{const i={boundaries:[]};e&&e.data&&e.data.length>0&&e.data.forEach((e=>{if(e.boundary){(Array.isArray(e.boundary)?e.boundary:[e.boundary]).forEach((e=>{const t=this._parseWktBoundary(e);i.boundaries.push(...t)}))}})),t&&t(i)})).catch((()=>{t&&t({boundaries:[]})}))}toString(){return"Boundary_Tdt"}}class Boundary{constructor(e={}){this.options=e,this.apiSource=e.apiSource||getApiSource(),this._boundary=this._createInstance(e)}_createInstance(e){return new({[API_SOURCE_BAIDU]:Boundary_Bd,[API_SOURCE_TIANDITU]:Boundary_Tdt}[this.apiSource]||Boundary_Bd)(e)}get(e,t){return this._boundary.get(e,t)}toString(){return"Boundary"}}class DistrictLayer_Bd{constructor(e={}){this.options={...e},this._map=null,this._layer=null,this._data=null}setOptions(e){this.options={...this.options,...e}}setName(e){this.options.name=e}setKind(e){this.options.kind=e}async _loadDistrict(){var e;const t=this.options.name||"",i=null!=(e=this.options.kind)?e:0,n=await SearchRequestMgr.request({qt:QUERY_TYPE_EXTS,adnames:t,level:i}),r=this._parseGeoData(n);return this.geojsonCoordConvert(r),this._data=r,r}_parseGeoData(e){let t={type:"FeatureCollection",features:[]};if(e&&e.content&&e.content.geometry){let i=e.content.geometry;for(let e=0;e<i.length;e++){let n=i[e],r=n.slice(6,8);n=n.slice(8,n.length)+r,n=atob(n),n=wellknown.exports(n);let s={type:"Feature",geometry:n,properties:{index:e}};t.features.push(s)}}return t}geojsonCoordConvert(e){let t=this.options.kind||0;for(let i=0;i<e.features.length;i++){let n=e.features[i];1===t&&0===i&&(n.geometry.coordinates=n.geometry.coordinates.filter(((e,t)=>0!==t)));const r=n.geometry.coordinates.length;for(let e=0;e<r;e++){const t=n.geometry.coordinates[e];n.geometry.coordinates[e]=t.map((e=>e.map((e=>{const t=MercatorProjection.convertMC2LL({lng:e[0],lat:e[1]});return[Number(t.lng),Number(t.lat)]}))))}}}geojson2boundaries(e){let t={boundaries:[]},i=0;for(let n=0;n<e.features.length;n++){i+=e.features[n].geometry.coordinates.length;for(let i=0;i<e.features[n].geometry.coordinates.length;i++){let r=e.features[n].geometry.coordinates[i];const s=[];for(let e=0;e<r[0].length;e++){const t=MercatorProjection.convertMC2LL({lng:r[0][e][0],lat:r[0][e][1]});s.push([t.lng,t.lat])}t.boundaries.push(s)}}return t}searchBoundary(e,t){const i=e.name||this.options.name||"",n=e.kind||this.options.kind||0;SearchRequestMgr.request({qt:QUERY_TYPE_EXTS,adnames:i,level:n}).then((e=>{const i=this._parseGeoData(e),n=this.geojson2boundaries(i);t&&t(n)}))}}const http$2="https:"===location.protocol?"https":"http";class DistrictLayer_Tdt{constructor(e={}){this.options={...e},this._data=null}setOptions(e){this.options={...this.options,...e}}setName(e){this.options.name=e}setKind(e){this.options.kind=e}async _loadDistrict(){var e;const t=this.options.name||"",i=null!=(e=this.options.kind)?e:0,n=await this._requestDistrictData(t,i),r=this._parseGeoData(n);return this.geojsonCoordConvert(r),this._data=r,r}async _requestDistrictData(e,t){const i=`${http$2}://api.tianditu.gov.cn/v2/administrative?keyword=${encodeURIComponent(e)}&childLevel=${t}&extensions=true`;try{return await ScriptLoader.request(i)}catch(n){return console.error("天地图行政区划请求失败:",n),{data:[]}}}_parseGeoData(e){let t={type:"FeatureCollection",features:[]};return e&&e.data&&e.data.length>0&&e.data.forEach(((e,i)=>{if(e.boundary){(Array.isArray(e.boundary)?e.boundary:[e.boundary]).forEach((n=>{const r=wellknown.exports(n);if(r){let n={type:"Feature",geometry:r,properties:{index:i,name:e.name||""}};t.features.push(n)}}))}})),t}geojsonCoordConvert(e){for(let t=0;t<e.features.length;t++){let i=e.features[t];i.geometry&&i.geometry.coordinates&&("Polygon"===i.geometry.type?i.geometry.coordinates=i.geometry.coordinates.map((e=>e.map((e=>[Number(e[0]),Number(e[1])])))):"MultiPolygon"===i.geometry.type&&(i.geometry.coordinates=i.geometry.coordinates.map((e=>e.map((e=>e.map((e=>[Number(e[0]),Number(e[1])]))))))))}}geojson2boundaries(e){let t={boundaries:[]};for(let i=0;i<e.features.length;i++){let n=e.features[i];n.geometry&&n.geometry.coordinates&&("Polygon"===n.geometry.type?n.geometry.coordinates.forEach((e=>{t.boundaries.push(e)})):"MultiPolygon"===n.geometry.type&&n.geometry.coordinates.forEach((e=>{e.forEach((e=>{t.boundaries.push(e)}))})))}return t}searchBoundary(e,t){const i=e.name||this.options.name||"",n=e.kind||this.options.kind||0;this._requestDistrictData(i,n).then((e=>{const i=this._parseGeoData(e),n=this.geojson2boundaries(i);t&&t(n)}))}}var earcut$1={exports:{}};function earcut(e,t,i){i=i||2;var n,r,s,a,o,l,c,h=t&&t.length,u=h?t[0]*i:e.length,d=linkedList(e,0,u,i,!0),p=[];if(!d||d.next===d.prev)return p;if(h&&(d=eliminateHoles(e,t,d,i)),e.length>80*i){n=s=e[0],r=a=e[1];for(var m=i;m<u;m+=i)(o=e[m])<n&&(n=o),(l=e[m+1])<r&&(r=l),o>s&&(s=o),l>a&&(a=l);c=0!==(c=Math.max(s-n,a-r))?32767/c:0}return earcutLinked(d,p,i,n,r,c,0),p}function linkedList(e,t,i,n,r){var s,a;if(r===signedArea(e,t,i,n)>0)for(s=t;s<i;s+=n)a=insertNode(s,e[s],e[s+1],a);else for(s=i-n;s>=t;s-=n)a=insertNode(s,e[s],e[s+1],a);return a&&equals(a,a.next)&&(removeNode(a),a=a.next),a}function filterPoints(e,t){if(!e)return e;t||(t=e);var i,n=e;do{if(i=!1,n.steiner||!equals(n,n.next)&&0!==area(n.prev,n,n.next))n=n.next;else{if(removeNode(n),(n=t=n.prev)===n.next)break;i=!0}}while(i||n!==t);return t}function earcutLinked(e,t,i,n,r,s,a){if(e){!a&&s&&indexCurve(e,n,r,s);for(var o,l,c=e;e.prev!==e.next;)if(o=e.prev,l=e.next,s?isEarHashed(e,n,r,s):isEar(e))t.push(o.i/i|0),t.push(e.i/i|0),t.push(l.i/i|0),removeNode(e),e=l.next,c=l.next;else if((e=l)===c){a?1===a?earcutLinked(e=cureLocalIntersections(filterPoints(e),t,i),t,i,n,r,s,2):2===a&&splitEarcut(e,t,i,n,r,s):earcutLinked(filterPoints(e),t,i,n,r,s,1);break}}}function isEar(e){var t=e.prev,i=e,n=e.next;if(area(t,i,n)>=0)return!1;for(var r=t.x,s=i.x,a=n.x,o=t.y,l=i.y,c=n.y,h=r<s?r<a?r:a:s<a?s:a,u=o<l?o<c?o:c:l<c?l:c,d=r>s?r>a?r:a:s>a?s:a,p=o>l?o>c?o:c:l>c?l:c,m=n.next;m!==t;){if(m.x>=h&&m.x<=d&&m.y>=u&&m.y<=p&&pointInTriangle(r,o,s,l,a,c,m.x,m.y)&&area(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function isEarHashed(e,t,i,n){var r=e.prev,s=e,a=e.next;if(area(r,s,a)>=0)return!1;for(var o=r.x,l=s.x,c=a.x,h=r.y,u=s.y,d=a.y,p=o<l?o<c?o:c:l<c?l:c,m=h<u?h<d?h:d:u<d?u:d,f=o>l?o>c?o:c:l>c?l:c,g=h>u?h>d?h:d:u>d?u:d,_=zOrder(p,m,t,i,n),A=zOrder(f,g,t,i,n),v=e.prevZ,y=e.nextZ;v&&v.z>=_&&y&&y.z<=A;){if(v.x>=p&&v.x<=f&&v.y>=m&&v.y<=g&&v!==r&&v!==a&&pointInTriangle(o,h,l,u,c,d,v.x,v.y)&&area(v.prev,v,v.next)>=0)return!1;if(v=v.prevZ,y.x>=p&&y.x<=f&&y.y>=m&&y.y<=g&&y!==r&&y!==a&&pointInTriangle(o,h,l,u,c,d,y.x,y.y)&&area(y.prev,y,y.next)>=0)return!1;y=y.nextZ}for(;v&&v.z>=_;){if(v.x>=p&&v.x<=f&&v.y>=m&&v.y<=g&&v!==r&&v!==a&&pointInTriangle(o,h,l,u,c,d,v.x,v.y)&&area(v.prev,v,v.next)>=0)return!1;v=v.prevZ}for(;y&&y.z<=A;){if(y.x>=p&&y.x<=f&&y.y>=m&&y.y<=g&&y!==r&&y!==a&&pointInTriangle(o,h,l,u,c,d,y.x,y.y)&&area(y.prev,y,y.next)>=0)return!1;y=y.nextZ}return!0}function cureLocalIntersections(e,t,i){var n=e;do{var r=n.prev,s=n.next.next;!equals(r,s)&&intersects(r,n,n.next,s)&&locallyInside(r,s)&&locallyInside(s,r)&&(t.push(r.i/i|0),t.push(n.i/i|0),t.push(s.i/i|0),removeNode(n),removeNode(n.next),n=e=s),n=n.next}while(n!==e);return filterPoints(n)}function splitEarcut(e,t,i,n,r,s){var a=e;do{for(var o=a.next.next;o!==a.prev;){if(a.i!==o.i&&isValidDiagonal(a,o)){var l=splitPolygon(a,o);return a=filterPoints(a,a.next),l=filterPoints(l,l.next),earcutLinked(a,t,i,n,r,s,0),void earcutLinked(l,t,i,n,r,s,0)}o=o.next}a=a.next}while(a!==e)}function eliminateHoles(e,t,i,n){var r,s,a,o=[];for(r=0,s=t.length;r<s;r++)(a=linkedList(e,t[r]*n,r<s-1?t[r+1]*n:e.length,n,!1))===a.next&&(a.steiner=!0),o.push(getLeftmost(a));for(o.sort(compareX),r=0;r<o.length;r++)i=eliminateHole(o[r],i);return i}function compareX(e,t){return e.x-t.x}function eliminateHole(e,t){var i=findHoleBridge(e,t);if(!i)return t;var n=splitPolygon(i,e);return filterPoints(n,n.next),filterPoints(i,i.next)}function findHoleBridge(e,t){var i,n=t,r=e.x,s=e.y,a=-1/0;do{if(s<=n.y&&s>=n.next.y&&n.next.y!==n.y){var o=n.x+(s-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(o<=r&&o>a&&(a=o,i=n.x<n.next.x?n:n.next,o===r))return i}n=n.next}while(n!==t);if(!i)return null;var l,c=i,h=i.x,u=i.y,d=1/0;n=i;do{r>=n.x&&n.x>=h&&r!==n.x&&pointInTriangle(s<u?r:a,s,h,u,s<u?a:r,s,n.x,n.y)&&(l=Math.abs(s-n.y)/(r-n.x),locallyInside(n,e)&&(l<d||l===d&&(n.x>i.x||n.x===i.x&&sectorContainsSector(i,n)))&&(i=n,d=l)),n=n.next}while(n!==c);return i}function sectorContainsSector(e,t){return area(e.prev,e,t.prev)<0&&area(t.next,e,e.next)<0}function indexCurve(e,t,i,n){var r=e;do{0===r.z&&(r.z=zOrder(r.x,r.y,t,i,n)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==e);r.prevZ.nextZ=null,r.prevZ=null,sortLinked(r)}function sortLinked(e){var t,i,n,r,s,a,o,l,c=1;do{for(i=e,e=null,s=null,a=0;i;){for(a++,n=i,o=0,t=0;t<c&&(o++,n=n.nextZ);t++);for(l=c;o>0||l>0&&n;)0!==o&&(0===l||!n||i.z<=n.z)?(r=i,i=i.nextZ,o--):(r=n,n=n.nextZ,l--),s?s.nextZ=r:e=r,r.prevZ=s,s=r;i=n}s.nextZ=null,c*=2}while(a>1);return e}function zOrder(e,t,i,n,r){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-i)*r|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*r|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function getLeftmost(e){var t=e,i=e;do{(t.x<i.x||t.x===i.x&&t.y<i.y)&&(i=t),t=t.next}while(t!==e);return i}function pointInTriangle(e,t,i,n,r,s,a,o){return(r-a)*(t-o)>=(e-a)*(s-o)&&(e-a)*(n-o)>=(i-a)*(t-o)&&(i-a)*(s-o)>=(r-a)*(n-o)}function isValidDiagonal(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!intersectsPolygon(e,t)&&(locallyInside(e,t)&&locallyInside(t,e)&&middleInside(e,t)&&(area(e.prev,e,t.prev)||area(e,t.prev,t))||equals(e,t)&&area(e.prev,e,e.next)>0&&area(t.prev,t,t.next)>0)}function area(e,t,i){return(t.y-e.y)*(i.x-t.x)-(t.x-e.x)*(i.y-t.y)}function equals(e,t){return e.x===t.x&&e.y===t.y}function intersects(e,t,i,n){var r=sign(area(e,t,i)),s=sign(area(e,t,n)),a=sign(area(i,n,e)),o=sign(area(i,n,t));return r!==s&&a!==o||(!(0!==r||!onSegment(e,i,t))||(!(0!==s||!onSegment(e,n,t))||(!(0!==a||!onSegment(i,e,n))||!(0!==o||!onSegment(i,t,n)))))}function onSegment(e,t,i){return t.x<=Math.max(e.x,i.x)&&t.x>=Math.min(e.x,i.x)&&t.y<=Math.max(e.y,i.y)&&t.y>=Math.min(e.y,i.y)}function sign(e){return e>0?1:e<0?-1:0}function intersectsPolygon(e,t){var i=e;do{if(i.i!==e.i&&i.next.i!==e.i&&i.i!==t.i&&i.next.i!==t.i&&intersects(i,i.next,e,t))return!0;i=i.next}while(i!==e);return!1}function locallyInside(e,t){return area(e.prev,e,e.next)<0?area(e,t,e.next)>=0&&area(e,e.prev,t)>=0:area(e,t,e.prev)<0||area(e,e.next,t)<0}function middleInside(e,t){var i=e,n=!1,r=(e.x+t.x)/2,s=(e.y+t.y)/2;do{i.y>s!=i.next.y>s&&i.next.y!==i.y&&r<(i.next.x-i.x)*(s-i.y)/(i.next.y-i.y)+i.x&&(n=!n),i=i.next}while(i!==e);return n}function splitPolygon(e,t){var i=new Node(e.i,e.x,e.y),n=new Node(t.i,t.x,t.y),r=e.next,s=t.prev;return e.next=t,t.prev=e,i.next=r,r.prev=i,n.next=i,i.prev=n,s.next=n,n.prev=s,n}function insertNode(e,t,i,n){var r=new Node(e,t,i);return n?(r.next=n.next,r.prev=n,n.next.prev=r,n.next=r):(r.prev=r,r.next=r),r}function removeNode(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Node(e,t,i){this.i=e,this.x=t,this.y=i,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(e,t,i,n){for(var r=0,s=t,a=i-n;s<i;s+=n)r+=(e[a]-e[s])*(e[s+1]+e[a+1]),a=s;return r}function ge(e,t,i,n,r){for(var s=r+1;n<=r;){var a=n+r>>>1,o=e[a];(void 0!==i?i(o,t):o-t)>=0?(s=a,r=a-1):n=a+1}return s}function gt(e,t,i,n,r){for(var s=r+1;n<=r;){var a=n+r>>>1,o=e[a];(void 0!==i?i(o,t):o-t)>0?(s=a,r=a-1):n=a+1}return s}function lt(e,t,i,n,r){for(var s=n-1;n<=r;){var a=n+r>>>1,o=e[a];(void 0!==i?i(o,t):o-t)<0?(s=a,n=a+1):r=a-1}return s}function le(e,t,i,n,r){for(var s=n-1;n<=r;){var a=n+r>>>1,o=e[a];(void 0!==i?i(o,t):o-t)<=0?(s=a,n=a+1):r=a-1}return s}function eq(e,t,i,n,r){for(;n<=r;){var s=n+r>>>1,a=e[s],o=void 0!==i?i(a,t):a-t;if(0===o)return s;o<=0?n=s+1:r=s-1}return-1}function norm(e,t,i,n,r,s){return"function"==typeof i?s(e,t,i,void 0===n?0:0|n,void 0===r?e.length-1:0|r):s(e,t,void 0,void 0===i?0:0|i,void 0===n?e.length-1:0|n)}earcut$1.exports=earcut,earcut$1.exports.default=earcut,earcut.deviation=function(e,t,i,n){var r=t&&t.length,s=r?t[0]*i:e.length,a=Math.abs(signedArea(e,0,s,i));if(r)for(var o=0,l=t.length;o<l;o++){var c=t[o]*i,h=o<l-1?t[o+1]*i:e.length;a-=Math.abs(signedArea(e,c,h,i))}var u=0;for(o=0;o<n.length;o+=3){var d=n[o]*i,p=n[o+1]*i,m=n[o+2]*i;u+=Math.abs((e[d]-e[m])*(e[p+1]-e[d+1])-(e[d]-e[p])*(e[m+1]-e[d+1]))}return 0===a&&0===u?0:Math.abs((u-a)/a)},earcut.flatten=function(e){for(var t=e[0][0].length,i={vertices:[],holes:[],dimensions:t},n=0,r=0;r<e.length;r++){for(var s=0;s<e[r].length;s++)for(var a=0;a<t;a++)i.vertices.push(e[r][s][a]);r>0&&(n+=e[r-1].length,i.holes.push(n))}return i};var searchBounds={ge:function(e,t,i,n,r){return norm(e,t,i,n,r,ge)},gt:function(e,t,i,n,r){return norm(e,t,i,n,r,gt)},lt:function(e,t,i,n,r){return norm(e,t,i,n,r,lt)},le:function(e,t,i,n,r){return norm(e,t,i,n,r,le)},eq:function(e,t,i,n,r){return norm(e,t,i,n,r,eq)}},orientation={exports:{}},twoProduct_1=twoProduct$1,SPLITTER=+(Math.pow(2,27)+1);function twoProduct$1(e,t,i){var n=e*t,r=SPLITTER*e,s=r-(r-e),a=e-s,o=SPLITTER*t,l=o-(o-t),c=t-l,h=a*c-(n-s*l-a*l-s*c);return i?(i[0]=h,i[1]=n,i):[h,n]}var robustSum=linearExpansionSum;function scalarScalar$1(e,t){var i=e+t,n=i-e,r=e-(i-n)+(t-n);return r?[r,i]:[i]}function linearExpansionSum(e,t){var i=0|e.length,n=0|t.length;if(1===i&&1===n)return scalarScalar$1(e[0],t[0]);var r,s,a=new Array(i+n),o=0,l=0,c=0,h=Math.abs,u=e[l],d=h(u),p=t[c],m=h(p);d<m?(s=u,(l+=1)<i&&(d=h(u=e[l]))):(s=p,(c+=1)<n&&(m=h(p=t[c]))),l<i&&d<m||c>=n?(r=u,(l+=1)<i&&(d=h(u=e[l]))):(r=p,(c+=1)<n&&(m=h(p=t[c])));for(var f,g,_=r+s,A=_-r,v=s-A,y=v,x=_;l<i&&c<n;)d<m?(r=u,(l+=1)<i&&(d=h(u=e[l]))):(r=p,(c+=1)<n&&(m=h(p=t[c]))),(v=(s=y)-(A=(_=r+s)-r))&&(a[o++]=v),y=x-((f=x+_)-(g=f-x))+(_-g),x=f;for(;l<i;)(v=(s=y)-(A=(_=(r=u)+s)-r))&&(a[o++]=v),y=x-((f=x+_)-(g=f-x))+(_-g),x=f,(l+=1)<i&&(u=e[l]);for(;c<n;)(v=(s=y)-(A=(_=(r=p)+s)-r))&&(a[o++]=v),y=x-((f=x+_)-(g=f-x))+(_-g),x=f,(c+=1)<n&&(p=t[c]);return y&&(a[o++]=y),x&&(a[o++]=x),o||(a[o++]=0),a.length=o,a}var twoSum$1=fastTwoSum;function fastTwoSum(e,t,i){var n=e+t,r=n-e,s=t-r,a=e-(n-r);return i?(i[0]=a+s,i[1]=n,i):[a+s,n]}var twoProduct=twoProduct_1,twoSum=twoSum$1,robustScale=scaleLinearExpansion;function scaleLinearExpansion(e,t){var i=e.length;if(1===i){var n=twoProduct(e[0],t);return n[0]?n:[n[1]]}var r=new Array(2*i),s=[.1,.1],a=[.1,.1],o=0;twoProduct(e[0],t,s),s[0]&&(r[o++]=s[0]);for(var l=1;l<i;++l){twoProduct(e[l],t,a);var c=s[1];twoSum(c,a[0],s),s[0]&&(r[o++]=s[0]);var h=a[1],u=s[1],d=h+u,p=u-(d-h);s[1]=d,p&&(r[o++]=p)}return s[1]&&(r[o++]=s[1]),0===o&&(r[o++]=0),r.length=o,r}var robustDiff=robustSubtract;function scalarScalar(e,t){var i=e+t,n=i-e,r=e-(i-n)+(t-n);return r?[r,i]:[i]}function robustSubtract(e,t){var i=0|e.length,n=0|t.length;if(1===i&&1===n)return scalarScalar(e[0],-t[0]);var r,s,a=new Array(i+n),o=0,l=0,c=0,h=Math.abs,u=e[l],d=h(u),p=-t[c],m=h(p);d<m?(s=u,(l+=1)<i&&(d=h(u=e[l]))):(s=p,(c+=1)<n&&(m=h(p=-t[c]))),l<i&&d<m||c>=n?(r=u,(l+=1)<i&&(d=h(u=e[l]))):(r=p,(c+=1)<n&&(m=h(p=-t[c])));for(var f,g,_=r+s,A=_-r,v=s-A,y=v,x=_;l<i&&c<n;)d<m?(r=u,(l+=1)<i&&(d=h(u=e[l]))):(r=p,(c+=1)<n&&(m=h(p=-t[c]))),(v=(s=y)-(A=(_=r+s)-r))&&(a[o++]=v),y=x-((f=x+_)-(g=f-x))+(_-g),x=f;for(;l<i;)(v=(s=y)-(A=(_=(r=u)+s)-r))&&(a[o++]=v),y=x-((f=x+_)-(g=f-x))+(_-g),x=f,(l+=1)<i&&(u=e[l]);for(;c<n;)(v=(s=y)-(A=(_=(r=p)+s)-r))&&(a[o++]=v),y=x-((f=x+_)-(g=f-x))+(_-g),x=f,(c+=1)<n&&(p=-t[c]);return y&&(a[o++]=y),x&&(a[o++]=x),o||(a[o++]=0),a.length=o,a}!function(e){var t=twoProduct_1,i=robustSum,n=robustScale,r=robustDiff;function s(e,t,i,n){return function(i,r,s){var a=e(e(t(r[1],s[0]),t(-s[1],r[0])),e(t(i[1],r[0]),t(-r[1],i[0]))),o=e(t(i[1],s[0]),t(-s[1],i[0])),l=n(a,o);return l[l.length-1]}}function a(e,t,i,n){return function(r,s,a,o){var l=e(e(i(e(t(a[1],o[0]),t(-o[1],a[0])),s[2]),e(i(e(t(s[1],o[0]),t(-o[1],s[0])),-a[2]),i(e(t(s[1],a[0]),t(-a[1],s[0])),o[2]))),e(i(e(t(s[1],o[0]),t(-o[1],s[0])),r[2]),e(i(e(t(r[1],o[0]),t(-o[1],r[0])),-s[2]),i(e(t(r[1],s[0]),t(-s[1],r[0])),o[2])))),c=e(e(i(e(t(a[1],o[0]),t(-o[1],a[0])),r[2]),e(i(e(t(r[1],o[0]),t(-o[1],r[0])),-a[2]),i(e(t(r[1],a[0]),t(-a[1],r[0])),o[2]))),e(i(e(t(s[1],a[0]),t(-a[1],s[0])),r[2]),e(i(e(t(r[1],a[0]),t(-a[1],r[0])),-s[2]),i(e(t(r[1],s[0]),t(-s[1],r[0])),a[2])))),h=n(l,c);return h[h.length-1]}}function o(e,t,i,n){return function(r,s,a,o,l){var c=e(e(e(i(e(i(e(t(o[1],l[0]),t(-l[1],o[0])),a[2]),e(i(e(t(a[1],l[0]),t(-l[1],a[0])),-o[2]),i(e(t(a[1],o[0]),t(-o[1],a[0])),l[2]))),s[3]),e(i(e(i(e(t(o[1],l[0]),t(-l[1],o[0])),s[2]),e(i(e(t(s[1],l[0]),t(-l[1],s[0])),-o[2]),i(e(t(s[1],o[0]),t(-o[1],s[0])),l[2]))),-a[3]),i(e(i(e(t(a[1],l[0]),t(-l[1],a[0])),s[2]),e(i(e(t(s[1],l[0]),t(-l[1],s[0])),-a[2]),i(e(t(s[1],a[0]),t(-a[1],s[0])),l[2]))),o[3]))),e(i(e(i(e(t(a[1],o[0]),t(-o[1],a[0])),s[2]),e(i(e(t(s[1],o[0]),t(-o[1],s[0])),-a[2]),i(e(t(s[1],a[0]),t(-a[1],s[0])),o[2]))),-l[3]),e(i(e(i(e(t(o[1],l[0]),t(-l[1],o[0])),s[2]),e(i(e(t(s[1],l[0]),t(-l[1],s[0])),-o[2]),i(e(t(s[1],o[0]),t(-o[1],s[0])),l[2]))),r[3]),i(e(i(e(t(o[1],l[0]),t(-l[1],o[0])),r[2]),e(i(e(t(r[1],l[0]),t(-l[1],r[0])),-o[2]),i(e(t(r[1],o[0]),t(-o[1],r[0])),l[2]))),-s[3])))),e(e(i(e(i(e(t(s[1],l[0]),t(-l[1],s[0])),r[2]),e(i(e(t(r[1],l[0]),t(-l[1],r[0])),-s[2]),i(e(t(r[1],s[0]),t(-s[1],r[0])),l[2]))),o[3]),e(i(e(i(e(t(s[1],o[0]),t(-o[1],s[0])),r[2]),e(i(e(t(r[1],o[0]),t(-o[1],r[0])),-s[2]),i(e(t(r[1],s[0]),t(-s[1],r[0])),o[2]))),-l[3]),i(e(i(e(t(a[1],o[0]),t(-o[1],a[0])),s[2]),e(i(e(t(s[1],o[0]),t(-o[1],s[0])),-a[2]),i(e(t(s[1],a[0]),t(-a[1],s[0])),o[2]))),r[3]))),e(i(e(i(e(t(a[1],o[0]),t(-o[1],a[0])),r[2]),e(i(e(t(r[1],o[0]),t(-o[1],r[0])),-a[2]),i(e(t(r[1],a[0]),t(-a[1],r[0])),o[2]))),-s[3]),e(i(e(i(e(t(s[1],o[0]),t(-o[1],s[0])),r[2]),e(i(e(t(r[1],o[0]),t(-o[1],r[0])),-s[2]),i(e(t(r[1],s[0]),t(-s[1],r[0])),o[2]))),a[3]),i(e(i(e(t(s[1],a[0]),t(-a[1],s[0])),r[2]),e(i(e(t(r[1],a[0]),t(-a[1],r[0])),-s[2]),i(e(t(r[1],s[0]),t(-s[1],r[0])),a[2]))),-o[3]))))),h=e(e(e(i(e(i(e(t(o[1],l[0]),t(-l[1],o[0])),a[2]),e(i(e(t(a[1],l[0]),t(-l[1],a[0])),-o[2]),i(e(t(a[1],o[0]),t(-o[1],a[0])),l[2]))),r[3]),i(e(i(e(t(o[1],l[0]),t(-l[1],o[0])),r[2]),e(i(e(t(r[1],l[0]),t(-l[1],r[0])),-o[2]),i(e(t(r[1],o[0]),t(-o[1],r[0])),l[2]))),-a[3])),e(i(e(i(e(t(a[1],l[0]),t(-l[1],a[0])),r[2]),e(i(e(t(r[1],l[0]),t(-l[1],r[0])),-a[2]),i(e(t(r[1],a[0]),t(-a[1],r[0])),l[2]))),o[3]),i(e(i(e(t(a[1],o[0]),t(-o[1],a[0])),r[2]),e(i(e(t(r[1],o[0]),t(-o[1],r[0])),-a[2]),i(e(t(r[1],a[0]),t(-a[1],r[0])),o[2]))),-l[3]))),e(e(i(e(i(e(t(a[1],l[0]),t(-l[1],a[0])),s[2]),e(i(e(t(s[1],l[0]),t(-l[1],s[0])),-a[2]),i(e(t(s[1],a[0]),t(-a[1],s[0])),l[2]))),r[3]),i(e(i(e(t(a[1],l[0]),t(-l[1],a[0])),r[2]),e(i(e(t(r[1],l[0]),t(-l[1],r[0])),-a[2]),i(e(t(r[1],a[0]),t(-a[1],r[0])),l[2]))),-s[3])),e(i(e(i(e(t(s[1],l[0]),t(-l[1],s[0])),r[2]),e(i(e(t(r[1],l[0]),t(-l[1],r[0])),-s[2]),i(e(t(r[1],s[0]),t(-s[1],r[0])),l[2]))),a[3]),i(e(i(e(t(s[1],a[0]),t(-a[1],s[0])),r[2]),e(i(e(t(r[1],a[0]),t(-a[1],r[0])),-s[2]),i(e(t(r[1],s[0]),t(-s[1],r[0])),a[2]))),-l[3])))),u=n(c,h);return u[u.length-1]}}function l(e){return(3===e?s:4===e?a:o)(i,t,n,r)}var c=l(3),h=l(4),u=[function(){return 0},function(){return 0},function(e,t){return t[0]-e[0]},function(e,t,i){var n,r=(e[1]-i[1])*(t[0]-i[0]),s=(e[0]-i[0])*(t[1]-i[1]),a=r-s;if(r>0){if(s<=0)return a;n=r+s}else{if(!(r<0))return a;if(s>=0)return a;n=-(r+s)}var o=33306690738754716e-32*n;return a>=o||a<=-o?a:c(e,t,i)},function(e,t,i,n){var r=e[0]-n[0],s=t[0]-n[0],a=i[0]-n[0],o=e[1]-n[1],l=t[1]-n[1],c=i[1]-n[1],u=e[2]-n[2],d=t[2]-n[2],p=i[2]-n[2],m=s*c,f=a*l,g=a*o,_=r*c,A=r*l,v=s*o,y=u*(m-f)+d*(g-_)+p*(A-v),x=7771561172376103e-31*((Math.abs(m)+Math.abs(f))*Math.abs(u)+(Math.abs(g)+Math.abs(_))*Math.abs(d)+(Math.abs(A)+Math.abs(v))*Math.abs(p));return y>x||-y>x?y:h(e,t,i,n)}];function d(e){var t=u[e.length];return t||(t=u[e.length]=l(e.length)),t.apply(void 0,e)}function p(e,t,i,n,r,s,a){return function(t,i,o,l,c){switch(arguments.length){case 0:case 1:return 0;case 2:return n(t,i);case 3:return r(t,i,o);case 4:return s(t,i,o,l);case 5:return a(t,i,o,l,c)}for(var h=new Array(arguments.length),u=0;u<arguments.length;++u)h[u]=arguments[u];return e(h)}}!function(){for(;u.length<=5;)u.push(l(u.length));e.exports=p.apply(void 0,[d].concat(u));for(var t=0;t<=5;++t)e.exports[t]=u[t]}()}(orientation);var bsearch$2=searchBounds,orient=orientation.exports[3],EVENT_POINT=0,EVENT_END=1,EVENT_START=2,monotone=monotoneTriangulate$1;function PartialHull(e,t,i,n,r){this.a=e,this.b=t,this.idx=i,this.lowerIds=n,this.upperIds=r}function Event(e,t,i,n){this.a=e,this.b=t,this.type=i,this.idx=n}function compareEvent(e,t){var i=e.a[0]-t.a[0]||e.a[1]-t.a[1]||e.type-t.type;return i||(e.type!==EVENT_POINT&&(i=orient(e.a,e.b,t.b))?i:e.idx-t.idx)}function testPoint(e,t){return orient(e.a,e.b,t)}function addPoint(e,t,i,n,r){for(var s=bsearch$2.lt(t,n,testPoint),a=bsearch$2.gt(t,n,testPoint),o=s;o<a;++o){for(var l=t[o],c=l.lowerIds,h=c.length;h>1&&orient(i[c[h-2]],i[c[h-1]],n)>0;)e.push([c[h-1],c[h-2],r]),h-=1;c.length=h,c.push(r);var u=l.upperIds;for(h=u.length;h>1&&orient(i[u[h-2]],i[u[h-1]],n)<0;)e.push([u[h-2],u[h-1],r]),h-=1;u.length=h,u.push(r)}}function findSplit(e,t){var i;return(i=e.a[0]<t.a[0]?orient(e.a,e.b,t.a):orient(t.b,t.a,e.a))?i:(i=t.b[0]<e.b[0]?orient(e.a,e.b,t.b):orient(t.b,t.a,e.b))||e.idx-t.idx}function splitHulls(e,t,i){var n=bsearch$2.le(e,i,findSplit),r=e[n],s=r.upperIds,a=s[s.length-1];r.upperIds=[a],e.splice(n+1,0,new PartialHull(i.a,i.b,i.idx,[a],s))}function mergeHulls(e,t,i){var n=i.a;i.a=i.b,i.b=n;var r=bsearch$2.eq(e,i,findSplit),s=e[r];e[r-1].upperIds=s.upperIds,e.splice(r,1)}function monotoneTriangulate$1(e,t){for(var i=e.length,n=t.length,r=[],s=0;s<i;++s)r.push(new Event(e[s],null,EVENT_POINT,s));for(s=0;s<n;++s){var a=t[s],o=e[a[0]],l=e[a[1]];o[0]<l[0]?r.push(new Event(o,l,EVENT_START,s),new Event(l,o,EVENT_END,s)):o[0]>l[0]&&r.push(new Event(l,o,EVENT_START,s),new Event(o,l,EVENT_END,s))}r.sort(compareEvent);for(var c=r[0].a[0]-(1+Math.abs(r[0].a[0]))*Math.pow(2,-52),h=[new PartialHull([c,1],[c,0],-1,[],[])],u=[],d=(s=0,r.length);s<d;++s){var p=r[s],m=p.type;m===EVENT_POINT?addPoint(u,h,e,p.a,p.idx):m===EVENT_START?splitHulls(h,e,p):mergeHulls(h,e,p)}return u}var bsearch$1=searchBounds,triangulation=createTriangulation;function Triangulation(e,t){this.stars=e,this.edges=t}var proto$1=Triangulation.prototype;function removePair(e,t,i){for(var n=1,r=e.length;n<r;n+=2)if(e[n-1]===t&&e[n]===i)return e[n-1]=e[r-2],e[n]=e[r-1],void(e.length=r-2)}function createTriangulation(e,t){for(var i=new Array(e),n=0;n<e;++n)i[n]=[];return new Triangulation(i,t)}proto$1.isConstraint=function(){var e=[0,0];function t(e,t){return e[0]-t[0]||e[1]-t[1]}return function(i,n){return e[0]=Math.min(i,n),e[1]=Math.max(i,n),bsearch$1.eq(this.edges,e,t)>=0}}(),proto$1.removeTriangle=function(e,t,i){var n=this.stars;removePair(n[e],t,i),removePair(n[t],i,e),removePair(n[i],e,t)},proto$1.addTriangle=function(e,t,i){var n=this.stars;n[e].push(t,i),n[t].push(i,e),n[i].push(e,t)},proto$1.opposite=function(e,t){for(var i=this.stars[t],n=1,r=i.length;n<r;n+=2)if(i[n]===e)return i[n-1];return-1},proto$1.flip=function(e,t){var i=this.opposite(e,t),n=this.opposite(t,e);this.removeTriangle(e,t,i),this.removeTriangle(t,e,n),this.addTriangle(e,n,i),this.addTriangle(t,i,n)},proto$1.edges=function(){for(var e=this.stars,t=[],i=0,n=e.length;i<n;++i)for(var r=e[i],s=0,a=r.length;s<a;s+=2)t.push([r[s],r[s+1]]);return t},proto$1.cells=function(){for(var e=this.stars,t=[],i=0,n=e.length;i<n;++i)for(var r=e[i],s=0,a=r.length;s<a;s+=2){var o=r[s],l=r[s+1];i<Math.min(o,l)&&t.push([i,o,l])}return t};var inSphere={exports:{}};!function(e){var t=twoProduct_1,i=robustSum,n=robustDiff,r=robustScale;function s(e){return(3===e?a:4===e?o:5===e?l:c)(i,n,t,r)}function a(e,t,i,n){return function(r,s,a){var o=i(r[0],r[0]),l=n(o,s[0]),c=n(o,a[0]),h=i(s[0],s[0]),u=n(h,r[0]),d=n(h,a[0]),p=i(a[0],a[0]),m=n(p,r[0]),f=n(p,s[0]),g=e(t(f,d),t(u,l)),_=t(m,c),A=t(g,_);return A[A.length-1]}}function o(e,t,i,n){return function(r,s,a,o){var l=e(i(r[0],r[0]),i(r[1],r[1])),c=n(l,s[0]),h=n(l,a[0]),u=n(l,o[0]),d=e(i(s[0],s[0]),i(s[1],s[1])),p=n(d,r[0]),m=n(d,a[0]),f=n(d,o[0]),g=e(i(a[0],a[0]),i(a[1],a[1])),_=n(g,r[0]),A=n(g,s[0]),v=n(g,o[0]),y=e(i(o[0],o[0]),i(o[1],o[1])),x=n(y,r[0]),b=n(y,s[0]),S=n(y,a[0]),C=e(e(n(t(S,v),s[1]),e(n(t(b,f),-a[1]),n(t(A,m),o[1]))),e(n(t(b,f),r[1]),e(n(t(x,u),-s[1]),n(t(p,c),o[1])))),T=e(e(n(t(S,v),r[1]),e(n(t(x,u),-a[1]),n(t(_,h),o[1]))),e(n(t(A,m),r[1]),e(n(t(_,h),-s[1]),n(t(p,c),a[1])))),E=t(C,T);return E[E.length-1]}}function l(e,t,i,n){return function(r,s,a,o,l){var c=e(i(r[0],r[0]),e(i(r[1],r[1]),i(r[2],r[2]))),h=n(c,s[0]),u=n(c,a[0]),d=n(c,o[0]),p=n(c,l[0]),m=e(i(s[0],s[0]),e(i(s[1],s[1]),i(s[2],s[2]))),f=n(m,r[0]),g=n(m,a[0]),_=n(m,o[0]),A=n(m,l[0]),v=e(i(a[0],a[0]),e(i(a[1],a[1]),i(a[2],a[2]))),y=n(v,r[0]),x=n(v,s[0]),b=n(v,o[0]),S=n(v,l[0]),C=e(i(o[0],o[0]),e(i(o[1],o[1]),i(o[2],o[2]))),T=n(C,r[0]),E=n(C,s[0]),M=n(C,a[0]),w=n(C,l[0]),I=e(i(l[0],l[0]),e(i(l[1],l[1]),i(l[2],l[2]))),P=n(I,r[0]),R=n(I,s[0]),B=n(I,a[0]),D=n(I,o[0]),F=e(e(e(n(e(n(t(D,w),a[1]),e(n(t(B,S),-o[1]),n(t(M,b),l[1]))),s[2]),e(n(e(n(t(D,w),s[1]),e(n(t(R,A),-o[1]),n(t(E,_),l[1]))),-a[2]),n(e(n(t(B,S),s[1]),e(n(t(R,A),-a[1]),n(t(x,g),l[1]))),o[2]))),e(n(e(n(t(M,b),s[1]),e(n(t(E,_),-a[1]),n(t(x,g),o[1]))),-l[2]),e(n(e(n(t(D,w),s[1]),e(n(t(R,A),-o[1]),n(t(E,_),l[1]))),r[2]),n(e(n(t(D,w),r[1]),e(n(t(P,p),-o[1]),n(t(T,d),l[1]))),-s[2])))),e(e(n(e(n(t(R,A),r[1]),e(n(t(P,p),-s[1]),n(t(f,h),l[1]))),o[2]),e(n(e(n(t(E,_),r[1]),e(n(t(T,d),-s[1]),n(t(f,h),o[1]))),-l[2]),n(e(n(t(M,b),s[1]),e(n(t(E,_),-a[1]),n(t(x,g),o[1]))),r[2]))),e(n(e(n(t(M,b),r[1]),e(n(t(T,d),-a[1]),n(t(y,u),o[1]))),-s[2]),e(n(e(n(t(E,_),r[1]),e(n(t(T,d),-s[1]),n(t(f,h),o[1]))),a[2]),n(e(n(t(x,g),r[1]),e(n(t(y,u),-s[1]),n(t(f,h),a[1]))),-o[2]))))),O=e(e(e(n(e(n(t(D,w),a[1]),e(n(t(B,S),-o[1]),n(t(M,b),l[1]))),r[2]),n(e(n(t(D,w),r[1]),e(n(t(P,p),-o[1]),n(t(T,d),l[1]))),-a[2])),e(n(e(n(t(B,S),r[1]),e(n(t(P,p),-a[1]),n(t(y,u),l[1]))),o[2]),n(e(n(t(M,b),r[1]),e(n(t(T,d),-a[1]),n(t(y,u),o[1]))),-l[2]))),e(e(n(e(n(t(B,S),s[1]),e(n(t(R,A),-a[1]),n(t(x,g),l[1]))),r[2]),n(e(n(t(B,S),r[1]),e(n(t(P,p),-a[1]),n(t(y,u),l[1]))),-s[2])),e(n(e(n(t(R,A),r[1]),e(n(t(P,p),-s[1]),n(t(f,h),l[1]))),a[2]),n(e(n(t(x,g),r[1]),e(n(t(y,u),-s[1]),n(t(f,h),a[1]))),-l[2])))),L=t(F,O);return L[L.length-1]}}function c(e,t,i,n){return function(r,s,a,o,l,c){var h=e(e(i(r[0],r[0]),i(r[1],r[1])),e(i(r[2],r[2]),i(r[3],r[3]))),u=n(h,s[0]),d=n(h,a[0]),p=n(h,o[0]),m=n(h,l[0]),f=n(h,c[0]),g=e(e(i(s[0],s[0]),i(s[1],s[1])),e(i(s[2],s[2]),i(s[3],s[3]))),_=n(g,r[0]),A=n(g,a[0]),v=n(g,o[0]),y=n(g,l[0]),x=n(g,c[0]),b=e(e(i(a[0],a[0]),i(a[1],a[1])),e(i(a[2],a[2]),i(a[3],a[3]))),S=n(b,r[0]),C=n(b,s[0]),T=n(b,o[0]),E=n(b,l[0]),M=n(b,c[0]),w=e(e(i(o[0],o[0]),i(o[1],o[1])),e(i(o[2],o[2]),i(o[3],o[3]))),I=n(w,r[0]),P=n(w,s[0]),R=n(w,a[0]),B=n(w,l[0]),D=n(w,c[0]),F=e(e(i(l[0],l[0]),i(l[1],l[1])),e(i(l[2],l[2]),i(l[3],l[3]))),O=n(F,r[0]),L=n(F,s[0]),N=n(F,a[0]),V=n(F,o[0]),U=n(F,c[0]),k=e(e(i(c[0],c[0]),i(c[1],c[1])),e(i(c[2],c[2]),i(c[3],c[3]))),G=n(k,r[0]),z=n(k,s[0]),j=n(k,a[0]),Q=n(k,o[0]),H=n(k,l[0]),$=e(e(e(n(e(e(n(e(n(t(H,U),o[1]),e(n(t(Q,D),-l[1]),n(t(V,B),c[1]))),a[2]),n(e(n(t(H,U),a[1]),e(n(t(j,M),-l[1]),n(t(N,E),c[1]))),-o[2])),e(n(e(n(t(Q,D),a[1]),e(n(t(j,M),-o[1]),n(t(R,T),c[1]))),l[2]),n(e(n(t(V,B),a[1]),e(n(t(N,E),-o[1]),n(t(R,T),l[1]))),-c[2]))),s[3]),e(n(e(e(n(e(n(t(H,U),o[1]),e(n(t(Q,D),-l[1]),n(t(V,B),c[1]))),s[2]),n(e(n(t(H,U),s[1]),e(n(t(z,x),-l[1]),n(t(L,y),c[1]))),-o[2])),e(n(e(n(t(Q,D),s[1]),e(n(t(z,x),-o[1]),n(t(P,v),c[1]))),l[2]),n(e(n(t(V,B),s[1]),e(n(t(L,y),-o[1]),n(t(P,v),l[1]))),-c[2]))),-a[3]),n(e(e(n(e(n(t(H,U),a[1]),e(n(t(j,M),-l[1]),n(t(N,E),c[1]))),s[2]),n(e(n(t(H,U),s[1]),e(n(t(z,x),-l[1]),n(t(L,y),c[1]))),-a[2])),e(n(e(n(t(j,M),s[1]),e(n(t(z,x),-a[1]),n(t(C,A),c[1]))),l[2]),n(e(n(t(N,E),s[1]),e(n(t(L,y),-a[1]),n(t(C,A),l[1]))),-c[2]))),o[3]))),e(e(n(e(e(n(e(n(t(Q,D),a[1]),e(n(t(j,M),-o[1]),n(t(R,T),c[1]))),s[2]),n(e(n(t(Q,D),s[1]),e(n(t(z,x),-o[1]),n(t(P,v),c[1]))),-a[2])),e(n(e(n(t(j,M),s[1]),e(n(t(z,x),-a[1]),n(t(C,A),c[1]))),o[2]),n(e(n(t(R,T),s[1]),e(n(t(P,v),-a[1]),n(t(C,A),o[1]))),-c[2]))),-l[3]),n(e(e(n(e(n(t(V,B),a[1]),e(n(t(N,E),-o[1]),n(t(R,T),l[1]))),s[2]),n(e(n(t(V,B),s[1]),e(n(t(L,y),-o[1]),n(t(P,v),l[1]))),-a[2])),e(n(e(n(t(N,E),s[1]),e(n(t(L,y),-a[1]),n(t(C,A),l[1]))),o[2]),n(e(n(t(R,T),s[1]),e(n(t(P,v),-a[1]),n(t(C,A),o[1]))),-l[2]))),c[3])),e(n(e(e(n(e(n(t(H,U),o[1]),e(n(t(Q,D),-l[1]),n(t(V,B),c[1]))),s[2]),n(e(n(t(H,U),s[1]),e(n(t(z,x),-l[1]),n(t(L,y),c[1]))),-o[2])),e(n(e(n(t(Q,D),s[1]),e(n(t(z,x),-o[1]),n(t(P,v),c[1]))),l[2]),n(e(n(t(V,B),s[1]),e(n(t(L,y),-o[1]),n(t(P,v),l[1]))),-c[2]))),r[3]),n(e(e(n(e(n(t(H,U),o[1]),e(n(t(Q,D),-l[1]),n(t(V,B),c[1]))),r[2]),n(e(n(t(H,U),r[1]),e(n(t(G,f),-l[1]),n(t(O,m),c[1]))),-o[2])),e(n(e(n(t(Q,D),r[1]),e(n(t(G,f),-o[1]),n(t(I,p),c[1]))),l[2]),n(e(n(t(V,B),r[1]),e(n(t(O,m),-o[1]),n(t(I,p),l[1]))),-c[2]))),-s[3])))),e(e(e(n(e(e(n(e(n(t(H,U),s[1]),e(n(t(z,x),-l[1]),n(t(L,y),c[1]))),r[2]),n(e(n(t(H,U),r[1]),e(n(t(G,f),-l[1]),n(t(O,m),c[1]))),-s[2])),e(n(e(n(t(z,x),r[1]),e(n(t(G,f),-s[1]),n(t(_,u),c[1]))),l[2]),n(e(n(t(L,y),r[1]),e(n(t(O,m),-s[1]),n(t(_,u),l[1]))),-c[2]))),o[3]),n(e(e(n(e(n(t(Q,D),s[1]),e(n(t(z,x),-o[1]),n(t(P,v),c[1]))),r[2]),n(e(n(t(Q,D),r[1]),e(n(t(G,f),-o[1]),n(t(I,p),c[1]))),-s[2])),e(n(e(n(t(z,x),r[1]),e(n(t(G,f),-s[1]),n(t(_,u),c[1]))),o[2]),n(e(n(t(P,v),r[1]),e(n(t(I,p),-s[1]),n(t(_,u),o[1]))),-c[2]))),-l[3])),e(n(e(e(n(e(n(t(V,B),s[1]),e(n(t(L,y),-o[1]),n(t(P,v),l[1]))),r[2]),n(e(n(t(V,B),r[1]),e(n(t(O,m),-o[1]),n(t(I,p),l[1]))),-s[2])),e(n(e(n(t(L,y),r[1]),e(n(t(O,m),-s[1]),n(t(_,u),l[1]))),o[2]),n(e(n(t(P,v),r[1]),e(n(t(I,p),-s[1]),n(t(_,u),o[1]))),-l[2]))),c[3]),n(e(e(n(e(n(t(Q,D),a[1]),e(n(t(j,M),-o[1]),n(t(R,T),c[1]))),s[2]),n(e(n(t(Q,D),s[1]),e(n(t(z,x),-o[1]),n(t(P,v),c[1]))),-a[2])),e(n(e(n(t(j,M),s[1]),e(n(t(z,x),-a[1]),n(t(C,A),c[1]))),o[2]),n(e(n(t(R,T),s[1]),e(n(t(P,v),-a[1]),n(t(C,A),o[1]))),-c[2]))),r[3]))),e(e(n(e(e(n(e(n(t(Q,D),a[1]),e(n(t(j,M),-o[1]),n(t(R,T),c[1]))),r[2]),n(e(n(t(Q,D),r[1]),e(n(t(G,f),-o[1]),n(t(I,p),c[1]))),-a[2])),e(n(e(n(t(j,M),r[1]),e(n(t(G,f),-a[1]),n(t(S,d),c[1]))),o[2]),n(e(n(t(R,T),r[1]),e(n(t(I,p),-a[1]),n(t(S,d),o[1]))),-c[2]))),-s[3]),n(e(e(n(e(n(t(Q,D),s[1]),e(n(t(z,x),-o[1]),n(t(P,v),c[1]))),r[2]),n(e(n(t(Q,D),r[1]),e(n(t(G,f),-o[1]),n(t(I,p),c[1]))),-s[2])),e(n(e(n(t(z,x),r[1]),e(n(t(G,f),-s[1]),n(t(_,u),c[1]))),o[2]),n(e(n(t(P,v),r[1]),e(n(t(I,p),-s[1]),n(t(_,u),o[1]))),-c[2]))),a[3])),e(n(e(e(n(e(n(t(j,M),s[1]),e(n(t(z,x),-a[1]),n(t(C,A),c[1]))),r[2]),n(e(n(t(j,M),r[1]),e(n(t(G,f),-a[1]),n(t(S,d),c[1]))),-s[2])),e(n(e(n(t(z,x),r[1]),e(n(t(G,f),-s[1]),n(t(_,u),c[1]))),a[2]),n(e(n(t(C,A),r[1]),e(n(t(S,d),-s[1]),n(t(_,u),a[1]))),-c[2]))),-o[3]),n(e(e(n(e(n(t(R,T),s[1]),e(n(t(P,v),-a[1]),n(t(C,A),o[1]))),r[2]),n(e(n(t(R,T),r[1]),e(n(t(I,p),-a[1]),n(t(S,d),o[1]))),-s[2])),e(n(e(n(t(P,v),r[1]),e(n(t(I,p),-s[1]),n(t(_,u),o[1]))),a[2]),n(e(n(t(C,A),r[1]),e(n(t(S,d),-s[1]),n(t(_,u),a[1]))),-o[2]))),c[3]))))),W=e(e(e(n(e(e(n(e(n(t(H,U),o[1]),e(n(t(Q,D),-l[1]),n(t(V,B),c[1]))),a[2]),n(e(n(t(H,U),a[1]),e(n(t(j,M),-l[1]),n(t(N,E),c[1]))),-o[2])),e(n(e(n(t(Q,D),a[1]),e(n(t(j,M),-o[1]),n(t(R,T),c[1]))),l[2]),n(e(n(t(V,B),a[1]),e(n(t(N,E),-o[1]),n(t(R,T),l[1]))),-c[2]))),r[3]),e(n(e(e(n(e(n(t(H,U),o[1]),e(n(t(Q,D),-l[1]),n(t(V,B),c[1]))),r[2]),n(e(n(t(H,U),r[1]),e(n(t(G,f),-l[1]),n(t(O,m),c[1]))),-o[2])),e(n(e(n(t(Q,D),r[1]),e(n(t(G,f),-o[1]),n(t(I,p),c[1]))),l[2]),n(e(n(t(V,B),r[1]),e(n(t(O,m),-o[1]),n(t(I,p),l[1]))),-c[2]))),-a[3]),n(e(e(n(e(n(t(H,U),a[1]),e(n(t(j,M),-l[1]),n(t(N,E),c[1]))),r[2]),n(e(n(t(H,U),r[1]),e(n(t(G,f),-l[1]),n(t(O,m),c[1]))),-a[2])),e(n(e(n(t(j,M),r[1]),e(n(t(G,f),-a[1]),n(t(S,d),c[1]))),l[2]),n(e(n(t(N,E),r[1]),e(n(t(O,m),-a[1]),n(t(S,d),l[1]))),-c[2]))),o[3]))),e(e(n(e(e(n(e(n(t(Q,D),a[1]),e(n(t(j,M),-o[1]),n(t(R,T),c[1]))),r[2]),n(e(n(t(Q,D),r[1]),e(n(t(G,f),-o[1]),n(t(I,p),c[1]))),-a[2])),e(n(e(n(t(j,M),r[1]),e(n(t(G,f),-a[1]),n(t(S,d),c[1]))),o[2]),n(e(n(t(R,T),r[1]),e(n(t(I,p),-a[1]),n(t(S,d),o[1]))),-c[2]))),-l[3]),n(e(e(n(e(n(t(V,B),a[1]),e(n(t(N,E),-o[1]),n(t(R,T),l[1]))),r[2]),n(e(n(t(V,B),r[1]),e(n(t(O,m),-o[1]),n(t(I,p),l[1]))),-a[2])),e(n(e(n(t(N,E),r[1]),e(n(t(O,m),-a[1]),n(t(S,d),l[1]))),o[2]),n(e(n(t(R,T),r[1]),e(n(t(I,p),-a[1]),n(t(S,d),o[1]))),-l[2]))),c[3])),e(n(e(e(n(e(n(t(H,U),a[1]),e(n(t(j,M),-l[1]),n(t(N,E),c[1]))),s[2]),n(e(n(t(H,U),s[1]),e(n(t(z,x),-l[1]),n(t(L,y),c[1]))),-a[2])),e(n(e(n(t(j,M),s[1]),e(n(t(z,x),-a[1]),n(t(C,A),c[1]))),l[2]),n(e(n(t(N,E),s[1]),e(n(t(L,y),-a[1]),n(t(C,A),l[1]))),-c[2]))),r[3]),n(e(e(n(e(n(t(H,U),a[1]),e(n(t(j,M),-l[1]),n(t(N,E),c[1]))),r[2]),n(e(n(t(H,U),r[1]),e(n(t(G,f),-l[1]),n(t(O,m),c[1]))),-a[2])),e(n(e(n(t(j,M),r[1]),e(n(t(G,f),-a[1]),n(t(S,d),c[1]))),l[2]),n(e(n(t(N,E),r[1]),e(n(t(O,m),-a[1]),n(t(S,d),l[1]))),-c[2]))),-s[3])))),e(e(e(n(e(e(n(e(n(t(H,U),s[1]),e(n(t(z,x),-l[1]),n(t(L,y),c[1]))),r[2]),n(e(n(t(H,U),r[1]),e(n(t(G,f),-l[1]),n(t(O,m),c[1]))),-s[2])),e(n(e(n(t(z,x),r[1]),e(n(t(G,f),-s[1]),n(t(_,u),c[1]))),l[2]),n(e(n(t(L,y),r[1]),e(n(t(O,m),-s[1]),n(t(_,u),l[1]))),-c[2]))),a[3]),n(e(e(n(e(n(t(j,M),s[1]),e(n(t(z,x),-a[1]),n(t(C,A),c[1]))),r[2]),n(e(n(t(j,M),r[1]),e(n(t(G,f),-a[1]),n(t(S,d),c[1]))),-s[2])),e(n(e(n(t(z,x),r[1]),e(n(t(G,f),-s[1]),n(t(_,u),c[1]))),a[2]),n(e(n(t(C,A),r[1]),e(n(t(S,d),-s[1]),n(t(_,u),a[1]))),-c[2]))),-l[3])),e(n(e(e(n(e(n(t(N,E),s[1]),e(n(t(L,y),-a[1]),n(t(C,A),l[1]))),r[2]),n(e(n(t(N,E),r[1]),e(n(t(O,m),-a[1]),n(t(S,d),l[1]))),-s[2])),e(n(e(n(t(L,y),r[1]),e(n(t(O,m),-s[1]),n(t(_,u),l[1]))),a[2]),n(e(n(t(C,A),r[1]),e(n(t(S,d),-s[1]),n(t(_,u),a[1]))),-l[2]))),c[3]),n(e(e(n(e(n(t(V,B),a[1]),e(n(t(N,E),-o[1]),n(t(R,T),l[1]))),s[2]),n(e(n(t(V,B),s[1]),e(n(t(L,y),-o[1]),n(t(P,v),l[1]))),-a[2])),e(n(e(n(t(N,E),s[1]),e(n(t(L,y),-a[1]),n(t(C,A),l[1]))),o[2]),n(e(n(t(R,T),s[1]),e(n(t(P,v),-a[1]),n(t(C,A),o[1]))),-l[2]))),r[3]))),e(e(n(e(e(n(e(n(t(V,B),a[1]),e(n(t(N,E),-o[1]),n(t(R,T),l[1]))),r[2]),n(e(n(t(V,B),r[1]),e(n(t(O,m),-o[1]),n(t(I,p),l[1]))),-a[2])),e(n(e(n(t(N,E),r[1]),e(n(t(O,m),-a[1]),n(t(S,d),l[1]))),o[2]),n(e(n(t(R,T),r[1]),e(n(t(I,p),-a[1]),n(t(S,d),o[1]))),-l[2]))),-s[3]),n(e(e(n(e(n(t(V,B),s[1]),e(n(t(L,y),-o[1]),n(t(P,v),l[1]))),r[2]),n(e(n(t(V,B),r[1]),e(n(t(O,m),-o[1]),n(t(I,p),l[1]))),-s[2])),e(n(e(n(t(L,y),r[1]),e(n(t(O,m),-s[1]),n(t(_,u),l[1]))),o[2]),n(e(n(t(P,v),r[1]),e(n(t(I,p),-s[1]),n(t(_,u),o[1]))),-l[2]))),a[3])),e(n(e(e(n(e(n(t(N,E),s[1]),e(n(t(L,y),-a[1]),n(t(C,A),l[1]))),r[2]),n(e(n(t(N,E),r[1]),e(n(t(O,m),-a[1]),n(t(S,d),l[1]))),-s[2])),e(n(e(n(t(L,y),r[1]),e(n(t(O,m),-s[1]),n(t(_,u),l[1]))),a[2]),n(e(n(t(C,A),r[1]),e(n(t(S,d),-s[1]),n(t(_,u),a[1]))),-l[2]))),-o[3]),n(e(e(n(e(n(t(R,T),s[1]),e(n(t(P,v),-a[1]),n(t(C,A),o[1]))),r[2]),n(e(n(t(R,T),r[1]),e(n(t(I,p),-a[1]),n(t(S,d),o[1]))),-s[2])),e(n(e(n(t(P,v),r[1]),e(n(t(I,p),-s[1]),n(t(_,u),o[1]))),a[2]),n(e(n(t(C,A),r[1]),e(n(t(S,d),-s[1]),n(t(_,u),a[1]))),-o[2]))),l[3]))))),q=t($,W);return q[q.length-1]}}var h=[function(){return 0},function(){return 0},function(){return 0}];function u(e){var t=h[e.length];return t||(t=h[e.length]=s(e.length)),t.apply(void 0,e)}function d(e,t,i,n,r,s,a,o){return function(t,i,l,c,h,u){switch(arguments.length){case 0:case 1:return 0;case 2:return n(t,i);case 3:return r(t,i,l);case 4:return s(t,i,l,c);case 5:return a(t,i,l,c,h);case 6:return o(t,i,l,c,h,u)}for(var d=new Array(arguments.length),p=0;p<arguments.length;++p)d[p]=arguments[p];return e(d)}}!function(){for(;h.length<=6;)h.push(s(h.length));e.exports=d.apply(void 0,[u].concat(h));for(var t=0;t<=6;++t)e.exports[t]=h[t]}()}(inSphere);var inCircle=inSphere.exports[4],delaunay=delaunayRefine;function testFlip(e,t,i,n,r,s){var a=t.opposite(n,r);if(!(a<0)){if(r<n){var o=n;n=r,r=o,o=s,s=a,a=o}t.isConstraint(n,r)||inCircle(e[n],e[r],e[s],e[a])<0&&i.push(n,r)}}function delaunayRefine(e,t){for(var i=[],n=e.length,r=t.stars,s=0;s<n;++s)for(var a=r[s],o=1;o<a.length;o+=2){if(!((u=a[o])<s)&&!t.isConstraint(s,u)){for(var l=a[o-1],c=-1,h=1;h<a.length;h+=2)if(a[h-1]===u){c=a[h];break}c<0||inCircle(e[s],e[u],e[l],e[c])<0&&i.push(s,u)}}for(;i.length>0;){for(var u=i.pop(),d=(l=-1,c=-1,a=r[s=i.pop()],1);d<a.length;d+=2){var p=a[d-1],m=a[d];p===u?c=m:m===u&&(l=p)}l<0||c<0||(inCircle(e[s],e[u],e[l],e[c])>=0||(t.flip(s,u),testFlip(e,t,i,l,s,c),testFlip(e,t,i,s,c,l),testFlip(e,t,i,c,u,l),testFlip(e,t,i,u,l,c)))}}var bsearch=searchBounds,filter=classifyFaces;function FaceIndex(e,t,i,n,r,s,a){this.cells=e,this.neighbor=t,this.flags=n,this.constraint=i,this.active=r,this.next=s,this.boundary=a}var proto=FaceIndex.prototype,key;function compareCell(e,t){return e[0]-t[0]||e[1]-t[1]||e[2]-t[2]}function indexCells(e,t){for(var i=e.cells(),n=i.length,r=0;r<n;++r){var s=(f=i[r])[0],a=f[1],o=f[2];a<o?a<s&&(f[0]=a,f[1]=o,f[2]=s):o<s&&(f[0]=o,f[1]=s,f[2]=a)}i.sort(compareCell);var l=new Array(n);for(r=0;r<l.length;++r)l[r]=0;var c=[],h=[],u=new Array(3*n),d=new Array(3*n),p=null;t&&(p=[]);var m=new FaceIndex(i,u,d,l,c,h,p);for(r=0;r<n;++r)for(var f=i[r],g=0;g<3;++g){s=f[g],a=f[(g+1)%3];var _=u[3*r+g]=m.locate(a,s,e.opposite(a,s)),A=d[3*r+g]=e.isConstraint(s,a);_<0&&(A?h.push(r):(c.push(r),l[r]=1),t&&p.push([a,s,-1]))}return m}function filterCells(e,t,i){for(var n=0,r=0;r<e.length;++r)t[r]===i&&(e[n++]=e[r]);return e.length=n,e}function classifyFaces(e,t,i){var n=indexCells(e,i);if(0===t)return i?n.cells.concat(n.boundary):n.cells;for(var r=1,s=n.active,a=n.next,o=n.flags,l=n.cells,c=n.constraint,h=n.neighbor;s.length>0||a.length>0;){for(;s.length>0;){var u=s.pop();if(o[u]!==-r){o[u]=r,l[u];for(var d=0;d<3;++d){var p=h[3*u+d];p>=0&&0===o[p]&&(c[3*u+d]?a.push(p):(s.push(p),o[p]=r))}}}var m=a;a=s,s=m,a.length=0,r=-r}var f=filterCells(l,o,t);return i?f.concat(n.boundary):f}proto.locate=(key=[0,0,0],function(e,t,i){var n=e,r=t,s=i;return t<i?t<e&&(n=t,r=i,s=e):i<e&&(n=i,r=e,s=t),n<0?-1:(key[0]=n,key[1]=r,key[2]=s,bsearch.eq(this.cells,key,compareCell))});var monotoneTriangulate=monotone,makeIndex=triangulation,delaunayFlip=delaunay,filterTriangulation=filter,cdt2d_1=cdt2d;function canonicalizeEdge(e){return[Math.min(e[0],e[1]),Math.max(e[0],e[1])]}function compareEdge(e,t){return e[0]-t[0]||e[1]-t[1]}function canonicalizeEdges(e){return e.map(canonicalizeEdge).sort(compareEdge)}function getDefault(e,t,i){return t in e?e[t]:i}function cdt2d(e,t,i){Array.isArray(t)?(i=i||{},t=t||[]):(i=t||{},t=[]);var n=!!getDefault(i,"delaunay",!0),r=!!getDefault(i,"interior",!0),s=!!getDefault(i,"exterior",!0),a=!!getDefault(i,"infinity",!1);if(!r&&!s||0===e.length)return[];var o=monotoneTriangulate(e,t);if(n||r!==s||a){for(var l=makeIndex(e.length,canonicalizeEdges(t)),c=0;c<o.length;++c){var h=o[c];l.addTriangle(h[0],h[1],h[2])}return n&&delaunayFlip(e,l),s?r?a?filterTriangulation(l,0,a):l.cells():filterTriangulation(l,1,a):filterTriangulation(l,-1)}return o}function pushInBatches(e,t,i=1e4){for(let n=0;n<t.length;n+=i)e.push(...t.slice(n,n+i))}function createEdgePoint(e,t){const i=[];for(let n=0;n<t.length;n++){const r=t[n],[s,a]=r;0===n&&i.push(e[s]),i.push(e[a])}return i}function dedupPoints(e){let t={},i={},n=[],r=0;for(let s=0;s<e.length;s++){const a=e[s],o=a[2]||0,l=`${a[0]},${a[1]},${o}`;void 0!==t[l]?r++:(t[l]=s-r,n.push(a));const c=t[l];i[s]=c}return{indexMap:i,points:n}}function dedupEdges(e,t){let i=[],n={},r=0;for(let s=0;s<e.length;s++){const a=e[s];if(a[0]=t[a[0]],a[1]=t[a[1]],a[0]===a[1])continue;const o=`${a[0]},${a[1]}`;void 0!==n[o]?r++:(n[o]=s-r,i.push(a))}return i}function isClockWise(e){let t=e.length,i=0;for(let n=t-1,r=0;r<t;n=r++)i+=e[n][0]*e[r][1]-e[r][0]*e[n][1];return i<0}const defaultColor=[1,1,0,1];let positionVec3$1=new three.Vector3,positionTemp$1=new three.Vector3;const subdivisionV0Scratch=new three.Vector3,subdivisionV1Scratch=new three.Vector3,subdivisionV2Scratch=new three.Vector3,subdivisionS0Scratch=new three.Vector3,subdivisionS1Scratch=new three.Vector3,subdivisionS2Scratch=new three.Vector3,subdivisionMidScratch=new three.Vector3,subdivisionT0Scratch=new three.Vector2,subdivisionT1Scratch=new three.Vector2,subdivisionT2Scratch=new three.Vector2,scaleToGeodeticHeightN1$1=new three.Vector3,scaleToGeodeticHeightN2$1=new three.Vector3,scaleToGeodeticHeightP1=new three.Vector3,scaleToGeodeticHeightP2$1=new three.Vector3,scratchCartesian3Position1$1=new three.Vector3,scratchCartesian3Position4$1=new three.Vector3,scratchRotatePoint=new three.Vector2,scratchPrevPoint=[0,0,0],scratchPoint=[0,0,0],scratchNextPoint=[0,0,0],subdivideHeightsScratchArray$1=[],subdivideHeights$1=(e,t,i)=>{const n=subdivideHeightsScratchArray$1;n.length=e;let r=0;if(t===i){for(r=0;r<e;r++)n[r]=t;return n}const s=(i-t)/e;for(let a=0;a<e;a++){const e=t+a*s;n[a]=e}return n},distanceScratch$1=new three.Vector3,getPointAtDistance$1=(e,t,i,n)=>(Cartesian3.subtract(t,e,distanceScratch$1),Cartesian3.multiplyByScalar(distanceScratch$1,i/n,distanceScratch$1),Cartesian3.add(e,distanceScratch$1,distanceScratch$1),[distanceScratch$1.x,distanceScratch$1.y,distanceScratch$1.z]),p1Scratch$2=new three.Vector3,p2Scratch$1=new three.Vector3,computeSubdivision=(e,t,i,n,r,s,a,o=!0)=>{a=a||CesiumMath.RADIANS_PER_DEGREE;const l=!!s,c=n.slice(0);let h=0;const u=t.length,d=new Array(3*u),p=new Array(2*u),m=new Array(u);let f=0,g=0,_=0;for(h=0;h<u;h++){const e=t[h];if(d[f++]=e.x,d[f++]=e.y,d[f++]=e.z,l){const e=s[h];p[g++]=e.x,p[g++]=e.y}m[_++]=i[h]}const A=[],v={},y={},x=e.maximumRadius,b=CesiumMath.chordLength(a,x),S=b*b;for(;c.length>0;){const e=c.pop(),t=c.pop(),i=c.pop(),n=subdivisionV0Scratch.fromArray(d,3*i),s=subdivisionV1Scratch.fromArray(d,3*t),a=subdivisionV2Scratch.fromArray(d,3*e),u=m[i],f=m[t],g=m[e];let _,b,C;l&&(_=subdivisionT0Scratch.fromArray(p,2*i),b=subdivisionT1Scratch.fromArray(p,2*t),C=subdivisionT2Scratch.fromArray(p,2*e));const T=Cartesian3.multiplyByScalar(Cartesian3.normalize(n,subdivisionS0Scratch),x,subdivisionS0Scratch),E=Cartesian3.multiplyByScalar(Cartesian3.normalize(s,subdivisionS1Scratch),x,subdivisionS1Scratch),M=Cartesian3.multiplyByScalar(Cartesian3.normalize(a,subdivisionS2Scratch),x,subdivisionS2Scratch),w=Cartesian3.magnitudeSquared(Cartesian3.subtract(T,E,subdivisionMidScratch)),I=Cartesian3.magnitudeSquared(Cartesian3.subtract(E,M,subdivisionMidScratch)),P=Cartesian3.magnitudeSquared(Cartesian3.subtract(M,T,subdivisionMidScratch)),R=Math.max(w,I,P);let B,D,F,O;o&&R>S?w===R?(B=`${Math.min(i,t)} ${Math.max(i,t)}`,h=v[B],null==h?(D=Cartesian3.add(n,s,subdivisionMidScratch),Cartesian3.multiplyByScalar(D,.5,D),d.push(D.x,D.y,D.z),h=d.length/3-1,v[B]=h,O=.5*(u+f),m.push(O),y[B]=O,l&&(F=Cartesian2.add(_,b,subdivisionMidScratch),Cartesian2.multiplyByScalar(F,.5,F),p.push(F.x,F.y))):O=y[B],c.push(i,h,e),c.push(h,t,e)):I===R?(B=`${Math.min(t,e)} ${Math.max(t,e)}`,h=v[B],h?O=y[B]:(D=Cartesian3.add(s,a,subdivisionMidScratch),Cartesian3.multiplyByScalar(D,.5,D),d.push(D.x,D.y,D.z),h=d.length/3-1,v[B]=h,O=.5*(f+g),m.push(O),y[B]=O,l&&(F=Cartesian2.add(b,C,subdivisionMidScratch),Cartesian2.multiplyByScalar(F,.5,F),p.push(F.x,F.y))),c.push(t,h,i),c.push(h,e,i)):P===R&&(B=`${Math.min(e,i)} ${Math.max(e,i)}`,h=v[B],h?O=y[B]:(D=Cartesian3.add(a,n,subdivisionMidScratch),Cartesian3.multiplyByScalar(D,.5,D),d.push(D.x,D.y,D.z),h=d.length/3-1,v[B]=h,O=.5*(g+u),m.push(O),y[B]=O,l&&(F=Cartesian2.add(C,_,subdivisionMidScratch),Cartesian2.multiplyByScalar(F,.5,F),p.push(F.x,F.y))),c.push(e,h,t),c.push(h,i,t)):(A.push(i+r),A.push(t+r),A.push(e+r))}return{subdividedPositions:d,subdividedTexcoords:p,subdividedIndices:A,subdividedHeights:m}};class PolygonGeometry extends three.BufferGeometry{constructor(e){super(),__publicField(this,"isPolygonGeometry",!0),__publicField(this,"_useUV",!1),__publicField(this,"_useEarCut",!1),__publicField(this,"_sideUVNormalized",!1),__publicField(this,"_sideUVReversed",!1),__publicField(this,"_sideUVUseHeight",!1),__publicField(this,"_rectangle",null),__publicField(this,"triangulate",((e,t)=>{const i=e.reduce(((e,t)=>e.concat(t.toArray())),[]);return earcut$1.exports(i,t)})),__publicField(this,"addGeoPolygonToVertices",((e,t,i=0,n=0,r,s,a,o,l,c,h,u,d,p,m=!1)=>{let f=e.vertices;const g=e.dimensions;Array.isArray(h)||(h=defaultColor);let _=1/0,A=1/0,v=-1/0,y=-1/0;for(let T=0,E=f.length-g+1;T<E;T+=g)_=f[T]<_?f[T]:_,A=f[T+1]<A?f[T+1]:A,v=f[T]>v?f[T]:v,y=f[T+1]>y?f[T+1]:y;const x=new three.Vector2((v+_)/2,(y+A)/2),b=new three.Vector3,S=new three.Vector3;let C=[];for(let T=0;T<=t.length-g;T+=g){let e=[];for(let a=0;a<3;a++){const s=t[T+a]*g;let v;v=2===g||m&&!this.perPositionHeight?new three.Vector3(f[s],f[s+1],i):new three.Vector3(f[s],f[s+1],f[s+2]+i),e.push(v),r.push(v.x,v.y,v.z),c.push(h[0],h[1],h[2],h[3]),this._pushHeightAndConcave(p,i,-1),rotatePoint(scratchRotatePoint.set(f[s],f[s+1]),x,l),o.push(scratchRotatePoint.x-_,scratchRotatePoint.y-A),u.push(d),C.push(n+T+a)}let s=[0,0,1];2!==g&&(b.subVectors(e[2],e[1]),S.subVectors(e[0],e[1]),b.cross(S),b.normalize(),s=b.toArray()),a.push(...s,...s,...s)}m?s.push(...C.reverse()):s.push(...C)})),__publicField(this,"_encodeConcave",((e,t,i)=>{let n=0;return e&&(n|=1),t&&(n|=2),i&&(n|=4),n})),__publicField(this,"_pushHeightAndConcave",((e,t,i,n,r,s,a)=>{if(-1===i)return void e.push(t,this._encodeConcave(!1,!1,!1));const o=isAOConcaveAngle(n,r,s),l=Array.isArray(e);0===i?l?e.push(0,this._encodeConcave(!0,o,!1),t,this._encodeConcave(!1,o,!1)):(e.bottom.push(0,this._encodeConcave(!0,o,!1)),e.top.push(t,this._encodeConcave(!1,o,!1))):i===a-1?l?e.push(t,this._encodeConcave(!1,o,!0),0,this._encodeConcave(!0,o,!0)):(e.bottom.push(0,this._encodeConcave(!0,o,!0)),e.top.push(t,this._encodeConcave(!1,o,!0))):l?e.push(t,this._encodeConcave(!1,o,!0),0,this._encodeConcave(!0,o,!0),0,this._encodeConcave(!0,o,!1),t,this._encodeConcave(!1,o,!1)):(e.bottom.push(0,this._encodeConcave(!0,o,!0),0,this._encodeConcave(!0,o,!1)),e.top.push(t,this._encodeConcave(!1,o,!0),t,this._encodeConcave(!1,o,!1)))})),__publicField(this,"_pushPosition",((e,t,i,n)=>{const r=this._calculateHeights(t,i,n);e.push(t[0],t[1],r.bottom,t[0],t[1],r.top,i[0],i[1],r.nextTop,i[0],i[1],r.nextBottom)})),__publicField(this,"_pushNormal",((e,t,i)=>{const n=this._calculateNormal(t,i);e.push(...n,...n,...n,...n)})),__publicField(this,"_pushUV",((e,t,i,n,r)=>{let s=0,a=0,o=i[0]-t[0],l=i[1]-t[1];const c=Math.sqrt(o*o+l*l);return this._sideUVUseHeight?(s=1*n,a=1*n):(s=0,a=1*n,this._sideUVNormalized&&(a=1),this._sideUVReversed&&(s=a,a=0)),e.push(1*r,s,1*r,a),r+=c,e.push(1*r,a,1*r,s),r})),__publicField(this,"_pushColor",((e,t,i=4)=>{for(let n=0;n<i;n++)e.push(t[0],t[1],t[2],t[3])})),__publicField(this,"_pushObjectIndex",((e,t)=>{e.push(t,t,t,t)})),__publicField(this,"addSideFace",((e,t,i,n,r,s,a,o,l,c,h,u)=>{let d=i;isClockWise(e)&&e.reverse(),Array.isArray(l)||(l=defaultColor);const p=e.length;let m=0;for(let f=0,g=p;f<g;f++){let g=0===f?e.length-2:f-1,_=f===e.length-1?1:f+1,A=e[g],v=e[f],y=e[_];this._pushHeightAndConcave(u,t,f,A,v,y,p),f!==e.length-1&&(_=(f+1)%p,y=e[_],this._pushPosition(n,v,y,t),this._pushNormal(s,v,y),this._pushColor(o,l),this._pushObjectIndex(c,h),m=this._pushUV(a,v,y,t,m),d=i+4*f,r.push(d,d+2,d+1,d,d+3,d+2))}})),__publicField(this,"subdivideLineCount",((e,t,i)=>{const n=e.distanceTo(t)/i,r=Math.max(0,Math.ceil(Math.log2(n)));return Math.pow(2,r)})),__publicField(this,"subdivideLine",((e,t,i,n,r,s,a,o,l,c,h)=>{const u=this.subdivideLineCount(e,t,s),d=e.distanceTo(t),p=d/u;this.extrude&&this._extrudeValue;let m=Cartesian3.clone(e,new three.Vector3),f=Cartesian3.clone(t,new three.Vector3),g=new three.Vector3,_=new three.Vector3,A=i,v=n;const y=a.scaleToGeodeticSurface(m);a.geodeticSurfaceNormal(m,g);const x=a.scaleToGeodeticSurface(f);a.geodeticSurfaceNormal(f,_),A+=this._zOffset,v+=this._zOffset,this.extrude&&(A+=o,v+=o),Cartesian3.multiplyByScalar(g,A,g),Cartesian3.add(y,g,m),Cartesian3.multiplyByScalar(_,v,_),Cartesian3.add(x,_,f),c||(c=[]),h||(h=[]);const b=new three.Vector3,S=new three.Vector3;let C,T,E=[];C=a.cartesianToCartographic(m,S).z,T=a.cartesianToCartographic(f,S).z,E=subdivideHeights$1(u,C,T);const M=scaleToGeodeticHeightN1$1;let w=scaleToGeodeticHeightN2$1,I=scaleToGeodeticHeightP2$1,P=0,R=0;for(let B=0;B<u;B++){const e=b.fromArray(getPointAtDistance$1(m,f,p*B,d));R=E[B],a.geodeticSurfaceNormal(e,M),I=a.scaleToGeodeticSurface(e,I),w=Cartesian3.multiplyByScalar(M,this._zOffset+r,w),w=Cartesian3.add(I,w,w),h[P]=w.x,h[P+1]=w.y,h[P+2]=w.z,B>0&&l.bottom.push(0,this._encodeConcave(!0,!1,!1)),this.perPositionHeight?(I=Cartesian2.clone(e,I),w=Cartesian3.clone(I,w)):(w=Cartesian3.multiplyByScalar(M,R,w),w=Cartesian3.add(I,w,w)),c[P]=w.x,c[P+1]=w.y,c[P+2]=w.z,B>0&&l.top.push(o,this._encodeConcave(!0,!1,!1)),P+=3}return a.geodeticSurfaceNormal(f,M),I=a.scaleToGeodeticSurface(f,I),w=Cartesian3.multiplyByScalar(M,this._zOffset+r,w),w=Cartesian3.add(I,w,w),h[P]=w.x,h[P+1]=w.y,h[P+2]=w.z,this.perPositionHeight?w=Cartesian2.clone(f,w):(w=Cartesian3.multiplyByScalar(M,T,w),w=Cartesian3.add(I,w,w)),c[P]=w.x,c[P+1]=w.y,c[P+2]=w.z,{topPositions:c,bottomPositions:h}})),__publicField(this,"crossVectors3",((e,t)=>{const i=[];return i[0]=e[1]*t[2]-e[2]*t[1],i[1]=e[2]*t[0]-e[0]*t[2],i[2]=e[0]*t[1]-e[1]*t[0],i})),this.parameters=e,this._needsUpdate=!1,this._extrude=defaultValue$1(e.extrude,!1),this._extrudeValue=defaultValue$1(e.extrudeValue,0),this._enableBottomFace=defaultValue$1(e.enableBottomFace,!1),this.perPositionHeight=defaultValue$1(e.perPositionHeight,!1),this._zOffset=defaultValue$1(e.zOffset,0),this.cachedPositions=[],this.cachedObjectIndices=[]}setData(e){this._needsUpdate=!0,this.cachedData=e,this.updateGeometry()}updateGeometry(){this.engine.map.isGlobe?this.updateGeometry3D():this.updateGeometryColumbus()}updateGeometry3D(){const e=this.cachedData,t=this.engine.map.map.ellipsoid||Ellipsoid.WGS84,i=[],n=[],r=[],s=[],a=[],o=[],l=[];let c=0;const h=[],u=[],d=[],p=[],m=[],f=[],g=[];let _=0;const A=scaleToGeodeticHeightN1$1;let v=scaleToGeodeticHeightN2$1;const y=scaleToGeodeticHeightP1;let x=scaleToGeodeticHeightP2$1;for(let S=0;S<e.position.length;S++){const b=e.position[S],C=e.index[S],T=this.parameters.vertexHeights?e.height[S]:this.extrudeValue,E=e.color?colorToArr4(e.color[S]):defaultColor,M=arrayRemoveDuplicates(b[0],!0),w=extractHeights$1(M,t).map((e=>e)),I=0;if(M.length<3)continue;for(let e=0;e<M.length;e++){let i=M[e];t.scaleToGeodeticSurface(positionVec3$1.fromArray(i),positionTemp$1),M[e]=positionTemp$1.toArray()}const P=computeRectangleFromPositions(M,t),R=createProjectTo2D(P,M,t),B=[];let D=Number.POSITIVE_INFINITY,F=Number.POSITIVE_INFINITY;D=Math.min(...R.map((e=>e.x))),F=Math.min(...R.map((e=>e.y)));for(let e=0;e<R.length;e++){const t=R[e],i=t.x-D,n=t.y-F;B.push(new three.Vector2(i,n))}const O=this.triangulate(R),L=M.map((e=>new three.Vector3(...e)));let N=this.parameters.granularity;const V=this.extrude&&this._enableBottomFace,U=!(this.extrude&&this.perPositionHeight),k=V||U,{subdividedPositions:G,subdividedTexcoords:z,subdividedIndices:j,subdividedHeights:Q}=computeSubdivision(t,L,w,O,c,B,N,k);let H=G.length;const $=a.length,W=[];let q=0;if(U){for(let e=0;e<H;e+=3)y.fromArray(G,e),t.geodeticSurfaceNormal(y,A),x=t.scaleToGeodeticSurface(y,x),q=Q[e/3],this.extrudeValue&&!this.perPositionHeight&&(q=0),v=Cartesian3.multiplyByScalar(A,this._zOffset+T+q,v),v=Cartesian3.add(x,v,v),W[e]=v.x,W[e+1]=v.y,W[e+2]=v.z,a[e+$]=A.x,a[e+1+$]=A.y,a[e+2+$]=A.z,n.push(T,this._encodeConcave(!1,!1,!1));pushInBatches(i,W),pushInBatches(r,j),pushInBatches(o,z)}else{for(let e=0;e<L.length;e++){const i=L[e],r=B[e];t.geodeticSurfaceNormal(i,A),a[3*e+$]=A.x,a[3*e+1+$]=A.y,a[3*e+2+$]=A.z,x=Cartesian3.clone(i,x),v=Cartesian3.multiplyByScalar(A,this._zOffset+w[e]+T,v),v=Cartesian3.add(x,v,v),W[3*e]=v.x,W[3*e+1]=v.y,W[3*e+2]=v.z,n.push(T,this._encodeConcave(!1,!1,!1)),o.push(r.x,r.y)}i.push(...W),r.push(...O)}const Y=a.length;if(V)for(let e=0;e<H;e+=3)y.fromArray(G,e),t.geodeticSurfaceNormal(y,A),x=t.scaleToGeodeticSurface(y,x),v=Cartesian3.multiplyByScalar(A,this._zOffset+I,v),v=Cartesian3.add(x,v,v),G[e]=v.x,G[e+1]=v.y,G[e+2]=v.z,a[e+Y]=-A.x,a[e+1+Y]=-A.y,a[e+2+Y]=-A.z,n.push(0,this._encodeConcave(!0,!1,!1));let X=W.length/3;this.extrude&&this._enableBottomFace&&(i.push(...G),X+=G.length/3);for(let e=0;e<X;e++)l.push(C);if(c+=X,this.extrude&&this._enableBottomFace){const e=[],t=W.length/3,i=j.length-1;for(let n=0;n<=i;n++)e.push(j[n]+t);pushInBatches(o,z),pushInBatches(r,e.reverse())}if(pushInBatches(s,Array.from({length:X},(()=>E)).flat()),this.extrude){isClockWise(R.map((e=>e.toArray())))&&(L.reverse(),R.reverse());const{edgePositions:e,edgeHeightAndConcaves:i,edgeIndices:n,edgeNormals:r,edgeUvs:s}=this.computeWallGeometry3D(L,R,t,CesiumMath.RADIANS_PER_DEGREE,_,T,w,I),a=Array.from({length:e.length/3},(()=>E)).flat();for(let t=0;t<e.length/3;t++)g.push(C);pushInBatches(h,e),pushInBatches(u,i),pushInBatches(d,n),pushInBatches(p,r),pushInBatches(m,a),pushInBatches(f,s),_+=e.length/3}}const b=r.length;this.extrude&&(d.forEach(((e,t)=>d[t]=e+c)),pushInBatches(i,h),pushInBatches(n,u),pushInBatches(r,d),pushInBatches(a,p),pushInBatches(s,m),pushInBatches(o,f),pushInBatches(l,g)),this.cachedPositions=i,this.cachedObjectIndices=l,this.setAttribute("position",new three.Float32BufferAttribute(i,3)),this.setAttribute("heightAndConcave",new three.Float32BufferAttribute(n,2)),this.parameters.vertexColors&&this.setAttribute("aColor",new three.Float32BufferAttribute(s,4)),this.setAttribute("uv",new three.Float32BufferAttribute(o,2)),this.setAttribute("normal",new three.Float32BufferAttribute(a,3)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(l,1)),this.setIndex(r),this.clearGroups(),this.addGroup(0,b,1),this.extrude&&this.addGroup(b,r.length-b,0),this.computeBoundingSphere(),this._needsUpdate=!1}updateGeometryColumbus(){let e=this.cachedData,t=null,i=null;const n=[],r=[],s=[],a=[],o=[];let l=[];const c=[],h=[],u=[],d=[],p=[],m=[],f=[],g=[],_=e.position&&e.position.length||0;for(let x=0;x<_;x++){const _=e.position[x],A=e.index[x],v=e.color?colorToArr4(e.color[x]):defaultColor,b=this.parameters.vertexHeights?e.height[x]:this.extrudeValue,S=this._useUV&&e.uvRotation?e.uvRotation[x]:0;let C=!1;const{points:T,edges:E}=flattenRingsAndEdges(_),{indexMap:M,points:w}=dedupPoints(T),I=dedupEdges(E,M);t=earcut$1.exports.flatten([w]);const P=createEdgePoint(w,I);try{i=cdt2d_1(w,I,{interior:!0,exterior:!1}).flat(),C=0===i.length,(C||this._useEarCut)&&(t=earcut$1.exports.flatten(_),i=earcut$1.exports(t.vertices,t.holes,t.dimensions))}catch(y){i=earcut$1.exports(t.vertices,t.holes,t.dimensions)}this.extrude&&this._enableBottomFace&&this.addGeoPolygonToVertices(t,i,this._zOffset,n.length/3,n,l,r,s,S,c,v,a,A,o,!0),this.addGeoPolygonToVertices(t,i,this._zOffset+b,n.length/3,n,l,r,s,S,c,v,a,A,o),this.extrude&&b>0&&this.addSideFace(P,b,h.length/3,h,g,u,d,f,v,p,A,m)}const A=l.length;let v=n.length/3;for(let x=0;x<g.length;x++)g[x]+=v;pushInBatches(n,h),pushInBatches(r,u),pushInBatches(c,f),pushInBatches(s,d),pushInBatches(o,m),pushInBatches(l,g),pushInBatches(a,p),this.cachedPositions=n,this.cachedObjectIndices=a,this.setAttribute("position",new three.Float32BufferAttribute(n,3)),this.parameters.vertexColors&&this.setAttribute("aColor",new three.Float32BufferAttribute(c,4)),this._useUV?this.setAttribute("uv",new three.Float32BufferAttribute(s,2)):this.deleteAttribute("uv"),this.setAttribute("heightAndConcave",new three.Float32BufferAttribute(o,2)),this.setAttribute("normal",new three.Float32BufferAttribute(r,3)),this.setIndex(l),this.clearGroups(),this.addGroup(0,A,1),this.extrude&&this.addGroup(A,l.length-A,0),this.computeBoundingSphere(),this._needsUpdate=!1}_calculateHeights(e,t,i){const[n,r]=[e[2]||0,t[2]||0],s=this._zOffset||0,a=this.perPositionHeight;return{bottom:s+(a?n:0),nextBottom:s+(a?r:0),top:n+s+i,nextTop:r+s+i}}_calculateNormal(e,t){const i=t[0]-e[0],n=t[1]-e[1],r=Math.hypot(i,n);return[n/r,-i/r,0]}computeWallGeometry3D(e,t,i,n,r,s,a,o){let l,c,h,u,d,p=e.length;const m=CesiumMath.chordLength(n,i.maximumRadius);let f=0;for(h=0;h<p;h++)f+=this.subdivideLineCount(e[h],e[(h+1)%p],m);const g=f+p;c=3*g,l=new Array(2*c);const _=[],A=[],v={bottom:[],top:[]};let y=0,x=0;for(h=0;h<p+1;h++){u=e[h],d=e[(h+1)%p],this.perPositionHeight&&(y=a[h],x=a[(h+1)%p]);let n=h===p?0:h,r=h===p-1?0:n+1;if(t[0===h?p-1:h-1].toArray(scratchPrevPoint),t[n].toArray(scratchPoint),t[r].toArray(scratchNextPoint),this._pushHeightAndConcave(v,s,h,scratchPrevPoint,scratchPoint,scratchNextPoint,p+1),h===p)continue;const{topPositions:l,bottomPositions:c}=this.subdivideLine(u,d,y,x,o,m,i,s,v);_.push(...c),A.push(...l)}l=[..._,..._];const b=[...v.top,...v.bottom];p=l.length;let S=[],C=0;for(p/=6,h=0;h<p;h++){const e=h,t=e+1,i=e+p,n=i+1;u=p1Scratch$2.fromArray(l,3*e),d=p2Scratch$1.fromArray(l,3*t),Cartesian3.equalsEpsilon(u,d,CesiumMath.EPSILON10,CesiumMath.EPSILON10)||(S[C++]=e+r,S[C++]=i+r,S[C++]=t+r,S[C++]=t+r,S[C++]=i+r,S[C++]=n+r)}l=[...A,..._],p=A.length/3;const T=[];T.length=l.length;const E=[];E.length=4*p;let M=new three.Vector3,w=new three.Vector3,I=new three.Vector3,P=!0,R=new three.Vector3;const B=[];let D=0;for(h=0;h<g;h++){M.fromArray(A,3*h),w.fromArray(_,3*h),I.fromArray(A,3*(h+1));const e=i.cartesianToCartographic(M).z,t=i.cartesianToCartographic(w).z;let n=2*h,r=2*(h+c/3);if(void 0===I.x?(E[n]=D,E[n+1]=e,E[r]=D,E[r+1]=t):(B.push(M.distanceTo(I)),E[n]=D,E[n+1]=e,E[r]=D,E[r+1]=t,D+=B[h]),(Cartesian3.equalsEpsilon(M,I,CesiumMath.EPSILON10)||h===g-1)&&(P=!1),P){const e=Cartesian3.subtract(I,M,scratchCartesian3Position4$1),t=Cartesian3.subtract(w,M,scratchCartesian3Position1$1);R=Cartesian3.normalize(Cartesian3.cross(t,e,R),R)}let s=3*h,a=3*h+c;T[s]=R.x,T[s+1]=R.y,T[s+2]=R.z,T[a]=R.x,T[a+1]=R.y,T[a+2]=R.z,P=!0}return{edgePositions:l,edgeIndices:S,edgeNormals:T,edgeUvs:E,edgeHeightAndConcaves:b,totalDistance:Array.from({length:2*g},(()=>D))}}get extrude(){return this._extrude}set extrude(e){const t=!!e;t!==this._extrude&&(this._extrude=t,this._needsUpdate=!0)}get extrudeValue(){return this._extrudeValue}set extrudeValue(e){!isNaN(e)&&e>=0&&e!==this._extrudeValue&&(this._extrudeValue=e,this._needsUpdate=!0)}get sideUVNormalized(){return this._sideUVNormalized}set sideUVNormalized(e){e!==this._sideUVNormalized&&(this._extrude&&(this._needsUpdate=!0),this._sideUVNormalized=e)}get sideUVReversed(){return this._sideUVReversed}set sideUVReversed(e){e!==this._sideUVReversed&&(this._extrude&&(this._needsUpdate=!0),this._sideUVReversed=e)}get sideUVUseHeight(){return this._sideUVUseHeight}set sideUVUseHeight(e){e!==this._sideUVUseHeight&&(this._extrude&&(this._needsUpdate=!0),this._sideUVUseHeight=e)}get useUV(){return this._useUV}set useUV(e){e!==this._useUV&&(this._needsUpdate=!0,this._useUV=e)}get needsUpdate(){return this._needsUpdate}set needsUpdate(e){this._needsUpdate=e}set useEarCut(e){this._useEarCut!==e&&(this._useEarCut=e)}}function flattenRingsAndEdges(e){const t=[],i=[];let n=0;for(let r=0;r<e.length;r++){const s=e[r],a=n;for(let e=0;e<s.length;e++)t.push(s[e]),e>0&&i.push([n+e-1,n+e]);i.push([n+s.length-1,a]),n+=s.length}return{points:t,edges:i}}const vertexShader$f="#define GLSLIFY 1\n#include <common>\n#include <fog_pars_vertex>\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n    uniform float mapScale;\n#endif\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n    varying vec4 vColor;\n#endif\n\nuniform float normalOffset;\n\n#if defined(USE_AO) || defined(MVT_HEIGHT_EXTRUSION)\nattribute vec2 heightAndConcave;\n#endif\n\n#ifdef USE_AO\nvarying float v_concave;\nvarying float v_h;\nvarying float v_ground;\n#endif\n\n#ifdef MVT_HEIGHT_EXTRUSION\nuniform float heightExtrusion;\nuniform vec3 zNormal;\n#endif\n\n#include <normal_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_selective_pars_vertex>\n\nvoid main() {\n\n    #include <mvt_selective_vertex>\n\n    #ifdef USE_MAP\n        vUv = uv / mapScale;\n    #endif\n\n     #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #endif\n\n    #include <begin_vertex>\n\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <normal_vertex>\n\n    #if defined(USE_AO) || defined(MVT_HEIGHT_EXTRUSION)\n    float encodeConcave = heightAndConcave.y;\n    float ground = mod(encodeConcave, 2.0);\n    #if defined(MVT_HEIGHT_EXTRUSION)\n    if (ground < 0.5) {\n        transformed.xyz += zNormal * heightExtrusion;\n    }\n    #endif\n    #endif\n\n    vec4 viewCoord = modelViewMatrix * vec4( transformed, 1.0 );\n    viewCoord.xyz += normalize(transformedNormal) * 0.0;\n\n    #ifdef USE_AO\n    v_h = heightAndConcave.x;\n    v_ground = ground;\n    float concave = mod(floor(encodeConcave * 0.5), 2.0);\n    float start = mod(floor(encodeConcave * 0.25), 2.0);\n    concave = pow(concave, 2.2);\n    v_concave = mix(concave, -concave, start);\n    #endif\n\n    gl_Position = projectionMatrix * viewCoord;\n    #include <fog_vertex>\n    #include <logdepthbuf_vertex>\n\n}\n\n",fragmentShader$d="#define GLSLIFY 1\n#include <common>\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n    uniform sampler2D map;\n    uniform vec2 mapLength;\n#endif\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec3 color;\n#endif\n\nuniform float opacity;\nuniform vec4 backgroundColor;\n\n#ifdef USE_AO\nuniform float concaveIntensity;\nuniform float heightIntensity;\n\nvarying float v_concave;\nvarying float v_ground;\nvarying float v_h;\n#endif\n\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_selective_pars_fragment>\n\nvoid main() {\n\n    vec4 mapColor = vec4(1.0);\n    #ifdef USE_MAP\n        mapColor = texture2D(map, vUv / mapLength);\n    #endif\n\n    vec4 baseColor;\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        baseColor = vColor;\n    #else\n        baseColor = vec4(color, 1.0);\n    #endif\n\n    gl_FragColor = mapColor * baseColor;\n\n    vec4 fg = gl_FragColor;\n    vec4 bg = backgroundColor;\n\n    float outA = fg.a + bg.a * (1.0 - fg.a);\n\n    vec3 outRGB = (fg.rgb * fg.a + bg.rgb * bg.a * (1.0 - fg.a)) / max(outA, 1e-5);\n\n    gl_FragColor = vec4(outRGB, outA);\n\n    gl_FragColor.a *= opacity;\n\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n\n    #if ( NUM_DIR_LIGHTS > 0 )\n        // 根据方向光的方向与法向，来计算颜色衰减程度，值范围为-1~1，给重映射到0.8~1的范围\n        float normalLightIntensity = dot(vNormal, directionalLights[0].direction);\n        gl_FragColor = vec4(gl_FragColor.rgb * (normalLightIntensity / 10.0 + 0.9), gl_FragColor.a);\n    #endif\n\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #ifdef USE_AO\n    float ao_shade = 1.0;\n    float concave = v_concave * v_concave;\n    float intensity = concaveIntensity;\n    float x_shade = mix(1.0, mix(0.6, 0.75, min(0.01, 1.0)), intensity) + 0.1 * intensity;\n    ao_shade *= mix(1.0, x_shade * x_shade * x_shade, concave);\n\n    intensity = heightIntensity;\n    float h_floors = v_h / 3.0;\n    float y_shade = 1.0 - 0.9 * intensity * min(v_ground, 1.0);\n    ao_shade *= (1.0 - 0.08 * intensity) * (y_shade + (1.0 - y_shade) * (1.0 - pow(1.0 - min(h_floors / 16.0, 1.0), 16.0))) + 0.08 * intensity * min(h_floors / 160.0, 1.0);\n\n    gl_FragColor.rgb *= ao_shade;\n    #endif\n\n    #include <mvt_selective_fragment>\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}\n\n",textureLoader$4=new three.TextureLoader,uniforms$g=three.UniformsUtils.merge([three.UniformsLib.fog,three.UniformsLib.lights,selectiveUniforms,emissiveUniforms,{isEmissive:{value:!1},opacity:{value:1},color:{value:[1,1,1]},vertexColors:{value:!1},map:{value:void 0},mapLength:{value:new three.Vector2(1,1)},mapSrc:{value:""},mapScale:{value:1},normalOffset:{value:0},concaveIntensity:{value:.2},heightIntensity:{value:.4},backgroundColor:{value:new three.Vector4(0,0,0,0)},heightExtrusion:{value:0},zNormal:{value:new three.Vector3(0,0,1)}}]);class PolygonMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="PolygonMaterial",this.isPolygonMaterial=!0,this.lights=!0,this.fog=!0,this.fragmentShader=fragmentShader$d,this.vertexShader=vertexShader$f,this.autoLength=e.autoLength||!0,Object.defineProperty(this,"mapSrc",{get:function(){return this.uniforms.map.value},set:function(e){const t=this.mapSrc,i=this.userData[this.urlCacheKey],n=this;if(i!==e){if(t&&t.dispose(),!e)return this.uniforms.map.value=null,delete this.defines.USE_MAP,void delete this.userData[this.urlCacheKey];textureLoader$4.load(e,(function(t){t.colorSpace=three.SRGBColorSpace,t.wrapS=t.wrapT=three.RepeatWrapping,n.uniforms.map.value=t,n.autoLength&&n.uniforms.mapLength.value.set(t.image.naturalWidth,t.image.naturalHeight),n.userData[n.urlCacheKey]=e,n.defines.USE_MAP=!0,n.needsUpdate=!0}))}}}),Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$g)),e.mapSrc&&(this.mapSrc=e.mapSrc,delete e.mapSrc),defineMaterialNormalProperties(this,["opacity","mapScale","isEmissive","normalOffset","concaveIntensity","heightIntensity","heightExtrusion","zNormal"]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["useAO","USE_AO"],["useHeightExtrusion","MVT_HEIGHT_EXTRUSION"]]),defineMaterialSelectiveProperties(this),defineMaterialEmissiveProperties(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}get backgroundColor(){return this.uniforms.backgroundColor.value}set backgroundColor(e){const t=colorToArr4(e);this.uniforms.backgroundColor.value.set(t[0],t[1],t[2],t[3])}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const vertexShader$e="#define GLSLIFY 1\n#include <common>\n#include <fog_pars_vertex>\n\n#ifdef USE_MAP\n    varying vec4 vSouthWestCorner;\n    varying vec2 vInversePlaneExtents;\n\n    uniform float mapScale;\n    uniform vec4 rectBounds;\n#else\n    #ifdef MVT_USE_VERTEX_COLOR\n        attribute vec4 aColor;\n        varying vec4 vColor;\n    #endif\n#endif\n\nuniform float normalOffset;\n\n#include <normal_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_selective_pars_vertex>\n\n// 模拟glDepthClamp,解决ZFail的远平面被视锥体所裁剪的问题\n#if !defined( USE_LOGDEPTHBUF )\n    varying float vWindowZ;\n#endif\n\nvec4 depthClamp(vec4 coords) {\n    #if !defined( USE_LOGDEPTHBUF )\n        vWindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;\n\n        coords.z = 0.0; \n    #else \n        coords.z = min(coords.z, coords.w);\n    #endif\n\n    return coords;\n}\n\nvoid main() {\n\n    #include <mvt_selective_vertex>\n\n    #ifdef USE_MAP\n        float eastExtend = rectBounds.z - rectBounds.x;\n        float northExtend = rectBounds.w - rectBounds.y;\n\n        vInversePlaneExtents = vec2(1.0 / eastExtend, 1.0 / northExtend);\n        vSouthWestCorner = modelMatrix * vec4(rectBounds.xy, 0.0, 1.0);\n    #else\n        #ifdef MVT_USE_VERTEX_COLOR\n            vColor = aColor;\n        #endif\n    #endif\n\n    #include <begin_vertex>\n\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <normal_vertex>\n\n    vec4 viewCoord = modelViewMatrix * vec4( transformed, 1.0 );\n    viewCoord.xyz += normalize(transformedNormal) * normalOffset;\n\n    gl_Position = projectionMatrix * viewCoord;\n    #include <fog_vertex>\n    #include <logdepthbuf_vertex>\n\n    gl_Position = depthClamp(gl_Position);\n\n}",fragmentShader$c="#define GLSLIFY 1\n#include <common>\n\n#include <packing>\n\nvarying vec4 vSouthWestCorner;\nvarying vec2 vInversePlaneExtents;\nuniform mat4 inverseProjection;\nuniform sampler2D depthTexture;\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 viewInverseMatrix;\nuniform float pixelRatio;\n\n#ifdef USE_MAP\n    uniform sampler2D map;\n#endif\n\nfloat linearize_depth(in float depth, in float cameraNear, in float cameraFar){\n    float a = cameraFar / (cameraFar - cameraNear);\n    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n    return a + b / depth;\n}\n\nfloat reconstruct_depth(sampler2D tDepth, const in vec2 uv, in float cameraNear, in float cameraFar){\n    float depth = texture2D(tDepth, uv).x;\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat getDepthFromTexture(sampler2D tDepth, vec2 uv) {\n    #if defined( USE_LOGDEPTHBUF )\n        return linearize_depth(reconstruct_depth(tDepth, uv, cameraNear, cameraFar), cameraNear, cameraFar);\n    #else\n        return texture2D(tDepth, uv).x;\n    #endif\n}\n\nvec3 getWorldPositionFromDepth(float depth, vec2 vUV) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(vUV * 2.0 - 1.0, z, 1.0);\n\n    vec4 viewSpacePosition = inverseProjection * clipSpacePosition;\n    \n    vec4 worldSpacePosition = viewInverseMatrix * viewSpacePosition;\n\n    return worldSpacePosition.xyz / worldSpacePosition.w;\n}\n\n#ifdef USE_NORMAL\n\n    vec3 vectorFromOffset(vec3 worldCoordinate, vec2 positiveOffset) {\n        vec2 glFragCoordXY = gl_FragCoord.xy;\n        // Sample depths at both offset and negative offset\n        float upOrRightLogDepth = getDepthFromTexture(depthTexture, (glFragCoordXY + positiveOffset) / resolution.xy / pixelRatio);\n        float downOrLeftLogDepth = getDepthFromTexture(depthTexture, (glFragCoordXY - positiveOffset) / resolution.xy / pixelRatio);\n        // Explicitly evaluate both paths\n        // Necessary for multifrustum and for edges of the screen\n        bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, resolution.xy * pixelRatio);\n        float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y);\n        float useDownOrLeft = float(useUpOrRight == 0.0);\n\n        vec3 upOrRightEC = getWorldPositionFromDepth(upOrRightLogDepth, (glFragCoordXY + positiveOffset) / resolution.xy / pixelRatio);\n        vec3 downOrLeftEC = getWorldPositionFromDepth(downOrLeftLogDepth, (glFragCoordXY - positiveOffset) / resolution.xy / pixelRatio);\n        return (upOrRightEC - worldCoordinate.xyz) * useUpOrRight + (worldCoordinate.xyz - downOrLeftEC) * useDownOrLeft;\n    }\n\n#endif\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec3 color;\n#endif\n\nuniform float opacity;\n\n// 模拟glDepthClamp\n#if !defined( USE_LOGDEPTHBUF )\nvarying float vWindowZ;\n\nvoid writeDepthClamp() {\n    \n    gl_FragDepthEXT = clamp(vWindowZ * gl_FragCoord.w, 0.0, 1.0);\n    \n}\n#endif\n\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_selective_pars_fragment>\n\nvoid main() {\n    vec2 coordUV = gl_FragCoord.xy / resolution / pixelRatio;\n    float depth = getDepthFromTexture(depthTexture, coordUV);\n    vec3 worldCoordinate = getWorldPositionFromDepth(depth, coordUV);\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        gl_FragColor = vColor;\n    #else\n        gl_FragColor = vec4(color, 1.0);\n    #endif\n\n    #ifdef USE_MAP\n\n        vec2 fragUv = vec2(0.0);\n        fragUv.x = (worldCoordinate.x - vSouthWestCorner.x) * vInversePlaneExtents.x;\n        fragUv.y = (worldCoordinate.y - vSouthWestCorner.y) * vInversePlaneExtents.y;\n\n        vec4 mapColor = texture2D(map, fragUv);\n\n        vec3 fragColor = vec3(0.0);\n        #ifdef MVT_USE_VERTEX_COLOR\n            mapColor *= vColor;\n        #else\n            mapColor *= vec4(color, 1.0);\n        #endif\n\n        gl_FragColor = mapColor;\n    #endif\n\n    #ifdef USE_NORMAL\n        // Compute normal by sampling adjacent pixels in 2x2 block in screen space\n        vec3 downUp = vectorFromOffset(worldCoordinate, vec2(0.0, 1.0));\n        vec3 leftRight = vectorFromOffset(worldCoordinate, vec2(1.0, 0.0));\n        vec3 normalWC = normalize(cross(leftRight, downUp));\n    #endif\n\n    gl_FragColor.a *= opacity;\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #if !defined( USE_LOGDEPTHBUF ) \n        vFragDepth = writeDepthClamp();\n    #endif\n\n    #include <mvt_selective_fragment>\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n\n}",textureLoader$3=new three.TextureLoader,uniforms$f=three.UniformsUtils.merge([three.UniformsLib.fog,three.UniformsLib.lights,selectiveUniforms,emissiveUniforms,{isEmissive:{value:!1},opacity:{value:1},color:{value:new three.Vector3(1,1,1)},vertexColors:{value:!1},useNormal:{value:!1},map:{value:void 0},mapLength:{value:new three.Vector2},mapSrc:{value:""},mapScale:{value:1},normalOffset:{value:0},rectBounds:{value:new three.Vector4(0,0,0,0)},inverseProjection:{value:new three.Matrix4},depthTexture:{value:null},cameraNear:{value:0},cameraFar:{value:0},viewInverseMatrix:{value:new three.Matrix4},cameraProjectionMatrix:{value:new three.Matrix4}}]);class ShadowVolumeMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="ShadowVolumeMaterial",this.isShadowMaterial=!0,this.lights=!0,this.fog=!0,this.fragmentShader=fragmentShader$c,this.vertexShader=vertexShader$e,Object.defineProperty(this,"mapSrc",{get:function(){return this.uniforms.map.value},set:function(e){const t=this.mapSrc,i=this.userData[this.urlCacheKey],n=this;if(i!==e){if(t&&t.dispose(),!e)return this.uniforms.map.value=null,delete this.defines.USE_MAP,void delete this.userData[this.urlCacheKey];textureLoader$3.load(e,(function(t){t.colorSpace=three.SRGBColorSpace,n.uniforms.map.value=t,n.uniforms.mapLength.value=new three.Vector2(t.image.naturalWidth,t.image.naturalHeight),n.userData[n.urlCacheKey]=e,n.defines.USE_MAP=!0,n.needsUpdate=!0}))}}}),Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$f)),e.mapSrc&&(this.mapSrc=e.mapSrc,delete e.mapSrc),defineMaterialNormalProperties(this,["opacity","mapScale","isEmissive","normalOffset","rectBounds"]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["useNormal","USE_NORMAL"]]),defineMaterialSelectiveProperties(this),defineMaterialEmissiveProperties(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}const sharedResources={},_tempCenter=new three.Vector3,_tempNormal=new three.Vector3;class Polygon extends GeoMesh{constructor(e={}){super(),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"extrude"),__publicField(this,"extrudeValue"),__publicField(this,"color"),__publicField(this,"vertexColors"),__publicField(this,"emissive"),__publicField(this,"opacity"),__publicField(this,"mapScale"),this.isPolygon=!0,this.parameters=e,this._nearScale=e.nearScale||5,this.isGroundPrimitive=e.isGroundPrimitive,this.isDynamic=e.isDynamic||!1,this.needReMapUv=this.isGroundPrimitive,this.excludeElements=e.excludeElements||[],this._sharedResourcesId=this.getSharedResourceFromExcludeElement(this.excludeElements),this.renderOrder=e.renderOrder||0,this.defineGeometryProxyProperties(["extrude","extrudeValue","vertexHeights","enableBottomFace","zOffset","perPositionHeight"]),this.defineMaterialProxyProperties(["transparent","opacity","color","vertexColors","emissive","mapScale","side","depthWrite","colorWrite","stencilWrite","stencilFunc","stencilZFail","stencilZPass","normalOffset","useNormal","useAO","concaveIntensity","heightIntensity"])}initObject(){const{extrude:e,extrudeValue:t,vertexHeights:i,enableBottomFace:n,zOffset:r,...s}=this.parameters;(this.geometry=new PolygonGeometry(this.parameters)).engine=this.engine;let a=null;if(this.isGroundPrimitive){if(a=this.material=new ShadowVolumeMaterial(s),this.needReMapUv){const e=this._sharedResourcesId,t=sharedResources[e];if(t){const{depthTexture:e,depthRenderTarget:i}=t;t.refCount++,this.depthRenderTarget=i,a.uniforms.depthTexture.value=e}else{const t=this.engine.rendering.resolution,i=this.engine.rendering.pixelRatio,n=this.depthRenderTarget=new three.WebGLRenderTarget(t.x*i,t.y*i),r=new three.DepthTexture;r.type=three.UnsignedInt248Type,n.depthTexture=r,a.uniforms.depthTexture.value=r,sharedResources[e]={depthRenderTarget:n,depthTexture:r,refCount:1,lastRenderFrame:-1}}}}else a=this.material=new PolygonMaterial(s);a.setCommonUniforms(this.engine.rendering.uniforms)}onBeforeSceneRenderHook(e,t,i,n){if(!this.needReMapUv)return;const r=n.frameCount,s=sharedResources[this._sharedResourcesId];if(s){if(s.lastRenderFrame!==r){const n=e.renderer;n.setRenderTarget(this.depthRenderTarget);let r=[];t.traverse((e=>{(e.isGroundPrimitive||this.excludeElements.includes(e))&&(e.originVisible=e.visible,e.visible=!1,r.push(e))}));let s=i.near;i.near=s*this.nearScale,i.updateProjectionMatrix(),n.render(t,i);for(let e=0;e<r.length;e++)r[e].visible=r[e].originVisible;this.material.uniforms.cameraNear.value=i.near,this.material.uniforms.cameraFar.value=i.far,this.material.uniforms.viewInverseMatrix.value.copy(i.matrixWorld),this.material.uniforms.pixelRatio.value=e.rendering.pixelRatio,this.material.uniforms.inverseProjection.value.copy(i.projectionMatrixInverse.clone()),i.near=s,i.updateProjectionMatrix(),n.setRenderTarget(null)}else{let t=i.near;i.near=t*this.nearScale,i.updateProjectionMatrix(),this.material.uniforms.cameraNear.value=i.near,this.material.uniforms.cameraFar.value=i.far,this.material.uniforms.viewInverseMatrix.value.copy(i.matrixWorld),this.material.uniforms.pixelRatio.value=e.rendering.pixelRatio,this.material.uniforms.inverseProjection.value.copy(i.projectionMatrixInverse.clone()),i.near=t,i.updateProjectionMatrix()}s.lastRenderFrame=r}}_updateData(){let e=this.dataSource.data;if(this.geometry.setData(e),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox(),this.needsUpdate=!1,this.needReMapUv){const e=this.computeRectangleBounds();this.material.rectBounds.fromArray(e)}if(this.material.zNormal){const e=this.getNormal();this.material.zNormal.copy(e)}this.needsUpdate=!1}getNormal(){if(this.engine.map.isGlobe){const e=_tempCenter.fromArray(this._cachedRtc);Ellipsoid.WGS84.geodeticSurfaceNormal(e,_tempNormal)}else _tempNormal.set(0,0,1);return _tempNormal}computeRectangleBounds(){const e=this.geometry.attributes.position.array,t=e.length;let i=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY;for(let a=0;a<t;a+=3){const t=e[a],o=e[a+1];i=Math.min(i,t),r=Math.min(r,o),n=Math.max(n,t),s=Math.max(s,o)}return[i,r,n,s]}afterGeometryUpdate(){this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox()}getEntityIndexByFace(e,t){return this.geometry.cachedObjectIndices[t]}getSharedResourceFromExcludeElement(e){let t="";if(e.length>0){t=e.map((e=>e.uuid)).join("-")}return t}dispose(){if(this.needReMapUv){const e=sharedResources[this._sharedResourcesId];if(e&&(e.refCount--,0===e.refCount)){const{depthRenderTarget:t,depthTexture:i}=e;t.dispose(),i.dispose(),delete sharedResources[this._sharedResourcesId]}}super.dispose()}get nearScale(){return this._nearScale}set nearScale(e){this._nearScale=e}get mapSrc(){return this.material.mapSrc}set mapSrc(e){this.material.mapSrc=e,this.geometry&&e&&(this.geometry.useUV=!0)}}Polygon.prototype.raycast=three.Mesh.prototype.raycast,Polygon.prototype._computeIntersections=three.Mesh.prototype._computeIntersections,Polygon.prototype.getVertexPosition=three.Mesh.prototype.getVertexPosition;class DistrictLayer extends three.EventDispatcher{constructor(e={}){super();const t=e.renderOptions||{};this.renderOptions=t,this.apiSource=e.apiSource||getApiSource(),this.options=e,this.autoViewport=t.autoViewport||!1,this._distrctLayer=this._createInstance(e),t.engine&&(this._engine=t.engine,this._fillColor=t.fillColor||"#ff0",this._fillOpacity=t.fillOpacity||.6),this._loadDistrict()}async _loadDistrict(){this._distrctLayer&&this._distrctLayer._loadDistrict&&(this._data=await this._distrctLayer._loadDistrict(),this._engine&&(this.renderMap(),this.dispatchEvent({type:"renderComplete",results:this._data,target:this}),this.autoViewport&&this._data&&this._flyToDistrict()))}_calculateBounds(){if(!this._data||!this._data.features)return null;let e=1/0,t=-1/0,i=1/0,n=-1/0;this._data.features.forEach((r=>{if(r.geometry&&r.geometry.coordinates){const s=r.geometry.coordinates;this._flattenCoordinates(s).forEach((([r,s])=>{e=Math.min(e,r),t=Math.max(t,r),i=Math.min(i,s),n=Math.max(n,s)}))}}));return{center:[(e+t)/2,(i+n)/2],bounds:{minLng:e,maxLng:t,minLat:i,maxLat:n}}}_flattenCoordinates(e){const t=[];return function e(i){for(const n of i)Array.isArray(n[0])?e(n):t.push(n)}(e),t}_flyToDistrict(){const e=this._calculateBounds();if(!e||!this._engine.map||!this._engine.map.flyTo)return;const{center:t,bounds:i}=e,n=[[i.minLng,i.minLat],[i.maxLng,i.maxLat],[i.minLng,i.maxLat],[i.maxLng,i.minLat]];this._engine.map.setViewport(n,{range:0})}renderMap(){var e;const t=this._data;if(this._layer)return void this._layer.dataSource.setData(t);const{engine:i,fillColor:n,fillOpacity:r,autoViewport:s,...a}=this.renderOptions;if(null!==this._fillColor){const n=i.add(new Polygon({vertexColors:!0,transparent:!0,opacity:null!=(e=this._fillOpacity)?e:1,...a})),r=GeoJSONDataSource.fromGeoJSON(t);r.defineAttribute("color",(e=>{if(Array.isArray(this._fillColor)){const e=Math.floor(Math.random()*this._fillColor.length);return this._fillColor[e]}return this._fillColor})),n.dataSource=r,this._layer=n}}reset(){this._layer&&(this._engine.remove(this._layer),this._layer=null)}setName(e){this._distrctLayer.setName(e),this._loadDistrict()}setKind(e){this._distrctLayer.setKind(e),this._loadDistrict()}setOptions(e){this._distrctLayer.setOptions(e),this._loadDistrict()}_createInstance(e){return new({[API_SOURCE_BAIDU]:DistrictLayer_Bd,[API_SOURCE_TIANDITU]:DistrictLayer_Tdt}[this.apiSource]||DistrictLayer_Bd)(e)}searchBoundary(e,t){this._distrctLayer.searchBoundary&&this._distrctLayer.searchBoundary(e,t)}}class BaseRoute{constructor(e={}){__publicField(this,"result",null),__publicField(this,"_polylines",[]),__publicField(this,"_markers",[]),e.renderOptions=e.renderOptions||{},this.options=e}async search(e,t,i){if(this.clearResult(),this._dw)return this.result=await this._dw.search(e,t,i),this._engine&&this.renderMap(this.result),this.result}renderMap(e){const t=this._engine;if(this.clearMap(),this.renderPly(e),this.renderMkr(e),this.options.renderOptions.autoViewport){const i=[];for(let t=0;t<e.paths.length;t++){const n=e.paths[t];i.push(...n)}for(let t=0;t<e.walkingPaths.length;t++){const n=e.walkingPaths[t];i.push(...n)}t.map.setViewport(i,{range:0})}}renderPly(e){const t=this._engine;for(let i=0;i<e.paths.length;i++){const n=e.paths[i],r=t.add(new Polyline({flat:!0,color:7846399,lineWidth:6,keepSize:!0,depthTest:!1}));r.renderOrder=100;const s=new DataSource;s.add(new DataItem(n)),r.dataSource=s,this._polylines.push(r)}for(let i=0;i<e.walkingPaths.length;i++){const n=e.walkingPaths[i],r=t.add(new Polyline({flat:!0,color:57088,lineWidth:6,keepSize:!0,depthTest:!1}));r.renderOrder=100;const s=new DataSource;s.add(new DataItem(n)),r.dataSource=s,this._polylines.push(r)}}renderMkr(e){const t=this._engine,i=t.add(new Marker({point:e.start.point,icon:getAssetUrl("assets/images/markers/mkr_start.png"),width:26,height:41,offset:[0,-16]})),n=t.add(new Marker({point:e.end.point,icon:getAssetUrl("assets/images/markers/mkr_end.png"),width:26,height:41,offset:[0,-16]}));this._markers.push(i,n);for(let r=0;r<e.waypoints.length;r++){const i=e.waypoints[r],n=t.add(new Marker({point:i.point,icon:getAssetUrl("assets/images/markers/mkr_waypoint.png"),width:26,height:41,offset:[0,-16]}));this._markers.push(n)}}clearMap(){if(this._engine){const e=this._engine;for(let t=0;t<this._polylines.length;t++){const i=this._polylines[t];e.remove(i)}for(let t=0;t<this._markers.length;t++){const i=this._markers[t];e.remove(i)}this._markers=[],this._polylines=[]}}getResult(){return this.result}clearResult(){this.result=null}}class RouteResult{constructor(e={}){this.start=e.start||{},this.end=e.end||{},this.waypoints=e.waypoints||[],this.distance=e.distance||0,this.duration=e.duration||0,this.steps=e.steps||[],this.paths=e.paths||[],this.walkingPaths=e.walkingPaths||[],this.type=e.type||""}}const _tempVec3=new three.Vector3;class DWRoute_Bd{constructor(e={}){__publicField(this,"_formatCoordYXString",((e,t)=>{let i;return t=t||{},"string"==typeof e?i=e:e.isVector2||e.isVector3?i=e.y.toFixed(6)+","+e.x.toFixed(6):Array.isArray(e)?i=e[1].toFixed(6)+","+e[0].toFixed(6):e.point&&(i=this._formatCoordYXString(e.point,t)),i})),__publicField(this,"_isUid",(e=>/^[0-9a-f]{24}$/.test(e))),this.options=e,this._baiduMercatorProjection=getProjection(PROJECTION_BD_MERCATOR),this._d={plys:[],viaPts:[],viaPtsInfo:[],dragOverlays:[],tipLbl:null,sliderMkr:null,dragReqFlag:!1,cbkDragPt:null,cbkPly:null,isSearchByDrag:!1,curDragPly:null,dragSrcCityCode:1,dragEndCityCode:1,mouseOnViaMkr:!1,cxtMenu:[]}}async search(e,t,i){this._d.isSearchByDrag=!1;const n=this.route;i=i||{},this._searchOpts=i;let r=i.waypoints;Array.isArray(r)||(r=[]),this.waypoints=SUtil.pointsToString(r);let s=1;if(this._engine){const e=this._baiduMercatorProjection.projectCoordinate(_tempVec3.fromArray(this._engine.map.getCenter())).toArray(),t=i.zoom||this._engine.map.getZoom();let n=await SearchRequestMgr.request({qt:QUERY_TYPE_CENTER,b:e[0]+","+e[1]+";"+e[0]+","+e[1],l:t});n&&n.result&&n.result.type===RETURN_TYPE_CENTER&&(s=n.content?n.content.uid:1)}let a={qt:QUERY_TYPE_DIRECTION,output:"json",coord_type:"bd09ll",ret_coordtype:"bd09ll"},o={start:e,end:t};if(this._isUid(i.start_uid)&&(a.origin_uid=i.start_uid),this._isUid(i.end_uid)&&(a.destination_uid=i.end_uid),n.QUERY_TYPE===QUERY_TYPE_WALKING)a.origin=this._formatCoordYXString(e),a.destination=this._formatCoordYXString(t),a.region=s,a.mode="walking";else if(n.QUERY_TYPE===QUERY_TYPE_DRIVING){if("string"==typeof t||"string"==typeof e)return;a.origin=this._formatCoordYXString(e),a.destination=this._formatCoordYXString(t),a.mode="driving",a.waypoints=this.waypoints,a.tactics=this.options.policy||0,o.policy=a.tactics}else n.QUERY_TYPE===QUERY_TYPE_RIDING&&(a.origin=this._formatCoordYXString(e),a.destination=this._formatCoordYXString(t),a.region=s,a.mode="riding");let l=await SearchRequestMgr.request(a,o,"");const c=this._processRaw(l,o);return this._d.isSearchByDrag=!1,c}_processRaw(e,t){const i=this.route;let n=e.content.result,r={},s={};"object"!=typeof t.start||t.start.isVector2||t.start.isVector3||Array.isArray(t.start)?i.QUERY_TYPE===QUERY_TYPE_WALKING||i.QUERY_TYPE===QUERY_TYPE_RIDING?(r.title=n.origin.wd||"起点",r.uid=n.origin.uid,r.point=new three.Vector3(n.origin.originPt.lng,n.origin.originPt.lat,0),r.city=n.origin.cname):i.QUERY_TYPE===QUERY_TYPE_DRIVING&&(r.title="起点",r.point=new three.Vector3(n.routes[0].origin.lng,n.routes[0].origin.lat,0)):Object.assign(r,t.start),"object"!=typeof t.end||t.end.isVector2||t.end.isVector3||Array.isArray(t.end)?i.QUERY_TYPE===QUERY_TYPE_WALKING||i.QUERY_TYPE===QUERY_TYPE_RIDING?(s.title=n.destination.wd||"终点",s.uid=n.destination.uid,s.point=new three.Vector3(n.destination.destinationPt.lng,n.destination.destinationPt.lat,0),s.city=n.destination.cname):i.QUERY_TYPE===QUERY_TYPE_DRIVING&&(s.title="终点",s.point=new three.Vector3(n.routes[0].destination.lng,n.routes[0].destination.lat,0)):Object.assign(s,t.end);let a=[],o=[];this._d.viaPtsInfo.length=0,this._d.viaPts.length=0,this._d.plys.length=0;let l=1;if(n.waypoints)for(let p=0;p<n.waypoints.length;p++){let e=n.waypoints[p];if(e&&e.pos){let t=e.pos.split(",");t=new three.Vector3(+t[0],+t[1],0),t.if_wp=1,a.push(t),this._d.viaPtsInfo.push({title:"途经点"+l,curNo:l,point:t}),l++}}let c=[],h=[],u=n.routes,d={};if(i.QUERY_TYPE===QUERY_TYPE_WALKING||i.QUERY_TYPE===QUERY_TYPE_RIDING){let e=u[0],t=e.steps;for(let i=0;i<t.length;i++){let e=new three.Vector3(t[i].stepOriginLocation.lng,t[i].stepOriginLocation.lat,0),n={point:e,index:i,description:t[i].instructions,distance:t[i].distance};c.push(n);let r=SUtil.pathToPoints(t[i].path);r.unshift([e.x,e.y]),r.push([t[i].stepDestinationLocation.lng,t[i].stepDestinationLocation.lat]),h.push(...r)}this._d.plys.push(h),d=new RouteResult({start:r,end:s,waypoints:this._d.viaPtsInfo,distance:e.distance,duration:e.duration,steps:c,paths:[h],type:i.ROUTE_TYPE}),i.QUERY_TYPE===QUERY_TYPE_WALKING&&(d.walkingPaths=[h],d.paths=[])}else if(i.QUERY_TYPE===QUERY_TYPE_DRIVING){let e=u[0],t=e.steps;for(let i=0;i<t.length;i++){let e=new three.Vector3(t[i].start_location.lng,t[i].start_location.lat,0),n=i,r="",s=t[i].distance,a=t[i].leg_index,l={point:e,index:n,description:r,distance:s};c.push(l);let u=SUtil.pathToPoints(t[i].path);h.push(...u),o[a]||(o[a]=[]),o[a].push(...u)}for(let i=0;i<o.length;i++){let e=o[i];e.stNo=i,e.edNo=i+1,e.legIndex=i,this._d.plys.push(e)}let n=r.point;this._d.viaPts.push(n);for(let i=0,r=a.length;i<r;i++){let e=a[i];this._d.viaPts.push(e)}let l=s.point;this._d.viaPts.push(l),d=new RouteResult({start:r,end:s,waypoints:this._d.viaPtsInfo,distance:e.distance,duration:e.duration,steps:c,paths:o,type:i.ROUTE_TYPE})}return d}}const http$1="https:"===location.protocol?"https":"http";class DWRoute_Tdt{constructor(e={}){this.options=e}async search(e,t,i){const n=this.route;i=i||{},this._searchOpts=i;const r={mid:this._pointsToString(i.waypoints),orig:this._pointsToString(e),dest:this._pointsToString(t),style:0};let s=`${http$1}://api.tianditu.gov.cn/drive/?postStr=${JSON.stringify(r)}&type=search`,a=await ScriptLoader.request(s);if(a&&a.result){const e=a.result,t=e.orig.split(","),i=e.dest.split(","),r={point:new three.Vector3(t[0],t[1],0),title:"起点"},s={point:new three.Vector3(i[0],i[1],0),title:"终点"},o=e.mid.split(";");let l=[];if(e.mid){let e=1;for(let t=0;t<o.length;t++){if(!o[t])continue;const[i,n]=o[t].split(",");l.push({point:new three.Vector3(+i,+n,0),title:"途经点"+e,curNo:e}),e++}}const c=[],h=e.routelatlon.split(";");for(let n=0;n<h.length;n++){const e=h[n];if(!e)continue;const t=e.split(","),i=[+t[0],+t[1]];c.push(i)}return new RouteResult({start:r,end:s,waypoints:l,distance:e.distance,duration:e.duration,steps:e.routes.item,paths:[c],type:n.ROUTE_TYPE})}}_pointsToString(e){let t="";if("object"!=typeof e)return e;if(Array.isArray(e)&&("number"==typeof e[0]||"string"==typeof e[0]))return e.join(",");if(e.isVector2||e.isVector3)return e.x+","+e.y;for(let i=0;i<e.length;i++){let n=SUtil.getX(e[i])+","+SUtil.getY(e[i]);i!==e.length-1?t=t+n+";":t+=n}return t}}class DrivingRoute extends BaseRoute{constructor(e={}){super(e),__publicField(this,"QUERY_TYPE",QUERY_TYPE_DRIVING),__publicField(this,"RETURN_TYPE",RETURN_TYPE_DRIVING),__publicField(this,"ROUTE_TYPE",BMAP_ROUTE_TYPE_DRIVING),__publicField(this,"name","DrivingRoute"),__publicField(this,"apiSource"),__publicField(this,"_dw"),__publicField(this,"_engine"),this.apiSource=e.apiSource||getApiSource(),this._dw=this._createInstance(e),this._dw.route=this,this.options.renderOptions.engine&&(this._engine=this.options.renderOptions.engine,this._dw._engine=this._engine)}_createInstance(e){return new({[API_SOURCE_BAIDU]:DWRoute_Bd,[API_SOURCE_TIANDITU]:DWRoute_Tdt}[this.apiSource]||DWRoute_Bd)(e)}}class RidingRoute extends BaseRoute{constructor(e={}){super(e),__publicField(this,"QUERY_TYPE",QUERY_TYPE_RIDING),__publicField(this,"ROUTE_TYPE",BMAP_ROUTE_TYPE_RIDING),__publicField(this,"name","RidingRoute"),__publicField(this,"_dw"),__publicField(this,"_engine"),this._dw=new DWRoute_Bd(e),this._dw.route=this,this.options.renderOptions.engine&&(this._engine=this.options.renderOptions.engine,this._dw._engine=this._engine)}}new three.Vector3;const _TransitRoute_Bd=class{constructor(e={}){__publicField(this,"_formatCoordYXString",((e,t)=>{let i;return t=t||{},"string"==typeof e?i=e:e.isVector2||e.isVector3?i=e.y.toFixed(6)+","+e.x.toFixed(6):Array.isArray(e)?i=e[1].toFixed(6)+","+e[0].toFixed(6):e.point&&(i=this._formatCoordYXString(e.point,t)),i})),__publicField(this,"_isUid",(e=>/^[0-9a-f]{24}$/.test(e))),__publicField(this,"_getLineType",((e,t)=>{let i=0,n="";switch(i=t?_TransitRoute_Bd.LINE_TYPE_MAPPING_CROSS_CITY[e]:_TransitRoute_Bd.LINE_TYPE_MAPPING[e],i){case BMAP_LINE_TYPE_SUBWAY:n="subway";break;case BMAP_LINE_TYPE_TRAIN:n="train";break;case BMAP_LINE_TYPE_AIRPLANE:n="airplane";break;default:n="bus"}return n})),this.options=e,this._baiduMercatorProjection=getProjection(PROJECTION_BD_MERCATOR)}async search(e,t,i){if("string"==typeof t||"string"==typeof e)return;let n;i=i||{},n={qt:QUERY_TYPE_DIRECTION,mode:"transit",output:"json",coord_type:"bd09ll",ret_coordtype:"bd09ll"},n.origin=this._formatCoordYXString(e),n.destination=this._formatCoordYXString(t),n.tactics_incity=this.options.policy||0,n.trans_type_intercity=this.options.transitTypePolicy||0,n.tactics_intercity=this.options.intercityPolicy||0,this._isUid(i.start_uid)&&(n.origin_uid=i.start_uid),this._isUid(i.end_uid)&&(n.destination_uid=i.end_uid);let r={start:e,end:t,_from:"search",policy:n.tactics_incity,intercityPolicy:n.tactics_intercity,transitTypePolicy:n.trans_type_intercity},s=await SearchRequestMgr.request(n,r),a=s.result,o=s.content||{};if(0===a.error&&0===o.status&&o.type===DIRECTION_RETURN_TYPE_CLEAR){let e=o.result;if(null===e.routes||0===e.routes.length)return;return e.origin.city_id===e.destination.city_id||e.origin.city_name===e.destination.city_name?(s.content.transitType=BMAP_TRANSIT_TYPE_IN_CITY,this._processRawInCity(s,r)):(s.content.transitType=BMAP_TRANSIT_TYPE_CROSS_CITY,this._processRawCrossCity(s,r))}}_processRawInCity(e,t){const i=this.route;let n=e.content,r=n.result,s={},a={};"object"!=typeof t.start||t.start.isVector2||t.start.isVector3||Array.isArray(t.start)?(s.title="起点",s.city=r.origin.city_name,s.point=new three.Vector3(r.origin.location.lng,r.origin.location.lat,0)):Object.assign(s,t.start),"object"!=typeof t.end||t.end.isVector2||t.end.isVector3||Array.isArray(t.end)?(a.title="终点",a.city=r.destination.city_name,a.point=new three.Vector3(r.destination.location.lng,r.destination.location.lat,0)):Object.assign(a,t.end);let o=n.result.routes[0],l=o.distance,c=o.duration,h=o.steps,u=0,d=[],p=[],m=[];for(let f=0;f<h.length;f++){let e=h[f][0],t=[];if(t.push([+e.start_location.lng,+e.start_location.lat]),t=t.concat(SUtil.pathToPoints(e.path)),t.push([+e.end_location.lng,+e.end_location.lat]),e.vehicle_info.type===BMAP_VEHICLE_TYPE_WALKING){let i={distance:e.distance,points:t,rt:BMAP_ROUTE_TYPE_WALKING,index:u,planIndex:0};u++,d.push(i),p.push(t)}else if(e.vehicle_info.type===BMAP_VEHICLE_TYPE_BUS){let i=e.vehicle_info.detail,n={title:i.on_station,point:new three.Vector3(e.start_location.lng,e.start_location.lat,0)},r={title:i.off_station,point:new three.Vector3(e.end_location.lng,e.end_location.lat,0)},s={title:i.name,distance:e.distance,points:t,stops:[n,r],rt:BMAP_ROUTE_TYPE_TRANSIT,type:this._getLineType(i.type,!1),numViaStops:i.stop_num};d.push(s),m.push(t)}}return new RouteResult({start:s,end:a,distance:l,duration:c,steps:d,paths:m,walkingPaths:p,type:i.ROUTE_TYPE,transitType:e.content.transitType,intercityPolicy:t.intercityPolicy,transitTypePolicy:t.transitTypePolicy,policy:t.policy})}_processRawCrossCity(e,t){const i=this.route;let n=e.content,r=n.result,s={},a={};"object"!=typeof t.start||t.start.isVector2||t.start.isVector3||Array.isArray(t.start)?(s.title="起点",s.city=r.origin.city_name,s.point=new three.Vector3(r.origin.location.lng,r.origin.location.lat,0)):Object.assign(s,t.start),"object"!=typeof t.end||t.end.isVector2||t.end.isVector3||Array.isArray(t.end)?(a.title="终点",a.city=r.destination.city_name,a.point=new three.Vector3(r.destination.location.lng,r.destination.location.lat,0)):Object.assign(a,t.end);let o=n.result.routes[0],l=o.distance,c=o.duration,h=o.steps,u=0,d=[],p=[],m=[];for(let f=0;f<h.length;f++)for(let e=0;e<h[f].length;e++){let t=h[f][e],i=[];if(i.push([+t.start_location.lng,+t.start_location.lat]),i=i.concat(SUtil.pathToPoints(t.path)),i.push([+t.end_location.lng,+t.end_location.lat]),t.vehicle_info.type===BMAP_VEHICLE_TYPE_WALKING){let e={distance:t.distance,points:i,rt:BMAP_ROUTE_TYPE_WALKING,index:u,planIndex:0};u++,d.push(e),p.push(i)}else if(t.vehicle_info.type===BMAP_VEHICLE_TYPE_BUS){let e=t.vehicle_info.detail,n={title:e.on_station,point:new three.Vector3(t.start_location.lng,t.start_location.lat,0)},r={title:e.off_station,point:new three.Vector3(t.end_location.lng,t.end_location.lat,0)},s={title:e.name,distance:t.distance,points:i,stops:[n,r],rt:BMAP_ROUTE_TYPE_TRANSIT,type:this._getLineType(e.type),numViaStops:e.stop_num};d.push(s),m.push(i)}else if(t.vehicle_info.type===BMAP_VEHICLE_TYPE_TRAIN){let e=t.vehicle_info.detail,n={title:e.departure_station,point:new three.Vector3(t.start_location.lng,t.start_location.lat,0)},r={title:e.arrive_station,point:new three.Vector3(t.end_location.lng,t.end_location.lat,0)},s={title:e.name,distance:t.distance,points:i,stops:[n,r],rt:BMAP_ROUTE_TYPE_TRANSIT,type:this._getLineType(t.vehicle_info.type,!0)};d.push(s),m.push(i)}else if(t.vehicle_info.type===BMAP_VEHICLE_TYPE_AIRPLANE){let e=t.vehicle_info.detail,n={title:e.departure_station,point:new three.Vector3(t.start_location.lng,t.start_location.lat,0)},r={title:e.arrive_station,point:new three.Vector3(t.end_location.lng,t.end_location.lat,0)},s={title:e.name,distance:t.distance,points:i,stops:[n,r],rt:BMAP_ROUTE_TYPE_TRANSIT,type:this._getLineType(t.vehicle_info.type,!0)};d.push(s),m.push(i)}else if(t.vehicle_info.type===BMAP_VEHICLE_TYPE_COACH){let e=t.vehicle_info.detail,n={title:e.departure_station,point:new three.Vector3(t.start_location.lng,t.start_location.lat,0)},r={title:e.arrive_station,point:new three.Vector3(t.end_location.lng,t.end_location.lat,0)},s={title:e.name,distance:t.distance,points:i,stops:[n,r],rt:BMAP_ROUTE_TYPE_TRANSIT,type:this._getLineType(t.vehicle_info.type,!0)};d.push(s),m.push(i)}else if(t.vehicle_info.type===BMAP_VEHICLE_TYPE_DRIVING){let e={distance:t.distance,points:i,rt:BMAP_ROUTE_TYPE_DRIVING,index:u,planIndex:0};u++,d.push(e),m.push(i)}}return new RouteResult({start:s,end:a,distance:l,duration:c,steps:d,paths:m,walkingPaths:p,type:i.ROUTE_TYPE,transitType:e.content.transitType,policy:t.policy,intercityPolicy:t.intercityPolicy,transitTypePolicy:t.transitTypePolicy})}};let TransitRoute_Bd=_TransitRoute_Bd;__publicField(TransitRoute_Bd,"LINE_TYPE_MAPPING",[0,1,0,0,0,0,0,0,2,0,0,0,1,1,1]),__publicField(TransitRoute_Bd,"LINE_TYPE_MAPPING_CROSS_CITY",[0,3,4,0,0,0,5]);const http="https:"===location.protocol?"https":"http";class TransitRoute_Tdt{constructor(e={}){this.options=e}async search(e,t,i){const n=this.route;i=i||{},this._searchOpts=i;const r={startposition:this._pointsToString(e),endposition:this._pointsToString(t),linetype:1};let s=`${http}://api.tianditu.gov.cn/transit?postStr=${JSON.stringify(r)}&type=busline`,a=await ScriptLoader.request(s);if(a&&0===a.resultCode){const e={title:"起点"},t={title:"终点"},i=a.results[0].lines[0];let r=[],s=[],o=[];for(let n=0;n<i.segments.length;n++){const a=i.segments[n];if(0===n){let t=a.stationStart.lonlat.split(",");e.point=new three.Vector3(+t[0],+t[1],0)}if(n===i.segments.length-1){let e=a.stationEnd.lonlat.split(",");t.point=new three.Vector3(+e[0],+e[1],0)}const l=this._getSegmentType(a.segmentType);let c={type:l},h=[];const u=a.segmentLine[0].linePoint.split(";");for(let e=0;e<u.length;e++){const t=u[e];if(!t)continue;const i=t.split(","),n=[+i[0],+i[1]];h.push(n)}if("walking"===l)c.rt=BMAP_ROUTE_TYPE_WALKING,s.push(h);else if("bus"===l||"subway"===l){c.rt=BMAP_ROUTE_TYPE_TRANSIT,c.title=a.segmentLine[0].lineName;let e={title:a.stationStart.name,point:new three.Vector3(+a.stationStart.lonlat.split(",")[0],+a.stationStart.lonlat.split(",")[1],0)},t={title:a.stationEnd.name,point:new three.Vector3(+a.stationEnd.lonlat.split(",")[0],+a.stationEnd.lonlat.split(",")[1],0)};c.stops=[e,t],r.push(h)}o.push(c)}return new RouteResult({start:e,end:t,steps:o,paths:r,walkingPaths:s,type:n.ROUTE_TYPE})}}_pointsToString(e){let t="";if("object"!=typeof e)return e;if(Array.isArray(e)&&("number"==typeof e[0]||"string"==typeof e[0]))return e.join(",");if(e.isVector2||e.isVector3)return e.x+","+e.y;for(let i=0;i<e.length;i++){let n=SUtil.getX(e[i])+","+SUtil.getY(e[i]);i!==e.length-1?t=t+n+";":t+=n}return t}_getSegmentType(e){let t="";switch(e){case 1:case 4:default:t="walking";break;case 2:t="bus";break;case 3:t="subway"}return t}}class TransitRoute extends BaseRoute{constructor(e={}){super(e),__publicField(this,"QUERY_TYPE",QUERY_TYPE_TRANSIT),__publicField(this,"RETURN_TYPE",RETURN_TYPE_TRANSIT),__publicField(this,"ROUTE_TYPE",BMAP_ROUTE_TYPE_TRANSIT),__publicField(this,"name","TransitRoute"),__publicField(this,"apiSource"),__publicField(this,"_dw"),__publicField(this,"_engine"),this.apiSource=e.apiSource||getApiSource(),this._dw=this._createInstance(e),this._dw.route=this,this.options.renderOptions.engine&&(this._engine=this.options.renderOptions.engine,this._dw._engine=this._engine)}_createInstance(e){return new({[API_SOURCE_BAIDU]:TransitRoute_Bd,[API_SOURCE_TIANDITU]:TransitRoute_Tdt}[this.apiSource]||TransitRoute_Bd)(e)}renderMkr(e){const t=this._engine,i=t.add(new Marker({point:e.start.point,icon:getAssetUrl("assets/images/markers/mkr_start.png"),width:26,height:41,offset:[0,-16]})),n=t.add(new Marker({point:e.end.point,icon:getAssetUrl("assets/images/markers/mkr_end.png"),width:26,height:41,offset:[0,-16]}));this._markers.push(i,n);for(let r=0;r<e.steps.length;r++){const i=e.steps[r];if(i.rt===BMAP_ROUTE_TYPE_TRANSIT)for(let e=0;e<i.stops.length;e++){const n=i.stops[e],r=t.add(new Marker({point:n.point,icon:getAssetUrl(`assets/images/markers/mkr_transit_${i.type}.png`),width:22,height:22}));this._markers.push(r)}}}}class WalkingRoute extends BaseRoute{constructor(e={}){super(e),__publicField(this,"QUERY_TYPE",QUERY_TYPE_WALKING),__publicField(this,"RETURN_TYPE",RETURN_TYPE_WALKING),__publicField(this,"ROUTE_TYPE",BMAP_ROUTE_TYPE_WALKING),__publicField(this,"name","WalkingRoute"),__publicField(this,"_dw"),__publicField(this,"_engine"),this._dw=new DWRoute_Bd(e),this._dw.route=this,this.options.renderOptions.engine&&(this._engine=this.options.renderOptions.engine,this._dw._engine=this._engine)}}const index=Object.freeze(Object.defineProperty({__proto__:null,Geocoder:Geocoder,LocalSearch:LocalSearch,AutoComplete:AutoComplete,Boundary:Boundary,DistrictLayer:DistrictLayer,DrivingRoute:DrivingRoute,RidingRoute:RidingRoute,TransitRoute:TransitRoute,WalkingRoute:WalkingRoute,setApiSource:setApiSource,getApiSource:getApiSource,API_SOURCE_BAIDU:API_SOURCE_BAIDU,API_SOURCE_TIANDITU:API_SOURCE_TIANDITU},Symbol.toStringTag,{value:"Module"}));class InstancedPlaneBufferGeometry extends CustomInstancedBufferGeometry{constructor(){super(),__publicField(this,"setModelData",(()=>{this.setAttribute("position",new three.Float32BufferAttribute([-.5,-.5,0,-.5,.5,0,.5,.5,0,.5,-.5,0],3)),this.setAttribute("uv",new three.Float32BufferAttribute([0,0,0,1,1,1,1,0],2)),this.setIndex([0,2,1,0,3,2])})),this.setModelData()}}class GeoInstancedPointMesh extends GeoInstancedMesh{constructor(){super(...arguments),__publicField(this,"isInstancedPointMesh",!0),__publicField(this,"getInstanceLocalMatrix",((e,t,i)=>{const{vertexSizes:n}=this.parameters,r=this.dataSource&&this.dataSource.data&&this.dataSource.data.size;if(n&&r){const e=new three.Matrix4;return e.makeScale(r[i],r[i],r[i]),e}return null})),__publicField(this,"addCustomAttributes",(()=>{const{vertexColors:e}=this.parameters,{color:t}=this.dataSource.data,i=[];e&&t&&t.forEach((e=>{const t=colorToArr4(e);i.push(t[0],t[1],t[2])})),this.instanceColor=new three.InstancedBufferAttribute(new Float32Array(i),3)}))}computeInstanceMorphMatrix(e){const{vertexSizes:t}=this.parameters,i=this.dataSource&&this.dataSource.data,{size:n}=i||{};if(t&&n)return defaultValue$1.EMPTY_MAT4;super.computeInstanceMorphMatrix(e)}}const uniforms$e=three.UniformsUtils.merge([three.UniformsLib.fog,commonUniforms,animationUnifroms,selectiveUniforms,keepSizeUniforms,{isCesium:{value:!1}}]);class InstancedEffectPointMaterial extends CommonShaderMaterial{constructor(e){super(),this.type="InstancedEffectPointMaterial",this.isInstancedEffectPointMaterial=!0,this.lights=!1,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$e)),defineCommonProperties(this),defineAnimationProperties(this),defineMaterialSelectiveProperties(this),defineMaterialKeepSizeProperties(this)}}const vertexShader$d="#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\n\n#ifdef IS_GLOBE\n    attribute mat4 ecefMatrix;\n#endif\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#endif\n\nuniform float height;\nuniform float size;\nuniform float elapsedTime;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\nuniform float duration;\n\nvarying vec2 vPosition;\nvarying float vEffectRatio;\nvarying vec2 vUV;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n\n    vUV = uv;\n\n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    vec3 transformed = vec3(position);\n\n    float animationRotatePeriod = duration;\n    float animationJumpPeriod = duration;\n    float animationPeriod = duration;\n\n    #include <mvt_animation_vertex>\n\n    #ifndef MVT_USE_VERTEX_SIZE\n        transformed *= size;\n    #endif\n\n    mat4 currentInstanceMatrix = instanceMatrix;\n    #ifdef IS_GLOBE\n        // instanceMatrix的偏移值是ecef坐标(减去中心偏移), 所以需要先ecefMatrix * instanceMatrixRotation转换到ecef坐标然后再加上偏移值\n        mat3 rot = mat3(ecefMatrix) * mat3(instanceMatrix);\n        vec4 col0 = vec4(rot[0], 0.0);\n        vec4 col1 = vec4(rot[1], 0.0);\n        vec4 col2 = vec4(rot[2], 0.0);\n        vec4 col3 = instanceMatrix[3];\n\n        currentInstanceMatrix = mat4(col0, col1, col2, col3);\n    #endif\n\n    float pixelSize = getPixelSize(vec3(modelMatrix * currentInstanceMatrix * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n    // Breath部分逻辑, 仅支持breath\n    #ifdef MVT_USE_BREATH\n    if (animationEffect) {\n        vEffectRatio = mod(elapsedTime, duration) / duration;\n        if (animationPeriodOffset) {\n            vEffectRatio += instancedRandomFactor;\n        }\n        vEffectRatio = mod(vEffectRatio, 1.0);\n        transformed *= vEffectRatio;\n    } else {\n        vEffectRatio = 1.0;\n    }\n    #endif\n\n    vec4 worldPosition = modelMatrix * currentInstanceMatrix * vec4(transformed, 1.0);\n    worldPosition.z += height;\n\n    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)\n        vColor = vec4(instanceColor.xyz, 1.0);\n    #endif\n\n    gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    #include <logdepthbuf_vertex>\n}",fragmentShaderFan="#define GLSLIFY 1\n// #include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n  varying vec4 vColor;\n#else\n  uniform vec3 color;\n#endif\n// uniform vec3 color;\nuniform float opacity;\nuniform bool animationEffect;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n// #include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n   \n    #ifndef MVT_USE_VERTEX_COLOR\n      vec4 vColor = vec4(color, 1.0);\n    #endif\n    float bb = atan(vPosition.y, vPosition.x) + 3.15;\n\n    float pi = 3.14 * 1.;\n    // bb = mod(bb, 6.28);\n    if (bb > pi) {\n        discard;\n    } else { \n        float aa = mod(bb / pi, 1.0);\n        float dis = distance(vPosition, vec2(0, 0));\n        if (dis > 0.5) {\n            discard;\n        } else {\n            gl_FragColor = vec4(vColor.rgb, 1.0);\n            gl_FragColor.a *= aa;\n        }\n    }\n\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n    // #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n}",fragmentShaderRadarRotate="#define GLSLIFY 1\nuniform float segmentAngle;\n#ifdef MVT_USE_VERTEX_COLOR\n  varying vec4 vColor;\n#else\n  uniform vec3 color;\n#endif\n// uniform vec3 color;\nuniform float opacity;\nvarying vec2 vPosition;\n\n#define PI 3.1415926\n#define radius .5\n#include <logdepthbuf_pars_fragment>\n\nfloat cros(vec2 line1, vec2 line2){\n    return line1.x * line2.y - line2.x * line1.y;\n}\n\nvoid main() {\n    #ifndef MVT_USE_VERTEX_COLOR\n      vec4 vColor = vec4(color, 1.0);\n    #endif\n    bool crossNPI = false;\n    float wholeAng = abs(mod(segmentAngle , PI * 2.));\n    float dis = length(vec2(vPosition.xy - vec2(0.0)));\n\n    // if(wholeAng < -1.0*PI){\n    //     crossNPI = true;\n    //     wholeAng = 2.0*PI + endAng-startAng;\n    // }\n    if (dis<radius) {\n        vec2 nV = normalize(vPosition.xy);\n        float angle = 0.0;\n        if(nV.x > 0.0 && abs(nV.y) < 0.01) {\n            angle = 0.5*PI;\n        }\n        else if (nV.x<0.0 && abs(nV.y) < 0.01) {\n            angle = -0.5*PI;\n        }\n        else {\n            angle = atan(nV.x,nV.y);\n        }\n\n        if (angle<.0) {\n            angle = 2. * PI + angle;\n        }\n\n        float alpha = 0.1;\n\n        if (angle > 0. && angle < wholeAng) {\n            // alpha = 1.1 - (endAng-angle)/wholeAng;\n            alpha = 1.1 - (1. - (wholeAng-angle) / wholeAng);\n        }\n        \n        gl_FragColor = vec4(vColor.rgb, 1.0);\n        gl_FragColor.a = alpha * opacity;\n        #ifdef OPAQUE\n            gl_FragColor.a = 1.0;\n        #endif\n    }\n    else {\n        discard;\n    }\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    #include <logdepthbuf_fragment>\n}",fragmentShaderRadarLaryeredRotate="#define GLSLIFY 1\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n// #define blue1 vec4(0.74,0.95,1.00,1.)\n// #define blue2 vec4(0.87,0.98,1.00,1.)\n// #define blue3 vec4(0.35,0.76,0.83,1.)\n// #define blue4 vec4(0.953,0.969,0.89,1.)\n// #define red   vec4(1.00,0.38,0.227,1.)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n// #define elapsedTime 0.01\nuniform float elapsedTime;\n// uniform float speed;\nuniform float duration;\nvarying vec2 vPosition;\n#ifdef MVT_USE_VERTEX_COLOR\n  varying vec4 vColor;\n#else\n  uniform vec3 color;\n#endif\nuniform vec3 sideColor;\nuniform float opacity;\nuniform float sideOpacity;\n#include <logdepthbuf_pars_fragment>\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float t = mod((elapsedTime / duration), duration);\n    float theta0 = 90.0 * t * 5.0;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) )* 500.;\n        d = normalize(d);\n        //compute gradient based on angle difference to theta0\n        float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.3,1.0);\n        return SMOOTH(l,1.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n    \n    float circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return smoothstep(radius-width,radius,r)-smoothstep(radius,radius+width,r);\n    // return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = 180.0*(atan(d.y,d.x)/M_PI);\n    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n    \nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n    \nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x * 100.);\n    int y = int(d.y * 100.);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\n\nvoid main() {\n    #ifndef MVT_USE_VERTEX_COLOR\n      vec4 vColor = vec4(color, 1.0);\n    #endif\n    vec4 finalColor = vec4(0.0, .0, .0, .0);\n    vec4 diffuseColor = vec4(vColor.rgb, 1.0);\n    vec4 side = vec4(sideColor, sideOpacity);\n    vec2 uv = vPosition.xy;\n    #include <logdepthbuf_fragment>\n    //center of the image\n    vec2 c = vec2(0.0, 0.0);\n    finalColor += 0.3*_cross( vPosition.xy, c, .5);\n    finalColor += ( circle(uv, c, .3, .01)\n                  + circle(uv, c, .4, .01) ) * diffuseColor;\n    finalColor += (circle(uv, c, .5, .02) ) * side;//+ dots(uv,c,240.0)) * blue4;\n    // finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n    // finalColor += triangles(uv, c, 315.0 + 30.0*sin(elapsedTime * speed *.0006)) * blue2;\n    finalColor += movingLine(uv, c, .5) * diffuseColor;\n    finalColor += circle(uv, c, .05, .01) * diffuseColor;\n    // finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(elapsedTime * speed *.0006)) * blue3;\n    if( length(uv-c) < .5 ) {\n        if( length(finalColor)<0.2) {\n            discard;\n        }\n    }\n    else{\n        discard;\n    }\n\n    finalColor.a *= opacity;\n    if (finalColor.a <= 0.) {\n        discard;\n    }\n    gl_FragColor = finalColor;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}",fragmentShaderSpread="#define GLSLIFY 1\n#include <common>\n\nvarying vec2 vUV;\n#ifdef MVT_USE_VERTEX_COLOR\n  varying vec4 vColor;\n#else\n  uniform vec3 color;\n#endif\nuniform float speed;\nuniform float elapsedTime;\nuniform float duration;\n\nvec3 RadarPing(in vec2 uv, in vec2 center, in float innerTail, \n    in float frontierBorder, in float timeResetSeconds, \n    in float radarPingSpeed, in float fadeDistance, float t) {\n    vec2 diff = center-uv;\n    float r = length(diff);\n    float time = mod(t, timeResetSeconds) * radarPingSpeed;\n    \n    float circle;\n    circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder,time, r);\n    circle *= smoothstep(fadeDistance, 0.25, r); // fade to 0 after fadeDistance\n            \n    return vec3(circle);\n}\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #ifndef MVT_USE_VERTEX_COLOR\n      vec4 vColor = vec4(color, 1.0);\n    #endif\n    // gl_FragColor = vec4(1.,.0,.0,1.);\n    //normalize coordinates \n    vec2 uv = vUV; //move coordinates to 0..1\n    uv = uv.xy*2.; // translate to the center\n    uv += vec2(-1.0, -1.0);\n    #include <logdepthbuf_fragment>\n    vec3 color1;\n    // generate some radar pings\n    float fadeDistance = 1.3;\n    float resetTimeSec = 5.0;\n    float radarPingSpeed = 0.2;\n    vec2 greenPing = vec2(0.0, 0.0);\n    float t = mod((elapsedTime / duration), duration);\n    color1 += RadarPing(uv, greenPing, 0.12, 0.00025, resetTimeSec,\n        radarPingSpeed, fadeDistance, t * 5.0) * vec3(vColor.rgb);\n    // color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec,\n    //    radarPingSpeed, fadeDistance, elapsedTime * speed * .0006 + 1.) * uColor;\n    color1 += RadarPing(uv, greenPing, 0.12, 0.00025, resetTimeSec,\n        radarPingSpeed, fadeDistance, t * 5.0 + 2.) * vec3(vColor.rgb);\n    //return the new color\n    if(length(color1)<0.001){\n        discard;\n    }else{\n        gl_FragColor = vec4(color1,clamp(length(color1),0.0,1.0));\n    }\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}",fragmentShaderBubble="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n  varying vec4 vColor;\n#else\n  uniform vec3 color;\n#endif\nuniform float opacity;\nuniform bool animationEffect;\nuniform float elapsedTime;\nuniform float duration;\nuniform float center;\nuniform float radius;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > 0.5) {\n        discard;\n    }\n\n    #ifndef MVT_USE_VERTEX_COLOR\n      vec4 vColor = vec4(color, 1.0);\n    #endif\n    float range = mod(elapsedTime, duration);\n    float percent = 0.0;\n    if (range <= duration) {\n      percent = range / duration * 2.0;\n    } else {\n      percent = 1.0;\n    }\n    float r = radius * percent;\n    \n    float vColorAlpha = vColor.a;\n    // 中心点\n    if (d <= center){\n      if(d > 0.99 * center && d <= center) {\n        vColorAlpha = 1.0 - smoothstep(0.99 * center, center, d);\n      }\n    }\n    else {\n      if (d < r) {\n        vColorAlpha = smoothstep(0.1, 0.9, pow(d / r, 2.0) * 0.9);\n        // 边缘抗锯齿\n        if (d >= 0.99 * r && d <= r) {\n          vColorAlpha *= 1.0 - smoothstep(0.99, 1.0, d / r);\n        }\n        // 拖尾渐隐\n        if (range > duration) {\n          vColorAlpha *= 1.0 - (range - duration);\n        }\n      }\n      else {\n        vColorAlpha = 0.0;\n      }\n      \n    }\n    gl_FragColor = vec4(vColor.rgb, vColorAlpha);\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}",fragmentShaderBreath="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n  varying vec4 vColor;\n#else\n  uniform vec3 color;\n#endif\nuniform float opacity;\nuniform bool animationEffect;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #ifndef MVT_USE_VERTEX_COLOR\n      vec4 vColor = vec4(color, 1.0);\n    #endif\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > 0.5) {\n        discard;\n    }\n\n    gl_FragColor = vColor;\n\n    if (animationEffect) {\n        if (vEffectRatio > 0.7) {\n            gl_FragColor.a *= (1.0 - vEffectRatio) / 0.3;\n        }\n    }\n\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}",fragmentShaderWave="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n  varying vec4 vColor;\n#else\n  uniform vec3 color;\n#endif\nuniform float opacity;\nuniform bool animationEffect;\nuniform float elapsedTime;\nuniform float duration;\nuniform float radiusDiff;\nuniform float center;\nuniform float radius;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > radius) {\n        discard;\n    }\n    #ifndef MVT_USE_VERTEX_COLOR\n      vec4 vColor = vec4(color, 1.0);\n    #endif\n\n    float vColorAlpha = vColor.a;\n    \n    float alpha = sin((radiusDiff - d) / radiusDiff * 2.0  * 3.14 + elapsedTime / duration * 10.);\n    // 中心点\n    if (d <= center){\n      if (d > 0.9 * center && d <= center) {\n        if (alpha >= 0.5) {\n          vColorAlpha = 1.0;\n        } else {\n          vColorAlpha = 1.0 - smoothstep(center - 0.0001, center, d);\n        }\n      }\n    }\n    else {\n      if (alpha >= 0.6) {\n        vColorAlpha = 1.0 - d / radius;\n        if (alpha >= 0.5 && alpha <= 0.6) {\n            vColorAlpha *= smoothstep(0.0, 0.1, alpha - 0.5);\n        }\n        \n        if (d >= 0.8 * radiusDiff && d <= radiusDiff) {\n            vColorAlpha *= 1.0 - smoothstep(0.9, 1.0, d / radiusDiff);\n        }\n        \n      }\n      else {\n        vColorAlpha = 0.0;\n      }\n    }\n    gl_FragColor = vec4(vColor.rgb, vColorAlpha);\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}";let uniforms$d=three.UniformsUtils.merge([{size:{value:100},color:{value:[1,0,0]},duration:{value:5e3},center:{value:.1},radius:{value:.5},radiusDiff:{value:.08},isEmissive:{value:!1},keepSize:{value:!0},segmentAngle:{value:.25*Math.PI},sideOpacity:{value:1},sideColor:{value:[.87,.98,1]}}]);class InstancedEffectMaterial extends InstancedEffectPointMaterial{constructor(e={}){super(),__publicField(this,"name","InstancedEffectPointMaterial"),__publicField(this,"isInstancedEffectPointMaterial",!0),this.depthTest=!0,this.depthWrite=!1,this.transparent=!0;const{type:t}=e,i="Breath"===t,n="Wave"===t,r="Fan"===t,s="Radar"===t,a="RadarLayered"===t,o="RadarSpread"===t;this.vertexShader=vertexShader$d,this.fragmentShader=r?fragmentShaderFan:s?fragmentShaderRadarRotate:a?fragmentShaderRadarLaryeredRotate:o?fragmentShaderSpread:i?fragmentShaderBreath:n?fragmentShaderWave:fragmentShaderBubble,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$d)),defineMaterialNormalProperties(this,["speed","sideOpacity","isEmissive","segmentAngle","duration"]),defineMaterialColorProperties(this,["sideColor"]),defineMaterialBoolDefineProperties(this,[["isGlobe","IS_GLOBE"],["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexSizes","MVT_USE_VERTEX_SIZE"],["isBreath","MVT_USE_BREATH"]]),this.isBreath=i,this.noAnimation=a||o,this.animationRotate=s,this.setValues(e)}}class EffectPoint extends GeoInstancedPointMesh{constructor(e){super(e),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"color"),__publicField(this,"size"),__publicField(this,"duration"),__publicField(this,"type"),this.parameters=e,this.defineMaterialProxyProperties(["color","size","duration","size3","height","opacity","vertexColors","segmentAngle","sideColor","vertexSizes"])}initObject(){this.geometry=new InstancedPlaneBufferGeometry,this.material=new InstancedEffectMaterial(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}clone(){const e=new this.constructor(this.parameters);return e.getInstanceLocalMatrix=this.getInstanceLocalMatrix,e}}class InstancedBallonBufferGeometry extends CustomInstancedBufferGeometry{constructor(){super(),__publicField(this,"setModelData",(()=>{this.setAttribute("position",new three.Float32BufferAttribute([-1,0,0,-1,0,2,1,0,2,1,0,0,-1,0,0,-1,0,2,1,0,2,1,0,0],3)),this.setAttribute("uv",new three.Float32BufferAttribute([0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],2)),this.setAttribute("gType",new three.Float32BufferAttribute([1,1,1,1,2,2,2,2],1)),this.setIndex([0,2,1,0,3,2,4,6,5,4,7,6])})),__publicField(this,"setData",(e=>{const{positions:t,randomFactors:i,aObjectIndices:n}=e;this.setAttribute("instancedPosition",new three.InstancedBufferAttribute(new Float32Array(t),3)),this.setAttribute("objectIndex",new three.InstancedBufferAttribute(new Float32Array(n),1))})),this.setModelData()}}const vertexShader$c="#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\nattribute float gType;\n// attribute vec2 uv;\n\nuniform float height;\nuniform float size;\nuniform float stringWidth;\nuniform vec2 resolution;\nuniform float time;\nuniform bool keepSize;\n\nvarying float vGType;\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nuniform bool animationPeriodOffset;\n#ifdef ENABLE_ANIMATION_ROTATE\nuniform float animationRotatePeriod;\n#endif\n\n#ifdef ENABLE_ANIMATION_JUMP\nuniform float animationJumpPeriod;\nuniform float animationJumpHeight;\n#endif\n\n#define MVT_KEEP_PROJECTION_POSITION\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nuniform float iconFillRatio;\nvoid main() {\n    vGType = gType;\n    #include <mvt_selective_vertex>\n    vec4 mvp_projectPosition;\n\n    vec3 cameraRight = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);\n    vec3 cameraUp    = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);\n\n    mat4 faceCameraMatrix = mat4(\n        vec4(cameraRight, 0.0),\n        vec4(cameraUp,    0.0),\n        vec4(0.0,         0.0, 1.0, 0.0),\n        vec4(0.0,         0.0, 0.0, 1.0)\n    );\n\n    vUv = uv;\n\n    vec3 worldPosition = (modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n    float pixelSize = getPixelSize(worldPosition);\n\n    vec3 transformed = position;\n\n    if (gType == 1.) {\n        transformed.x *= stringWidth * pixelSize / 2.0;\n        if (keepSize) {\n            transformed.z *= height * pixelSize / 2.0;\n        }\n        else {\n            transformed.z *= height / 2.0;\n        }\n        vec4 projectionPosition = projectionMatrix * modelViewMatrix * instanceMatrix * faceCameraMatrix * vec4(transformed, 1.0);\n        mvp_projectPosition = vec4(projectionPosition);\n\n        gl_Position = projectionPosition;\n\n    }\n    else if (gType == 2.) {\n        vPosition = position;\n        vUv = uv;\n        float uvScale = 1.0 / iconFillRatio;\n        // vUv = uv * uvScale - (uvScale - 1.0) * 0.5;\n\n        transformed.x *= size * pixelSize / 2.0;\n        transformed.z = transformed.z * (size * pixelSize / 2.0);\n        if (keepSize) {\n            transformed.z += height * pixelSize;\n        } else {\n            transformed.z += height;\n        }\n\n        vec4 projectionPosition = projectionMatrix * modelViewMatrix * instanceMatrix * faceCameraMatrix * vec4(transformed, 1.0);\n        mvp_projectPosition = vec4(projectionPosition);\n\n        gl_Position = projectionPosition;\n    }\n    \n    #ifdef ENABLE_ANIMATION_JUMP\n        float jumpRatio = mod(time, animationJumpPeriod) / animationJumpPeriod;\n        if (animationPeriodOffset) {\n            jumpRatio = mod(jumpRatio + instancedRandomFactor, 1.0);\n        }\n        if (jumpRatio <= 0.5) {\n            jumpRatio *= 2.0;\n            jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n        } else {\n            jumpRatio = (1.0 - jumpRatio) * 2.0;\n            jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n        }\n        gl_Position.y += jumpRatio * height * 2.0 / resolution.y;\n    #endif\n    #include <logdepthbuf_vertex>\n}",fragmentShader$b="#define GLSLIFY 1\n#include <common>\n\nuniform float size;\nuniform vec3 color;\nuniform float shape;\nuniform vec4 stringColor;\nuniform sampler2D iconTexture;\nuniform float opacity;\nuniform float iconFillRatio;\nuniform float pixelRatio;\n\nvarying float vGType;\nvarying vec3 vPosition;\nvarying vec2 vUv;\n\nmat2 rotate(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    if (vGType == 1.) {\n        #ifdef USE_DASH\n            vec2 rotatedCoord = rotate(1.570796327) * gl_FragCoord.xy;\n            float dash = fract(rotatedCoord.x / (8.0 * pixelRatio));\n            if (dash > 0.5) {\n                discard;\n            }\n        #endif\n        gl_FragColor = stringColor;\n    } else if (vGType == 2.) {\n       \n        gl_FragColor = vec4(color, 1.0);\n        \n        vec2 newUv = vUv;\n        // float uvScale = 1.0 / iconFillRatio;\n        // vec2 newUv = vUv * uvScale - (uvScale - 1.0) * 0.5;\n        // newUv.x -= 0.25;\n        // newUv.y -= 0.25;\n        vec4 textureColor = texture2D(iconTexture, newUv);\n        gl_FragColor = mix(gl_FragColor, textureColor, textureColor.a);\n\n        if (shape == 1.) {\n            float d = distance(vec2(vPosition.x, vPosition.z), vec2(0, 1));\n            if (d > 1.) {\n                discard;\n            }\n        }\n    }\n\n    if (gl_FragColor.a < 0.001) {\n        discard;\n    }\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n    \n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}",uniforms$c=three.UniformsUtils.merge([selectiveUniforms,{stringWidth:{value:2},resolution:{value:[1,1]},stringColor:{value:[1,0,0,1]},iconTexture:{value:null},shape:{value:1},height:{value:100},iconFillRatio:{value:.8},keepSize:{value:!0},size:{value:10}}]);class InstancedBallonMaterial extends InstancedEffectPointMaterial{constructor(e){super(),this.name="InstancedBallonMaterial",this.isInstancedBallonMaterial=!0,this.vertexShader=vertexShader$c,this.fragmentShader=fragmentShader$b,this.side=three.DoubleSide,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$c)),this.textureLoader=new three.TextureLoader;let t=null;defineMaterialNormalProperties(this,["resolution","shape","stringColor","stringWidth","iconFillRatio","isEmissive"]),defineMaterialBoolDefineProperties(this,[["dashed","USE_DASH"]]),Object.defineProperties(this,{iconSrc:{get:function(){return t},set:function(e){if(t===e)return;t=e,this.uniforms.iconTexture.value&&(this.uniforms.iconTexture.value.dispose(),this.uniforms.iconTexture.value=null);const i=this.textureLoader.load(e);i.colorSpace=three.SRGBColorSpace,i.wrapS=i.wrapT=three.RepeatWrapping,this.uniforms.iconTexture.value=i}}}),this.setValues(e)}dispose(){this.uniforms.iconTexture.value&&this.uniforms.iconTexture.value.dispose(),super.dispose()}}class BallonPoint extends GeoInstancedMesh{constructor(e){super(e),__publicField(this,"getBallonIconSrc",(e=>{if(e)return e})),this.parameters=e,this.defineMaterialProxyProperties(["color","size","size3","height","opacity","dashed"])}getDefaultParams(){return{iconSrc:"car"}}initObject(){this.geometry=new InstancedBallonBufferGeometry,this.material=new InstancedBallonMaterial({iconSrc:this.getBallonIconSrc(this.parameters.iconSrc),...this.parameters}),this.material.setCommonUniforms(this.engine.rendering.uniforms)}}const vertexShader$b="#define GLSLIFY 1\n#include <common>\n\nattribute float pIndex;\nattribute float aMapIndex;\n\nuniform float pixelRatio;\nuniform float width;\nuniform float height;\nuniform float uScale;\nuniform float ulength;\nuniform vec2 resolution;\nuniform vec2 offset;\nuniform bool uFlat;\nuniform bool keepSize;\nuniform float elapsedTime;\n\n#ifdef IS_GLOBE\nattribute mat3 aInstanceRotationMatrix;\n#endif\n\nvarying vec2 vUv;\nvarying vec4 vColor;\n\n#ifdef MVT_USE_VERTEX_ROTATEZ\n    attribute float aRotateZ;\n# else\n    uniform float uRotateZ;\n#endif\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n#else\n    uniform vec3 color;\n#endif\n\n#ifdef USE_ANIMATION\nuniform float jumpHeight;\nuniform float jumpSpeed;\n#endif\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {\n    float x = coord.x;\n    float y = coord.y;\n    if (corner == 1.0) {\n        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    } else if (corner == 2.0) {\n        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else if (corner == 3.0) {\n        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else {\n        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    }\n    return vec3(x, y, coord.z);\n}\n\nvoid main() { \n    #include <mvt_selective_vertex>\n\n    mat4 currentInstanceMatrix = mat4(1.0);\n    vec3 currentPosition = position;\n    #ifdef IS_GLOBE\n        currentInstanceMatrix = mat4(\n            vec4(aInstanceRotationMatrix[0], 0.0),\n            vec4(aInstanceRotationMatrix[1], 0.0),\n            vec4(aInstanceRotationMatrix[2], 0.0),\n            vec4(position, 1.0)\n        );\n\n        currentPosition = vec3(0.0, 0.0, 0.0);\n    #endif\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #else\n        vColor = vec4(color, 1.0);\n    #endif\n\n    float rotateZ;\n    #ifdef MVT_USE_VERTEX_ROTATEZ\n        rotateZ = aRotateZ;\n    # else\n        rotateZ = uRotateZ;\n    #endif\n\n    vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    if (uFlat) {\n        float hw = width * 0.5;\n        float hh = height * 0.5;\n        if (keepSize) {\n            hw *= pixelSize;\n            hh *= pixelSize;\n        }\n\n        vec3 current = transformCoord(currentPosition, vec2(hw, hh), pIndex, -rotateZ);\n        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);\n    }\n    else {\n        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0);\n        float w = gl_Position.w;\n        gl_Position /= w;\n\n        float hw = width / resolution.x * uScale;\n        float hh = height / resolution.y * uScale;\n        vec2 o = offset;\n        if (!keepSize) {\n            hw /= pixelSize;\n            hh /= pixelSize;\n            o /= pixelSize;\n        }\n\n        gl_Position.x += o.x * 2. / resolution.x;\n        gl_Position.y -= o.y * 2. / resolution.y;\n\n        if (pIndex == 1.0) {\n            gl_Position.x -= hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 2.0) {\n            gl_Position.x += hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 3.0) {\n            gl_Position.x += hw;\n            gl_Position.y -= hh;\n        } else {\n            gl_Position.x -= hw;\n            gl_Position.y -= hh;\n        }\n\n        #ifdef USE_ANIMATION\n            float bounce = abs(sin(elapsedTime / 1000.0 * jumpSpeed)) * jumpHeight;\n            gl_Position.y += (bounce * 2. / resolution.y);\n        #endif\n\n        gl_Position *= w;\n    }\n\n    vUv = uv;\n\n    #include <logdepthbuf_vertex>\n}",fragmentShader$a="#define GLSLIFY 1\n#include <common>\n\nuniform float opacity;\n\nuniform bool useMap;\nuniform bool useCanvasMap;\nuniform sampler2D map;\nuniform float width;\nuniform float height;\n\nvarying vec2 vUv;\nvarying vec4 vColor;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_emissive_pars_fragment>\n\nvoid main() {\n\n    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));\n    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);\n\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n    gl_FragColor *= vColor;\n\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <mvt_selective_fragment> \n    #include <logdepthbuf_fragment> \n    #include <mvt_emissive_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}",textureLoader$2=new three.TextureLoader,uniforms$b=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,keepSizeUniforms,{emissive:{value:[0,0,0]},isEmissive:{value:!1},width:{value:12},height:{value:12},offset:{value:[0,0]},ulength:{value:1},useCanvasMap:{value:!1},vertexIcons:{value:!1},opacity:{value:1},map:{value:null},useMap:{value:!1},uScale:{value:1},uFlat:{value:!1},keepSize:{value:!0},color:{value:[1,1,1]},vertexColors:{value:!1},jumpHeight:{value:0},jumpSpeed:{value:0},uRotateZ:{value:0}}]);class IconMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="IconMaterial",this.vertexShader=vertexShader$b,this.fragmentShader=fragmentShader$a,this.isIconMaterial=!0,this.transparent=!0,this._fallback=getAssetUrl("assets/images/fallbackIcon.png"),this._fallbackTexture=textureLoader$2.load(this.fallback),this._fallbackTexture.wrapS=this._fallbackTexture.wrapT=three.ClampToEdgeWrapping,this._fallbackTexture.colorSpace=three.SRGBColorSpace,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$b)),defineMaterialKeepSizeProperties(this),defineMaterialSelectiveProperties(this),defineMaterialNormalProperties(this,["width","height","offset","opacity","emissive","isEmissive","jumpHeight","jumpSpeed"]),defineMaterialAliasProperties(this,[["scale","uScale"],["flat","uFlat"],["rotateZ","uRotateZ"]]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexRotateZs","MVT_USE_VERTEX_ROTATEZ"],["vertexColors","MVT_USE_VERTEX_COLOR"],["animationJump","USE_ANIMATION"],["isGlobe","IS_GLOBE"]]),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const t=this.mapSrc,i=this.userData[this.urlCacheKey],n=this;if(i!==e){if(t&&t.dispose(),!e&&!this.fallback)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[this.urlCacheKey];textureLoader$2.load(e,(function(t){t.wrapS=t.wrapT=three.ClampToEdgeWrapping,t.colorSpace=three.SRGBColorSpace,n.uniforms.map.value=t,n.userData[n.urlCacheKey]=e,n.uniforms.useMap.value=!0,n.uniforms.useCanvasMap.value=!1}),void 0,(t=>{n.uniforms.map.value=this._fallbackTexture,n.userData[n.urlCacheKey]=e,n.uniforms.useMap.value=!0,n.uniforms.useCanvasMap.value=!1}))}}},mapTexture:{get:function(){return this.uniforms.map.value},set:function(e){if(!e)return this.uniforms.map.value=null,void(this.uniforms.useCanvasMap.value=!1);e.wrapS=e.wrapT=three.ClampToEdgeWrapping,e.colorSpace=three.SRGBColorSpace,this.uniforms.map.value=e,this.uniforms.useMap.value=!1,this.uniforms.useCanvasMap.value=!0,delete this.userData[this.urlCacheKey]}}}),this.setValues(e)}set fallback(e){this._fallback=e,this._fallbackTexture=textureLoader$2.load(e),this._fallbackTexture.wrapS=this._fallbackTexture.wrapT=three.ClampToEdgeWrapping,this._fallbackTexture.colorSpace=three.SRGBColorSpace}get fallback(){return this._fallback}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class IconGeometry extends three.BufferGeometry{constructor(e){super(e),this.parameters=e}setData(e){const{aPositions:t,aObjectIndices:i,aUvs:n,aColors:r,pIndices:s,rotateZs:a,indices:o}=e;this.setAttribute("position",new three.Float32BufferAttribute(t,3)),this.setAttribute("pIndex",new three.Float32BufferAttribute(s,1)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(i,1)),this.setAttribute("uv",new three.Float32BufferAttribute(n,2)),this.parameters.vertexColors&&this.setAttribute("aColor",new three.Float32BufferAttribute(r,4)),this.parameters.vertexRotateZs&&this.setAttribute("aRotateZ",new three.Float32BufferAttribute(a,1)),e.aInstanceMatrices&&this.setAttribute("aInstanceRotationMatrix",new three.Float32BufferAttribute(e.aInstanceMatrices,9)),this.setIndex(o),this.cachedObjectIndices=i}}const _tempVector3$2=new three.Vector3,_tempVector4$2=new three.Vector4,_tempMatrix4$2=new three.Matrix4,_tempMatrix3=new three.Matrix3,_tempA=new three.Vector3,_morphA=new three.Vector3;class Icon extends GeoMesh{constructor(e={}){super(e),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"_padding"),__publicField(this,"oldMapTextureRes",new Map),__publicField(this,"texture"),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"canvas"),__publicField(this,"ctx"),__publicField(this,"iconUrlHash",new Map),__publicField(this,"boxHash",new Map),__publicField(this,"gap",[2,2]),__publicField(this,"getTextureAndHash",((e,t,i,n,r)=>{const s=this.iconUrlHash;if(!r&&this.oldMapTextureRes)return this.oldMapTextureRes;if(!e[0]||!e[0][t])return{texture:this.texture,iconUrlHash:s};let a=s.size,o=s.size,l=new Map;for(let h=0;h<e.length;h++){const i=e[h][t];void 0===s.get(i)&&(s.set(i,a),l.set(i,a),a++)}if(o===s.size)return this.oldMapTextureRes;let c=Array.from(s.entries()).map((([e,t])=>new Promise(((t,i)=>{url2canvas(e,(i=>{s.set(e,i),t(e)}),(()=>{if(this.material.fallback){let i=new Image;i.crossOrigin="anonymous",i.onload=function(){let n=i.width,r=i.height,a=document.createElement("canvas");a.width=n,a.height=r,a.getContext("2d").drawImage(i,0,0,n,r),s.set(e,a),t(e)},i.src=this.material.fallback}}))}))));return c})),this.parameters=e,this._padding=void 0!==this.parameters.padding?this.parameters.padding:[2,2];const t=this.canvas=document.createElement("canvas");t.width=t.height=1,this.ctx=t.getContext("2d"),this.texture=new three.CanvasTexture(t),this.parameters.mapSrc||(this.parameters.mapSrc=""),this.defineMaterialProxyProperties(["width","height","offset","map","mapSrc","transparent","opacity","flat","keepSize","color","vertexColors","animationJump","jumpHeight","jumpSpeed","fallback"]),this.boxes=[],this.boxSize=e.boxSize||100}initObject(){let{vertexIcons:e,...t}=this.parameters;this.geometry=new IconGeometry(this.parameters),this.material=new IconMaterial(t),this.material.setCommonUniforms(this.engine.rendering.uniforms)}getDefaultParams(){return{width:12,height:12}}collisionTest(e){return{width:this.width,height:this.height}}createTexture(){if(!this.canvas)return this.oldMapTextureRes;const e=this.ctx,t=this.iconUrlHash;for(let[i,n]of t){const e=i,n=t.get(e);if("string"==typeof n)continue;const r=this.boxes.findIndex((e=>e.key===i));if(r>=0){const e=this.boxes.splice(r,1);this.boxes.unshift(e[0]);continue}const s=n.width,a=n.height,o=s+this.gap[0],l=a+this.gap[1];this.boxes.unshift({w:o,h:l,width:s,height:a,key:i,icon:n})}for(let i=0;i<this.boxes.length;i++){const e=this.boxes[i];this.boxHash.set(e.key,e)}return createSprite(this.boxes,e,this.canvas,{fillStyle:this._fillStyle,fontSize:this.parameters.fontSize,gap:this.gap,padding:this.padding,dpr:this.engine.rendering.pixelRatio})?(this.texture.dispose(),this.texture=new three.CanvasTexture(this.canvas)):this.texture.needsUpdate=!0,this.oldMapTextureRes={texture:this.texture,iconUrlHash:t},{texture:this.texture,iconUrlHash:t}}async _updateData(){const e=this.engine.map.isGlobe,{vertexIcons:t,inconPropName:i="icon",width:n,height:r}=this.parameters;let s=[];s=this._enableCollision&&this._collisionData?this._collisionData:this.dataSource.userData;const a=[],o=[],l=[],c=[],h=[],u=[],d=[],p=[];let m="",f={};const g=new three.Matrix4;if(t){let t,_=this.getTextureAndHash(s,i,n,r,!0);Array.isArray(_)?(await Promise.all(_),t=this.createTexture()):t=_,m=t.texture,f=t.iconUrlHash||{},this.material.mapTexture=m,this.material.uniforms.ulength.value=f.size;for(let n=0;n<s.length;n++){const t=s[n].position,r=s[n].index,m=s[n][i],f=s[n].rotateZ||0,_=this.boxHash.get(m);if(!_)continue;const A=s[n].color;let v;this.parameters.vertexColors&&(v=A?colorToArr4(A):[1,1,1,1]),this.parameters.vertexRotateZs&&d.push(f,f,f,f),e&&(this._calculateTransform(t,g),_tempMatrix3.setFromMatrix4(g));for(let i=0;i<4;i++)a.push(...t),o.push(i),l.push(r),v&&u.push(...v),e&&p.push(..._tempMatrix3.elements);const y=_.x/this.canvas.width,x=(_.x+_.w)/this.canvas.width,b=(_.y+_.h)/this.canvas.height,S=_.y/this.canvas.height;c.push(y,b,y,S,x,S,x,b);const C=4*n;h.push(C,C+2,C+1,C,C+3,C+2)}}else for(let v=0;v<s.length;v++){const t=s[v].position,i=s[v].index,n=s[v].color,r=s[v].rotateZ||0;let m;this.parameters.vertexColors&&(m=n?colorToArr4(n):[1,1,1,1]),this.parameters.vertexRotateZs&&d.push(r,r,r,r),e&&(this._calculateTransform(t,g),_tempMatrix3.setFromMatrix4(g));for(let s=0;s<4;s++)a.push(...t),o.push(s),l.push(i),m&&u.push(...m),e&&p.push(..._tempMatrix3.elements);c.push(0,1,0,0,1,0,1,1);const f=4*v;h.push(f,f+2,f+1,f,f+3,f+2)}const _=e?p:null;this.geometry.setData({aColors:u,aPositions:a,pIndices:o,aObjectIndices:l,aUvs:c,aInstanceMatrices:_,rotateZs:d,indices:h}),this.geometry.computeBoundingSphere();const A=this.geometry.boundingSphere.center;this.originCenter=(new three.Vector3).copy(A),this.makeGeometryOffsetPosition(this.geometry,a),this.needsUpdate=!1,this.engine.requestRender()}_calculateTransform(e,t){return this.engine.map.isGlobe?(t||(t=new three.Matrix4),Transforms.eastNorthUpToFixedFrame(_tempVector3$2.fromArray(e),null,t),t):defaultValue$1.EMPTY_MAT4}getEntityByIndex(e){const t=this.dataSource;this._enableCollision&&this._collisionData&&(e=this._collisionData[e].index);const i={index:e,value:t.getDataItem(e),itemIndex:t.getDataItemIndex(e),pairs:{}},n=t.data;for(const r of Object.keys(n))i.pairs[r]=n[r][e];return i}raycast(e,t){const i=this.flat;if(!this.visible)return;if(i){null===this.geometry.boundingSphere&&this.geometry.computeBoundingSphere();const{width:i,height:n}=this.parameters;let r=Math.max(i,n)/2;return this.keepSize&&(r*=this.material.uniforms.zoomUnits.value),this.geometry.boundingSphere.radius+=r,three.Mesh.prototype.raycast.call(this,e,t),void(this.geometry.boundingSphere.radius-=r)}const n=this.geometry,r=n.getAttribute("position");if(!r||!r.array||0===!r.array.length)return;const s=n.getAttribute("offset");let a=[];s&&(a=s.array);let o=e.camera;o||(o=this.engine.camera);const l=e.mouse;if(!l)return;const c=this.material.uniforms.resolution.value,h=l.x,u=l.y;let d=this.width/c.x,p=this.height/c.y;const m=d,f=p;let g=0,_=0,A=0,v=0,y=0,x=0;_tempMatrix4$2.multiplyMatrices(o.projectionMatrix,o.matrixWorldInverse),_tempMatrix4$2.multiplyMatrices(_tempMatrix4$2,this.matrixWorld);const b=r.array;let S=0;for(let C=0,T=b.length-11;C<T;C+=12){if(_tempVector4$2.set(b[C],b[C+1],b[C+2],1),_tempVector4$2.applyMatrix4(_tempMatrix4$2),_tempVector4$2.divideScalar(_tempVector4$2.w),this.parameters.vertexOffsets?(S=C/12*8,y=a[S]||0,x=a[S+1]||0):(y=this.material.uniforms.offset.value?this.material.uniforms.offset.value[0]:0,x=this.material.uniforms.offset.value?this.material.uniforms.offset.value[1]:0),_tempVector4$2.x+=2*y/c.x,_tempVector4$2.y-=2*x/c.y,!this.keepSize){const{x:e,y:t,z:i}=this.originCenter,n=this.getPixelSize(new three.Vector3(b[C]+e,b[C+1]+t,b[C+2]+i));d=m/n,p=f/n,y/=n,x/=n}if(g=_tempVector4$2.x-d,A=_tempVector4$2.x+d,_=_tempVector4$2.y-p,v=_tempVector4$2.y+p,g<=h&&A>=h&&_<=u&&v>=u){_tempVector3$2.set(b[C],b[C+1],b[C+2]),_tempVector3$2.applyMatrix4(this.matrixWorld);const e={instanceId:C/12,object:this,point:_tempVector3$2.clone(),distance:_tempVector3$2.distanceTo(o.position)};t.push(e)}}}onDispose(){this.texture&&this.texture.dispose()}set padding(e){this._padding=e}get padding(){return this._padding}getVertexPosition(e,t){const i=this.geometry,n=i.attributes.position,r=i.morphAttributes.position,s=i.morphTargetsRelative;t.fromBufferAttribute(n,e);const a=e%4;let o=this.parameters.width/2,l=this.parameters.height/2;if(this.keepSize){const e=this.originCenter,i=this.getPixelSize((new three.Vector3).addVectors(e,t));o*=i,l*=i}1===a?o=-o:2===a||(3===a?l=-l:(l=-l,o=-o)),t.x+=o,t.y+=l;const c=this.morphTargetInfluences;if(r&&c){_morphA.set(0,0,0);for(let i=0,n=r.length;i<n;i++){const n=c[i],a=r[i];0!==n&&(_tempA.fromBufferAttribute(a,e),s?_morphA.addScaledVector(_tempA,n):_morphA.addScaledVector(_tempA.sub(t),n))}t.add(_morphA)}return t}getPixelSize(e){const{camera:t,rendering:i}=this.engine;return t.isOrthographicCamera?this.material.uniforms.zoomUnits.value:.2*t.projectionMatrix.elements[5]/i.resolution.y*t.position.distanceTo(e)}getEntityIndexByFace(e,t){return this.geometry.cachedObjectIndices[t]}}Icon.prototype._computeIntersections=three.Mesh.prototype._computeIntersections;const _vector4=new three.Vector4,_matrix4=new three.Matrix4,_screenSize=new three.Vector2;class DOMPoint extends GeoObject{constructor(e){super(e),__publicField(this,"isDOMPoint",!0),__publicField(this,"frustumCulled",!1),__publicField(this,"_visible",!0),__publicField(this,"onBeforeScenePrepareRenderHook",((e,t,i)=>{this.container=e.map.container;let n=e.renderer;const r=this.points,s=this.nodes;n.getSize(_screenSize),_matrix4.multiplyMatrices(i.matrixWorldInverse,this.matrixWorld),_matrix4.multiplyMatrices(i.projectionMatrix,_matrix4);for(let a=0;a<r.length;a++){_vector4.set(r[a][0],r[a][1],r[a][2],1),_vector4.applyMatrix4(_matrix4),_vector4.divideScalar(_vector4.w);const e=(_vector4.x+1)/2*_screenSize.x,t=(1-_vector4.y)/2*_screenSize.y;if(!s[a])return;_vector4.x>1||_vector4.x<-1||_vector4.y>1||_vector4<-1||_vector4.z>1||_vector4<-1?addClass(s[a],`${CSS_NAMESPACE}-hidden`):removeClass(s[a],`${CSS_NAMESPACE}-hidden`),s[a].style.left=e+this.offset[0]+"px",s[a].style.top=t+this.offset[1]+"px"}})),this.points=[],this.nodes=[],this.offset=[0,0],this.parameters=e}renderItem(e){const t=document.createElement("div");return t.style.position="absolute",t.style.width="60px",t.style.height="40px",t.style.background="#FFFFFF",t}clone(){const e=super.clone();return e.parameters=this.parameters,e.renderItem=this.renderItem,e}_updateData(){const e=this.engine,t=e.camera,i=e.renderer,{offset:n=[0,0]}=this.parameters;for(let a=0;a<this.nodes.length;a++)this.nodes[a].remove();this.nodes=[],this.points=[];const r=this.dataSource;if(!r)return;r.needsUpdate&&r.update(),i.getSize(_screenSize),_matrix4.multiplyMatrices(t.matrixWorldInverse,this.matrixWorld),_matrix4.multiplyMatrices(t.projectionMatrix,_matrix4);const s=r.data&&r.data.position||[];for(let a=0,o=r.size;a<o;a++){const e=s[a];this.points.push(e);const t=this.renderItem(r.getDataItem(a));_vector4.set(e[0],e[1],e[2],1),_vector4.applyMatrix4(_matrix4),_vector4.divideScalar(_vector4.w);const i=(_vector4.x+1)/2*_screenSize.x,o=(1-_vector4.y)/2*_screenSize.y;_vector4.x>1||_vector4.x<-1||_vector4.y>1||_vector4<-1||_vector4.z>1||_vector4<-1?addClass(t,`${CSS_NAMESPACE}-hidden`):removeClass(t,`${CSS_NAMESPACE}-hidden`),addClass(t,`${CSS_NAMESPACE}-dom-points`),t.style.left=i+n[0]+"px",t.style.top=o+n[1]+"px",t.style.visibility=!0===this.visible?"":"hidden",this.nodes.push(t),this.container.appendChild(t)}this.offset=n,this.needsUpdate=!1,this.engine&&this.engine.requestRender()}onDispose(){this.nodes&&this.nodes.length&&this.nodes.forEach((e=>{e.remove()})),this.points=[],this.nodes=[]}set visible(e){if(this._visible===e)return;this._visible=e;let t=!0==!!e?"":"hidden";this.nodes&&this.nodes.length&&this.nodes.forEach((e=>{e.style.visibility=t}))}get visible(){return this._visible}}const vertexShader$a="#define GLSLIFY 1\n#include <common>\n\nattribute float pIndex;\nattribute float aMapIndex;\n\nuniform float pixelRatio;\nuniform float width;\nuniform float height;\nuniform float ulength;\nuniform vec2 resolution;\nuniform vec2 offset;\nuniform vec3 positionOffset;\nuniform bool uFlat;\nuniform bool keepSize;\nuniform float scaleRatio;\n\n#ifdef MVT_USE_VERTEX_SIZE\n    attribute vec2 aSize;\n#endif\n\n#ifdef MVT_USE_VERTEX_POSITION_OFFSET\n    attribute vec3 aPositionOffsets;\n#endif\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n    #include <mvt_selective_vertex>\n    float setWidth = width;\n    float setHeight = height;\n\n    #ifdef MVT_USE_VERTEX_SIZE\n        setWidth = aSize.x * scaleRatio;\n        setHeight = aSize.y * scaleRatio;\n    #endif\n\n    vec2 o = offset * scaleRatio;\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    if (uFlat) {\n        float hw = setWidth * 0.5;\n        float hh = setHeight * 0.5;\n        if (keepSize) {\n            hw *= pixelSize;\n            hh *= pixelSize;\n            o *= pixelSize;\n        }\n        if (pIndex == 1.0) {\n            hw = -hw;\n        } else if (pIndex == 2.0) {\n\n        } else if (pIndex == 3.0) {\n            hh = -hh;\n        } else {\n            hw = -hw;\n            hh = -hh;\n        }\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);\n    }\n    else {\n        vec3 setPositionOffset = positionOffset;\n        #ifdef MVT_USE_VERTEX_POSITION_OFFSET\n            setPositionOffset = aPositionOffsets;\n        #endif\n        worldPosition.x += setPositionOffset.x;\n        worldPosition.y += setPositionOffset.y;\n        worldPosition.z += setPositionOffset.z;\n\n        gl_Position = projectionMatrix * viewMatrix * worldPosition;\n        float w = gl_Position.w;\n        gl_Position /= w;\n\n        float hw = setWidth / resolution.x;\n        float hh = setHeight / resolution.y;\n        if (!keepSize) {\n            hw /= pixelSize;\n            hh /= pixelSize;\n            o /= pixelSize;\n        }\n\n        gl_Position.x += o.x * 2. / resolution.x;\n        gl_Position.y -= o.y * 2. / resolution.y;\n\n        if (pIndex == 1.0) {\n            gl_Position.x -= hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 2.0) {\n            gl_Position.x += hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 3.0) {\n            gl_Position.x += hw;\n            gl_Position.y -= hh;\n        } else {\n            gl_Position.x -= hw;\n            gl_Position.y -= hh;\n        }\n\n        gl_Position *= w;\n    }\n\n    vUv = uv;\n\n    #include <logdepthbuf_vertex>\n}",fragmentShader$9="#define GLSLIFY 1\n#include <common>\n\nuniform float opacity;\n\nuniform bool useMap;\nuniform bool useCanvasMap;\nuniform sampler2D map;\nuniform float width;\nuniform float height;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_emissive_pars_fragment>\n\nvoid main() {\n\n    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));\n    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);\n\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n    gl_FragColor.a *= clamp(opacity, 0.0, 1.0);\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <mvt_selective_fragment> \n    #include <logdepthbuf_fragment> \n    #include <mvt_emissive_fragment>\n    #include <colorspace_fragment>\n}",textureLoader$1=new three.TextureLoader,uniforms$a=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,keepSizeUniforms,{emissive:{value:[0,0,0]},isEmissive:{value:!1},width:{value:12},height:{value:12},offset:{value:[0,0]},positionOffset:{value:[0,0,0]},ulength:{value:1},useCanvasMap:{value:!1},vertexIcons:{value:!1},opacity:{value:1},map:{value:null},useMap:{value:!1},uFlat:{value:!1},keepSize:{value:!0},scaleRatio:{value:1}}]);class LabelMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="LabelMaterial",this.vertexShader=vertexShader$a,this.fragmentShader=fragmentShader$9,this.isLabelMaterial=!0,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$a)),defineMaterialKeepSizeProperties(this),defineMaterialSelectiveProperties(this),defineMaterialAliasProperties(this,[["flat","uFlat"]]),defineMaterialBoolDefineProperties(this,[["vertexBackgroundCanvas","MVT_USE_VERTEX_SIZE"],["vertexBackgrounds","MVT_USE_VERTEX_SIZE"],["vertexPositionOffsets","MVT_USE_VERTEX_POSITION_OFFSET"]]),defineMaterialNormalProperties(this,["width","height","offset","positionOffset","opacity","emissive","isEmissive","scaleRatio"]),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const t=this.mapSrc,i=this.userData[this.urlCacheKey],n=this;if(i!==e){if(t&&t.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[this.urlCacheKey];textureLoader$1.load(e,(function(t){t.wrapS=t.wrapT=three.ClampToEdgeWrapping,t.colorSpace=three.SRGBColorSpace,n.uniforms.map.value=t,n.userData[n.urlCacheKey]=e,n.uniforms.useMap.value=!0,n.uniforms.useCanvasMap.value=!1}))}}},mapTexture:{get:function(){return this.uniforms.map.value},set:function(e){if(!e)return this.uniforms.map.value=null,void(this.uniforms.useCanvasMap.value=!1);e.wrapS=e.wrapT=three.ClampToEdgeWrapping,e.colorSpace=three.SRGBColorSpace,this.uniforms.map.value=e,this.uniforms.useMap.value=!1,this.uniforms.useCanvasMap.value=!0,delete this.userData[this.urlCacheKey]}}}),this.setValues(e)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class LabelGeometry extends three.BufferGeometry{constructor(e){super(e),this.parameters=e}setData(e){const{vertexBackgrounds:t,vertexBackgroundCanvas:i,vertexPositionOffsets:n}=this.parameters,{aPositions:r,aObjectIndices:s,aUvs:a,pIndices:o,indices:l,aSize:c,aPositionOffsets:h}=e;this.setAttribute("position",new three.Float32BufferAttribute(r,3)),this.setAttribute("pIndex",new three.Float32BufferAttribute(o,1)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(s,1)),this.setAttribute("uv",new three.Float32BufferAttribute(a,2)),(t||i)&&this.setAttribute("aSize",new three.Float32BufferAttribute(c,2)),n&&this.setAttribute("aPositionOffsets",new three.Float32BufferAttribute(h,3)),this.setIndex(l)}}const _tempVector3$1=new three.Vector3,_tempVector4$1=new three.Vector4,_tempMatrix4$1=new three.Matrix4;class TwinLabel extends GeoMesh{constructor(e){super(e),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"isLabel",!0),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"canvas"),__publicField(this,"ctx"),__publicField(this,"texture"),__publicField(this,"iconUrlHash",new Map),__publicField(this,"canvasHash",new Map),__publicField(this,"boxHash",new Map),__publicField(this,"gap",[2,2]),__publicField(this,"_padding"),__publicField(this,"_fillStyle"),__publicField(this,"oldMapTextureRes",{}),__publicField(this,"_instanceIds",[]),__publicField(this,"labelHash"),this.parameters=e,this._padding=[0,0,0,0],this.parameters.padding&&(this.padding=this.parameters.padding),this._fillStyle=this.parameters.fillStyle||"#fff",this.labelHash=new Map;const t=this.canvas=document.createElement("canvas");t.width=t.height=1;(this.ctx=t.getContext("2d")).textAlign="start",this.texture=new three.CanvasTexture(t),this.widthPropName=e.widthPropName||"width",this.heightPropName=e.heightPropName||"height",this.defineMaterialProxyProperties(["width","height","offset","transparent","opacity","flat","keepSize","positionOffset"]),this.boxes=[],this.boxSize=e.boxSize||100,e.labelTest&&(document.body.append(t),t.style.cssText="position: absolute; z-index: 111; top: 10px; left: 10px; background: #fff")}initObject(){const{background:e,fontSize:t,padding:i,fillStyle:n,vertexVisible:r,visiblePropName:s,backgroundCanvasPropName:a,maxCacheSize:o,...l}=this.parameters;this.geometry=new LabelGeometry(this.parameters),this.material=new LabelMaterial(l),this.material.setCommonUniforms(this.engine.rendering.uniforms)}clone(){return new this.constructor(this.parameters)}getDefaultParams(){return{width:12,height:12,fontSize:14}}collisionTest(e){return{width:this.width,height:this.height}}createLabelTexture(e){const{backgroundCanvas:t,backgroundCanvasPropName:i}=e,n=this.labelHash,r=this.iconUrlHash,s=this.canvasHash,a=this.ctx;let o;this.boxes=[];for(let[l,c]of n.entries()){const e=JSON.parse(l),{icon:t,text:i,id:n}=e,a=n?s.get(l):r.get(t);if("string"==typeof a||void 0===a)continue;const o=this.boxes.findIndex((e=>e.key===l));if(o>=0){const e=this.boxes.splice(o,1);this.boxes.unshift(e[0]);continue}const c=a.width,h=a.height,u=c+this.gap[0],d=h+this.gap[1];this.boxes.unshift({w:u,h:d,width:c,height:h,key:l,icon:a,text:i})}for(let l=0;l<this.boxes.length;l++){const e=this.boxes[l];this.boxHash.set(e.key,e)}return createSprite(this.boxes,a,this.canvas,{fillStyle:this._fillStyle,fontSize:this.parameters.fontSize,gap:this.gap,padding:this.padding,dpr:this.engine.rendering.pixelRatio,drawText:!(i||t),textAlign:this.parameters.textAlign})?(this.texture.dispose(),this.texture=new three.CanvasTexture(this.canvas)):this.texture.needsUpdate=!0,o=this.texture,o}async _updateData(){const{vertexSizes:e,vertexBackgrounds:t,vertexBackgroundCanvas:i,vertexPositionOffsets:n,vertexVisible:r=!1,background:s,bgPropName:a="background",textPropName:o="text",visiblePropName:l="visible",backgroundCanvas:c,backgroundCanvasPropName:h}=this.parameters;let u=[];u=this._enableCollision&&this._collisionData?this._collisionData:this.dataSource.userData,u.length>(this.parameters.maxCacheSize||2e3)&&console.warn(`Label数量超过了最大限制，请更新maxCacheSize参数；当前最大值为${this.parameters.maxCacheSize||2e3}`);let d=this.labelHash;const p=this.iconUrlHash,m=this.canvasHash;m.clear(),d.clear();let f,g=d.size,_=d.size,A=[];if(c||h)for(let M=0;M<u.length;M++){let e=this.parameters.vertexBackgroundCanvas?u[M][h]:c;const t=u[M][o],i=JSON.stringify({id:u[M].id||u[M].index,text:String(t)});e instanceof Promise?A.push(e.then((e=>{void 0===m.get(i)&&m.set(i,e)}))):void 0===m.get(i)&&m.set(i,e),void 0===d.get(i)&&(d.set(i,g),g++)}else{for(let e=0;e<u.length;e++){const t=this.parameters.vertexBackgrounds?u[e][a]:s,i=u[e][o],n=JSON.stringify({icon:t,text:String(i)});void 0===p.get(t)&&p.set(t,t),void 0===d.get(n)&&(d.set(n,g),g++)}A=Array.from(p.entries()).filter((e=>"string"==typeof e[1])).map((([e,t])=>new Promise(((t,i)=>{this.url2canvas(e,(i=>{p.set(e,i),t(e)}))}))))}if(A.length>0&&await Promise.all(A),_===g&&this.oldTexture&&(f=this.oldTexture),f||(f=this.createLabelTexture({backgroundCanvasPropName:h,backgroundCanvas:c}),this.oldTexture=f),!f)return;this.material.mapTexture=f,this.material.uniforms.ulength.value=d.size,this._instanceIds=[];const v=[],y=[],x=[],b=[],S=[],C=[],T=[];let E=0;for(let M=0;M<u.length;M++){let d=u[M].position;const p=u[M].index,m=u[M][o],f=u[M][l];if(r&&!1===f)continue;this._instanceIds.push(M);const g=c||h?JSON.stringify({id:u[M].id||u[M].index,text:String(m)}):JSON.stringify({icon:t?u[M][a]:s,text:String(m)}),_=this.boxHash.get(g);if(!_)continue;for(let e=0;e<4;e++)v.push(...d),y.push(e),x.push(p),n&&T.push(...u[M].positionOffset);const A=_.x/this.canvas.width,w=(_.x+_.w)/this.canvas.width,I=(_.y+_.h)/this.canvas.height,P=_.y/this.canvas.height;b.push(A,I,A,P,w,P,w,I);const R=4*E;if(S.push(R,R+2,R+1,R,R+3,R+2),E++,t||i){let t=_.width,i=_.height;const{originWidth:n,originHeight:r}=_.icon;r&&n&&(t=n,i=r),e&&(t=u[M][this.widthPropName],i=u[M][this.heightPropName]),C.push(t,i,t,i,t,i,t,i)}}this.geometry.setData({aPositions:v,pIndices:y,aObjectIndices:x,aUvs:b,indices:S,aSize:C,aPositionOffsets:T}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,v),this.needsUpdate=!1,this.engine.requestRender()}url2canvas(e,t){if("object"==typeof e)t(e);else{let i=new Image;i.crossOrigin="anonymous",i.onload=function(){let e=i.width,n=i.height,r=document.createElement("canvas");r.width=e,r.height=n,r.getContext("2d").drawImage(i,0,0,e,n),t(r)},i.onerror=function(){let e=document.createElement("canvas");e.width=20,e.height=40;let i=e.getContext("2d");i.fillStyle="red",i.beginPath(),i.lineTo(0,0),i.lineTo(20,0),i.lineTo(10,40),i.closePath(),i.fill(),t(e)},i.src=e}}getEntityByIndex(e){const t=this.dataSource;this._enableCollision&&this._collisionData&&(e=this._collisionData[e].index);const i={index:e,value:t.getDataItem(e),itemIndex:t.getDataItemIndex(e),pairs:{}},n=t.data;for(const r of Object.keys(n))i.pairs[r]=n[r][e];return i}raycast(e,t){const i=this.flat;if(!this.visible)return;if(i)return;const n=this.geometry,r=n.getAttribute("position");if(!r||!r.array||0===!r.array.length)return;const s=n.getAttribute("offset");let a=[];s&&(a=s.array);let o=e.camera;o||(o=this.engine.camera);const l=e.mouse;if(!l)return;const c=this.material.uniforms.resolution.value,h=l.x,u=l.y;let d=this.width/c.x,p=this.height/c.y,m=[];const f=n.getAttribute("aSize");f&&(m=f.array);let g=[];const _=n.getAttribute("aPositionOffsets");g=_?_.array:[];let A=0,v=0,y=0,x=0,b=0,S=0;_tempMatrix4$1.multiplyMatrices(o.projectionMatrix,o.matrixWorldInverse),_tempMatrix4$1.multiplyMatrices(_tempMatrix4$1,this.matrixWorld);const C=r.array;let T=0,E=0,M=1;this.keepSize||(M=this.material.uniforms.zoomUnits.value);for(let w=0,I=C.length-11;w<I;w+=12){const e=this.material.positionOffset||[0,0,0];if(this.parameters.vertexPositionOffsets&&(e[0]=g[w],e[1]=g[w+1],e[2]=g[w+2]),_tempVector4$1.set(C[w]+e[0],C[w+1]+e[1],C[w+2]+e[2],1),_tempVector4$1.applyMatrix4(_tempMatrix4$1),_tempVector4$1.divideScalar(_tempVector4$1.w),this.parameters.vertexOffsets?(T=w/12*8,b=a[T]||0,S=a[T+1]||0):(b=this.material.uniforms.offset.value?this.material.uniforms.offset.value[0]:0,S=this.material.uniforms.offset.value?this.material.uniforms.offset.value[1]:0),_tempVector4$1.x+=2*b/c.x/M,_tempVector4$1.y-=2*S/c.y/M,(this.parameters.vertexSizes||this.parameters.vertexBackgrounds||this.parameters.vertexBackgroundCanvas)&&(E=w/12*8,d=m[E]/c.x,p=m[E+1]/c.y),A=_tempVector4$1.x-d/M,y=_tempVector4$1.x+d/M,v=_tempVector4$1.y-p/M,x=_tempVector4$1.y+p/M,A<=h&&y>=h&&v<=u&&x>=u){_tempVector3$1.set(C[w],C[w+1],C[w+2]),_tempVector3$1.applyMatrix4(this.matrixWorld);const e=w/12;const i={instanceId:this._instanceIds[e],object:this,distance:_tempVector3$1.distanceTo(o.position)};t.push(i)}}}set padding(e){2===e.length?this._padding=[e[0],e[1],e[0],e[1]]:3===e.length?this._padding=[e[0],e[1],e[2],e[1]]:e.length>=4&&(this._padding=[e[0],e[1],e[2],e[3]])}get padding(){return this._padding}onDispose(){this.texture&&this.texture.dispose(),this.canvas&&(this.canvas=null),this.iconUrlHash.clear(),this.labelHash.clear(),this.boxHash.clear()}}function sortKD(e,t,i,n,r,s){if(r-n<=i)return;const a=n+r>>1;select(e,t,a,n,r,s%2),sortKD(e,t,i,n,a-1,s+1),sortKD(e,t,i,a+1,r,s+1)}function select(e,t,i,n,r,s){for(;r>n;){if(r-n>600){const a=r-n+1,o=i-n+1,l=Math.log(a),c=.5*Math.exp(2*l/3),h=.5*Math.sqrt(l*c*(a-c)/a)*(o-a/2<0?-1:1);select(e,t,i,Math.max(n,Math.floor(i-o*c/a+h)),Math.min(r,Math.floor(i+(a-o)*c/a+h)),s)}const a=t[2*i+s];let o=n,l=r;for(swapItem(e,t,n,i),t[2*r+s]>a&&swapItem(e,t,n,r);o<l;){for(swapItem(e,t,o,l),o++,l--;t[2*o+s]<a;)o++;for(;t[2*l+s]>a;)l--}t[2*n+s]===a?swapItem(e,t,n,l):(l++,swapItem(e,t,l,r)),l<=i&&(n=l+1),i<=l&&(r=l-1)}}function swapItem(e,t,i,n){swap(e,i,n),swap(t,2*i,2*n),swap(t,2*i+1,2*n+1)}function swap(e,t,i){const n=e[t];e[t]=e[i],e[i]=n}function range(e,t,i,n,r,s,a){const o=[0,e.length-1,0],l=[];let c,h;for(;o.length;){const u=o.pop(),d=o.pop(),p=o.pop();if(d-p<=a){for(let a=p;a<=d;a++)c=t[2*a],h=t[2*a+1],c>=i&&c<=r&&h>=n&&h<=s&&l.push(e[a]);continue}const m=Math.floor((p+d)/2);c=t[2*m],h=t[2*m+1],c>=i&&c<=r&&h>=n&&h<=s&&l.push(e[m]);const f=(u+1)%2;(0===u?i<=c:n<=h)&&(o.push(p),o.push(m-1),o.push(f)),(0===u?r>=c:s>=h)&&(o.push(m+1),o.push(d),o.push(f))}return l}function within(e,t,i,n,r,s){const a=[0,e.length-1,0],o=[],l=r*r;for(;a.length;){const c=a.pop(),h=a.pop(),u=a.pop();if(h-u<=s){for(let r=u;r<=h;r++)sqDist(t[2*r],t[2*r+1],i,n)<=l&&o.push(e[r]);continue}const d=Math.floor((u+h)/2),p=t[2*d],m=t[2*d+1];sqDist(p,m,i,n)<=l&&o.push(e[d]);const f=(c+1)%2;(0===c?i-r<=p:n-r<=m)&&(a.push(u),a.push(d-1),a.push(f)),(0===c?i+r>=p:n+r>=m)&&(a.push(d+1),a.push(h),a.push(f))}return o}function sqDist(e,t,i,n){const r=e-i,s=t-n;return r*r+s*s}const defaultGetX=e=>e[0],defaultGetY=e=>e[1];class KDBush{constructor(e,t=defaultGetX,i=defaultGetY,n=64,r=Float64Array){this.nodeSize=n,this.points=e;const s=e.length<65536?Uint16Array:Uint32Array,a=this.ids=new s(e.length),o=this.coords=new r(2*e.length);for(let l=0;l<e.length;l++)a[l]=l,o[2*l]=t(e[l]),o[2*l+1]=i(e[l]);sortKD(a,o,n,0,a.length-1,0)}range(e,t,i,n){return range(this.ids,this.coords,e,t,i,n,this.nodeSize)}within(e,t,i){return within(this.ids,this.coords,e,t,i,this.nodeSize)}}const defaultOptions={minZoom:0,maxZoom:16,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:e=>e};class Supercluster{constructor(e){this.options=extend(Object.create(defaultOptions),e),this.trees=new Array(this.options.maxZoom+1)}convertDataItemsToGeoJSON(e){return e.map((e=>({type:"Feature",properties:e.attributes,geometry:{type:"Point",coordinates:e.coordinates}})))}load(e){const{log:t,minZoom:i,maxZoom:n,nodeSize:r}=this.options;t&&console.time("total time");const s=`prepare ${e.length} points`;t&&console.time(s),this.points=this.convertDataItemsToGeoJSON(e);let a=[];for(let o=0;o<this.points.length;o++){const e=this.points[o];(Array.isArray(e)||e.geometry)&&a.push(createPointCluster(e,o))}this.trees[n+1]=new KDBush(a,getX,getY,r,Float32Array),t&&console.timeEnd(s);for(let o=n;o>=i;o--)a=this._cluster(a,o),this.trees[o]=new KDBush(a,getX,getY,r,Float32Array);return t&&console.timeEnd("total time"),this}getClusters(e,t){let i=((e[0]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,e[1]));let r=180===e[2]?180:((e[2]+180)%360+360)%360-180;const s=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)i=-180,r=180;else if(i>r){const e=this.getClusters([i,n,180,s],t),a=this.getClusters([-180,n,r,s],t);return e.concat(a)}const a=this.trees[this._limitZoom(t)],o=a.range(lngX(i),latY(s),lngX(r),latY(n)),l=[];for(const c of o){const e=a.points[c];l.push(e.numPoints?getClusterJSON(e):this.points[e.index])}return l}getChildren(e){const t=this._getOriginId(e),i=this._getOriginZoom(e),n="No cluster with the specified id.",r=this.trees[i];if(!r)throw new Error(n);const s=r.points[t];if(!s)throw new Error(n);const a=this.options.radius/(this.options.extent*Math.pow(2,i-1)),o=r.within(s.x,s.y,a),l=[];for(const c of o){const t=r.points[c];t.parentId===e&&l.push(t.numPoints?getClusterJSON(t):this.points[t.index])}if(0===l.length)throw new Error(n);return l}getLeaves(e,t,i){t=t||10,i=i||0;const n=[];return this._appendLeaves(n,e,t,i,0),n}getTile(e,t,i){const n=this.trees[this._limitZoom(e)],r=Math.pow(2,e),{extent:s,radius:a}=this.options,o=a/s,l=(i-o)/r,c=(i+1+o)/r,h={features:[]};return this._addTileFeatures(n.range((t-o)/r,l,(t+1+o)/r,c),n.points,t,i,r,h),0===t&&this._addTileFeatures(n.range(1-o/r,l,1,c),n.points,r,i,r,h),t===r-1&&this._addTileFeatures(n.range(0,l,o/r,c),n.points,-1,i,r,h),h.features.length?h:null}getClusterExpansionZoom(e){let t=this._getOriginZoom(e)-1;for(;t<=this.options.maxZoom;){const i=this.getChildren(e);if(t++,1!==i.length)break;e=i[0].properties.cluster_id}return t}_appendLeaves(e,t,i,n,r){const s=this.getChildren(t);for(const a of s){const t=a.properties;if(t&&t.cluster?r+t.point_count<=n?r+=t.point_count:r=this._appendLeaves(e,t.cluster_id,i,n,r):r<n?r++:e.push(a),e.length===i)break}return r}_addTileFeatures(e,t,i,n,r,s){for(const a of e){const e=t[a],o=e.numPoints,l={type:1,geometry:[[Math.round(this.options.extent*(e.x*r-i)),Math.round(this.options.extent*(e.y*r-n))]],tags:o?getClusterProperties(e):this.points[e.index].properties};let c;o?c=e.id:this.options.generateId?c=e.index:this.points[e.index].id&&(c=this.points[e.index].id),void 0!==c&&(l.id=c),s.features.push(l)}}_limitZoom(e){return Math.max(this.options.minZoom,Math.min(e,this.options.maxZoom+1))}_cluster(e,t){const i=[],{radius:n,extent:r,reduce:s}=this.options,a=n/(r*Math.pow(2,t));for(let o=0;o<e.length;o++){const n=e[o];if(n.zoom<=t)continue;n.zoom=t;const r=this.trees[t+1],l=r.within(n.x,n.y,a);let c=n.numPoints||1,h=n.x*c,u=n.y*c,d=s&&c>1?this._map(n,!0):null;const p=(o<<5)+(t+1)+this.points.length;for(const e of l){const i=r.points[e];if(i.zoom<=t)continue;i.zoom=t;const a=i.numPoints||1;h+=i.x*a,u+=i.y*a,c+=a,i.parentId=p,s&&(d||(d=this._map(n,!0)),s(d,this._map(i)))}1===c?i.push(n):(n.parentId=p,i.push(createCluster(h/c,u/c,p,c,d)))}return i}_getOriginId(e){return e-this.points.length>>5}_getOriginZoom(e){return(e-this.points.length)%32}_map(e,t){if(e.numPoints)return t?extend({},e.properties):e.properties;const i=this.points[e.index].properties,n=this.options.map(i);return t&&n===i?extend({},n):n}}function createCluster(e,t,i,n,r){return{x:e,y:t,zoom:1/0,id:i,parentId:-1,numPoints:n,properties:r}}function createPointCluster(e,t){const[i,n]=Array.isArray(e)?e:e.geometry.coordinates;return{x:lngX(i),y:latY(n),zoom:1/0,index:t,parentId:-1}}function getClusterJSON(e){return{type:"Feature",id:e.id,properties:getClusterProperties(e),geometry:{type:"Point",coordinates:[xLng(e.x),yLat(e.y)]}}}function getClusterProperties(e){const t=e.numPoints,i=t>=1e4?`${Math.round(t/1e3)}k`:t>=1e3?Math.round(t/100)/10+"k":t;return extend(extend({},e.properties),{cluster:!0,cluster_id:e.id,point_count:t,point_count_abbreviated:i})}function lngX(e){return e/360+.5}function latY(e){const t=Math.sin(e*Math.PI/180),i=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return i<0?0:i>1?1:i}function xLng(e){return 360*(e-.5)}function yLat(e){const t=(180-360*e)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}function extend(e,t){for(const i in t)e[i]=t[i];return e}function getX(e){return e.x}function getY(e){return e.y}class PointGroup extends GeoObject{constructor(){super(...arguments),__publicField(this,"isEventEntitySupported",!0)}addComponent(e){if(!e.isGeoObject)return void console.warn("Only GeoObject can be added");e.__eventProxyByParent=!0,this.add(e),e.afterAddToEngine(this.engine);const t=this.getChildDataSource(e);return t&&(e.dataSource=t),this.needsUpdate=!0,e}removeComponent(e){this.remove(e),e.__eventProxyByParent=!1,e.dataSource=null,e.beforeRemoveFromEngine(this.engine),this.needsUpdate=!0}getChildDataSource(e){return this.dataSource}onBeforeScenePrepareRender(e,t,i,n){super.onBeforeScenePrepareRender&&super.onBeforeScenePrepareRender(e,t,i,n);for(const r of this.children)r.onBeforeScenePrepareRender&&r.onBeforeScenePrepareRender(e,t,i,n)}onBeforeSceneRender(e,t,i,n){super.onBeforeSceneRender&&super.onBeforeSceneRender(e,t,i,n);for(const r of this.children)r.onBeforeSceneRender&&r.onBeforeSceneRender(e,t,i,n)}setDataSource(e){super.setDataSource(e);for(const t of this.children)t.setDataSource(this.getChildDataSource(t))}_updateData(){for(const e of this.children)e.needsUpdate&&e._updateData();this.needsUpdate=!1}dispose(){for(const e of this.children)this.removeComponent(e)}}const defaultIconOptions={width:30,height:30,mapSrc:"https://bj.bcebos.com/v1/yanpan-screen-attachment/resources/image/yinlianPOC/djiudian.png"},defaultTextOptions={fillStyle:"#ccc",fontSize:16,flat:!1},defaultClusterOptions={maxZoom:18,minZoom:5,radius:50};class ClusterPoint extends PointGroup{constructor(e={}){super(e),__publicField(this,"_ready"),__publicField(this,"_cluster"),__publicField(this,"_clusterDataSource"),__publicField(this,"_icon"),__publicField(this,"_label"),__publicField(this,"_minUpdateInterval"),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"_minUpdateInterval",300),__publicField(this,"_lastUpdateTime",0),__publicField(this,"_updateTimeoutHandler",null),__publicField(this,"_clusterData",[]),__publicField(this,"_updateRenderingData",(()=>{const{map:e}=this.engine,t=e.getBoundingBox(),i=Math.round(e.getZoom()),n=this._cluster.getClusters([...t.min,...t.max],i);this._clusterData=n,this._clusterDataSource.objects.length>0&&this._clusterDataSource.setData(n),this._clusterDataSource.update();for(const r of this.children)r._updateData()})),this.parameters=e,this._ready=!1,this._cluster=new Supercluster(Object.assign({},defaultClusterOptions,e.cluster)),this._cluster.load([]);(this._clusterDataSource=new GeoJSONDataSource).defineAttribute("size").defineAttribute("icon").defineAttribute("text",(e=>(e&&e.cluster?e.point_count:0)+""))}initObject(){}afterAddToEngine(e){super.afterAddToEngine(e);const t=this.parameters;t.icon&&(this._icon=this.addComponent(new Icon(Object.assign({},defaultIconOptions,t.icon)))),t.label&&(this._label=this.addComponent(new TwinLabel(Object.assign({},defaultTextOptions,t.label)))),this._ready=!0}_updateData(){let e=this.dataSource.data;this.cachedData=e,this._cluster.load(this.dataSource.dataItems),this.needsUpdate=!1}onBeforeScenePrepareRender(e,t,i,n){if(!this._ready||!this.dataSource)return;this._needsUpdate&&this._updateRenderingData(),clearTimeout(this._updateTimeoutHandler);const r=n.time;if(r-this._lastUpdateTime>this._minUpdateInterval)return this._updateRenderingData(),void(this._lastUpdateTime=r);this._updateTimeoutHandler=setTimeout((()=>{this._updateRenderingData(),e.requestRender()}),this._minUpdateInterval),super.onBeforeScenePrepareRender(e,t,i,n)}getChildDataSource(){return this._clusterDataSource}getEntityByIndex(e){const t=this._clusterDataSource;if(!t)return;const i={index:e,value:t.getDataItem(e),itemIndex:t.getDataItemIndex(e),pairs:{}},n=t.data;for(const r of Object.keys(n))i.pairs[r]=n[r][e];return i}get minUpdateInterval(){return this._minUpdateInterval}set minUpdateInterval(e){e<16&&(e=16),this._minUpdateInterval=e}get clusterDataSource(){return this._clusterDataSource}get clusterData(){return this._clusterData}}const vertexShader$9="#define GLSLIFY 1\n#include <common>\n\nuniform float height;\n#if defined(USE_SIZE3)\n    uniform vec3 size3;\n#else\n    uniform float size;\n#endif\n#ifdef IS_GLOBE\n    attribute mat4 ecefMatrix;\n#endif\n\nuniform float elapsedTime;\nattribute float instancedRandomFactor;\n\n#if defined(VERTEX_COLOR4)\n    attribute vec4 color;\n    varying vec4 vColor;\n#elif defined(VERTEX_COLOR3)\n    attribute vec3 color;\n    varying vec3 vColor;\n#endif\n\n#if defined(MVT_USE_VERTEX_COLOR)\n    varying vec3 vInstanceColor;\n#endif\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n#endif\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\n#define MVT_KEEP_PROJECTION_POSITION\n\n#include <logdepthbuf_pars_vertex>\nvec3 transformPosition(vec3 p, mat4 im) {\n    vec3 transformed = vec3(p);\n\n    #include <mvt_animation_vertex>\n\n    #ifndef MVT_USE_VERTEX_SIZE\n        #if defined(USE_SIZE3)\n            transformed *= size3;\n        #else\n            transformed *= size;\n        #endif\n    #endif\n    transformed.z += height;\n\n    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\n    float pixelSize = getPixelSize(vec3(modelMatrix * im * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n\n    return transformed;\n}\nvoid main() {\n    #ifdef USE_MAP\n        vUv = uv;\n    #endif\n    \n    #if defined(VERTEX_COLOR4)\n        vColor = vec4(color);\n    #elif defined(VERTEX_COLOR3)\n        vColor = vec3(color);\n    #endif\n\n    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)\n        vInstanceColor = instanceColor.xyz;\n    #endif\n\n    #include <mvt_selective_vertex>\n    vec4 mvp_projectPosition;\n\n    mat4 currentInstanceMatrix = instanceMatrix;\n    #ifdef IS_GLOBE\n        currentInstanceMatrix = instanceMatrix * ecefMatrix;\n    #endif\n    vec3 transformed = transformPosition(position, currentInstanceMatrix);\n    \n    gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(transformed, 1.0);\n    \n    mvp_projectPosition = gl_Position;\n\n    #include <logdepthbuf_vertex>\n}",fragmentShader$8="#define GLSLIFY 1\n#include <common>\n#include <map_pars_fragment>\n\n#if defined(MVT_USE_VERTEX_COLOR)\n    varying vec3 vInstanceColor;\n#endif\n\n#if defined(VERTEX_COLOR4)\n    varying vec4 vColor;\n#elif defined(VERTEX_COLOR3)\n    varying vec3 vColor;\n#else\n    uniform vec3 color;\n#endif\n\nuniform float opacity;\nuniform vec3 emissive;\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n#endif\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#define MVT_EMISSIVE_SHADER\nvoid main() {\n\n    #include <logdepthbuf_fragment> \n\n    #if defined(VERTEX_COLOR4)\n        gl_FragColor = vColor;\n    #elif defined(VERTEX_COLOR3)\n        gl_FragColor = vec4(vColor, 1.0);\n    #elif defined(USE_MAP)\n        gl_FragColor = texture2D( map, vUv );\n    #else\n        gl_FragColor = vec4(color, 1.0);\n    #endif\n\n    #if defined(MVT_USE_VERTEX_COLOR)\n        gl_FragColor.rgb *= vInstanceColor;\n    #endif\n      \n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n    vec4 out_emissive = vec4(emissive, 1.0);\n    #include <mvt_selective_fragment>\n\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}",uniforms$9=three.UniformsUtils.merge([{emissive:{value:[0,0,0]},isEmissive:{value:!1},map:{value:null}}]);class InstancedEffectModelMaterial extends InstancedEffectPointMaterial{constructor(e){super(),this.name="InstancedEffectModelMaterial",this.isInstancedEffectModelMaterial=!0,this.vertexShader=vertexShader$9,this.fragmentShader=fragmentShader$8,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$9)),this.defines={},defineMaterialNormalProperties(this,["emissive","isEmissive"]),defineMaterialBoolDefineProperties(this,[["isGlobe","IS_GLOBE"],["useVertexColors","MVT_USE_VERTEX_COLOR"],["useVertexSizes","MVT_USE_VERTEX_SIZE"]]),Object.defineProperty(this,"map",{get:function(){return this.uniforms.map.value},set:function(e){this.uniforms.map.value=e}}),this.setValues(e)}get vertexColors4(){return this.defines.VERTEX_COLOR4=!0}set vertexColors4(e){e!==this.defines.VERTEX_COLOR4&&(this.defines.VERTEX_COLOR4=!!e,this.needsUpdate=!0)}get vertexColors3(){return this.defines.VERTEX_COLOR3=!0}set vertexColors3(e){e!==this.defines.VERTEX_COLOR3&&(this.defines.VERTEX_COLOR3=!!e,this.needsUpdate=!0)}}const defaultParameters={normalize:!0,rotateToZUp:!0,keepSize:!0};class EffectModelPoint extends GeoObject{constructor(e){super(),__publicField(this,"_model"),__publicField(this,"_normalize"),__publicField(this,"_rotateToZUp"),__publicField(this,"_keepSize"),__publicField(this,"_size"),__publicField(this,"_size3"),__publicField(this,"_useSize3"),__publicField(this,"_height"),__publicField(this,"_animationRotate"),__publicField(this,"_animationRotatePeriod"),__publicField(this,"_animationJump"),__publicField(this,"_animationJumpPeriod"),__publicField(this,"_animationJumpHeight"),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"_model",null),__publicField(this,"_normalize",!0),__publicField(this,"_rotateToZUp",!0),__publicField(this,"_keepSize",!0),__publicField(this,"_size",1),__publicField(this,"_size3",[1,1,1]),__publicField(this,"_useSize3",!1),__publicField(this,"_height",0),__publicField(this,"_animationRotate",!1),__publicField(this,"_animationRotatePeriod",3e3),__publicField(this,"_animationJump",!1),__publicField(this,"_animationJumpPeriod",3e3),__publicField(this,"_animationJumpHeight",30),__publicField(this,"_updateModel",(()=>{this._cleanOldMesh();const e=parseScene(this._model,this._normalize,this._rotateToZUp),{normalize:t,rotateToZUp:i,...n}=this.parameters;for(const r of e){const e=r.material;let t=new InstancedEffectModelMaterial;t.isGlobe=this.engine.map.isGlobe,t.useVertexColors=n.vertexColors,t.useVertexSizes=n.vertexSizes,t.setCommonUniforms(this.engine.rendering.uniforms),t.transparent=e.transparent,t.opacity=e.opacity,t.side=e.side,t.depthWrite=e.depthWrite,t.depthTest=e.depthTest,t.depthFunc=e.depthFunc,t.blendDst=e.blendDst,t.blendDstAlpha=e.blendDstAlpha,t.blendEquation=e.blendEquation,t.blendEquationAlpha=e.blendEquationAlpha,t.blending=e.blending,t.blendSrc=e.blendSrc,t.blendSrcAlpha=e.blendSrcAlpha,t.premultipliedAlpha=e.premultipliedAlpha,t.color=e.color,t.colorWrite=e.colorWrite,t.emissive=e.emissive,t.map=e.map,t.keepSize=this._keepSize,t.size=this._size,t.size3=this._size3,t.useSize3=this._useSize3,t.height=this._height,t.animationRotate=this._animationRotate,t.animationRotatePeriod=this._animationRotatePeriod,t.animationJump=this._animationJump,t.animationJumpPeriod=this._animationJumpPeriod,t.animationJumpHeight=this._animationJumpHeight;const i=r.geometry,s=i.getAttribute("color");s&&(4===s.itemSize?t.vertexColors4=!0:3===s.itemSize&&(t.vertexColors3=!0));const a=new GeoInstancedPointMesh(i,t,this.parameters);a.engine=this.engine,a.dataAutoUpdate=!1,a.__eventProxyByParent=!0,this.dataSource&&(a.dataSource=this.dataSource),this.add(a)}this.needsUpdate=!0})),__publicField(this,"_cleanOldMesh",(()=>{const e=this.children;for(let t=e.length-1;t>=0;t--){const i=e[t];this.remove(i),i.geometry&&i.geometry.dispose(),i.material&&(i.material.map&&i.material.map.dispose(),i.material.dispose())}})),__publicField(this,"_defineChildrenMaterialProperty",(e=>{Object.defineProperty(this,e,{get:function(){return this["_"+e]},set:function(t){this["_"+e]=t;for(const i of this.children)i.material[e]=t}})})),e=Object.assign({},defaultParameters,e),this._normalize=e.normalize,this._rotateToZUp=e.rotateToZUp,this.parameters=e,["size","size3","useSize3","height","keepSize","animationRotate","animationRotatePeriod","animationJump","animationJumpPeriod","animationJumpHeight"].forEach((t=>{void 0!==e[t]&&(this["_"+t]=e[t]),this._defineChildrenMaterialProperty(t)}))}initObject(){this._initDefaultModel()}_initDefaultModel(){if(!this._model)if(EffectModelPoint.defaultModel)this._model=EffectModelPoint.defaultModel.clone(!0),this._updateModel();else if(EffectModelPoint.defaultModelLoading)EffectModelPoint.defaultModelLoading.then((e=>{this._model||(this._model=e.clone(!0),this._updateModel())}));else{const e=gltfLoader.loadAsync(getAssetUrl("assets/models/effect/diamond.glb")).then((e=>{const t=e.scene;return EffectModelPoint.defaultModel=t,t}));EffectModelPoint.defaultModelLoading=e,e.then((e=>{this._model||(this._model=e.clone(!0),this._updateModel())})).catch((e=>{console.error("Failed to load default model:",e)}))}}_updateData(){const e=this.dataSource;for(const t of this.children)t.dataSource=e,t._updateData();this.needsUpdate=!1}onDispose(){this._cleanOldMesh()}set model(e){e!==this._model&&(this._model=e,this._updateModel())}get model(){return this._model}}const vertexShader$8="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#endif\n\n#ifndef MVT_USE_VERTEX_SIZE\n    uniform float size;\n#endif\n\n#ifdef IS_GLOBE\n    attribute mat4 ecefMatrix;\n#endif\n\nvarying vec2 vPosition;\nvarying float vScale;\n\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n\n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n\n    vec3 transformed = vec3(position);\n    #ifdef MVT_USE_VERTEX_SIZE\n        vScale = instanceMatrix[0][0];\n    #else\n        vScale = size;\n        transformed *= size;\n    #endif\n\n    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\n    float pixelSize = getPixelSize(vec3(modelMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n\n    #ifdef IS_GLOBE\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * ecefMatrix * vec4(transformed, 1.0);\n    #else\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);\n    #endif\n    #include <logdepthbuf_vertex>\n\n    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)\n        vColor.xyz = instanceColor.xyz;\n        vColor.a = 1.0;\n    #endif\n}",fragmentShader$7="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec3 color;\n#endif\nuniform vec3 borderColor;\nuniform float opacity;\nuniform float borderOpacity;\nuniform float fillOpacity;\nuniform float radius;\nuniform float borderWidth;\n\nvarying vec2 vPosition;\nvarying float vScale;\n\n#include <logdepthbuf_pars_fragment>\n#include <mvt_selective_pars_fragment>\n\nvoid main() {\n    float dis = distance(vPosition, vec2(0, 0));\n\n    // 用来保持边框的宽度不会随着缩放而变化\n    float radius2 = radius - (borderWidth / vScale) * radius;\n\n    // 用于抗锯齿\n    float blur = 0.001;\n    float pct = (1.0 - smoothstep(radius - blur, radius + blur, dis));\n    vec4 border = vec4(borderColor, borderOpacity);\n    #ifdef MVT_USE_VERTEX_COLOR\n        vec4 currentColor = mix(vec4(vColor.rgb, fillOpacity), border, smoothstep( radius2 - blur,radius2 + blur, dis));\n    #else\n        vec4 currentColor = mix(vec4(color, fillOpacity), border, smoothstep( radius2 - blur,radius2 + blur, dis));\n    #endif\n\n    // 设置的自身颜色的透明度优先级高于设置的opacity优先级\n    gl_FragColor = vec4(currentColor.rgb, pct * currentColor.a);\n    if (gl_FragColor.a < 0.001) {\n        discard;\n    }\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment>\n    #include <colorspace_fragment>\n}",fragmentShaderGradient="#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec3 color;\n#endif\nuniform float radius;\nuniform float opacity;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > 0.5) {\n        discard;\n    }\n    vec4 fillColor;\n    #ifdef MVT_USE_VERTEX_COLOR\n        fillColor = vColor;\n    #else\n        fillColor = vec4(color, 1.0);\n    #endif\n    \n    fillColor.a = smoothstep(0.0, 1.0, pow(d / radius, 2.0));\n    // 边缘抗锯齿\n    if(d > -0.99 * radius) {\n        fillColor.a *= 1.0 - smoothstep(0.99, 1.0, d / radius); \n    }\n    fillColor.a *= opacity;\n    gl_FragColor = fillColor;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment>   \n    #include <colorspace_fragment>\n}";let uniforms$8=three.UniformsUtils.merge([emissiveUniforms,{color:{value:[1,.5,0]},borderColor:{value:[0,1,0]},borderOpacity:{value:1},fillOpacity:{value:1},opacity:{value:1},radius:{value:.5},borderWidth:{value:1},isEmissive:{value:!1}}]);class InstancedCircleMaterial extends InstancedEffectPointMaterial{constructor(e){super(),__publicField(this,"name","CircleMaterial"),__publicField(this,"isCircleMaterial",!0),this.depthTest=!1,this.depthWrite=!1,e.vertexSizes||(uniforms$8=three.UniformsUtils.merge([uniforms$8,{size:{value:100}}])),Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$8)),defineMaterialNormalProperties(this,["borderWidth","borderOpacity","fillOpacity","isEmissive"]),defineMaterialColorProperties(this,["borderColor"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexSizes","MVT_USE_VERTEX_SIZE"],["isGlobe","IS_GLOBE"]]),defineMaterialEmissiveProperties(this),this.vertexShader=vertexShader$8,"Gradient"===e.type?this.fragmentShader=fragmentShaderGradient:this.fragmentShader=fragmentShader$7,this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}}class Circle extends GeoInstancedPointMesh{constructor(e){super(e),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"color"),__publicField(this,"size"),__publicField(this,"opacity"),__publicField(this,"type"),__publicField(this,"borderColor"),__publicField(this,"borderWidth"),__publicField(this,"borderOpacity"),__publicField(this,"fillOpacity"),this.parameters=e,this.defineMaterialProxyProperties(["color","size","size3","opacity","borderWidth","borderColor","borderOpacity","fillOpacity","radius","keepSize","transparent"])}initObject(){const e=this.engine.map.isGlobe;this.geometry=new InstancedPlaneBufferGeometry,this.material=new InstancedCircleMaterial(this.parameters),this.material.isGlobe=e,this.material.setCommonUniforms(this.engine.rendering.uniforms)}collisionTest(e){let t=0;return this.material.keepSize&&(t=this.parameters.vertexSizes&&e.size?e.size:this.size),{width:t,height:t}}}class BasePillarGeometry extends three.BufferGeometry{constructor(e){var t,i,n,r,s,a;super(e),__publicField(this,"_needsUpdate",!1),__publicField(this,"setModelData",(()=>{this._needsUpdate=!0,this.updateGeometry()})),this.parameters={...e,radiusTop:null!=(i=null!=(t=e.radiusTop)?t:e.radius)?i:6,radiusBottom:null!=(r=null!=(n=e.radiusBottom)?n:e.radius)?r:6,height:null!=(s=e.height)?s:1,openEnded:defaultValue$1(e.openEnded,!0),color:null!=(a=e.color)?a:[80,20,170,.8]},this.parameters.radialSegments=e.radialSegments?Math.floor(e.radialSegments):4,this.parameters.heightSegments=e.heightSegments?Math.floor(e.heightSegments):1,this.setModelData()}updateGeometry(){const e=[],t=[],i=[],n=[],r=[];let s={index:0,indexArray:[],halfHeight:0,groupStart:0};this.generateTorso(e,t,i,n,r,s),this.parameters.radiusTop>0&&this.generateCap(!0,e,t,i,n,r,s),!1===this.parameters.openEnded&&this.parameters.radiusBottom>0&&this.generateCap(!1,e,t,i,n,r,s),this.addCustomGeometry(e,t,i,n,r,s),this.setIndex(e),this.setAttribute("position",new three.Float32BufferAttribute(t,3)),this.setAttribute("normal",new three.Float32BufferAttribute(i,3)),this.setAttribute("uv",new three.Float32BufferAttribute(n,2)),this.addCustomAttribute(r),this._needsUpdate=!1}addCustomGeometry(){}addCustomAttribute(){}generateCap(e,t,i,n,r,s,a){}generateTorso(e,t,i,n,r,s){}get needsUpdate(){return this._needsUpdate}set needsUpdate(e){this._needsUpdate=e}}class PillarGeometry extends BasePillarGeometry{constructor(e){e.shape=defaultValue$1(e.shape,"pillar"),super(e),this.type="PillarGeometry"}isCone(){return"cone"===this.parameters.shape}addRadiusFunc(e){return 1-Math.sqrt(e)}generateTorso(e,t,i,n,r,s){const a=new three.Vector3,o=new three.Vector3;let l=0;for(let c=0;c<=this.parameters.heightSegments;c++){const e=[],r=c/this.parameters.heightSegments;let l;this.isCone()?(l=this.addRadiusFunc(r),this.parameters.vertexSizes||(l*=this.parameters.size)):l=(1-r)*this.parameters.radiusBottom+r*this.parameters.radiusTop;for(let c=0;c<=this.parameters.radialSegments;c++){const h=c/this.parameters.radialSegments,u=2*h*Math.PI,d=Math.sin(u),p=Math.cos(u);if(a.x=l*d,a.y=l*p,a.z=this.parameters.vertexHeights?r:r*this.parameters.height,t.push(a.x,a.y,a.z),this.isCone()){const e=this.parameters.radiusBottom/this.parameters.height;o.set(d,p,e).normalize()}else{const e=(this.parameters.radiusBottom-this.parameters.radiusTop)/this.parameters.height;o.set(d,p,e).normalize()}i.push(o.x,o.y,o.z),n.push(h,r),e.push(s.index++)}s.indexArray.push(e)}for(let c=0;c<this.parameters.radialSegments;c++)for(let t=0;t<this.parameters.heightSegments;t++){const i=s.indexArray[t][c],n=s.indexArray[t+1][c],r=s.indexArray[t+1][c+1],a=s.indexArray[t][c+1];e.push(i,n,a),e.push(n,r,a),l+=6}this.addGroup(s.groupStart,l,0),s.groupStart+=l}generateCap(e,t,i,n,r,s,a){if(this.isCone()&&e)return;const o=a.index,l=new three.Vector3;let c=0;const h=this.isCone()?this.parameters.vertexSizes?1:this.parameters.size:e?this.parameters.radiusTop:this.parameters.radiusBottom,u=e?1:0,d=e?1:-1;for(let m=1;m<=this.parameters.radialSegments;m++){const e=this.parameters.vertexHeights?u:u*this.parameters.height;i.push(0,0,e),n.push(0,0,d),r.push(.5,u),a.index++}const p=a.index;for(let m=0;m<=this.parameters.radialSegments;m++){const e=2*(m/this.parameters.radialSegments)*Math.PI,t=Math.cos(e),s=Math.sin(e);l.x=h*s,l.y=h*t,l.z=this.parameters.vertexHeights?u:u*this.parameters.height,i.push(l.x,l.y,l.z),n.push(0,0,d),r.push(.5,u),a.index++}for(let m=0;m<this.parameters.radialSegments;m++){const i=o+m,n=p+m;e?t.push(n+1,n,i):t.push(n,n+1,i),c+=3}this.addGroup(a.groupStart,c,e?1:2),a.groupStart+=c}generateTopSphere(e,t,i,n,r,s){this.parameters.sphereIndex=s.index}addCustomGeometry(e,t,i,n,r,s){this.generateTopSphere(e,t,i,n,r,s)}}const vertexShader$7="#define GLSLIFY 1\n#include <common>\n\nuniform float maxHeight;\nuniform bool heatmap;\nvarying vec2 vUv;\n\n#ifdef IS_GLOBE\n    attribute mat4 ecefMatrix;\n#endif\n\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\n    #ifdef IS_GLOBE\n        mat4 adjustedInstanceMatrix = instanceMatrix;\n        float height = adjustedInstanceMatrix[2][2];\n        adjustedInstanceMatrix[2][2] = 1.0;\n        vec4 transformed = vec4(position.x, position.y, position.z * height, 1.0);\n        gl_Position = projectionMatrix * modelViewMatrix * adjustedInstanceMatrix * ecefMatrix * transformed;\n    #else\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n    #endif\n\n    #ifdef MVT_USE_VERTEX_HEIGHT\n        float instanceHeight = instanceMatrix[2][2];\n        if (heatmap) {\n            vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));\n        }\n        else {\n            vUv = vec2(uv.x, uv.y);\n        }\n    #else\n        vUv = uv;\n    #endif\n\n    #include <logdepthbuf_vertex>\n}",fragmentShaderPillar="#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D gradientMap;\nuniform float opacity;\n\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    gl_FragColor = texture2D(gradientMap, vUv.yx);\n    gl_FragColor.a *= opacity;\n\n    #include <logdepthbuf_fragment>\n    #include <colorspace_fragment>\n}",fragmentShaderCone="#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D gradientMap;\nuniform float opacity;\n\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    gl_FragColor = texture2D(gradientMap, vUv.yx);\n    gl_FragColor.a *= opacity;\n\n    #include <logdepthbuf_fragment>\n    #include <colorspace_fragment>\n}",DEFAULT_GRADIENT={0:"rgba(0,0,255,1)",.3:"rgba(0,255,0,1)",.6:"rgba(255,255,0,1)",1:"rgba(255,0,0,1)"},DEFAULT_BAND=["rgba(0,0,255,1)","rgba(0,255,0,1)","rgba(255,255,0,1)","rgba(255,0,0,1)"];function createDefaultGradientTexture(e=64,t=2){return createGradientTexture(DEFAULT_GRADIENT,e,t)}function createGradientTexture(e={},t=64,i=2){const n=document.createElement("canvas");n.width=t,n.height=i;const r=n.getContext("2d"),s=r.createLinearGradient(0,0,t,0),a=Object.keys(e).map((e=>parseFloat(e))).filter((e=>!isNaN(e)&&e>=0&&e<=1)).sort(((e,t)=>e-t));if(0===a.length)return console.warn("No valid gradient stops provided. Skipping texture creation."),new three.CanvasTexture(n);for(const o of a)s.addColorStop(o,e[o]);return r.fillStyle=s,r.fillRect(0,0,t,i),new three.CanvasTexture(n)}function updateGradientTexture(e,t,i=64,n=2){if(!e||!t)return;if("[object Object]"!==Object.prototype.toString.call(t))return;const r=e.image.getContext("2d");r.clearRect(0,0,i,n);const s=r.createLinearGradient(0,0,i,0);for(const a in t)Object.hasOwnProperty.call(t,a)&&s.addColorStop(parseFloat(a),t[a]);r.fillStyle=s,r.fillRect(0,0,i,n),e.needsUpdate=!0}function createBandTexture(e=DEFAULT_BAND,t=64,i=2){const n=document.createElement("canvas");n.width=t,n.height=i;const r=n.getContext("2d");r.imageSmoothingEnabled=!1;const s=e.length,a=Math.floor(t/s);for(let o=0;o<s;o++){r.fillStyle=e[o];const n=o*a,l=o===s-1?t-n:a;r.fillRect(n,0,l,i)}return new three.CanvasTexture(n)}function updateBandTexture(e,t=[],i=64,n=2){if(!e||!Array.isArray(t)||0===t.length)return void console.warn("Invalid input for updateBandTexture.");const r=e.image.getContext("2d");r.imageSmoothingEnabled=!1,r.clearRect(0,0,i,n);const s=t.length,a=Math.floor(i/s);for(let o=0;o<s;o++){r.fillStyle=t[o];const e=o*a,l=o===s-1?i-e:a;r.fillRect(e,0,l,n)}e.needsUpdate=!0}const uniforms$7=three.UniformsUtils.merge([{gradientMap:{value:null},maxHeight:{value:1},vertexHeights:{value:!1},isEmissive:{value:!1},heatmap:{value:!0}}]);class PillarMaterial extends InstancedEffectPointMaterial{constructor(e){super(),__publicField(this,"name","PillarMaterial"),__publicField(this,"isPillarMaterial",!0),this.vertexShader=vertexShader$7;const{shape:t}=e;this.fragmentShader="cone"===t?fragmentShaderCone:fragmentShaderPillar,this.transparent=!0,defineMaterialNormalProperties(this,["maxHeight","sphereIndex","isEmissive","heatmap"]),defineMaterialBoolDefineProperties(this,[["vertexHeights","MVT_USE_VERTEX_HEIGHT"],["isGlobe","IS_GLOBE"]]),Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$7)),this._cachedGradient=null,this._cachedBandColors=null,this._colorMode=defaultValue$1(e.colorMode,"gradient"),Object.defineProperties(this,{gradient:{get:function(){return this._cachedGradient},set:function(e){this._cachedGradient=e,this.updateGradientMap()}},bandColors:{get:()=>this._cachedBandColors,set:e=>{this._cachedBandColors=e,"band"===this._colorMode&&this.updateBandMap()}}}),"band"===this._colorMode?(this._cachedBandMap||this.createBandMap(),this.uniforms.gradientMap.value=this._cachedBandMap):(this._cachedGradientMap||this.createGradientMap(),this.uniforms.gradientMap.value=this._cachedGradientMap),this.setValues(e)}createGradientMap(){this._cachedGradientMap=createDefaultGradientTexture()}createBandMap(){this._cachedBandMap=createBandTexture()}updateGradientMap(){const e=this._cachedGradientMap;if(!e)return;updateGradientTexture(e,this._cachedGradient),e.needsUpdate=!0}updateBandMap(){const e=this._cachedBandMap;if(!e)return;updateBandTexture(e,this._cachedBandColors),e.needsUpdate=!0}dispose(){this._cachedGradientMap&&this._cachedGradientMap.dispose(),this._cachedBandMap&&this._cachedBandMap.dispose(),super.dispose()}}class Pillar extends GeoInstancedPointMesh{constructor(e){super(e),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"opacity"),__publicField(this,"height"),__publicField(this,"radiusSegments"),__publicField(this,"radius"),__publicField(this,"gradient"),__publicField(this,"vertexHeights"),__publicField(this,"openEnded"),__publicField(this,"colorMode"),__publicField(this,"heatmap"),__publicField(this,"getInstanceLocalMatrix",((e,t,i)=>{const{vertexHeights:n,vertexSizes:r}=this.parameters,{height:s,size:a}=this.dataSource.data;let o=new three.Matrix4;if(n&&s){const e=new three.Matrix4;e.makeScale(1,1,s[i]),o.multiply(e)}if(r&&a){const e=new three.Matrix4;e.makeScale(a[i],a[i],1),o.multiply(e)}return o})),__publicField(this,"addCustomAttributes",(()=>{const{vertexHeights:e}=this.parameters,{height:t}=this.dataSource.data;let i=-1;if(!e||!t)return i;for(let n=0;n<t.length;n++)i<t[n]&&(i=t[n]);this.material.uniforms.maxHeight.value=i})),this.parameters=e}initObject(){const{radius:e,height:t,radialSegments:i,heightSegments:n,openEnded:r,...s}=this.parameters;this.geometry=new PillarGeometry(this.parameters),this.material=new PillarMaterial(s),this.material.setCommonUniforms(this.engine.rendering.uniforms)}computeInstanceMorphMatrix(e){return defaultValue$1.EMPTY_MAT4}getSphereIndex(){const{sphereIndex:e}=this.geometry.parameters;this.material.uniforms.sphereIndex.value=e}}const vertexShader$6="#define GLSLIFY 1\n#include <common>\nuniform sampler2D gradientMap;\n\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() { \n    \n    gl_Position = vec4(position, 1.0);\n    // vUv = position.xy;\n    vUv = vec2((position.x + 1.0) * 0.5, (position.y + 1.0) * 0.5);\n    // vec4 gray = texture2D(gradientMap, vUv);\n\n    // vec4 m0 = matrixWorldInverse * vec4(gl_Position.xy, 0.0, 1.0);\n    // vec4 m1 = matrixWorldInverse * vec4(gl_Position.xy, 1.0, 1.0);\n    // m0 /= m0.w;\n    // m1 /= m1.w;\n    // vec4 pixel = m0 + (-m0.z / (m1.z - m0.z)) * (m1 - m0);\n    // pixel.z = 100. * gray.a;\n\n    // gl_Position = projectionMatrix * pixelToViewMatrix * vec4(pixel.xyz, 1.0);\n    #include <logdepthbuf_vertex>\n}",fragmentShader$6="#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D heatmap;\nuniform sampler2D gradientMap;\nuniform sampler2D heatmapDepth;\nuniform float opacity;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\n#include <packing>\n\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n    vec4 color = texture2D(heatmap, vUv);\n    \n    if (color.a <= 0.) {\n        discard;\n    }\n    gl_FragColor = texture2D(gradientMap, vec2(color.a, 0.5));\n    float addAlpha = 1.0;\n    if (color.a < 0.3) {\n        addAlpha = color.a * 3.3;\n    }\n    // if (color.a < 0.3) {\n    //     gl_FragColor.a = color.a * 3.3;\n    // } else {\n    //     gl_FragColor.a = 1.0;\n    // }\n    gl_FragColor.a *= color.a;\n    gl_FragColor.a *= opacity;\n\n    #if defined( USE_LOGDEPTHBUF ) \n        gl_FragDepthEXT = texture2D(heatmapDepth, vUv).r;\n    #endif\n    #include <colorspace_fragment>\n}",uniforms$6=three.UniformsUtils.merge([three.UniformsLib.fog,{heatmap:{value:null},heatmapDepth:{value:null},gradientMap:{value:null},opacity:{value:1},isEmissive:{value:!1}}]);class HeatmapMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="HeatmapMaterial",this.isHeatmapMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.fragmentShader=fragmentShader$6,this.vertexShader=vertexShader$6,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$6)),defineMaterialNormalProperties(this,["opacity","resolution","isEmissive"]),defineMaterialAliasProperties(this,[]),defineMaterialBoolDefineProperties(this,[]),this._cachedGradient=null,Object.defineProperties(this,{gradient:{get:function(){return this._cachedGradient},set:function(e){this._cachedGradient=e,this.updateGradientMap()}}}),this.createGradientMap(),this.uniforms.gradientMap.value=this._cachedGradientMap,this.setValues(e)}createGradientMap(){this._cachedGradientMap=createDefaultGradientTexture()}updateGradientMap(){const e=this._cachedGradientMap;updateGradientTexture(e,this._cachedGradient),e.needsUpdate=!0}dispose(){this._cachedGradientMap&&this._cachedGradientMap.dispose(),super.dispose()}}const vertexShader$5="#define GLSLIFY 1\n#include <common>\n\nattribute float instancedWeight;\n\nuniform float radius;\nuniform float maxValue;\nuniform float minValue;\nuniform bool keepSize;\nuniform float attenuateMValueFactor;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\nvarying float vWeight;\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n\n    float range = (maxValue - minValue) * attenuateMValueFactor;\n\n    vec4 worldPosition = (modelMatrix * instanceMatrix * vec4(position, 1.0));\n    float pixelSize = getPixelSize(worldPosition.xyz);\n\n    if (keepSize) {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize, 1.0);\n        range *= pixelSize;\n    } else {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius, 1.0);\n    }\n    \n    // gl_Position = vec4(position, 1.0);\n    // vZDepth = (gl_Position.z / gl_Position.w + 1.0) * 0.5;\n   \n    vUv = vec2(position.x + 0.5, position.y + 0.5);\n    \n    vWeight = (instancedWeight - minValue) / (maxValue + range - minValue);\n\n    #include <logdepthbuf_vertex>\n}",fragmentShader$5="#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D circleMap;\n\nvarying vec2 vUv;\nvarying float vWeight;\nvarying float vZDepth;\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n    gl_FragColor.a = texture2D(circleMap, vUv).a * vWeight;\n    // gl_FragColor.a = 1.;\n    //#if defined( USE_LOGDEPTHBUF )\n        // gl_FragColor = vec4(vec3(gl_FragDepthEXT), 1.0);\n        // int d = int(gl_FragDepthEXT * 16581375.0);\n        // gl_FragColor.r = float((d & 0xff0000) >> 16) / 255.0;\n        // gl_FragColor.g = float((d & 0x00ff00) >> 8) / 255.0;\n        // gl_FragColor.b = float(d & 0x0000ff) / 255.0;\n        // gl_FragColor.r = gl_FragDepthEXT; // a\n        // gl_FragColor.g = mod(gl_FragDepthEXT * 10.0, 1.0);\n        // gl_FragColor.b = mod(gl_FragDepthEXT * 1000.0, 1.0);\n        // int d = int(gl_FragDepthEXT * 10000000.0);\n        // gl_FragColor.r = (d & 0xff000 >> 16) / 255.0; \n        // gl_FragColor.g = (d & 0x00ff00 >> 8) / 255.0; \n        // gl_FragColor.b = (d & 0x0000ff ) / 255.0; \n        // gl_FragColor.r = gl_FragDepthEXT;\n        // gl_FragColor.r = gl_FragCoord.z;\n\n        // float depthVal = gl_FragCoord.z * (256.0*256.0 - 1.0) / (256.0*256.0);\n        // vec3 encode = fract( depthVal * vec3(1.0, 256.0, 256.0*256.0) );\n        // encode.xy = encode.xy - encode.yz / 256.0 + 1.0/512.0;\n        // gl_FragColor.rgb = encode;\n\n    // #else \n    //     gl_FragColor.r = gl_FragCoord.z;\n    // #endif\n    // gl_FragColor.r = 1.0;\n    // gl_FragColor.a = gl_FragCoord.z;\n}",uniforms$5=three.UniformsUtils.merge([three.UniformsLib.fog,{radius:{value:30},circleMap:{value:null},minValue:{value:0},maxValue:{value:100},keepSize:{value:!1},attenuateMValueFactor:{value:0}}]);class HeatmapTextureMaterial extends CommonShaderMaterial{constructor(e){super(e),this.type="HeatmapTextureMaterial",this.isHeatmapTextureMaterial=!0,this.fog=!0,this.lights=!1,this.transparent=!0,this.depthTest=!1,this.fragmentShader=fragmentShader$5,this.vertexShader=vertexShader$5,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$5)),defineMaterialNormalProperties(this,["radius","minValue","maxValue","keepSize","attenuateMValueFactor"]),defineMaterialAliasProperties(this,[]),defineMaterialBoolDefineProperties(this,[]);const t=this.createCircleMap();this.uniforms.circleMap.value=t,this.setValues(e),this.blending=three.CustomBlending,this.blendSrc=three.OneFactor,this.blendDst=three.ZeroFactor,this.blendSrcAlpha=three.OneFactor,this.blendDstAlpha=three.OneFactor}createCircleMap(){let e=document.createElement("canvas");e.width=64,e.height=64;let t=e.getContext("2d"),i=t.createRadialGradient(32,32,0,32,32,32);return i.addColorStop(0,"rgba(0,0,0,1)"),i.addColorStop(1,"rgba(0,0,0,0)"),t.fillStyle=i,t.arc(32,32,32,0,2*Math.PI,!1),t.fill(),new three.CanvasTexture(e)}dispose(){this.uniforms.circleMap.value&&this.uniforms.circleMap.value.dispose(),super.dispose()}}class InstancedPointGeometry extends three.InstancedBufferGeometry{constructor(){super();const e=this.geometry=new three.PlaneGeometry;this.setAttribute("position",e.attributes.position),this.setAttribute("uv",e.attributes.uv),this.setIndex(e.index)}dispose(){this.geometry.dispose()}}class Heatmap extends GeoMesh{constructor(e){super(e),__publicField(this,"isHeatmap",!0),__publicField(this,"frustumCulled",!1),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"scene"),__publicField(this,"pointMesh"),__publicField(this,"pointMaterial"),__publicField(this,"pointGeometry"),__publicField(this,"renderTarget"),__publicField(this,"depthMaterial"),__publicField(this,"depthRenderTarget"),this.parameters=e,this.defineMaterialProxyProperties(["resolution"])}getDefaultParams(){return{radius:100,maxValue:1,gradient:{0:"rgba(0,0,255,1)",.3:"rgba(0,255,0,1)",.6:"rgba(255,255,0,1)",1:"rgba(255,0,0,1)"}}}initObject(){let e=this.parameters;const t=this.geometry=new three.BufferGeometry;t.setAttribute("position",new three.BufferAttribute(new Float32Array([-1,1,0,1,1,0,-1,-1,0,1,-1,0]),3)),t.setAttribute("uv",new three.BufferAttribute(new Float32Array([0,1,1,1,0,0,1,0]),2)),t.setIndex([0,2,1,2,3,1]);(this.material=new HeatmapMaterial({})).setCommonUniforms(this.engine.rendering.uniforms);const[i,n]=this.resolution||[],r=this.scene=new three.Scene;this.renderTarget=new three.WebGLRenderTarget(i,n),this.depthRenderTarget=new three.WebGLRenderTarget(i,n,{});const s=new three.DepthTexture(i,n);s.format=three.DepthFormat,s.type=three.UnsignedInt248Type,this.depthRenderTarget.depthTexture=s,this.depthMaterial=new HeatmapTextureMaterial({depthTest:!0,depthWrite:!0,colorWrite:!1});const a=this.pointGeometry=new InstancedPointGeometry,o=this.pointMaterial=new HeatmapTextureMaterial({depthTest:!1,depthWrite:!1});o.setCommonUniforms(this.engine.rendering.uniforms),this.depthMaterial.setCommonUniforms(this.engine.rendering.uniforms);const l=this.pointMesh=new GeoInstancedMesh(a,o);l.engine=this.engine,this.pointMesh.matrixAutoUpdate=!0,l.frustumCulled=!1,r.add(l),this.material.uniforms.heatmap.value=this.renderTarget.texture,this.material.uniforms.heatmapDepth.value=this.depthRenderTarget.depthTexture,void 0!==e.gradient&&(this.gradient=e.gradient),void 0!==e.radius&&(this.radius=e.radius),void 0!==e.minValue&&(this.minValue=e.minValue),void 0!==e.maxValue&&(this.maxValue=e.maxValue),void 0!==e.opacity&&(this.opacity=e.opacity),void 0!==e.keepSize&&(this.keepSize=e.keepSize),void 0!==e.attenuateMValueFactor&&(this.attenuateMValueFactor=e.attenuateMValueFactor)}onBeforeSceneRenderHook(e,t,i,n){let r=e.renderer;const s=n.cameraOffset;this.scene.position.set(-s.x,-s.y,-s.z),r.setRenderTarget(this.renderTarget),!1===r.autoClear&&r.clear(),r.render(this.scene,i),r.setRenderTarget(this.depthRenderTarget),!1===r.autoClear&&r.clear(),this.scene.overrideMaterial=this.depthMaterial,r.render(this.scene,i),this.scene.overrideMaterial=null,r.setRenderTarget(null)}set dataSource(e){this.pointMesh.dataSource=e,this.needsUpdate=!0}get dataSource(){return this.pointMesh.dataSource}_updateData(){this.pointMesh.dataSource&&(this.pointMesh.addCustomAttributes=(e,t)=>{let i=t.data,n=[];for(let r=0;r<i.position.length;r++){const e=i.count[r]?i.count[r]:1;n.push(e)}e.setAttribute("instancedWeight",new three.InstancedBufferAttribute(new Float32Array(n),1))},this.pointMesh._updateData())}dispose(){this.material.dispose(),this.geometry.dispose(),this.pointGeometry.dispose(),this.pointMaterial.dispose(),this.renderTarget.dispose(),this.depthMaterial.dispose(),this.depthRenderTarget.dispose()}set gradient(e){"[object Object]"===Object.prototype.toString.call(e)&&(this.material.gradient=e)}set radius(e){!isNaN(e)&&e>0&&(this.pointMaterial.radius=e,this.depthMaterial.radius=e)}get radius(){return this.pointMaterial.radius}set minValue(e){isNaN(e)||(this.pointMaterial.minValue=e)}get minValue(){return this.pointMaterial.minValue}set maxValue(e){isNaN(e)||(this.pointMaterial.maxValue=e)}get maxValue(){return this.pointMaterial.maxValue}set opacity(e){isNaN(e)||(this.material.opacity=e)}get opacity(){return this.material.opacity}set keepSize(e){this.pointMaterial.keepSize=e,this.depthMaterial.keepSize=e}get keepSize(){return this.pointMaterial.keepSize}set attenuateMValueFactor(e){this.pointMaterial.attenuateMValueFactor=e}}const vertexShader$4="#define GLSLIFY 1\n#include <common>\n\nuniform float heightRatio;\nuniform sampler2D map;\n\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() { \n\n    vUv = vec2(uv.x, 1. - uv.y);\n    #include <begin_vertex>\n\n    transformed.z = texture2D(map, vUv).a * heightRatio;\n\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n}",fragmentShader$4="#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D map;\nuniform float opacity;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n\n    gl_FragColor = texture2D(map, vUv);\n    gl_FragColor.a *= opacity;\n\n    #include <logdepthbuf_fragment> \n    #include <colorspace_fragment>\n\n}",uniforms$4=three.UniformsUtils.merge([three.UniformsLib.fog,{heightRatio:{value:100},opacity:{value:1},map:{value:null},isEmissive:{value:!1}}]);class Heatmap3DMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="Heatmap3DMaterial",this.isHeatmapMaterial=!0,this.fog=!0,this.lights=!1,this.side=three.DoubleSide,this.forceSinglePass=!1,this.transparent=!0,this.depthWrite=!0,this.depthTest=!0,this.fragmentShader=fragmentShader$4,this.vertexShader=vertexShader$4,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$4)),defineMaterialNormalProperties(this,["heightRatio","resolution","opacity","map","isEmissive"]),this.setValues(e)}}var simpleheat$1={exports:{}};!function(e){function t(e){if(!(this instanceof t))return new t(e);this._canvas=e="string"==typeof e?document.getElementById(e):e,this._ctx=e.getContext("2d"),this._width=e.width,this._height=e.height,this._max=1,this._data=[]}e.exports=t,t.prototype={defaultRadius:25,defaultGradient:{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},data:function(e){return this._data=e,this},max:function(e){return this._max=e,this},add:function(e){return this._data.push(e),this},clear:function(){return this._data=[],this},radius:function(e,t){t=void 0===t?15:t;var i=this._circle=this._createCanvas(),n=i.getContext("2d"),r=this._r=e+t;return i.width=i.height=2*r,n.shadowOffsetX=n.shadowOffsetY=2*r,n.shadowBlur=t,n.shadowColor="black",n.beginPath(),n.arc(-r,-r,e,0,2*Math.PI,!0),n.closePath(),n.fill(),this},resize:function(){this._width=this._canvas.width,this._height=this._canvas.height},gradient:function(e){var t=this._createCanvas(),i=t.getContext("2d"),n=i.createLinearGradient(0,0,0,256);for(var r in t.width=1,t.height=256,e)n.addColorStop(+r,e[r]);return i.fillStyle=n,i.fillRect(0,0,1,256),this._grad=i.getImageData(0,0,1,256).data,this},draw:function(e){this._circle||this.radius(this.defaultRadius),this._grad||this.gradient(this.defaultGradient);var t=this._ctx;t.clearRect(0,0,this._width,this._height);for(var i,n=0,r=this._data.length;n<r;n++)i=this._data[n],t.globalAlpha=Math.max(i[2]/this._max,void 0===e?.05:e),t.drawImage(this._circle,i[0]-this._r,i[1]-this._r);var s=t.getImageData(0,0,this._width,this._height);return this._colorize(s.data,this._grad),t.putImageData(s,0,0),this},_colorize:function(e,t){for(var i,n=0,r=e.length;n<r;n+=4)(i=4*e[n+3])&&(e[n]=t[i],e[n+1]=t[i+1],e[n+2]=t[i+2])},_createCanvas:function(){return"undefined"!=typeof document?document.createElement("canvas"):new this._canvas.constructor}}}(simpleheat$1);const simpleheat=simpleheat$1.exports;new three.Vector3;const rotationMatrixScratch=new three.Matrix4;function Canvas(e,t){let i=document.createElement("canvas");return e&&(i.width=e),t&&(i.height=t),i}let positionVec3=new three.Vector3,positionTemp=new three.Vector3;class Heatmap3D extends GeoMesh{constructor(e){super(e),__publicField(this,"_gradient"),__publicField(this,"_radius"),__publicField(this,"_maxValue"),__publicField(this,"isHeatmap3D",!0),__publicField(this,"frustumCulled",!1),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"opacity"),__publicField(this,"heightRatio"),this.parameters=e,this._gradient=void 0!==this.parameters.gradient?this.parameters.gradient:{.4:"rgba(0,0,255,1)",.6:"rgba(0,255,0,1)",.8:"rgba(255,255,0,1)",1:"rgba(255,0,0,1)"},this._radius=void 0!==this.parameters.radius?this.parameters.radius:100,this._maxValue=void 0!==this.parameters.maxValue?this.parameters.maxValue:1,this.defineMaterialProxyProperties(["resolution","opacity","heightRatio"])}initObject(){const{radius:e,maxValue:t,...i}=this.parameters;this.geometry=new three.PlaneGeometry;(this.material=new Heatmap3DMaterial(i)).setCommonUniforms(this.engine.rendering.uniforms)}_updateData(){let e=this.dataSource.data;const t=this.engine.map.isGlobe,i=this.engine.map.map.ellipsoid||Ellipsoid.WGS84;let n=1/0,r=1/0,s=-1/0,a=-1/0,o=[];if(t){const t=[];for(let n=0;n<e.position.length;n++){const r=e.position[n];i.scaleToGeodeticSurface(positionVec3.fromArray(r),positionTemp),t[n]=positionTemp.toArray()}const l=t.map((e=>new three.Vector3(...e))),c=createTangentPlane(t,i),h=c.projectPointsOntoPlane(l);for(let e=0;e<h.length;e++){const t=h[e];n=Math.min(n,t.x),s=Math.max(s,t.x),r=Math.min(r,t.y),a=Math.max(a,t.y)}const u=c._origin,d=u.clone().add(c._xAxis.multiplyScalar((s+n)/2)).add(c._yAxis.multiplyScalar((a+r)/2));for(let i=0;i<h.length;i++){const t=h[i],s=e.count?e.count[i]:1;o.push([t.x-n+this._radius,t.y-r+this._radius,s])}this.position.copy(d);const p=Transforms.eastNorthUpToFixedFrame(u),m=rotationMatrixScratch.extractRotation(p);this.rotation.setFromRotationMatrix(m)}else{let t=1/0,i=-1/0;for(let c=0;c<e.position.length;c++){const l=e.position[c],h=e.count?e.count[c]:1;n=Math.min(l[0],n),r=Math.min(l[1],r),t=Math.min(l[2],t),s=Math.max(l[0],s),a=Math.max(l[1],a),i=Math.max(l[2],i),o.push([l[0],l[1],h])}let l=[(n+s)/2,(r+a)/2,(t+i)/2];this.position.set(...l),o.forEach((e=>{e[0]=e[0]-n+this._radius,e[1]=e[1]-r+this._radius}))}let l=Math.ceil(s-n)+2*this._radius,c=Math.ceil(a-r)+2*this._radius;let h=Math.min(l*c/4e4,2048),u=h/2,d=new Canvas(h,h),p=simpleheat(d),m=p._ctx;m.save(),m.scale(h/l,h/c),p.data(o).radius(this._radius).max(this._maxValue).gradient(this._gradient).draw(),m.restore(),this.geometry&&this.geometry.dispose();const f=this.geometry=new three.PlaneGeometry(l,c,u,u);f.computeBoundingSphere(),f.computeBoundingBox(),this.texture&&this.texture.dispose();let g=this.texture=new three.CanvasTexture(d);this.material.uniforms.map.value=g,this.needsUpdate=!1}onDispose(){this.texture&&this.texture.dispose()}get gradient(){return this._gradient}set gradient(e){this._gradient=e}get radius(){return this._radius}set radius(e){this._radius=e}get maxValue(){return this._maxValue}set maxValue(e){this._maxValue=e}}const vertexShader$3="#define GLSLIFY 1\n#include <common>\n\nuniform float positionOffsetX;\nuniform float positionOffsetY;\nuniform float pixelOffsetX;\nuniform float pixelOffsetY;\nuniform float positionOffsetZ;\nuniform bool uFlat;\n#ifdef RENDER_IN_POSTPROCESS\n    uniform float cameraFar;\n#endif\n\nattribute float pIndex;\nattribute vec2 wh;\n\n#ifdef IS_GLOBE\n    attribute mat4 instanceMatrix;\n#endif\n\n#ifdef MVT_USE_VERTEX_ROTATEZ\n    attribute float aRotateZ;\n# else\n    uniform float uRotateZ;\n#endif\n\nvarying vec2 vUv;\n\n#ifdef RENDER_IN_POSTPROCESS\n    varying vec2 vClipSpacePosition;\n    varying float vLogDepth;\n#endif\n#include <logdepthbuf_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {\n    float x = coord.x;\n    float y = coord.y;\n    if (corner == 1.0) {\n        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    } else if (corner == 2.0) {\n        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else if (corner == 3.0) {\n        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else {\n        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    }\n    return vec3(x, y, coord.z);\n}\n\nvoid main() {\n    #include <mvt_selective_vertex>\n    // float x = position.x;\n    // float y = position.y;\n    vUv = uv;\n\n    float rotateZ;\n    #ifdef MVT_USE_VERTEX_ROTATEZ\n        rotateZ = aRotateZ;\n    # else\n        rotateZ = uRotateZ;\n    #endif\n\n    mat4 currentInstanceMatrix = mat4(1.0);\n    vec3 currentPosition = position;\n    #ifdef IS_GLOBE\n        currentInstanceMatrix = instanceMatrix;\n\n        currentInstanceMatrix[3][0] = position.x;\n        currentInstanceMatrix[3][1] = position.y;\n        currentInstanceMatrix[3][2] = position.z;\n\n        currentPosition = vec3(0.0, 0.0, 0.0);\n    #endif\n\n    vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));\n\n    #ifdef RENDER_IN_POSTPROCESS\n    vec4 clipSpacePosition = projectionMatrix * viewMatrix * worldPosition;\n    vClipSpacePosition.xy = ((clipSpacePosition.xy / clipSpacePosition.w) + 1.0) / 2.0;\n\n    float fcoef = 1.0 / log2(cameraFar + 1.0);\n    float logDepth = log2(max(1e-6, 1.0 + clipSpacePosition.w)) * fcoef;\n    vLogDepth = logDepth;\n    #endif\n\n    if (uFlat) {\n        // viewMatrix[0]表示相机的右方向，不管相机如何倾斜tilt，法向量都指向正北方向，正好可以用来计算和文字的夹角\n        mat4 localViewMatrix = viewMatrix * currentInstanceMatrix;\n        vec4 right = localViewMatrix[0];\n        float theta = dot(vec2(sin(rotateZ), cos(rotateZ)), vec2(-right.y, right.x));\n        if (theta < 0.0) {\n            rotateZ += PI;\n        }\n        // TODO 支持offset\n        float hw = wh.x * 0.5;\n        float hh = wh.y * 0.5;\n        if (keepSize) {\n            float pixelSize = getPixelSize(worldPosition.xyz);\n            hw = hw * pixelSize;\n            hh = hh * pixelSize;\n        }\n\n        vec3 current = transformCoord(currentPosition, vec2(hw, hh), pIndex, -rotateZ);\n        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);\n\n        // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    }\n    else {\n        // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);\n        worldPosition.x += positionOffsetX;\n        worldPosition.y += positionOffsetY;\n        worldPosition.z += positionOffsetZ;\n        vec4 pos = projectionMatrix * viewMatrix * worldPosition;\n        float w = pos.w;\n        vec3 screen = pos.xyz / w;\n        \n        float hw = wh.x / resolution.x;\n        float hh = wh.y / resolution.y;\n        if (!keepSize) {\n            float pixelSize = getPixelSize(worldPosition.xyz);\n            hw = hw / pixelSize;\n            hh = hh / pixelSize;\n        }\n\n        vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -rotateZ);\n        gl_Position = vec4(current, 1.0);\n\n        gl_Position.x += pixelOffsetX * 2. / resolution.x;\n        gl_Position.y += pixelOffsetY * 2. / resolution.y;\n\n        gl_Position *= w;\n    }\n    #include <logdepthbuf_vertex>\n    // gl_PointSize = size * pixelRatio;\n    // vSize = size;\n    // vOffset = offset;\n}",fragmentShader$3="#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D map;\nuniform sampler2D depthTexture;\nuniform vec4 backgroundColor;\nuniform float opacity;\nuniform float lineHeight;\n\n#ifdef RENDER_IN_POSTPROCESS\n    uniform float cameraFar;\n#endif\n\nvarying vec2 vUv;\n\n#ifdef RENDER_IN_POSTPROCESS\n    varying vec2 vClipSpacePosition;\n    varying float vLogDepth;\n#endif\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <tonemapping_pars_fragment>\n#include <output_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n    // gl_FragColor = vec4(1., 0, 0, 1.);\n    gl_FragColor = texture2D(map, vec2(vUv.x, 1.0 - vUv.y));\n\n    #ifdef RENDER_IN_POSTPROCESS\n    float depthValue = texture2D(depthTexture, vClipSpacePosition).r;\n    float bias = 0.001; // 避免设置一个阈值，精度误差造成文字绘制不稳定\n    if (vLogDepth > depthValue + bias) {\n        discard;\n    }\n    #endif\n\n    if (backgroundColor.a > 0.0) {\n        gl_FragColor = mix(backgroundColor, gl_FragColor, gl_FragColor.a);\n    }\n\n    if (gl_FragColor.a <= 0.0) {\n        discard;\n    }\n    gl_FragColor.a *= opacity;\n\n    #include <mvt_selective_fragment> \n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n    #include <output_fragment>\n}",uniforms$3=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,emissiveUniforms,{map:{value:null},pixelRatio:{value:1},lineHeight:{value:14},pixelOffsetX:{value:0},pixelOffsetY:{value:0},positionOffsetX:{value:0},positionOffsetZ:{value:0},positionOffsetY:{value:0},backgroundColor:{value:[1,1,0,0]},uFlat:{value:!1},opacity:{value:1},isEmissive:{value:!1},uRotateZ:{value:0},keepSize:{value:!0},depthTexture:{value:null},cameraFar:{value:0}}]);class DefaultTextMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="DefaultTextMaterial",this.vertexShader=vertexShader$3,this.fragmentShader=fragmentShader$3,this.isDefaultTextMaterial=!0,this.transparent=!0,this.depthTest=!1,this.depthWrite=!1,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$3)),defineMaterialSelectiveProperties(this),defineMaterialKeepSizeProperties(this),defineMaterialNormalProperties(this,["lineHeight","pixelRatio","map","depthTexture","cameraFar","pixelOffsetX","pixelOffsetY","positionOffsetX","positionOffsetY","positionOffsetZ","backgroundColor","resolution","opacity","isEmissive"]),defineMaterialAliasProperties(this,[["flat","uFlat"],["rotateZ","uRotateZ"]]),defineMaterialBoolDefineProperties(this,[["vertexRotateZs","MVT_USE_VERTEX_ROTATEZ"],["isGlobe","IS_GLOBE"],["isRenderInPostprocess","RENDER_IN_POSTPROCESS"]]),defineMaterialEmissiveProperties(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}}let curStyleId$1;const _tempVector3=new three.Vector3,_tempVector4=new three.Vector4,_tempMatrix4=new three.Matrix4;class Text extends GeoMesh{constructor(e){super(e),__publicField(this,"isEventEntitySupported",!0),__publicField(this,"_fontSize"),__publicField(this,"_fontFamily"),__publicField(this,"_fillStyle"),__publicField(this,"_padding"),__publicField(this,"_strokeStyle"),__publicField(this,"_shouldStroke"),__publicField(this,"_collisionBoxCache",{}),__publicField(this,"isRenderInPostprocess",!1),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"cachedData",[]),__publicField(this,"drawingData"),__publicField(this,"canvas"),__publicField(this,"ctx"),__publicField(this,"texture"),__publicField(this,"matrixAutoUpdate",!0),__publicField(this,"sortByStyle",(e=>this.parameters.vertexStyles?e.sort(((e,t)=>t.styleId-e.styleId)):e)),__publicField(this,"getStrictStyleId",(e=>{if(this.parameters.vertexStyles){let{fontSize:t,fontWeight:i,lineWidth:n,fillStyle:r=[],strokeStyle:s=[]}=e;return`${t}_${i}_${n}_${r[0]}_${r[1]}_${r[2]}_${r[3]}_${s[0]}_${s[1]}_${s[2]}_${s[3]}`}return 0})),__publicField(this,"updateRenderingData",(()=>{const e=this.engine.rendering.pixelRatio,t=this.engine.map.isGlobe,i=this.canvas,n=this.ctx,r=this._fontSize,s=this._fontFamily,a=this._fillStyle,o=this._padding,l=this.cachedData||[],c=potpack(l);0===l.length&&(c.w=1,c.h=1);let h=c.w,u=c.h;i.width=h*e,i.height=u*e,n.save(),n.scale(e,e),n.textBaseline="top",n.fillStyle=a,this._shouldStroke&&(n.strokeStyle=this._strokeStyle,this._lineWidth>0&&(n.lineWidth=this._lineWidth)),n.font=r+"px "+s,this.shadowColor&&(n.shadowColor=this.shadowColor,n.shadowOffsetX=this.shadowOffsetX||0,n.shadowOffsetY=this.shadowOffsetY||0,n.shadowBlur=this.shadowBlur||0);const d=[],p=[],m=[],f=[],g=[],_=[],A=[],v=[];let y=r,x=1/0,b=1/0,S=1/0,C=-1/0,T=-1/0,E=-1/0;for(let D=0;D<l.length;D++){const e=l[D].position,[t,i,n=0]=e;t<x&&(x=t),t>C&&(C=t),i<b&&(b=i),i>T&&(T=i),n<S&&(S=n),n>E&&(E=n)}let M=(x+C)/2,w=(b+T)/2,I=(S+E)/2;M=Number.isNaN(M)?0:M,w=Number.isNaN(w)?0:w,I=Number.isNaN(I)?0:I;let P=[M,w,I],R=new three.Matrix4;for(let D=0,F=l.length;D<F;++D){const e=l[D],i=this.getStrictStyleId(e);if(this.parameters.vertexStyles&&curStyleId$1!==i){curStyleId$1=i;let{fontWeight:t,fontSize:r,fillStyle:a,strokeStyle:o,lineWidth:l}=e;n.font=t>=10&&t%10==0?10*t+" "+r+"px "+s:r+"px "+s,y=r,l>0&&(n.lineWidth=l,n.strokeStyle="rgba("+o.join(",")+")"),n.fillStyle="rgba("+a.join(",")+")"}let r=String(e.text).split("\\");for(let t=0;t<r.length;t++)(this._shouldStroke||this.parameters.vertexStyles)&&n.strokeText(r[t],e.x+o[0],e.y+o[1]+t*y),n.fillText(r[t],e.x+o[0],e.y+o[1]+t*y);let[a,c,x=0]=e.position;if(t){R=Transforms.eastNorthUpToFixedFrame(new three.Vector3(a,c,x),null,R),R.elements[12]=0,R.elements[13]=0,R.elements[14]=0;for(let e=0;e<4;e++)for(let t=0;t<16;t++)v.push(R.elements[t])}a-=P[0],c-=P[1],x-=P[2],d.push(a,c,x,a,c,x,a,c,x,a,c,x),m.push(0,1,2,3),g.push(e.w,e.h,e.w,e.h,e.w,e.h,e.w,e.h);const b=4*D;f.push(b,b+2,b+1,b,b+3,b+2);const S=e.x/h,C=(e.x+e.w)/h,T=(e.y+e.h)/u,E=e.y/u;p.push(S,T,S,E,C,E,C,T),_.push(e.index,e.index,e.index,e.index),this.parameters.vertexRotateZs&&A.push(e.rotateZ,e.rotateZ,e.rotateZ,e.rotateZ)}n.restore();const B=this.geometry;B.setAttribute("position",new three.Float32BufferAttribute(d,3)),B.setAttribute("pIndex",new three.Float32BufferAttribute(m,1)),B.setAttribute("wh",new three.Float32BufferAttribute(g,2)),B.setAttribute("uv",new three.Float32BufferAttribute(p,2)),t&&B.setAttribute("instanceMatrix",new three.Float32BufferAttribute(v,16)),this.parameters.vertexRotateZs&&B.setAttribute("aRotateZ",new three.Float32BufferAttribute(A,1)),B.setIndex(f),B.computeBoundingSphere(),this.makeMeshPositionOffset(P),d.length>0&&(this.texture&&this.texture.dispose(),this.texture=new three.CanvasTexture(this.canvas),this.texture.minFilter=three.LinearFilter,this.texture.magFilter=three.LinearFilter,this.texture.generateMipmaps=!1,this.material.uniforms.map.value=this.texture),this.needsUpdate=!1,curStyleId$1=null})),this.parameters=e,this._fontSize=void 0!==this.parameters.fontSize?this.parameters.fontSize:16,this._fontFamily=void 0!==this.parameters.fontFamily?this.parameters.fontFamily:"Microsoft Yahei",this._fillStyle=void 0!==this.parameters.fillStyle?this.parameters.fillStyle:"#ff0",this._padding=void 0!==this.parameters.padding?this.parameters.padding:[2,2],this.strokeStyle=this.parameters.strokeStyle,this._lineWidth=this.parameters.lineWidth,this.isRenderInPostprocess=this.parameters.isRenderInPostprocess||!1,this.cachedData=[],this.drawingData=[];const t=this.canvas=document.createElement("canvas");t.width=t.height=1;const i=this.ctx=t.getContext("2d");i.textAlign="start",i.textBaseline="top",this.defineMaterialProxyProperties(["lineHeight","map","pixelOffsetX","pixelOffsetY","positionOffsetX","positionOffsetY","positionOffsetZ","backgroundColor","resolution","opacity","flat","emissive","keepSize"])}initObject(){let{padding:e,fillStyle:t,strokeStyle:i,lineWidth:n,fontSize:r,fontFamily:s,vertexStyles:a,...o}=this.parameters;const l=this.engine.map.isGlobe;this.geometry=new three.BufferGeometry(this.parameters),this.material=new DefaultTextMaterial(o),this.material.isGlobe=l,this.material.setCommonUniforms(this.engine.rendering.uniforms),this.texture=new three.CanvasTexture(this.canvas),this.texture.minFilter=three.LinearFilter,this.texture.magFilter=three.LinearFilter,this.texture.generateMipmaps=!1,this.material.uniforms.map.value=this.texture}_updateData(){this._enableCollision&&this._collisionData?(this.cachedData=this.sortByStyle(this._collisionData),curStyleId$1=null):(this.cachedData=this.sortByStyle(this.dataSource.userData).map((e=>{let t=this.collisionTest(e);return{...e,w:t.width,h:t.height}})),curStyleId$1=null),this.update()}onBeforeScenePrepareRenderHook(e,t,i){const n=e.rendering.main.sceneRendering.depthTexture;this.material.uniforms.depthTexture.value=n,this.material.uniforms.cameraFar.value=e.rendering.camera.far}update(){this.updateRenderingData()}collisionTest(e){const t=this.ctx,i=this.engine.rendering.pixelRatio,n=this._fontSize,r=this._fontFamily,s=this._padding;t.save(),t.scale(i,i),t.textBaseline="top";let a="";if(this.parameters.vertexStyles){let{text:t,fontWeight:i,fontSize:n,lineWidth:r}=e;a+=`${t}_${n}_${i}_${r}`}else a+=`${e.text}_${n}`;if(this._collisionBoxCache[a])return this._collisionBoxCache[a];let o=n;const l=this.getStrictStyleId(e);if(this.parameters.vertexStyles&&l!==curStyleId$1){let{fontWeight:i,fontSize:n,lineWidth:s}=e;t.font=i>=10&&i%10==0?10*i+" "+n+"px "+r:n+"px "+r,o=n,s>0&&(t.lineWidth=s)}else t.font=n+"px "+r;let c=String(e.text).split("\\");const h=c.map((e=>t.measureText(e).width));let u=Math.max(...h),d=o*c.length;const p=u+2*s[0],m=d+2*s[1];return t.restore(),this._collisionBoxCache[a]={width:p,height:m},{width:p,height:m}}onDispose(){this.texture&&this.texture.dispose()}getEntityByIndex(e){const t=this.dataSource;this._enableCollision&&this._collisionData&&(e=this._collisionData[e].index);const i={index:e,value:t.getDataItem(e),itemIndex:t.getDataItemIndex(e),pairs:{}},n=t.data;for(const r of Object.keys(n))i.pairs[r]=n[r][e];return i}raycast(e,t){const i=this.flat;if(!this.visible)return;if(i)return;const n=this.geometry,r=n.getAttribute("position");if(!r||!r.array||0===!r.array.length)return;let s=e.camera;s||(s=this.engine.camera);const a=e.mouse;if(!a)return;const o=this.material.uniforms.resolution.value,l=a.x,c=a.y;let h=[];const u=n.getAttribute("wh");u&&(h=u.array);let d=0,p=0,m=0,f=0,g=0,_=0;_tempMatrix4.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),_tempMatrix4.multiplyMatrices(_tempMatrix4,this.matrixWorld);const A=r.array;let v=0,y=1;this.keepSize||(y=this.material.uniforms.zoomUnits.value);for(let x=0,b=A.length-11;x<b;x+=12)if(_tempVector4.set(A[x],A[x+1],A[x+2],1),_tempVector4.applyMatrix4(_tempMatrix4),_tempVector4.divideScalar(_tempVector4.w),v=x/12*8,g=h[v]/o.x,_=h[v+1]/o.y,d=_tempVector4.x-g/y,m=_tempVector4.x+g/y,p=_tempVector4.y-_/y,f=_tempVector4.y+_/y,d<=l&&m>=l&&p<=c&&f>=c){_tempVector3.set(A[x],A[x+1],A[x+2]),_tempVector3.applyMatrix4(this.matrixWorld);const e={instanceId:x/12,object:this,distance:_tempVector3.distanceTo(s.position)};t.push(e)}}set fontSize(e){this._fontSize!==e&&(this._fontSize=e,this._collisionBoxCache={},this.needsUpdate=!0,this.engine.requestRender())}get fontSize(){return this._fontSize}set fontFamily(e){this._fontFamily!==e&&(this._fontFamily=e,this._collisionBoxCache={},this.needsUpdate=!0,this.engine.requestRender())}get fontFamily(){return this._fontFamily}set fillStyle(e){this._fillStyle=e,this.needsUpdate=!0,this.engine.requestRender()}get fillStyle(){return this._fillStyle}set strokeStyle(e){this._shouldStroke=!!e,this._strokeStyle=e,this.needsUpdate=!0,this.engine&&this.engine.requestRender()}get strokeStyle(){return this._strokeStyle}set lineWidth(e){this._lineWidth=e,this.needsUpdate=!0,this.engine.requestRender()}get lineWidth(){return this._lineWidth}set padding(e){this._padding!==e&&(this._padding=e,this._collisionBoxCache={},this.needsUpdate=!0,this.engine.requestRender())}get padding(){return this._padding}}const vertexShader$2="#define GLSLIFY 1\n#include <common>\n\nuniform float positionOffsetX;\nuniform float positionOffsetY;\nuniform float pixelOffsetX;\nuniform float pixelOffsetY;\nuniform float positionOffsetZ;\nuniform bool uFlat;\n\nattribute float pIndex;\nattribute vec4 iconFrame;\nattribute vec2 wh;\nattribute vec4 strokeStyle;\nattribute vec3 fillStyle;\nattribute vec4 sizeAndOffset;\n\n#ifdef IS_ALIGN_ROTATE\nattribute float verticalOffsets;\n#endif\n\nvarying vec4 vStrokeStyle;\nvarying vec3 vFillStyle;\nvarying float vFontSize;\n\n#ifdef IS_GLOBE\n    attribute mat4 ecefMatrix;\n#endif\n\n#ifdef MVT_USE_VERTEX_ROTATEZ\n    attribute float aRotateZ;\n# else\n    uniform float uRotateZ;\n#endif\n\nuniform float elapsedTime;\n#ifdef MVT_ENABLE_FADE\n    attribute float fadeOpacity;\n    attribute float fadeSince;\n    uniform float fadeDuration;\n    varying float vFadeOpacity;\n#endif\n\nvarying vec2 vUv;\n#include <logdepthbuf_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {\n    float x = coord.x;\n    float y = coord.y;\n    if (corner == 1.0) {\n        // 左上\n        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    } else if (corner == 2.0) {\n        // 右上\n        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else if (corner == 3.0) {\n        // 右下\n        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else {\n        // 左下\n        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    }\n    return vec3(x, y, coord.z);\n}\n\nvoid main() {\n    #include <mvt_selective_vertex>\n    // float x = position.x;\n    // float y = position.y;\n    vUv = uv;\n\n    float rotateZ;\n    #ifdef MVT_USE_VERTEX_ROTATEZ\n        rotateZ = aRotateZ;\n    # else\n        rotateZ = uRotateZ;\n    #endif\n\n    mat4 currentInstanceMatrix = mat4(1.0);\n    vec3 currentPosition = position;\n    #ifdef IS_GLOBE\n        currentInstanceMatrix = ecefMatrix;\n\n        currentInstanceMatrix[3][0] = position.x;\n        currentInstanceMatrix[3][1] = position.y;\n        currentInstanceMatrix[3][2] = position.z;\n\n        currentPosition = vec3(0.0, 0.0, 0.0);\n    #endif\n\n    float width = iconFrame.z;\n    float height = iconFrame.w;\n    float scale = sizeAndOffset.x / height;\n\n    currentPosition.x += positionOffsetX;\n    currentPosition.y += positionOffsetY;\n    currentPosition.z += positionOffsetZ;\n   vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));\n    if (uFlat) {\n        // viewMatrix[0]表示相机的右方向，不管相机如何倾斜tilt，法向量都指向正北方向，正好可以用来计算和文字的夹角\n        mat4 localViewMatrix = viewMatrix * currentInstanceMatrix;\n        vec4 right = localViewMatrix[0];\n        float cosTheta = dot(vec2(sin(rotateZ), cos(rotateZ)), vec2(-right.y, right.x));\n\n        float rotateOffset = 0.0;\n        #ifdef IS_ALIGN_ROTATE\n        // 用于判断方向\n        float sinTheta = sin(rotateZ) * right.x - cos(rotateZ) * -right.y;\n\n        // [-π, π] + 0.25 PI\n        float theta = atan(sinTheta, cosTheta) + PI * 0.25;\n        if (theta < 0.0) {\n            theta += 2.0 * PI;\n        }\n\n        float deg = degrees(theta);\n\n        float isVertical = 0.0;\n        // 根据 theta 划分象限\n        if (deg >= 90.0 && deg < 180.0) {\n            rotateOffset = -PI * 0.5;\n            rotateZ += PI;\n            isVertical = 1.0;\n        } else if (deg >= 180.0 && deg < 270.0) {\n            rotateZ += PI;\n        } else if (deg >= 270.0){\n            rotateOffset = -PI * 0.5;\n            isVertical = 1.0;\n        }\n        #else\n        if (cosTheta < 0.0) {\n            rotateZ += PI;\n        }\n        #endif\n\n        // TODO 支持offset\n        float hw = width * 0.5 * scale;\n        float hh = height * 0.5 * scale;\n\n        float pixelSize = 1.0;\n        if (keepSize) {\n            pixelSize = getPixelSize(worldPosition.xyz);\n            // pixelSize = pixelSize * 2.0;\n            hw = hw * pixelSize;\n            hh = hh * pixelSize;\n\n        }\n\n        vec3 current = currentPosition;\n\n        #ifdef IS_ALIGN_ROTATE\n        float xOffset = isVertical == 1.0 ? ((verticalOffsets - sizeAndOffset.w) * pixelSize * scale) : sizeAndOffset.z * pixelSize * scale;\n        float yOffset = isVertical == 1.0 ? 0.0 : sizeAndOffset.w * pixelSize * scale;\n        #else\n        float xOffset = sizeAndOffset.z * pixelSize * scale;\n        float yOffset = sizeAndOffset.w * pixelSize * scale;\n        #endif\n\n        xOffset += pixelOffsetX * scale;\n        yOffset += pixelOffsetY * scale;\n\n        current = transformCoord(current, vec2(hw, hh), pIndex, -rotateZ + rotateOffset);\n        current = transformCoord(current, vec2(xOffset, yOffset), 2.0, -rotateZ);\n\n        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);\n\n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    }\n    else {\n        // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);\n        vec4 pos = projectionMatrix * viewMatrix * worldPosition;\n        float w = pos.w;\n       \n        vec3 screen = pos.xyz / w;\n\n        float hw = width / resolution.x * scale;\n        float hh = height / resolution.y * scale;\n\n        float pixelSize = 1.0;\n        if (!keepSize) {\n            pixelSize = getPixelSize(worldPosition.xyz);\n            pixelSize = pixelSize * 2.0;\n\n            hw /= pixelSize;\n            hh /= pixelSize;\n        }\n\n        vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -rotateZ);\n        current.x += sizeAndOffset.z * 2.0 / resolution.x * scale / pixelSize + pixelOffsetX / resolution.x;\n        current.y += sizeAndOffset.w * 2.0 / resolution.y * scale / pixelSize + pixelOffsetY / resolution.y;\n        gl_Position = vec4(current, 1.0);\n\n        gl_Position *= w;\n    }\n\n    #ifdef MVT_ENABLE_FADE\n        float fadeDiff = (elapsedTime - fadeSince) / fadeDuration;\n        if (fadeOpacity > 2.0) {\n            fadeDiff = clamp(fadeDiff, 0.0, 1.0);\n            vFadeOpacity = fadeOpacity - fadeDiff - 2.0;\n            vFadeOpacity = vFadeOpacity * vFadeOpacity;\n        } else {\n            vFadeOpacity = fadeOpacity + fadeDiff;\n            vFadeOpacity = sqrt(vFadeOpacity);\n        }\n        vFadeOpacity = clamp(vFadeOpacity, 0.0, 1.0);\n    #endif\n\n    vStrokeStyle = strokeStyle;\n    vFillStyle = fillStyle;\n\n    vFontSize = sizeAndOffset.y;\n\n    #include <logdepthbuf_vertex>\n    // gl_PointSize = size * pixelRatio;\n    // vSize = size;\n    // vOffset = offset;\n}",fragmentShader$2="#define GLSLIFY 1\n#include <common>\n\n#define SDF_BUFFER 6.0\n#define SDF_PX 8.0\n\nuniform sampler2D map;\nuniform vec4 backgroundColor;\nuniform float opacity;\nuniform float lineHeight;\nuniform vec3 color;\nuniform float sdfBuffer;\nuniform float pixelRatio;\nuniform float isHalo;\nvarying vec2 vUv;\n\nvarying vec4 vStrokeStyle;\nvarying vec3 vFillStyle;\nvarying float vgamma_scale;\nvarying float vFontSize;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\n#ifdef MVT_ENABLE_FADE\n    varying float vFadeOpacity;\n#endif\nvoid main() {\n    #include <logdepthbuf_fragment>\n\n    float fontScale = vFontSize / 24.0;\n    float gamma = (0.105 / pixelRatio) / fontScale;\n    float buff = (256.0 - 64.0) / 256.0;\n\n    vec3 outColor = vFillStyle;\n\n    if (isHalo > 0.0) {\n        if (vStrokeStyle.w > 0.0) {\n          outColor = vStrokeStyle.xyz;\n          buff = (SDF_BUFFER - vStrokeStyle.w / fontScale) / SDF_PX;\n        }\n    }\n\n    float distance = texture2D(map, vec2(vUv.x, vUv.y)).r;\n    float alpha = smoothstep(buff - gamma, buff + gamma, distance);\n\n    alpha = clamp(alpha * 1.5, 0.0, 1.0);\n\n    gl_FragColor = vec4(outColor, alpha);\n\n    #ifdef MVT_ENABLE_FADE\n        gl_FragColor.a *= vFadeOpacity;\n    #endif\n    \n    #include <mvt_selective_fragment> \n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}",uniforms$2=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,emissiveUniforms,{map:{value:null},pixelRatio:{value:1},lineHeight:{value:14},pixelOffsetX:{value:0},pixelOffsetY:{value:0},positionOffsetX:{value:0},positionOffsetZ:{value:0},positionOffsetY:{value:0},backgroundColor:{value:[1,1,0,0]},uFlat:{value:!1},opacity:{value:1},isEmissive:{value:!1},uRotateZ:{value:0},keepSize:{value:!0},outlineBuffer:{value:0},outlineColor:{value:new three.Color(0)},color:{value:new three.Color(16777215)},sdfBuffer:{value:.75},gamma:{value:.1},isHalo:{value:0},fadeDuration:{value:300}}]);class SDFTextMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="SDFTextMaterial",this.vertexShader=vertexShader$2,this.fragmentShader=fragmentShader$2,this.isSDFTextMaterial=!0,this.transparent=!0,this.depthTest=!1,this.depthWrite=!1,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$2)),defineMaterialSelectiveProperties(this),defineMaterialKeepSizeProperties(this),defineMaterialNormalProperties(this,["lineHeight","pixelRatio","map","pixelOffsetX","pixelOffsetY","positionOffsetX","positionOffsetY","positionOffsetZ","backgroundColor","resolution","opacity","isEmissive","isHalo","fadeDuration"]),defineMaterialAliasProperties(this,[["flat","uFlat"],["rotateZ","uRotateZ"]]),defineMaterialBoolDefineProperties(this,[["vertexRotateZs","MVT_USE_VERTEX_ROTATEZ"],["isGlobe","IS_GLOBE"],["alignRotate","IS_ALIGN_ROTATE"],["enableFade","MVT_ENABLE_FADE"]]),defineMaterialEmissiveProperties(this),defineMaterialColorProperties(this,["color"]),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}}class GeoGroup extends GeoObject{constructor(){super(...arguments),__publicField(this,"isGroup",!0)}}let curStyleId;const TEXT_ALIGN={center:0,left:1,right:-1},getPixelSize=(e,t,i)=>.2*Math.tan(t/2)*e/i*10,SDF_SCALE=2,fontSettings={fontSize:24*SDF_SCALE,buffer:3*SDF_SCALE,radius:8*SDF_SCALE},positionScratch$1=new three.Vector3,defaultTextStyle={fontSize:16,fontWeight:"400",fillStyle:[1,1,0],strokeStyle:[0,0,0],lineWidth:0};class SDFText extends GeoGroup{constructor(e){super(e),__publicField(this,"frustumCulled",!0),__publicField(this,"_needsUpdate",!1),__publicField(this,"_enableFade",!1),__publicField(this,"texture",null),__publicField(this,"_padding",[0,0]),__publicField(this,"_characterSet",getDefaultCharacterSet()),__publicField(this,"_collisionBoxCache",{}),__publicField(this,"_sdfTextureNeedUpdate",!1),__publicField(this,"updateRenderingData",(()=>{const[e,t]=this.material.resolution||[],i=this.engine.map.isGlobe;let n=new three.Matrix4;if(isNaN(e)||e<=0||isNaN(t)||t<=0)return void console.warn("resolution is invalid");const r=[],s=[],a=[],o=[],l=[],c=[],h=[],u=[],d=[],p=[],m=[],f=[],g=[],{mapping:_,width:A,height:v}=this.fontAtalasManager.atlas||{};let y=[0],x=0,b=null;for(let C=0;C<this.cachedData.length;C++){b=this.cachedData[C];const e=b.position;b.index;const t=b.text,S=b.textStyle,{fontSize:T=this._fontSize,fontWeight:E=this._fontWeight,lineWidth:M=this._lineWidth,strokeStyle:w=this._strokeStyle,fillStyle:I=this._fillStyle,rotateZ:P=0,hOffset:R=0,vOffset:B=0,offset:D=[0,0]}=S||{},F=Array.from(t).map((e=>e+E)),O=this._letterSpacing*this._fontSettings.fontSize,{x:L,y:N,rowWidth:V,rowNum:U,heightSize:k,textHeights:G,size:[z,j]}=transformParagraph(t,F,1,"break-word",-1*T,_,O),Q=L.length;x+=y[C];const H=Array.from(t);let $=0,W=0;const q=k/2;for(let y=0;y<Q;y++){const t=H[y];if("\\"===t)continue;const S=_[t+E];if(!S)return;if(i){n=Transforms.eastNorthUpToFixedFrame(positionScratch$1.fromArray(e),null,n),n.elements[12]=0,n.elements[13]=0,n.elements[14]=0;for(let e=0;e<4;e++)for(let t=0;t<16;t++)u.push(n.elements[t])}if(a.push(0,1,2,3),this.alignRotate){const e=G[y],t=W+e/2-q;W+=e,m.push(t,t,t,t)}const C=4*(x+$);o.push(C,C+2,C+1,C,C+3,C+2),r.push(...e,...e,...e,...e);let{x:F,y:O,width:k,height:Q}=S;k+=2*this._fontSettings.buffer,s.push(F,O,k,Q,F,O,k,Q,F,O,k,Q,F,O,k,Q);const Y=F/A,X=O/v,Z=Y+k/A,K=X+Q/v;l.push(Y,K,Y,X,Z,X,Z,K);const J=(1-TEXT_ALIGN[this.textAlign])*(z-V[y])/2,ee=D[0]*T+R,te=D[1]*T+B,ie=-1*z/2+J+L[y]+ee,ne=j/U*(U-1)/2-N[y]+te,re=T*(Q/this._fontSettings.fontSize);if(p.push(re,T,ie,ne,re,T,ie,ne,re,T,ie,ne,re,T,ie,ne),c.push(w[0],w[1],w[2],M,w[0],w[1],w[2],M,w[0],w[1],w[2],M,w[0],w[1],w[2],M),h.push(I[0],I[1],I[2],I[0],I[1],I[2],I[0],I[1],I[2],I[0],I[1],I[2]),this.parameters.vertexRotateZs&&d.push(P,P,P,P),this._enableFade){const e=b.fadeOpacity||.001,t=b.fadeSince||0;f.push(e,e,e,e),g.push(t,t,t,t)}$++}y.push($)}const S=this.geometry;S.setAttribute("position",new three.Float32BufferAttribute(r,3)),S.setAttribute("pIndex",new three.Float32BufferAttribute(a,1)),S.setAttribute("sizeAndOffset",new three.Float32BufferAttribute(p,4)),S.setAttribute("iconFrame",new three.Float32BufferAttribute(s,4)),S.setAttribute("uv",new three.Float32BufferAttribute(l,2)),S.setAttribute("strokeStyle",new three.Float32BufferAttribute(c,4)),S.setAttribute("fillStyle",new three.Float32BufferAttribute(h,3)),this.alignRotate&&S.setAttribute("verticalOffsets",new three.Float32BufferAttribute(m,1)),i&&S.setAttribute("ecefMatrix",new three.Float32BufferAttribute(u,16)),this.parameters.vertexRotateZs&&S.setAttribute("aRotateZ",new three.Float32BufferAttribute(d,1)),this._enableFade&&(S.setAttribute("fadeOpacity",new three.Float32BufferAttribute(f,1)),S.setAttribute("fadeSince",new three.Float32BufferAttribute(g,1))),S.setIndex(o),S.computeBoundingSphere(),this.makeGeometryOffsetPosition(S,r),this.needsUpdate=!1,this._enableFade&&(this.material[0].fadeDuration=this._fadeData.fadeDuration,this.material[1].fadeDuration=this._fadeData.fadeDuration)})),__publicField(this,"getStrictStyleId",(e=>{if(this.parameters.vertexStyles){let{fontSize:t,fontWeight:i,lineWidth:n,fillStyle:r=[],strokeStyle:s=[]}=e;return`${t}_${i}_${n}_${r[0]}_${r[1]}_${r[2]}_${s[0]}_${s[1]}_${s[2]}`}return 0})),this.parameters=e,this._flat=defaultValue$1(this.parameters.flat,!1),this._fontSize=defaultValue$1(this.parameters.fontSize,defaultTextStyle.fontSize),this._fontWeight=defaultValue$1(this.parameters.fontWeight,defaultTextStyle.fontWeight),this._letterSpacing=defaultValue$1(this.parameters.letterSpacing,0);const t=defaultValue$1(this.parameters.fillStyle,defaultTextStyle.fillStyle);Array.isArray(t)?this._fillStyle=t:this._fillStyle=colorToArr4(t),this._lineWidth=defaultValue$1(this.parameters.lineWidth,defaultTextStyle.lineWidth),this.outlineWidth=defaultValue$1(this.parameters.lineWidth,defaultTextStyle.lineWidth);const i=defaultValue$1(this.parameters.strokeStyle,defaultTextStyle.strokeStyle);Array.isArray(i)?this._strokeStyle=i:this._strokeStyle=colorToArr4(i),this._fontFamily=defaultValue$1(this.parameters.fontFamily,"Microsoft Yahei"),this._padding=defaultValue$1(this.parameters.padding,[2,2]),this._margin=defaultValue$1(this.parameters.margin,[0,0]),this.textAlign=defaultValue$1(this.parameters.textAlign,"center"),this.alignRotate=defaultValue$1(this.parameters.alignRotate,!1),this._enableFade=defaultValue$1(this.parameters.enableFade,!1),this.cachedData=[],this.shouldUpdateRenderingData=!1,this.drawingData=[],this._fadeData=new FadeData;const n=this.canvas=document.createElement("canvas");n.width=n.height=1;const r=this.ctx=n.getContext("2d");r.textAlign="start",r.textBaseline="top",this.matrixAutoUpdate=!0}initObject(){const{fillStyle:e,strokeStyle:t,fontFamily:i,vertexStyles:n,...r}=this.parameters;this.geometry=new three.BufferGeometry(this.parameters);const s=new SDFTextMaterial(r);s.setCommonUniforms(this.engine.rendering.uniforms),s.isHalo=0,s.enableFade=this._enableFade;const a=new SDFTextMaterial(r);a.setCommonUniforms(this.engine.rendering.uniforms),a.isHalo=1,a.enableFade=this._enableFade,this.material=[s,a],this.defineMaterialProperties(["lineHeight","pixelRatio","map","pixelOffsetX","pixelOffsetY","positionOffsetX","positionOffsetY","positionOffsetZ","backgroundColor","resolution","opacity","flat","isGlobe","alignRotate"]),this.add(new three.Mesh(this.geometry,a)),this.add(new three.Mesh(this.geometry,s));const o=this.engine.map.isGlobe;this.material.isGlobe=o;const l=`${this.fontFamily} ${this._fontWeight}`;this.fontStack=l;const c=new FontAtlasManager;this.fontAtalasManager=c}onBeforeSceneRender(e,t,i,n){super.onBeforeSceneRender(e,t,i,n),this._enableFade&&!this._fadeData.isStable(n.elapsedTime)&&e.requestRender()}update(){this.updateRenderingData()}updateSdfTexture(){if(this._sdfTextureNeedUpdate){this._fontSettings={fontFamily:this._fontFamily,fontWeight:"400",characterSet:this._characterSet,sdf:!0,...fontSettings},this.fontAtalasManager.setProps(this._fontSettings);const{textureData:e,width:t,height:i}=this.fontAtalasManager.atlas;if(!this.texture){const e=new Uint8Array(t*i);this.texture=new three.DataTexture(e,t,i),this.texture.minFilter=this.texture.magFilter=three.LinearFilter,this.texture.format=three.RedFormat}this.texture.image.data.set(e),this.texture.needsUpdate=!0,this.material.map=this.texture,this._sdfTextureNeedUpdate=!1}}_updateData(){this._enableCollision&&this._collisionData?this.cachedData=this._collisionData:this.cachedData=this.dataSource.userData.map((e=>{let t=this.collisionTest(e);return{...e,w:t.width,h:t.height}})),this._enableFade&&(this._fadeData.update(this.cachedData,this.engine.rendering.uniforms.elapsedTime.value),this.cachedData=this._fadeData.data);let e={};this.fontAtalasManager&&this.fontAtalasManager.mapping&&(e=this.fontAtalasManager.mapping);let t=new Map,i=!1;const n=this.cachedData,r=n.length;for(let s=0;s<r;s++){const r=n[s],a=r.text,o=r.textStyle||{},l={fontSize:defaultValue$1(o.fontSize,this._fontSize),fontWeight:defaultValue$1(o.fontWeight,this._fontWeight),lineWidth:defaultValue$1(o.lineWidth,this._lineWidth),fillStyle:defaultValue$1(o.fillStyle,this._fillStyle),strokeStyle:defaultValue$1(o.strokeStyle,this._strokeStyle)},c=Array.from(a);for(let n=0,s=c.length;n<s;n++){const r=c[n],s=r+l.fontWeight;t.set(s,{char:r,textStyle:l}),e[s]||(i=!0)}}i&&(this._sdfTextureNeedUpdate=!0,this._characterSet=t.values()),this.updateSdfTexture(this._characterSet),this.update()}_setupCanvas(e,t){e.save(),e.scale(t,t),e.textBaseline="top"}_calculateTransform(e,t){return this.engine.map.isGlobe?(t||(t=new three.Matrix4),Transforms.eastNorthUpToFixedFrame(positionScratch$1.fromArray(e),null,t),t.extractRotation(t),t):defaultValue$1.EMPTY_MAT4}_processTextStyle(e={}){return{fontSize:defaultValue$1(e.fontSize,this._fontSize),fontWeight:defaultValue$1(e.fontWeight,this._fontWeight),lineWidth:defaultValue$1(e.lineWidth,this._lineWidth),fillStyle:defaultValue$1(e.fillStyle,this._fillStyle),strokeStyle:defaultValue$1(e.strokeStyle,this._strokeStyle),rotateZ:defaultValue$1(e.rotateZ,0)}}_generateCacheName(e,t){let i="";if(this._flat){i+=e.position.join("_")}if(this.parameters.vertexStyles){const{fontWeight:n,fontSize:r,lineWidth:s}=t;i+=`${e.text}_${r}_${n}_${s}`}else i+=`${e.text}_${this._fontSize}`;return i}_calculateRotation(e,t,i){const n=new three.Matrix4;n.multiplyMatrices(e,t);const r=n.elements[0],s=n.elements[1];return Math.sin(i)*-s+Math.cos(i)*r}_calculateCharInfo(e,t,i,n,r,s){const a=t.measureText(e).width;return{char:e,width:a+2*s[0],height:i,offsetX:n+a/2,offsetY:r}}_calculatePixelSize(e,t){const i=this._rendering.renderState.cameraOffset;t.sub(i);const n=e.position.distanceTo(t),r=e.fov*Math.PI/180,s=this._rendering.resolution.y;return getPixelSize(n,r,s)}_processTextLayout(e,t,i){const n=this.ctx,r=this._padding,s=String(e).split("\\"),a=-(t*s.length)/2;return s.map(((e,i)=>{const s=[];let o=0;for(let r=0;r<e.length;r++){const l=e[r],c=n.measureText(l).width;s.push({char:l,width:c,height:t,offsetX:0,offsetY:-(a+t/2+i*t)}),o+=c}let l=-o/2;for(let t=0;t<s.length;t++){const e=s[t];l+=e.width/2,e.offsetX=l,l+=e.width/2,e.width+=2*r[0]}return s}))}_applyRotateZ(e,t,i){const n=this.engine.camera.matrixWorld;return this._calculateRotation(n,i,t)<0&&(t+=Math.PI),e.map((e=>{const i=e.offsetX,n=e.offsetY;return{...e,offsetX:i*Math.cos(t)-n*Math.sin(t),offsetY:i*Math.sin(t)+n*Math.cos(t)}}))}collisionTest(e){const t=this.ctx,i=this.engine.rendering.pixelRatio,n=this._fontSize,r=this._fontFamily,s=this._padding,a=this._processTextStyle(e.textStyle);this._setupCanvas(t,i);const o=this._generateCacheName(e,a);if(this._collisionBoxCache[o]){const e=this._collisionBoxCache[o],t=e.chars;if(t){const i=e.rotationMatrix,n=this._applyRotateZ(t,a.rotateZ,i);return{...this._collisionBoxCache[o],chars:n}}return e}let l=n;const c=this.getStrictStyleId(a);if(c===curStyleId){let{fontWeight:e,fontSize:i,lineWidth:n}=a;t.font=e>=10&&e%10==0?10*e+" "+i+"px "+r:i+"px "+r,l=i,n>0&&(t.lineWidth=n)}else t.font=n+"px "+r,curStyleId=c;if(this._flat){const t=this._calculateTransform(e.position),i=this._processTextLayout(e.text,l,a).flat();this._collisionBoxCache[o]={chars:i,rotationMatrix:t};return{chars:this._applyRotateZ(i,a.rotateZ,t),rotationMatrix:t}}let h=String(e.text).split("\\");const u=h.map((e=>t.measureText(e).width));let d=Math.max(...u),p=l*h.length;const m=d+2*s[0],f=p+2*s[1];return t.restore(),this._collisionBoxCache[o]={width:m,height:f},{width:m,height:f}}onDispose(){this.texture&&this.texture.dispose()}get needsUpdate(){return this._needsUpdate}set needsUpdate(e){this._needsUpdate=e}set fontSize(e){this._fontSize!==e&&(this._fontSize=e,this._collisionBoxCache={},this._sdfTextureNeedUpdate=!0)}get fontSize(){return this._fontSize}set fontFamily(e){this._fontFamily!==e&&(this._fontFamily=e,this._collisionBoxCache={},this._sdfTextureNeedUpdate=!0)}get fontFamily(){return this._fontFamily}set fillStyle(e){this._fillStyle=e}get fillStyle(){return this._fillStyle}set padding(e){this._padding!==e&&(this._padding=e,this._collisionBoxCache={})}get padding(){return this._padding}set strokeStyle(e){this._shouldStroke=!!e,this._strokeStyle=e}get strokeStyle(){return this._strokeStyle}get enableFade(){return this._enableFade}set enableFade(e){this._enableFade=e,this.material[0].enableFade=e,this.material[1].enableFade=e}defineMaterialProperties(e=[]){for(let t=0;t<e.length;t++){const i=e[t];Object.defineProperty(this.material,i,{get:function(){return this&&this[0][i]},set:function(e){this.forEach((t=>{t[i]=e}))}})}this.defineMaterialProxyProperties(e)}}class GeoLine extends GeoObject{constructor(){super(...arguments),__publicField(this,"isLine",!0),__publicField(this,"isLineSegments",!0)}}class SparkGeometry extends three.BufferGeometry{constructor(e){super(e),this.parameters=e}setData(e){const{vertexColors:t,vertexHeights:i}=this.parameters,{aPositions:n,indices:r,aColors:s,aHeights:a,aLengths:o}=e;this.setAttribute("position",new three.Float32BufferAttribute(n,3)),this.setAttribute("aLength",new three.Float32BufferAttribute(o,1)),t&&this.setAttribute("aColor",new three.Float32BufferAttribute(s,4)),i&&this.setAttribute("aHeight",new three.Float32BufferAttribute(a,1)),this.setIndex(r)}}const vertexShader$1="#define GLSLIFY 1\n#include <common>\n\nattribute float aLength;\n\nuniform float elapsedTime;\nuniform float tailLength;\nuniform float speed;\nuniform float idle;\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n#else\n    uniform vec3 color;\n#endif\n\n#ifdef MVT_USE_VERTEX_HEIGHT\n    attribute float aHeight;\n#else\n    uniform float height;\n#endif\n\nvarying float vOpacity;\nvarying vec4 vColor;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n    #include <mvt_selective_vertex>\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #else\n        vColor = vec4(color, 1.0);\n    #endif\n\n    #include <begin_vertex>\n    #include <project_vertex>\n\n    #ifdef MVT_USE_VERTEX_HEIGHT\n        float total = aHeight + tailLength;\n    #else\n        float total = height + tailLength;\n    #endif\n    float currentHeight = mod(elapsedTime * speed, total + idle * speed);\n    vOpacity = (aLength - (currentHeight - tailLength)) / tailLength;\n    // vOpacity = 1.;\n\n    #include <logdepthbuf_vertex>\n}",fragmentShader$1="#define GLSLIFY 1\n#include <common>\n\nvarying vec4 vColor;\nvarying float vOpacity;\nuniform float opacity;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n    if (vOpacity > 1.0 || vOpacity < 0.0) {\n        discard;\n    }\n    gl_FragColor = vec4(vColor.rgb, vColor.a * vOpacity);\n    gl_FragColor.a *= opacity;\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <colorspace_fragment>\n}\n",uniforms$1=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,emissiveUniforms,{isEmissive:{value:!1},color:{value:[1,1,0]},height:{value:100},vertexColors:{value:!1},vertexHeights:{value:!1},tailLength:{value:50},speed:{value:1},opacity:{value:1},idle:{value:2e3}}]);class SparkMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="SparkMaterial",this.isSparkMaterial=!0,this.vertexShader=vertexShader$1,this.fragmentShader=fragmentShader$1,this.transparent=!0,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms$1)),defineMaterialSelectiveProperties(this),defineMaterialNormalProperties(this,["isEmissive","height","tailLength","speed","idle","opacity"]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["vertexHeights","MVT_USE_VERTEX_HEIGHT"]]),defineMaterialEmissiveProperties(this),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}}const positionScratch=new three.Vector3,surfaceNormalScratch=new three.Vector3;class Spark extends GeoLine{constructor(e){super(e),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"color"),__publicField(this,"vertexColors"),__publicField(this,"height"),__publicField(this,"vertexHeights"),__publicField(this,"speed"),__publicField(this,"tailLength"),__publicField(this,"idle"),__publicField(this,"emissive"),this.parameters=e,this.defineMaterialProxyProperties(["color","height","tailLength","speed","idle","emissive","vertexColors","vertexHeights"])}getDefaultParams(){return{height:100}}initObject(){this.geometry=new SparkGeometry(this.parameters),this.material=new SparkMaterial(this.parameters),this.material.setCommonUniforms(this.engine.rendering.uniforms)}_updateData(){const e=this.engine.map.isGlobe,t=this.dataSource.data,i=[],n=[],r=[],s=[],a=[];for(let o=0;o<t.position.length;o++){let l=t.position[o];if(i.push(l[0],l[1],l[2]),e){this.engine.map.map._ellipsoid.geodeticSurfaceNormal(positionScratch.fromArray(l),surfaceNormalScratch)}if(this.parameters.vertexHeights&&t.height){if(e){const e=surfaceNormalScratch.multiplyScalar(t.height[o]);i.push(l[0]+e.x,l[1]+e.y,l[2]+e.z)}else i.push(l[0],l[1],l[2]+t.height[o]);r.push(t.height[o],t.height[o]),s.push(0,t.height[o])}else{if(e){const e=surfaceNormalScratch.multiplyScalar(t.height[o]);i.push(l[0]+e.x,l[1]+e.y,l[2]+e.z)}else i.push(l[0],l[1],l[2]+this.parameters.height);s.push(0,this.parameters.height)}if(this.parameters.vertexColors&&t.color){let e=colorToArr4(t.color[o]);n.push(e[0],e[1],e[2],e[3],e[0],e[1],e[2],e[3])}a.push(2*o,2*o+1)}this.geometry.setData({aPositions:i,aColors:n,aHeights:r,aLengths:s,indices:a}),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,i),this.needsUpdate=!1}}const scaleFirst=new three.Vector3,carto1=new three.Vector3,cartesian=new three.Vector3,tempTrans=new three.Vector3,lastPoint=new three.Vector3,p0Scratch=new three.Vector3,p1Scratch$1=new three.Vector3;function numberOfPoints(e,t,i){let n;return n=e.isVector3?e.distanceTo(t):getDistance(e,t),Math.ceil(n/i)}const cartoScratch=new three.Vector3,cartesianScratch=new three.Vector3;function extractHeights(e,t){const i=e.length,n=new Array(i);for(let r=0;r<i;r++)cartesianScratch.fromArray(e[r]),n[r]=t.cartesianToCartographic(cartesianScratch,cartoScratch).z;return n}class SimpleLineGeometry extends three.BufferGeometry{constructor(e){super(e),this._granularity=e.granularity||CesiumMath.RADIANS_PER_DEGREE,this._height=e.height||0,this.parameters=e}setData(e){this._needsUpdate=!0;this.engine.map.isGlobe?this.updateGeometry3D(e):this.updateGeometryColumbus(e),this._needsUpdate=!1}updateGeometryColumbus(e){const{vertexColors:t}=this.parameters,i=[],n=[],r=[],s=[];let a=0;for(let o=0;o<e.position.length;o++){const l=e.position[o],c=e.index[o];for(let h=0;h<l.length-1;h++){const u=l[h],d=l[h+1];if(i.push(u[0],u[1],u[2],d[0],d[1],d[2]),s.push(a,a+1),n.push(c,c),t&&e.color){let t=colorToArr4(e.color[o]);r.push(t[0],t[1],t[2],t[3]),r.push(t[0],t[1],t[2],t[3])}a+=2}}this.cachedPositions=i,this.setAttribute("position",new three.Float32BufferAttribute(i,3)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(n,1)),t&&this.setAttribute("color",new three.Float32BufferAttribute(r,4)),this.setIndex(s)}updateGeometry3D(e){const{vertexColors:t}=this.parameters,i=[],n=[],r=[],s=[];let a=0;const o=this._granularity,l=this.engine.map.map.ellipsoid||Ellipsoid.WGS84,c=CesiumMath.chordLength(o,l.maximumRadius);for(let h=0;h<e.position.length;h++){const o=e.position[h],u=e.index[h],d=e.color&&e.color[h],p=extractHeights(o,l).map((e=>e+this._height)),m=this.generateArc({positions:o,minDistance:c,ellipsoid:l,height:p}),f=m.length/3;for(let e=0;e<f-1;e++){if(i.push(m[3*e],m[3*e+1],m[3*e+2],m[3*(e+1)],m[3*(e+1)+1],m[3*(e+1)+2]),n.push(u,u),s.push(a,a+1),t&&d){let e=colorToArr4(d);r.push(e[0],e[1],e[2],e[3]),r.push(e[0],e[1],e[2],e[3])}a+=2}}this.cachedPositions=i,this.setAttribute("position",new three.Float32BufferAttribute(i,3)),this.setAttribute("objectIndex",new three.Float32BufferAttribute(n,1)),t&&this.setAttribute("color",new three.Float32BufferAttribute(r,4)),this.setIndex(s)}generateArc(e){e||(e={});const t=e.positions,i=t.length,n=e.ellipsoid||Ellipsoid.WGS84;let r=e.height||0;const s=Array.isArray(r);if(i<1)return[];if(1===i){tempTrans.fromArray(t[0]);const e=n.scaleToGeodeticSurface(tempTrans,scaleFirst);if(r=s?r[0]:r,0!==r){const t=n.geodeticSurfaceNormal(e,cartesian);Cartesian3.multiplyByScalar(t,r,t),Cartesian3.add(e,t,e)}return[e.x,e.y,e.z]}let a=e.minDistance;defined$2(a)||(a=CesiumMath.chordLength(this._granularity,n.maximumRadius));let o,l=0;for(let p=0;p<i-1;p++)l+=numberOfPoints(t[p],t[p+1],a);const c=new Array(3*(l+1));let h=0;const u=new three.Vector3;for(o=0;o<i-1;o++){p0Scratch.fromArray(t[o]),p1Scratch$1.fromArray(t[o+1]),u.crossVectors(p0Scratch,p1Scratch$1).normalize();const e=s?r[o]:r,i=s?r[o+1]:r;h=generateCartesianArc(p0Scratch,p1Scratch$1,a,n,e,i,c,h)}lastPoint.set(...t[i-1]);const d=n.cartesianToCartographic(lastPoint,carto1);d.z=s?r[i-1]:r;return n.cartographicToCartesian(d,cartesian).toArray(c,h),h+=3,c}}class SimpleLine extends GeoLine{constructor(e){super(e),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"color"),this.parameters=e,this.defineGeometryProxyProperties(["granularity"]),this.defineMaterialColorProxyProperties(["color"])}initObject(){this.geometry=new SimpleLineGeometry(this.parameters),this.geometry.engine=this.engine,this.material=new three.LineBasicMaterial(this.parameters)}_updateData(){const e=this.dataSource.data;this.geometry.setData(e),this.geometry.computeBoundingSphere(),this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.needsUpdate=!1}}class FatLine extends Polyline{constructor(e){console.warn("FatLine is deprecated, use Polyline with flat=true instead."),super({...e,flat:!0})}}const distanceScratch=new three.Vector3,p1Scratch=new three.Vector3,p2Scratch=new three.Vector3,scaleToGeodeticHeightN1=new three.Vector3,scaleToGeodeticHeightN2=new three.Vector3;new three.Vector3;const scaleToGeodeticHeightP2=new three.Vector3,scratchCartesian3Position1=new three.Vector3,scratchCartesian3Position4=new three.Vector3,createGeometryFromPositionsExtrudedPositions=[],getPointAtDistance=(e,t,i,n)=>(Cartesian3.subtract(t,e,distanceScratch),Cartesian3.multiplyByScalar(distanceScratch,i/n,distanceScratch),Cartesian3.add(e,distanceScratch,distanceScratch),[distanceScratch.x,distanceScratch.y,distanceScratch.z]),subdivideHeightsScratchArray=[],subdivideHeights=(e,t,i)=>{const n=subdivideHeightsScratchArray;n.length=e;let r=0;if(t===i){for(r=0;r<e;r++)n[r]=t;return n}const s=(i-t)/e;for(let a=0;a<e;a++){const e=t+a*s;n[a]=e}return n},subdivideLineCount=(e,t,i)=>{const n=e.distanceTo(t);return Math.ceil(n/i)};class WallGeometry extends three.BufferGeometry{constructor(e){super(),__publicField(this,"isWallGeometry",!0),__publicField(this,"_needsUpdate",!1),__publicField(this,"isClockWise",(e=>{let t=e.length,i=0;for(let n=t-1,r=0;r<t;n=r++)i+=e[n][0]*e[r][1]-e[r][0]*e[n][1];return i<0})),__publicField(this,"subdivideLine",((e,t,i,n,r,s)=>{const a=subdivideLineCount(e,t,i),o=e.distanceTo(t),l=o/a;r||(r=[]),s||(s=[]);const c=new three.Vector3,h=new three.Vector3,u=n.cartesianToCartographic(e,h).z,d=n.cartesianToCartographic(t,h).z,p=subdivideHeights(a,u,d),m=scaleToGeodeticHeightN1;let f=scaleToGeodeticHeightN2,g=scaleToGeodeticHeightP2,_=0;for(let A=0;A<a;A++){const i=c.fromArray(getPointAtDistance(e,t,l*A,o));n.geodeticSurfaceNormal(i,m),g=n.scaleToGeodeticSurface(i,g),f=Cartesian3.multiplyByScalar(m,p[A],f),f=Cartesian3.add(g,f,f),s[_]=f.x,s[_+1]=f.y,s[_+2]=f.z,f=Cartesian3.multiplyByScalar(m,p[A]+this._height,f),f=Cartesian3.add(g,f,f),r[_]=f.x,r[_+1]=f.y,r[_+2]=f.z,_+=3}return n.geodeticSurfaceNormal(t,m),g=n.scaleToGeodeticSurface(t,g),f=Cartesian3.multiplyByScalar(m,d,f),f=Cartesian3.add(g,f,f),s[_]=f.x,s[_+1]=f.y,s[_+2]=f.z,f=Cartesian3.multiplyByScalar(m,d+this._height,f),f=Cartesian3.add(g,f,f),r[_]=f.x,r[_+1]=f.y,r[_+2]=f.z,{topPositions:r,bottomPositions:s}})),this._height=e.height||100,this.parameters=e}setData(e){this._needsUpdate=!0,this.cachedData=e,this.updateGeometry()}computeWallGeometry3D(e,t,i,n){let r,s,a,o,l,c=e.length;const h=CesiumMath.chordLength(i,t.maximumRadius);let u=0;for(a=0;a<c-1;a++)u+=subdivideLineCount(e[a],e[(a+1)%c],h);const d=u+c-1;s=3*d,r=new Array(2*s);const p=[],m=[];for(a=0;a<c-1;a++){o=e[a],l=e[(a+1)%c];const{topPositions:i,bottomPositions:n}=this.subdivideLine(o,l,h,t);p.push(...n),m.push(...i)}r=[...p,...p],c=r.length;let f=[],g=0;for(c/=6,a=0;a<c-1;a++){const e=a,t=e+1,i=e+c,s=i+1;o=p1Scratch.fromArray(r,3*e),l=p2Scratch.fromArray(r,3*t),Cartesian3.equalsEpsilon(o,l,CesiumMath.EPSILON10,CesiumMath.EPSILON10)||(f[g++]=e+n,f[g++]=i+n,f[g++]=t+n,f[g++]=t+n,f[g++]=i+n,f[g++]=s+n)}r=[...m,...p],c=m.length/3;const _=[];_.length=r.length;const A=[];A.length=4*c;let v=new three.Vector3,y=new three.Vector3,x=new three.Vector3;new three.Vector3;let b=!0,S=new three.Vector3;const C=[];let T=0;for(a=0;a<d;a++){v.fromArray(m,3*a),x.fromArray(m,3*(a+1));let e=2*a,t=2*(a+s/3);void 0!==x.x?(C.push(v.distanceTo(x)),A[e]=T,A[e+1]=1,A[t]=T,A[t+1]=0,T+=C[a]):(A[e]=T,A[e+1]=1,A[t]=T,A[t+1]=0)}for(a=0;a<d;a++){if(v.fromArray(m,3*a),y.fromArray(p,3*a),x.fromArray(m,3*(a+1)),(Cartesian3.equalsEpsilon(v,x,CesiumMath.EPSILON10)||a===d-1)&&(b=!1),b){const e=Cartesian3.subtract(x,v,scratchCartesian3Position4),t=Cartesian3.subtract(y,v,scratchCartesian3Position1);S=Cartesian3.normalize(Cartesian3.cross(t,e,S),S),C.push(v.distanceTo(x))}let e=3*a,t=3*a+s;_[e]=S.x,_[e+1]=S.y,_[e+2]=S.z,_[t]=S.x,_[t+1]=S.y,_[t+2]=S.z,b=!0}return{edgePositions:r,edgeIndices:f,edgeNormals:_,edgeUvs:A,totalDistance:Array.from({length:2*d},(()=>T))}}updateGeometry3D(){let e=this.cachedData;const t=this.engine.map.map.ellipsoid||Ellipsoid.WGS84,i=[],n=[],r=[],s=[],a=[];let o=0,l=0,c=e.position.length;for(o=0;o<c;o++){const c=e.position[o];!this.parameters.vertexColors||colorToArr4(e.color[o]);const h=c.map((e=>(new three.Vector3).fromArray(e)));let u=EllipsoidTangentPlane.fromPoints(h,t).projectPointsOntoPlane(h,createGeometryFromPositionsExtrudedPositions);this.isClockWise(u.map((e=>e.toArray())))&&h.reverse();const d=CesiumMath.RADIANS_PER_DEGREE,{edgePositions:p,edgeIndices:m,edgeNormals:f,edgeUvs:g,totalDistance:_}=this.computeWallGeometry3D(h,t,d,l);i.push(...p),n.push(...m),r.push(...f),s.push(...g),a.push(..._),l+=p.length/3}this.cachedPositions=i,this.setAttribute("position",new three.Float32BufferAttribute(i,3)),this.setAttribute("normal",new three.Float32BufferAttribute(r,3)),this.setAttribute("uv",new three.Float32BufferAttribute(s,2)),this.setAttribute("totalDistance",new three.Float32BufferAttribute(a,1)),this.setIndex(n)}updateGeometryColumbus(){let e=this.cachedData;const t=[],i=[],n=[],r=[],s=[],a=[],o=[];for(let l=0;l<e.position.length;l++){const c=e.position[l];e.index[l];const h=this.parameters.vertexColors?colorToArr4(e.color[l]):[1,1,1,1],u=this.parameters.vertexHeights?e.height[l]:this._height;let d=0;const p=c.length;let m=t.length/3,f=0;for(let e=0;e<p;e++){const o=c[e],l=e<p-1?c[e+1]:null;if(l&&isPointEqual(o,l))continue;const g=[o[0],o[1],o[2]+u];if(f>0&&(d+=getDistance(c[e-1],o)),t.push(...o,...g),a.push(...h,...h),n.push(f/(p-1),f/(p-1)),s.push(d,d),i.push(d,0,d,1),f>0){const e=m+2*(f-1);r.push(e,e+1,e+2,e+2,e+1,e+3)}f++}for(let e=0;e<p;e++)o.push(d,d);m+=2*p}this.cachedPositions=t,this.setAttribute("position",new three.Float32BufferAttribute(t,3)),this.setAttribute("uv",new three.Float32BufferAttribute(i,2)),this.setAttribute("counter",new three.Float32BufferAttribute(n,1)),this.setAttribute("distances",new three.Float32BufferAttribute(s,1)),this.setAttribute("totalDistance",new three.Float32BufferAttribute(o,1)),this.parameters.vertexColors&&this.setAttribute("aColor",new three.Float32BufferAttribute(a,4)),this.setIndex(r)}updateGeometry(){this.engine.map.isGlobe?this.updateGeometry3D():this.updateGeometryColumbus(),this.computeBoundingSphere(),this._needsUpdate=!1}get needsUpdate(){return this._needsUpdate}set needsUpdate(e){this._needsUpdate=e}get height(){return this._height}set height(e){this._height=e}}const vertexShader="#define GLSLIFY 1\n#include <common>\n#include <bsdfs>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n#else\n    uniform vec3 color;\n#endif\n\nattribute float counter;\nattribute float totalDistance;\nattribute float distances;\n\nuniform float elapsedTime;\nuniform bool vertexColors;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vDistance;\nvarying float vTotalDistance;\n\nuniform vec2 mapScale;\n\n#ifdef USE_ANIMATION\nuniform float animationSpeed;\nuniform float animationTailType;\n// varying float vAnimationTailType;\nuniform float animationTailRatio;\nuniform float animationTailLength;\nuniform float animationIdle;\nvarying float vAnimationOpacity;\n#endif\n\nvoid main() {\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #else\n        vColor = vec4(color, 1.0);\n    #endif\n\n    vUV = uv / mapScale;\n    vCounter = counter;\n    vDistance = distances;\n    vTotalDistance = totalDistance;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    #ifdef USE_ANIMATION\n        if (animationTailType < 3.0) {\n            float tailLength = animationTailType == 1.0 ? totalDistance * animationTailRatio : animationTailLength;\n            float currentLength = mod(elapsedTime * animationSpeed, totalDistance + tailLength + animationIdle * animationSpeed);\n            vAnimationOpacity = (distances - (currentLength - tailLength)) / tailLength;\n        }\n        else if (animationTailType == 3.0) {\n            vAnimationOpacity = 1.0 - mod(elapsedTime * animationSpeed / 1000.0, 1.0) + uv.y;\n        } \n        // else if (animationTailType == 4.0) {\n        //     vAnimationTailType = animationTailType;\n        // }\n    #endif\n\n    #include <beginnormal_vertex>\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    #include <fog_vertex>\n\n    #include <logdepthbuf_vertex>\n}",fragmentShader="#define GLSLIFY 1\n#include <common>\n#include <bsdfs>\n#include <fog_pars_fragment>\n\n#include <logdepthbuf_pars_fragment>\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\nuniform sampler2D map;\nuniform bool useMap;\nuniform float minOpacity;\nuniform float maxOpacity;\nuniform float opacity;\nuniform float elapsedTime;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vDistance;\nvarying float vTotalDistance;\n\n#ifdef USE_ANIMATION\nuniform float animationRatio;\nuniform float animationBales;\nuniform float animationSpeed;\nvarying float vAnimationOpacity;\nuniform float animationTailType;\n#endif\n\nvoid main() {\n\n    vec4 c = vColor;\n\n    if(useMap) {\n        vec4 texture = texture2D(map, vec2(vUV.x / vTotalDistance, vUV.y));\n        c *= texture;\n    }\n\n    #ifdef USE_ANIMATION\n        if (vAnimationOpacity > 1.0 || vAnimationOpacity < 0.0) {\n            c.a = 0.0;\n        }\n\n        if(animationTailType == 4.) {\n            float ratio = animationRatio;\n            float bales = animationBales;\n            if(animationRatio > 1.) {\n                ratio = 1.;\n            }\n            if(animationRatio < .0) {\n                ratio = .0;\n            }\n            if(animationBales < 1.) {\n                bales = 1.;\n            }\n            if(mod((vUV.y - elapsedTime * animationSpeed * .0001), 1./bales) < ratio / bales) {\n                c.a = (1. - vUV.y) * maxOpacity;\n            } else {\n                c.a = minOpacity;\n            }\n        } else {\n            c.a *= vAnimationOpacity;\n        }\n    #endif\n\n    gl_FragColor = c;\n    gl_FragColor.a *= opacity;\n\n    if (maxOpacity > minOpacity) {\n        gl_FragColor.a = clamp(gl_FragColor.a, minOpacity, maxOpacity);\n    }\n    #ifdef OPAQUE\n        gl_FragColor.a = 1.0;\n    #endif\n\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n}",textureLoader=new three.TextureLoader,uniforms=three.UniformsUtils.merge([three.UniformsLib.fog,selectiveUniforms,emissiveUniforms,{map:{value:null},mapScale:{value:[1,1]},useMap:{value:!1},color:{value:[0,1,1]},minOpacity:{value:0},maxOpacity:{value:1},opacity:{value:1},vertexColors:{value:!1},elapsedTime:{value:0},enableAnimation:{value:!1},animationSpeed:{value:1},animationTailType:{value:3},animationTailRatio:{value:.2},animationTailLength:{value:100},animationIdle:{value:1e3},animationRatio:{value:.5},animationBales:{value:5},isEmissive:{value:!1}}]);class WallMaterial extends CommonShaderMaterial{constructor(e){super(),this.name="WallMaterial",this.isWallMaterial=!0,this.fog=!0,this.side=three.DoubleSide,this.forceSinglePass=!1,this.fragmentShader=fragmentShader,this.vertexShader=vertexShader,Object.assign(this.uniforms,three.UniformsUtils.clone(uniforms)),defineMaterialNormalProperties(this,["map","minOpacity","maxOpacity","opacity","elapsedTime","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle","animationBales","animationRatio","isEmissive"]),defineMaterialColorProperties(this,["color"]),defineMaterialBoolDefineProperties(this,[["vertexColors","MVT_USE_VERTEX_COLOR"],["enableAnimation","USE_ANIMATION"]]),defineMaterialEmissiveProperties(this),Object.defineProperties(this,{mapSrc:{get:function(){return this.uniforms.map.value},set:function(e){const t=this.mapSrc,i="url_map";if(this.userData[i]===e)return;if(t&&t.dispose(),!e)return this.uniforms.map.value=null,this.uniforms.useMap.value=!1,void delete this.userData[i];const n=textureLoader.load(e);n.wrapS=n.wrapT=three.RepeatWrapping,n.colorSpace=three.SRGBColorSpace,this.uniforms.map.value=n,this.userData[i]=e,this.uniforms.useMap.value=!0}},mapScale:{get:function(){return this.uniforms.map.value},set:function(e){this.uniforms.mapScale.value="number"==typeof e?[e,e]:e}}}),this.emissiveEnabled=!0,this.emissive=[0,0,0],this.setValues(e)}dispose(){this.uniforms.map.value&&this.uniforms.map.value.dispose(),super.dispose()}}class Wall extends GeoMesh{constructor(e){super(),__publicField(this,"geometry"),__publicField(this,"material"),__publicField(this,"height"),__publicField(this,"color"),__publicField(this,"vertexColors"),__publicField(this,"map"),__publicField(this,"opacity"),__publicField(this,"minOpacity"),__publicField(this,"maxOpacity"),__publicField(this,"enableAnimation"),__publicField(this,"animationSpeed"),__publicField(this,"animationTailType"),__publicField(this,"animationTailRatio"),__publicField(this,"animationTailLength"),__publicField(this,"animationIdle"),__publicField(this,"animationRatio"),__publicField(this,"animationBales"),this.parameters=e,this.defineGeometryUpdateProxyProperties(["height"]),this.defineMaterialProxyProperties(["color","vertexColors","emissive","map","mapScale","transparent","opacity","minOpacity","maxOpacity","enableAnimation","animationSpeed","animationTailType","animationTailRatio","animationTailLength","animationIdle","animationBales","animationRatio"])}getDefaultParams(){return{height:100}}initObject(){const{height:e,...t}=this.parameters;(this.geometry=new WallGeometry(this.parameters)).engine=this.engine;(this.material=new WallMaterial(t)).setCommonUniforms(this.engine.rendering.uniforms)}_updateData(){const e=this.dataSource.data;this.geometry.setData(e),this.geometry.computeBoundingSphere(),this.geometry.computeBoundingBox(),this.makeGeometryOffsetPosition(this.geometry,this.geometry.cachedPositions),this.needsUpdate=!1}}injectStyle(styleSheet),window.MAPVTHREE_VERSION="1.4.1",window._disable_hmt||(window._hmt=window._hmt||[],function(){let e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?1baab79677df9b34e5e6db4315726094";let t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()),exports.AnimationModel=AnimationModel,exports.Baidu09ImageryTileProvider=Baidu09ImageryTileProvider,exports.BaiduMapConfig=BaiduMapConfig,exports.BaiduTrafficTileProvider=BaiduTrafficTileProvider,exports.BaiduVectorTileProvider=BaiduVectorTileProvider,exports.BallonPoint=BallonPoint,exports.BingImageryTileProvider=BingImageryTileProvider,exports.CSVDataSource=CSVDataSource,exports.CesiumConfig=CesiumConfig,exports.CesiumTerrainTileProvider=CesiumTerrainTileProvider,exports.Circle=Circle,exports.ClusterPoint=ClusterPoint,exports.DOMOverlay=DOMOverlay,exports.DOMPoint=DOMPoint,exports.DataItem=DataItem,exports.DataSource=DataSource,exports.Default3DTiles=Default3DTiles,exports.DefaultSky=DefaultSky,exports.DynamicSky=DynamicSky,exports.DynamicWeather=DynamicWeather,exports.EffectModelPoint=EffectModelPoint,exports.EffectPoint=EffectPoint,exports.EmptySky=EmptySky,exports.Engine=Engine,exports.FastTileLoaderStrategy=FastTileLoaderStrategy,exports.FatLine=FatLine,exports.GEOMETRY_TYPE_LINE=GEOMETRY_TYPE_LINE,exports.GEOMETRY_TYPE_POINT=GEOMETRY_TYPE_POINT,exports.GEOMETRY_TYPE_POLYGON=GEOMETRY_TYPE_POLYGON,exports.GLTFLoader=GLTFLoader$1,exports.GeoInstancedMesh=GeoInstancedMesh,exports.GeoJSONDataSource=GeoJSONDataSource,exports.Heatmap=Heatmap,exports.Heatmap3D=Heatmap3D,exports.HierarchicalTileLoaderStrategy=HierarchicalTileLoaderStrategy,exports.Icon=Icon,exports.ImageryTileProvider=ImageryTileProvider,exports.JSONDataSource=JSONDataSource,exports.LODModel=LODModel,exports.Label=Label,exports.MapView=MapView,exports.MapboxConfig=MapboxConfig,exports.MapboxVectorTileProvider=MapboxVectorTileProvider,exports.Marker=Marker,exports.OSMImageryTileProvider=OSMImageryTileProvider,exports.ObjectTracker=ObjectTracker,exports.PROJECTION_BD_MERCATOR=PROJECTION_BD_MERCATOR,exports.PROJECTION_ECEF=PROJECTION_ECEF,exports.PROJECTION_EQUAL_EARTH=PROJECTION_EQUAL_EARTH,exports.PROJECTION_GEO=PROJECTION_GEO,exports.PROJECTION_SCREEN_PIXEL=PROJECTION_SCREEN_PIXEL,exports.PROJECTION_UTM=PROJECTION_UTM,exports.PROJECTION_WEB_MERCATOR=PROJECTION_WEB_MERCATOR,exports.PathTracker=PathTracker,exports.Pillar=Pillar,exports.PlaneTerrainTileProvider=PlaneTerrainTileProvider,exports.PointerLockControl=PointerLockControl,exports.Polygon=Polygon,exports.Polyline=Polyline,exports.Popup=Popup,exports.RENDER_STAGE_BLOOM=RENDER_STAGE_BLOOM,exports.RENDER_STAGE_FEATURES=RENDER_STAGE_FEATURES,exports.RENDER_STAGE_POSTPROCESSING=RENDER_STAGE_POSTPROCESSING,exports.RENDER_STAGE_PREPARE=RENDER_STAGE_PREPARE,exports.RENDER_STAGE_SCENE=RENDER_STAGE_SCENE,exports.RasterSurface=RasterSurface,exports.RotateTracker=RotateTracker,exports.SDFText=SDFText,exports.Services=index,exports.SimpleLine=SimpleLine,exports.SimpleModel=SimpleModel,exports.SimplePoint=SimplePoint,exports.Spark=Spark,exports.StadiaImageryTileProvider=StadiaImageryTileProvider,exports.StaticSky=StaticSky,exports.TerrainTileProvider=TerrainTileProvider,exports.Text=Text,exports.TiandituConfig=TiandituConfig,exports.TiandituImageryTileProvider=TiandituImageryTileProvider,exports.TileProvider=TileProvider,exports.VectorSurface=VectorSurface,exports.VectorTileProvider=VectorTileProvider,exports.WMSImageryTileProvider=WMSImageryTileProvider,exports.WMTSImageryTileProvider=WMTSImageryTileProvider,exports.Wall=Wall,exports.WaterMaterial=WaterMaterial,exports.XYZImageryTileProvider=XYZImageryTileProvider,exports.colorUtils=colorUtils,exports.geojsonUtils=geojsonUtils,exports.gltfLoader=gltfLoader,exports.mapViewConstants=constants,exports.modelUtils=model,exports.objectUtils=object$1,exports.requestUtils=request$1,exports.services=index,exports.urlUtils=urlUtils,Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
